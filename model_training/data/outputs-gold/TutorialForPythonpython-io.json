from typing import Any [EOL] import typing [EOL] import json [EOL] import websocket [EOL] [EOL] ws = websocket . create_connection ( [string] ) [EOL] try : [EOL] count = [number] [EOL] for message in ws : [EOL] if not ws . connected : [EOL] break [EOL] if count == [number] : [EOL] ws . send ( json . dumps ( { [string] : [string] } ) ) [EOL] print ( [string] ) [EOL] else : [EOL] count += [number] [EOL] print ( message ) [EOL] except Exception : [EOL] ws . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any , Union , Set , Dict [EOL] import asyncio [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] import datetime [EOL] import json [EOL] import websockets [EOL] from websockets . exceptions import ( ConnectionClosedError , ConnectionClosedOK , ConnectionClosed ) [EOL] [EOL] from logger import log [EOL] [EOL] ROOMS = { [string] : set ( ) } [EOL] HOST = [string] [EOL] PORT = [number] [EOL] [EOL] [EOL] async def notify_user ( websocket , path , message ) : [EOL] [docstring] [EOL] if ROOMS . get ( path ) : [EOL] message = json . dumps ( { [string] : [number] , [string] : [string] , [string] : message } ) [EOL] await websocket . send ( message ) [EOL] [EOL] [EOL] async def join_room ( websocket , path ) : [EOL] room = ROOMS . get ( path ) [EOL] if isinstance ( room , set ) : [EOL] room . add ( websocket ) [EOL] await notify_user ( websocket , path , [string] ) [EOL] return True [EOL] else : [EOL] await notify_user ( websocket , path , [string] ) [EOL] return False [EOL] [EOL] [EOL] async def leave_room ( websocket , path ) : [EOL] room = ROOMS . get ( path ) [EOL] if isinstance ( room , set ) : [EOL] if websocket in room : [EOL] room . remove ( websocket ) [EOL] log . info ( f" [string] { path }" ) [EOL] return True [EOL] else : [EOL] log . info ( f" [string] { path }" ) [EOL] return False [EOL] else : [EOL] log . info ( [string] ) [EOL] return False [EOL] [EOL] [EOL] async def send_time ( websocket ) : [EOL] while True : [EOL] now = datetime . datetime . utcnow ( ) . isoformat ( ) + [string] [EOL] data = { [string] : now , [string] : [string] , [string] : [number] } [EOL] await websocket . send ( json . dumps ( data ) ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] [EOL] async def listen_close ( websocket , task ) : [EOL] async for message in websocket : [EOL] if json . loads ( message ) . get ( [string] ) == [string] : [EOL] log . info ( [string] ) [EOL] break [EOL] try : [EOL] task . cancel ( ) [EOL] except Exception as e : [EOL] log . info ( f" [string] { type ( e ) } [string] { str ( e ) }" ) [EOL] else : [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] async def nowtime ( websocket , path ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] log . info ( path ) [EOL] is_in_room = await join_room ( websocket , path ) [EOL] if is_in_room : [EOL] task = loop . create_task ( send_time ( websocket ) ) [EOL] task . add_done_callback ( lambda x : log . info ( [string] ) ) [EOL] listener = loop . create_task ( listen_close ( websocket , task ) ) [EOL] try : [EOL] await task [EOL] except asyncio . CancelledError as ce : [EOL] log . info ( [string] ) [EOL] await websocket . send ( json . dumps ( { [string] : [string] } ) ) [EOL] except ConnectionClosedError as close_error : [EOL] log . info ( [string] ) [EOL] except ConnectionClosedOK as close_ok : [EOL] log . info ( [string] ) [EOL] except ConnectionClosed as close : [EOL] log . info ( [string] ) [EOL] except Exception as e : [EOL] raise e [EOL] finally : [EOL] listener . cancel ( ) [EOL] await leave_room ( websocket , path ) [EOL] [EOL] [EOL] asyncio . get_event_loop ( ) . run_until_complete ( websockets . serve ( nowtime , HOST , PORT ) ) [EOL] [EOL] log . info ( f" [string] { HOST } [string] { PORT }" ) [EOL] asyncio . get_event_loop ( ) . run_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import asyncio [EOL] import json [EOL] import websockets [EOL] [EOL] async def hello ( ) : [EOL] uri = [string] [EOL] async with websockets . connect ( uri ) as websocket : [EOL] count = [number] [EOL] async for message in websocket : [EOL] if websocket . closed : [EOL] break [EOL] if count == [number] : [EOL] await websocket . send ( json . dumps ( { [string] : [string] } ) ) [EOL] print ( [string] ) [EOL] [comment] [EOL] else : [EOL] count += [number] [EOL] print ( message ) [EOL] [EOL] [EOL] asyncio . get_event_loop ( ) . run_until_complete ( hello ( ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from app import app [EOL] import unittest [EOL] [EOL] class SanicTestCase ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] print ( [string] ) [EOL] self . app = app . test_client [EOL] def tearDown ( self ) : [EOL] print ( [string] ) [EOL] [EOL] def test_user ( self ) : [EOL] request , response = self . app . get ( [string] ) [EOL] assert [string] in response . json . keys ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any , Type , Union [EOL] import server [EOL] import typing [EOL] import 接口服务 [EOL] from sanic import Sanic [EOL] from sanic import Blueprint [EOL] from sanic . views import HTTPMethodView [EOL] from sanic . response import json as jsonify [EOL] from jsonschema import validate [EOL] [EOL] from functools import wraps [EOL] import time [EOL] [EOL] def print_time ( f ) : [EOL] @ wraps ( f ) async def decorated_function ( request , * args , ** kwargs ) : [EOL] start = time . time ( ) [EOL] response = await f ( request , * args , ** kwargs ) [EOL] end = time . time ( ) [EOL] spend = end - start [EOL] print ( f" [string] { spend } [string] " ) [EOL] return response [EOL] return decorated_function [EOL] [EOL] app = Sanic ( ) [EOL] api_user = Blueprint ( [string] ) [EOL] [EOL] User = [ ] [EOL] [EOL] User_Schema = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : True } } , [string] : [ [string] , [string] ] } [EOL] [EOL] [EOL] class UserIndexAPI ( HTTPMethodView ) : [EOL] @ print_time async def get ( self , request ) : [EOL] count = len ( User ) [EOL] result = { [string] : [string] , [string] : count , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] } [EOL] [EOL] return jsonify ( result , ensure_ascii = False ) [EOL] [EOL] async def post ( self , request ) : [EOL] insert = request . json [EOL] [EOL] try : [EOL] validate ( instance = insert , schema = User_Schema ) [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , [string] : str ( e ) } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] uid = User . append ( insert ) [EOL] return jsonify ( { [string] : [string] , [string] : uid } , ensure_ascii = False ) [EOL] [EOL] [EOL] class UserAPI ( HTTPMethodView ) : [EOL] [EOL] async def get ( self , request , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] if u : [EOL] return jsonify ( u , ensure_ascii = False ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] async def put ( self , request , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] if u : [EOL] insert = request . json [EOL] u . update ( insert ) [EOL] return jsonify ( { [string] : [string] } , ensure_ascii = False ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] async def delete ( self , request , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] if u : [EOL] User [ uid ] = None [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] [EOL] user_index_view = UserIndexAPI . as_view ( ) [EOL] user_view = UserAPI . as_view ( ) [EOL] [EOL] api_user . add_route ( user_index_view , [string] ) [EOL] api_user . add_route ( user_view , [string] ) [EOL] [EOL] [EOL] api_todo = Blueprint ( [string] ) [EOL] [EOL] Todo = { } [EOL] [EOL] Todo_Schema = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } } , [string] : [ [string] ] } [EOL] [EOL] [EOL] class TodoAPI ( HTTPMethodView ) : [EOL] decorators = [ print_time ] [EOL] async def get ( self , request , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] if u : [EOL] if Todo . get ( uid ) : [EOL] return jsonify ( { [string] : uid , [string] : Todo . get ( uid ) } , ensure_ascii = False ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] async def post ( self , request , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] if u : [EOL] insert = request . json [EOL] try : [EOL] validate ( instance = insert , schema = Todo_Schema ) [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , [string] : str ( e ) } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] Todo . get ( uid ) . append ( insert ) [EOL] return jsonify ( { [string] : [string] } , ensure_ascii = False ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] [EOL] todo_view = TodoAPI . as_view ( ) [EOL] api_todo . add_route ( todo_view , [string] ) [EOL] [EOL] api_v1 = Blueprint . group ( api_user , api_todo ) [EOL] [EOL] app . blueprint ( api_v1 , url_prefix = [string] ) [EOL] [EOL] @ app . listener ( [string] ) async def _before_server_start ( app , loop ) : [EOL] print ( [string] ) [EOL] [EOL] @ app . listener ( [string] ) async def _after_server_start ( app , loop ) : [EOL] print ( [string] ) [EOL] [EOL] @ app . listener ( [string] ) async def _before_server_stop ( app , loop ) : [EOL] print ( [string] ) [EOL] [EOL] @ app . listener ( [string] ) async def _after_server_stop ( app , loop ) : [EOL] print ( [string] ) [EOL] [EOL] @ app . middleware ( [string] ) async def print_on_request ( request ) : [EOL] print ( [string] ) [EOL] [EOL] @ app . middleware ( [string] ) async def print_on_response ( request , response ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( host = [string] , port = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Union , List , Dict [EOL] import typing [EOL] from sanic import Sanic [EOL] from sanic . views import HTTPMethodView [EOL] from sanic . response import json as jsonify [EOL] from jsonschema import validate [EOL] [EOL] app = Sanic ( ) [EOL] [EOL] User = [ ] [EOL] [EOL] User_Schema = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : True } } , [string] : [ [string] , [string] ] } [EOL] [EOL] [EOL] class UserIndexAPI ( HTTPMethodView ) : [EOL] [EOL] async def get ( self , request ) : [EOL] count = len ( User ) [EOL] result = { [string] : [string] , [string] : count , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] } [EOL] [EOL] return jsonify ( result , ensure_ascii = False ) [EOL] [EOL] async def post ( self , request ) : [EOL] insert = request . json [EOL] [EOL] try : [EOL] validate ( instance = insert , schema = User_Schema ) [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , [string] : str ( e ) } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] uid = User . append ( insert ) [EOL] return jsonify ( { [string] : [string] , [string] : uid } , ensure_ascii = False ) [EOL] [EOL] [EOL] class UserAPI ( HTTPMethodView ) : [EOL] [EOL] async def get ( self , request , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] if u : [EOL] return jsonify ( u , ensure_ascii = False ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] async def put ( self , request , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] if u : [EOL] insert = request . json [EOL] u . update ( insert ) [EOL] return jsonify ( { [string] : [string] } , ensure_ascii = False ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] async def delete ( self , request , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] else : [EOL] if u : [EOL] User [ uid ] = None [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } , ensure_ascii = False , status = [number] ) [EOL] [EOL] [EOL] user_index_view = UserIndexAPI . as_view ( ) [EOL] user_view = UserAPI . as_view ( ) [EOL] [EOL] [EOL] app . add_route ( user_index_view , [string] ) [EOL] app . add_route ( user_view , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( host = [string] , port = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any , Union , TextIO [EOL] import typing [EOL] import time [EOL] import sys [EOL] import logging [EOL] import sanic . log [EOL] import structlog [EOL] logging . Formatter . converter = time . gmtime [EOL] [EOL] [EOL] LOGGING_CONFIG_JSON = dict ( version = [number] , disable_existing_loggers = False , loggers = { [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] , [string] : True , [string] : [string] , } , [string] : { [string] : [string] , [string] : [ [string] ] , [string] : True , [string] : [string] , } , } , handlers = { [string] : { [string] : [string] , [string] : [string] , [string] : sys . stdout , } , [string] : { [string] : [string] , [string] : [string] , [string] : sys . stderr , } , [string] : { [string] : [string] , [string] : [string] , [string] : sys . stdout , } , } , formatters = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , } , ) [EOL] [EOL] [EOL] [comment] [EOL] structlog . configure ( processors = [ structlog . stdlib . filter_by_level , structlog . stdlib . add_logger_name , structlog . stdlib . add_log_level , structlog . stdlib . PositionalArgumentsFormatter ( ) , structlog . processors . TimeStamper ( fmt = [string] ) , structlog . processors . StackInfoRenderer ( ) , structlog . processors . format_exc_info , structlog . processors . StackInfoRenderer ( ) , structlog . processors . JSONRenderer ( ) ] , context_class = dict , logger_factory = structlog . stdlib . LoggerFactory ( ) , wrapper_class = structlog . stdlib . BoundLogger , cache_logger_on_first_use = True , ) [EOL] log = structlog . get_logger ( [string] ) [EOL] sanic . log . logger = log	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$
import builtins [EOL] from typing import Any , Union , List , Dict [EOL] import flask [EOL] import typing [EOL] from uuid import uuid4 [EOL] import json [EOL] import werkzeug [EOL] from flask import Flask , Blueprint , jsonify , request , after_this_request , g , current_app [EOL] from flask . views import MethodView [EOL] from jsonschema import validate [EOL] from flask_jsonifylog import JsonLogger [EOL] app = Flask ( __name__ ) [EOL] app . config [ [string] ] = False [EOL] JsonLogger ( app ) [EOL] api_v1 = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] User = [ ] [EOL] [EOL] User_Schema = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : True } } , [string] : [ [string] , [string] ] } [EOL] [EOL] [EOL] class UserIndexAPI ( MethodView ) : [EOL] [EOL] def get ( self ) : [EOL] [EOL] count = len ( User ) [EOL] result = { [string] : [string] , [string] : count , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] } [EOL] [EOL] return jsonify ( result ) [EOL] [EOL] def post ( self ) : [EOL] insert = request . json [EOL] [EOL] try : [EOL] validate ( instance = insert , schema = User_Schema ) [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , [string] : str ( e ) } ) , [number] [EOL] else : [EOL] uid = User . append ( insert ) [EOL] return jsonify ( { [string] : [string] , [string] : uid } ) [EOL] [EOL] [EOL] class UserAPI ( MethodView ) : [EOL] [EOL] def get ( self , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] else : [EOL] if u : [EOL] return jsonify ( u ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] def put ( self , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] else : [EOL] if u : [EOL] insert = request . json [EOL] u . update ( insert ) [EOL] return jsonify ( { [string] : [string] } ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] def delete ( self , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] else : [EOL] if u : [EOL] User [ uid ] = None [EOL] return jsonify ( { [string] : [string] , } ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] user_index_view = UserIndexAPI . as_view ( [string] ) [EOL] user_view = UserAPI . as_view ( [string] ) [EOL] [EOL] [EOL] api_v1 . add_url_rule ( [string] , view_func = user_index_view ) [EOL] api_v1 . add_url_rule ( [string] , view_func = user_view ) [EOL] [EOL] app . register_blueprint ( api_v1 , url_prefix = [string] ) [EOL] @ app . errorhandler ( werkzeug . exceptions . NotFound ) def handle_bad_request ( e ) : [EOL] return jsonify ( { [string] : [string] } ) , [number] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Dict , Any , Type , Union [EOL] import flask [EOL] import server [EOL] import typing [EOL] import 接口服务 [EOL] from flask import Flask , Blueprint , jsonify , request , after_this_request [EOL] from flask . views import MethodView [EOL] from jsonschema import validate [EOL] from functools import wraps [EOL] import time [EOL] [EOL] def print_time ( f ) : [EOL] @ wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] start = time . time ( ) [EOL] response = f ( * args , ** kwargs ) [EOL] end = time . time ( ) [EOL] spend = end - start [EOL] print ( f" [string] { spend } [string] " ) [EOL] return response [EOL] return decorated_function [EOL] app = Flask ( __name__ ) [EOL] app . config [ [string] ] = False [EOL] api_v1 = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] User = [ ] [EOL] [EOL] User_Schema = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : True } } , [string] : [ [string] , [string] ] } [EOL] [EOL] [EOL] class UserIndexAPI ( MethodView ) : [EOL] decorators = [ print_time ] [EOL] def get ( self ) : [EOL] @ after_this_request def _after_this_request ( response ) : [EOL] print ( [string] ) [EOL] return response [EOL] count = len ( User ) [EOL] result = { [string] : [string] , [string] : count , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] } [EOL] [EOL] return jsonify ( result ) [EOL] [EOL] def post ( self ) : [EOL] insert = request . json [EOL] [EOL] try : [EOL] validate ( instance = insert , schema = User_Schema ) [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , [string] : str ( e ) } ) , [number] [EOL] else : [EOL] uid = User . append ( insert ) [EOL] return jsonify ( { [string] : [string] , [string] : uid } ) [EOL] [EOL] [EOL] class UserAPI ( MethodView ) : [EOL] [EOL] def get ( self , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] else : [EOL] if u : [EOL] return jsonify ( u ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] def put ( self , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] else : [EOL] if u : [EOL] insert = request . json [EOL] u . update ( insert ) [EOL] return jsonify ( { [string] : [string] } ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] def delete ( self , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] else : [EOL] if u : [EOL] User [ uid ] = None [EOL] return jsonify ( { [string] : [string] , } ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] [EOL] @ app . before_first_request def _before_first_request ( ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] @ app . before_request def _before_request ( ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] @ app . after_request def _after_request ( response ) : [EOL] print ( f" [string] { response }" ) [EOL] return response [EOL] [EOL] [EOL] @ app . teardown_request def _teardown_request ( response ) : [EOL] print ( f" [string] { response }" ) [EOL] return response [EOL] [EOL] [EOL] @ api_v1 . before_request def _bp_before_request ( ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] @ api_v1 . teardown_request def _bp_teardown_request ( response ) : [EOL] print ( f" [string] { response }" ) [EOL] return response [EOL] [EOL] [EOL] @ api_v1 . after_request def _bp_after_request ( response ) : [EOL] print ( f" [string] { response }" ) [EOL] return response [EOL] [EOL] [EOL] user_index_view = UserIndexAPI . as_view ( [string] ) [EOL] user_view = UserAPI . as_view ( [string] ) [EOL] [EOL] [EOL] api_v1 . add_url_rule ( [string] , view_func = user_index_view ) [EOL] api_v1 . add_url_rule ( [string] , view_func = user_view ) [EOL] [EOL] app . register_blueprint ( api_v1 , url_prefix = [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Union , List , Dict [EOL] import flask [EOL] import typing [EOL] from uuid import uuid4 [EOL] import json [EOL] from flask import Flask , Blueprint , jsonify , request , after_this_request , g [EOL] from flask . views import MethodView [EOL] from jsonschema import validate [EOL] app = Flask ( __name__ ) [EOL] app . config [ [string] ] = False [EOL] api_v1 = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] User = [ ] [EOL] [EOL] User_Schema = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : True } } , [string] : [ [string] , [string] ] } [EOL] [EOL] [EOL] class UserIndexAPI ( MethodView ) : [EOL] [EOL] def get ( self ) : [EOL] count = len ( User ) [EOL] result = { [string] : [string] , [string] : count , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] } [EOL] [EOL] return jsonify ( result ) [EOL] [EOL] def post ( self ) : [EOL] insert = request . json [EOL] [EOL] try : [EOL] validate ( instance = insert , schema = User_Schema ) [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , [string] : str ( e ) } ) , [number] [EOL] else : [EOL] uid = User . append ( insert ) [EOL] return jsonify ( { [string] : [string] , [string] : uid } ) [EOL] [EOL] [EOL] class UserAPI ( MethodView ) : [EOL] [EOL] def get ( self , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] else : [EOL] if u : [EOL] return jsonify ( u ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] def put ( self , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] else : [EOL] if u : [EOL] insert = request . json [EOL] u . update ( insert ) [EOL] return jsonify ( { [string] : [string] } ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] def delete ( self , uid ) : [EOL] try : [EOL] u = User [ uid ] [EOL] except IndexError as dn : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] except Exception as e : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] else : [EOL] if u : [EOL] User [ uid ] = None [EOL] return jsonify ( { [string] : [string] , } ) [EOL] else : [EOL] return jsonify ( { [string] : [string] , } ) , [number] [EOL] [EOL] [EOL] @ app . before_request def _before_request ( ) : [EOL] g . uuid = str ( uuid4 ( ) ) [EOL] print ( f"{ g . uuid }" ) [EOL] [EOL] @ app . after_request def _after_request ( response ) : [EOL] data = response . get_json ( ) [EOL] data . update ( { [string] : g . uuid } ) [EOL] print ( f" [string] { g . uuid }" ) [EOL] return jsonify ( data ) [EOL] user_index_view = UserIndexAPI . as_view ( [string] ) [EOL] user_view = UserAPI . as_view ( [string] ) [EOL] [EOL] [EOL] api_v1 . add_url_rule ( [string] , view_func = user_index_view ) [EOL] api_v1 . add_url_rule ( [string] , view_func = user_view ) [EOL] [EOL] app . register_blueprint ( api_v1 , url_prefix = [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import json [EOL] import unittest [EOL] import app [EOL] class FlaskrTestCase ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] print ( [string] ) [EOL] self . app = app . app . test_client ( ) [EOL] def tearDown ( self ) : [EOL] print ( [string] ) [EOL] [EOL] def test_user ( self ) : [EOL] rv = self . app . get ( [string] ) [EOL] assert [string] in json . loads ( rv . data ) . keys ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from gevent import monkey ; monkey . patch_all ( ) [EOL] from gevent . pywsgi import WSGIServer [EOL] from app import app [EOL] import logging [EOL] [comment] [EOL] http_server = WSGIServer ( ( [string] , [number] ) , app , log = logging . getLogger ( [string] ) ) [EOL] http_server . serve_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] from aiogrpc import insecure_channel [EOL] from data_pb2_grpc import SquareServiceStub [EOL] from data_pb2 import Message [EOL] [EOL] url = [string] [EOL] [EOL] async def query ( ) : [EOL] async with insecure_channel ( url ) as conn : [EOL] client = SquareServiceStub ( channel = conn ) [EOL] result = await client . square ( Message ( message = [number] ) ) [EOL] print ( result ) [EOL] [EOL] [EOL] def main ( ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( query ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import grpc [EOL] from data_pb2_grpc import SquareServiceStub [EOL] from data_pb2 import Message [EOL] with open ( [string] , [string] ) as f : [EOL] trusted_certs = f . read ( ) [EOL] [EOL] url = [string] [EOL] [EOL] credentials = grpc . ssl_channel_credentials ( root_certificates = trusted_certs ) [EOL] channel = grpc . secure_channel ( url , credentials ) [EOL] client = SquareServiceStub ( channel = channel ) [EOL] result = client . square ( Message ( message = [number] ) ) [EOL] print ( result )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import grpc [EOL] from data_pb2_grpc import SquareServiceStub [EOL] from data_pb2 import Message [EOL] url = [string] [EOL] conn = grpc . insecure_channel ( url ) [EOL] client = SquareServiceStub ( channel = conn ) [EOL] for result in client . streamrangeSquare ( Message ( message = i ) for i in range ( [number] ) ) : [EOL] print ( result )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] from concurrent import futures [EOL] import grpc [EOL] from data_pb2_grpc import SquareServiceServicer , add_SquareServiceServicer_to_server [EOL] from data_pb2 import Message [EOL] [EOL] [EOL] HOST = [string] [EOL] PORT = [number] [EOL] ONE_DAY_IN_SECONDS = [number] * [number] * [number] [EOL] [EOL] class SquareServic ( SquareServiceServicer ) : [EOL] def streamrangeSquare ( self , request_iterator , context ) : [EOL] for i in request_iterator : [EOL] yield Message ( message = i . message ** [number] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] grpcServer = grpc . server ( futures . ThreadPoolExecutor ( max_workers = [number] ) ) [EOL] add_SquareServiceServicer_to_server ( SquareServic ( ) , grpcServer ) [EOL] print ( f' [string] { HOST } [string] { PORT } [string] ' ) [EOL] grpcServer . add_insecure_port ( f"{ HOST } [string] { PORT }" ) [EOL] grpcServer . start ( ) [EOL] try : [EOL] while True : [EOL] time . sleep ( ONE_DAY_IN_SECONDS ) [EOL] except KeyboardInterrupt : [EOL] grpcServer . stop ( [number] ) [EOL] except Exception as e : [EOL] grpcServer . stop ( [number] ) [EOL] raise [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] from aiogrpc import insecure_channel [EOL] from data_pb2_grpc import SquareServiceStub [EOL] from data_pb2 import Message [EOL] [EOL] url = [string] [EOL] [EOL] async def query ( ) : [EOL] async with insecure_channel ( url ) as conn : [EOL] client = SquareServiceStub ( channel = conn ) [EOL] async for response in client . rangeSquare ( Message ( message = [number] ) ) : [EOL] print ( response . message ) [EOL] [EOL] [EOL] def main ( ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( query ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import grpc [EOL] [EOL] import data_pb2 as data__pb2 [EOL] [EOL] [EOL] class SquareServiceStub ( object ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def __init__ ( self , channel ) : [EOL] [docstring] [EOL] self . rangeSquare = channel . unary_stream ( [string] , request_serializer = data__pb2 . Message . SerializeToString , response_deserializer = data__pb2 . Message . FromString , ) [EOL] [EOL] [EOL] class SquareServiceServicer ( object ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def rangeSquare ( self , request , context ) : [EOL] [comment] [EOL] pass [EOL] context . set_code ( grpc . StatusCode . UNIMPLEMENTED ) [EOL] context . set_details ( [string] ) [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [EOL] def add_SquareServiceServicer_to_server ( servicer , server ) : [EOL] rpc_method_handlers = { [string] : grpc . unary_stream_rpc_method_handler ( servicer . rangeSquare , request_deserializer = data__pb2 . Message . FromString , response_serializer = data__pb2 . Message . SerializeToString , ) , } [EOL] generic_handler = grpc . method_handlers_generic_handler ( [string] , rpc_method_handlers ) [EOL] server . add_generic_rpc_handlers ( ( generic_handler , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] from aitertools import AsyncIterWrapper [EOL] from aiogrpc import insecure_channel [EOL] from data_pb2_grpc import SquareServiceStub [EOL] from data_pb2 import Message [EOL] [EOL] url = [string] [EOL] [EOL] async def query ( ) : [EOL] async with insecure_channel ( url ) as conn : [EOL] client = SquareServiceStub ( channel = conn ) [EOL] response = await client . sumSquare ( AsyncIterWrapper ( Message ( message = i ) for i in range ( [number] ) ) ) [EOL] print ( response . message ) [EOL] [EOL] [EOL] def main ( ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( query ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import time [EOL] from hashlib import md5 [EOL] from concurrent . futures import ProcessPoolExecutor , wait [EOL] from http import HTTPStatus [EOL] from jsonrpclib . SimpleJSONRPCServer import PooledJSONRPCServer [EOL] from jsonrpclib . SimpleJSONRPCServer import SimpleJSONRPCRequestHandler [EOL] from jsonrpclib . threadpool import ThreadPool [EOL] from logger import log [EOL] [EOL] HOST = [string] [EOL] PORT = [number] [EOL] WORKER = [number] [EOL] [EOL] class RequestHandler ( SimpleJSONRPCRequestHandler ) : [EOL] rpc_paths = ( [string] , ) [EOL] [EOL] def log_error ( self , format , * args ) : [EOL] [docstring] [EOL] log . error ( [string] , address = self . address_string ( ) , errormsg = format % args ) [EOL] [EOL] def log_request ( self , code = [string] , size = [string] ) : [EOL] [docstring] [EOL] if isinstance ( code , HTTPStatus ) : [EOL] code = code . value [EOL] log . info ( [string] , address = self . address_string ( ) , requestline = self . requestline , code = str ( code ) , size = str ( size ) ) [EOL] [EOL] [EOL] def _md5_func ( text ) : [EOL] [docstring] [EOL] start = time . time ( ) [EOL] result = md5 ( text . encode ( [string] ) ) . hexdigest ( ) [EOL] end = time . time ( ) [EOL] log . info ( [string] , seconds = end - start ) [EOL] return result [EOL] [EOL] [EOL] def main ( ) : [EOL] nofif_pool = ThreadPool ( max_threads = [number] , min_threads = [number] ) [EOL] request_pool = ThreadPool ( max_threads = [number] , min_threads = [number] ) [EOL] with ProcessPoolExecutor ( WORKER ) as executor : [EOL] [comment] [EOL] def md5_func ( text ) : [EOL] fut = executor . submit ( _md5_func , text ) [EOL] wait ( [ fut ] ) [EOL] return fut . result ( ) [EOL] with PooledJSONRPCServer ( ( HOST , PORT ) , thread_pool = request_pool , requestHandler = RequestHandler ) as server : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] server . register_introspection_functions ( ) [EOL] server . set_notification_pool ( nofif_pool ) [EOL] [EOL] [comment] [EOL] server . register_multicall_functions ( ) [EOL] server . register_function ( md5_func , md5_func . __name__ ) [EOL] try : [EOL] nofif_pool . start ( ) [EOL] request_pool . start ( ) [EOL] log . info ( [string] , msg = f" [string] { HOST } [string] { PORT } [string] " ) [EOL] server . serve_forever ( ) [EOL] except Exception : [EOL] raise [EOL] finally : [EOL] request_pool . stop ( ) [EOL] nofif_pool . stop ( ) [EOL] server . set_notification_pool ( None ) [EOL] log . info ( [string] , msg = f" [string] { HOST } [string] { PORT } [string] " ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import jsonrpclib [EOL] [EOL] HOST = [string] [EOL] PORT = [number] [EOL] [EOL] [EOL] url = [string] [EOL] [EOL] with jsonrpclib . ServerProxy ( url ) as cli : [EOL] result = cli . md5_func ( [string] ) [EOL] print ( result )	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any [EOL] import typing [EOL] import jsonrpclib [EOL] [EOL] HOST = [string] [EOL] PORT = [number] [EOL] [EOL] [EOL] url = [string] [EOL] [EOL] cli = jsonrpclib . ServerProxy ( url ) [EOL] [EOL] result = cli . md5_func ( [string] ) [EOL] cli ( [string] ) ( ) [EOL] print ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] import zerorpc [EOL] [EOL] HOST = [string] [EOL] PORT = [number] [EOL] [EOL] c = zerorpc . Client ( ) [EOL] c . connect ( f" [string] { HOST } [string] { PORT }" ) [EOL] for item in c . streaming_md5 ( [ [string] , [string] , [string] ] ) : [EOL] print ( item )	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Any , List [EOL] import typing [EOL] import builtins [EOL] import time [EOL] from hashlib import md5 [EOL] from concurrent . futures import ProcessPoolExecutor , wait [EOL] from typing import List , Iterator [EOL] import zerorpc [EOL] from logger import log [EOL] HOST = [string] [EOL] PORT = [number] [EOL] WORKER = [number] [EOL] [EOL] [EOL] def _md5_func ( text ) : [EOL] [docstring] [EOL] start = time . time ( ) [EOL] result = md5 ( text . encode ( [string] ) ) . hexdigest ( ) [EOL] end = time . time ( ) [EOL] log . info ( [string] , seconds = end - start ) [EOL] return result [EOL] [EOL] [EOL] def main ( ) : [EOL] with ProcessPoolExecutor ( WORKER ) as executor : [EOL] class HelloRPC : [EOL] [EOL] def _stream_md5 ( self , texts ) : [EOL] for text in texts : [EOL] fut = executor . submit ( _md5_func , text ) [EOL] wait ( [ fut ] ) [EOL] yield fut . result ( ) [EOL] [EOL] @ zerorpc . stream def streaming_md5 ( self , texts ) : [EOL] return self . _stream_md5 ( texts ) [EOL] [EOL] s = zerorpc . Server ( HelloRPC ( ) ) [EOL] s . bind ( f" [string] { HOST } [string] { PORT }" ) [EOL] s . run ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import zerorpc [EOL] [EOL] HOST = [string] [EOL] PORT = [number] [EOL] [EOL] c = zerorpc . Client ( ) [EOL] c . connect ( f" [string] { HOST } [string] { PORT }" ) [EOL] print ( c . md5_func ( [string] ) )	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import time [EOL] from hashlib import md5 [EOL] from concurrent . futures import ProcessPoolExecutor , wait [EOL] import zerorpc [EOL] from logger import log [EOL] HOST = [string] [EOL] PORT = [number] [EOL] WORKER = [number] [EOL] [EOL] [EOL] def _md5_func ( text ) : [EOL] [docstring] [EOL] start = time . time ( ) [EOL] result = md5 ( text . encode ( [string] ) ) . hexdigest ( ) [EOL] end = time . time ( ) [EOL] log . info ( [string] , seconds = end - start ) [EOL] return result [EOL] [EOL] [EOL] def main ( ) : [EOL] with ProcessPoolExecutor ( WORKER ) as executor : [EOL] class HelloRPC : [EOL] def md5_func ( self , text ) : [EOL] fut = executor . submit ( _md5_func , text ) [EOL] wait ( [ fut ] ) [EOL] return fut . result ( ) [EOL] [EOL] s = zerorpc . Server ( HelloRPC ( ) ) [EOL] s . bind ( f" [string] { HOST } [string] { PORT }" ) [EOL] s . run ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import sys [EOL] import logging [EOL] import structlog [EOL] LOG_LEVEL = logging . INFO [EOL] SERVER_NAME = [string] [EOL] structlog . configure ( processors = [ structlog . stdlib . filter_by_level , structlog . stdlib . add_logger_name , structlog . stdlib . add_log_level , structlog . stdlib . PositionalArgumentsFormatter ( ) , structlog . processors . TimeStamper ( fmt = [string] ) , structlog . processors . StackInfoRenderer ( ) , structlog . processors . format_exc_info , structlog . processors . StackInfoRenderer ( ) , structlog . processors . JSONRenderer ( ) ] , context_class = dict , logger_factory = structlog . stdlib . LoggerFactory ( ) , wrapper_class = structlog . stdlib . BoundLogger , cache_logger_on_first_use = True , ) [EOL] [EOL] handler = logging . StreamHandler ( sys . stdout ) [EOL] root_logger = logging . getLogger ( ) [EOL] root_logger . addHandler ( handler ) [EOL] root_logger . setLevel ( LOG_LEVEL ) [comment] [EOL] log = structlog . get_logger ( SERVER_NAME )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $logging.StreamHandler$ 0 0 $logging.Logger$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0
from typing import List , Dict , Any , Union , Tuple [EOL] import datetime [EOL] import typing [EOL] import xmlrpc [EOL] import xmlrpc . client [EOL] [EOL] HOST = [string] [EOL] PORT = [number] [EOL] [EOL] with xmlrpc . client . ServerProxy ( f" [string] { HOST } [string] { PORT } [string] " ) as proxy : [EOL] result = proxy . md5_func ( [string] ) [EOL] [EOL] print ( result )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.bytes,datetime.datetime,builtins.float,builtins.int,builtins.str,xmlrpc.client.Binary,xmlrpc.client.DateTime,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.bytes,datetime.datetime,builtins.float,builtins.int,builtins.str,xmlrpc.client.Binary,xmlrpc.client.DateTime,typing.Tuple[typing.Any,...]]$ 0
from typing import List , Dict , Any , Union , Tuple [EOL] import datetime [EOL] import typing [EOL] import xmlrpc [EOL] import xmlrpc . client [EOL] [EOL] HOST = [string] [EOL] PORT = [number] [EOL] [EOL] with xmlrpc . client . ServerProxy ( f" [string] { HOST } [string] { PORT } [string] " ) as proxy : [EOL] result = proxy . md5_func ( [string] ) [EOL] [EOL] print ( result )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.bytes,datetime.datetime,builtins.float,builtins.int,builtins.str,xmlrpc.client.Binary,xmlrpc.client.DateTime,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.List[typing.Any],builtins.bool,builtins.bytes,datetime.datetime,builtins.float,builtins.int,builtins.str,xmlrpc.client.Binary,xmlrpc.client.DateTime,typing.Tuple[typing.Any,...]]$ 0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from docopt import docopt [EOL] from math import sqrt [EOL] __version__ = [string] [EOL] [EOL] [EOL] [EOL] def version ( ) : [EOL] return [string] + __version__ [EOL] [EOL] def main ( ) : [EOL] args = docopt ( __doc__ ) [EOL] [EOL] if args . get ( [string] ) or args . get ( [string] ) : [EOL] print ( __doc__ ) [EOL] elif args . get ( [string] ) or args . get ( [string] ) : [EOL] print ( __version__ ) [EOL] elif args . get ( [string] ) or args . get ( [string] ) : [EOL] print ( args ) [EOL] elif args . get ( [string] ) : [EOL] print ( [string] . join ( map ( lambda x : str ( sqrt ( float ( x ) ) ) , args . get ( [string] ) ) ) ) [EOL] else : [EOL] print ( [string] ) [EOL] print ( __doc__ ) [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from distutils . core import setup [EOL] import os [EOL] pathroot = os . path . split ( os . path . realpath ( __file__ ) ) [ [number] ] [EOL] setup ( name = [string] , version = [string] , scripts = [ pathroot + [string] ] )	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
import tkinter [EOL] from tkinter import * [EOL] [EOL] master = Tk ( ) [EOL] [EOL] variable = StringVar ( master ) [EOL] variable . set ( [string] ) [comment] [EOL] [EOL] w = OptionMenu ( master , variable , [string] , [string] , [string] ) [EOL] w . pack ( ) [EOL] [EOL] mainloop ( )	0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.StringVar$ 0 0 0 $tkinter.Tk$ 0 0 $tkinter.StringVar$ 0 0 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 $tkinter.Tk$ 0 $tkinter.StringVar$ 0 0 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 0 0 0 0 0 0
import tkinter [EOL] from tkinter import Tk [EOL] [EOL] win = Tk ( ) [EOL] win . title ( [string] ) [EOL] win . geometry ( [string] ) [EOL] win . configure ( background = [string] ) [EOL] win . attributes ( [string] , [number] ) [EOL] win . mainloop ( )	0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
[EOL] import 人机交互 [EOL] from tkinter import Frame , Canvas [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] Frame . __init__ ( self , master ) [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] [EOL] def createWidgets ( self ) : [EOL] self . can = Canvas ( self , width = [number] , height = [number] , bg = [string] ) [EOL] self . can . create_line ( ( [number] , [number] ) , ( [number] , [number] ) , width = [number] ) [EOL] self . can . create_text ( [number] , [number] , text = [string] ) [EOL] self . can . pack ( ) [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.canvas.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.canvas.Application$ 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.canvas.Application$ 0 0 0 0
import 人机交互 [EOL] from tkinter import Frame , Label , Button , Toplevel [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] Frame . __init__ ( self , master ) [EOL] [comment] [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] [EOL] def createWidgets ( self ) : [EOL] self . helloLabel = Label ( self , text = [string] ) [EOL] [EOL] self . helloLabel . pack ( ) [EOL] class App2 ( Toplevel ) : [EOL] def __init__ ( self , master = None ) : [EOL] Toplevel . __init__ ( self , master ) [EOL] self . createWidgets ( ) [EOL] [EOL] def createWidgets ( self ) : [EOL] self . helloLabel = Label ( self , text = [string] ) [EOL] self . helloLabel . pack ( ) [EOL] [EOL] if __name__ == [string] : [EOL] app1 = Application ( ) [EOL] [comment] [EOL] app1 . master . title ( [string] ) [EOL] app1 . master . geometry ( [string] )[comment] [EOL] [comment] [EOL] app2 = App2 ( ) [EOL] app2 . title ( [string] ) [EOL] app2 . geometry ( [string] )[comment] [EOL] app1 . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.toplevel.App2$ 0 0 0 0 0 0 0 $人机交互.GUI.src.toplevel.App2$ 0 0 0 0 0 0 0 0 $人机交互.GUI.src.toplevel.App2$ 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.toplevel.App2$ 0 0 0 0 0 $人机交互.GUI.src.toplevel.App2$ 0 0 0 0 0 0 $人机交互.GUI.src.toplevel.App2$ 0 0 0 0 0 0 $人机交互.GUI.src.toplevel.App2$ 0 0 0 0
import 人机交互 [EOL] from tkinter import Frame , Label , Button , Checkbutton [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] Frame . __init__ ( self , master ) [EOL] [comment] [EOL] self . master . geometry ( [string] )[comment] [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] def createWidgets ( self ) : [EOL] self . helloLabel = Label ( self , text = [string] ) [EOL] self . helloLabel . pack ( ) [EOL] [EOL] self . c1 = Checkbutton ( self , text = [string] , command = lambda : self . helloLabel . config ( text = self . helloLabel [ [string] ] + [string] ) ) [EOL] self . c1 . pack ( ) [EOL] self . c2 = Checkbutton ( self , text = [string] , command = lambda : self . helloLabel . config ( text = self . helloLabel [ [string] ] + [string] ) ) [EOL] self . c2 . pack ( ) [EOL] self . quitButton = Button ( self , text = [string] , fg = [string] , command = self . quit ) [EOL] self . quitButton . pack ( ) [EOL] [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] [EOL] app . master . geometry ( [string] )[comment] [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.checkbutton.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.checkbutton.Application$ 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.checkbutton.Application$ 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.checkbutton.Application$ 0 0 0 0
[EOL] [comment] [EOL] import 人机交互 [EOL] from tkinter import Frame , Label , Button [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] super ( ) . __init__ ( master ) [EOL] [comment] [EOL] self . master . geometry ( [string] )[comment] [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] [EOL] def createWidgets ( self ) : [EOL] self . helloLabel = Label ( self , text = [string] ) [EOL] [EOL] self . helloLabel . pack ( ) [EOL] self . quitButton = Button ( self , text = [string] , fg = [string] , command = self . quit ) [EOL] self . quitButton . pack ( ) [EOL] [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] [EOL] app . master . geometry ( [string] )[comment] [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.firstGUI.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.firstGUI.Application$ 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.firstGUI.Application$ 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.firstGUI.Application$ 0 0 0 0
import builtins [EOL] from typing import Any [EOL] import typing [EOL] import tkinter [EOL] from tkinter import * [EOL] from tkinter import ttk [EOL] import time [EOL] [EOL] def manu_increment ( * args ) : [EOL] for i in range ( [number] ) : [EOL] p1 [ [string] ] = i + [number] [EOL] root . update ( ) [EOL] time . sleep ( [number] ) [EOL] [EOL] def auto_increment ( * args ) : [EOL] global flag , value [EOL] flag = not flag [EOL] [EOL] if flag : [EOL] btn2 [ [string] ] = [string] [EOL] p2 . start ( [number] ) [EOL] else : [EOL] btn2 [ [string] ] = [string] [EOL] value = p2 [ [string] ] [EOL] p2 . stop ( ) [EOL] p2 [ [string] ] = value [EOL] root = Tk ( ) [EOL] root . title ( [string] ) [EOL] sg = ttk . Sizegrip ( root ) . grid ( row = [number] , column = [number] , sticky = [string] ) [EOL] [comment] [EOL] p1 = ttk . Progressbar ( root , length = [number] , mode = [string] , orient = HORIZONTAL ) [EOL] p1 . grid ( row = [number] , column = [number] ) [EOL] p1 [ [string] ] = [number] [EOL] p1 [ [string] ] = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] btn = ttk . Button ( root , text = [string] , command = manu_increment ) [EOL] btn . grid ( row = [number] , column = [number] ) [EOL] [EOL] [comment] [EOL] flag = False [comment] [EOL] value = [number] [comment] [EOL] [EOL] [comment] [EOL] sep = ttk . Separator ( root ) [EOL] sep . grid ( sticky = [string] ) [EOL] [EOL] p2 = ttk . Progressbar ( root , length = [number] , orient = HORIZONTAL ) [EOL] p2 . grid ( row = [number] , column = [number] ) [EOL] [EOL] btn2 = ttk . Button ( root , text = [string] , command = auto_increment ) [EOL] btn2 . grid ( row = [number] , column = [number] ) [EOL] [EOL] root . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $tkinter.ttk.Separator$ 0 0 0 0 0 0 0 0 $tkinter.ttk.Separator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import 人机交互 [EOL] from tkinter import Frame , Label , Button [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] Frame . __init__ ( self , master ) [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] [EOL] def createWidgets ( self ) : [EOL] self . LabelL = Label ( self , text = [string] ) [EOL] self . LabelL . pack ( side = [string] ) [EOL] self . LabelR = Label ( self , text = [string] ) [EOL] self . LabelR . pack ( side = [string] ) [EOL] self . LabelT = Label ( self , text = [string] ) [EOL] self . LabelT . pack ( side = [string] ) [EOL] self . LabelB = Label ( self , text = [string] ) [EOL] self . LabelB . pack ( side = [string] ) [EOL] [EOL] self . LabelN = Label ( self , text = [string] ) [EOL] self . LabelN . pack ( anchor = [string] ) [EOL] self . LabelE = Label ( self , text = [string] ) [EOL] self . LabelE . pack ( anchor = [string] ) [EOL] self . LabelS = Label ( self , text = [string] ) [EOL] self . LabelS . pack ( anchor = [string] ) [EOL] self . LabelW = Label ( self , text = [string] ) [EOL] self . LabelW . pack ( anchor = [string] ) [EOL] self . LabelCENTER = Label ( self , text = [string] ) [EOL] self . LabelCENTER . pack ( anchor = [string] ) [EOL] [EOL] [EOL] self . quitButton = Button ( self , text = [string] , background = [string] , command = self . quit ) [EOL] self . quitButton . pack ( side = [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.pack.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.pack.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.pack.Application$ 0 0 0 0
import tkinter [EOL] from tkinter import Tk , END [EOL] from tkinter . scrolledtext import ScrolledText [EOL] root = Tk ( ) [EOL] stext = ScrolledText ( root , bg = [string] , height = [number] ) [EOL] stext . pack ( fill = [string] , side = [string] , expand = True ) [EOL] stext . focus_set ( ) [EOL] root . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 $tkinter.scrolledtext.ScrolledText$ 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 $tkinter.scrolledtext.ScrolledText$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.scrolledtext.ScrolledText$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import tkinter [EOL] import tkinter [EOL] from tkinter import filedialog [EOL] [EOL] def openfile ( ) : [EOL] r = filedialog . askopenfilename ( title = [string] , filetypes = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] print ( r ) [EOL] def savefile ( ) : [EOL] r = filedialog . asksaveasfilename ( title = [string] , initialdir = [string] , initialfile = [string] ) [EOL] print ( r ) [EOL] [EOL] root = tkinter . Tk ( ) [EOL] btn1 = tkinter . Button ( root , text = [string] , command = openfile ) [EOL] btn2 = tkinter . Button ( root , text = [string] , command = savefile ) [EOL] [EOL] btn1 . pack ( side = [string] ) [EOL] btn2 . pack ( side = [string] ) [EOL] root . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
[EOL] import tkinter [EOL] from tkinter import * [EOL] [EOL] [EOL] root = Tk ( ) [EOL] [EOL] text = Text ( root ) [EOL] text . pack ( ) [EOL] [EOL] [comment] [EOL] text . insert ( INSERT , [string] ) [EOL] text . insert ( END , [string] ) [EOL] [EOL] mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tkinter [EOL] from tkinter import Tk , Message [EOL] [EOL] master = Tk ( ) [EOL] [EOL] w = Message ( master , text = [string] ) [EOL] w . pack ( ) [EOL] [EOL] master . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Message$ 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Message$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
import tkinter [EOL] from tkinter import Tk , StringVar [EOL] from tkinter . ttk import Combobox [EOL] master = Tk ( ) [EOL] number = StringVar ( ) [EOL] w = Combobox ( master , textvariable = number ) [EOL] w [ [string] ] = ( [number] , [number] , [number] , [number] , [number] ) [comment] [EOL] w . grid ( column = [number] , row = [number] ) [comment] [EOL] w . current ( [number] ) [EOL] w . pack ( ) [EOL] master . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 $tkinter.StringVar$ 0 0 0 0 0 $tkinter.ttk.Combobox$ 0 0 0 $tkinter.Tk$ 0 0 0 $tkinter.StringVar$ 0 0 $tkinter.ttk.Combobox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Combobox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Combobox$ 0 0 0 0 0 0 $tkinter.ttk.Combobox$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import tkinter [EOL] from tkinter import * [EOL] from tkinter import ttk [EOL] [EOL] root = Tk ( ) [EOL] [EOL] tree = ttk . Treeview ( root ) [EOL] [EOL] tree [ [string] ] = ( [string] , [string] ) [EOL] tree . column ( [string] , width = [number] ) [EOL] tree . column ( [string] , width = [number] ) [EOL] tree . heading ( [string] , text = [string] ) [EOL] tree . heading ( [string] , text = [string] ) [EOL] [EOL] tree . insert ( [string] , [number] , text = [string] , values = ( [string] , [string] ) ) [EOL] [EOL] id2 = tree . insert ( [string] , [number] , [string] , text = [string] ) [EOL] tree . insert ( id2 , [string] , [string] , text = [string] , values = ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] tree . insert ( [string] , [number] , [string] , text = [string] ) [EOL] tree . insert ( [string] , [number] , text = [string] , values = ( [string] , [string] ) ) [EOL] [EOL] tree . pack ( ) [EOL] root . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Treeview$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
[comment] [EOL] from typing import Any , List , Dict [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import cmd , sys [EOL] import pandas as pd [EOL] import readline [EOL] from playhouse . db_url import connect [EOL] [EOL] [EOL] class SqlShell ( cmd . Cmd ) : [EOL] def __init__ ( self , completekey = [string] , stdin = None , stdout = None , sql_uri = None ) : [EOL] super ( ) . __init__ ( completekey = completekey , stdin = stdin , stdout = stdout ) [EOL] self . uri = sql_uri or [string] [EOL] self . db = connect ( self . uri ) [EOL] self . db . connect ( ) [EOL] self . intro = [string] [EOL] self . prompt = [string] + self . uri . split ( [string] ) [ [number] ] + [string] [EOL] self . file = None [EOL] self . sql_string = [string] [EOL] [EOL] [EOL] def _run_sql ( self ) : [EOL] try : [EOL] q = self . db . execute_sql ( self . sql_string , require_commit = False ) [EOL] except Exception as e : [EOL] print ( type ( e ) ) [EOL] print ( str ( e ) ) [EOL] else : [EOL] if q . description : [EOL] titles = [ i [ [number] ] for i in q . description ] [EOL] rows = q . fetchall ( ) [EOL] t = [ { t : v for ( t , v ) in zip ( titles , i ) } for i in rows ] [EOL] table = pd . DataFrame ( t ) [EOL] print ( [string] ) [EOL] print ( table . to_string ( ) ) [EOL] [comment] [EOL] [comment] [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] def default ( self , string ) : [EOL] self . sql_string += string . strip ( ) [EOL] if self . sql_string . endswith ( [string] ) : [EOL] print ( self . sql_string ) [EOL] self . _run_sql ( ) [EOL] self . sql_string = [string] [EOL] [EOL] def do_uri ( self , arg ) : [EOL] print ( self . uri ) [EOL] [EOL] def do_bye ( self , arg ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] self . close ( ) [EOL] self . db . close ( ) [EOL] return True [EOL] [EOL] def do_exit ( self , arg ) : [EOL] return self . do_bye ( arg ) [EOL] [EOL] def do_quit ( self , arg ) : [EOL] return self . do_bye ( arg ) [EOL] [EOL] [comment] [EOL] def do_record ( self , arg ) : [EOL] [docstring] [EOL] self . file = open ( arg , [string] ) [EOL] def do_playback ( self , arg ) : [EOL] [docstring] [EOL] self . close ( ) [EOL] with open ( arg ) as f : [EOL] self . cmdqueue . extend ( f . read ( ) . splitlines ( ) ) [EOL] def precmd ( self , line ) : [EOL] line = line . lower ( ) [EOL] if self . file and [string] not in line : [EOL] print ( line , file = self . file ) [EOL] return line [EOL] def close ( self ) : [EOL] if self . file : [EOL] self . file . close ( ) [EOL] self . file = None [EOL] [EOL] def shell ( args ) : [EOL] SqlShell ( sql_uri = args . dburi ) . cmdloop ( ) [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , type = str ) [EOL] parser . set_defaults ( func = shell ) [EOL] args = parser . parse_args ( argv ) [EOL] args . func ( args ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( argv = sys . argv [ [number] : ] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tkinter [EOL] from tkinter import Tk [EOL] [EOL] win = Tk ( ) [EOL] win . title ( [string] ) [EOL] win . iconbitmap ( [string] ) [EOL] win . geometry ( [string] ) [EOL] win . configure ( background = [string] ) [EOL] win . attributes ( [string] , [number] ) [EOL] win . mainloop ( )	0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
[EOL] from typing import Any [EOL] import 人机交互 [EOL] import typing [EOL] import tkinter [EOL] from tkinter import Frame , Label , Button , Menu [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None , ) : [EOL] Frame . __init__ ( self , master ) [EOL] [comment] [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] menu = self . creatMenu ( ) [EOL] [EOL] [EOL] def creatMenu ( self ) : [EOL] [comment] [EOL] menubar = Menu ( self . master ) [EOL] [EOL] [comment] [EOL] menufile = Menu ( menubar ) [EOL] for item in [ [string] , [string] , [string] , [string] ] : [EOL] menufile . add_radiobutton ( label = item ) [EOL] [EOL] menuedit = Menu ( menubar ) [EOL] for item in [ [string] , [string] , [string] ] : [EOL] menuedit . add_checkbutton ( label = item ) [EOL] [comment] [EOL] for name , submenu in zip ( [ [string] , [string] ] , [ menufile , menuedit ] ) : [EOL] menubar . add_cascade ( label = name , menu = submenu ) [EOL] [comment] [EOL] self . master . config ( menu = menubar ) [EOL] [EOL] [EOL] [comment] [EOL] menu = Menu ( self . master ) [EOL] for i in ( [string] , [string] , [string] ) : [EOL] menu . add_command ( label = i ) [EOL] [comment] [EOL] menu . add_separator ( ) [EOL] [EOL] for i in ( [string] , [string] , [string] ) : [EOL] menu . add_command ( label = i ) [EOL] [comment] [EOL] if ( self . master . tk . call ( [string] , [string] ) == [string] ) : [EOL] self . master . bind ( [string] , lambda e : menu . post ( e . x_root , e . y_root ) ) [EOL] self . master . bind ( [string] , lambda e : menu . post ( e . x_root , e . y_root ) ) [EOL] else : [EOL] self . master . bind ( [string] , lambda e : menu . post ( e . x_root , e . y_root ) ) [EOL] [EOL] [EOL] [EOL] def createWidgets ( self ) : [EOL] self . helloLabel = Label ( self , text = [string] ) [EOL] self . helloLabel [ [string] ] = [string] [EOL] self . helloLabel . pack ( ) [EOL] self . quitButton = Button ( self , text = [string] , fg = [string] , command = self . quit ) [EOL] self . quitButton . pack ( ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] app . master . geometry ( [string] )[comment] [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 $tkinter.Menu$ 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 $tkinter.Menu$ 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.menu.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.menu.Application$ 0 0 0 0 0 0 0 0 $人机交互.GUI.src.menu.Application$ 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.menu.Application$ 0 0 0 0
[EOL] from typing import Any [EOL] import 人机交互 [EOL] import typing [EOL] import tkinter [EOL] from tkinter import Frame , Label , Button , Menu [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None , ) : [EOL] Frame . __init__ ( self , master ) [EOL] [comment] [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] menu = self . creatMenu ( ) [EOL] self . master . config ( menu = menu ) [EOL] [EOL] [EOL] def creatMenu ( self ) : [EOL] [comment] [EOL] menubar = Menu ( self . master ) [EOL] [comment] [EOL] menufile = Menu ( menubar ) [EOL] [comment] [EOL] menuradio = Menu ( menubar ) [EOL] [comment] [EOL] menucheck = Menu ( menubar ) [EOL] for item in [ [string] , [string] , [string] , [string] ] : [EOL] menufile . add_command ( label = item ) [EOL] menubar . add_cascade ( label = [string] , menu = menufile ) [EOL] for i in [ [string] , [string] , [string] ] : [EOL] menuradio . add_radiobutton ( label = i ) [EOL] menubar . add_cascade ( label = [string] , menu = menuradio ) [EOL] for i in [ [string] , [string] , [string] ] : [EOL] menucheck . add_checkbutton ( label = i ) [EOL] menubar . add_cascade ( label = [string] , menu = menucheck ) [EOL] return menubar [EOL] [EOL] [EOL] def createWidgets ( self ) : [EOL] self . helloLabel = Label ( self , text = [string] ) [EOL] self . helloLabel [ [string] ] = [string] [EOL] self . helloLabel . pack ( ) [EOL] self . quitButton = Button ( self , text = [string] , fg = [string] , command = self . quit ) [EOL] self . quitButton . pack ( ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] app . master . geometry ( [string] )[comment] [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 $tkinter.Menu$ 0 0 0 0 $tkinter.Menu$ 0 0 0 $tkinter.Menu$ 0 0 0 0 $tkinter.Menu$ 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 $tkinter.Menu$ 0 0 0 $tkinter.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.menu_othercommand.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.menu_othercommand.Application$ 0 0 0 0 0 0 0 0 $人机交互.GUI.src.menu_othercommand.Application$ 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.menu_othercommand.Application$ 0 0 0 0
import tkinter [EOL] from tkinter import Tk , Spinbox [EOL] [EOL] master = Tk ( ) [EOL] [EOL] w = Spinbox ( master , from_ = [number] , to = [number] ) [EOL] w . pack ( ) [EOL] master . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Spinbox$ 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Spinbox$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import tkinter [EOL] import datetime [EOL] from tkinter import Tk , Button , IntVar [EOL] import numpy as np [EOL] import matplotlib as mpl [EOL] mpl . use ( [string] ) [EOL] import matplotlib . pyplot as plt [EOL] import matplotlib . finance as mpf [EOL] from matplotlib . pylab import date2num [EOL] from matplotlib . backend_bases import key_press_handler [EOL] from matplotlib . backends . backend_tkagg import FigureCanvasTkAgg , NavigationToolbar2TkAgg [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] def plot ( i ) : [EOL] fig , ax = plt . subplots ( ) [EOL] x = np . arange ( [number] , [number] * np . pi , [number] ) [EOL] line , = ax . plot ( x , np . sin ( x + i / [number] ) ) [EOL] return fig , ax [EOL] [EOL] [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] root = Tk ( ) [EOL] I = [number] [EOL] f , ax = plot ( I ) [EOL] canvas = FigureCanvasTkAgg ( f , master = root ) [EOL] canvas . show ( ) [EOL] canvas . get_tk_widget ( ) . pack ( side = [string] , fill = [string] , expand = [number] ) [EOL] toolbar = NavigationToolbar2TkAgg ( canvas , root ) [EOL] toolbar . update ( ) [EOL] canvas . _tkcanvas . pack ( side = [string] , fill = [string] , expand = [number] ) [EOL] def callback ( ) : [EOL] nonlocal I [EOL] ax . clear ( ) [EOL] x = np . arange ( [number] , [number] * np . pi , [number] ) [EOL] line , = ax . plot ( x , np . sin ( x + I / [number] ) ) [EOL] I += [number] [EOL] canvas . draw ( ) [EOL] root . after ( [number] , callback ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def on_key_event ( event ) : [EOL] print ( [string] % event . key ) [EOL] key_press_handler ( event , canvas , toolbar ) [EOL] canvas . mpl_connect ( [string] , on_key_event ) [EOL] [EOL] def _quit ( ) : [EOL] [comment] [EOL] root . quit ( ) [EOL] root . destroy ( ) [EOL] button = Button ( master = root , text = [string] , command = _quit ) [EOL] button . pack ( side = [string] ) [EOL] root . after ( [number] , callback ) [EOL] root . mainloop ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tkinter [EOL] from tkinter import Tk , PhotoImage [EOL] from tkinter . ttk import Notebook , Frame , Button [EOL] [EOL] [EOL] root = Tk ( ) [EOL] [EOL] scheduledimage = PhotoImage ( [string] ) [EOL] note = Notebook ( root ) [EOL] [EOL] tab1 = Frame ( note ) [EOL] tab2 = Frame ( note ) [EOL] tab3 = Frame ( note ) [EOL] Button ( tab1 , text = [string] , command = root . destroy ) . pack ( padx = [number] , pady = [number] ) [EOL] note . add ( tab1 , text = [string] , image = scheduledimage , compound = [string] ) [EOL] note . add ( tab2 , text = [string] ) [EOL] note . add ( tab3 , text = [string] ) [EOL] note . pack ( ) [EOL] root . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.PhotoImage$ 0 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 $tkinter.Tk$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 $tkinter.ttk.Notebook$ 0 0 $tkinter.ttk.Frame$ 0 0 0 $tkinter.ttk.Notebook$ 0 0 $tkinter.ttk.Frame$ 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 $tkinter.PhotoImage$ 0 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
[EOL] [comment] [EOL] import 人机交互 [EOL] import tkinter [EOL] from tkinter . ttk import LabelFrame , Label , Button , Style [EOL] [EOL] style = Style ( ) [EOL] style . configure ( [string] , foreground = [string] , background = [string] ) [EOL] [EOL] class Application ( LabelFrame ) : [EOL] def __init__ ( self , master = None ) : [EOL] super ( ) . __init__ ( master ) [EOL] [comment] [EOL] self . master . geometry ( [string] )[comment] [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] self . config ( text = [string] , labelanchor = [string] ) [EOL] [EOL] def createWidgets ( self ) : [EOL] self . helloLabel = Label ( self , text = [string] ) [EOL] [EOL] self . helloLabel . pack ( ) [EOL] self . quitButton = Button ( self , text = [string] , style = [string] , command = self . quit ) [EOL] self . quitButton . pack ( ) [EOL] [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] [EOL] app . master . geometry ( [string] )[comment] [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Style$ 0 0 0 0 0 $tkinter.ttk.Style$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Style$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.ttklf.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.ttklf.Application$ 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.ttklf.Application$ 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.ttklf.Application$ 0 0 0 0
[EOL] import 人机交互 [EOL] from tkinter import Frame , Label , Button , Radiobutton , IntVar [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] Frame . __init__ ( self , master ) [EOL] [comment] [EOL] self . master . geometry ( [string] )[comment] [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] def createWidgets ( self ) : [EOL] self . var = IntVar ( ) [EOL] self . helloLabel = Label ( self , text = [string] ) [EOL] self . helloLabel . pack ( ) [EOL] self . rbframe = Frame ( self ) [EOL] self . rbframe . pack ( ) [EOL] self . c1 = Radiobutton ( self . rbframe , indicatoron = False , text = [string] , value = [number] , variable = self . var , command = self . _callback ) [EOL] self . c1 . pack ( ) [EOL] self . c2 = Radiobutton ( self . rbframe , indicatoron = False , text = [string] , value = [number] , variable = self . var , command = self . _callback ) [EOL] self . c2 . pack ( ) [EOL] self . quitButton = Button ( self , text = [string] , fg = [string] , command = self . quit ) [EOL] self . quitButton . pack ( ) [EOL] [EOL] def _callback ( self ) : [EOL] self . helloLabel . config ( text = [string] . format ( self . var . get ( ) ) ) [EOL] [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] [EOL] app . master . geometry ( [string] )[comment] [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.radiobutton.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.radiobutton.Application$ 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.radiobutton.Application$ 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.radiobutton.Application$ 0 0 0 0
import tkinter [EOL] from tkinter import Tk , Scale , HORIZONTAL [EOL] [EOL] master = Tk ( ) [EOL] [EOL] w = Scale ( master , from_ = [number] , to = [number] ) [EOL] w . pack ( ) [EOL] [EOL] w = Scale ( master , from_ = [number] , to = [number] , orient = HORIZONTAL ) [EOL] w . pack ( ) [EOL] [EOL] master . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Scale$ 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Scale$ 0 0 0 0 0 0 $tkinter.Scale$ 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Scale$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
import tkinter [EOL] from tkinter import Tk , Scrollbar , Listbox [EOL] master = Tk ( ) [EOL] scrollbar = Scrollbar ( master ) [EOL] scrollbar . pack ( side = [string] , fill = [string] ) [EOL] [EOL] listbox = Listbox ( master , yscrollcommand = scrollbar . set ) [EOL] for i in range ( [number] ) : [EOL] listbox . insert ( [string] , str ( i ) ) [EOL] listbox . pack ( side = [string] , fill = [string] ) [EOL] [EOL] scrollbar . config ( command = listbox . yview ) [EOL] [EOL] master . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 $tkinter.Scrollbar$ 0 0 0 $tkinter.Tk$ 0 0 $tkinter.Scrollbar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Listbox$ 0 0 0 $tkinter.Tk$ 0 0 0 $tkinter.Scrollbar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Listbox$ 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Listbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Scrollbar$ 0 0 0 0 0 $tkinter.Listbox$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
[EOL] import 人机交互 [EOL] from tkinter import Frame , Listbox , END [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] Frame . __init__ ( self , master ) [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] [EOL] def createWidgets ( self ) : [EOL] self . list = Listbox ( self ) [EOL] self . list . pack ( ) [EOL] self . list . insert ( END , [string] ) [EOL] for item in [ [string] , [string] , [string] , [string] ] : [EOL] self . list . insert ( END , item ) [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.listbox.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.listbox.Application$ 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.listbox.Application$ 0 0 0 0
from typing import Any , List [EOL] import datetime [EOL] import typing [EOL] import tkinter [EOL] import datetime [EOL] from tkinter import Tk , Button [EOL] import matplotlib as mpl [EOL] import matplotlib . pyplot as plt [EOL] import matplotlib . finance as mpf [EOL] from matplotlib . pylab import date2num [EOL] from matplotlib . backend_bases import key_press_handler [EOL] from matplotlib . backends . backend_tkagg import FigureCanvasTkAgg , NavigationToolbar2TkAgg [EOL] import tushare as ts [EOL] [EOL] mpl . use ( [string] ) [EOL] [EOL] def date_to_num ( dates ) : [EOL] num_time = [ ] [EOL] for date in dates : [EOL] date_time = datetime . datetime . strptime ( date , [string] ) [EOL] num_date = date2num ( date_time ) [EOL] num_time . append ( num_date ) [EOL] return num_time [EOL] [EOL] def plot ( mat_wdyx ) : [EOL] fig , ( ax1 , ax2 ) = plt . subplots ( [number] , sharex = True , figsize = ( [number] , [number] ) ) [EOL] mpf . candlestick_ochl ( ax1 , mat_wdyx , width = [number] , colorup = [string] , colordown = [string] ) [EOL] ax1 . set_title ( [string] ) [EOL] ax1 . set_ylabel ( [string] ) [EOL] ax1 . grid ( True ) [EOL] ax1 . xaxis_date ( ) [EOL] plt . bar ( mat_wdyx [ : , [number] ] - [number] , mat_wdyx [ : , [number] ] , width = [number] ) [EOL] ax2 . set_ylabel ( [string] ) [EOL] ax2 . grid ( True ) [EOL] return fig [EOL] [EOL] def main ( ) : [EOL] wdyx = ts . get_k_data ( [string] , [string] ) [EOL] mat_wdyx = wdyx . as_matrix ( ) [EOL] num_time = date_to_num ( mat_wdyx [ : , [number] ] ) [EOL] mat_wdyx [ : , [number] ] = num_time [EOL] f = plot ( mat_wdyx ) [EOL] [EOL] root = Tk ( ) [EOL] [EOL] canvas = FigureCanvasTkAgg ( f , master = root ) [EOL] canvas . show ( ) [EOL] canvas . get_tk_widget ( ) . pack ( side = [string] , fill = [string] , expand = [number] ) [EOL] [EOL] toolbar = NavigationToolbar2TkAgg ( canvas , root ) [EOL] toolbar . update ( ) [EOL] canvas . _tkcanvas . pack ( side = [string] , fill = [string] , expand = [number] ) [EOL] [comment] [EOL] def on_key_event ( event ) : [EOL] print ( [string] % event . key ) [EOL] key_press_handler ( event , canvas , toolbar ) [EOL] canvas . mpl_connect ( [string] , on_key_event ) [EOL] [EOL] def _quit ( ) : [EOL] [comment] [EOL] root . quit ( ) [EOL] root . destroy ( ) [EOL] button = Button ( master = root , text = [string] , command = _quit ) [EOL] button . pack ( side = [string] ) [EOL] root . mainloop ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import 人机交互 [EOL] import typing [EOL] import tkinter [EOL] from tkinter import Frame , Label , Button , Entry [EOL] from tkinter . dialog import Dialog [EOL] [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] Frame . __init__ ( self , master ) [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] [EOL] def createWidgets ( self ) : [EOL] self . userLabel = Label ( self , text = [string] ) [EOL] self . userLabel . grid ( row = [number] , column = [number] , sticky = [string] ) [EOL] self . userEntry = Entry ( self ) [EOL] self . userEntry . grid ( row = [number] , column = [number] , sticky = [string] ) [EOL] self . pwLabel = Label ( self , text = [string] ) [EOL] self . pwLabel . grid ( row = [number] , column = [number] , sticky = [string] ) [EOL] self . pwEntry = Entry ( self ) [EOL] self . pwEntry . grid ( row = [number] , column = [number] , sticky = [string] ) [EOL] [EOL] self . enterButton = Button ( self , text = [string] , command = self . reg ) [EOL] self . enterButton . grid ( row = [number] , column = [number] , sticky = [string] ) [EOL] [EOL] self . logLabel = Label ( self , text = [string] ) [EOL] self . logLabel . grid ( row = [number] ) [EOL] [EOL] def reg ( self ) : [EOL] s1 = self . userEntry . get ( ) [EOL] s2 = self . pwEntry . get ( ) [EOL] if s1 == [string] and s2 == [string] : [EOL] self . logLabel [ [string] ] = [string] [EOL] else : [EOL] self . logLabel [ [string] ] = [string] [EOL] self . userEntry . delete ( [number] , len ( s1 ) ) [EOL] self . pwEntry . delete ( [number] , len ( s1 ) ) [EOL] d = Dialog ( None , title = [string] , text = [string] , default = [number] , strings = ( [string] , [string] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $tkinter.dialog.Dialog$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.dialog.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.dialog.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.dialog.Application$ 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , Type [EOL] import 人机交互 [EOL] import typing [EOL] from __future__ import print_function [EOL] import cmd , sys [EOL] from turtle import * [EOL] [EOL] class TurtleShell ( cmd . Cmd ) : [EOL] intro = [string] [EOL] prompt = [string] [EOL] file = None [EOL] [EOL] [comment] [EOL] def do_forward ( self , arg ) : [EOL] [docstring] [EOL] forward ( * parse ( arg ) ) [EOL] def do_right ( self , arg ) : [EOL] [docstring] [EOL] right ( * parse ( arg ) ) [EOL] def do_left ( self , arg ) : [EOL] [docstring] [EOL] left ( * parse ( arg ) ) [EOL] def do_goto ( self , arg ) : [EOL] [docstring] [EOL] goto ( * parse ( arg ) ) [EOL] def do_home ( self , arg ) : [EOL] [docstring] [EOL] home ( ) [EOL] def do_circle ( self , arg ) : [EOL] [docstring] [EOL] circle ( * parse ( arg ) ) [EOL] def do_position ( self , arg ) : [EOL] [docstring] [EOL] print ( [string] % position ( ) ) [EOL] def do_heading ( self , arg ) : [EOL] [docstring] [EOL] print ( [string] % ( heading ( ) , ) ) [EOL] def do_color ( self , arg ) : [EOL] [docstring] [EOL] color ( arg . lower ( ) ) [EOL] def do_undo ( self , arg ) : [EOL] [docstring] [EOL] def do_reset ( self , arg ) : [EOL] [docstring] [EOL] reset ( ) [EOL] def do_bye ( self , arg ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] self . close ( ) [EOL] bye ( ) [EOL] return True [EOL] [EOL] [comment] [EOL] def do_record ( self , arg ) : [EOL] [docstring] [EOL] self . file = open ( arg , [string] ) [EOL] def do_playback ( self , arg ) : [EOL] [docstring] [EOL] self . close ( ) [EOL] with open ( arg ) as f : [EOL] self . cmdqueue . extend ( f . read ( ) . splitlines ( ) ) [EOL] def precmd ( self , line ) : [EOL] line = line . lower ( ) [EOL] if self . file and [string] not in line : [EOL] print ( line , file = self . file ) [EOL] return line [EOL] def close ( self ) : [EOL] if self . file : [EOL] self . file . close ( ) [EOL] self . file = None [EOL] [EOL] def parse ( arg ) : [EOL] [docstring] [EOL] return tuple ( map ( int , arg . split ( ) ) ) [EOL] [EOL] if __name__ == [string] : [EOL] TurtleShell ( ) . cmdloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tkinter [EOL] from tkinter import Tk , Label , PanedWindow , BOTH , VERTICAL [EOL] [EOL] master = Tk ( ) [EOL] m1 = PanedWindow ( master ) [EOL] m1 . pack ( fill = BOTH , expand = [number] ) [EOL] [EOL] left = Label ( m1 , text = [string] ) [EOL] m1 . add ( left ) [EOL] [EOL] m2 = PanedWindow ( m1 , orient = VERTICAL ) [EOL] m1 . add ( m2 ) [EOL] [EOL] top = Label ( m2 , text = [string] ) [EOL] m2 . add ( top ) [EOL] [EOL] bottom = Label ( m2 , text = [string] ) [EOL] m2 . add ( bottom ) [EOL] [EOL] master . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 $tkinter.PanedWindow$ 0 0 0 $tkinter.Tk$ 0 0 $tkinter.PanedWindow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.PanedWindow$ 0 0 0 0 0 0 $tkinter.PanedWindow$ 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.PanedWindow$ 0 0 0 $tkinter.PanedWindow$ 0 0 0 0 0 0 $tkinter.PanedWindow$ 0 0 0 $tkinter.PanedWindow$ 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.PanedWindow$ 0 0 0 0 0 0 $tkinter.PanedWindow$ 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.PanedWindow$ 0 0 0 0 0 0 $tkinter.PanedWindow$ 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.Tk$ 0 0 0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] import tkinter [EOL] from tkinter import Tk , Frame [EOL] from pandastable import Table , TableModel [EOL] [EOL] data = { [string] : { [string] : [number] , [string] : [number] , [string] : [string] } , [string] : { [string] : [number] , [string] : [number] , [string] : [string] } } [EOL] [EOL] root = Tk ( ) [EOL] f = Frame ( root ) [EOL] f . pack ( fill = [string] , expand = [number] ) [EOL] model = TableModel . getSampleData ( ) [EOL] table = Table ( f , dataframe = model , showtoolbar = True , showstatusbar = True ) [EOL] table . show ( ) [EOL] table . showPlotViewer ( layout = [string] ) [EOL] [comment] [EOL] [EOL] root . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 $tkinter.Frame$ 0 0 0 $tkinter.Tk$ 0 0 $tkinter.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $tkinter.Frame$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0
[EOL] import 人机交互 [EOL] from tkinter import Frame , Label , Button [EOL] [EOL] [EOL] [EOL] class Application ( Frame ) : [EOL] def __init__ ( self , master = None ) : [EOL] Frame . __init__ ( self , master ) [EOL] self . pack ( ) [EOL] self . createWidgets ( ) [EOL] [EOL] def createWidgets ( self ) : [EOL] self . Label00 = Label ( self , text = [string] ) [EOL] self . Label00 . grid ( row = [number] , column = [number] ) [EOL] self . Label10 = Label ( self , text = [string] ) [EOL] self . Label10 . grid ( row = [number] , column = [number] ) [EOL] self . Label11 = Label ( self , text = [string] ) [EOL] self . Label11 . grid ( row = [number] , column = [number] ) [EOL] self . Label30 = Label ( self , text = [string] ) [EOL] self . Label30 . grid ( row = [number] , column = [number] ) [EOL] [EOL] [EOL] self . quitButton = Button ( self , text = [string] , background = [string] , command = self . quit ) [EOL] self . quitButton . grid ( row = [number] , column = [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] app = Application ( ) [EOL] [comment] [EOL] app . master . title ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] app . mainloop ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.grid.Application$ 0 0 0 0 0 0 0 $人机交互.GUI.src.grid.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $人机交互.GUI.src.grid.Application$ 0 0 0 0
[EOL] from distutils . core import setup [EOL] import os [EOL] pathroot = os . path . split ( os . path . realpath ( __file__ ) ) [ [number] ] [EOL] setup ( name = [string] , version = [string] , scripts = [ pathroot + [string] ] )	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
[comment] [EOL] import argparse [EOL] import argparse [EOL] from math import sqrt [EOL] from gooey import Gooey , GooeyParser [EOL] [EOL] [EOL] __version__ = [string] [EOL] [EOL] def sqrtarg ( number ) : [EOL] return sqrt ( number ) [EOL] [EOL] def version ( ) : [EOL] return [string] + __version__ [EOL] @ Gooey ( language = [string] ) def main ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = int , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] if args . version : [EOL] print ( version ( ) ) [EOL] if args . number : [EOL] print ( sqrtarg ( args . number ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from setuptools import setup , find_packages [EOL] import os [EOL] pathroot = os . path . split ( os . path . realpath ( __file__ ) ) [ [number] ] [EOL] setup ( name = [string] , version = [string] , packages = find_packages ( ) , entry_points = { [string] : [ [string] ] , } )	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Coroutine , Dict [EOL] import asyncio [EOL] import typing [EOL] import 异步socket编程 [EOL] import json [EOL] import asyncio [EOL] [EOL] subscribers = { } [EOL] [EOL] [EOL] class Exchange : [EOL] [EOL] def error_hander ( self , query , msg ) : [EOL] print ( [string] ) [EOL] answer = { [string] : [string] , [string] : query . get ( [string] ) , [string] : query . get ( [string] ) , [string] : query . get ( [string] ) , [string] : msg } [EOL] self . client_writer . write ( json . dumps ( answer ) . encode ( ) + [string] ) [EOL] [EOL] async def handler ( self , query ) : [EOL] if query [ [string] ] == [string] : [EOL] channel = subscribers . get ( query [ [string] ] ) [EOL] if channel and len ( channel ) > [number] : [EOL] chanlen = len ( channel ) [EOL] channel . discard ( self . client_writer ) [EOL] newchanlen = len ( channel ) [EOL] if chanlen == newchanlen : [EOL] self . error_hander ( query , [string] ) [EOL] return False [EOL] [EOL] if newchanlen == [number] : [EOL] del subscribers [ query [ [string] ] ] [EOL] answer = { [string] : [string] , [string] : [string] , [string] : query [ [string] ] , [string] : newchanlen } [EOL] self . client_writer . write ( json . dumps ( answer ) . encode ( ) + [string] ) [EOL] return True [EOL] else : [EOL] self . error_hander ( query , [string] ) [EOL] return False [EOL] [EOL] elif query [ [string] ] == [string] : [EOL] channel = subscribers . get ( query [ [string] ] ) [EOL] if channel : [EOL] channel . add ( self . client_writer ) [EOL] else : [EOL] subscribers [ query [ [string] ] ] = set ( [ self . client_writer ] ) [EOL] [EOL] answer = { [string] : [string] , [string] : [string] , [string] : query [ [string] ] , [string] : len ( subscribers [ query [ [string] ] ] ) } [EOL] self . client_writer . write ( json . dumps ( answer ) . encode ( ) + [string] ) [EOL] return True [EOL] [EOL] elif query [ [string] ] == [string] : [EOL] channel = subscribers . get ( query [ [string] ] ) [EOL] if channel : [EOL] answer = { [string] : [string] , [string] : query [ [string] ] , [string] : query [ [string] ] } [EOL] for subscriber in channel : [EOL] subscriber . write ( json . dumps ( answer ) . encode ( ) + [string] ) [EOL] else : [EOL] self . error_hander ( query , [string] ) [EOL] return False [EOL] else : [EOL] self . error_hander ( query , [string] ) [EOL] return False [EOL] [EOL] async def client_connected_cb ( self , client_reader , client_writer ) : [EOL] self . client_reader = client_reader [EOL] self . client_writer = client_writer [EOL] while True : [EOL] try : [EOL] data = await client_reader . readuntil ( separator = [string] ) [EOL] except asyncio . streams . IncompleteReadError as re : [EOL] print ( [string] ) [EOL] self . client_writer . close ( ) [EOL] for _ , channel in subscribers . items ( ) : [EOL] channel . discard ( self . client_writer ) [EOL] print ( [string] ) [EOL] break [EOL] except : [EOL] raise [EOL] else : [EOL] query = json . loads ( data [ : - [number] ] . decode ( ) ) [EOL] if query [ [string] ] == [string] : [EOL] await self . handler ( query ) [EOL] else : [EOL] self . error_hander ( query , [string] ) [EOL] self . client_writer . close ( ) [EOL] [EOL] def run ( self , host = [string] , port = [number] , loop = None ) : [EOL] coro = asyncio . start_server ( self . client_connected_cb , host = host , port = port , loop = loop ) [EOL] server = loop . run_until_complete ( coro ) [EOL] [comment] [EOL] print ( [string] . format ( server . sockets [ [number] ] . getsockname ( ) ) ) [EOL] try : [EOL] loop . run_forever ( ) [EOL] except KeyboardInterrupt : [EOL] pass [EOL] [EOL] [comment] [EOL] server . close ( ) [EOL] loop . run_until_complete ( loop . shutdown_asyncgens ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app = Exchange ( ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] app . run ( loop = loop ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Coroutine[typing.Any,typing.Any,asyncio.events.AbstractServer]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Coroutine[typing.Any,typing.Any,asyncio.events.AbstractServer]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $异步socket编程.broker.Exchange$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $异步socket编程.broker.Exchange$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 $asyncio.events.AbstractEventLoop$ 0 0
import sys [EOL] def main ( ) : [EOL] who = input ( [string] ) [EOL] sys . stdout . write ( f" [string] { who } [string] " ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] def main ( ) : [EOL] who = input ( [string] ) [EOL] print ( f" [string] { who } [string] " ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import sys [EOL] [EOL] def main ( ) : [EOL] print ( [string] ) [EOL] sys . stdin . readline ( ) [EOL] while True : [EOL] line = sys . stdin . readline ( ) [EOL] if not line : [EOL] break [EOL] who = line . strip ( ) [EOL] print ( f" [string] { who } [string] " ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0