from typing import Dict , Union , Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from util import hf_size , apply_transformation [EOL] [EOL] [EOL] class TestUtil : [EOL] def test_hf_size_zero_bytes ( self ) : [EOL] assert hf_size ( [number] ) == [string] [EOL] [EOL] def test_hf_size_string_arg ( self ) : [EOL] assert hf_size ( [string] ) == [string] [EOL] [EOL] def test_hf_format_kb ( self ) : [EOL] assert hf_size ( [number] ) == [string] [EOL] [EOL] def test_hf_format_mb ( self ) : [EOL] assert hf_size ( [number] ) == [string] [EOL] [EOL] def test_hf_format_gb ( self ) : [EOL] assert hf_size ( [number] ) == [string] [EOL] [EOL] def test_apply_transformation_nested_dict ( self ) : [EOL] data = { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] } , } , } [EOL] expected = { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] } , } , } [EOL] result = apply_transformation ( data , lambda x : str ( x ) . upper ( ) ) [EOL] assert str ( result ) == str ( expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0
from typing import List , Dict , Any , Union [EOL] import typing [EOL] import datetime [EOL] from datetime import datetime [EOL] import subprocess [EOL] [EOL] import pytest [comment] [EOL] [EOL] from api . models import FracSchedule [EOL] from sqlalchemy . exc import IntegrityError [EOL] [EOL] [EOL] @ pytest . fixture def records ( ) : [EOL] yield [ { [string] : [string] , [string] : datetime . now ( ) , [string] : datetime . now ( ) , [string] : [number] , [string] : - [number] , } , { [string] : [string] , [string] : datetime . now ( ) , [string] : datetime . now ( ) , [string] : [number] , [string] : - [number] , } , ] [EOL] [EOL] [EOL] class TestModelMixins : [EOL] def test_bulk_insert ( self , app , records ) : [EOL] [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] with app . app_context ( ) : [EOL] FracSchedule . bulk_insert ( records ) [EOL] [EOL] def test_core_insert_ignore_on_conflict ( self , app , records ) : [EOL] [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] with app . app_context ( ) : [EOL] FracSchedule . core_insert ( records , update_on_conflict = False , ignore_on_conflict = True ) [EOL] [EOL] def test_core_insert_update_on_conflict ( self , app , records ) : [EOL] [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] with app . app_context ( ) : [EOL] FracSchedule . core_insert ( records , update_on_conflict = False , ignore_on_conflict = True ) [EOL] [EOL] def test_get_pks ( self , app , records ) : [EOL] [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] with app . app_context ( ) : [EOL] FracSchedule . core_insert ( records , update_on_conflict = False , ignore_on_conflict = True ) [EOL] [EOL] pks = [ x [ [number] ] for x in FracSchedule . pks ] [EOL] expected = [ x [ [string] ] for x in records ] [EOL] assert pks == expected [EOL] [EOL] def test_bulk_merge ( self , app , records ) : [EOL] [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] with app . app_context ( ) : [EOL] FracSchedule . bulk_merge ( records ) [EOL] [EOL] pks = [ x [ [number] ] for x in FracSchedule . pks ] [EOL] expected = [ x [ [string] ] for x in records ] [EOL] assert pks == expected [EOL] [EOL] def test_persist_objects ( self , app , records ) : [EOL] [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] objs = [ FracSchedule ( ** o ) for o in records ] [EOL] with app . app_context ( ) : [EOL] FracSchedule . persist_objects ( objs ) [EOL] [EOL] pks = [ x [ [number] ] for x in FracSchedule . pks ] [EOL] expected = [ x [ [string] ] for x in records ] [EOL] assert pks == expected [EOL] [EOL] def test_core_insert_invalid_data ( self , app ) : [EOL] records = [ { [string] : [string] , [string] : datetime . now ( ) , [string] : datetime . now ( ) , [string] : [number] , [string] : - [number] , } , { [string] : [string] , [string] : datetime . now ( ) , [string] : datetime . now ( ) , [string] : [number] , [string] : - [number] , } , { [string] : [string] , [string] : datetime . now ( ) , [string] : datetime . now ( ) , [string] : [number] , [string] : - [number] , } , ] [EOL] [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] with app . app_context ( ) : [EOL] FracSchedule . core_insert ( records ) [EOL] with pytest . raises ( IntegrityError ) : [EOL] FracSchedule . bulk_insert ( records ) [EOL] [EOL] def test_get_primary_key_names ( self , app ) : [EOL] with app . app_context ( ) : [EOL] assert FracSchedule . primary_key_names ( ) == [ [string] , [string] , [string] , ] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[datetime.datetime,builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[datetime.datetime,builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[datetime.datetime,builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import datetime [EOL] from datetime import datetime [EOL] [EOL] import pytest [comment] [EOL] [EOL] from collector . parser import ( Parser , Criterion , RegexCriterion , ValueCriterion , TypeCriterion , ParserRule , ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . fixture def parser ( conf ) : [EOL] yield Parser . init ( conf . PARSER_CONFIG [ [string] ] [ [string] ] [ [string] ] , name = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def arbitrary_callable ( ) : [EOL] def return1 ( value ) : [EOL] return [number] [EOL] [EOL] yield return1 [EOL] [EOL] [EOL] @ pytest . fixture def rule ( ) : [EOL] fc = RegexCriterion ( [string] ) [EOL] ic = RegexCriterion ( [string] ) [EOL] yield ParserRule ( criteria = [ fc , ic ] , allow_partial = True ) [EOL] [EOL] [EOL] class TestParser : [EOL] def test_parse_signed_int ( self , parser ) : [EOL] inputs = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] expected = [ [number] , [number] , [number] , [number] , - [number] , - [number] , - [number] , - [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] result = [ parser . parse ( x ) for x in inputs ] [EOL] assert result == expected [EOL] [EOL] def test_parse_unsigned_int ( self , parser ) : [EOL] inputs = [ [string] , [string] ] [EOL] expected = [ [number] , [number] ] [EOL] [EOL] result = [ parser . parse ( x ) for x in inputs ] [EOL] assert result == expected [EOL] [EOL] def test_parse_signed_float ( self , parser ) : [EOL] inputs = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] expected = [ [number] , - [number] , [number] , - [number] , [number] , [number] , [number] , - [number] , - [number] , - [number] , [number] , - [number] , [number] , - [number] , ] [EOL] [EOL] result = [ parser . parse ( x ) for x in inputs ] [EOL] assert result == expected [EOL] [EOL] def test_parse_unsigned_float ( self , parser ) : [EOL] inputs = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] expected = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] result = [ parser . parse ( x ) for x in inputs ] [EOL] assert result == expected [EOL] [EOL] def test_parse_datetime ( self , parser ) : [EOL] inputs = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] expected = [ datetime ( year = [number] , month = [number] , day = [number] ) , datetime ( year = [number] , month = [number] , day = [number] ) , datetime ( year = [number] , month = [number] , day = [number] ) , datetime ( year = [number] , month = [number] , day = [number] , hour = [number] ) , datetime ( year = [number] , month = [number] , day = [number] , hour = [number] ) , ] [EOL] [EOL] result = [ parser . parse ( x ) for x in inputs ] [EOL] assert result == expected [EOL] [EOL] def test_ignore_clouded_datetime ( self , parser ) : [EOL] inputs = [ [string] , [string] , [string] , ] [EOL] assert parser . parse_many ( inputs ) == inputs [EOL] [EOL] def test_ignore_incomplete_datetime ( self , parser ) : [EOL] inputs = [ [string] ] [EOL] assert parser . parse_many ( inputs ) == inputs [EOL] [EOL] def test_parse_bool ( self , parser ) : [EOL] inputs = [ [string] , [string] , [string] , [string] ] [EOL] expected = [ True , True , False , False ] [EOL] [EOL] result = [ parser . parse ( x ) for x in inputs ] [EOL] assert result == expected [EOL] [EOL] def test_parser_repr ( self , parser ) : [EOL] repr ( parser ) [EOL] [EOL] def test_parser_rule_repr ( self , rule ) : [EOL] repr ( rule ) [EOL] [EOL] def test_try_date ( self , parser ) : [EOL] assert parser . try_date ( [string] ) == datetime ( [number] , [number] , [number] ) [EOL] [EOL] def test_try_date_handle_none ( self , parser ) : [EOL] assert parser . try_date ( None ) is None [EOL] [EOL] def test_add_rule ( self , rule ) : [EOL] parser = Parser ( rules = [ rule , rule ] ) [EOL] parser . add_rule ( rule ) [EOL] assert len ( parser . rules ) == [number] [EOL] [EOL] [EOL] class TestCriterion : [EOL] def test_criterion_repr_works ( self ) : [EOL] repr ( Criterion ( lambda x : [number] , name = [string] ) ) [EOL] [EOL] def test_regexcriterion_repr_works ( self ) : [EOL] repr ( RegexCriterion ( [string] , name = [string] ) ) [EOL] [EOL] def test_criterion_callable ( self ) : [EOL] c = Criterion ( lambda x : [number] , name = [string] ) [EOL] assert c ( [number] ) == [number] [EOL] [EOL] def test_regex_criterion ( self ) : [EOL] rc = RegexCriterion ( [string] ) [EOL] assert rc ( [string] ) is True [EOL] [EOL] def test_type_criterion_int ( self ) : [EOL] tc = TypeCriterion ( int ) [EOL] assert tc ( [number] ) is True [EOL] [EOL] def test_type_criterion_string_is_not_int ( self ) : [EOL] tc = TypeCriterion ( str ) [EOL] assert tc ( [number] ) is False [EOL] [EOL] def test_value_criterion_parse_value ( self ) : [EOL] vc = ValueCriterion ( [number] ) [EOL] assert vc ( [number] ) is True [EOL] [EOL] def test_rule_repr ( self , rule ) : [EOL] repr ( rule ) [EOL] [EOL] def test_rule_return_partials ( self , rule ) : [EOL] assert rule ( [string] , return_partials = True ) == [ True , False ] [EOL] [EOL] def test_get_match_mode ( self , rule ) : [EOL] assert rule . match_mode == [string] [EOL] [EOL] def test_toggle_match_mode ( self , rule ) : [EOL] rule . allow_partial = False [EOL] assert rule . match_mode == [string] [EOL] [EOL] def test_partial_parse ( self , rule ) : [EOL] assert rule ( [string] ) is True [EOL] assert rule ( [string] ) is True [EOL] assert rule ( [string] ) is False [EOL] assert rule ( [string] ) is False [EOL] assert rule ( [string] ) is False [EOL] assert rule ( [string] ) is False [EOL] [EOL] def test_full_parse ( self ) : [EOL] fc = RegexCriterion ( [string] ) [EOL] fc2 = RegexCriterion ( [string] ) [EOL] rule = ParserRule ( criteria = [ fc , fc2 ] , allow_partial = False ) [EOL] assert rule ( [string] ) is True [EOL] assert rule ( [string] ) is False [EOL] assert rule ( [string] ) is False [EOL] assert rule ( [string] ) is False [EOL] assert rule ( [string] ) is False [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from metrics import load , post , post_event , post_heartbeat , to_tags [EOL] [EOL] [EOL] class TestMetrics : [EOL] def test_load_datadog_lib ( self , conf ) : [EOL] conf . DATADOG_API_KEY = [string] [EOL] conf . DATADOG_APP_KEY = [string] [EOL] conf . DATADOG_Enabled = True [EOL] [EOL] load ( conf ) [EOL] [EOL] def test_dict_to_tags ( self ) : [EOL] data = { [string] : [string] , [string] : [string] , } [EOL] assert to_tags ( data ) == [ [string] , [string] ] [EOL] [EOL] def test_list_to_tags ( self ) : [EOL] data = [ [string] , [string] ] [EOL] assert to_tags ( data ) == data [EOL] [EOL] def test_comma_delimited_string_to_tags ( self ) : [EOL] data = [string] [EOL] assert to_tags ( data ) == [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import tests [EOL] import typing [EOL] import datetime [EOL] import pytest [EOL] from datetime import datetime , timedelta [EOL] import json [EOL] [EOL] from util . jsontools import ObjectEncoder , DateTimeEncoder [EOL] [EOL] [EOL] @ pytest . fixture def kv ( ) : [EOL] yield { [string] : datetime . utcfromtimestamp ( [number] ) } [EOL] [EOL] [EOL] @ pytest . fixture def datetime_encoder ( ) : [EOL] yield DateTimeEncoder ( ) [EOL] [EOL] [EOL] class TestDatetimeEncoder : [EOL] def test_encode_datetime ( self , datetime_encoder ) : [EOL] data = { [string] : datetime . utcfromtimestamp ( [number] ) } [EOL] expected = [string] [EOL] result = datetime_encoder . encode ( data ) [EOL] assert result == expected [EOL] [EOL] def test_encode_non_datetime ( self , datetime_encoder ) : [EOL] data = { [string] : [string] , [string] : [string] } [EOL] expected = [string] [EOL] result = datetime_encoder . encode ( data ) [EOL] assert result == expected [EOL] [EOL] def test_dump_datetime ( self ) : [EOL] data = { [string] : datetime . utcfromtimestamp ( [number] ) } [EOL] expected = [string] [EOL] result = json . dumps ( data , cls = DateTimeEncoder ) [EOL] assert result == expected [EOL] [EOL] def test_super_class_raise_type_error ( self , datetime_encoder ) : [EOL] with pytest . raises ( TypeError ) : [EOL] datetime_encoder . default ( [number] ) [EOL] [EOL] [EOL] class TestObjectEncoder : [EOL] def test_encode_datetime ( self ) : [EOL] data = { [string] : datetime . utcfromtimestamp ( [number] ) , [string] : [string] } [EOL] expected = [string] [comment] [EOL] result = json . dumps ( data , cls = ObjectEncoder ) [EOL] assert result == expected [EOL] [EOL] def test_encode_with_dict_attribute ( self ) : [EOL] class ObjectForEncoding : [EOL] key = [string] [EOL] [EOL] def __dict__ ( self ) : [EOL] return { [string] : self . key } [EOL] [EOL] data = { [string] : ObjectForEncoding ( ) } [EOL] expected = [string] [EOL] assert json . dumps ( data , cls = ObjectEncoder ) == expected [EOL] [EOL] def test_encode_with_to_json ( self ) : [EOL] class ObjectForEncoding : [EOL] key = [string] [EOL] [EOL] def to_json ( self ) : [EOL] return json . dumps ( { [string] : self . key } ) [EOL] [EOL] data = { [string] : ObjectForEncoding ( ) } [EOL] expected = [string] [comment] [EOL] assert json . dumps ( data , cls = ObjectEncoder ) == expected [EOL] [EOL] def test_encode_timedelta ( self ) : [EOL] data = { [string] : timedelta ( hours = [number] ) } [EOL] expected = [string] [EOL] assert json . dumps ( data , cls = ObjectEncoder ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime]$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[datetime.datetime,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[datetime.datetime,builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,tests.test_jsontools.TestObjectEncoder.test_encode_with_dict_attribute.ObjectForEncoding]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,tests.test_jsontools.TestObjectEncoder.test_encode_with_dict_attribute.ObjectForEncoding]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,tests.test_jsontools.TestObjectEncoder.test_encode_with_to_json.ObjectForEncoding]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,tests.test_jsontools.TestObjectEncoder.test_encode_with_to_json.ObjectForEncoding]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.timedelta]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.timedelta]$ 0 0 0 0 0 0 $builtins.str$ 0
from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] import config [EOL] [EOL] [EOL] class TestConfig : [EOL] def test_load_config_from_yaml_file_no_exists ( self , capsys ) : [EOL] config . safe_load_yaml ( [string] ) [EOL] captured = capsys . readouterr ( ) [EOL] assert [string] in captured . out [EOL] [EOL] def test_get_default_port_mssql ( self ) : [EOL] assert config . get_default_port ( [string] ) == [number] [EOL] [EOL] def test_get_default_driver_mssql ( self ) : [EOL] assert config . get_default_driver ( [string] ) == [string] [EOL] [EOL] def test_get_default_schema_mssql ( self ) : [EOL] assert config . get_default_schema ( [string] ) == [string] [EOL] [EOL] def test_get_default_port_postgres ( self ) : [EOL] assert config . get_default_port ( [string] ) == [number] [EOL] [EOL] def test_get_default_driver_postgres ( self ) : [EOL] assert config . get_default_driver ( [string] ) == [string] [EOL] [EOL] def test_get_default_schema_postgres ( self ) : [EOL] assert config . get_default_schema ( [string] ) == [string] [EOL] [EOL] def test_get_project_meta ( self ) : [EOL] assert config . _get_project_meta ( pyproj_path = [string] ) == { } [EOL] [EOL] def test_show_config_attrs ( self ) : [EOL] c = config . BaseConfig ( ) [EOL] assert isinstance ( c . show , dict ) [EOL] assert len ( c . show ) > [number] [comment] [EOL] [EOL] def test_get_collector_params ( self ) : [EOL] c = config . BaseConfig ( ) [EOL] assert isinstance ( c . collector_params , dict ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from util . strings import StringProcessor [EOL] [EOL] SPECIAL_CHARS = [string] [EOL] [EOL] [EOL] @ pytest . fixture def sp ( ) : [EOL] yield StringProcessor ( ) [EOL] [EOL] [EOL] class TestStringProcessor : [EOL] def test_sp_props ( self , sp ) : [EOL] assert sp . replacement == [string] [EOL] assert sp . tolower is True [EOL] assert sp . toupper is False [EOL] [EOL] def test_remove_special_chars ( self , sp ) : [EOL] s = sp . alphanum_only ( f" [string] { SPECIAL_CHARS }" ) [EOL] s = sp . fill_whitespace ( s , [string] ) [EOL] assert s == [string] [EOL] [EOL] def test_dedupe_whitespace ( self , sp ) : [EOL] assert sp . dedupe_whitespace ( [string] ) == [string] [EOL] [EOL] def test_remove_all_whitespace ( self , sp ) : [EOL] assert sp . remove_whitespace ( [string] ) == [string] [EOL] [EOL] def test_normalize_string ( self , sp ) : [EOL] assert sp . normalize ( f" [string] { SPECIAL_CHARS }" ) == [string] [EOL] [EOL] def test_normalize_string_to_int ( self , sp ) : [EOL] i = int ( sp . normalize ( f" [string] { SPECIAL_CHARS }" , int_compatable = True ) ) [EOL] assert i == [number] [EOL] [EOL] def test_replace_all_non_numeric ( self , sp ) : [EOL] assert int ( sp . numeric_only ( [string] ) ) == [number] [EOL] [EOL] def test_normalize_to_uppercase ( self ) : [EOL] sp = StringProcessor ( toupper = True ) [EOL] assert sp . normalize ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import logging [EOL] import os [EOL] import pytest [comment] [EOL] [EOL] from loggers import ( mlevel , ColorizingStreamHandler , DatadogJSONFormatter , get_formatter , config , ) [EOL] [EOL] [EOL] @ pytest . fixture def logger ( ) : [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . setLevel ( [number] ) [EOL] yield logger [EOL] [EOL] [EOL] class TestLogger : [EOL] def test_logger ( self , caplog , logger ) : [EOL] logger . info ( [string] ) [EOL] assert [string] in caplog . text [EOL] [EOL] def test_convert_qualifier_to_log_level ( self , logger ) : [EOL] assert mlevel ( [string] ) == [number] [EOL] assert mlevel ( [string] ) == [number] [EOL] assert mlevel ( [string] ) == [number] [EOL] assert mlevel ( [string] ) == [number] [EOL] assert mlevel ( [string] ) == [number] [EOL] [EOL] def test_colorized_stream_handler_nt ( self , monkeypatch , logger , caplog ) : [EOL] [EOL] handler = ColorizingStreamHandler ( ) [EOL] logger . addHandler ( handler ) [EOL] monkeypatch . setattr ( os , [string] , [string] ) [EOL] [EOL] logger . info ( [string] ) [EOL] [EOL] assert [string] in caplog . text [EOL] [EOL] def test_datadog_json_formatter ( self , logger , caplog ) : [EOL] fmt = get_formatter ( [string] ) [EOL] handler = ColorizingStreamHandler ( ) [EOL] handler . setFormatter ( fmt ) [EOL] if logger . handlers : [EOL] logger . removeHandler ( logger . handlers [ [number] ] ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] logger . info ( [string] ) [EOL] [EOL] def test_datadog_json_formatter_tracing ( self , logger , caplog ) : [EOL] fmt = DatadogJSONFormatter ( ) [EOL] fmt . trace_enabled = True [EOL] handler = ColorizingStreamHandler ( ) [EOL] handler . setFormatter ( fmt ) [EOL] if logger . handlers : [EOL] logger . removeHandler ( logger . handlers [ [number] ] ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] logger . info ( [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] import functools [EOL] [EOL] from collector import Endpoint [EOL] from flask_sqlalchemy import Model [EOL] [EOL] [EOL] @ pytest . fixture def prototype ( conf ) : [EOL] yield functools . partial ( Endpoint , name = [string] , model = [string] ) [EOL] [EOL] [EOL] class TestEndpoint : [EOL] def test_endpoint_loaded ( self , endpoint ) : [EOL] endpoint [EOL] [EOL] def test_load_from_config ( self , conf ) : [EOL] ep = Endpoint . load_from_config ( conf ) . get ( conf . FRAC_SCHEDULE_TABLE_NAME ) [EOL] assert ep . name == conf . FRAC_SCHEDULE_TABLE_NAME [EOL] [EOL] def test_model_found ( self , endpoint ) : [EOL] assert Model in endpoint . model . __mro__ [EOL] [EOL] def test_exclustions_are_valid ( self , prototype ) : [EOL] expected = [ [string] , [string] , [string] ] [EOL] ep = prototype ( exclude = expected ) [EOL] assert ep . exclude == expected [EOL] [EOL] def test_create_from_dict ( self ) : [EOL] Endpoint . from_dict ( [string] , { [string] : [string] } ) [EOL] [EOL] def test_alias_mapping_properties_are_valid ( self , prototype ) : [EOL] mappings = { [string] : { [string] : [string] , [string] : [string] , } } [EOL] ep = prototype ( mappings = mappings ) [EOL] assert ep . alias_map == mappings [ [string] ] [EOL] assert ep . mapped_aliases == list ( mappings [ [string] ] . values ( ) ) [EOL] assert ep . mapped_names == list ( mappings [ [string] ] . keys ( ) ) [EOL] [EOL] def test_known_columns_are_valid ( self , prototype ) : [EOL] mappings = { [string] : { [string] : [string] , [string] : [string] , } , } [EOL] exclusions = [ [string] , [string] ] [EOL] ep = prototype ( mappings = mappings , exclude = exclusions ) [EOL] expected = exclusions + list ( mappings [ [string] ] . keys ( ) ) [EOL] assert ep . known_columns == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0
import os [EOL] import sys [EOL] [EOL] [EOL] sys . path . append ( os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , os . pardir + [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import logging [EOL] import pytest [comment] [EOL] [EOL] from collector . downloader import Ftp , InvalidCredentialsError [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class TestsFTP : [EOL] def test_ftpserver_class ( self , ftpserver ) : [EOL] assert ftpserver . uses_TLS is False [EOL] [EOL] def test_ftpserver ( self , ftpserver ) : [EOL] logger . warning ( [string] ) [EOL] logger . warning ( ftpserver . get_login_data ( ) ) [EOL] [EOL] login = ftpserver . get_login_data ( ) [EOL] url = login [ [string] ] [EOL] username = login [ [string] ] [EOL] password = login [ [string] ] [EOL] port = login [ [string] ] [EOL] [EOL] ftp = Ftp ( url , username , password , port = port ) [EOL] ftp . list_files ( ) [EOL] [EOL] def test_load_ftp_from_config ( self , ftpserver , conf ) : [EOL] login = ftpserver . get_login_data ( ) [EOL] conf . COLLECTOR_FTP_URL = login [ [string] ] [EOL] conf . COLLECTOR_FTP_USERNAME = login [ [string] ] [EOL] conf . COLLECTOR_FTP_PASSWORD = login [ [string] ] [EOL] conf . COLLECTOR_FTP_PORT = login [ [string] ] [EOL] Ftp . from_config ( conf ) [EOL] [EOL] def test_load_ftp_from_config_bad_password ( self , ftpserver , conf ) : [EOL] login = ftpserver . get_login_data ( ) [EOL] conf . COLLECTOR_FTP_PASSWORD = [string] [EOL] conf . COLLECTOR_FTP_URL = login [ [string] ] [EOL] conf . COLLECTOR_FTP_PORT = login [ [string] ] [EOL] [EOL] with pytest . raises ( InvalidCredentialsError ) : [EOL] Ftp . from_config ( conf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def test_ftp_access_basepath ( self , ftp ) : [EOL] assert ftp . basepath == [string] [EOL] [EOL] def test_ftp_set_basepath_to_same_value ( self , ftp ) : [EOL] ftp . basepath = [string] [EOL] assert ftp . basepath == [string] [EOL] [EOL] def test_ftp_set_basepath_to_invalid_value ( self , ftpserver ) : [EOL] login = ftpserver . get_login_data ( ) [EOL] url = login [ [string] ] [EOL] username = login [ [string] ] [EOL] password = login [ [string] ] [EOL] port = login [ [string] ] [EOL] [EOL] ftp = Ftp ( url , username , password , port = port ) [EOL] with pytest . raises ( Exception ) : [EOL] ftp . basepath = [string] [EOL] [EOL] def test_check_credentials_all_present ( self , ftp , conf ) : [EOL] creds = conf . with_prefix ( [string] ) [EOL] ftp . check_connection_details ( creds ) [EOL] [EOL] def test_missing_credentials ( self , ftp , conf ) : [EOL] creds = conf . with_prefix ( [string] ) [EOL] creds [ [string] ] = None [EOL] creds [ [string] ] = None [EOL] with pytest . raises ( InvalidCredentialsError ) : [EOL] ftp . check_connection_details ( creds ) [EOL] [EOL] def test_ftp_upload ( self , ftp , tmpdir ) : [EOL] path = tmpdir . mkdir ( [string] ) . join ( [string] ) [EOL] path . write ( [string] ) [EOL] dest = [string] [EOL] result = ftp . upload ( path , to = dest ) [EOL] assert result == { [string] : dest , [string] : str ( path ) , [string] : [string] } [EOL] [EOL] def test_ftp_upload_file_no_exist ( self , ftp ) : [EOL] result = ftp . upload ( [string] , to = [string] ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] def test_ftp_get_file ( self , ftp , tmpdir ) : [EOL] path = tmpdir . mkdir ( [string] ) . join ( [string] ) [EOL] path . write ( [string] ) [EOL] dest = [string] [EOL] result = ftp . upload ( path , to = dest ) [EOL] result = ftp . get ( dest ) [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] def test_ftp_get_latest_file ( self , ftp , tmpdir ) : [EOL] tempdir = tmpdir . mkdir ( [string] ) [EOL] path = tempdir . join ( [string] ) [EOL] path . write ( [string] ) [EOL] dest = [string] [EOL] result = ftp . upload ( path , to = dest ) [EOL] [EOL] path = tempdir . join ( [string] ) [EOL] path . write ( [string] ) [EOL] dest = [string] [EOL] result = ftp . upload ( path , to = dest ) [EOL] [EOL] result = ftp . get_latest ( ) [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] def test_ftp_cleanup ( self , ftp , tmpdir ) : [EOL] tempdir = tmpdir . mkdir ( [string] ) [EOL] path = tempdir . join ( [string] ) [EOL] path . write ( [string] ) [EOL] dest = [string] [EOL] ftp . upload ( path , to = dest ) [EOL] [EOL] path = tempdir . join ( [string] ) [EOL] path . write ( [string] ) [EOL] dest = [string] [EOL] ftp . upload ( path , to = dest ) [EOL] [EOL] ftp . cleanup ( ) [EOL] assert len ( ftp . list_files ( ) ) == [number] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import logging [EOL] import typing [EOL] import logging [EOL] import pytest [comment] [EOL] from datetime import datetime [EOL] [EOL] from collector . yammler import Yammler [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ pytest . fixture def tmpyaml ( tmpdir ) : [EOL] path = tmpdir . mkdir ( [string] ) . join ( [string] ) [EOL] path . write ( [string] ) [EOL] yield path [EOL] [EOL] [EOL] class TestYammler : [EOL] def test_load_yaml ( self , tmpyaml ) : [EOL] [EOL] expected = { [string] : { [string] : True , [string] : [string] , [string] : True , } } [EOL] [EOL] yml = Yammler ( str ( tmpyaml ) ) [EOL] assert yml . fspath == str ( tmpyaml ) [EOL] assert yml [ [string] ] == expected [EOL] [EOL] def test_dump_to_file ( self , tmpdir ) : [EOL] path = tmpdir . mkdir ( [string] ) . join ( [string] ) [EOL] yml = Yammler ( str ( path ) , { [string] : [string] } ) [EOL] yml . dump ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def test_stamp ( self , tmpdir ) : [EOL] path = tmpdir . mkdir ( [string] ) . join ( [string] ) [EOL] yml = Yammler ( str ( path ) , { } ) [EOL] assert isinstance ( yml . stamp ( ) , datetime ) [EOL] [EOL] def test_generic_context_manager ( self , tmpyaml ) : [EOL] with Yammler . context ( tmpyaml ) as f : [EOL] f [ [string] ] = [string] [EOL] [EOL] [comment] [EOL] with Yammler . context ( tmpyaml ) as f : [EOL] assert f [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import pytest [comment] [EOL] import subprocess [EOL] import logging [EOL] [EOL] import sqlalchemy [EOL] from sqlalchemy import MetaData [EOL] [EOL] import manage [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ pytest . fixture def table_names ( conf ) : [EOL] db_url = conf . SQLALCHEMY_DATABASE_URI [EOL] engine = sqlalchemy . create_engine ( db_url ) [EOL] [EOL] m = MetaData ( ) [EOL] m . reflect ( engine , views = True ) [EOL] [EOL] tables = m . tables . values ( ) [EOL] [EOL] table_names = [ x . name for x in tables ] [EOL] yield table_names [EOL] [EOL] [EOL] class TestManage : [EOL] def test_endpoints_command ( self ) : [EOL] output = subprocess . check_output ( [ [string] , [string] ] , universal_newlines = True ) [EOL] output = output . replace ( [string] , [string] ) [EOL] assert output == [string] [EOL] [EOL] def test_run_collector_command ( self , ftpserver , monkeypatch ) : [EOL] login = ftpserver . get_login_data ( ) [EOL] url = login [ [string] ] [EOL] username = login [ [string] ] [EOL] password = login [ [string] ] [EOL] port = login [ [string] ] [EOL] monkeypatch . setenv ( [string] , url ) [EOL] monkeypatch . setenv ( [string] , port ) [EOL] monkeypatch . setenv ( [string] , username ) [EOL] monkeypatch . setenv ( [string] , password ) [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] subprocess . check_output ( [ [string] , [string] , [string] ] , universal_newlines = True ) [EOL] [EOL] def test_db_init ( self ) : [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] [EOL] db_url = manage . conf . SQLALCHEMY_DATABASE_URI [EOL] engine = sqlalchemy . create_engine ( db_url ) [EOL] [EOL] m = MetaData ( ) [EOL] m . reflect ( engine , views = True ) [EOL] [EOL] tables = m . tables . values ( ) [EOL] [EOL] table_names = [ x . name for x in tables ] [EOL] [EOL] assert manage . conf . FRAC_SCHEDULE_TABLE_NAME in table_names [EOL] assert ( f"{ manage . conf . FRAC_SCHEDULE_TABLE_NAME } [string] " in table_names ) [EOL] [EOL] def test_db_recreate ( self ) : [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] [EOL] db_url = manage . conf . SQLALCHEMY_DATABASE_URI [EOL] engine = sqlalchemy . create_engine ( db_url ) [EOL] [EOL] m = MetaData ( ) [EOL] m . reflect ( engine , views = True ) [EOL] [EOL] tables = m . tables . values ( ) [EOL] [EOL] table_names = [ x . name for x in tables ] [EOL] [EOL] assert manage . conf . FRAC_SCHEDULE_TABLE_NAME in table_names [EOL] assert ( f"{ manage . conf . FRAC_SCHEDULE_TABLE_NAME } [string] " in table_names ) [EOL] [EOL] def test_run_cli ( self ) : [EOL] subprocess . run ( [ [string] ] ) [EOL] [EOL] def test_print_hr ( self ) : [EOL] manage . hr ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import pytest [EOL] [EOL] import logging [EOL] from collector import Endpoint [EOL] from collector . downloader import Ftp [EOL] [EOL] from fracx import create_app [EOL] from config import TestingConfig [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ pytest . fixture def conf ( ) : [EOL] conf = TestingConfig ( ) [EOL] conf . SQLALCHEMY_DATABASE_URI = [string] [EOL] yield conf [EOL] [EOL] [EOL] @ pytest . fixture def app ( ) : [EOL] app = create_app ( ) [EOL] return app [EOL] [EOL] [EOL] @ pytest . fixture def endpoint ( conf ) : [EOL] yield Endpoint ( name = [string] , model = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def ftp ( ftpserver ) : [EOL] login = ftpserver . get_login_data ( ) [EOL] url = login [ [string] ] [EOL] username = login [ [string] ] [EOL] password = login [ [string] ] [EOL] port = login [ [string] ] [EOL] [EOL] ftp = Ftp ( url , username , password , port = port ) [EOL] yield ftp [EOL] [EOL] [comment] [EOL] try : [EOL] if ftp . sock is not None : [EOL] try : [EOL] ftp . quit ( ) [EOL] except Exception as e : [EOL] logger . error ( f" [string] { e }" ) [EOL] finally : [EOL] ftp . close ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , Pattern , Match , Optional [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] import os [EOL] import re [EOL] import subprocess [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] [EOL] import tomlkit [EOL] [EOL] SRC_FOLDER = [string] [EOL] PROJECT_ROOT = Path ( [string] ) . resolve ( ) [EOL] GITHUB_API_ENDPOINT = ( subprocess . check_output ( [ [string] , [string] , [string] , [string] ] ) . decode ( [string] ) . strip ( ) ) [EOL] [EOL] [EOL] def project_meta ( ) : [EOL] pyproj_path = f"{ PROJECT_ROOT } [string] " [EOL] if os . path . exists ( pyproj_path ) : [EOL] with open ( pyproj_path , [string] ) as pyproject : [EOL] file_contents = pyproject . read ( ) [EOL] return tomlkit . parse ( file_contents ) [ [string] ] [ [string] ] [EOL] else : [EOL] return { } [EOL] [EOL] [EOL] PKG_META = project_meta ( ) [EOL] PROJECT_NAME = PKG_META . get ( [string] ) [EOL] PROJECT_VERSION = PKG_META . get ( [string] ) [EOL] [EOL] [EOL] def set_version ( ) : [EOL] [docstring] [EOL] [EOL] print ( f" [string] { PROJECT_VERSION } [string] " ) [EOL] [EOL] [comment] [EOL] versionfile = PROJECT_ROOT / SRC_FOLDER / [string] [EOL] with open ( versionfile , [string] ) as f : [EOL] print ( f" [string] { versionfile }" ) [EOL] f . write ( f' [string] { PROJECT_VERSION } [string] ' ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] with open ( PROJECT_ROOT / [string] , [string] ) as f : [EOL] changelog = f . read ( ) [EOL] [EOL] wip_anchor = [string] [EOL] [EOL] [comment] [EOL] wip_regex = re . compile ( wip_anchor + [string] , re . MULTILINE | re . DOTALL ) [EOL] match = wip_regex . search ( changelog ) [EOL] if not match : [EOL] print ( f" [string] { wip_anchor } [string] " ) [EOL] return [EOL] [EOL] [comment] [EOL] changes = match . group ( [number] ) [EOL] today = datetime . now ( ) . strftime ( [string] ) [EOL] changelog = wip_regex . sub ( wip_anchor + [string] + f" [string] { PROJECT_VERSION } [string] { today } [string] { changes }" , changelog , count = [number] , ) [EOL] [EOL] [comment] [EOL] with open ( PROJECT_ROOT / [string] , [string] ) as f : [EOL] f . write ( changelog ) [EOL] [EOL] print ( [string] ) [EOL] subprocess . run ( [ [string] , [string] , [string] ] ) [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] subprocess . run ( [ [string] , [string] , [string] , f" [string] { PROJECT_VERSION }" ] ) [EOL] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def publish ( ) : [EOL] [docstring] [EOL] [EOL] print ( f" [string] { PROJECT_VERSION }" ) [EOL] [EOL] print ( [string] ) [EOL] subprocess . run ( [ [string] , [string] , [string] , f"{ PROJECT_VERSION }" , [string] , f"{ PROJECT_VERSION }" ] ) [EOL] [EOL] print ( [string] ) [EOL] subprocess . run ( [ [string] , [string] , [string] ] , check = True ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] set_version ( ) [EOL] publish ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Union , Any , List [EOL] import typing [EOL] import builtins [EOL] import json [EOL] import os [EOL] [EOL] import boto3 [EOL] import tomlkit [EOL] [EOL] [EOL] def get_project_meta ( ) : [EOL] pyproj_path = [string] [EOL] if os . path . exists ( pyproj_path ) : [EOL] with open ( pyproj_path , [string] ) as pyproject : [EOL] file_contents = pyproject . read ( ) [EOL] return tomlkit . parse ( file_contents ) [ [string] ] [ [string] ] [EOL] else : [EOL] return { } [EOL] [EOL] [EOL] account_id = boto3 . client ( [string] ) . get_caller_identity ( ) . get ( [string] ) [EOL] [EOL] pkg_meta = get_project_meta ( ) [EOL] project = pkg_meta . get ( [string] ) [EOL] version = pkg_meta . get ( [string] ) [EOL] [EOL] iam = boto3 . client ( [string] ) [EOL] [EOL] path = [string] [EOL] role_name = f"{ project } [string] " [EOL] description = f" [string] { project }" [EOL] [EOL] trust_policy = { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : { [string] : [string] } , [string] : [string] , } ] , } [EOL] [EOL] policy_name = f"{ project } [string] " [EOL] policy_arn = f" [string] { account_id } [string] { policy_name }" [EOL] policy = { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ f" [string] { project } [string] " , [string] , ] , } , { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , ] , [string] : f" [string] { account_id } [string] { os . getenv ( [string] ) }" , } , { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [ f" [string] { account_id } [string] { os . getenv ( [string] ) }" , f" [string] { account_id } [string] { os . getenv ( [string] ) }" , ] , } , ] , } [EOL] [EOL] tags = [ { [string] : [string] , [string] : project } ] [EOL] [EOL] try : [EOL] role = iam . create_role ( Path = path , RoleName = role_name , AssumeRolePolicyDocument = json . dumps ( trust_policy ) , Description = description , MaxSessionDuration = [number] , Tags = tags , ) [EOL] except : [EOL] role = iam . get_role ( RoleName = role_name ) [EOL] [EOL] try : [EOL] policy_response = iam . create_policy ( PolicyName = policy_name , PolicyDocument = json . dumps ( policy ) ) [EOL] except : [EOL] policy_response = iam . create_policy_version ( PolicyArn = policy_arn , PolicyDocument = json . dumps ( policy ) ) [EOL] [EOL] iam . attach_role_policy ( PolicyArn = policy_arn , RoleName = role_name ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Type , Dict , List , Any , Union , Literal [EOL] import builtins [EOL] import attrdict [EOL] import typing [EOL] import typing_extensions [EOL] import src [EOL] import sqlalchemy [EOL] import sys [EOL] import logging [EOL] import os [EOL] import socket [EOL] import shutil [EOL] [EOL] import tomlkit [EOL] import yaml [EOL] from attrdict import AttrDict [EOL] from sqlalchemy . engine . url import URL [EOL] import pandas as pd [EOL] [EOL] _pg_aliases = [ [string] , [string] , [string] , [string] ] [EOL] _mssql_aliases = [ [string] , [string] ] [EOL] [EOL] APP_SETTINGS = os . getenv ( [string] , [string] ) [EOL] FLASK_APP = os . getenv ( [string] , [string] ) [EOL] [EOL] sys . path . append ( os . path . abspath ( os . path . join ( [string] , [string] ) ) ) [EOL] [EOL] [docstring] [EOL] pd . options . display . max_rows = None [EOL] pd . set_option ( [string] , lambda x : [string] % x ) [EOL] pd . set_option ( [string] , [string] ) [EOL] pd . set_option ( [string] , [number] ) [EOL] [EOL] try : [EOL] __file__ [EOL] except : [comment] [EOL] __file__ = [string] [EOL] [EOL] [EOL] def abs_path ( path , filename ) : [EOL] return os . path . abspath ( os . path . join ( path , filename ) ) [EOL] [EOL] [EOL] def make_config_path ( path , filename ) : [EOL] [comment] [EOL] return os . path . join ( path , filename ) [EOL] [EOL] [EOL] def safe_load_yaml ( path ) : [EOL] try : [EOL] with open ( path ) as f : [EOL] return yaml . safe_load ( f ) [EOL] except FileNotFoundError as fe : [EOL] print ( f" [string] { fe }" ) [EOL] [EOL] [EOL] def get_active_config ( ) : [EOL] return globals ( ) [ APP_SETTINGS . replace ( [string] , [string] ) ] ( ) [EOL] [EOL] [EOL] def get_default_port ( driver ) : [EOL] port = None [EOL] if driver in _pg_aliases : [EOL] port = [number] [EOL] elif driver in _mssql_aliases : [EOL] port = [number] [EOL] [EOL] return port [EOL] [EOL] [EOL] def get_default_driver ( dialect ) : [EOL] driver = None [EOL] if dialect in _pg_aliases : [EOL] driver = [string] [comment] [EOL] elif dialect in _mssql_aliases : [EOL] driver = [string] [EOL] [EOL] return driver [EOL] [EOL] [EOL] def get_default_schema ( dialect ) : [EOL] driver = None [EOL] if dialect in _pg_aliases : [EOL] driver = [string] [EOL] elif dialect in _mssql_aliases : [EOL] driver = [string] [EOL] [EOL] return driver [EOL] [EOL] [EOL] def make_url ( url_params ) : [EOL] return URL ( ** url_params ) [EOL] [EOL] [EOL] def _get_project_meta ( pyproj_path = [string] ) : [EOL] if os . path . exists ( pyproj_path ) : [EOL] with open ( pyproj_path , [string] ) as pyproject : [EOL] file_contents = pyproject . read ( ) [EOL] return tomlkit . parse ( file_contents ) [ [string] ] [ [string] ] [EOL] else : [EOL] return { } [EOL] [EOL] [EOL] pkg_meta = _get_project_meta ( ) [EOL] project = pkg_meta . get ( [string] ) [EOL] version = pkg_meta . get ( [string] ) [EOL] [EOL] [EOL] class BaseConfig : [EOL] [docstring] [EOL] [EOL] FLASK_ENV = os . getenv ( [string] , [string] ) [EOL] ENV_NAME = os . getenv ( [string] , socket . gethostname ( ) ) [EOL] [EOL] [docstring] [EOL] DATADOG_ENABLED = os . getenv ( [string] , False ) [EOL] DATADOG_API_KEY = os . getenv ( [string] , None ) [EOL] DATADOG_APP_KEY = os . getenv ( [string] , None ) [EOL] [EOL] [docstring] [EOL] CONFIG_BASEPATH = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] ) [EOL] [EOL] [docstring] [EOL] COLLECTOR_CONFIG_PATH = make_config_path ( CONFIG_BASEPATH , [string] ) [EOL] COLLECTOR_CONFIG = safe_load_yaml ( COLLECTOR_CONFIG_PATH ) [EOL] COLLECTOR_FTP_URL = os . getenv ( [string] , [string] ) [EOL] COLLECTOR_FTP_PORT = os . getenv ( [string] , [string] ) [EOL] COLLECTOR_FTP_OUTPATH = os . getenv ( [string] , [string] ) [EOL] COLLECTOR_FTP_INPATH = os . getenv ( [string] , [string] ) [EOL] COLLECTOR_FTP_USERNAME = os . getenv ( [string] ) [EOL] COLLECTOR_FTP_PASSWORD = os . getenv ( [string] ) [EOL] COLLECTOR_WRITE_SIZE = int ( os . getenv ( [string] , [string] ) ) [EOL] [EOL] [docstring] [EOL] PARSER_CONFIG_PATH = abs_path ( CONFIG_BASEPATH , [string] ) [EOL] PARSER_CONFIG = safe_load_yaml ( PARSER_CONFIG_PATH ) [EOL] [EOL] [docstring] [EOL] LOG_LEVEL = os . getenv ( [string] , logging . INFO ) [EOL] LOG_FORMAT = os . getenv ( [string] , [string] ) [EOL] [EOL] [docstring] [EOL] DATABASE_DIALECT = os . getenv ( [string] , [string] ) [EOL] DATABASE_DRIVER = os . getenv ( [string] , get_default_driver ( DATABASE_DIALECT ) ) [EOL] DATABASE_USERNAME = os . getenv ( [string] , [string] ) [EOL] DATABASE_PASSWORD = os . getenv ( [string] , [string] ) [EOL] DATABASE_HOST = os . getenv ( [string] , [string] ) [EOL] DATABASE_PORT = os . getenv ( [string] , get_default_port ( DATABASE_DRIVER ) ) [EOL] DATABASE_SCHEMA = os . getenv ( [string] , get_default_schema ( DATABASE_DRIVER ) ) [EOL] DATABASE_NAME = os . getenv ( [string] , [string] ) [EOL] DATABASE_URL_PARAMS = { [string] : DATABASE_DRIVER , [string] : DATABASE_USERNAME , [string] : DATABASE_PASSWORD , [string] : DATABASE_HOST , [string] : DATABASE_PORT , [string] : DATABASE_NAME , } [EOL] SQLALCHEMY_DATABASE_URI = str ( make_url ( DATABASE_URL_PARAMS ) ) [EOL] FRAC_SCHEDULE_TABLE_NAME = os . getenv ( [string] , [string] ) [EOL] [EOL] @ property def show ( self ) : [EOL] return { x : getattr ( self , x ) for x in dir ( self ) if not x . startswith ( [string] ) and x . isupper ( ) } [EOL] [EOL] @ property def collector_params ( self ) : [EOL] return self . with_prefix ( [string] ) [EOL] [EOL] @ property def datadog_params ( self ) : [EOL] return self . with_prefix ( [string] ) [EOL] [EOL] @ property def endpoints ( self ) : [EOL] return self . COLLECTOR_CONFIG . get ( [string] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] hr = [string] * shutil . get_terminal_size ( ) . columns + [string] [EOL] tpl = [string] [EOL] string = [string] [EOL] string += tpl . format ( name = [string] , value = APP_SETTINGS ) [EOL] string += tpl . format ( name = [string] , value = FLASK_APP ) [EOL] string += tpl . format ( name = [string] , value = self . FLASK_ENV ) [EOL] string += tpl . format ( name = [string] , value = make_url ( self . DATABASE_URL_PARAMS ) . __repr__ ( ) ) [EOL] string += tpl . format ( name = [string] , value = self . COLLECTOR_FTP_URL ) [EOL] return hr + string + hr [EOL] [EOL] def with_prefix ( self , kw ) : [EOL] [docstring] [EOL] if not kw . endswith ( [string] ) : [EOL] kw = kw + [string] [EOL] return { key . lower ( ) . replace ( kw . lower ( ) , [string] ) : getattr ( self , key ) for key in dir ( self ) if key . startswith ( kw . upper ( ) ) } [EOL] [EOL] [EOL] class DevelopmentConfig ( BaseConfig ) : [EOL] [docstring] [EOL] [EOL] DEBUG_TB_ENABLED = True [EOL] SECRET_KEY = os . getenv ( [string] , [string] ) [EOL] SQLALCHEMY_TRACK_MODIFICATIONS = True [EOL] [EOL] [EOL] class TestingConfig ( BaseConfig ) : [EOL] [docstring] [EOL] [EOL] TESTING = True [EOL] SQLALCHEMY_TRACK_MODIFICATIONS = False [EOL] [EOL] API_BASE_URL = [string] [EOL] [EOL] COLLECTOR_FTP_URL = [string] [EOL] COLLECTOR_FTP_PORT = [string] [EOL] COLLECTOR_FTP_OUTPATH = [string] [EOL] COLLECTOR_FTP_INPATH = [string] [EOL] COLLECTOR_FTP_USERNAME = [string] [EOL] COLLECTOR_FTP_PASSWORD = [string] [EOL] [EOL] [EOL] class CIConfig ( BaseConfig ) : [EOL] DATABASE_NAME = [string] [EOL] DATABASE_DRIVER = [string] [EOL] DATABASE_HOST = [string] [EOL] DATABASE_USERNAME = [string] [EOL] DATABASE_PORT = [number] [EOL] DATABASE_PASSWORD = [string] [EOL] DATABASE_URL_PARAMS = { [string] : DATABASE_DRIVER , [string] : DATABASE_USERNAME , [string] : DATABASE_PASSWORD , [string] : DATABASE_HOST , [string] : DATABASE_PORT , [string] : DATABASE_NAME , } [EOL] SQLALCHEMY_DATABASE_URI = str ( make_url ( DATABASE_URL_PARAMS ) ) [EOL] [EOL] [EOL] class ProductionConfig ( BaseConfig ) : [EOL] [docstring] [EOL] [EOL] SQLALCHEMY_TRACK_MODIFICATIONS = False [EOL] CELERYD_PREFETCH_MULTIPLIER = [number] [EOL] CELERYD_CONCURRENCY = [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] c = CIConfig ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import flask [EOL] import typing [EOL] import sys [EOL] import os [EOL] [EOL] sys . path . append ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] from flask import Flask [comment] [EOL] from flask_sqlalchemy import SQLAlchemy [comment] [EOL] [EOL] [EOL] import loggers [comment] [EOL] from config import APP_SETTINGS , get_active_config [comment] [EOL] [EOL] [EOL] loggers . config ( ) [EOL] [EOL] conf = get_active_config ( ) [EOL] [EOL] [comment] [EOL] db = SQLAlchemy ( ) [EOL] [EOL] [EOL] def create_app ( script_info = None ) : [EOL] app = Flask ( __name__ ) [EOL] app . config . from_object ( APP_SETTINGS ) [EOL] [EOL] [comment] [EOL] db . init_app ( app ) [EOL] [EOL] [comment] [EOL] @ app . shell_context_processor def ctx ( ) : [EOL] return { [string] : app , [string] : db } [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Type , Any , Tuple , Union , Mapping , Optional [EOL] import builtins [EOL] import typing [EOL] import types [EOL] import src [EOL] import logging [EOL] [docstring] [EOL] [EOL] import numbers [EOL] from typing import Any , Mapping , Union [EOL] import logging [EOL] import logging . config [EOL] import os [EOL] from logging import LogRecord [EOL] [EOL] import json_log_formatter [EOL] import logutils . colorize [EOL] [EOL] [EOL] from config import get_active_config [EOL] from util . jsontools import ObjectEncoder [EOL] [EOL] [EOL] conf = get_active_config ( ) [EOL] [EOL] [EOL] LOG_LEVELS = dict ( logging . _nameToLevel ) [EOL] LOG_LEVELS . update ( logging . _levelToName ) [comment] [EOL] LOG_LEVELS . update ( { str ( k ) : v for k , v in logging . _levelToName . items ( ) } ) [comment] [EOL] LOG_LEVELS . setdefault ( [string] , logging . FATAL ) [EOL] LOG_LEVELS . setdefault ( logging . FATAL , [string] ) [comment] [EOL] [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . CRITICAL ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . CRITICAL ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . CRITICAL ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . CRITICAL ) [EOL] [EOL] [EOL] def mlevel ( level ) : [EOL] [docstring] [EOL] if level and not isinstance ( level , numbers . Integral ) : [EOL] return LOG_LEVELS [ level . upper ( ) ] [EOL] return level [EOL] [EOL] [EOL] class ColorizingStreamHandler ( logutils . colorize . ColorizingStreamHandler ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] color_map = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [comment] [EOL] if os . name == [string] : [EOL] level_map = { logging . DEBUG : ( None , [string] , True ) , logging . INFO : ( None , [string] , False ) , logging . WARNING : ( None , [string] , True ) , logging . ERROR : ( None , [string] , True ) , logging . CRITICAL : ( [string] , [string] , True ) , } [EOL] else : [EOL] [docstring] [EOL] level_map = { logging . DEBUG : ( None , [string] , False ) , logging . INFO : ( None , [string] , False ) , logging . WARNING : ( None , [string] , False ) , logging . ERROR : ( None , [string] , False ) , logging . CRITICAL : ( [string] , [string] , True ) , } [EOL] [EOL] [EOL] class DatadogJSONFormatter ( json_log_formatter . JSONFormatter ) : [EOL] [docstring] [EOL] [EOL] def format ( self , record ) : [EOL] [docstring] [EOL] json_record = self . json_record ( record . getMessage ( ) , record ) [EOL] mutated_record = self . mutate_json_record ( json_record ) [EOL] [EOL] if mutated_record is None : [EOL] mutated_record = json_record [EOL] return self . to_json ( mutated_record ) [EOL] [EOL] def to_json ( self , record ) : [EOL] [docstring] [EOL] return self . json_lib . dumps ( record , cls = ObjectEncoder ) [EOL] [EOL] def json_record ( self , message , record ) : [EOL] [docstring] [EOL] record_dict = dict ( record . __dict__ ) [EOL] [EOL] record_dict [ [string] ] = message [EOL] [EOL] if [string] not in record_dict : [EOL] [comment] [EOL] record_dict [ [string] ] = int ( record . created * [number] ) [EOL] [EOL] if [string] not in record_dict : [EOL] record_dict [ [string] ] = record . levelname [EOL] [EOL] if [string] not in record_dict : [EOL] record_dict [ [string] ] = record . name [EOL] if [string] not in record_dict : [EOL] record_dict [ [string] ] = record . funcName [EOL] if [string] not in record_dict : [EOL] record_dict [ [string] ] = record . threadName [EOL] [EOL] exc_info = record . exc_info [EOL] [EOL] if exc_info : [EOL] if [string] not in record_dict : [EOL] record_dict [ [string] ] = exc_info [ [number] ] . __name__ [comment] [EOL] if [string] not in record_dict : [EOL] record_dict [ [string] ] = str ( exc_info [ [number] ] ) [EOL] if [string] not in record_dict : [EOL] record_dict [ [string] ] = self . formatException ( exc_info ) [EOL] [EOL] return record_dict [EOL] [EOL] [EOL] def get_formatter ( name ) : [EOL] formatters = { [string] : logging . Formatter ( fmt = [string] , datefmt = [string] , ) , [string] : logging . Formatter ( fmt = [string] , datefmt = [string] , ) , [string] : logging . Formatter ( fmt = [string] , datefmt = [string] ) , [string] : logging . Formatter ( fmt = [string] , datefmt = [string] ) , [string] : DatadogJSONFormatter ( ) , } [EOL] return formatters [ name or [string] ] [comment] [EOL] [EOL] [EOL] def config ( level = None , formatter = None , logger = None ) : [EOL] [EOL] root_logger = logger or logging . getLogger ( ) [EOL] root_logger . setLevel ( mlevel ( conf . LOG_LEVEL ) or level or [number] ) [EOL] console_handler = ColorizingStreamHandler ( ) [EOL] console_handler . setFormatter ( get_formatter ( formatter or conf . LOG_FORMAT ) ) [EOL] if root_logger . handlers : [EOL] root_logger . removeHandler ( root_logger . handlers [ [number] ] ) [EOL] root_logger . addHandler ( console_handler ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] config ( formatter = [string] ) [EOL] logger = logging . getLogger ( ) [EOL] logger . debug ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . warning ( [string] ) [EOL] logger . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Tuple[typing.Optional[builtins.str],builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Tuple[typing.Optional[builtins.str],builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $logging.LogRecord$ 0 0 0 0 0 $logging.LogRecord$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $logging.LogRecord$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $logging.LogRecord$ 0 0 0 0 $typing.Union[None,typing.Tuple[None,None,None],typing.Tuple[typing.Type[typing.Any],builtins.BaseException,typing.Optional[types.TracebackType]]]$ 0 $logging.LogRecord$ 0 $typing.Union[None,typing.Tuple[None,None,None],typing.Tuple[typing.Type[typing.Any],builtins.BaseException,typing.Optional[types.TracebackType]]]$ 0 0 0 $typing.Union[None,typing.Tuple[None,None,None],typing.Tuple[typing.Type[typing.Any],builtins.BaseException,typing.Optional[types.TracebackType]]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Union[None,typing.Tuple[None,None,None],typing.Tuple[typing.Type[typing.Any],builtins.BaseException,typing.Optional[types.TracebackType]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Union[None,typing.Tuple[None,None,None],typing.Tuple[typing.Type[typing.Any],builtins.BaseException,typing.Optional[types.TracebackType]]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Union[None,typing.Tuple[None,None,None],typing.Tuple[typing.Type[typing.Any],builtins.BaseException,typing.Optional[types.TracebackType]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from fracx import create_app [EOL] [EOL] [EOL] [comment] [EOL] application = create_app ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import List , Dict , Any , Union [EOL] import flask [EOL] import logging [EOL] import typing [EOL] import logging [EOL] import os [EOL] import shutil [EOL] import sys [EOL] [EOL] import click [EOL] from flask . cli import AppGroup , FlaskGroup [EOL] import sqlalchemy [EOL] [EOL] from collector import BytesFileHandler , Endpoint , FracScheduleCollector , Ftp [EOL] from config import get_active_config [EOL] from fracx import create_app [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] CONTEXT_SETTINGS = dict ( help_option_names = [ [string] , [string] ] , ignore_unknown_options = False ) [EOL] [EOL] conf = get_active_config ( ) [EOL] [EOL] app = create_app ( ) [EOL] cli = FlaskGroup ( create_app = create_app , context_settings = CONTEXT_SETTINGS ) [EOL] run_cli = AppGroup ( [string] ) [EOL] db_cli = AppGroup ( [string] ) [EOL] test_cli = AppGroup ( [string] ) [EOL] [EOL] [EOL] def get_terminal_columns ( ) : [EOL] return shutil . get_terminal_size ( ) . columns [EOL] [EOL] [EOL] def hr ( ) : [EOL] return [string] * get_terminal_columns ( ) [EOL] [EOL] [EOL] @ run_cli . command ( ) @ click . option ( [string] , [string] , [string] , help = [string] , show_default = True , default = True , ) @ click . option ( [string] , [string] , [string] , help = [string] , show_default = True , is_flag = True , ) @ click . option ( [string] , [string] , [string] , help = f" [string] " , is_flag = True , ) def collector ( update_on_conflict , ignore_on_conflict , use_existing ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] logger . info ( conf ) [EOL] [EOL] endpoint = Endpoint . load_from_config ( conf ) [ [string] ] [EOL] collector = FracScheduleCollector ( endpoint ) [EOL] [EOL] ftp = Ftp . from_config ( ) [EOL] latest = ftp . get_latest ( ) [EOL] [EOL] rows = BytesFileHandler . xlsx ( latest . get ( [string] ) , date_columns = endpoint . mappings . get ( [string] ) , sheet_no = [number] ) [EOL] [EOL] rows = list ( rows ) [EOL] [EOL] rows = [ collector . transform ( row ) for row in rows ] [EOL] [EOL] _ = [ collector . persist ( [ row ] ) for row in rows ] [EOL] [EOL] collector . collect ( rows , update_on_conflict , ignore_on_conflict ) [EOL] [EOL] ftp . cleanup ( ) [EOL] [EOL] [EOL] @ cli . command ( ) def endpoints ( ) : [EOL] from collector import Endpoint [EOL] [EOL] for name , ep in Endpoint . load_from_config ( conf ) . items ( ) : [EOL] click . secho ( name ) [EOL] [EOL] [EOL] @ cli . command ( ) def show ( ) : [EOL] import yaml [EOL] [EOL] yaml . safe_dump ( conf . show , sys . stdout ) [EOL] [EOL] [EOL] @ db_cli . command ( ) def init ( c = None ) : [EOL] c = c or conf [EOL] db_url = c . SQLALCHEMY_DATABASE_URI [EOL] basepath = os . path . dirname ( __file__ ) [EOL] if c . DATABASE_DRIVER == [string] : [EOL] filename = f"{ c . CONFIG_BASEPATH } [string] " [EOL] elif [string] in c . DATABASE_DRIVER : [EOL] filename = f"{ c . CONFIG_BASEPATH } [string] " [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] with open ( os . path . join ( basepath , filename ) ) as f : [EOL] contents = f . read ( ) [EOL] [EOL] engine = sqlalchemy . create_engine ( db_url ) [EOL] [EOL] contents = contents . format ( TABLE_NAME = c . FRAC_SCHEDULE_TABLE_NAME , DATABASE_SCHEMA = c . DATABASE_SCHEMA ) [EOL] stmts = [ sqlalchemy . text ( x ) for x in contents . split ( [string] ) ] [comment] [EOL] [EOL] try : [EOL] for s in stmts : [EOL] engine . execute ( s ) [EOL] logger . info ( [string] ) [EOL] except Exception as e : [EOL] logger . error ( f" [string] { e }" ) [EOL] [EOL] [EOL] @ db_cli . command ( ) @ click . pass_context def recreate ( ctx ) : [EOL] [EOL] db_url = conf . SQLALCHEMY_DATABASE_URI [EOL] engine = sqlalchemy . create_engine ( db_url ) [EOL] engine . execute ( f" [string] { conf . FRAC_SCHEDULE_TABLE_NAME } [string] " ) [EOL] engine . execute ( f" [string] { conf . FRAC_SCHEDULE_TABLE_NAME } [string] " ) [EOL] ctx . invoke ( init ) [EOL] [EOL] [EOL] def main ( argv = sys . argv ) : [EOL] [docstring] [EOL] [EOL] cli ( ) [EOL] return [number] [EOL] [EOL] [EOL] cli . add_command ( run_cli ) [EOL] cli . add_command ( db_cli ) [EOL] [EOL] if __name__ == [string] : [EOL] cli ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.cli.FlaskGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $flask.cli.FlaskGroup$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.bool]]$ 0 0 $flask.cli.AppGroup$ 0 0 0 0 0 0 $flask.cli.AppGroup$ 0 0 0 0 0 0 $flask.cli.AppGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.cli.AppGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.cli.FlaskGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.cli.FlaskGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $flask.cli.AppGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.cli.AppGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.cli.FlaskGroup$ 0 0 0 0 0 0 0 0 $flask.cli.FlaskGroup$ 0 0 0 $flask.cli.AppGroup$ 0 0 $flask.cli.FlaskGroup$ 0 0 0 $flask.cli.AppGroup$ 0 0 0 0 0 0 0 0 0 $flask.cli.FlaskGroup$ 0 0 0
[docstring] [EOL] import sys [EOL] [EOL] from manage import main [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Type , List , Any , Union , Iterable [EOL] import collector [EOL] import builtins [EOL] import typing [EOL] import src [EOL] import logging [EOL] import flask_sqlalchemy [EOL] from typing import Dict , List , Union , Iterable [EOL] import logging [EOL] [EOL] from flask_sqlalchemy import Model [EOL] [EOL] [EOL] from api . models import * [comment] [EOL] from collector . endpoint import Endpoint [EOL] from collector . transformer import Transformer [EOL] from config import get_active_config [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] conf = get_active_config ( ) [EOL] [EOL] [EOL] class Collector ( object ) : [EOL] [docstring] [EOL] [EOL] _tf = None [EOL] _functions = None [EOL] _model = None [EOL] [EOL] def __init__ ( self , endpoint , functions = None , ) : [EOL] self . endpoint = endpoint [EOL] self . _functions = functions [EOL] [EOL] @ property def functions ( self ) : [EOL] if self . _functions is None : [EOL] self . _functions = conf . functions [EOL] return self . _functions [EOL] [EOL] @ property def model ( self ) : [EOL] if self . _model is None : [EOL] self . _model = self . endpoint . model [EOL] return self . _model [EOL] [EOL] @ property def tf ( self ) : [EOL] if self . _tf is None : [EOL] self . _tf = Transformer ( aliases = self . endpoint . mappings . get ( [string] , { } ) , exclude = self . endpoint . exclude , ignore_unknown = self . endpoint . ignore_unknown , ) [EOL] return self . _tf [EOL] [EOL] def transform ( self , data ) : [EOL] return self . tf . transform ( data ) [EOL] [EOL] [EOL] class FracScheduleCollector ( Collector ) : [EOL] def collect ( self , iterable , update_on_conflict = True , ignore_on_conflict = False , ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] self . persist ( [ x for x in iterable ] ) [EOL] [EOL] def persist ( self , rows , update_on_conflict = True , ignore_on_conflict = False , ) : [EOL] if [string] in conf . DATABASE_DRIVER : [EOL] self . model . bulk_merge ( rows ) [EOL] else : [EOL] self . model . core_insert ( rows , update_on_conflict = update_on_conflict , ignore_on_conflict = ignore_on_conflict , ) [EOL] rows = [ ] [EOL] [EOL] def filter ( self , row ) : [EOL] if row . get ( [string] ) and row . get ( [string] ) : [EOL] return row [EOL] else : [EOL] return None [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] from fracx import create_app [EOL] [EOL] app = create_app ( ) [EOL] app . app_context ( ) . push ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Union[builtins.str,None],typing.Union[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Union[builtins.str,None],typing.Union[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask_sqlalchemy.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 $typing.Union[typing.Dict,None]$ 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Generator , Any , Union [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] from typing import Generator , Dict , List , Union [EOL] from datetime import datetime [EOL] import logging [EOL] [EOL] import xlrd [EOL] from util import StringProcessor [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] sp = StringProcessor ( ) [EOL] [EOL] [EOL] class BytesFileHandler : [EOL] @ classmethod def xlsx ( cls , content , sheet_no = [number] , date_columns = None ) : [EOL] [docstring] [EOL] date_columns = date_columns or [ ] [EOL] [EOL] try : [EOL] sheet = xlrd . open_workbook ( file_contents = content ) . sheet_by_index ( sheet_no ) [EOL] [EOL] keys = sheet . row_values ( [number] ) [EOL] keys = [ sp . normalize ( x ) for x in keys ] [EOL] [EOL] for idx in range ( [number] , sheet . nrows ) : [EOL] result = dict ( zip ( keys , sheet . row_values ( idx ) ) ) [EOL] for dc in date_columns : [EOL] value = result . get ( dc ) [EOL] [comment] [EOL] result [ dc ] = cls . _parse_excel_date ( value , sheet . book . datemode ) [EOL] [EOL] yield result [EOL] except TypeError as te : [EOL] logger . error ( f" [string] { te }" ) [EOL] yield { } [EOL] [EOL] @ classmethod def _parse_excel_date ( cls , value , date_mode = [number] ) : [EOL] if value : [EOL] return datetime ( * xlrd . xldate_as_tuple ( value , date_mode ) ) [EOL] else : [EOL] return value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Dict,None,None]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.float,None]$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Union[builtins.float,None]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.float,None]$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Union[builtins.float,None]$ 0
[EOL] from typing import List , Dict , Any , Union , Literal [EOL] import collector [EOL] import builtins [EOL] import typing [EOL] import typing_extensions [EOL] import logging [EOL] from typing import List , Dict [EOL] [EOL] import logging [EOL] from config import get_active_config [EOL] [EOL] import util [EOL] [EOL] from collector . parser import Parser [EOL] [EOL] conf = get_active_config ( ) [EOL] [EOL] sp = util . StringProcessor ( ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class RowParser ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , aliases = None , exclude = None , normalize = False , parsers = None , ) : [EOL] self . normalize = normalize [EOL] self . aliases = aliases or { } [EOL] self . exclude = exclude or [ ] [EOL] self . parsers = parsers or [ ] [EOL] self . errors = [ ] [EOL] [EOL] def __repr__ ( self ) : [EOL] s = [string] if len ( self . parsers ) > [number] else [string] [EOL] return f" [string] { len ( self . parsers ) } [string] { s }" [EOL] [EOL] def add_parser ( self , parser = None , ruleset = None , name = None ) : [EOL] self . parsers . append ( parser or Parser . init ( ruleset , name = name ) ) [EOL] return self [EOL] [EOL] def normalize_keys ( self , data ) : [EOL] return util . apply_transformation ( data , sp . normalize , keys = True , values = False ) [EOL] [EOL] def parse_value_dtypes ( self , data ) : [EOL] for parser in self . parsers : [EOL] data = util . apply_transformation ( data , parser . parse , keys = False , values = True ) [EOL] return data [EOL] [EOL] def parse ( self , row , parse_dtypes = True , ** kwargs ) : [EOL] [comment] [EOL] if parse_dtypes : [EOL] parsed = self . parse_value_dtypes ( row ) [EOL] return parsed [EOL] [EOL] @ staticmethod def load_from_config ( parser_conf ) : [EOL] parser_conf = parser_conf . get ( [string] , parser_conf ) [EOL] parsers = [ ] [EOL] for name , parser_def in parser_conf . items ( ) : [EOL] ruleset = parser_def . get ( [string] , parser_def ) [EOL] parsers . append ( Parser . init ( ruleset , name ) ) [EOL] [EOL] return RowParser ( parsers = parsers ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] rp = RowParser . load_from_config ( conf . PARSER_CONFIG ) [EOL] [EOL] row = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] rp . parse ( row ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $collector.parser.Parser$ 0 0 0 $typing.Dict[builtins.str,typing.List]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $collector.parser.Parser$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict$ 0 0 0 $builtins.dict$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.dict$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.List[collector.parser.Parser]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[collector.parser.Parser]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[collector.parser.Parser]$ 0 $typing.List[collector.parser.Parser]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.float,builtins.str]]$ 0 0
from typing import List , Dict , Any [EOL] import builtins [EOL] import typing [EOL] import src [EOL] import logging [EOL] import flask_sqlalchemy [EOL] from typing import Dict , List [EOL] import logging [EOL] from pydoc import locate [EOL] [EOL] from attrdict import AttrDict [EOL] from flask_sqlalchemy import Model [EOL] [EOL] [EOL] from api . models import * [comment] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Endpoint ( object ) : [EOL] def __init__ ( self , name , model , version = None , path = [string] , mappings = None , url_params = None , exclude = None , options = None , normalize = False , updated_column = [string] , enabled = True , ignore_unknown = True , ** kwargs , ) : [EOL] [EOL] self . name = name [EOL] self . version = version [EOL] self . path = path [EOL] self . mappings = AttrDict ( mappings or { } ) [EOL] self . model_name = model [EOL] self . _model = None [EOL] self . updated_column = updated_column [EOL] self . url_params = url_params [EOL] self . _exclude = exclude or [ ] [EOL] self . normalize = normalize [EOL] self . options = options or [ ] [EOL] self . enabled = enabled [EOL] self . ignore_unknown = ignore_unknown [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . path [EOL] [EOL] def __iter__ ( self ) : [EOL] attrs = [ x for x in dir ( self ) if not x . startswith ( [string] ) ] [EOL] for a in attrs : [EOL] yield a , getattr ( self , a ) [EOL] [EOL] @ property def model ( self ) : [EOL] if self . _model is None : [EOL] self . _model = self . locate_model ( self . model_name ) [EOL] return self . _model [EOL] [EOL] @ property def exclude ( self ) : [EOL] return self . _exclude [EOL] [EOL] @ property def known_columns ( self ) : [EOL] return self . _exclude + self . mapped_names [EOL] [EOL] @ property def alias_map ( self ) : [EOL] return self . mappings . get ( [string] , { } ) [EOL] [EOL] @ property def mapped_names ( self ) : [EOL] return list ( self . alias_map . keys ( ) ) [EOL] [EOL] @ property def mapped_aliases ( self ) : [EOL] return list ( self . alias_map . values ( ) ) [EOL] [EOL] def locate_model ( self , model_name ) : [EOL] model = None [EOL] try : [EOL] [comment] [EOL] model = locate ( model_name ) [EOL] logger . debug ( f" [string] { model_name }" ) [EOL] except ModuleNotFoundError : [EOL] logger . debug ( f" [string] { model_name } [string] " ) [EOL] try : [EOL] [comment] [EOL] model = globals ( ) [ model_name ] [EOL] logger . debug ( f" [string] { model_name } [string] " ) [EOL] except ModuleNotFoundError : [EOL] raise ModuleNotFoundError ( f" [string] { model_name } [string] " ) [EOL] except Exception as e : [EOL] raise Exception ( f" [string] { model_name } [string] { e }" ) [EOL] [EOL] return model [EOL] [EOL] @ staticmethod def load_from_config ( app_config , load_disabled = False ) : [EOL] endpoints = { } [EOL] try : [EOL] endpoints = app_config . endpoints [comment] [EOL] except AttributeError : [EOL] raise AttributeError ( [string] ) [EOL] [EOL] loaded = { } [EOL] for ep in endpoints . items ( ) : [EOL] try : [EOL] new = Endpoint ( name = ep [ [number] ] , ** ep [ [number] ] ) [EOL] if new . enabled or load_disabled : [EOL] loaded [ ep [ [number] ] ] = new [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] except Exception as e : [EOL] logger . error ( f" [string] { ep [ [number] ] } [string] { e }" ) [EOL] [EOL] return loaded [EOL] [EOL] @ staticmethod def from_dict ( name , data ) : [EOL] return Endpoint ( name , ** data ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] from config import get_active_config [EOL] [EOL] conf = get_active_config ( ) [EOL] endpoints = conf . endpoints [EOL] [comment] [EOL] Endpoint . load_from_config ( conf ) [EOL] [EOL] [comment] [EOL] e = Endpoint ( name = [string] , ** endpoints [ [string] ] ) [EOL] e . exclude [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask_sqlalchemy.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,"Endpoint"]$ 0 $builtins.object$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.object$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Endpoint]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $src.fracx.collector.endpoint.Endpoint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.fracx.collector.endpoint.Endpoint$ 0 0 0 $builtins.bool$ 0 0 $typing.Dict[builtins.str,Endpoint]$ 0 0 0 0 0 0 0 $src.fracx.collector.endpoint.Endpoint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Endpoint]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any , IO [EOL] import src [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] from datetime import datetime [EOL] import os [EOL] import tempfile [EOL] from contextlib import contextmanager [EOL] import logging [EOL] [EOL] import yaml [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Yammler ( dict ) : [EOL] _no_dump = [ [string] ] [EOL] _metavars = [ [string] , [string] ] [EOL] _data_key = [string] [EOL] _meta_key = [string] [EOL] [EOL] def __init__ ( self , fspath , data = None ) : [EOL] self . fspath = fspath [EOL] self . changed = False [EOL] self . updated_at = self . stamp ( ) [EOL] data = { } [EOL] if os . path . exists ( fspath ) : [EOL] with open ( fspath ) as f : [EOL] data = yaml . safe_load ( f ) or { } [EOL] super ( ) . __init__ ( data ) [EOL] [EOL] def dump ( self ) : [EOL] with self . durable ( self . fspath , [string] ) as f : [EOL] yaml . safe_dump ( dict ( self ) , f , default_flow_style = False ) [EOL] [EOL] @ staticmethod def stamp ( ) : [EOL] return datetime . utcnow ( ) [EOL] [EOL] @ classmethod @ contextmanager def context ( cls , fspath ) : [EOL] obj = cls ( fspath ) [EOL] try : [EOL] yield obj [EOL] finally : [EOL] obj . dump ( ) [EOL] [EOL] @ classmethod @ contextmanager def durable ( cls , fspath , mode = [string] ) : [EOL] [docstring] [EOL] _fspath = fspath [EOL] _mode = mode [EOL] _file = tempfile . NamedTemporaryFile ( _mode , delete = False ) [EOL] [EOL] try : [EOL] yield _file [EOL] except Exception as e : [comment] [EOL] os . unlink ( _file . name ) [EOL] raise e [EOL] else : [EOL] _file . close ( ) [EOL] os . rename ( _file . name , _fspath ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.fracx.collector.yammler.Yammler$ 0 0 0 0 0 0 0 0 0 0 $src.fracx.collector.yammler.Yammler$ 0 0 0 0 $src.fracx.collector.yammler.Yammler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.IO[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.IO[typing.Any]$ 0 0 0 $builtins.str$ 0 0
[comment] [EOL] from collector . downloader import Ftp [EOL] from collector . endpoint import Endpoint [EOL] from collector . collector import Collector , FracScheduleCollector [EOL] from collector . transformer import Transformer [EOL] from collector . filehandler import BytesFileHandler [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import Dict , Type , Any , List [EOL] import builtins [EOL] import typing [EOL] import fracx [EOL] import src [EOL] import logging [EOL] import logging [EOL] from enum import Enum [EOL] from timeit import default_timer as timer [EOL] from typing import Dict , List [EOL] [EOL] from sqlalchemy . dialects . postgresql . dml import Insert [EOL] from sqlalchemy . exc import IntegrityError [EOL] from sqlalchemy . sql import func [EOL] [EOL] import metrics [EOL] import util [EOL] from util . deco import classproperty [EOL] from fracx import db [EOL] [EOL] [EOL] class Operation ( Enum ) : [EOL] INSERT = [string] [EOL] UPDATE = [string] [EOL] DELETE = [string] [EOL] MERGE = [string] [EOL] [EOL] [EOL] class TimestampMixin ( object ) : [EOL] created_at = db . Column ( db . DateTime ( timezone = True ) , default = func . now ( ) , nullable = False ) [EOL] updated_at = db . Column ( db . DateTime ( timezone = True ) , default = func . now ( ) , nullable = False ) [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class CoreMixin ( object ) : [EOL] [docstring] [EOL] [EOL] pks = None [EOL] [EOL] @ classproperty def s ( self ) : [EOL] return db . session [EOL] [EOL] @ classproperty def pks ( cls ) : [comment] [EOL] query = cls . s . query ( ) . with_entities ( * cls . primary_key_columns ( ) ) [EOL] return query . all ( ) [EOL] [EOL] @ classmethod def primary_key_columns ( cls ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] return list ( cls . __table__ . primary_key . columns ) [EOL] [EOL] @ classmethod def primary_key_names ( cls ) : [EOL] [docstring] [EOL] [EOL] return list ( cls . __table__ . primary_key . columns . keys ( ) ) [EOL] [EOL] @ classmethod def persist_objects ( cls , objects ) : [EOL] cls . s . add_all ( objects ) [EOL] cls . persist ( ) [EOL] logger . info ( f"{ cls . __table__ . name } [string] { len ( objects ) } [string] " ) [EOL] [EOL] @ classmethod def persist ( cls ) : [EOL] [docstring] [EOL] try : [EOL] cls . s . flush ( ) [EOL] cls . s . commit ( ) [EOL] except Exception as e : [EOL] logger . info ( e ) [EOL] cls . s . rollback ( ) [EOL] [EOL] @ classmethod def core_insert ( cls , records , size = None , exclude_cols = None , update_on_conflict = True , ignore_on_conflict = False , ) : [EOL] op_name = [string] [EOL] affected = [number] [EOL] size = size or len ( records ) [EOL] exclude_cols = exclude_cols or [ ] [EOL] for chunk in util . chunks ( records , size ) : [EOL] ts = timer ( ) [EOL] chunk = list ( chunk ) [EOL] stmt = Insert ( cls ) . values ( chunk ) [EOL] [EOL] [comment] [EOL] if ignore_on_conflict : [EOL] final_stmt = stmt . on_conflict_do_nothing ( constraint = cls . __table__ . primary_key ) [EOL] op_name = op_name + [string] [EOL] elif update_on_conflict : [EOL] on_conflict_update_cols = [ c . name for c in cls . __table__ . c if c not in list ( cls . __table__ . primary_key . columns ) [EOL] and c . name not in exclude_cols ] [EOL] op_name = op_name + [string] [EOL] [EOL] [comment] [EOL] final_stmt = stmt . on_conflict_do_update ( constraint = cls . __table__ . primary_key , set_ = { k : getattr ( stmt . excluded , k ) for k in on_conflict_update_cols } , ) [EOL] [EOL] else : [EOL] final_stmt = stmt [EOL] try : [EOL] cls . s . bind . engine . execute ( final_stmt ) [EOL] cls . persist ( ) [EOL] exc_time = round ( timer ( ) - ts , [number] ) [EOL] n = len ( chunk ) [EOL] cls . post_op_metrics ( Operation . INSERT , op_name , n , exc_time ) [EOL] affected += len ( records ) [EOL] [EOL] except IntegrityError as ie : [EOL] logger . warning ( ie ) [EOL] [EOL] [comment] [EOL] if len ( records ) > [number] : [EOL] first_half = records [ : len ( records ) // [number] ] [EOL] second_half = records [ len ( records ) // [number] : ] [EOL] cls . core_insert ( records = first_half , size = len ( first_half ) // [number] , update_on_conflict = update_on_conflict , ignore_on_conflict = ignore_on_conflict , ) [EOL] cls . core_insert ( records = second_half , size = len ( second_half ) // [number] , update_on_conflict = update_on_conflict , ignore_on_conflict = ignore_on_conflict , ) [EOL] except Exception as e : [EOL] logger . error ( e ) [EOL] [EOL] return affected [EOL] [EOL] @ classmethod def bulk_insert ( cls , records , size = None ) : [EOL] [EOL] affected = [number] [EOL] size = size or len ( records ) [EOL] [EOL] for chunk in util . chunks ( records , size ) : [EOL] [EOL] cls . s . bulk_insert_mappings ( cls , chunk ) [EOL] cls . persist ( ) [EOL] logger . info ( f"{ cls . __table__ . name } [string] { len ( records ) } [string] " ) [EOL] affected += len ( records ) [EOL] return affected [EOL] [EOL] @ classmethod def bulk_update ( cls , records , size = None ) : [EOL] [EOL] affected = [number] [EOL] size = size or len ( records ) [EOL] [EOL] for chunk in util . chunks ( records , size ) : [EOL] cls . s . bulk_update_mappings ( cls , chunk ) [EOL] cls . persist ( ) [EOL] logger . info ( f"{ cls . __table__ . name } [string] { len ( records ) } [string] " ) [EOL] affected += len ( records ) [EOL] return affected [EOL] [EOL] @ classmethod def bulk_merge ( cls , records , size = None ) : [EOL] affected = [number] [EOL] size = size or len ( records ) [EOL] [EOL] for chunk in util . chunks ( records , size ) : [EOL] ts = timer ( ) [EOL] chunk = list ( chunk ) [EOL] cls . s . add_all ( [ cls . s . merge ( cls ( ** row ) ) for row in chunk ] ) [EOL] cls . persist ( ) [EOL] exc_time = round ( timer ( ) - ts , [number] ) [EOL] n = len ( chunk ) [EOL] cls . post_op_metrics ( Operation . MERGE , [string] , n , exc_time ) [EOL] affected += len ( records ) [EOL] [EOL] return affected [EOL] [EOL] @ classmethod def post_op_metrics ( cls , method_type , method , n , exc_time ) : [EOL] op_name = method_type . name . lower ( ) [EOL] tags = { [string] : cls . __table__ . name , [string] : method } [EOL] measurements = { f"{ op_name } [string] " : n , f"{ op_name } [string] " : exc_time , f"{ op_name } [string] " : n / exc_time or [number] , } [EOL] [EOL] for key , value in measurements . items ( ) : [EOL] metrics . post ( key , value , tags = tags ) [EOL] [EOL] logger . info ( f"{ cls . __table__ . name } [string] { method } [string] { op_name } [string] { n } [string] { exc_time } [string] " , extra = measurements , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.fracx.api.mixins.TimestampMixin]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.fracx.api.mixins.TimestampMixin]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.fracx.api.mixins.CoreMixin]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.tuple]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[fracx.db.Model]$ 0 0 0 0 0 0 0 0 0 $typing.List[fracx.db.Model]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[fracx.db.Model]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict]$ 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $typing.List[typing.Dict]$ 0 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $typing.List[typing.Dict]$ 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Dict]$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $Operation$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.float$ 0 0 0 $builtins.str$ 0 $Operation$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import Dict , Type , Any [EOL] import typing [EOL] from typing import Any [EOL] import json [EOL] from datetime import datetime , date , timedelta [EOL] [EOL] [EOL] class DateTimeEncoder ( json . JSONEncoder ) : [EOL] def default ( self , obj ) : [EOL] if isinstance ( obj , ( datetime , date ) ) : [EOL] return obj . isoformat ( ) [EOL] return super ( DateTimeEncoder , self ) . default ( obj ) [EOL] [EOL] [EOL] class ObjectEncoder ( json . JSONEncoder ) : [EOL] [docstring] [EOL] [EOL] def default ( self , obj ) : [EOL] [docstring] [EOL] if hasattr ( obj , [string] ) : [EOL] return self . default ( obj . to_json ( ) ) [EOL] elif hasattr ( obj , [string] ) : [EOL] return obj . __class__ . __name__ [EOL] elif hasattr ( obj , [string] ) : [EOL] return [string] [EOL] elif isinstance ( obj , timedelta ) : [EOL] return obj . __str__ ( ) [EOL] else : [EOL] [comment] [EOL] cls = type ( obj ) [EOL] result = { [string] : True , [string] : cls . __module__ , [string] : cls . __name__ , } [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0
from typing import Dict , Callable , Generator , Any , Iterator , Tuple , Union , Iterable , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import builtins [EOL] from typing import Callable , Union , Iterable , Generator , Dict [EOL] import math [EOL] import itertools [EOL] [EOL] from util . strings import StringProcessor [comment] [EOL] from util . exc import RootException [comment] [EOL] [EOL] [EOL] def hf_size ( size_bytes ) : [EOL] [docstring] [comment] [EOL] if size_bytes == [number] : [EOL] return [string] [EOL] [EOL] suffixes = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] if isinstance ( size_bytes , str ) : [EOL] size_bytes = int ( size_bytes ) [EOL] [EOL] i = int ( math . floor ( math . log ( size_bytes , [number] ) ) ) [EOL] p = math . pow ( [number] , i ) [EOL] s = round ( size_bytes / p , [number] ) [EOL] return f"{ s } [string] { suffixes [ i ] }" [EOL] [EOL] [EOL] def chunks ( iterable , n = [number] ) : [EOL] [docstring] [EOL] it = iter ( iterable ) [EOL] while True : [EOL] chunk_it = itertools . islice ( it , n ) [EOL] try : [EOL] first_el = next ( chunk_it ) [EOL] except StopIteration : [EOL] return [EOL] yield itertools . chain ( ( first_el , ) , chunk_it ) [EOL] [EOL] [EOL] def apply_transformation ( data , convert , keys = False , values = True ) : [EOL] [docstring] [EOL] if isinstance ( data , ( str , int , float ) ) : [EOL] if values : [EOL] return convert ( data ) [EOL] else : [EOL] return data [EOL] if isinstance ( data , dict ) : [EOL] new = data . __class__ ( ) [EOL] for k , v in data . items ( ) : [EOL] if keys : [EOL] new [ convert ( k ) ] = apply_transformation ( v , convert , keys , values ) [EOL] else : [EOL] new [ k ] = apply_transformation ( v , convert , keys , values ) [EOL] elif isinstance ( data , ( list , set , tuple ) ) : [EOL] new = data . __class__ ( apply_transformation ( v , convert , keys , values ) for v in data ) [EOL] else : [EOL] return data [EOL] return new [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import src [EOL] import typing [EOL] import builtins [EOL] import re [EOL] [EOL] [EOL] class StringProcessor : [EOL] re_ws = re . compile ( [string] ) [EOL] re_dup_ws = re . compile ( [string] ) [EOL] re_non_alphanum = re . compile ( [string] ) [EOL] re_non_num = re . compile ( [string] ) [EOL] replacement = [string] [EOL] tolower = True [EOL] [EOL] def __init__ ( self , replacement = [string] , tolower = True , toupper = False ) : [EOL] [EOL] self . replacement = replacement [EOL] self . tolower = tolower [EOL] self . toupper = toupper [EOL] [EOL] def alphanum_only ( self , s ) : [EOL] [docstring] [EOL] [EOL] return self . re_non_alphanum . sub ( [string] , s ) [EOL] [EOL] def numeric_only ( self , s ) : [EOL] [docstring] [EOL] [EOL] return self . re_non_num . sub ( [string] , s ) [EOL] [EOL] def dedupe_whitespace ( self , s ) : [EOL] [docstring] [EOL] return self . re_dup_ws . sub ( [string] , s ) [EOL] [EOL] def remove_whitespace ( self , s ) : [EOL] [docstring] [EOL] return self . re_ws . sub ( [string] , s ) [EOL] [EOL] def fill_whitespace ( self , s , replacement = None ) : [EOL] replacement = replacement if replacement is not None else self . replacement [EOL] return s . replace ( [string] , replacement ) [EOL] [EOL] def normalize ( self , s , int_compatable = False ) : [EOL] [docstring] [EOL] [EOL] if s is not None : [EOL] s = str ( s ) [EOL] s = self . alphanum_only ( s ) [EOL] s = self . dedupe_whitespace ( s ) [EOL] s = str . strip ( s ) [EOL] [EOL] if int_compatable : [EOL] s = self . remove_whitespace ( s ) [EOL] else : [EOL] s = self . fill_whitespace ( s ) [EOL] [EOL] if self . toupper : [EOL] s = s . upper ( ) [EOL] elif self . tolower : [EOL] s = s . lower ( ) [EOL] [EOL] return s [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0
class RootException ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
class classproperty ( object ) : [EOL] def __init__ ( self , f ) : [EOL] self . f = f [EOL] [EOL] def __get__ ( self , obj , owner ) : [EOL] return self . f ( owner ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from metrics . metrics import * [EOL] [EOL] [docstring] [EOL] load ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Tuple , Union , Literal [EOL] import typing_extensions [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] from typing import List , Tuple , Union , Dict [EOL] import logging [EOL] [EOL] [EOL] from config import get_active_config , project [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] conf = get_active_config ( ) [EOL] [EOL] datadog = None [EOL] [EOL] [EOL] def load ( c = None ) : [EOL] [docstring] [EOL] try : [EOL] c = c or conf [EOL] parms = c . datadog_params [EOL] if parms . get ( [string] ) : [EOL] logger . debug ( [string] ) [EOL] if parms . get ( [string] ) and parms . get ( [string] ) : [EOL] global datadog [comment] [EOL] import datadog [EOL] [EOL] datadog . initialize ( ** parms ) [EOL] logger . info ( [string] ) [EOL] else : [EOL] missing_key = [string] if not parms . get ( [string] ) else [string] [EOL] logger . error ( f" [string] { missing_key }" ) [EOL] else : [EOL] logger . debug ( [string] ) [EOL] [EOL] except Exception as e : [EOL] logger . error ( f" [string] { e }" ) [EOL] [EOL] [EOL] def post ( name , points , metric_type = [string] , tags = None , ) : [EOL] [docstring] [EOL] try : [EOL] name = f"{ project } [string] { name }" . lower ( ) [EOL] if datadog : [EOL] result = datadog . api . Metric . send ( metric = name , points = points , type = str ( metric_type ) . lower ( ) , tags = to_tags ( conf . DEFAULT_TAGS ) + to_tags ( tags or [ ] ) , ) [EOL] if result . get ( [string] ) == [string] : [EOL] logger . debug ( [string] , name , points , ) [EOL] else : [EOL] logger . debug ( [string] , result . get ( [string] ) , name , points , ) [EOL] else : [EOL] logger . debug ( [string] , name , points , ) [EOL] except Exception as e : [EOL] logger . debug ( [string] , e ) [EOL] [EOL] [EOL] def post_event ( title , text , tags = None ) : [EOL] [docstring] [EOL] try : [EOL] if datadog : [EOL] datadog . api . Event . create ( title = title , text = text , tags = to_tags ( tags or [ ] ) ) [EOL] except Exception as e : [EOL] logger . debug ( [string] , e ) [EOL] [EOL] [EOL] def post_heartbeat ( ) : [EOL] [docstring] [EOL] return post ( [string] , [number] , metric_type = [string] ) [EOL] [EOL] [EOL] def to_tags ( values , sep = [string] ) : [EOL] [docstring] [EOL] result = [ ] [EOL] if isinstance ( values , dict ) : [EOL] result = [ f"{ key } [string] { str ( value ) . lower ( ) . replace ( [string] , [string] ) }" for key , value in values . items ( ) if isinstance ( value , ( str , int ) ) ] [EOL] elif isinstance ( values , str ) : [EOL] if [string] in values : [EOL] result = values . split ( sep ) [EOL] else : [EOL] result = [ values ] [EOL] elif isinstance ( values , list ) : [EOL] result = values [EOL] else : [EOL] result = [ ] [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0