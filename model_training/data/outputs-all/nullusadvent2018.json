[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Deque , Tuple , Dict , Iterator , List [EOL] import typing [EOL] import builtins [EOL] from collections import defaultdict , deque [EOL] from itertools import chain , count [EOL] from typing import List , Dict , Tuple , Iterator , Deque [EOL] [EOL] [EOL] def _parser ( growth_rules ) : [EOL] initial_state = [ ] [EOL] rules = defaultdict ( lambda : False ) [EOL] for i , line in enumerate ( growth_rules . splitlines ( ) ) : [EOL] if i == [number] : [EOL] initial_state = [ i == [string] for i in line [ [number] : ] ] [EOL] elif i > [number] : [EOL] rules [ tuple ( i == [string] for i in line [ : [number] ] ) ] = line [ - [number] ] == [string] [EOL] return initial_state , rules [EOL] [EOL] [EOL] def _next_state ( state , rules , offset = [number] ) : [EOL] [comment] [EOL] def window_state ( window_size = [number] ) : [EOL] padding = [ False ] * ( window_size - [number] ) [EOL] state_padded = chain ( state , padding ) [EOL] window = deque ( padding , maxlen = window_size ) [EOL] for elem in state_padded : [EOL] window . append ( elem ) [EOL] yield tuple ( window ) [EOL] [EOL] next_state = [ rules [ i ] for i in window_state ( [number] ) ] [EOL] first_true = next_state . index ( True ) [EOL] [EOL] return next_state [ first_true : next ( [number] - i for i in count ( [number] ) if next_state [ - i ] ) ] , offset - [number] + first_true [EOL] [EOL] [EOL] def _print_state ( state ) : [EOL] print ( [string] . join ( { True : [string] , False : [string] } [ i ] for i in state ) ) [EOL] [EOL] [EOL] def _final_state ( state , rules , generations ) : [EOL] offset = [number] [EOL] for generation in range ( generations ) : [EOL] next_state , next_offset = _next_state ( state , rules , offset ) [EOL] if next_state == state : [EOL] [comment] [EOL] return state , offset + ( next_offset - offset ) * ( generations - generation ) [EOL] state , offset = next_state , next_offset [EOL] [EOL] return state , offset [EOL] [EOL] [EOL] def answer ( growth_rules , generations ) : [EOL] state , rules = _parser ( growth_rules ) [EOL] final_state , offset = _final_state ( state , rules , generations ) [EOL] [EOL] return sum ( ( i + offset ) for i in range ( [number] , len ( final_state ) ) if final_state [ i ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.bool],typing.Dict[typing.Tuple[builtins.bool,...],builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.bool],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.bool],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Tuple , Iterator [EOL] import typing [EOL] import builtins [EOL] from math import inf [EOL] from operator import add [EOL] from typing import Tuple , Dict , Iterator [EOL] [EOL] direction_to_vector = { [string] : ( [number] , - [number] ) , [string] : ( [number] , [number] ) , [string] : ( [number] , [number] ) , [string] : ( - [number] , [number] ) , } [EOL] [EOL] [EOL] def process_map_path ( map_regex_iter , map_nodes , start_location , start_distance = [number] ) : [EOL] [EOL] location = start_location [EOL] distance = start_distance [EOL] [EOL] while True : [EOL] try : [EOL] token = next ( map_regex_iter ) [EOL] except StopIteration : [EOL] break [EOL] if token in ( [string] , [string] , [string] , [string] ) : [EOL] [comment] [EOL] next_location = tuple ( map ( add , location , direction_to_vector [ token ] ) ) [EOL] map_nodes [ next_location ] = min ( distance + [number] , map_nodes . get ( next_location , inf ) ) [EOL] distance += [number] [EOL] location = next_location [EOL] elif token == [string] : [EOL] process_map_path ( map_regex_iter , map_nodes , location , distance ) [EOL] elif token == [string] : [EOL] process_map_path ( map_regex_iter , map_nodes , start_location , start_distance ) [EOL] break [EOL] elif token == [string] or token == [string] : [EOL] break [EOL] else : [EOL] raise RuntimeError ( f' [string] { token }' ) [EOL] [EOL] [EOL] def process_map_regex ( map_regex_iter ) : [EOL] while True : [EOL] token = next ( map_regex_iter ) [EOL] if token == [string] : [EOL] map_nodes = { } [EOL] process_map_path ( map_regex_iter , map_nodes , ( [number] , [number] ) ) [EOL] return map_nodes [EOL] else : [EOL] raise RuntimeError ( f' [string] { token }' ) [EOL] [EOL] [EOL] def part1 ( map_regex ) : [EOL] map_nodes = process_map_regex ( iter ( map_regex ) ) [EOL] max_node = max ( map_nodes . values ( ) ) [EOL] return max_node [EOL] [EOL] [EOL] def part2 ( map_regex ) : [EOL] map_nodes = process_map_regex ( iter ( map_regex ) ) [EOL] return len ( [ i for i in map_nodes . values ( ) if i >= [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Tuple[builtins.int,builtins.int],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Generator , List , Any [EOL] import typing [EOL] import builtins [EOL] from more_itertools import take [EOL] [EOL] [EOL] def part1 ( license_text ) : [EOL] numbers = ( int ( i ) for i in license_text . split ( ) ) [EOL] [EOL] def process_record ( iterable ) : [EOL] num_child_nodes , num_metadata_entries = next ( iterable ) , next ( iterable ) [EOL] result = [ ] [EOL] for i in range ( num_child_nodes ) : [EOL] result += process_record ( iterable ) [EOL] metadata_entries = take ( num_metadata_entries , iterable ) [EOL] return [ metadata_entries ] + result [EOL] [EOL] records = process_record ( numbers ) [EOL] return sum ( sum ( i ) for i in records ) [EOL] [EOL] [EOL] def part2 ( license_text ) : [EOL] numbers = ( int ( i ) for i in license_text . split ( ) ) [EOL] [EOL] def process_record ( iterable , parent ) : [EOL] num_child_nodes , num_metadata_entries = next ( iterable ) , next ( iterable ) [EOL] children = [ ] [EOL] for i in range ( num_child_nodes ) : [EOL] children += process_record ( iterable , parent + [number] ) [EOL] [EOL] metadata_entries = take ( num_metadata_entries , iterable ) [EOL] [EOL] if num_child_nodes : [EOL] direct_children = [ i [ [number] ] for i in children if i [ [number] ] == parent + [number] ] [EOL] value = sum ( direct_children [ i - [number] ] for i in metadata_entries if [number] < i <= len ( direct_children ) ) [EOL] else : [EOL] value = sum ( metadata_entries ) [EOL] [EOL] return [ ( parent , value , [ metadata_entries ] ) ] + children [EOL] [EOL] return process_record ( numbers , [number] ) [ [number] ] [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Dict , Any , Iterator , List [EOL] import typing [EOL] import builtins [EOL] from collections import defaultdict [EOL] from itertools import accumulate [EOL] from re import findall [EOL] from typing import List , Dict , Tuple , Iterator [EOL] [EOL] [EOL] def _guard_sleep_journal ( response_record_text ) : [EOL] guard_total_sleep = defaultdict ( lambda : [number] ) [EOL] guard_sleep_times = defaultdict ( list ) [EOL] guard = None [EOL] [EOL] for record in sorted ( response_record_text . strip ( ) . splitlines ( ) ) : [EOL] minutes = int ( record [ [number] : [number] ] ) [EOL] action = record [ [number] : ] [EOL] [EOL] if action . startswith ( [string] ) : [EOL] guard = int ( action [ [number] : - [number] ] ) [EOL] elif action . startswith ( [string] ) : [EOL] guard_sleep_times [ guard ] . append ( ( minutes , [number] ) ) [EOL] elif action . startswith ( [string] ) : [EOL] guard_sleep_times [ guard ] . append ( ( minutes , - [number] ) ) [EOL] ( m1 , _ ) , ( m2 , _ ) = guard_sleep_times [ guard ] [ - [number] : ] [EOL] guard_total_sleep [ guard ] += m2 - m1 [EOL] else : [EOL] raise RuntimeError ( ) [EOL] [EOL] return guard_total_sleep , guard_sleep_times [EOL] [EOL] [EOL] def part1 ( response_record_text ) : [EOL] [EOL] guard_total_sleep , guard_sleep_times = _guard_sleep_journal ( response_record_text ) [EOL] [EOL] sleepy_guard = sorted ( ( ( v , k ) for k , v in guard_total_sleep . items ( ) ) , key = lambda x : x [ [number] ] , reverse = True ) [ [number] ] [ [number] ] [EOL] [EOL] cumulative_sleep = accumulate ( sorted ( guard_sleep_times [ sleepy_guard ] , key = lambda x : x [ [number] ] ) , func = lambda a , b : ( b [ [number] ] , a [ [number] ] + b [ [number] ] ) ) [EOL] [EOL] m1 = [number] [EOL] deepest = [number] [EOL] minutey = [number] [EOL] for m2 , depth in reversed ( list ( cumulative_sleep ) ) : [EOL] if m2 < m1 and depth > deepest : [EOL] deepest = depth [EOL] minutey = m2 [EOL] m1 = m2 [EOL] [EOL] return minutey * sleepy_guard [EOL] [EOL] [EOL] def part2 ( response_record_text ) : [EOL] [EOL] guard_total_sleep , guard_sleep_times = _guard_sleep_journal ( response_record_text ) [EOL] [EOL] longest_sleep = [number] [EOL] guard_id = [number] [EOL] sleeping_minute = [number] [EOL] [EOL] for guard_number , guard_sleep_time in guard_sleep_times . items ( ) : [EOL] [EOL] cumulative_sleep = accumulate ( sorted ( guard_sleep_time , key = lambda x : x [ [number] ] ) , func = lambda a , b : ( b [ [number] ] , a [ [number] ] + b [ [number] ] ) ) [EOL] [EOL] m1 = [number] [EOL] deepest = [number] [EOL] minutey = [number] [EOL] [EOL] for m2 , depth in reversed ( list ( cumulative_sleep ) ) : [EOL] if m2 < m1 and depth > deepest : [EOL] deepest = depth [EOL] minutey = m2 [EOL] m1 = m2 [EOL] [EOL] if deepest > longest_sleep : [EOL] longest_sleep = deepest [EOL] guard_id = guard_number [EOL] sleeping_minute = minutey [EOL] [EOL] return guard_id * sleeping_minute [EOL] [EOL] [EOL] def impl1 ( response_record_text ) : [EOL] [docstring] [EOL] guards = defaultdict ( lambda : defaultdict ( lambda : [number] ) ) [EOL] [EOL] guard = None [EOL] started_sleeping = None [EOL] [EOL] for line in sorted ( response_record_text . strip ( ) . splitlines ( ) ) : [EOL] last_number = int ( findall ( [string] , line ) [ - [number] ] ) [EOL] if line . endswith ( [string] ) : [EOL] guard = last_number [EOL] elif line . endswith ( [string] ) : [EOL] started_sleeping = last_number [EOL] elif line . endswith ( [string] ) : [EOL] woke_up = last_number [EOL] for min_ in range ( started_sleeping , woke_up ) : [EOL] guards [ guard ] [ min_ ] += [number] [EOL] [EOL] for f in ( sum , max ) : [EOL] id_ , minutes = max ( guards . items ( ) , key = lambda v : f ( v [ [number] ] . values ( ) ) ) [EOL] yield id_ * max ( minutes , key = lambda k : minutes [ k ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Match , Tuple , Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] from operator import sub , add [EOL] from random import randrange [EOL] from re import match [EOL] [EOL] [EOL] def _parse_coordinate_text ( coordinate_text ) : [EOL] nanobots = [ ] [EOL] for line in coordinate_text . splitlines ( ) : [EOL] match_group = match ( [string] , line ) [EOL] if match_group : [EOL] pos = tuple ( [ int ( match_group [ [number] ] ) , int ( match_group [ [number] ] ) , int ( match_group [ [number] ] ) ] ) [EOL] r = int ( match_group [ [number] ] ) [EOL] nanobots . append ( ( pos , r ) ) [EOL] return nanobots [EOL] [EOL] [EOL] def part1 ( coordinate_text ) : [EOL] nanobots = _parse_coordinate_text ( coordinate_text ) [EOL] [EOL] nanobots . sort ( key = lambda k : k [ [number] ] ) [EOL] [EOL] count = [number] [EOL] for i in nanobots [ : - [number] ] : [EOL] if sum ( map ( lambda a , b : abs ( a - b ) , i [ [number] ] , nanobots [ - [number] ] [ [number] ] ) ) <= nanobots [ - [number] ] [ [number] ] : [EOL] count += [number] [EOL] [EOL] return count [EOL] [EOL] [EOL] def _count_overlap ( nanobots ) : [EOL] return sum ( int ( sum ( map ( lambda a , b : abs ( a - b ) , i [ [number] ] , j [ [number] ] ) ) <= ( i [ [number] ] + j [ [number] ] ) / [number] ) for i in nanobots for j in nanobots ) [EOL] [EOL] [EOL] def _count_in_range ( nanobots , coordinates ) : [EOL] return sum ( int ( sum ( map ( lambda a , b : abs ( a - b ) , coordinates , nanobot [ [number] ] ) ) <= nanobot [ [number] ] ) for nanobot in nanobots ) [EOL] [EOL] [EOL] def _sample_range ( nanobots , left_coordinate , right_coordinate ) : [EOL] samples = [ ] [EOL] len_nanobots = len ( nanobots ) [EOL] for i in range ( len_nanobots * [number] ) : [EOL] nanobot = nanobots [ randrange ( [number] , len_nanobots ) ] [EOL] first = randrange ( [number] , nanobot [ [number] ] + [number] ) [EOL] second = randrange ( [number] , nanobot [ [number] ] - first + [number] ) [EOL] third = nanobot [ [number] ] - first - second [EOL] location = tuple ( map ( add , nanobot [ [number] ] , ( first , second , third ) ) ) [EOL] [EOL] location = tuple ( max ( min ( location [ i ] , right_coordinate [ i ] - [number] ) , left_coordinate [ i ] ) for i in range ( [number] ) ) [EOL] [EOL] samples . append ( _count_in_range ( nanobots , location ) ) [EOL] [EOL] return samples [EOL] [EOL] [EOL] def _search_axis ( axis , left_coordinate , right_coordinate , nanobots ) : [EOL] if sum ( map ( abs , map ( sub , left_coordinate , right_coordinate ) ) ) <= [number] : [EOL] return left_coordinate [EOL] [EOL] comparison = int ( ( left_coordinate [ axis ] + right_coordinate [ axis ] ) / [number] ) [EOL] [EOL] left = [ b for b in nanobots if b [ [number] ] [ axis ] - b [ [number] ] <= comparison ] [EOL] right = [ b for b in nanobots if b [ [number] ] [ axis ] + b [ [number] ] >= comparison ] [EOL] [EOL] left_range = ( left_coordinate , tuple ( comparison if i == axis else right_coordinate [ i ] for i in range ( [number] ) ) ) [EOL] right_range = ( tuple ( comparison if i == axis else left_coordinate [ i ] for i in range ( [number] ) ) , right_coordinate ) [EOL] [EOL] left_sample = max ( _sample_range ( left , left_range [ [number] ] , left_range [ [number] ] ) ) [EOL] right_sample = max ( _sample_range ( right , right_range [ [number] ] , right_range [ [number] ] ) ) [EOL] [EOL] if left_sample > right_sample : [EOL] return _search_axis ( ( axis + [number] ) % [number] , left_range [ [number] ] , left_range [ [number] ] , left ) [EOL] else : [EOL] return _search_axis ( ( axis + [number] ) % [number] , right_range [ [number] ] , right_range [ [number] ] , right ) [EOL] [EOL] [EOL] def _nanobots_range ( nanobots ) : [EOL] min_ = ( min ( b [ [number] ] [ [number] ] - b [ [number] ] for b in nanobots ) , min ( b [ [number] ] [ [number] ] - b [ [number] ] for b in nanobots ) , min ( b [ [number] ] [ [number] ] - b [ [number] ] for b in nanobots ) ) [EOL] [EOL] max_ = ( max ( b [ [number] ] [ [number] ] + b [ [number] ] for b in nanobots ) , max ( b [ [number] ] [ [number] ] + b [ [number] ] for b in nanobots ) , max ( b [ [number] ] [ [number] ] + b [ [number] ] for b in nanobots ) ) [EOL] [EOL] return min_ , max_ [EOL] [EOL] [EOL] def part2 ( coordinate_text ) : [EOL] nanobots = _parse_coordinate_text ( coordinate_text ) [EOL] [EOL] search_range = _nanobots_range ( nanobots ) [EOL] [EOL] coordinate = _search_axis ( [number] , search_range [ [number] ] , search_range [ [number] ] , nanobots ) [EOL] [EOL] c = sum ( int ( sum ( map ( lambda a , b : abs ( a - b ) , coordinate , b [ [number] ] ) ) <= b [ [number] ] ) for b in nanobots ) [EOL] print ( c , coordinate ) [EOL] [EOL] return sum ( abs ( i ) for i in coordinate ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Set , Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , Set , List , Tuple [EOL] from collections import defaultdict [EOL] [EOL] [EOL] def _parse ( instructions_text ) : [EOL] dependencies = defaultdict ( list ) [EOL] steps = set ( ) [EOL] [EOL] for line in instructions_text . strip ( ) . splitlines ( ) : [EOL] dependency , step = line [ [number] ] , line [ [number] ] [EOL] steps . add ( step ) [EOL] steps . add ( dependency ) [EOL] dependencies [ step ] . append ( dependency ) [EOL] [EOL] return steps , dependencies [EOL] [EOL] [EOL] def _common ( instructions_text , parallelism , ticks_offset ) : [EOL] steps_remaining , dependencies = _parse ( instructions_text ) [EOL] [EOL] worker_assignment = [ ] [EOL] ticks , order = [number] , [string] [EOL] while steps_remaining or worker_assignment : [EOL] [comment] [EOL] while len ( worker_assignment ) < parallelism : [EOL] try : [EOL] step = min ( step for step in steps_remaining if step not in dependencies or not dependencies [ step ] ) [EOL] except ValueError : [EOL] break [EOL] steps_remaining . remove ( step ) [EOL] worker_assignment . append ( ( step , ticks + ticks_offset + ord ( step ) - [number] ) ) [EOL] [EOL] [comment] [EOL] ticks = min ( job [ [number] ] for job in worker_assignment ) [EOL] for finishing_task in sorted ( [ job for job in worker_assignment if job [ [number] ] <= ticks ] , key = lambda k : k [ [number] ] ) : [EOL] order += finishing_task [ [number] ] [EOL] worker_assignment . remove ( finishing_task ) [EOL] dependencies = dict ( ( k , [ i for i in v if i != finishing_task [ [number] ] ] ) for k , v in dependencies . items ( ) ) [EOL] [EOL] return ticks , order [EOL] [EOL] [EOL] def part1 ( instructions_text ) : [EOL] return _common ( instructions_text , [number] , [number] ) [ [number] ] [EOL] [EOL] [EOL] def part2 ( instructions_text , workers = [number] , base_time = [number] ) : [EOL] return _common ( instructions_text , workers , base_time ) [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Set[builtins.str],typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple [EOL] import typing [EOL] import builtins [EOL] from collections import Counter [EOL] from typing import Tuple [EOL] [EOL] [EOL] def is_letter_repeated_2_3_times ( box_id ) : [EOL] return int ( any ( i == [number] for i in Counter ( box_id ) . values ( ) ) ) , int ( any ( i == [number] for i in Counter ( box_id ) . values ( ) ) ) [EOL] [EOL] [EOL] def part1 ( box_ids ) : [EOL] total_count = ( [number] , [number] ) [EOL] for box_id in box_ids . split ( ) : [EOL] count = is_letter_repeated_2_3_times ( box_id ) [EOL] total_count = total_count [ [number] ] + count [ [number] ] , total_count [ [number] ] + count [ [number] ] [EOL] return total_count [ [number] ] * total_count [ [number] ] [EOL] [EOL] [EOL] def common_characters ( this , that ) : [EOL] return [string] . join ( i for i , j in zip ( this , that ) if i == j ) [EOL] [EOL] [EOL] def part2 ( box_ids_text ) : [EOL] box_ids = box_ids_text . split ( ) [EOL] matching_id = next ( common_characters ( x , y ) for i , x in enumerate ( box_ids [ : - [number] ] ) for y in box_ids [ i + [number] : ] if len ( common_characters ( x , y ) ) == len ( x ) - [number] ) [EOL] return matching_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import sys [EOL] from itertools import count [EOL] from typing import List , Tuple [EOL] [EOL] [EOL] def generate_map ( scan_locations ) : [EOL] [EOL] vert_seam = [ ] [EOL] horiz_seam = [ ] [EOL] [EOL] [comment] [EOL] x_min , x_max , y_min , y_max = [number] , [number] , [number] , - [number] [EOL] [EOL] for line in scan_locations . splitlines ( ) : [EOL] pos , range_ = line . split ( [string] ) [EOL] pos_axis , pos_value = pos . split ( [string] ) [EOL] range_axis , range_value = range_ . split ( [string] ) [EOL] range_value = range_value . split ( [string] ) [EOL] [EOL] if pos_axis == [string] : [EOL] x , y1 , y2 = int ( pos_value ) , int ( range_value [ [number] ] ) , int ( range_value [ [number] ] ) [EOL] x_min , x_max = min ( x , x_min ) , max ( x , x_max ) [EOL] y_min , y_max = min ( y1 , y_min ) , max ( y2 , y_max ) [EOL] [EOL] vert_seam . append ( ( x , range ( y1 , y2 + [number] ) ) ) [EOL] elif pos_axis == [string] : [EOL] y , x1 , x2 = int ( pos_value ) , int ( range_value [ [number] ] ) , int ( range_value [ [number] ] ) [EOL] x_min , x_max = min ( x1 , x_min ) , max ( x2 , x_max ) [EOL] y_min , y_max = min ( y , y_min ) , max ( y , y_max ) [EOL] [EOL] horiz_seam . append ( ( y , range ( x1 , x2 + [number] ) ) ) [EOL] [EOL] [comment] [EOL] offset = x_min - [number] , y_min [EOL] [EOL] map_ = [ ] [EOL] for y in range ( y_min , y_max + [number] ) : [EOL] line = [ ] [EOL] [EOL] [comment] [EOL] horiz_check = [ h for h in horiz_seam if y == h [ [number] ] ] [EOL] vert_check = [ v for v in vert_seam if y in v [ [number] ] ] [EOL] [EOL] [comment] [EOL] for x in range ( x_min - [number] , x_max + [number] ) : [EOL] if ( x , y ) == ( [number] , [number] ) : [EOL] [comment] [EOL] line . append ( [string] ) [EOL] elif any ( y == h [ [number] ] and x in h [ [number] ] for h in horiz_check ) : [EOL] [comment] [EOL] line . append ( [string] ) [EOL] elif any ( x == v [ [number] ] and y in v [ [number] ] for v in vert_check ) : [EOL] [comment] [EOL] line . append ( [string] ) [EOL] else : [EOL] [comment] [EOL] line . append ( [string] ) [EOL] map_ . append ( line ) [EOL] [EOL] return offset , map_ [EOL] [EOL] [EOL] def _tile_totals ( offset , map_ ) : [EOL] [EOL] def _scan_and_fill_horiz ( location ) : [EOL] next_scan_and_fill = [ ] [EOL] [EOL] y = location [ [number] ] [EOL] [EOL] if y >= len ( map_ ) : [EOL] return None [EOL] [EOL] [comment] [EOL] x1 = location [ [number] ] [EOL] for x1 in count ( location [ [number] ] , - [number] ) : [EOL] if map_ [ y + [number] ] [ x1 ] not in ( [string] , [string] ) : [EOL] [comment] [EOL] next_scan_and_fill . append ( ( x1 , y + [number] ) ) [EOL] break [EOL] elif map_ [ y ] [ x1 - [number] ] in ( [string] , [string] ) : [EOL] break [EOL] [EOL] x2 = location [ [number] ] [EOL] for x2 in count ( location [ [number] ] ) : [EOL] if map_ [ y + [number] ] [ x2 ] not in ( [string] , [string] ) : [EOL] [comment] [EOL] next_scan_and_fill . append ( ( x2 , y + [number] ) ) [EOL] break [EOL] elif map_ [ y ] [ x2 + [number] ] in ( [string] , [string] ) : [EOL] break [EOL] [EOL] if not next_scan_and_fill : [EOL] for u in range ( x1 , x2 + [number] ) : [EOL] map_ [ y ] [ u ] = [string] [EOL] return location [ [number] ] , y - [number] [EOL] else : [EOL] for u in range ( x1 , x2 + [number] ) : [EOL] map_ [ y ] [ u ] = [string] [EOL] while next_scan_and_fill : [EOL] _scan_and_fill ( next_scan_and_fill . pop ( ) ) [EOL] [EOL] return None [EOL] [EOL] def _scan_and_fill ( location ) : [EOL] y = location [ [number] ] [EOL] try : [EOL] for y in count ( location [ [number] ] ) : [EOL] if map_ [ y + [number] ] [ location [ [number] ] ] in ( [string] , [string] ) : [EOL] break [EOL] except IndexError : [EOL] [comment] [EOL] y += [number] [EOL] [EOL] [comment] [EOL] for v in range ( location [ [number] ] , y ) : [EOL] map_ [ v ] [ location [ [number] ] ] = [string] [EOL] [EOL] last_location = _scan_and_fill_horiz ( ( location [ [number] ] , y ) ) [EOL] [EOL] if last_location : [EOL] _scan_and_fill ( last_location ) [EOL] [EOL] [comment] [EOL] recursion_limit = sys . getrecursionlimit ( ) [EOL] sys . setrecursionlimit ( [number] ) [EOL] [EOL] _scan_and_fill ( tuple ( map ( lambda a , b : max ( a - b , [number] ) , ( [number] , [number] ) , offset ) ) ) [EOL] [EOL] sys . setrecursionlimit ( recursion_limit ) [EOL] [EOL] return sum ( row . count ( [string] ) for row in map_ ) , sum ( row . count ( [string] ) for row in map_ ) [EOL] [EOL] [EOL] def part1 ( scan_locations ) : [EOL] offset , map_ = generate_map ( scan_locations ) [EOL] [EOL] tilde , pipe = _tile_totals ( offset , map_ ) [EOL] [EOL] return tilde + pipe [EOL] [EOL] [EOL] def part2 ( scan_locations ) : [EOL] offset , map_ = generate_map ( scan_locations ) [EOL] [EOL] tilde , _ = _tile_totals ( offset , map_ ) [EOL] [EOL] return tilde [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.List[typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Set , Tuple , Iterator [EOL] import typing [EOL] import src [EOL] import builtins [EOL] from typing import Iterator , Tuple , Set [EOL] [EOL] [EOL] class Rect ( object ) : [EOL] def __init__ ( self , x1 , y1 , x2 , y2 ) : [EOL] super ( ) . __init__ ( ) [EOL] self . x1 = min ( x1 , x2 ) [EOL] self . y1 = min ( y1 , y2 ) [EOL] self . x2 = max ( x1 , x2 ) [EOL] self . y2 = max ( y1 , y2 ) [EOL] [EOL] @ property def area ( self ) : [EOL] return ( self . x2 - self . x1 ) * ( self . y2 - self . y1 ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Rect ) : [EOL] return False [EOL] return self . x1 == other . x1 and self . y1 == other . y1 and self . x2 == other . x2 and self . y2 == other . y2 [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . x1 , self . y1 , self . x2 , self . y2 ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . x1 } [string] { self . y1 } [string] { self . x2 } [string] { self . y2 } [string] " [EOL] [EOL] [EOL] class Claim ( object ) : [EOL] def __init__ ( self , id_ , x , y , width , height ) : [EOL] super ( ) . __init__ ( ) [EOL] self . r = Rect ( x , y , x + width , y + height ) [EOL] self . id = id_ [EOL] [EOL] def __eq__ ( self , o ) : [EOL] if not isinstance ( o , Claim ) : [EOL] return False [EOL] return self . id == o . id and self . r == o . r [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . id , hash ( self . r ) ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . id } [string] { self . r } [string] " [EOL] [EOL] [EOL] def parse_claims_text ( claims_text ) : [EOL] [docstring] [EOL] for line in claims_text . strip ( ) . splitlines ( ) : [EOL] claim_id , _ , offset , size = line . split ( ) [EOL] offset_x , offset_y = offset . strip ( [string] ) . split ( [string] ) [EOL] width , height = size . split ( [string] ) [EOL] yield Claim ( claim_id , int ( offset_x ) , int ( offset_y ) , int ( width ) , int ( height ) ) [EOL] [EOL] [EOL] def _generate_y_events ( claims ) : [EOL] for claim in claims : [EOL] yield claim . r . y1 , claim [EOL] yield claim . r . y2 , claim [EOL] [EOL] [EOL] def _generate_x_events ( claims ) : [EOL] for claim in claims : [EOL] yield claim . r . x1 , claim [EOL] yield claim . r . x2 , claim [EOL] [EOL] [EOL] def _scan_claims ( claims ) : [EOL] scan_y = set ( ) [EOL] y_events = sorted ( _generate_y_events ( claims ) , key = lambda x : x [ [number] ] ) [EOL] y1 = [number] [EOL] for y_event in y_events : [EOL] y2 , y_claim = y_event [EOL] if y2 > y1 : [EOL] scan_x = set ( ) [EOL] x_events = sorted ( _generate_x_events ( iter ( scan_y ) ) , key = lambda x : x [ [number] ] ) [EOL] x1 = [number] [EOL] for x_event in x_events : [EOL] x2 , x_claim = x_event [EOL] if x2 > x1 : [EOL] yield scan_x , Rect ( x1 , y1 , x2 , y2 ) [EOL] x1 = x2 [EOL] if x_claim in scan_x : [EOL] scan_x . remove ( x_claim ) [EOL] else : [EOL] scan_x . add ( x_claim ) [EOL] y1 = y2 [EOL] if y_claim in scan_y : [EOL] scan_y . remove ( y_claim ) [EOL] else : [EOL] scan_y . add ( y_claim ) [EOL] [EOL] [EOL] def part1 ( claims_text ) : [EOL] return sum ( rect . area for claims , rect in _scan_claims ( parse_claims_text ( claims_text ) ) if len ( claims ) > [number] ) [EOL] [EOL] [EOL] def part2 ( claims_text ) : [EOL] claims = list ( parse_claims_text ( claims_text ) ) [EOL] valid_claims = set ( claim . id for claim in claims ) - set ( claim . id for match_claims , _ in _scan_claims ( iter ( claims ) ) for claim in match_claims if len ( match_claims ) > [number] ) [EOL] return [string] . join ( valid_claims ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.advent.no_matter_how_you_slice_it.Rect$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[Claim]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.int,Claim]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.int,Claim]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[typing.Set[Claim],Rect]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from itertools import count [EOL] from typing import List , Tuple [EOL] [EOL] [EOL] def parser ( particles_text ) : [EOL] return [ tuple ( tuple ( int ( i ) for i in part . split ( [string] ) ) for part in re . findall ( [string] , line ) ) for line in particles_text . strip ( ) . splitlines ( ) ] [EOL] [EOL] [EOL] def _bounds ( particles ) : [EOL] return ( min ( particles , key = lambda k : k [ [number] ] [ [number] ] ) [ [number] ] [ [number] ] , min ( particles , key = lambda k : k [ [number] ] [ [number] ] ) [ [number] ] [ [number] ] ) , ( max ( particles , key = lambda k : k [ [number] ] [ [number] ] ) [ [number] ] [ [number] ] , max ( particles , key = lambda k : k [ [number] ] [ [number] ] ) [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] def part1 ( particles_text ) : [EOL] [EOL] particles = parser ( particles_text ) [EOL] particles_bounds = _bounds ( particles ) [EOL] [EOL] seconds = [number] [EOL] for seconds in count ( ) : [EOL] [comment] [EOL] particles_new = [ ( ( p [ [number] ] [ [number] ] + p [ [number] ] [ [number] ] , p [ [number] ] [ [number] ] + p [ [number] ] [ [number] ] ) , ( p [ [number] ] [ [number] ] , p [ [number] ] [ [number] ] ) ) for p in particles ] [EOL] particles_bounds_new = _bounds ( particles_new ) [EOL] if ( particles_bounds [ [number] ] [ [number] ] >= particles_bounds_new [ [number] ] [ [number] ] and particles_bounds [ [number] ] [ [number] ] >= particles_bounds_new [ [number] ] [ [number] ] and particles_bounds [ [number] ] [ [number] ] <= particles_bounds_new [ [number] ] [ [number] ] and particles_bounds [ [number] ] [ [number] ] <= particles_bounds_new [ [number] ] [ [number] ] ) : [EOL] break [EOL] particles = particles_new [EOL] particles_bounds = particles_bounds_new [EOL] [EOL] result = [string] [EOL] [EOL] positions = [ i [ [number] ] for i in particles ] [EOL] [EOL] for y in range ( particles_bounds [ [number] ] [ [number] ] , particles_bounds [ [number] ] [ [number] ] + [number] ) : [EOL] for x in range ( particles_bounds [ [number] ] [ [number] ] , particles_bounds [ [number] ] [ [number] ] + [number] ) : [EOL] if ( x , y ) in positions : [EOL] result += [string] [EOL] else : [EOL] result += [string] [EOL] result += [string] [EOL] [EOL] return seconds , result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple , Iterator [EOL] import typing [EOL] import builtins [EOL] from itertools import takewhile , dropwhile [EOL] [EOL] from typing import List , Iterator , Tuple [EOL] [EOL] [EOL] def _gen_score_sequence ( initial_scores ) : [EOL] scores = initial_scores . copy ( ) [EOL] len_scores = len ( scores ) [EOL] i , j = [number] , [number] [EOL] [EOL] for x in scores : [EOL] yield x [EOL] [EOL] while True : [EOL] try : [EOL] a , b = scores [ i ] , scores [ j ] [EOL] score = a + b [EOL] if score > [number] : [EOL] score -= [number] [EOL] yield [number] [EOL] yield score [EOL] scores += [ [number] , score ] [EOL] len_scores += [number] [EOL] else : [EOL] yield score [EOL] scores . append ( score ) [EOL] len_scores += [number] [EOL] i , j = ( a + i + [number] ) , ( b + j + [number] ) [EOL] except IndexError : [EOL] i %= len_scores [EOL] j %= len_scores [EOL] [EOL] [EOL] def part1 ( initial_scores , attempted_recipes ) : [EOL] sequence = takewhile ( lambda n : n [ [number] ] < attempted_recipes + [number] , dropwhile ( lambda n : n [ [number] ] < attempted_recipes , enumerate ( _gen_score_sequence ( initial_scores ) ) ) ) [EOL] return [string] . join ( str ( i [ [number] ] ) for i in sequence ) [EOL] [EOL] [EOL] def part2 ( initial_scores , match_sequence_str ) : [EOL] match_sequence = [ int ( i ) for i in match_sequence_str ] [EOL] matched = [number] [EOL] [EOL] for i , score in enumerate ( _gen_score_sequence ( initial_scores ) ) : [EOL] if score == match_sequence [ matched ] : [EOL] matched += [number] [EOL] if matched >= len ( match_sequence_str ) : [EOL] return i - len ( match_sequence_str ) + [number] [EOL] elif score == match_sequence [ [number] ] : [EOL] matched = [number] [EOL] else : [EOL] matched = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Set , Any [EOL] import typing [EOL] import builtins [EOL] from itertools import product , count [EOL] from typing import List , Set , Tuple [EOL] [EOL] [EOL] def parse ( input_map_str ) : [EOL] return [ [ i for i in row ] for row in input_map_str . splitlines ( ) ] [EOL] [EOL] [EOL] def resource_value ( map_ ) : [EOL] return sum ( row . count ( [string] ) for row in map_ ) * sum ( row . count ( [string] ) for row in map_ ) [EOL] [EOL] [EOL] def map_str ( map_ ) : [EOL] return [string] . join ( [string] . join ( row ) for row in map_ ) [EOL] [EOL] [EOL] def next_state ( map_ ) : [EOL] next_map = [ ] [EOL] for y , row in enumerate ( map_ ) : [EOL] next_row = [ ] [EOL] for x , tile in enumerate ( row ) : [EOL] surrounding_tiles = [ map_ [ v ] [ u ] for u , v in product ( range ( x - [number] , x + [number] ) , range ( y - [number] , y + [number] ) ) if ( u , v ) != ( x , y ) and [number] <= u < len ( row ) and [number] <= v < len ( map_ ) ] [EOL] if tile == [string] and surrounding_tiles . count ( [string] ) >= [number] : [EOL] next_row . append ( [string] ) [EOL] elif tile == [string] and surrounding_tiles . count ( [string] ) >= [number] : [EOL] next_row . append ( [string] ) [EOL] elif tile == [string] and not ( surrounding_tiles . count ( [string] ) >= [number] and surrounding_tiles . count ( [string] ) >= [number] ) : [EOL] next_row . append ( [string] ) [EOL] else : [EOL] next_row . append ( tile ) [EOL] next_map . append ( next_row ) [EOL] [EOL] return next_map [EOL] [EOL] [EOL] def part1 ( input_map_str ) : [EOL] map_ = parse ( input_map_str ) [EOL] [EOL] for i in range ( [number] ) : [EOL] map_ = next_state ( map_ ) [EOL] [EOL] return resource_value ( map_ ) [EOL] [EOL] [EOL] def part2 ( input_map_str , minutes ) : [EOL] map_ = parse ( input_map_str ) [EOL] history = [ input_map_str . strip ( ) ] [EOL] map_history = { input_map_str . strip ( ) } [EOL] i = [number] [EOL] for i in range ( minutes ) : [EOL] map_ = next_state ( map_ ) [EOL] map_serialised = map_str ( map_ ) [EOL] if map_serialised in map_history : [EOL] break [EOL] map_history . add ( map_serialised ) [EOL] history . append ( map_serialised ) [EOL] [EOL] first_index = history . index ( map_str ( map_ ) ) [EOL] return resource_value ( parse ( history [ first_index + ( minutes - i - [number] ) % ( len ( history ) - first_index ) ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , Iterator [EOL] import typing [EOL] import builtins [EOL] from typing import Iterator [EOL] [EOL] [EOL] def _value_of_r3 ( ) : [EOL] [docstring] [EOL] [EOL] r1 , r3 = [number] , [number] [EOL] while True : [EOL] r1 = r3 | [number] [EOL] r3 = [number] [EOL] while r1 != [number] : [EOL] r3 = ( ( ( r3 + ( r1 & [number] ) ) & [number] ) * [number] ) & [number] [EOL] r1 = int ( r1 / [number] ) [EOL] yield r3 [EOL] [EOL] [EOL] def part1 ( ) : [EOL] return next ( _value_of_r3 ( ) ) [EOL] [EOL] [EOL] def part2 ( ) : [EOL] seen_r3 = set ( ) [EOL] last_r3 = None [EOL] for r3 in _value_of_r3 ( ) : [EOL] if r3 in seen_r3 : [EOL] break [EOL] seen_r3 . add ( r3 ) [EOL] last_r3 = r3 [EOL] [EOL] return last_r3 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def _react_list ( polymer_list ) : [EOL] [comment] [EOL] result = polymer_list . copy ( ) [EOL] [EOL] i = [number] [EOL] while i < len ( result ) - [number] : [EOL] if result [ i ] . swapcase ( ) == result [ i + [number] ] : [EOL] del result [ i : i + [number] ] [EOL] if i > [number] : [EOL] i -= [number] [EOL] else : [EOL] i += [number] [EOL] [EOL] return result [EOL] [EOL] [EOL] def part1 ( polymer_input ) : [EOL] return len ( _react_list ( list ( polymer_input ) ) ) [EOL] [EOL] [EOL] def part2 ( polymer_input ) : [EOL] polymer_base = _react_list ( list ( polymer_input ) ) [EOL] [EOL] return min ( len ( _react_list ( [ j for j in polymer_base if j . lower ( ) != i ] ) ) for i in set ( polymer_input . lower ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Set , Any , Tuple [EOL] import typing [EOL] import src [EOL] import builtins [EOL] from functools import lru_cache [EOL] from heapq import heappush , heappop [EOL] from operator import sub , add [EOL] from typing import Tuple , List [EOL] [EOL] [EOL] @ lru_cache ( maxsize = [number] ) def erosion_level ( coords , depth ) : [EOL] return ( geologic_index ( coords , depth ) + depth ) % [number] [EOL] [EOL] [EOL] @ lru_cache ( maxsize = [number] ) def geologic_index ( coords , depth ) : [EOL] if coords [ [number] ] == [number] : [EOL] return coords [ [number] ] * [number] [EOL] elif coords [ [number] ] == [number] : [EOL] return coords [ [number] ] * [number] [EOL] else : [EOL] return ( erosion_level ( tuple ( map ( sub , coords , ( [number] , [number] ) ) ) , depth ) * erosion_level ( tuple ( map ( sub , coords , ( [number] , [number] ) ) ) , depth ) ) [EOL] [EOL] [EOL] def part1 ( coords , depth ) : [EOL] return sum ( erosion_level ( ( x , y ) , depth ) % [number] for y in range ( [number] , coords [ [number] ] + [number] ) for x in range ( [number] , coords [ [number] ] + [number] ) if ( x , y ) != coords ) [EOL] [EOL] [EOL] def _valid_tools ( location , depth , target ) : [EOL] if location == target : [EOL] return [ [string] , [string] ] [EOL] [EOL] return [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , ] [ erosion_level ( location , depth ) % [number] ] [EOL] [EOL] [EOL] class Action ( object ) : [EOL] def __init__ ( self , minutes_elapsed , location , equipped , target ) : [EOL] super ( ) . __init__ ( ) [EOL] self . minutes_elapsed = minutes_elapsed [EOL] self . location = location [EOL] self . equipped = equipped [EOL] self . target = target [EOL] self . priority = self . minutes_elapsed + abs ( self . target [ [number] ] - self . location [ [number] ] ) + abs ( self . target [ [number] ] - self . location [ [number] ] ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if not isinstance ( other , Action ) : [EOL] raise ValueError ( ) [EOL] return self . priority < other . priority [EOL] [EOL] [EOL] def part2 ( target , depth ) : [EOL] [docstring] [EOL] [EOL] action_queue = [ ] [EOL] previous_states = set ( ) [EOL] [EOL] heappush ( action_queue , Action ( [number] , ( [number] , [number] ) , [string] , target ) ) [EOL] [EOL] while True : [EOL] action = heappop ( action_queue ) [EOL] [EOL] previous_states . add ( ( action . location , action . equipped ) ) [EOL] [EOL] if action . location == target and action . equipped == [string] : [EOL] return action . minutes_elapsed [EOL] [EOL] next_actions = [ Action ( action . minutes_elapsed + [number] , next_location , action . equipped , action . target ) for next_location in ( tuple ( map ( add , action . location , direction ) ) for direction in [ ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , [number] ) , ( [number] , - [number] ) ] ) if ( next_location [ [number] ] >= [number] and next_location [ [number] ] >= [number] and action . equipped in _valid_tools ( next_location , depth , target ) and ( next_location , action . equipped ) not in previous_states ) ] + [ Action ( action . minutes_elapsed + [number] , action . location , next_equipped , action . target ) for next_equipped in _valid_tools ( action . location , depth , target ) if ( action . location , next_equipped ) not in previous_states ] [EOL] [EOL] for i in next_actions : [EOL] heappush ( action_queue , i ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set [EOL] import typing [EOL] import builtins [EOL] from itertools import cycle [EOL] from typing import Set [EOL] [EOL] [EOL] def part1 ( adjustments ) : [EOL] return sum ( int ( i ) for i in adjustments . split ( ) ) [EOL] [EOL] [EOL] def part2 ( adjustments ) : [EOL] frequencies = { [number] } [EOL] value = [number] [EOL] for i in cycle ( adjustments . split ( ) ) : [EOL] value += int ( i ) [EOL] if value in frequencies : [EOL] return value [EOL] frequencies . add ( value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] from functools import lru_cache [EOL] from typing import Tuple [EOL] [EOL] [EOL] [comment] [EOL] @ lru_cache ( [number] ) def power_level ( x , y , serial ) : [EOL] return int ( ( ( x + [number] ) * y + serial ) * ( x + [number] ) / [number] % [number] ) - [number] [EOL] [EOL] [EOL] @ lru_cache ( [number] ) def grid_power_levels ( x , y , serial , size = [number] ) : [EOL] if size > [number] : [EOL] n = size - [number] [EOL] return grid_power_levels ( x , y , serial , n ) + sum ( power_level ( x + i , y + n , serial ) + power_level ( x + n , y + i , serial ) for i in range ( [number] , n ) ) + power_level ( x + n , y + n , serial ) [EOL] else : [EOL] return sum ( power_level ( u , v , serial ) for u in range ( x , x + [number] ) for v in range ( y , y + [number] ) ) [EOL] [EOL] [EOL] def part1 ( serial ) : [EOL] return max ( ( ( grid_power_levels ( x , y , serial ) , ( x , y ) ) for y in range ( [number] , [number] ) for x in range ( [number] , [number] ) ) , key = lambda k : k [ [number] ] ) [ [number] ] [EOL] [EOL] [EOL] def part2 ( serial ) : [EOL] return max ( ( ( grid_power_levels ( x , y , serial , z ) , ( x , y , z ) ) for y in range ( [number] , [number] ) for x in range ( [number] , [number] ) for z in range ( [number] , [number] ) if y + z < [number] and x + z < [number] ) , key = lambda k : k [ [number] ] ) [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import DefaultDict , Tuple , Any , Iterator , List [EOL] import typing [EOL] import builtins [EOL] from collections import defaultdict [EOL] from typing import Iterator , Tuple , List [EOL] [EOL] [EOL] def text_to_points ( text ) : [EOL] for i in text . strip ( ) . splitlines ( ) : [EOL] yield tuple ( int ( i ) for i in i . split ( [string] ) ) [EOL] [EOL] [EOL] def manhattan ( a , b ) : [EOL] return abs ( a [ [number] ] - b [ [number] ] ) + abs ( a [ [number] ] - b [ [number] ] ) [EOL] [EOL] [EOL] def inside ( a , low , high ) : [EOL] return low [ [number] ] < a [ [number] ] < high [ [number] ] and low [ [number] ] < a [ [number] ] < high [ [number] ] [EOL] [EOL] [EOL] def part1 ( input_text ) : [EOL] points = list ( text_to_points ( input_text ) ) [EOL] [EOL] bound_low = min ( points , key = lambda k : k [ [number] ] ) [ [number] ] , min ( points , key = lambda k : k [ [number] ] ) [ [number] ] [EOL] bound_high = max ( points , key = lambda k : k [ [number] ] ) [ [number] ] , max ( points , key = lambda k : k [ [number] ] ) [ [number] ] [EOL] [EOL] inside_points = [ i for i , point in enumerate ( points ) if inside ( point , bound_low , bound_high ) ] [EOL] [EOL] point_area = defaultdict ( lambda : [number] ) [EOL] [EOL] for y in range ( bound_low [ [number] ] , bound_high [ [number] ] + [number] ) : [EOL] for x in range ( bound_low [ [number] ] , bound_high [ [number] ] + [number] ) : [EOL] distances = sorted ( [ ( manhattan ( ( x , y ) , point ) , i ) for i , point in enumerate ( points ) ] , key = lambda k : k [ [number] ] ) [EOL] [comment] [EOL] if inside ( ( x , y ) , bound_low , bound_high ) : [EOL] if distances [ [number] ] [ [number] ] < distances [ [number] ] [ [number] ] and distances [ [number] ] [ [number] ] in inside_points : [EOL] point_area [ distances [ [number] ] [ [number] ] ] += [number] [EOL] else : [EOL] if distances [ [number] ] [ [number] ] in inside_points : [EOL] del inside_points [ inside_points . index ( distances [ [number] ] [ [number] ] ) ] [EOL] point_area [ distances [ [number] ] [ [number] ] ] = [number] [EOL] [EOL] return max ( point_area . items ( ) , key = lambda k : k [ [number] ] ) [ [number] ] [EOL] [EOL] [EOL] def part2 ( input_text , threshold ) : [EOL] points = list ( text_to_points ( input_text ) ) [EOL] [EOL] bound_low = min ( points , key = lambda k : k [ [number] ] ) [ [number] ] , min ( points , key = lambda k : k [ [number] ] ) [ [number] ] [EOL] bound_high = max ( points , key = lambda k : k [ [number] ] ) [ [number] ] , max ( points , key = lambda k : k [ [number] ] ) [ [number] ] [EOL] [EOL] distance_total = [ ] [EOL] [EOL] for y in range ( bound_low [ [number] ] , bound_high [ [number] ] + [number] ) : [EOL] distance_total . append ( [ [number] ] * ( bound_high [ [number] ] - bound_low [ [number] ] + [number] ) ) [EOL] for x in range ( bound_low [ [number] ] , bound_high [ [number] ] + [number] ) : [EOL] if distance_total [ y - bound_low [ [number] ] ] [ x - bound_low [ [number] ] ] < threshold : [EOL] distance_total [ y - bound_low [ [number] ] ] [ x - bound_low [ [number] ] ] += sum ( manhattan ( ( x , y ) , point ) for point in points ) [EOL] [EOL] return sum ( [ len ( [ i for i in row if i < threshold ] ) for row in distance_total ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Match , Tuple , Dict , Optional , Any , List [EOL] import typing [EOL] import src [EOL] import builtins [EOL] from collections import namedtuple [EOL] from re import match [EOL] [EOL] from typing import Tuple , List , Dict [EOL] [EOL] [EOL] class Unit ( namedtuple ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) ) : [EOL] @ property def effective_strength ( self ) : [EOL] return self . size * self . damage [EOL] [EOL] @ property def attack_order ( self ) : [EOL] return self . effective_strength , self . initiative [EOL] [EOL] def _attack_multiplier ( self , attacker ) : [EOL] if attacker . type in self . weaknesses : [EOL] return [number] [EOL] elif attacker . type in self . immunities : [EOL] return [number] [EOL] else : [EOL] return [number] [EOL] [EOL] def effective_damage ( self , defender ) : [EOL] if not isinstance ( defender , Unit ) : [EOL] raise ValueError ( [string] ) [EOL] return defender . _attack_multiplier ( self ) * self . effective_strength [EOL] [EOL] def defend_order ( self , attacker ) : [EOL] if not isinstance ( attacker , Unit ) : [EOL] raise ValueError ( [string] ) [EOL] return attacker . effective_damage ( self ) , self . effective_strength , self . initiative [EOL] [EOL] [EOL] def parse_unit_description ( unit_description ) : [EOL] unit_regex = [string] [string] [EOL] effects_regex = [string] [EOL] [EOL] immunities = [ ] [EOL] weaknesses = [ ] [EOL] [EOL] unit_group = match ( unit_regex , unit_description ) [EOL] if unit_group [ [number] ] : [EOL] for effects in unit_group [ [number] ] . strip ( [string] ) . split ( [string] ) : [EOL] effects_group = match ( effects_regex , effects ) [EOL] if effects_group [ [number] ] == [string] : [EOL] immunities += effects_group [ [number] ] . split ( [string] ) [EOL] elif effects_group [ [number] ] == [string] : [EOL] weaknesses += effects_group [ [number] ] . split ( [string] ) [EOL] [EOL] return Unit ( int ( unit_group [ [number] ] ) , int ( unit_group [ [number] ] ) , int ( unit_group [ [number] ] ) , int ( unit_group [ [number] ] ) , unit_group [ [number] ] , frozenset ( immunities ) , frozenset ( weaknesses ) ) [EOL] [EOL] [EOL] def parse ( description ) : [EOL] immune = [ ] [EOL] infection = [ ] [EOL] [EOL] team = None [EOL] for line in description . splitlines ( ) : [EOL] if line . startswith ( [string] ) : [EOL] team = immune [EOL] elif line . startswith ( [string] ) : [EOL] team = infection [EOL] else : [EOL] if len ( line ) == [number] : [EOL] continue [EOL] team . append ( parse_unit_description ( line ) ) [EOL] [EOL] return immune , infection [EOL] [EOL] [EOL] def choose_targets ( immune , infection ) : [EOL] r = { } [EOL] [EOL] def _add_attackers ( attackers , defenders ) : [EOL] targets = defenders . copy ( ) [EOL] [EOL] for attacker in sorted ( attackers , key = lambda k : k . attack_order , reverse = True ) : [EOL] targets . sort ( key = lambda k : k . defend_order ( attacker ) ) [EOL] if len ( targets ) > [number] and attacker . effective_damage ( targets [ - [number] ] ) > [number] : [EOL] r [ attacker ] = targets . pop ( ) [EOL] [EOL] _add_attackers ( infection , immune ) [EOL] _add_attackers ( immune , infection ) [EOL] [EOL] return r [EOL] [EOL] [EOL] def part1 ( description ) : [EOL] immune , infection = parse ( description ) [EOL] [EOL] immune , infection = _simulate_battle ( immune , infection ) [EOL] [EOL] return max ( sum ( i . size for i in immune ) , sum ( i . size for i in infection ) ) [EOL] [EOL] [EOL] def _simulate_battle ( immune , infection ) : [EOL] [comment] [EOL] while immune and infection : [EOL] targets = choose_targets ( immune , infection ) [EOL] if not targets : [EOL] [comment] [EOL] break [EOL] [comment] [EOL] for initiative in sorted ( [ attacker . initiative for attacker in targets . keys ( ) ] , reverse = True ) : [EOL] casualties = { } [EOL] for attacker , defender in [ target for target in targets . items ( ) if target [ [number] ] . initiative == initiative ] : [EOL] [comment] [EOL] damage = attacker . effective_damage ( defender ) [EOL] units_killed = min ( defender . size , int ( damage / defender . hit_points ) ) [EOL] if units_killed > [number] : [EOL] casualties [ defender ] = Unit ( defender . size - units_killed , defender . hit_points , defender . initiative , defender . damage , defender . type , defender . immunities , defender . weaknesses ) [EOL] [comment] [EOL] for unit in casualties : [EOL] update = immune if unit in immune else infection [EOL] if casualties [ unit ] . size > [number] : [EOL] if unit in targets : [EOL] targets [ casualties [ unit ] ] = targets [ unit ] [EOL] update . append ( casualties [ unit ] ) [EOL] if unit in targets : [EOL] del targets [ unit ] [EOL] update . remove ( unit ) [EOL] [EOL] return immune , infection [EOL] [EOL] [EOL] def part2 ( description ) : [EOL] immune , infection = parse ( description ) [EOL] [EOL] boosted_immune , remaining_infection = None , None [EOL] search = range ( [number] , [number] ) [EOL] while len ( search ) > [number] : [EOL] boost = int ( ( search . start + search . stop ) / [number] ) [EOL] boosted_immune = [ Unit ( unit . size , unit . hit_points , unit . initiative , unit . damage + boost , unit . type , unit . immunities , unit . weaknesses ) for unit in immune ] [EOL] boosted_immune , remaining_infection = _simulate_battle ( boosted_immune , infection . copy ( ) ) [EOL] if remaining_infection : [EOL] search = range ( boost , search . stop ) [EOL] else : [EOL] search = range ( search . start , boost ) [EOL] [EOL] if remaining_infection : [EOL] boosted_immune = [ Unit ( unit . size , unit . hit_points , unit . initiative , unit . damage + search . stop , unit . type , unit . immunities , unit . weaknesses ) for unit in immune ] [EOL] boosted_immune , remaining_infection = _simulate_battle ( boosted_immune , infection . copy ( ) ) [EOL] [EOL] return sum ( unit . size for unit in boosted_immune ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $'Unit'$ 0 0 0 0 0 0 0 $'Unit'$ 0 0 0 0 0 0 0 0 0 0 0 0 $'Unit'$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 $'Unit'$ 0 0 0 0 0 0 0 $'Unit'$ 0 0 0 0 0 0 0 0 0 0 0 0 $'Unit'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from importlib . resources import read_text [EOL] [EOL] [EOL] def text ( input_name ) : [EOL] return read_text ( __name__ , input_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . input import text [EOL] from advent . reservoir_research import generate_map , part1 , part2 [EOL] [EOL] test_data = [string] . strip ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] test_map_output = [string] . strip ( ) . splitlines ( ) [EOL] [EOL] test_map_output_array = [ [ tile for tile in row ] for row in test_map_output ] [EOL] [EOL] [EOL] def test_map ( ) : [EOL] assert ( ( [number] , [number] ) , test_map_output_array ) == generate_map ( test_data ) [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == part1 ( test_data ) [EOL] [EOL] [EOL] @ mark . slow def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] def test_part2 ( ) : [EOL] assert [number] == part2 ( test_data ) [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from advent . chronal_classification import part1 , part2 [EOL] from advent . input import text [EOL] [EOL] test_data = [string] . strip ( ) [EOL] [EOL] [EOL] test_part2_output = None [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == part1 ( test_data ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) , text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple , Union [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . chronal_charge import power_level , part1 , part2 [EOL] from advent . input import text [EOL] [EOL] [EOL] def test_power_level ( ) : [EOL] assert [number] == power_level ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] test_power_level_data = [ [ [ [number] , [number] , [number] ] , - [number] ] , [ [ [number] , [number] , [number] ] , [number] ] , [ [ [number] , [number] , [number] ] , [number] ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_power_level_data ) def test_power_levels ( params , level ) : [EOL] assert level == power_level ( * params ) [EOL] [EOL] [EOL] test_part1_data = [ [ [number] , ( [number] , [number] ) ] , [ [number] , ( [number] , [number] ) ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_part1_data ) def test_part1 ( serial , coordinates ) : [EOL] assert coordinates == part1 ( serial ) [EOL] [EOL] [EOL] test_part2_data = [ [ [number] , ( [number] , [number] , [number] ) ] , [ [number] , ( [number] , [number] , [number] ) ] , ] [EOL] [EOL] [EOL] @ mark . slow @ mark . parametrize ( [string] , test_part2_data ) def test_part2 ( serial , coordinates ) : [EOL] assert coordinates == part2 ( serial ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert ( [number] , [number] ) == part1 ( int ( text ( [string] ) ) ) [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert ( [number] , [number] , [number] ) == part2 ( int ( text ( [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . input import text [EOL] from advent . the_stars_align import parser , part1 [EOL] [EOL] test_data = [string] [EOL] [EOL] test_output = [string] [EOL] [EOL] [EOL] def test_parser ( ) : [EOL] test = list ( parser ( test_data ) ) [EOL] assert test [ [number] ] == ( ( [number] , - [number] ) , ( - [number] , [number] ) ) [EOL] assert test [ [number] ] == ( ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert test_output . strip ( ) == part1 ( test_data ) [ [number] ] . strip ( ) [EOL] [EOL] [EOL] def test_part2 ( ) : [EOL] assert [number] == part1 ( test_data ) [ [number] ] [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Union , Literal , Any , List [EOL] import typing [EOL] import typing_extensions [EOL] from textwrap import dedent [EOL] [EOL] from pytest import mark [EOL] [EOL] from advent . four_dimensional_adventure import part1 , KdTree , Node , parse [EOL] from advent . input import text [EOL] [EOL] test_data = [ [ dedent ( [string] ) . strip ( ) , [number] ] , [ dedent ( [string] ) . strip ( ) , [number] ] , [ dedent ( [string] ) . strip ( ) , [number] ] , [ dedent ( [string] ) . strip ( ) , [number] ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_data ) def test_part1 ( puzzle_input , constellations ) : [EOL] assert constellations == part1 ( puzzle_input ) [EOL] [EOL] [EOL] def test_kdtree ( ) : [EOL] points = ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] kdtree = KdTree ( [number] , points ) [EOL] [EOL] assert Node ( ( [number] , [number] ) , Node ( ( [number] , [number] ) , None , None ) , Node ( ( [number] , [number] ) , Node ( ( [number] , [number] ) , None , None ) , None ) ) == kdtree . root [EOL] [EOL] [EOL] def test_kdtree_points_in_range ( ) : [EOL] points = ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] kdtree = KdTree ( [number] , points ) [EOL] [EOL] assert { ( [number] , [number] ) , ( [number] , [number] ) } == set ( kdtree . points_in_range ( ( [number] , [number] ) , [number] ) ) [EOL] [EOL] [EOL] def test_parse ( ) : [EOL] assert [ ( - [number] , [number] , - [number] , [number] ) , ( [number] , [number] , - [number] , [number] ) ] == list ( parse ( dedent ( [string] ) . strip ( ) ) ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Union [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . chocolate_charts import part1 , part2 [EOL] from advent . input import text [EOL] [EOL] test_data_initial_state = [ [number] , [number] ] [EOL] [EOL] test_data = [ [ [number] , [string] ] , [ [number] , [string] ] , [ [number] , [string] ] , [ [number] , [string] ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_data ) def test_part1 ( recipes , next_scores ) : [EOL] assert next_scores == part1 ( test_data_initial_state , recipes ) [EOL] [EOL] [EOL] test_part2_data = [ [ [number] , [string] ] , [ [number] , [string] ] , [ [number] , [string] ] , [ [number] , [string] ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_part2_data ) def test_part2 ( recipes , sequence ) : [EOL] assert recipes == part2 ( test_data_initial_state , sequence ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [string] == part1 ( test_data_initial_state , int ( text ( [string] ) ) ) [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( test_data_initial_state , text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Tuple [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . input import text [EOL] from advent . mine_cart_madness import part1 , Cart , part2 [EOL] [EOL] test_data = [string] . strip ( ) [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert ( [number] , [number] ) == part1 ( test_data ) [EOL] [EOL] [EOL] def test_cart_turn ( ) : [EOL] cart = Cart ( ( [number] , [number] ) , [string] ) [EOL] cart . act ( [string] ) [EOL] assert [string] == cart . direction [EOL] cart . act ( [string] ) [EOL] assert [string] == cart . direction [EOL] cart . act ( [string] ) [EOL] assert [string] == cart . direction [EOL] [EOL] [EOL] test_cart_order_data = [ [ ( [number] , [number] ) , ( [number] , [number] ) ] , [ ( [number] , [number] ) , ( [number] , [number] ) ] , [ ( [number] , [number] ) , ( [number] , [number] ) ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_cart_order_data ) def test_cart_order ( high_pos , low_pos ) : [EOL] cart_low = Cart ( low_pos , [string] ) [EOL] cart_high = Cart ( high_pos , [string] ) [EOL] [EOL] assert cart_low < cart_high [EOL] [EOL] [EOL] test_collision_order = [string] . strip ( ) [EOL] [EOL] [EOL] def test_part1_collision_order ( ) : [EOL] assert ( [number] , [number] ) == part1 ( test_collision_order ) [EOL] [EOL] [EOL] test_data2 = [string] . strip ( ) [EOL] [EOL] [EOL] def test_part2 ( ) : [EOL] assert ( [number] , [number] ) == part2 ( test_data2 ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert ( [number] , [number] ) == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] def test_part2_with_puzzle_input ( ) : [EOL] assert ( [number] , [number] ) == part2 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Union [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . marble_mania import part1 , part2 [EOL] [EOL] test_data = [ [ [ [number] , [number] ] , [number] ] , [ [ [number] , [number] ] , [number] ] , [ [ [number] , [number] ] , [number] ] , [ [ [number] , [number] ] , [number] ] , [ [ [number] , [number] ] , [number] ] , [ [ [number] , [number] ] , [number] ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_data ) def test_part1 ( args , score ) : [EOL] assert score == part1 ( * args ) [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_data ) def test_part2 ( args , score ) : [EOL] assert score == part2 ( * args ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( [number] , [number] ) [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[typing.List[builtins.int],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[typing.List[builtins.int],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[typing.List[builtins.int],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple , Union [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . input import text [EOL] from advent . inventory_management_system import is_letter_repeated_2_3_times , part1 , part2 , common_characters [EOL] [EOL] [EOL] test_is_letter_repeated_2_3_times_data = [ [ [string] , ( [number] , [number] ) ] , [ [string] , ( [number] , [number] ) ] , [ [string] , ( [number] , [number] ) ] , [ [string] , ( [number] , [number] ) ] , [ [string] , ( [number] , [number] ) ] , [ [string] , ( [number] , [number] ) ] , [ [string] , ( [number] , [number] ) ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_is_letter_repeated_2_3_times_data ) def test_is_letter_repeated_2_3_times ( box_id , count ) : [EOL] assert count == is_letter_repeated_2_3_times ( box_id ) [EOL] [EOL] [EOL] test_part1_data = [string] [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert part1 ( test_part1_data ) == [number] [EOL] [EOL] [EOL] test_part2_data = [string] [EOL] [EOL] [EOL] def test_part2 ( ) : [EOL] assert [string] == part2 ( test_part2_data ) [EOL] [EOL] [EOL] test_common_characters_data = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_common_characters_data ) def test_common_characters ( this , that , common ) : [EOL] assert common == common_characters ( this , that ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] def test_part2_with_puzzle_input ( ) : [EOL] assert [string] == part2 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.str,typing.Tuple[builtins.int,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.str,typing.Tuple[builtins.int,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Union [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . a_regular_map import part1 , part2 [EOL] from advent . input import text [EOL] [EOL] test_data = [ [ [string] , [number] ] , [ [string] , [number] ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_data ) def test_part1 ( map_regex , furthest_room ) : [EOL] assert furthest_room == part1 ( map_regex ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple , Union [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . mode_maze import erosion_level , geologic_index , part1 , part2 [EOL] [EOL] test_geologic_index_data = [ [ ( [number] , [number] ) , [number] ] , [ ( [number] , [number] ) , [number] ] , [ ( [number] , [number] ) , [number] ] , [ ( [number] , [number] ) , [number] ] ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_geologic_index_data ) def test_geologic_index ( coords , index ) : [EOL] assert index == geologic_index ( coords , [number] ) [EOL] [EOL] [EOL] test_erosion_level_data = [ [ ( [number] , [number] ) , [number] , [number] ] , [ ( [number] , [number] ) , [number] , [number] ] , [ ( [number] , [number] ) , [number] , [number] ] , [ ( [number] , [number] ) , [number] , [number] ] ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_erosion_level_data ) def test_erosion_level ( coords , depth , level ) : [EOL] assert level == erosion_level ( coords , depth ) [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == part1 ( ( [number] , [number] ) , [number] ) [EOL] [EOL] [EOL] def test_part2 ( ) : [EOL] assert [number] == part2 ( ( [number] , [number] ) , [number] ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( ( [number] , [number] ) , [number] ) [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( ( [number] , [number] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,typing.Tuple[builtins.int,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,typing.Tuple[builtins.int,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,typing.Tuple[builtins.int,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Union[builtins.int,typing.Tuple[builtins.int,builtins.int]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . immune_system_simulator_20xx import parse_unit_description , parse , part1 , Unit , choose_targets , part2 [EOL] from advent . input import text [EOL] [EOL] test_parse_unit_description_data = [ [ [string] , Unit ( [number] , [number] , [number] , [number] , [string] , frozenset ( [ [string] , [string] ] ) , frozenset ( [ [string] ] ) ) , ] , [ [string] , Unit ( [number] , [number] , [number] , [number] , [string] , frozenset ( ) , frozenset ( ) ) , ] , [ [string] , Unit ( [number] , [number] , [number] , [number] , [string] , frozenset ( ) , frozenset ( [ [string] , [string] ] ) ) , ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_parse_unit_description_data ) def test_parse_unit_description ( description , unit ) : [EOL] [comment] [EOL] assert unit == parse_unit_description ( description ) [EOL] [EOL] [EOL] test_data = [string] . strip ( ) [EOL] [EOL] [EOL] def test_parse ( ) : [EOL] immune , infection = parse ( test_data ) [EOL] [EOL] assert [number] == len ( immune ) [EOL] assert [number] == len ( infection ) [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == part1 ( test_data ) [EOL] [EOL] [EOL] def test_target_defenders ( ) : [EOL] immune , infection = parse ( test_data ) [EOL] targets = choose_targets ( immune , infection ) [EOL] [EOL] assert targets [ immune [ [number] ] ] == infection [ [number] ] [EOL] assert targets [ immune [ [number] ] ] == infection [ [number] ] [EOL] assert targets [ infection [ [number] ] ] == immune [ [number] ] [EOL] assert targets [ infection [ [number] ] ] == immune [ [number] ] [EOL] [EOL] [EOL] def test_unit_effective_strength ( ) : [EOL] assert [number] == Unit ( [number] , [number] , [number] , [number] , [string] , set ( ) , set ( ) ) . effective_strength [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from pytest import mark [EOL] [EOL] from advent . chronal_coordinates import part1 , part2 [EOL] from advent . input import text [EOL] [EOL] test_day_7_data = [string] [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == part1 ( test_day_7_data ) [EOL] [EOL] [EOL] @ mark . slow def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] def test_part2 ( ) : [EOL] assert [number] == part2 ( test_day_7_data , [number] ) [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . beverage_bandits import part1 , Battle , Vector , part2 [EOL] from advent . input import text [EOL] [EOL] test_battle1 = [string] . strip ( ) [EOL] [EOL] test_battle1_outcome = [number] [EOL] [EOL] test_battle1_map = [string] . strip ( ) . splitlines ( ) [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert test_battle1_outcome == part1 ( test_battle1 ) [EOL] [EOL] [EOL] def test_battle_map ( ) : [EOL] assert test_battle1_map == Battle ( test_battle1 ) . map [EOL] [EOL] [EOL] def test_battle_actors ( ) : [EOL] assert [number] == len ( Battle ( test_battle1 ) . actors ) [EOL] [EOL] [EOL] def test_battle_start_at_round_zero ( ) : [EOL] assert [number] == Battle ( test_battle1 ) . round [EOL] [EOL] [EOL] def test_battle_str_matches_text ( ) : [EOL] assert test_battle1 == str ( Battle ( test_battle1 ) ) [EOL] [EOL] [EOL] def test_battle_actors_health ( ) : [EOL] assert [number] * [number] == sum ( actor . hit_points for actor in Battle ( test_battle1 ) . actors . values ( ) ) [EOL] [EOL] [EOL] test_data_battle1_space_is_empty = [ [ [number] , [number] , True ] , [ [number] , [number] , False ] , [ [number] , [number] , False ] , [ [number] , [number] , False ] , [ [number] , [number] , True ] , ] [EOL] [EOL] [EOL] @ mark . parametrize ( [string] , test_data_battle1_space_is_empty ) def test_battle_space_is_empty ( x , y , is_empty ) : [EOL] assert is_empty == Battle ( test_battle1 ) . is_empty ( Vector ( x , y ) ) [EOL] [EOL] [EOL] @ mark . slow def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from advent . alchemical_reduction import part1 , part2 [EOL] from advent . input import text [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == part1 ( [string] ) [EOL] [EOL] [EOL] def test_part2 ( ) : [EOL] assert [number] == part2 ( [string] ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from pytest import mark [EOL] [EOL] from advent . input import text [EOL] from advent . settlers_of_the_north_pole import parse , resource_value , next_state , part1 , part2 [EOL] [EOL] test_area_initial_str = [string] . strip ( ) [EOL] [EOL] test_area_step1_str = [string] . strip ( ) [EOL] [EOL] test_area_step10_str = [string] . strip ( ) [EOL] [EOL] [EOL] def test_parse_map ( ) : [EOL] [comment] [EOL] [EOL] map_ = parse ( test_area_initial_str ) [EOL] [EOL] assert [string] == map_ [ [number] ] [ [number] ] [EOL] assert [string] == map_ [ [number] ] [ [number] ] [EOL] assert [string] == map_ [ [number] ] [ [number] ] [EOL] [EOL] [EOL] def test_resource_value ( ) : [EOL] assert [number] == resource_value ( parse ( test_area_step10_str ) ) [EOL] [EOL] [EOL] def test_next_state ( ) : [EOL] assert parse ( test_area_step1_str ) == next_state ( parse ( test_area_initial_str ) ) [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == part1 ( test_area_initial_str ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] @ mark . slow def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from advent . chronal_conversion import part1 , part2 [EOL] [EOL] [EOL] def test_part1_based_on_puzzle_input ( ) : [EOL] assert [number] == part1 ( ) [EOL] [EOL] [EOL] def test_part2_based_on_puzzle_input ( ) : [EOL] assert [number] == part2 ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from pytest import mark [EOL] [EOL] from advent . go_with_the_flow import part1 , part2 [EOL] from advent . input import text [EOL] [EOL] test_program = [string] [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == part1 ( test_program ) [EOL] [EOL] [EOL] @ mark . slow def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from advent . input import text [EOL] from advent . response_record import part1 , part2 , impl1 [EOL] [EOL] test_response_record_data = [string] [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == part1 ( test_response_record_data ) [EOL] [EOL] [EOL] def test_part2 ( ) : [EOL] assert [number] == part2 ( test_response_record_data ) [EOL] [EOL] [EOL] def test_impl1 ( ) : [EOL] assert [ [number] , [number] ] == list ( impl1 ( test_response_record_data ) ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_input ( ) : [EOL] assert [number] == part1 ( text ( [string] ) ) [EOL] [EOL] [EOL] def test_part2_with_puzzle_input ( ) : [EOL] assert [number] == part2 ( text ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from advent . input import text [EOL] from advent . subterranean_sustainability import answer [EOL] [EOL] test_data = [string] . strip ( ) [EOL] [EOL] [EOL] def test_part1 ( ) : [EOL] assert [number] == answer ( test_data , [number] ) [EOL] [EOL] [EOL] def test_part1_with_puzzle_data ( ) : [EOL] assert [number] == answer ( text ( [string] ) , [number] ) [EOL] [EOL] [EOL] def test_part2_with_puzzle_data ( ) : [EOL] assert [number] == answer ( text ( [string] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0