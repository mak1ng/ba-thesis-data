from typing import Optional [EOL] import typing [EOL] import builtins [EOL] from typing import Optional [EOL] [EOL] [EOL] def process_line ( line ) : [EOL] if line == [string] : [EOL] return [string] [EOL] elif line == [string] : [EOL] return [string] [EOL] elif line . startswith ( [string] ) : [EOL] [comment] [EOL] pass [EOL] elif line . startswith ( [string] ) : [EOL] [comment] [EOL] pass [EOL] elif line . startswith ( [string] ) : [EOL] pass [EOL] elif line . startswith ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import board [EOL] import string [EOL] from textwrap import dedent [EOL] [EOL] import pytest [EOL] from board import COLOR , PIECES , Board [EOL] [EOL] [EOL] @ pytest . fixture def board ( ) : [EOL] return Board ( ) [EOL] [EOL] [EOL] def test_pieces_displayed_as_unicode_symbol ( ) : [EOL] assert str ( PIECES . K ) == [string] [EOL] [EOL] [EOL] def test_board_creation_defaults_to_empty_board ( board ) : [EOL] for row in board . mailbox : [EOL] for square in row : [EOL] assert square . piece is None [EOL] [EOL] [EOL] def test_board_created_with_correct_algebraic_notation_coordinates ( board ) : [EOL] assert board . mailbox [ [number] ] [ [number] ] . coordinate == [string] [EOL] [EOL] [EOL] def test_board_created_with_colored_squares ( board ) : [EOL] assert board . mailbox [ [number] ] [ [number] ] . color == COLOR . black [EOL] [EOL] [EOL] def test_can_print_empty_board ( board ) : [EOL] expected_empty_board = [string] [comment] [EOL] assert str ( board ) == expected_empty_board [EOL] [EOL] [EOL] def test_pieces_are_printed_if_they_are_on_square ( board ) : [EOL] board . mailbox [ [number] ] [ [number] ] . piece = PIECES . K [EOL] board . mailbox [ [number] ] [ [number] ] . piece = PIECES . r [EOL] [EOL] expected_board = dedent ( [string] ) [EOL] assert str ( board ) == expected_board [EOL] [EOL] [EOL] def test_get_square_from_coordinate ( board ) : [EOL] for row_number in range ( [number] , [number] ) : [EOL] for col_alpha in string . ascii_lowercase [ : [number] ] : [EOL] coordinate = f"{ col_alpha }{ row_number }" [EOL] square = board . get_square_from_coordinate ( coordinate ) [EOL] assert square . coordinate == coordinate [EOL] [EOL] [EOL] def test_setup_FEN_position ( board ) : [EOL] board . setup_FEN_position ( [string] ) [EOL] assert board . next_move == COLOR . black [EOL] assert board . castling == [string] [EOL] assert board . en_passant is None [EOL] assert board . halfmove_clock == [number] [EOL] assert board . fullmove == [number] [EOL] [EOL] assert board . get_square_from_coordinate ( [string] ) . piece == PIECES . P [EOL] assert board . get_square_from_coordinate ( [string] ) . piece == PIECES . p [EOL] assert board . get_square_from_coordinate ( [string] ) . piece == PIECES . N [EOL] [EOL] board . setup_FEN_position ( [string] ) [EOL] assert board . en_passant == board . get_square_from_coordinate ( [string] ) [EOL] [EOL] [EOL] def test_setup_FEN_position_should_raise_if_invalid ( board ) : [EOL] with pytest . raises ( Exception , match = [string] ) : [EOL] board . setup_FEN_position ( [string] ) [EOL] with pytest . raises ( Exception , match = [string] ) : [EOL] board . setup_FEN_position ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import subprocess [EOL] import signal [EOL] import subprocess [EOL] import sys [EOL] import time [EOL] from pathlib import Path [EOL] from tempfile import NamedTemporaryFile [EOL] from unittest . mock import Mock , call , patch [EOL] [EOL] import pytest [EOL] from uci_server import process_stdin [EOL] [EOL] SERVER_FILE = str ( Path ( [string] ) . resolve ( ) ) [EOL] [EOL] [EOL] def test_can_exit_server_with_ctrl_c ( ) : [EOL] proc = subprocess . Popen ( [ sys . executable , SERVER_FILE ] , stdin = subprocess . PIPE ) [EOL] [comment] [EOL] with pytest . raises ( subprocess . TimeoutExpired ) : [EOL] proc . wait ( timeout = [number] ) [EOL] proc . send_signal ( signal . SIGINT ) [EOL] [EOL] try : [EOL] proc . wait ( timeout = [number] ) [EOL] except subprocess . TimeoutExpired : [comment] [EOL] proc . kill ( ) [EOL] with open ( Path ( [string] ) ) as f : [EOL] pytest . fail ( [string] + f . read ( ) ) [EOL] [EOL] [EOL] def test_server_has_logging ( ) : [EOL] with NamedTemporaryFile ( ) as fp : [EOL] proc = subprocess . Popen ( [ sys . executable , SERVER_FILE , [string] , fp . name ] , stdin = subprocess . PIPE ) [EOL] time . sleep ( [number] ) [EOL] with pytest . raises ( subprocess . TimeoutExpired ) : [EOL] proc . communicate ( input = [string] , timeout = [number] ) [EOL] proc . send_signal ( signal . SIGINT ) [EOL] time . sleep ( [number] ) [EOL] logfile = fp . read ( ) . decode ( [string] ) [EOL] [EOL] [comment] [EOL] for logitem in [ [string] , [string] , [string] , [string] ] : [EOL] assert logitem in logfile [EOL] [EOL] [EOL] def test_delegates_to_uci_interface ( ) : [EOL] with patch ( [string] ) as mock_process_line : [EOL] with patch ( [string] , Mock ( return_value = [string] ) ) : [EOL] process_stdin ( ) [EOL] assert mock_process_line . call_args_list == [ call ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , List , Any , Optional [EOL] import typing [EOL] import builtins [EOL] import board [EOL] import itertools [EOL] import string [EOL] from dataclasses import dataclass [EOL] from itertools import cycle [EOL] from typing import Iterator , List , NamedTuple , Optional [EOL] [EOL] from colorama import Back , Fore , Style [EOL] [EOL] from tabulate import tabulate [EOL] [EOL] [comment] [EOL] Color = bool [EOL] [EOL] [EOL] class Colors ( NamedTuple ) : [EOL] white = False [EOL] black = True [EOL] [EOL] [EOL] COLOR = Colors ( ) [EOL] [EOL] [EOL] [comment] [EOL] @ dataclass ( frozen = True ) class Piece : [EOL] name = ... [EOL] color = ... [EOL] notation = ... [EOL] symbol = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . symbol [EOL] [EOL] [EOL] class Pieces ( NamedTuple ) : [EOL] K = Piece ( name = [string] , color = COLOR . white , notation = [string] , symbol = [string] ) [EOL] Q = Piece ( name = [string] , color = COLOR . white , notation = [string] , symbol = [string] ) [EOL] R = Piece ( name = [string] , color = COLOR . white , notation = [string] , symbol = [string] ) [EOL] B = Piece ( name = [string] , color = COLOR . white , notation = [string] , symbol = [string] ) [EOL] N = Piece ( name = [string] , color = COLOR . white , notation = [string] , symbol = [string] ) [EOL] P = Piece ( name = [string] , color = COLOR . white , notation = [string] , symbol = [string] ) [EOL] k = Piece ( name = [string] , color = COLOR . black , notation = [string] , symbol = [string] ) [EOL] q = Piece ( name = [string] , color = COLOR . black , notation = [string] , symbol = [string] ) [EOL] r = Piece ( name = [string] , color = COLOR . black , notation = [string] , symbol = [string] ) [EOL] b = Piece ( name = [string] , color = COLOR . black , notation = [string] , symbol = [string] ) [EOL] n = Piece ( name = [string] , color = COLOR . black , notation = [string] , symbol = [string] ) [EOL] p = Piece ( name = [string] , color = COLOR . black , notation = [string] , symbol = [string] ) [EOL] [EOL] [EOL] PIECES = Pieces ( ) [EOL] [EOL] [EOL] @ dataclass class Square : [EOL] coordinate = ... [EOL] color = ... [EOL] piece = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . piece . symbol if self . piece else [string] [EOL] [EOL] [EOL] class Board : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mailbox = ... [EOL] next_move = ... [EOL] en_passant = ... [EOL] castling = ... [EOL] half_move_clock = ... [EOL] full_move = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . mailbox = [ ] [EOL] color_iterator = cycle ( [ COLOR . black , COLOR . white ] ) [EOL] for row_number in range ( [number] , [number] , - [number] ) : [EOL] row = [ ] [EOL] for col_alpha in string . ascii_lowercase [ : [number] ] : [EOL] row . append ( Square ( coordinate = f"{ col_alpha }{ row_number }" , color = next ( color_iterator ) , piece = None ) ) [EOL] self . mailbox . append ( row ) [EOL] [EOL] def __repr__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] board_string = [string] + Fore . BLACK + Back . WHITE + [string] [EOL] board_string += tabulate ( self . mailbox , tablefmt = [string] ) [EOL] return board_string + [string] + Style . RESET_ALL + [string] [EOL] [EOL] def get_square_from_coordinate ( self , coordinate ) : [EOL] row = int ( coordinate [ [number] ] ) [EOL] col = ord ( coordinate [ [number] ] . lower ( ) ) - [number] [EOL] return self . mailbox [ - row ] [ col ] [EOL] [EOL] def setup_FEN_position ( self , fen ) : [EOL] fen_mailbox , active , self . castling , en_passant , halfmove_clock , fullmove = fen . split ( [string] ) [EOL] self . halfmove_clock = int ( halfmove_clock ) [EOL] self . fullmove = int ( fullmove ) [EOL] self . next_move = COLOR . white if active == [string] else COLOR . black [EOL] if en_passant != [string] : [EOL] self . en_passant = self . get_square_from_coordinate ( en_passant ) [EOL] else : [EOL] self . en_passant = None [EOL] [EOL] def generate_mailbox_squares ( ) : [EOL] for row in self . mailbox : [EOL] for square in row : [EOL] yield square [EOL] return [string] [EOL] [EOL] mailbox_squares = generate_mailbox_squares ( ) [EOL] [EOL] for row in fen_mailbox . split ( [string] ) : [EOL] for char in row : [EOL] if char . isnumeric ( ) : [EOL] for ii in range ( int ( char ) ) : [EOL] next ( mailbox_squares ) . piece = None [EOL] else : [EOL] next ( mailbox_squares ) . piece = getattr ( PIECES , char ) [EOL] assert next ( mailbox_squares , None ) is None , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Color$ 0 0 0 $Color$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Color$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Piece$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $board.Pieces$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Color$ 0 0 0 $typing.Optional[Piece]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[Square]]$ 0 0 0 $Color$ 0 0 0 $typing.Optional[Square]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[typing.List[board.Square]]$ 0 0 0 0 $itertools.cycle[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[board.Square]]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $Square$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[board.Square]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[board.Square]$ 0 0 0 0 0 0 $typing.Optional[board.Square]$ 0 0 0 0 0 $typing.Optional[board.Square]$ 0 0 0 0 0 0 0 $typing.Optional[board.Square]$ 0 0 0 0 0 $typing.Iterator[Square]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[board.Square]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[board.Square]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[board.Square]$ 0 0 0 0 0 0 $board.Pieces$ 0 0 0 0 0 0 0 $typing.Iterator[board.Square]$ 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Optional [EOL] import typing [EOL] import asyncio [EOL] [docstring] [EOL] import asyncio [EOL] import datetime [EOL] import logging [EOL] import signal [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] from docopt import docopt [EOL] from uci_interface import process_line [EOL] [EOL] HEARTBEAT_FREQUENCY = [number] [EOL] [EOL] [EOL] async def heartbeat ( ) : [EOL] while True : [EOL] logging . debug ( f" [string] { datetime . datetime . now ( ) }" ) [EOL] print ( [string] , flush = True ) [EOL] await asyncio . sleep ( HEARTBEAT_FREQUENCY ) [EOL] [EOL] [EOL] def ask_exit ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] logging . debug ( [string] ) [EOL] [EOL] async def stop_all_tasks ( ) : [EOL] tasks = [ t for t in asyncio . all_tasks ( ) if t is not asyncio . current_task ( ) ] [comment] [EOL] for task in tasks : [EOL] task . cancel ( ) [EOL] await asyncio . wait ( tasks , timeout = [number] ) [EOL] asyncio . get_event_loop ( ) . stop ( ) [EOL] logging . debug ( [string] ) [EOL] [EOL] asyncio . get_event_loop ( ) . create_task ( stop_all_tasks ( ) ) [EOL] [EOL] [EOL] def process_stdin ( ) : [EOL] command = sys . stdin . readline ( ) [EOL] logging . debug ( f" [string] { repr ( command ) }" ) [EOL] command = command . rstrip ( [string] ) [EOL] if command : [EOL] if command == [string] : [EOL] ask_exit ( ) [EOL] response = process_line ( command ) [EOL] if response is not None : [EOL] logging . debug ( f" [string] { repr ( response ) }" ) [EOL] print ( response , flush = True ) [EOL] [EOL] [EOL] async def setup_server ( loop ) : [EOL] loop . create_task ( heartbeat ( ) ) [EOL] loop . add_reader ( sys . stdin . fileno ( ) , process_stdin ) [EOL] loop . add_signal_handler ( signal . SIGINT , ask_exit ) [EOL] [EOL] [EOL] if __name__ == [string] : [comment] [EOL] arguments = docopt ( __doc__ ) [EOL] log_path = str ( arguments [ [string] ] ) if arguments [ [string] ] else [string] [EOL] [comment] [EOL] logging . basicConfig ( filename = str ( Path ( log_path ) . resolve ( ) ) , level = logging . DEBUG ) [EOL] logging . debug ( [string] ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] [comment] [EOL] [comment] [EOL] loop . create_task ( setup_server ( loop ) ) [EOL] loop . run_forever ( ) [EOL] loop . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0