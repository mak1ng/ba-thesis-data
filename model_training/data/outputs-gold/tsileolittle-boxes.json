[comment] [EOL] [EOL] from typing import Dict , Any , List [EOL] import typing [EOL] from distutils . core import setup [EOL] import io [EOL] import os [EOL] [EOL] from setuptools import find_packages [EOL] [EOL] [EOL] here = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] [comment] [EOL] NAME = [string] [EOL] DESCRIPTION = ( [string] ) [EOL] URL = [string] [EOL] EMAIL = [string] [EOL] AUTHOR = [string] [EOL] REQUIRES_PYTHON = [string] [EOL] VERSION = None [EOL] [EOL] [EOL] REQUIRED = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] DEPENDENCY_LINKS = [ ] [EOL] [EOL] [EOL] [comment] [EOL] about = { } [EOL] if not VERSION : [EOL] with open ( os . path . join ( here , NAME , [string] ) ) as f : [EOL] exec ( f . read ( ) , about ) [EOL] else : [EOL] about [ [string] ] = VERSION [EOL] [EOL] [EOL] [comment] [EOL] with io . open ( os . path . join ( here , [string] ) , encoding = [string] ) as f : [EOL] long_description = [string] + f . read ( ) [EOL] [EOL] [EOL] setup ( name = NAME , version = about [ [string] ] , description = DESCRIPTION , long_description = long_description , long_description_content_type = [string] , author = AUTHOR , author_email = EMAIL , python_requires = REQUIRES_PYTHON , url = URL , packages = find_packages ( ) , install_requires = REQUIRED , dependency_links = DEPENDENCY_LINKS , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import key [EOL] import typing [EOL] import little_boxes [EOL] import hashlib [EOL] import logging [EOL] [docstring] [EOL] import base64 [EOL] import hashlib [EOL] import logging [EOL] from datetime import datetime [EOL] from typing import Any [EOL] from typing import Dict [EOL] from typing import Optional [EOL] from urllib . parse import urlparse [EOL] [EOL] from Crypto . Hash import SHA256 [EOL] from Crypto . Signature import PKCS1_v1_5 [EOL] from requests . auth import AuthBase [EOL] [EOL] from . activitypub import get_backend [EOL] from . activitypub import _has_type [EOL] from . errors import ActivityNotFoundError [EOL] from . errors import ActivityGoneError [EOL] from . key import Key [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def _build_signed_string ( signed_headers , method , path , headers , body_digest ) : [EOL] out = [ ] [EOL] for signed_header in signed_headers . split ( [string] ) : [EOL] if signed_header == [string] : [EOL] out . append ( [string] + method . lower ( ) + [string] + path ) [EOL] elif signed_header == [string] : [EOL] out . append ( [string] + body_digest ) [EOL] else : [EOL] out . append ( signed_header + [string] + headers [ signed_header ] ) [EOL] return [string] . join ( out ) [EOL] [EOL] [EOL] def _parse_sig_header ( val ) : [EOL] if not val : [EOL] return None [EOL] out = { } [EOL] for data in val . split ( [string] ) : [EOL] k , v = data . split ( [string] , [number] ) [EOL] out [ k ] = v [ [number] : len ( v ) - [number] ] [comment] [EOL] return out [EOL] [EOL] [EOL] def _verify_h ( signed_string , signature , pubkey ) : [EOL] signer = PKCS1_v1_5 . new ( pubkey ) [EOL] digest = SHA256 . new ( ) [EOL] digest . update ( signed_string . encode ( [string] ) ) [EOL] return signer . verify ( digest , signature ) [EOL] [EOL] [EOL] def _body_digest ( body ) : [EOL] h = hashlib . new ( [string] ) [EOL] h . update ( body ) [comment] [EOL] return [string] + base64 . b64encode ( h . digest ( ) ) . decode ( [string] ) [EOL] [EOL] [EOL] def _get_public_key ( key_id ) : [EOL] actor = get_backend ( ) . fetch_iri ( key_id ) [EOL] if _has_type ( actor [ [string] ] , [string] ) : [EOL] [comment] [EOL] k = Key ( actor [ [string] ] , actor [ [string] ] ) [EOL] k . load_pub ( actor [ [string] ] ) [EOL] else : [EOL] k = Key ( actor [ [string] ] , actor [ [string] ] [ [string] ] ) [EOL] k . load_pub ( actor [ [string] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] if key_id != k . key_id ( ) : [EOL] raise ValueError ( f" [string] { key_id } [string] { actor [ [string] ] [ [string] ] }" ) [EOL] [EOL] return k [EOL] [EOL] [EOL] def verify_request ( method , path , headers , body ) : [EOL] hsig = _parse_sig_header ( headers . get ( [string] ) ) [EOL] if not hsig : [EOL] logger . debug ( [string] ) [EOL] return False [EOL] logger . debug ( f" [string] { hsig }" ) [EOL] signed_string = _build_signed_string ( hsig [ [string] ] , method , path , headers , _body_digest ( body ) ) [EOL] [EOL] try : [EOL] k = _get_public_key ( hsig [ [string] ] ) [EOL] except ( ActivityGoneError , ActivityNotFoundError ) : [EOL] logger . debug ( [string] ) [EOL] return False [EOL] [EOL] return _verify_h ( signed_string , base64 . b64decode ( hsig [ [string] ] ) , k . pubkey ) [EOL] [EOL] [EOL] class HTTPSigAuth ( AuthBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , key ) : [EOL] self . key = key [EOL] [EOL] def __call__ ( self , r ) : [EOL] logger . info ( f" [string] { self . key . key_id ( ) }" ) [EOL] host = urlparse ( r . url ) . netloc [EOL] [EOL] bh = hashlib . new ( [string] ) [EOL] body = r . body [EOL] try : [EOL] body = r . body . encode ( [string] ) [EOL] except AttributeError : [EOL] pass [EOL] bh . update ( body ) [EOL] bodydigest = [string] + base64 . b64encode ( bh . digest ( ) ) . decode ( [string] ) [EOL] [EOL] date = datetime . utcnow ( ) . strftime ( [string] ) [EOL] [EOL] r . headers . update ( { [string] : bodydigest , [string] : date , [string] : host } ) [EOL] [EOL] sigheaders = [string] [EOL] [EOL] to_be_signed = _build_signed_string ( sigheaders , r . method , r . path_url , r . headers , bodydigest ) [EOL] signer = PKCS1_v1_5 . new ( self . key . privkey ) [EOL] digest = SHA256 . new ( ) [EOL] digest . update ( to_be_signed . encode ( [string] ) ) [EOL] sig = base64 . b64encode ( signer . sign ( digest ) ) [EOL] sig = sig . decode ( [string] ) [EOL] [EOL] key_id = self . key . key_id ( ) [EOL] headers = { [string] : f' [string] { key_id } [string] { sigheaders } [string] { sig } [string] ' } [EOL] logger . debug ( f" [string] { headers }" ) [EOL] [EOL] r . headers . update ( headers ) [EOL] [EOL] return r [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.key.Key$ 0 0 0 0 0 $little_boxes.key.Key$ 0 $little_boxes.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $hashlib._Hash$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $hashlib._Hash$ 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $hashlib._Hash$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0
from typing import Dict , Any [EOL] import hashlib [EOL] import builtins [EOL] import typing [EOL] import base64 [EOL] import hashlib [EOL] import typing [EOL] from datetime import datetime [EOL] from typing import Any [EOL] from typing import Dict [EOL] [EOL] from Crypto . Hash import SHA256 [EOL] from Crypto . Signature import PKCS1_v1_5 [EOL] from pyld import jsonld [EOL] [EOL] if typing . TYPE_CHECKING : [EOL] from . key import Key [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] _CACHE = { } [EOL] LOADER = jsonld . requests_document_loader ( ) [EOL] [EOL] [EOL] def _caching_document_loader ( url ) : [EOL] if url in _CACHE : [EOL] return _CACHE [ url ] [EOL] resp = LOADER ( url ) [EOL] _CACHE [ url ] = resp [EOL] return resp [EOL] [EOL] [EOL] jsonld . set_document_loader ( _caching_document_loader ) [EOL] [EOL] [EOL] def _options_hash ( doc ) : [EOL] doc = dict ( doc [ [string] ] ) [EOL] for k in [ [string] , [string] , [string] ] : [EOL] if k in doc : [EOL] del doc [ k ] [EOL] doc [ [string] ] = [string] [EOL] normalized = jsonld . normalize ( doc , { [string] : [string] , [string] : [string] } ) [EOL] h = hashlib . new ( [string] ) [EOL] h . update ( normalized . encode ( [string] ) ) [EOL] return h . hexdigest ( ) [EOL] [EOL] [EOL] def _doc_hash ( doc ) : [EOL] doc = dict ( doc ) [EOL] if [string] in doc : [EOL] del doc [ [string] ] [EOL] normalized = jsonld . normalize ( doc , { [string] : [string] , [string] : [string] } ) [EOL] h = hashlib . new ( [string] ) [EOL] h . update ( normalized . encode ( [string] ) ) [EOL] return h . hexdigest ( ) [EOL] [EOL] [EOL] def verify_signature ( doc , key ) : [EOL] to_be_signed = _options_hash ( doc ) + _doc_hash ( doc ) [EOL] signature = doc [ [string] ] [ [string] ] [EOL] signer = PKCS1_v1_5 . new ( key . pubkey or key . privkey ) [comment] [EOL] digest = SHA256 . new ( ) [EOL] digest . update ( to_be_signed . encode ( [string] ) ) [EOL] return signer . verify ( digest , base64 . b64decode ( signature ) ) [comment] [EOL] [EOL] [EOL] def generate_signature ( doc , key ) : [EOL] options = { [string] : [string] , [string] : doc [ [string] ] + [string] , [string] : datetime . utcnow ( ) . replace ( microsecond = [number] ) . isoformat ( ) + [string] , } [EOL] doc [ [string] ] = options [EOL] to_be_signed = _options_hash ( doc ) + _doc_hash ( doc ) [EOL] if not key . privkey : [EOL] raise ValueError ( f" [string] { key !r}" ) [EOL] [EOL] signer = PKCS1_v1_5 . new ( key . privkey ) [EOL] digest = SHA256 . new ( ) [EOL] digest . update ( to_be_signed . encode ( [string] ) ) [EOL] sig = base64 . b64encode ( signer . sign ( digest ) ) [comment] [EOL] options [ [string] ] = sig . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any [EOL] from typing import Callable [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Optional [EOL] [EOL] from . errors import RecursionLimitExceededError [EOL] from . errors import UnexpectedActivityTypeError [EOL] [EOL] [EOL] def parse_collection ( payload = None , url = None , level = [number] , fetcher = None , ) : [EOL] [docstring] [EOL] if not fetcher : [EOL] raise Exception ( [string] ) [EOL] if level > [number] : [EOL] raise RecursionLimitExceededError ( [string] ) [EOL] [EOL] [comment] [EOL] out = [ ] [EOL] if url : [EOL] payload = fetcher ( url ) [EOL] if not payload : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if payload [ [string] ] in [ [string] , [string] ] : [EOL] if [string] in payload : [EOL] return payload [ [string] ] [EOL] if [string] in payload : [EOL] return payload [ [string] ] [EOL] if [string] in payload : [EOL] if isinstance ( payload [ [string] ] , str ) : [EOL] out . extend ( parse_collection ( url = payload [ [string] ] , level = level + [number] , fetcher = fetcher ) ) [EOL] else : [EOL] if [string] in payload [ [string] ] : [EOL] out . extend ( payload [ [string] ] [ [string] ] ) [EOL] if [string] in payload [ [string] ] : [EOL] out . extend ( payload [ [string] ] [ [string] ] ) [EOL] n = payload [ [string] ] . get ( [string] ) [EOL] if n : [EOL] out . extend ( parse_collection ( url = n , level = level + [number] , fetcher = fetcher ) ) [EOL] return out [EOL] [EOL] while payload : [EOL] if payload [ [string] ] in [ [string] , [string] ] : [EOL] if [string] in payload : [EOL] out . extend ( payload [ [string] ] ) [EOL] if [string] in payload : [EOL] out . extend ( payload [ [string] ] ) [EOL] n = payload . get ( [string] ) [EOL] if n is None : [EOL] break [EOL] payload = fetcher ( n ) [EOL] else : [EOL] raise UnexpectedActivityTypeError ( [string] . format ( payload [ [string] ] ) ) [EOL] [EOL] return out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any [EOL] import little_boxes [EOL] import Crypto [EOL] import builtins [EOL] import typing [EOL] import base64 [EOL] from typing import Any [EOL] from typing import Dict [EOL] from typing import Optional [EOL] [EOL] from Crypto . PublicKey import RSA [EOL] from Crypto . Util import number [EOL] [EOL] [EOL] class Key ( object ) : [EOL] DEFAULT_KEY_SIZE = [number] [EOL] [EOL] def __init__ ( self , owner , id_ = None ) : [EOL] self . owner = owner [EOL] self . privkey_pem = None [EOL] self . pubkey_pem = None [EOL] self . privkey = None [EOL] self . pubkey = None [EOL] self . id_ = id_ [EOL] [EOL] def load_pub ( self , pubkey_pem ) : [EOL] self . pubkey_pem = pubkey_pem [EOL] self . pubkey = RSA . importKey ( pubkey_pem ) [EOL] [EOL] def load ( self , privkey_pem ) : [EOL] self . privkey_pem = privkey_pem [EOL] self . privkey = RSA . importKey ( self . privkey_pem ) [EOL] self . pubkey_pem = self . privkey . publickey ( ) . exportKey ( [string] ) . decode ( [string] ) [EOL] [EOL] def new ( self ) : [EOL] k = RSA . generate ( self . DEFAULT_KEY_SIZE ) [EOL] self . privkey_pem = k . exportKey ( [string] ) . decode ( [string] ) [EOL] self . pubkey_pem = k . publickey ( ) . exportKey ( [string] ) . decode ( [string] ) [EOL] self . privkey = k [EOL] [EOL] def key_id ( self ) : [EOL] return self . id_ or f"{ self . owner } [string] " [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . key_id ( ) , [string] : self . owner , [string] : self . pubkey_pem , [string] : [string] , } [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] try : [EOL] k = cls ( data [ [string] ] , data [ [string] ] ) [EOL] k . load_pub ( data [ [string] ] ) [EOL] except KeyError : [EOL] raise ValueError ( f" [string] { data !r}" ) [EOL] return k [EOL] [EOL] def to_magic_key ( self ) : [EOL] mod = base64 . urlsafe_b64encode ( number . long_to_bytes ( self . privkey . n ) ) . decode ( [string] ) [EOL] pubexp = base64 . urlsafe_b64encode ( number . long_to_bytes ( self . privkey . e ) ) . decode ( [string] ) [EOL] return f" [string] { mod } [string] { pubexp }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[Crypto.PublicKey.RSA.RsaKey]$ 0 0 0 0 0 $typing.Optional[Crypto.PublicKey.RSA.RsaKey]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.key.Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.key.Key$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
from typing import Dict , Optional , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any [EOL] from typing import Dict [EOL] from typing import Optional [EOL] [EOL] [EOL] class Error ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class DropActivityPreProcessError ( Error ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ServerError ( Error ) : [EOL] [docstring] [EOL] [EOL] status_code = [number] [EOL] [EOL] def __init__ ( self , message , status_code = None , payload = None , ) : [EOL] Exception . __init__ ( self ) [EOL] self . message = message [EOL] if status_code is not None : [EOL] self . status_code = status_code [EOL] self . payload = payload [EOL] [EOL] def to_dict ( self ) : [EOL] rv = dict ( self . payload or { } ) [EOL] rv [ [string] ] = self . message [EOL] return rv [EOL] [EOL] def __repr__ ( self ) : [comment] [EOL] return ( f"{ self . __class__ . __qualname__ } [string] { self . message !r} [string] " f" [string] { self . payload !r} [string] { self . status_code } [string] " ) [EOL] [EOL] def __str__ ( self ) : [comment] [EOL] return self . __repr__ ( ) [EOL] [EOL] [EOL] class ActorBlockedError ( ServerError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class NotFromOutboxError ( ServerError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ActivityNotFoundError ( ServerError ) : [EOL] [docstring] [EOL] [EOL] status_code = [number] [EOL] [EOL] [EOL] class ActivityGoneError ( ServerError ) : [EOL] [docstring] [EOL] [EOL] status_code = [number] [EOL] [EOL] [EOL] class BadActivityError ( ServerError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class RecursionLimitExceededError ( BadActivityError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UnexpectedActivityTypeError ( BadActivityError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ActivityUnavailableError ( ServerError ) : [EOL] [docstring] [EOL] [EOL] status_code = [number] [EOL] [EOL] [EOL] class NotAnActivityError ( ServerError ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List , Tuple [EOL] import builtins [EOL] import typing [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Tuple [EOL] [EOL] from markdown import markdown [EOL] [EOL] import regex as re [EOL] [EOL] from . activitypub import get_backend [EOL] from . webfinger import get_actor_url [EOL] [EOL] [EOL] def _set_attrs ( attrs , new = False ) : [EOL] attrs [ ( None , [string] ) ] = [string] [EOL] attrs [ ( None , [string] ) ] = [string] [EOL] attrs [ ( None , [string] ) ] = [string] [EOL] attrs [ ( None , [string] ) ] = attrs [ ( None , [string] ) ] [EOL] return attrs [EOL] [EOL] [EOL] HASHTAG_REGEX = re . compile ( [string] ) [EOL] MENTION_REGEX = re . compile ( [string] ) [EOL] [EOL] [EOL] def hashtagify ( content ) : [EOL] base_url = get_backend ( ) . base_url ( ) [EOL] tags = [ ] [EOL] hashtags = re . findall ( HASHTAG_REGEX , content ) [EOL] hashtags = list ( set ( hashtags ) ) [comment] [EOL] hashtags . sort ( ) [EOL] hashtags . reverse ( ) [comment] [EOL] for hashtag in hashtags : [EOL] tag = hashtag [ [number] : ] [EOL] link = f' [string] { base_url } [string] { tag } [string] { tag } [string] ' [EOL] tags . append ( dict ( href = f"{ base_url } [string] { tag }" , name = hashtag , type = [string] ) ) [EOL] content = content . replace ( hashtag , link ) [EOL] return content , tags [EOL] [EOL] [EOL] def mentionify ( content , hide_domain = False ) : [EOL] tags = [ ] [EOL] for mention in re . findall ( MENTION_REGEX , content ) : [EOL] _ , username , domain = mention . split ( [string] ) [EOL] actor_url = get_actor_url ( mention ) [EOL] if not actor_url : [EOL] [comment] [EOL] continue [EOL] p = get_backend ( ) . fetch_iri ( actor_url ) [EOL] tags . append ( dict ( type = [string] , href = p [ [string] ] , name = mention ) ) [EOL] [EOL] d = f" [string] { domain }" [EOL] if hide_domain : [EOL] d = [string] [EOL] [EOL] link = f' [string] { p [ [string] ] } [string] { username } [string] { d } [string] ' [EOL] content = content . replace ( mention , link ) [EOL] return content , tags [EOL] [EOL] [EOL] def parse_markdown ( content ) : [EOL] tags = [ ] [EOL] content , hashtag_tags = hashtagify ( content ) [EOL] tags . extend ( hashtag_tags ) [EOL] content , mention_tags = mentionify ( content ) [EOL] tags . extend ( mention_tags ) [EOL] content = markdown ( content , extensions = [ [string] ] ) [EOL] return content , tags [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import logging [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def strtobool ( s ) : [comment] [EOL] if s in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] return True [EOL] if s in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] return False [EOL] [EOL] raise ValueError ( f" [string] { s } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
VERSION = ( [number] , [number] , [number] ) [comment] [EOL] [EOL] __version__ = [string] . join ( map ( str , VERSION ) ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import urllib [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import ipaddress [EOL] import logging [EOL] import socket [EOL] from typing import Dict [EOL] from urllib . parse import urlparse [EOL] [EOL] from . errors import Error [EOL] from . errors import ServerError [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] _CACHE = { } [EOL] [EOL] [EOL] class InvalidURLError ( ServerError ) : [EOL] pass [EOL] [EOL] [EOL] class URLLookupFailedError ( Error ) : [EOL] pass [EOL] [EOL] [EOL] def is_url_valid ( url , debug = False ) : [EOL] parsed = urlparse ( url ) [EOL] if parsed . scheme not in [ [string] , [string] ] : [EOL] return False [EOL] [EOL] [comment] [EOL] if debug : [comment] [EOL] return True [EOL] [EOL] if parsed . hostname in [ [string] ] : [EOL] return False [EOL] [EOL] if _CACHE . get ( parsed . hostname , False ) : [EOL] return True [EOL] [EOL] try : [EOL] ip_address = ipaddress . ip_address ( parsed . hostname ) [EOL] except ValueError : [EOL] try : [EOL] ip_address = socket . getaddrinfo ( parsed . hostname , parsed . port or [number] ) [ [number] ] [ [number] ] [ [number] ] [EOL] logger . debug ( f" [string] { parsed . hostname } [string] { ip_address }" ) [EOL] except socket . gaierror : [EOL] logger . exception ( f" [string] { url }" ) [EOL] _CACHE [ parsed . hostname ] = False [EOL] raise URLLookupFailedError ( f" [string] { url }" ) [EOL] [EOL] logger . debug ( f"{ ip_address }" ) [EOL] [EOL] if ipaddress . ip_address ( ip_address ) . is_private : [EOL] logger . info ( f" [string] { url }" ) [EOL] _CACHE [ parsed . hostname ] = False [EOL] return False [EOL] [EOL] _CACHE [ parsed . hostname ] = True [EOL] return True [EOL] [EOL] [EOL] def check_url ( url , debug = False ) : [EOL] logger . debug ( f" [string] { url } [string] { debug }" ) [EOL] if not is_url_valid ( url , debug = debug ) : [EOL] raise InvalidURLError ( f' [string] { url } [string] ' ) [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import json [EOL] import logging [EOL] from typing import Any [EOL] from typing import Dict [EOL] from typing import Optional [EOL] from urllib . parse import urlparse [EOL] [EOL] import requests [EOL] [EOL] from . activitypub import get_backend [EOL] from . urlutils import check_url [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def webfinger ( resource , debug = False ) : [comment] [EOL] [docstring] [EOL] logger . info ( f" [string] { resource }" ) [EOL] protos = [ [string] , [string] ] [EOL] if resource . startswith ( [string] ) : [EOL] protos . reverse ( ) [EOL] host = urlparse ( resource ) . netloc [EOL] elif resource . startswith ( [string] ) : [EOL] host = urlparse ( resource ) . netloc [EOL] else : [EOL] if resource . startswith ( [string] ) : [EOL] resource = resource [ [number] : ] [EOL] if resource . startswith ( [string] ) : [EOL] resource = resource [ [number] : ] [EOL] _ , host = resource . split ( [string] , [number] ) [EOL] resource = [string] + resource [EOL] [EOL] [comment] [EOL] check_url ( f" [string] { host }" , debug = debug ) [EOL] is_404 = False [EOL] [EOL] for i , proto in enumerate ( protos ) : [EOL] try : [EOL] url = f"{ proto } [string] { host } [string] " [EOL] [comment] [EOL] resp = get_backend ( ) . fetch_json ( url , params = { [string] : resource } ) [EOL] break [EOL] except requests . ConnectionError : [EOL] logger . exception ( [string] ) [EOL] [comment] [EOL] if i == [number] : [EOL] continue [EOL] break [EOL] except requests . HTTPError as http_error : [EOL] logger . exception ( [string] ) [EOL] if http_error . response . status_code in [ [number] , [number] ] : [EOL] is_404 = True [EOL] continue [EOL] raise [EOL] if is_404 : [EOL] return None [EOL] resp . raise_for_status ( ) [EOL] try : [EOL] return resp . json ( ) [EOL] except json . JSONDecodeError : [EOL] return None [EOL] [EOL] [EOL] def get_remote_follow_template ( resource , debug = False ) : [EOL] data = webfinger ( resource , debug = debug ) [EOL] if data is None : [EOL] return None [EOL] for link in data [ [string] ] : [EOL] if link . get ( [string] ) == [string] : [EOL] return link . get ( [string] ) [EOL] return None [EOL] [EOL] [EOL] def get_actor_url ( resource , debug = False ) : [EOL] [docstring] [EOL] data = webfinger ( resource , debug = debug ) [EOL] if data is None : [EOL] return None [EOL] for link in data [ [string] ] : [EOL] if ( link . get ( [string] ) == [string] [EOL] and link . get ( [string] ) == [string] ) : [EOL] return link . get ( [string] ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [EOL] import pytest [EOL] from little_boxes import activitypub as ap [EOL] from little_boxes . collection import parse_collection [EOL] from little_boxes . errors import RecursionLimitExceededError [EOL] from little_boxes . errors import UnexpectedActivityTypeError [EOL] [EOL] from test_backend import InMemBackend [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] [EOL] def test_empty_collection ( ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] back . FETCH_MOCK [ [string] ] = { [string] : [string] , [string] : [ ] , [string] : [string] , } [EOL] [EOL] out = parse_collection ( url = [string] , fetcher = back . fetch_iri ) [EOL] assert out == [ ] [EOL] [EOL] [EOL] def test_recursive_collection_limit ( ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] back . FETCH_MOCK [ [string] ] = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] with pytest . raises ( RecursionLimitExceededError ) : [EOL] parse_collection ( url = [string] , fetcher = back . fetch_iri ) [EOL] [EOL] [EOL] def test_unexpected_activity_type ( ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] back . FETCH_MOCK [ [string] ] = { [string] : [string] , [string] : [string] } [EOL] [EOL] with pytest . raises ( UnexpectedActivityTypeError ) : [EOL] parse_collection ( url = [string] , fetcher = back . fetch_iri ) [EOL] [EOL] [EOL] def test_collection ( ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] back . FETCH_MOCK [ [string] ] = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] back . FETCH_MOCK [ [string] ] = { [string] : [string] , [string] : [string] , [string] : [ [number] , [number] , [number] ] , } [EOL] [EOL] out = parse_collection ( url = [string] , fetcher = back . fetch_iri ) [EOL] assert out == [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_ordered_collection ( ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] back . FETCH_MOCK [ [string] ] = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [ [number] , [number] , [number] ] , [string] : [string] , } , [string] : [string] , } [EOL] back . FETCH_MOCK [ [string] ] = { [string] : [string] , [string] : [string] , [string] : [ [number] , [number] , [number] ] , } [EOL] [EOL] out = parse_collection ( url = [string] , fetcher = back . fetch_iri ) [EOL] assert out == [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] from unittest import mock [EOL] [EOL] from little_boxes import activitypub as ap [EOL] from little_boxes import content_helper [EOL] [EOL] from test_backend import InMemBackend [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] [EOL] def test_little_content_helper_simple ( ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] content , tags = content_helper . parse_markdown ( [string] ) [EOL] assert content == [string] [EOL] assert tags == [ ] [EOL] [EOL] [EOL] def test_little_content_helper_linkify ( ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] content , tags = content_helper . parse_markdown ( [string] ) [EOL] assert content . startswith ( [string] ) [EOL] assert [string] in content [EOL] assert tags == [ ] [EOL] [EOL] [EOL] @ mock . patch ( [string] , return_value = [string] ) def test_little_content_helper_mention ( _ ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] back . FETCH_MOCK [ [string] ] = { [string] : [string] , [string] : [string] , } [EOL] [EOL] content , tags = content_helper . parse_markdown ( [string] ) [EOL] assert content == ( [string] [string] ) [EOL] assert tags == [ { [string] : [string] , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] [EOL] @ mock . patch ( [string] , return_value = [string] ) def test_little_content_helper_tag ( _ ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] content , tags = content_helper . parse_markdown ( [string] ) [EOL] base_url = back . base_url ( ) [EOL] assert content == ( f' [string] { base_url } [string] ' f" [string] " ) [EOL] assert tags == [ { [string] : f"{ base_url } [string] " , [string] : [string] , [string] : [string] , } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from unittest import mock [EOL] [EOL] import pytest [EOL] from little_boxes import urlutils [EOL] [EOL] [EOL] def test_urlutils_reject_invalid_scheme ( ) : [EOL] assert not urlutils . is_url_valid ( [string] ) [EOL] [EOL] [EOL] def test_urlutils_reject_localhost ( ) : [EOL] assert not urlutils . is_url_valid ( [string] ) [EOL] [EOL] [EOL] def test_urlutils_reject_private_ip ( ) : [EOL] assert not urlutils . is_url_valid ( [string] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] , return_value = [ [ [number] , [number] , [number] , [number] , [ [string] , None ] ] ] ) def test_urlutils_reject_domain_that_resolve_to_private_ip ( _ ) : [EOL] assert not urlutils . is_url_valid ( [string] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] , return_value = [ [ [number] , [number] , [number] , [number] , [ [string] , None ] ] ] ) def test_urlutils_accept_valid_url ( _ ) : [EOL] assert urlutils . is_url_valid ( [string] ) [EOL] [EOL] [EOL] def test_urlutils_check_url_helper ( ) : [EOL] with pytest . raises ( urlutils . InvalidURLError ) : [EOL] urlutils . check_url ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import little_boxes [EOL] import requests [EOL] import typing [EOL] import logging [EOL] [EOL] import requests [EOL] from little_boxes import activitypub as ap [EOL] from little_boxes import httpsig [EOL] from little_boxes . key import Key [EOL] [EOL] import httpretty [EOL] from test_backend import InMemBackend [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] [EOL] @ httpretty . activate def test_httpsig ( ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] k = Key ( [string] , [string] ) [EOL] k . new ( ) [EOL] back . FETCH_MOCK [ [string] ] = { [string] : k . to_dict ( ) , [string] : [string] , [string] : [string] , } [EOL] [EOL] httpretty . register_uri ( httpretty . POST , [string] , body = [string] ) [EOL] [EOL] auth = httpsig . HTTPSigAuth ( k ) [EOL] resp = requests . post ( [string] , json = { [string] : [number] } , auth = auth ) [EOL] [EOL] assert httpsig . verify_request ( resp . request . method , resp . request . path_url , resp . request . headers , resp . request . body , ) [EOL] [EOL] [EOL] @ httpretty . activate def test_httpsig_key ( ) : [EOL] back = InMemBackend ( ) [EOL] ap . use_backend ( back ) [EOL] [EOL] k = Key ( [string] , [string] ) [EOL] k . new ( ) [EOL] back . FETCH_MOCK [ [string] ] = k . to_dict ( ) [EOL] [EOL] httpretty . register_uri ( httpretty . POST , [string] , body = [string] ) [EOL] [EOL] auth = httpsig . HTTPSigAuth ( k ) [EOL] resp = requests . post ( [string] , json = { [string] : [number] } , auth = auth ) [EOL] [EOL] assert httpsig . verify_request ( resp . request . method , resp . request . path_url , resp . request . headers , resp . request . body , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Optional , Any , List [EOL] import typing [EOL] import json [EOL] import logging [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] from little_boxes import urlutils [EOL] from little_boxes import webfinger [EOL] [EOL] import httpretty [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] [EOL] _WEBFINGER_RESP = { [string] : [ [string] ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , } , ] , [string] : [string] , } [EOL] [EOL] [EOL] @ mock . patch ( [string] , return_value = None ) @ mock . patch ( [string] , return_value = None ) @ httpretty . activate def test_webfinger ( _ , _1 ) : [EOL] [comment] [EOL] httpretty . register_uri ( httpretty . GET , [string] , body = json . dumps ( _WEBFINGER_RESP ) , ) [EOL] data = webfinger . webfinger ( [string] ) [EOL] assert data == _WEBFINGER_RESP [EOL] [EOL] assert webfinger . get_actor_url ( [string] ) == [string] [EOL] assert ( webfinger . get_remote_follow_template ( [string] ) == [string] ) [EOL] [EOL] [EOL] def test_webfinger_invalid_url ( ) : [EOL] with pytest . raises ( urlutils . InvalidURLError ) : [EOL] webfinger . webfinger ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import little_boxes [EOL] from little_boxes . key import Key [EOL] [EOL] [EOL] def test_key_new_load ( ) : [EOL] owner = [string] [EOL] k = Key ( owner ) [EOL] k . new ( ) [EOL] [EOL] assert k . to_dict ( ) == { [string] : f"{ owner } [string] " , [string] : owner , [string] : k . pubkey_pem , [string] : [string] , } [EOL] [EOL] k2 = Key ( owner ) [EOL] k2 . load ( k . privkey_pem ) [EOL] [EOL] assert k2 . to_dict ( ) == k . to_dict ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Optional , Any , List , Tuple [EOL] import little_boxes [EOL] import tests [EOL] import builtins [EOL] import typing [EOL] import json [EOL] from typing import List [EOL] from typing import Optional [EOL] [EOL] import little_boxes . activitypub as ap [EOL] from little_boxes . backend import Backend [EOL] [EOL] [EOL] def track_call ( f ) : [EOL] [docstring] [EOL] fname = f . __name__ [EOL] [EOL] def wrapper ( * args , ** kwargs ) : [EOL] args [ [number] ] . _METHOD_CALLS [ args [ [number] ] . id ] . append ( ( fname , args , kwargs ) ) [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] class InMemBackend ( Backend ) : [EOL] [docstring] [EOL] [EOL] DB = { } [EOL] USERS = { } [EOL] FETCH_MOCK = { } [EOL] INBOX_IDX = { } [EOL] OUTBOX_IDX = { } [EOL] FOLLOWERS = { } [EOL] FOLLOWING = { } [EOL] [EOL] [comment] [EOL] _METHOD_CALLS = { } [EOL] [EOL] def called_methods ( self , p ) : [EOL] data = list ( self . _METHOD_CALLS [ p . id ] ) [EOL] self . _METHOD_CALLS [ p . id ] = [ ] [EOL] return data [EOL] [EOL] def assert_called_methods ( self , p , * asserts ) : [EOL] calls = self . called_methods ( p ) [EOL] for i , assert_data in enumerate ( asserts ) : [EOL] if len ( calls ) < i + [number] : [EOL] raise ValueError ( f" [string] { i }" ) [EOL] error_msg , name , * funcs = assert_data [EOL] if name != calls [ i ] [ [number] ] : [EOL] raise ValueError ( f" [string] { name } [string] { i } [string] { calls [ i ] [ [number] ] }" ) [EOL] if len ( funcs ) < len ( calls [ i ] [ [number] ] ) - [number] : [EOL] raise ValueError ( f" [string] { name } [string] { i }" ) [EOL] for z , f in enumerate ( funcs ) : [EOL] if len ( calls [ i ] [ [number] ] ) < z + [number] : [comment] [EOL] raise ValueError ( f" [string] { name } [string] { z }" ) [EOL] try : [EOL] f ( calls [ i ] [ [number] ] [ z + [number] ] ) [EOL] except AssertionError as ae : [EOL] ae . args = ( (error_msg) , ) [EOL] raise ae [EOL] [EOL] if len ( asserts ) < len ( calls ) : [EOL] raise ValueError ( f" [string] { len ( calls ) } [string] { len ( asserts ) } [string] " f" [string] { calls [ len ( asserts ) : ] !r}" ) [EOL] [EOL] return calls [EOL] [EOL] def debug_mode ( self ) : [EOL] return True [EOL] [EOL] def setup_actor ( self , name , pusername ) : [EOL] [docstring] [EOL] p = ap . Person ( name = name , preferredUsername = pusername , summary = [string] , id = f" [string] { pusername }" , inbox = f" [string] { pusername } [string] " , followers = f" [string] { pusername } [string] " , following = f" [string] { pusername } [string] " , ) [EOL] [EOL] self . USERS [ p . preferredUsername ] = p [EOL] self . DB [ p . id ] = { [string] : [ ] , [string] : [ ] } [EOL] self . INBOX_IDX [ p . id ] = { } [EOL] self . OUTBOX_IDX [ p . id ] = { } [EOL] self . FOLLOWERS [ p . id ] = [ ] [EOL] self . FOLLOWING [ p . id ] = [ ] [EOL] self . FETCH_MOCK [ p . id ] = p . to_dict ( ) [EOL] self . _METHOD_CALLS [ p . id ] = [ ] [EOL] return p [EOL] [EOL] def fetch_iri ( self , iri ) : [EOL] if iri . endswith ( [string] ) : [EOL] data = self . FOLLOWERS [ iri . replace ( [string] , [string] ) ] [EOL] return { [string] : iri , [string] : ap . ActivityType . ORDERED_COLLECTION . value , [string] : len ( data ) , [string] : data , } [EOL] if iri . endswith ( [string] ) : [EOL] data = self . FOLLOWING [ iri . replace ( [string] , [string] ) ] [EOL] return { [string] : iri , [string] : ap . ActivityType . ORDERED_COLLECTION . value , [string] : len ( data ) , [string] : data , } [EOL] return self . FETCH_MOCK [ iri ] [EOL] [EOL] def get_user ( self , username ) : [EOL] if username in self . USERS : [EOL] return self . USERS [ username ] [EOL] else : [EOL] raise ValueError ( f" [string] { username }" ) [EOL] [EOL] @ track_call def outbox_is_blocked ( self , as_actor , actor_id ) : [EOL] [docstring] [EOL] for activity in self . DB [ as_actor . id ] [ [string] ] : [EOL] if activity . ACTIVITY_TYPE == ap . ActivityType . BLOCK : [EOL] return True [EOL] return False [EOL] [EOL] def inbox_check_duplicate ( self , as_actor , iri ) : [EOL] for activity in self . DB [ as_actor . id ] [ [string] ] : [EOL] if activity . id == iri : [EOL] return activity [EOL] [EOL] return None [EOL] [EOL] @ track_call def inbox_new ( self , as_actor , activity ) : [EOL] if activity . id in self . INBOX_IDX [ as_actor . id ] : [EOL] return [EOL] self . DB [ as_actor . id ] [ [string] ] . append ( activity ) [EOL] self . INBOX_IDX [ as_actor . id ] [ activity . id ] = activity [EOL] [EOL] def base_url ( self ) : [EOL] return [string] [EOL] [EOL] def activity_url ( self , obj_id ) : [EOL] [comment] [EOL] return f" [string] { obj_id }" [EOL] [EOL] def note_url ( self , obj_id ) : [EOL] [comment] [EOL] return f" [string] { obj_id }" [EOL] [EOL] @ track_call def outbox_new ( self , as_actor , activity ) : [EOL] print ( f" [string] { activity !r} [string] " ) [EOL] actor_id = activity . get_actor ( ) . id [EOL] if activity . id in self . OUTBOX_IDX [ actor_id ] : [EOL] return [EOL] self . DB [ actor_id ] [ [string] ] . append ( activity ) [EOL] self . OUTBOX_IDX [ actor_id ] [ activity . id ] = activity [EOL] self . FETCH_MOCK [ activity . id ] = activity . to_dict ( ) [EOL] if isinstance ( activity , ap . Create ) : [EOL] self . FETCH_MOCK [ activity . get_object ( ) . id ] = activity . get_object ( ) . to_dict ( ) [EOL] [EOL] @ track_call def new_follower ( self , as_actor , follow ) : [EOL] self . FOLLOWERS [ follow . get_object ( ) . id ] . append ( follow . get_actor ( ) . id ) [EOL] [EOL] @ track_call def undo_new_follower ( self , as_actor , follow ) : [EOL] self . FOLLOWERS [ follow . get_object ( ) . id ] . remove ( follow . get_actor ( ) . id ) [EOL] [EOL] @ track_call def new_following ( self , as_actor , follow ) : [EOL] print ( f" [string] { follow !r}" ) [EOL] self . FOLLOWING [ as_actor . id ] . append ( follow . get_object ( ) . id ) [EOL] [EOL] @ track_call def undo_new_following ( self , as_actor , follow ) : [EOL] self . FOLLOWING [ as_actor . id ] . remove ( follow . get_object ( ) . id ) [EOL] [EOL] def followers ( self , as_actor ) : [EOL] return self . FOLLOWERS [ as_actor . id ] [EOL] [EOL] def following ( self , as_actor ) : [EOL] return self . FOLLOWING [ as_actor . id ] [EOL] [EOL] @ track_call def post_to_remote_inbox ( self , as_actor , payload_encoded , recp ) : [EOL] payload = json . loads ( payload_encoded ) [EOL] print ( f" [string] { payload } [string] { recp }" ) [EOL] act = ap . parse_activity ( payload ) [EOL] as_actor = ap . parse_activity ( self . fetch_iri ( recp . replace ( [string] , [string] ) ) ) [EOL] act . process_from_inbox ( as_actor ) [EOL] [EOL] @ track_call def inbox_like ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def inbox_undo_like ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def outbox_like ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def outbox_undo_like ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def inbox_announce ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def inbox_undo_announce ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def outbox_announce ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def outbox_undo_announce ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def inbox_delete ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def outbox_delete ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def inbox_update ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def outbox_update ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def inbox_create ( self , as_actor , activity ) : [EOL] pass [EOL] [EOL] @ track_call def outbox_create ( self , as_actor , activity ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 $little_boxes.activitypub.ObjectType$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $little_boxes.activitypub.Person$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[little_boxes.activitypub.BaseActivity]$ 0 0 0 $little_boxes.activitypub.Person$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 $typing.Any$ 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 $typing.Any$ 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 $little_boxes.activitypub.Follow$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 0 0 $typing.Any$ 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $little_boxes.activitypub.BaseActivity$ 0 0 0 $little_boxes.activitypub.Person$ 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Like$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Like$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Like$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Like$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Announce$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Announce$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Announce$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Announce$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Delete$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Delete$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Update$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Update$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Create$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $little_boxes.activitypub.Person$ 0 $little_boxes.activitypub.Create$ 0 0 0 0 0
from typing import Any [EOL] import little_boxes [EOL] import typing [EOL] import json [EOL] import logging [EOL] [EOL] from little_boxes import linked_data_sig [EOL] from little_boxes . key import Key [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] [EOL] DOC = [string] [comment] [EOL] [EOL] [EOL] def test_linked_data_sig ( ) : [EOL] doc = json . loads ( DOC ) [EOL] [EOL] k = Key ( [string] ) [EOL] k . new ( ) [EOL] [EOL] linked_data_sig . generate_signature ( doc , k ) [EOL] assert linked_data_sig . verify_signature ( doc , k ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0