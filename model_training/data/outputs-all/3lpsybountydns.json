[comment] [EOL] from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import asyncio [EOL] import uvloop [EOL] [EOL] asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ( ) ) [EOL] [EOL] from sys import exit [EOL] [EOL] [EOL] async def call_command ( command , args ) : [EOL] result = await command . make ( args ) . call ( ) [EOL] return result [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] from boucanpy . cli import commands [EOL] from boucanpy . cli . parser import make_parser [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] [comment] [EOL] parser = make_parser ( ) [EOL] args = parser . parse_args ( ) [EOL] for command in commands : [EOL] if command . has_command ( args . command ) : [EOL] result = loop . run_until_complete ( call_command ( command , args ) ) [EOL] exit ( result ) [EOL] parser . print_help ( ) [EOL] exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
	0
from http . server import HTTPServer [EOL] [EOL] [EOL] class HttpServer ( HTTPServer ) : [EOL] is_ssl = False [EOL] [EOL] def __init__ ( self , server_address , handler_class , api_client , logger ) : [EOL] self . api_client = api_client [EOL] self . logger = logger [EOL] super ( ) . __init__ ( server_address , handler_class ) [EOL] [EOL] [EOL] class HttpsServer ( HttpServer ) : [EOL] is_ssl = True [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0
from typing import Literal , Union [EOL] import typing [EOL] import typing_extensions [EOL] import threading [EOL] from boucanpy . core import logger [EOL] [EOL] from boucanpy . http . handler import HttpHandler [EOL] from boucanpy . http . server import HttpServer , HttpsServer [EOL] import ssl as ssllib [EOL] [EOL] [EOL] class HttpServerManager : [EOL] def __init__ ( self , port = [number] , listen = [string] , ssl = False , ssl_key_path = None , ssl_cert_path = None , api_client = None , ) : [EOL] self . port = int ( port ) [EOL] self . listen = listen [EOL] self . ssl = ssl [EOL] self . api_client = api_client [EOL] self . logger = logger [EOL] if not ssl : [EOL] self . server = HttpServer ( ( self . listen , self . port ) , HttpHandler , api_client , logger ) [EOL] else : [EOL] self . server = HttpsServer ( ( self . listen , self . port ) , HttpHandler , api_client , logger ) [EOL] logger . info ( f" [string] { ssl_cert_path } [string] { ssl_key_path }" ) [EOL] self . server . socket = ssllib . wrap_socket ( self . server . socket , server_side = True , certfile = ssl_cert_path , keyfile = ssl_key_path , ssl_version = ssllib . PROTOCOL_TLS , ) [EOL] [EOL] self . thread = None [EOL] [EOL] def start ( self ) : [EOL] if self . ssl : [EOL] logger . info ( [string] ) [EOL] else : [EOL] logger . info ( [string] ) [EOL] if not self . server : [EOL] raise Exception ( [string] ) [EOL] self . server . serve_forever ( ) [EOL] [EOL] def start_thread ( self ) : [EOL] proto = [string] if self . ssl else [string] [EOL] logger . info ( f" [string] { proto }{ self . listen } [string] { self . port }" ) [EOL] self . thread = threading . Thread ( target = self . server . serve_forever ) [EOL] self . thread . daemon = True [EOL] self . thread . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] logger . info ( [string] ) [EOL] if not self . server : [EOL] raise Exception ( [string] ) [EOL] self . server . shutdown ( ) [EOL] [EOL] def is_alive ( self ) : [EOL] if not self . thread : [EOL] logger . info ( [string] ) [EOL] return False [EOL] return self . thread . isAlive ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import io [EOL] import socket [comment] [EOL] from http . server import BaseHTTPRequestHandler [EOL] import io [EOL] import os [EOL] import shutil [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class HttpHandler ( BaseHTTPRequestHandler ) : [EOL] def do_GET ( self ) : [EOL] self . server . logger . info ( [string] ) [EOL] self . create_http_request ( [string] ) [EOL] return self . dummy_response ( ) [EOL] [EOL] def do_HEAD ( self ) : [EOL] self . server . logger . info ( [string] ) [EOL] self . create_http_request ( [string] ) [EOL] return self . dummy_response ( ) [EOL] [EOL] def do_OPTIONS ( self ) : [EOL] self . server . logger . info ( [string] ) [EOL] [EOL] self . create_http_request ( [string] ) [EOL] return self . dummy_response ( ) [EOL] [EOL] def do_POST ( self ) : [EOL] self . server . logger . info ( [string] ) [EOL] self . create_http_request ( [string] ) [EOL] return self . dummy_response ( ) [EOL] [EOL] def do_PATCH ( self ) : [EOL] self . server . logger . info ( [string] ) [EOL] self . create_http_request ( [string] ) [EOL] return self . dummy_response ( ) [EOL] [EOL] def do_PUT ( self ) : [EOL] self . server . logger . info ( [string] ) [EOL] self . create_http_request ( [string] ) [EOL] return self . dummy_response ( ) [EOL] [EOL] def do_DELETE ( self ) : [EOL] self . server . logger . info ( [string] ) [EOL] self . create_http_request ( [string] ) [EOL] return self . dummy_response ( ) [EOL] [EOL] def send_error ( self , code , message = None , explain = None ) : [EOL] self . server . logger . info ( [string] ) [EOL] [EOL] type = [string] [EOL] if hasattr ( self , [string] ) : [EOL] name = self . headers . get ( [string] , self . client_address [ [number] ] ) [EOL] else : [EOL] name = self . client_address [ [number] ] [EOL] [EOL] if [string] in name : [EOL] name = name . split ( [string] ) [ [number] ] [EOL] [EOL] path = self . path or [string] [EOL] [EOL] source_address = self . client_address [ [number] ] [EOL] source_port = self . client_address [ [number] ] [EOL] protocol = self . get_protocol ( ) [EOL] raw_request = ( [string] + str ( code ) + [string] + [string] + str ( message ) + [string] + [string] + str ( explain ) ) [EOL] self . server . api_client . create_http_request ( name , path , source_address , source_port , type , protocol , raw_request , ) [EOL] return super ( ) . send_error ( code , message = None , explain = None ) [EOL] [EOL] def dummy_response ( self ) : [EOL] [EOL] f = io . BytesIO ( ) [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] f . write ( [string] ) [EOL] length = f . tell ( ) [EOL] f . seek ( [number] ) [EOL] self . send_response ( [number] ) [EOL] self . send_header ( [string] , [string] ) [EOL] self . send_header ( [string] , str ( length ) ) [EOL] self . end_headers ( ) [EOL] if f : [EOL] self . copyfile ( f , self . wfile ) [EOL] f . close ( ) [EOL] [EOL] def create_http_request ( self , method ) : [EOL] self . server . logger . info ( [string] ) [EOL] type = method . upper ( ) [EOL] if hasattr ( self , [string] ) : [EOL] name = self . headers . get ( [string] , self . client_address [ [number] ] ) [EOL] else : [EOL] name = self . client_address [ [number] ] [EOL] [EOL] path = self . path [EOL] [EOL] if [string] in name : [EOL] name = name . split ( [string] ) [ [number] ] [EOL] source_address = self . client_address [ [number] ] [EOL] source_port = self . client_address [ [number] ] [EOL] protocol = self . get_protocol ( ) [EOL] raw_request = str ( self . build_raw_request ( method ) ) [EOL] self . server . api_client . create_http_request ( name , path , source_address , source_port , type , protocol , raw_request , ) [EOL] [EOL] def build_raw_request ( self , method ) : [EOL] self . server . logger . info ( [string] ) [EOL] request = self . raw_requestline . decode ( ) . rstrip ( [string] ) [EOL] [EOL] self . server . logger . info ( [string] ) [EOL] [EOL] if hasattr ( self , [string] ) : [EOL] for h , v in self . headers . items ( ) : [EOL] request = request + [string] + str ( h ) + [string] + str ( v ) [EOL] [EOL] if method in [ [string] , [string] , [string] , [string] ] : [EOL] self . server . logger . info ( [string] ) [EOL] data = self . parse_data ( ) [EOL] try : [EOL] data = data . decode ( ) [EOL] except Exception as e : [EOL] self . server . logger . warning ( [string] ) [EOL] request = request + [string] + str ( data ) [EOL] return request [EOL] [EOL] def parse_data ( self ) : [EOL] content_length = [number] [EOL] try : [EOL] found = False [EOL] for h , v in self . headers . items ( ) : [EOL] if h . lower ( ) == [string] : [EOL] content_length = int ( v ) [EOL] found = True [EOL] if not found : [EOL] self . server . logger . warning ( [string] ) [EOL] [comment] [EOL] except Exception as e : [EOL] self . server . logger . warning ( [string] ) [EOL] data = [string] . encode ( ) [EOL] return data [EOL] [EOL] try : [EOL] data = self . rfile . read ( content_length ) [EOL] return data [EOL] except socket . timeout as e : [EOL] [comment] [EOL] self . server . logger . warning ( f" [string] { content_length }" ) [EOL] [comment] [EOL] return data [EOL] [EOL] def copyfile ( self , source , outputfile ) : [EOL] shutil . copyfileobj ( source , outputfile ) [EOL] [EOL] def get_protocol ( self ) : [EOL] return [string] if self . server . is_ssl else [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 $builtins.int$ 0 $io.BytesIO$ 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import _importlib_modulespec [EOL] from os import walk [EOL] from pathlib import Path [EOL] from os . path import join , basename [EOL] from importlib import import_module [EOL] from boucanpy . core . utils import cli_dir , snake_to_title [EOL] [EOL] commands = [ ] [EOL] [EOL] [EOL] def extact_commands ( parent_dir , parent_mod ) : [EOL] _commands = [ ] [EOL] for directory_name , sub_directories , files in walk ( parent_dir ) : [EOL] [comment] [EOL] if not basename ( directory_name ) . startswith ( ( [string] , [string] ) ) : [EOL] for f in sorted ( files ) : [EOL] if ( not f . startswith ( ( [string] , [string] ) ) [EOL] and Path ( join ( parent_dir , f ) ) . is_file ( ) ) : [EOL] base_name = f . split ( [string] ) [ [number] ] [EOL] class_name = snake_to_title ( base_name ) [EOL] module_path = f"{ parent_mod } [string] { base_name }" [EOL] module = import_module ( module_path , class_name ) [EOL] _command = getattr ( module , class_name , None ) [EOL] if _command : [EOL] _commands . append ( _command ) [EOL] else : [EOL] if module_path != [string] : [EOL] print ( f" [string] { module_path }" ) [EOL] [EOL] for directory_name , sub_directories , files in walk ( parent_dir ) : [EOL] [comment] [EOL] for sub_dir_name in sub_directories : [EOL] if not sub_dir_name . startswith ( ( [string] , [string] ) ) : [EOL] sub_dir = join ( parent_dir , sub_dir_name ) [EOL] _commands = _commands + extact_commands ( sub_dir , f"{ parent_mod } [string] { sub_dir_name }" ) [EOL] return _commands [EOL] [EOL] [EOL] for c in extact_commands ( cli_dir ( ) , [string] ) : [EOL] commands . append ( c ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0
import argparse [EOL] import argparse [EOL] from boucanpy . cli import commands [EOL] [EOL] [EOL] def make_parser ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] sub_parser = parser . add_subparsers ( help = [string] , dest = [string] ) [EOL] for command in commands : [EOL] command . apply_parser ( sub_parser ) [EOL] return parser [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from ipaddress import ip_address [EOL] from boucanpy . core . security import hash_password [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . db . models . user import User [EOL] [EOL] [EOL] class UserCreate ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] parser . add_argument ( [string] , [string] , action = [string] , required = True , type = str , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] self . db_register ( ) [EOL] email = self . option ( [string] ) . lower ( ) [EOL] password = self . get_password ( ) [EOL] hashed_password = hash_password ( password ) [EOL] is_superuser = bool ( self . option ( [string] ) ) [EOL] user = User ( email = email , hashed_password = hashed_password , is_superuser = is_superuser ) [EOL] [EOL] self . session ( ) . add ( user ) [EOL] self . session ( ) . commit ( ) [EOL] [EOL] def get_password ( self ) : [EOL] if self . option ( [string] ) : [EOL] return self . option ( [string] ) [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . db . models . user import User [EOL] [EOL] [EOL] class UserList ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] self . db_register ( ) [EOL] for user in self . session ( ) . query ( User ) . all ( ) : [EOL] print ( user . id , user . email , user . is_superuser ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Optional , Any [EOL] import typing [EOL] import boucanpy [EOL] import uvicorn [EOL] [EOL] from uvicorn import Config as UvicornConfig , Server as UvicornServer [EOL] from uvicorn . supervisors import Multiprocess , StatReload [EOL] [EOL] [EOL] from os import environ [EOL] from boucanpy . core import logger , set_log_level [EOL] from boucanpy . core . utils import project_dir [EOL] from boucanpy . core . security import hash_password [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . cli . db_setup import DbSetup [EOL] from boucanpy . cli . db_wait import DbWait [EOL] from boucanpy . db . factories import factory [EOL] [EOL] [EOL] class ApiServer ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] add_log_level = True [EOL] add_debug = True [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] app = [string] [EOL] kwargs = self . get_kwargs ( ) [EOL] [EOL] if self . should_import_check ( ) : [EOL] logger . info ( [string] ) [EOL] from boucanpy . api . main import api [EOL] [EOL] logger . critical ( [string] . format ( str ( kwargs ) ) ) [EOL] from boucanpy . db . checks import is_db_up , is_db_setup [EOL] [EOL] [comment] [EOL] if self . should_db_check ( ) : [EOL] logger . info ( [string] ) [EOL] db_wait_options = self . _args_to_dict ( self . options ) [EOL] await DbWait ( db_wait_options ) . run ( ) [EOL] [EOL] if self . option ( [string] ) : [EOL] logger . critical ( [string] ) [EOL] db_setup_options = self . _args_to_dict ( self . options ) [EOL] if self . option ( [string] ) : [EOL] db_setup_options [ [string] ] = True [EOL] await DbSetup ( db_setup_options ) . run ( ) [EOL] [EOL] if self . should_db_check ( ) : [EOL] logger . info ( [string] ) [EOL] [EOL] db_setup = is_db_setup ( ) [EOL] if not db_setup : [EOL] logger . critical ( [string] ) [EOL] return self . exit ( [number] ) [EOL] [EOL] from boucanpy . broadcast import is_broadcast_up [EOL] [EOL] if self . should_bcast_check ( ) : [EOL] bcast_up = await is_broadcast_up ( ) [EOL] if not bcast_up : [EOL] logger . critical ( [string] ) [EOL] return self . exit ( [number] ) [EOL] [EOL] if self . option ( [string] , False ) : [EOL] self . seed_from_env ( ) [EOL] [EOL] [comment] [EOL] [EOL] logger . debug ( [string] ) [EOL] config = UvicornConfig ( app , log_config = self . get_uvicorn_logging ( ) , ** kwargs ) [EOL] server = UvicornServer ( config = config ) [EOL] if self . option ( [string] ) : [EOL] server . force_exit = True [EOL] [EOL] if isinstance ( app , str ) and ( config . debug or config . reload ) : [EOL] logger . warning ( f" [string] " ) [EOL] sock = config . bind_socket ( ) [EOL] supervisor = StatReload ( config ) [EOL] return supervisor . run ( server . run , sockets = [ sock ] ) [EOL] elif config . workers > [number] : [EOL] sock = config . bind_socket ( ) [EOL] supervisor = Multiprocess ( config ) [EOL] logger . warning ( f" [string] " ) [EOL] return supervisor . run ( server . run , sockets = [ sock ] ) [EOL] else : [EOL] sockets = None [EOL] logger . warning ( f" [string] " ) [EOL] return await server . serve ( sockets = sockets ) [EOL] [EOL] def get_kwargs ( self ) : [EOL] kwargs = { [string] : self . option ( [string] ) , [string] : self . option ( [string] ) , [string] : self . get_log_level ( ) , } [EOL] if self . get_reload ( ) : [EOL] kwargs [ [string] ] = self . get_reload ( ) [EOL] kwargs [ [string] ] = [ project_dir ( ) ] [EOL] [EOL] elif self . get_workers ( ) : [EOL] kwargs [ [string] ] = int ( self . get_workers ( ) ) [EOL] [EOL] if self . option ( [string] , None ) : [EOL] kwargs [ [string] ] = True [EOL] return kwargs [EOL] [EOL] def get_reload ( self ) : [EOL] if self . option ( [string] , None ) : [EOL] return True [EOL] return bool ( self . option ( [string] ) ) [EOL] [EOL] def get_workers ( self ) : [EOL] if self . option ( [string] , None ) or self . option ( [string] , None ) : [EOL] logger . critical ( [string] ) [EOL] return None [EOL] return self . option ( [string] , [number] ) [EOL] [EOL] def should_import_check ( self ) : [EOL] return ( self . option ( [string] , False ) or self . env ( [string] , [number] , int_ = True ) == [number] ) [EOL] [EOL] def should_db_check ( self ) : [EOL] if not self . option ( [string] , False ) : [EOL] return True [EOL] elif self . env ( [string] , [number] , int_ = True ) == [number] : [EOL] return True [EOL] return False [EOL] [EOL] def should_bcast_check ( self ) : [EOL] if self . env ( [string] , [number] , int_ = True ) == [number] : [EOL] return False [EOL] elif self . option ( [string] , False ) : [EOL] return False [EOL] elif self . env ( [string] , [number] , int_ = True ) == [number] : [EOL] return False [EOL] return True [EOL] [EOL] def seed_from_env ( self ) : [EOL] from boucanpy . core . user import UserRepo [EOL] from boucanpy . core . zone import ZoneRepo [EOL] from boucanpy . core . dns_server import DnsServerRepo [EOL] from boucanpy . db . session import _scoped_session [EOL] [EOL] session = _scoped_session [EOL] [EOL] for i in range ( [number] ) : [EOL] i = str ( i ) [EOL] user_data = { } [EOL] email_key = f" [string] { i } [string] " [EOL] email = environ . get ( email_key , None ) [EOL] password_key = f" [string] { i } [string] " [EOL] password = environ . get ( password_key , None ) [EOL] superuser_key = f" [string] { i } [string] " [EOL] is_superuser = int ( environ . get ( superuser_key , [number] ) ) [EOL] if email and password : [EOL] email = email . lower ( ) [EOL] hashed_password = hash_password ( password ) [EOL] repo = UserRepo ( db = session ) [EOL] if not repo . exists ( email = email ) : [EOL] logger . info ( f" [string] { email }" ) [EOL] user = factory ( [string] , session = session ) . create ( email = email , hashed_password = hashed_password , is_superuser = is_superuser , ) [EOL] else : [EOL] logger . info ( f" [string] { email } [string] " ) [EOL] [EOL] for i in range ( [number] ) : [EOL] i = str ( i ) [EOL] name_key = f" [string] { i } [string] " [EOL] name = environ . get ( name_key , None ) [EOL] if name : [EOL] repo = DnsServerRepo ( db = session ) [EOL] if not repo . exists ( name = name ) : [EOL] logger . info ( f" [string] { name }" ) [EOL] domain = factory ( [string] , session = session ) . create ( name = name ) [EOL] [EOL] for i in range ( [number] ) : [EOL] i = str ( i ) [EOL] ip_key = f" [string] { i } [string] " [EOL] domain_key = f" [string] { i } [string] " [EOL] dns_server_name_key = f" [string] { i } [string] " [EOL] ip = environ . get ( ip_key , None ) [EOL] domain = environ . get ( domain_key , None ) [EOL] if domain : [EOL] domain = domain . lower ( ) [EOL] dns_server_name = environ . get ( dns_server_name_key , None ) [EOL] if ip and domain : [EOL] if dns_server_name : [EOL] dns_server_repo = DnsServerRepo ( db = session ) [EOL] if dns_server_repo . exists ( name = dns_server_name ) : [EOL] dns_server = dns_server_repo . results ( ) [EOL] else : [EOL] logger . info ( f" [string] { name }" ) [EOL] dns_server = factory ( [string] , session = session ) . create ( name = dns_server_name ) [EOL] factory ( [string] , session = session ) . create ( ip = ip , domain = domain , dns_server = dns_server ) [EOL] else : [EOL] repo = ZoneRepo ( db = session ) [EOL] if not repo . exists ( ip = ip , domain = domain ) : [EOL] logger . info ( f" [string] { ip } [string] { domain }" ) [EOL] factory ( [string] , session = session ) . create ( ip = ip , domain = domain ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $boucanpy.core.zone.repos.ZoneRepo$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $boucanpy.core.zone.repos.ZoneRepo$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $boucanpy.core.zone.repos.ZoneRepo$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $boucanpy.core.zone.repos.ZoneRepo$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $boucanpy.core.dns_server.repos.DnsServerRepo$ 0 0 0 0 0 $typing.Any$ 0 0 0 $boucanpy.core.dns_server.repos.DnsServerRepo$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 $boucanpy.core.dns_server.repos.DnsServerRepo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $boucanpy.core.zone.repos.ZoneRepo$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $boucanpy.core.zone.repos.ZoneRepo$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0
from typing import List [EOL] import typing [EOL] import requests [EOL] import requests [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . db . models . zone import Zone [EOL] [EOL] [EOL] class ApiZonesList ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] path = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , default = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , help = [string] ) [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] res = requests . get ( self . get_url ( ) , headers = self . get_headers ( ) ) [EOL] print ( res . json ( ) ) [EOL] [EOL] def get_url ( self ) : [EOL] return self . option ( [string] ) + self . path [EOL] [EOL] def get_headers ( self ) : [EOL] return { [string] : [string] + self . option ( [string] ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from boucanpy . cli . base import BaseCommand [EOL] [EOL] [EOL] class ApiUrls ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] from boucanpy . api . main import api [EOL] [EOL] for route in api . routes : [EOL] print ( route . name , route . path , getattr ( route , [string] , None ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import requests [EOL] import requests [EOL] from boucanpy . cli . base import BaseCommand [EOL] [EOL] [EOL] class ApiZoneCreate ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] path = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , default = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , required = True , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , required = True , type = str , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , required = True , help = [string] , ) [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] [comment] [EOL] url = self . option ( [string] ) [EOL] domain = self . option ( [string] ) [EOL] ip = self . option ( [string] ) [EOL] print ( f" [string] { self . get_url ( ) }" ) [EOL] [comment] [EOL] response = requests . post ( self . get_url ( ) , headers = { [string] : [string] . format ( self . option ( [string] ) ) } , json = { [string] : domain , [string] : ip } , ) [EOL] json_res = response . json ( ) [EOL] print ( json_res ) [EOL] [EOL] def get_url ( self ) : [EOL] return self . option ( [string] ) + self . path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import requests [EOL] import requests [EOL] from boucanpy . cli . base import BaseCommand [EOL] [EOL] [EOL] class ApiLogin ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] path = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , default = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , required = True , type = str , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , help = [string] , ) [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] url = self . option ( [string] ) [EOL] email = self . option ( [string] ) [EOL] password = self . get_password ( ) [EOL] print ( f" [string] { self . get_url ( ) }" ) [EOL] [comment] [EOL] response = requests . post ( self . get_url ( ) , data = self . get_json ( ) ) [EOL] json_res = response . json ( ) [EOL] print ( json_res ) [EOL] [EOL] def get_url ( self ) : [EOL] return self . option ( [string] ) + self . path [EOL] [EOL] def get_json ( self ) : [EOL] return { [string] : self . option ( [string] ) , [string] : self . get_password ( ) } [EOL] [EOL] def get_password ( self ) : [EOL] if self . option ( [string] ) : [EOL] return self . option ( [string] ) [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from ipaddress import ip_address [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . db . models . zone import Zone [EOL] [EOL] [EOL] class ZoneCreate ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] parser . add_argument ( [string] , [string] , required = True , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , required = True , action = [string] , help = [string] ) [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] self . db_register ( ) [EOL] ip = self . get_ip ( ) [EOL] domain = self . get_domain ( ) [EOL] zone = Zone ( ip = ip , domain = domain ) [EOL] self . session ( ) . add ( zone ) [EOL] self . session ( ) . commit ( ) [EOL] [EOL] def get_ip ( self ) : [EOL] ip_raw = self . options . get ( [string] ) [EOL] try : [EOL] ip_address ( ip_raw ) [EOL] except ValueError as e : [EOL] print ( [string] ) [EOL] print ( e ) [EOL] self . exit ( [number] ) [EOL] return ip_raw [EOL] [EOL] def get_domain ( self ) : [EOL] domain = self . option ( [string] ) [EOL] if [string] not in domain : [EOL] print ( [string] ) [EOL] self . exit ( [number] ) [EOL] return domain [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import List [EOL] import typing [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . db . models . zone import Zone [EOL] [EOL] [EOL] class ZoneList ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] self . db_register ( ) [EOL] for zone in self . session ( ) . query ( Zone ) . all ( ) : [EOL] print ( zone . id , zone . domain , zone . ip , zone . dns_server . name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import os [EOL] from pathlib import Path [EOL] from time import sleep [EOL] from dnslib . server import DNSServer [EOL] from boucanpy . core import logger [EOL] from boucanpy . dns . resolver import Resolver [EOL] from boucanpy . dns . logger import DNSLogger [EOL] from boucanpy . dns . handler import DNSHandler [EOL] [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . api_client import ApiClient [EOL] [EOL] [EOL] class DnsServer ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] add_log_level = True [EOL] add_debug = True [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . api_client = None [EOL] self . resolver = None [EOL] self . udp_server = None [EOL] self . tcp_server = None [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] parser . add_argument ( [string] , [string] , default = [string] , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = int , default = [number] , action = [string] , help = [string] , ) [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] [EOL] [comment] [EOL] verify_ssl = True [EOL] if bool ( self . option ( [string] ) ) : [EOL] verify_ssl = False [EOL] [EOL] self . api_client = ApiClient ( self . get_api_url ( ) , self . get_api_token ( ) , verify_ssl = verify_ssl ) [EOL] [EOL] if not self . api_client . wait_for_up ( ) : [EOL] logger . critical ( [string] ) [EOL] self . exit ( [number] ) [EOL] [EOL] if self . option ( [string] ) : [EOL] logger . info ( [string] ) [EOL] else : [EOL] self . api_client . sync ( ) [EOL] [EOL] self . boot ( ) [EOL] [EOL] self . start_servers ( ) [EOL] [EOL] try : [EOL] count = [number] [EOL] while self . udp_server . isAlive ( ) : [EOL] if count > [number] and count % self . option ( [string] ) == [number] : [EOL] if self . api_client . refresh_zones_if_needed ( ) : [EOL] logger . critical ( [string] ) [EOL] [comment] [EOL] self . stop_servers ( ) [EOL] [EOL] sleep ( [number] ) [EOL] [EOL] stop_count = [number] [EOL] logger . critical ( [string] ) [EOL] while self . udp_server . thread and self . udp_server . isAlive ( ) : [EOL] if stop_count > [number] : [EOL] logger . critical ( [string] ) [EOL] raise Exception ( [string] ) [EOL] logger . info ( [string] ) [EOL] stop_count = stop_count + [number] [EOL] sleep ( [number] ) [EOL] stop_count = [number] [EOL] logger . critical ( [string] ) [EOL] while self . tcp_server . thread and self . tcp_server . isAlive ( ) : [EOL] if stop_count > [number] : [EOL] logger . critical ( [string] ) [EOL] raise Exception ( [string] ) [EOL] logger . info ( [string] ) [EOL] stop_count = stop_count + [number] [EOL] sleep ( [number] ) [EOL] logger . critical ( [string] ) [EOL] self . boot ( ) [EOL] self . start_servers ( ) [EOL] [EOL] count = count + [number] [EOL] sleep ( [number] ) [EOL] except KeyboardInterrupt : [EOL] pass [EOL] [EOL] def get_api_url ( self ) : [EOL] if os . environ . get ( [string] , None ) : [EOL] return os . environ . get ( [string] ) [EOL] return self . option ( [string] ) [EOL] [EOL] def get_api_token ( self ) : [EOL] if os . environ . get ( [string] , None ) : [EOL] return os . environ . get ( [string] ) [EOL] if self . option ( [string] , None ) : [EOL] return self . option ( [string] ) [EOL] logger . critical ( [string] ) [EOL] self . exit ( [number] ) [EOL] [EOL] def get_port ( self ) : [EOL] return self . option ( [string] ) [EOL] [EOL] def get_listen ( self ) : [EOL] return self . option ( [string] ) [EOL] [EOL] def boot ( self ) : [EOL] port = self . get_port ( ) [EOL] listen = self . get_listen ( ) [EOL] [EOL] self . resolver = Resolver ( self . api_client ) [EOL] self . udp_server = DNSServer ( self . resolver , address = listen , port = port , handler = DNSHandler , logger = DNSLogger ( self . api_client ) , ) [EOL] self . tcp_server = DNSServer ( self . resolver , address = listen , port = port , tcp = True , handler = DNSHandler , logger = DNSLogger ( self . api_client ) , ) [EOL] [EOL] logger . info ( [string] , port ) [EOL] [EOL] def start_servers ( self ) : [EOL] self . udp_server . start_thread ( ) [EOL] self . tcp_server . start_thread ( ) [EOL] [EOL] def stop_servers ( self ) : [EOL] self . udp_server . stop ( ) [EOL] self . udp_server . server . socket . close ( ) [EOL] self . udp_server . server . server_close ( ) [EOL] self . tcp_server . stop ( ) [EOL] self . tcp_server . server . socket . close ( ) [EOL] self . tcp_server . server . server_close ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . db . models . api_token import ApiToken [EOL] [EOL] [EOL] class ApiTokenList ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] self . db_register ( ) [EOL] for zone in self . session ( ) . query ( ApiToken ) . all ( ) : [EOL] print ( zone . id , zone . scopes , zone . token ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import datetime [EOL] from datetime import timedelta , datetime [EOL] [EOL] import uuid [EOL] from boucanpy . core . enums import NODE_SCOPES [EOL] from boucanpy . core . security import create_bearer_token [EOL] from boucanpy . core . api_token import ApiTokenRepo [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . db . models . api_token import ApiToken [EOL] [EOL] [EOL] class ApiTokenCreate ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [number] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [number] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = str , help = [string] , ) [EOL] [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] self . db_register ( ) [EOL] [EOL] server_name = self . option ( [string] , None ) or uuid . uuid4 ( ) . hex [EOL] [EOL] scopes = self . get_scopes ( ) [EOL] expires_delta = timedelta ( days = int ( self . option ( [string] ) ) ) [EOL] expires_at = datetime . utcnow ( ) + expires_delta [EOL] [EOL] token = create_bearer_token ( data = { [string] : self . option ( [string] ) , [string] : scopes , [string] : server_name , [string] : server_name , } , expire = expires_at , ) [EOL] [EOL] print ( [string] . format ( str ( token ) ) ) [EOL] [EOL] def get_scopes ( self ) : [EOL] if self . option ( [string] ) : [EOL] return [string] . join ( self . option ( [string] ) ) [EOL] else : [EOL] return NODE_SCOPES [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import os [EOL] from pathlib import Path [EOL] from time import sleep [EOL] from boucanpy . core import logger [EOL] from boucanpy . core . utils import storage_dir [EOL] from boucanpy . cli . base import BaseCommand [EOL] from boucanpy . api_client import ApiClient [EOL] from boucanpy . http . manager import HttpServerManager [EOL] [EOL] [EOL] class HttpServer ( BaseCommand ) : [EOL] name = [string] [EOL] aliases = [ [string] ] [EOL] description = [string] [EOL] add_log_level = True [EOL] add_debug = True [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . api_client = None [EOL] self . http_server = None [EOL] self . https_server = None [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] @ classmethod def parser ( cls , parser ) : [EOL] parser . add_argument ( [string] , [string] , default = [string] , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , type = int , default = [number] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , type = int , default = [number] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = storage_dir ( [string] ) , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , default = storage_dir ( [string] ) , help = [string] , ) [EOL] [EOL] [comment] [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = int , default = [number] , action = [string] , help = [string] , ) [EOL] return parser [EOL] [EOL] async def run ( self ) : [EOL] [comment] [EOL] verify_ssl = True [EOL] if bool ( self . option ( [string] ) ) : [EOL] verify_ssl = False [EOL] [EOL] self . api_client = ApiClient ( self . get_api_url ( ) , self . get_api_token ( ) , verify_ssl = verify_ssl ) [EOL] [EOL] if not self . option ( [string] ) : [EOL] if not self . api_client . wait_for_up ( ) : [EOL] logger . critical ( [string] ) [EOL] self . exit ( [number] ) [EOL] [EOL] if self . option ( [string] ) : [EOL] logger . info ( [string] ) [EOL] else : [EOL] self . api_client . sync ( ) [EOL] [EOL] self . boot ( ) [EOL] [EOL] self . start_servers ( ) [EOL] [EOL] try : [EOL] count = [number] [EOL] while self . is_alive ( ) : [EOL] [comment] [EOL] [comment] [EOL] count = count + [number] [EOL] sleep ( [number] ) [EOL] [EOL] except KeyboardInterrupt : [EOL] pass [EOL] [EOL] def boot ( self ) : [EOL] port = self . option ( [string] ) [EOL] listen = self . option ( [string] ) [EOL] [EOL] logger . info ( [string] , port ) [EOL] [EOL] self . http_server = HttpServerManager ( port = port , listen = listen , ssl = False , api_client = self . api_client ) [EOL] [EOL] if bool ( self . option ( [string] ) ) : [EOL] [EOL] ssl_port = self . option ( [string] ) [EOL] ssl_listen = self . option ( [string] ) [EOL] ssl_key_path = self . option ( [string] ) [EOL] ssl_cert_path = self . option ( [string] ) [EOL] logger . info ( f" [string] { str ( ssl_port ) } [string] { ssl_cert_path } [string] { ssl_key_path }" , ) [EOL] [EOL] self . https_server = HttpServerManager ( port = ssl_port , listen = ssl_listen , api_client = self . api_client , ssl = True , ssl_cert_path = ssl_cert_path , ssl_key_path = ssl_key_path , ) [EOL] logger . info ( [string] , ssl_port ) [EOL] [EOL] def start_servers ( self ) : [EOL] self . http_server . start_thread ( ) [EOL] if bool ( self . option ( [string] ) ) : [EOL] self . https_server . start_thread ( ) [EOL] [EOL] def stop_servers ( self ) : [EOL] self . http_server . stop ( ) [EOL] if bool ( self . option ( [string] ) ) : [EOL] self . https_server . stop ( ) [EOL] [EOL] def is_alive ( self ) : [EOL] _is_alive = self . http_server . is_alive ( ) [EOL] if bool ( self . option ( [string] ) ) : [EOL] _is_alive = _is_alive and self . https_server . is_alive ( ) [EOL] [EOL] return _is_alive [EOL] [EOL] def get_api_url ( self ) : [EOL] if os . environ . get ( [string] , None ) : [EOL] return os . environ . get ( [string] ) [EOL] return self . option ( [string] ) [EOL] [EOL] def get_api_token ( self ) : [EOL] if os . environ . get ( [string] , None ) : [EOL] return os . environ . get ( [string] ) [EOL] if self . option ( [string] , None ) : [EOL] return self . option ( [string] ) [EOL] logger . critical ( [string] ) [EOL] self . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . session import db_register , session , metadata , engine , async_session [EOL] from . utils import make_db_url [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from time import sleep [EOL] from boucanpy . core import logger [EOL] from boucanpy . db . session import session [EOL] [EOL] [EOL] def is_db_up ( ) : [EOL] seconds = [number] [EOL] while True : [EOL] if seconds > [number] : [EOL] logger . critical ( [string] ) [EOL] return False [EOL] logger . debug ( [string] ) [EOL] try : [EOL] session ( ) . execute ( [string] ) [EOL] return True [EOL] except KeyError as e : [EOL] logger . critical ( [string] ) [EOL] return False [EOL] except Exception as e : [EOL] logger . critical ( [string] . format ( str ( seconds ) , str ( e . __class__ . __name__ ) ) ) [EOL] seconds = seconds + [number] [EOL] sleep ( [number] ) [EOL] [EOL] [EOL] def is_db_setup ( ) : [EOL] seconds = [number] [EOL] while True : [EOL] if seconds > [number] : [EOL] logger . critical ( [string] ) [EOL] return False [EOL] logger . debug ( [string] ) [EOL] try : [EOL] session ( ) . execute ( [string] ) [EOL] return True [EOL] except KeyError as e : [EOL] logger . critical ( [string] ) [EOL] return False [EOL] except Exception as e : [EOL] logger . critical ( [string] ) [EOL] return False [EOL] seconds = seconds + [number] [EOL] sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import asyncio [EOL] from sqlalchemy . event import listen [EOL] import asyncio [EOL] from boucanpy . core import logger [EOL] [EOL] ORM_EVENTS = [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] def make_event ( func ) : [EOL] def _event ( * args , ** kwargs ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] [comment] [EOL] [comment] [EOL] result = asyncio . ensure_future ( func ( * args , ** kwargs ) , loop = loop ) [EOL] return result [EOL] [EOL] return _event [EOL] [EOL] [EOL] def db_register_model_events ( models ) : [EOL] for m in models : [EOL] for event_name in ORM_EVENTS : [EOL] event_cb = [string] + event_name [EOL] if hasattr ( m , event_cb ) : [EOL] logger . info ( [string] + event_cb + [string] + str ( m ) ) [EOL] listen ( m , event_name , make_event ( getattr ( m , event_cb ) ) ) [EOL] [EOL] [EOL] def db_register_search_events ( session , mixin ) : [EOL] listen ( session , [string] , mixin . before_commit ) [EOL] listen ( session , [string] , mixin . after_commit ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from os . path import join , exists [EOL] from boucanpy . core . utils import getenv , storage_dir [EOL] [EOL] [EOL] def resolve_db_path ( db_path ) : [EOL] if db_path : [EOL] [comment] [EOL] if not exists ( db_path ) : [EOL] db_path = storage_dir ( join ( [string] , db_path ) ) [EOL] return db_path [EOL] [EOL] [EOL] def get_resolved_db_path ( ) : [EOL] DB_DATABASE = getenv ( [string] , [string] , optional = True ) [comment] [EOL] return resolve_db_path ( DB_DATABASE ) [EOL] [EOL] [EOL] def make_db_url ( ) : [EOL] DB_DRIVER = getenv ( [string] , [string] ) [EOL] if [string] in DB_DRIVER : [EOL] DB_DATABASE = get_resolved_db_path ( ) [EOL] SQLALCHEMY_DATABASE_URI = f"{ DB_DRIVER } [string] { DB_DATABASE }" [EOL] else : [EOL] DB_DATABASE = getenv ( [string] , [string] ) [EOL] DB_SERVER = getenv ( [string] , [string] ) [EOL] DB_USER = getenv ( [string] , [string] ) [EOL] DB_PASSWORD = getenv ( [string] , [string] ) [EOL] DB_PORT = getenv ( [string] , [string] ) [EOL] SQLALCHEMY_DATABASE_URI = ( f"{ DB_DRIVER } [string] { DB_USER } [string] { DB_PASSWORD } [string] { DB_SERVER } [string] { DB_PORT } [string] { DB_DATABASE }" ) [EOL] [EOL] return SQLALCHEMY_DATABASE_URI [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from os import environ [EOL] from importlib import import_module [EOL] from sqlalchemy import create_engine [EOL] from sqlalchemy . orm import scoped_session , sessionmaker [EOL] from boucanpy . db . pagination . query import PaginationQuery [EOL] from . events import db_register_model_events , db_register_search_events [EOL] [EOL] [comment] [EOL] [EOL] DEFAULT_KEY = [string] [EOL] [EOL] dbs = { } [EOL] _sessions = { } [EOL] _session = sessionmaker ( autocommit = False , autoflush = False , query_cls = PaginationQuery ) [EOL] _scoped_session = scoped_session ( _session ) [EOL] [EOL] import traceback [EOL] import inspect [EOL] [EOL] [comment] [EOL] def session ( ) : [EOL] if DEFAULT_KEY in _sessions . keys ( ) : [EOL] return _sessions [ DEFAULT_KEY ] [EOL] session = dbs [ DEFAULT_KEY ] [ [string] ] ( ) [EOL] _sessions [ DEFAULT_KEY ] = session [EOL] return session [EOL] [EOL] [EOL] [comment] [EOL] async def async_session ( ) : [EOL] return session ( ) [EOL] [EOL] [EOL] def db_session ( ) : [EOL] return dbs [ DEFAULT_KEY ] [ [string] ] [EOL] [EOL] [EOL] def engine ( ) : [EOL] return dbs [ DEFAULT_KEY ] [ [string] ] [EOL] [EOL] [EOL] def db_url ( ) : [EOL] return dbs [ DEFAULT_KEY ] [ [string] ] [EOL] [EOL] [EOL] def metadata ( ) : [EOL] return dbs [ DEFAULT_KEY ] [ [string] ] [EOL] [EOL] [EOL] def db_register ( db_uri , force = False ) : [EOL] global dbs [EOL] if DEFAULT_KEY not in dbs or force : [EOL] engine = create_engine ( db_uri ) [EOL] db = { } [EOL] db [ [string] ] = engine [EOL] _scoped_session . configure ( bind = engine ) [EOL] db [ [string] ] = _session [EOL] db [ [string] ] = _scoped_session [EOL] db [ [string] ] = db_uri [EOL] db [ [string] ] = getattr ( import_module ( f" [string] " , [string] ) , [string] ) [EOL] models = getattr ( import_module ( f" [string] " , [string] ) , [string] ) [EOL] db [ [string] ] = models . values ( ) [EOL] dbs [ DEFAULT_KEY ] = db [EOL] [comment] [EOL] [EOL] if int ( environ . get ( [string] , [number] ) ) == [number] : [EOL] db_register_model_events ( models . values ( ) ) [EOL] [EOL] from boucanpy . db . search . mixin import SearchableMixin [EOL] [EOL] db_register_search_events ( _scoped_session , SearchableMixin ) [EOL] [EOL] [comment] [EOL] from boucanpy . db . factories . base import BaseFactory [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from fastapi import HTTPException [EOL] from sqlalchemy import orm [EOL] from boucanpy . db . pagination . pagination import Pagination [EOL] [EOL] [EOL] class PaginationQuery ( orm . Query ) : [EOL] def get_or_404 ( self , ident ) : [EOL] rv = self . get ( ident ) [EOL] if rv is None : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] return rv [EOL] [EOL] def first_or_404 ( self ) : [EOL] rv = self . first ( ) [EOL] if rv is None : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] return rv [EOL] [EOL] def paginate ( self , page = [number] , per_page = [number] , error_out = True , max_per_page = None , count = True ) : [EOL] if max_per_page is not None : [EOL] per_page = min ( per_page , max_per_page ) [EOL] [EOL] if page < [number] : [EOL] if error_out : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] else : [EOL] page = [number] [EOL] [EOL] if per_page < [number] : [EOL] if error_out : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] else : [EOL] per_page = [number] [EOL] [EOL] items = self . limit ( per_page ) . offset ( ( page - [number] ) * per_page ) . all ( ) [EOL] [EOL] if not items and page != [number] and error_out : [EOL] raise HTTPException ( status_code = [number] , detail = [string] ) [EOL] [EOL] if not count : [EOL] total = None [EOL] elif page == [number] and len ( items ) < per_page : [EOL] total = len ( items ) [EOL] else : [EOL] total = self . order_by ( None ) . count ( ) [EOL] [EOL] return Pagination ( self , page , per_page , total , items ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0
from . pagination import Pagination [EOL] from . query import PaginationQuery [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] from boucanpy . db . search import search [EOL] [EOL] [EOL] class SearchableMixin ( object ) : [EOL] @ classmethod def search ( cls , expression , page , per_page ) : [EOL] ids , total = search . query_index ( cls . __tablename__ , expression , page , per_page ) [EOL] if total == [number] : [EOL] return cls . query . filter_by ( id = [number] ) , [number] [EOL] when = [ ] [EOL] for i in range ( len ( ids ) ) : [EOL] when . append ( ( ids [ i ] , i ) ) [EOL] return ( cls . query . filter ( cls . id . in_ ( ids ) ) . order_by ( db . case ( when , value = cls . id ) ) , total , ) [EOL] [EOL] @ classmethod def before_commit ( cls , session ) : [EOL] session . _changes = { [string] : list ( session . new ) , [string] : list ( session . dirty ) , [string] : list ( session . deleted ) , } [EOL] [EOL] @ classmethod def after_commit ( cls , session ) : [EOL] for obj in session . _changes [ [string] ] : [EOL] if isinstance ( obj , SearchableMixin ) : [EOL] search . add_to_index ( obj . __tablename__ , obj ) [EOL] for obj in session . _changes [ [string] ] : [EOL] if isinstance ( obj , SearchableMixin ) : [EOL] search . add_to_index ( obj . __tablename__ , obj ) [EOL] for obj in session . _changes [ [string] ] : [EOL] if isinstance ( obj , SearchableMixin ) : [EOL] search . remove_from_index ( obj . __tablename__ , obj ) [EOL] session . _changes = None [EOL] [EOL] @ classmethod def reindex ( cls ) : [EOL] for obj in cls . query : [EOL] search . add_to_index ( cls . __tablename__ , obj ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import boucanpy [EOL] from elasticsearch import Elasticsearch [EOL] [EOL] [EOL] class Search : [EOL] def __init__ ( self , elasticsearch = None ) : [EOL] self . elasticsearch = elasticsearch [EOL] [EOL] def register ( self , el_url ) : [EOL] self . elasticsearch = Elasticsearch ( [ url ] ) [EOL] [EOL] def add_to_index ( self , index , model ) : [EOL] if not self . elasticsearch : [EOL] return [EOL] payload = { } [EOL] for field in model . __searchable__ : [EOL] payload [ field ] = getattr ( model , field ) [EOL] self . elasticsearch . index ( index = index , doc_type = index , id = model . id , body = payload ) [EOL] [EOL] def remove_from_index ( self , index , model ) : [EOL] if not self . elasticsearch : [EOL] return [EOL] self . elasticsearch . delete ( index = index , doc_type = index , id = model . id ) [EOL] [EOL] def query_index ( self , index , query , page , per_page ) : [EOL] if not self . elasticsearch : [EOL] return [ ] , [number] [EOL] search = self . elasticsearch . search ( index = index , doc_type = index , body = { [string] : { [string] : { [string] : query , [string] : [ [string] ] } } , [string] : ( page - [number] ) * per_page , [string] : per_page , } , ) [EOL] ids = [ int ( hit [ [string] ] ) for hit in search [ [string] ] [ [string] ] ] [EOL] return ids , search [ [string] ] [ [string] ] [EOL] [EOL] [EOL] search = Search ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $boucanpy.db.search.search.Search$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from boucanpy . db . migrate . config import get_config [EOL] [EOL] [comment] [EOL] def upgrade ( directory = None , revision = [string] , sql = False , tag = None , x_arg = None ) : [EOL] from alembic import command [EOL] [EOL] [docstring] [EOL] config = get_config ( directory , x_arg = x_arg ) [EOL] command . upgrade ( config , revision , sql = sql , tag = tag ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import boucanpy [EOL] import os [EOL] import argparse [EOL] [EOL] [comment] [EOL] def get_config ( directory , x_arg = None , opts = None ) : [EOL] from alembic . config import Config as AlembicConfig [EOL] [EOL] class Config ( AlembicConfig ) : [EOL] def get_template_directory ( self ) : [EOL] package_dir = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] return os . path . join ( package_dir , [string] ) [EOL] [EOL] config = Config ( os . path . join ( directory , [string] ) ) [EOL] config . set_main_option ( [string] , directory ) [EOL] if config . cmd_opts is None : [EOL] config . cmd_opts = argparse . Namespace ( ) [EOL] for opt in opts or [ ] : [EOL] setattr ( config . cmd_opts , opt , True ) [EOL] if not hasattr ( config . cmd_opts , [string] ) : [EOL] if x_arg is not None : [EOL] setattr ( config . cmd_opts , [string] , [ ] ) [EOL] if isinstance ( x_arg , list ) or isinstance ( x_arg , tuple ) : [EOL] for x in x_arg : [EOL] config . cmd_opts . x . append ( x ) [EOL] else : [EOL] config . cmd_opts . x . append ( x_arg ) [EOL] else : [EOL] setattr ( config . cmd_opts , [string] , None ) [EOL] return config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from boucanpy . db . migrate . config import get_config [EOL] [EOL] [comment] [EOL] def history ( directory = None , rev_range = None , verbose = False , indicate_current = False ) : [EOL] from alembic import command [EOL] [EOL] [docstring] [EOL] config = get_config ( directory ) [EOL] command . history ( config , rev_range , verbose = verbose , indicate_current = indicate_current ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] from boucanpy . db . migrate . config import get_config [EOL] [EOL] [comment] [EOL] def migrate ( directory = None , message = None , sql = False , head = [string] , splice = False , branch_label = None , version_path = None , rev_id = None , x_arg = None , ) : [EOL] from alembic import command [EOL] [EOL] [docstring] [EOL] [EOL] config = get_config ( directory , opts = [ [string] ] , x_arg = x_arg ) [EOL] command . revision ( config , message , autogenerate = True , sql = sql , head = head , splice = splice , branch_label = branch_label , version_path = version_path , rev_id = rev_id , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from boucanpy . db . migrate . config import get_config [EOL] [EOL] [comment] [EOL] def stamp ( directory = None , revision = [string] , sql = False , tag = None ) : [EOL] from alembic import command [EOL] [EOL] config = get_config ( directory ) [EOL] command . stamp ( config , revision , sql = sql , tag = tag ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from boucanpy . db . migrate . config import get_config [EOL] [EOL] [comment] [EOL] def show ( directory = None , revision = [string] ) : [EOL] from alembic import command [EOL] [EOL] [docstring] [EOL] config = get_config ( directory ) [EOL] command . show ( config , revision ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import boucanpy [EOL] import os [EOL] [EOL] [comment] [EOL] def initialize ( directory = None , multidb = False ) : [EOL] from alembic import command [EOL] from alembic . config import Config as AlembicConfig [EOL] [EOL] class Config ( AlembicConfig ) : [EOL] def get_template_directory ( self ) : [EOL] package_dir = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] return os . path . join ( package_dir , [string] ) [EOL] [EOL] [docstring] [EOL] config = Config ( ) [EOL] config . set_main_option ( [string] , directory ) [EOL] config . config_file_name = os . path . join ( directory , [string] ) [EOL] command . init ( config , directory , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from boucanpy . db . migrate . config import get_config [EOL] [EOL] [comment] [EOL] def current ( directory = None , verbose = False , head_only = False ) : [EOL] from alembic import command [EOL] [EOL] [docstring] [EOL] config = get_config ( directory ) [EOL] command . current ( config , verbose = verbose , head_only = head_only ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import typing [EOL] import boucanpy [EOL] from factory import alchemy [EOL] from faker import Faker as RealFaker [EOL] from faker . providers import internet [EOL] from boucanpy . db . session import _scoped_session [EOL] [EOL] [EOL] fake = RealFaker ( ) [EOL] fake . add_provider ( internet ) [EOL] [EOL] [EOL] class BaseFactory ( alchemy . SQLAlchemyModelFactory ) : [EOL] class Meta : [EOL] abstract = True [EOL] sqlalchemy_session = _scoped_session [EOL] sqlalchemy_session_persistence = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Type[boucanpy.db.factories.base.BaseFactory.Meta]$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import _importlib_modulespec [EOL] from os import walk [EOL] from os . path import join [EOL] from importlib import import_module [EOL] from boucanpy . core . utils import db_dir , snake_to_title [EOL] [EOL] factories = { } [EOL] [EOL] factories_dir = db_dir ( [string] ) [EOL] for directory_name , sub_directories , files in walk ( factories_dir ) : [EOL] for f in sorted ( files ) : [EOL] if not f . startswith ( [string] ) and not f . startswith ( [string] ) : [EOL] base_name = f . split ( [string] ) [ [number] ] [EOL] class_name = snake_to_title ( base_name ) + [string] [EOL] module_path = f" [string] { base_name }" [EOL] module = import_module ( module_path , class_name ) [EOL] model = getattr ( module , class_name ) [EOL] if class_name not in factories . keys ( ) : [EOL] factories [ class_name ] = model [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def factory ( key , session = None ) : [EOL] [comment] [EOL] [comment] [EOL] f = factories [ key ] [EOL] if session : [EOL] f . _meta . sqlalchemy_session = session [EOL] return f [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $_importlib_modulespec.ModuleType$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] from __future__ import with_statement [EOL] [EOL] import logging [EOL] from logging . config import fileConfig [EOL] [EOL] from sqlalchemy import engine_from_config [EOL] from sqlalchemy import pool [EOL] [EOL] from alembic import context [EOL] [EOL] [comment] [EOL] [comment] [EOL] config = context . config [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from boucanpy . core . utils import getenv [EOL] from boucanpy . db . session import metadata , db_url [EOL] [EOL] config . set_main_option ( [string] , db_url ( ) ) [EOL] target_metadata = metadata ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def run_migrations_offline ( ) : [EOL] [docstring] [EOL] url = config . get_main_option ( [string] ) [EOL] context . configure ( url = url , target_metadata = target_metadata , literal_binds = True ) [EOL] [EOL] with context . begin_transaction ( ) : [EOL] context . run_migrations ( ) [EOL] [EOL] [EOL] def run_migrations_online ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def process_revision_directives ( context , revision , directives ) : [EOL] if getattr ( config . cmd_opts , [string] , False ) : [EOL] script = directives [ [number] ] [EOL] if script . upgrade_ops . is_empty ( ) : [EOL] directives [ : ] = [ ] [EOL] logger . info ( [string] ) [EOL] [EOL] connectable = engine_from_config ( config . get_section ( config . config_ini_section ) , prefix = [string] , poolclass = pool . NullPool , ) [EOL] [EOL] with connectable . connect ( ) as connection : [EOL] context . configure ( connection = connection , target_metadata = target_metadata , process_revision_directives = process_revision_directives , ) [EOL] [EOL] with context . begin_transaction ( ) : [EOL] context . run_migrations ( ) [EOL] [EOL] [EOL] if context . is_offline_mode ( ) : [EOL] run_migrations_offline ( ) [EOL] else : [EOL] run_migrations_online ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = [string] [EOL] branch_labels = None [EOL] depends_on = None [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] [comment] [EOL] op . drop_index ( [string] , table_name = [string] ) [EOL] [comment] [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] [comment] [EOL] op . create_index ( [string] , [string] , [ [string] ] , unique = False ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple [EOL] import typing [EOL] from dnslib import QTYPE , dns [EOL] [EOL] [comment] [EOL] TYPES = { [string] : ( dns . A , QTYPE . A ) , [string] : ( dns . AAAA , QTYPE . AAAA ) , [string] : ( dns . CAA , QTYPE . CAA ) , [string] : ( dns . CNAME , QTYPE . CNAME ) , [string] : ( dns . DNSKEY , QTYPE . DNSKEY ) , [string] : ( dns . MX , QTYPE . MX ) , [string] : ( dns . NAPTR , QTYPE . NAPTR ) , [string] : ( dns . NS , QTYPE . NS ) , [string] : ( dns . PTR , QTYPE . PTR ) , [string] : ( dns . RRSIG , QTYPE . RRSIG ) , [string] : ( dns . SOA , QTYPE . SOA ) , [string] : ( dns . SRV , QTYPE . SRV ) , [string] : ( dns . TXT , QTYPE . TXT ) , [string] : ( dns . TXT , QTYPE . TXT ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from time import sleep [EOL] from boucanpy . core import logger [EOL] from boucanpy . broadcast import make_redis [EOL] [EOL] [EOL] async def is_broadcast_up ( ) : [EOL] seconds = [number] [EOL] while True : [EOL] if seconds > [number] : [EOL] logger . critical ( [string] ) [EOL] return False [EOL] logger . debug ( [string] ) [EOL] try : [EOL] redis = await make_redis ( ) [EOL] await redis . set ( [string] , [string] ) [EOL] val = await redis . get ( [string] ) [EOL] val = await redis . delete ( [string] ) [EOL] return True [EOL] except Exception as e : [EOL] logger . critical ( [string] . format ( str ( seconds ) , str ( e . __class__ . __name__ ) ) ) [EOL] seconds = seconds + [number] [EOL] sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . broadcast import make_redis , make_subscriber [EOL] from . utils import make_broadcast_url [EOL] from . checks import is_broadcast_up [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from boucanpy . core . utils import getenv [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def make_broadcast_url ( ) : [EOL] BROADCAST_USER = [string] [EOL] BROADCAST_DRIVER = getenv ( [string] , [string] ) [EOL] BROADCAST_PATH = getenv ( [string] , [string] ) [EOL] BROADCAST_HOST = getenv ( [string] , [string] ) [EOL] BROADCAST_PORT = getenv ( [string] , [string] ) [EOL] BROADCAST_PASSWORD = getenv ( [string] , [string] ) [EOL] BROADCAST_URL = f"{ BROADCAST_DRIVER } [string] { BROADCAST_USER } [string] { BROADCAST_PASSWORD } [string] { BROADCAST_HOST } [string] { BROADCAST_PORT } [string] { BROADCAST_PATH }" [EOL] [EOL] return BROADCAST_URL [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aioredis [EOL] from . utils import make_broadcast_url [EOL] [EOL] [EOL] async def make_redis ( ) : [EOL] return await aioredis . create_redis ( make_broadcast_url ( ) ) [EOL] [EOL] [EOL] async def make_subscriber ( name ) : [EOL] subscriber = await make_redis ( ) [EOL] res = await subscriber . subscribe ( f" [string] { name }" ) [EOL] channel = res [ [number] ] [EOL] return subscriber , channel [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import os [EOL] from base64 import b64encode [EOL] from boucanpy . core . utils import getenv_bool , getenv [EOL] from boucanpy . db . session import db_url [EOL] [EOL] API_V1_STR = [string] [EOL] [EOL] [EOL] API_SECRET_KEY = getenv ( [string] ) [EOL] JWT_ALGORITHM = [string] [EOL] [EOL] if not API_SECRET_KEY : [EOL] API_SECRET_KEY = b64encode ( os . urandom ( [number] ) ) . decode ( [string] ) [EOL] [EOL] ACCESS_TOKEN_EXPIRE_MINUTES = [number] * [number] * [number] [comment] [EOL] [EOL] API_CORS_ORIGINS = getenv ( [string] ) [comment] [EOL] API_PROJECT_NAME = getenv ( [string] , [string] ) [EOL] SQLALCHEMY_DATABASE_URI = db_url ( ) [EOL] [EOL] API_SUPERUSER_EMAIL = getenv ( [string] , optional = True ) [EOL] API_SUPERUSER_PASSWORD = getenv ( [string] , optional = True ) [EOL] API_SUPERUSER_MFA_SECRET = getenv ( [string] , optional = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Any [EOL] import typing [EOL] import _importlib_modulespec [EOL] from os import walk [EOL] from pathlib import Path [EOL] from os . path import join [EOL] from importlib import import_module [EOL] from boucanpy . core . utils import api_dir , snake_to_title [EOL] [EOL] routers = [ ] [EOL] [EOL] [EOL] def extact_routers ( parent_dir , parent_mod ) : [EOL] _routers = [ ] [EOL] for directory_name , sub_directories , files in walk ( parent_dir ) : [EOL] for sub_dir_name in sorted ( sub_directories ) : [EOL] if not sub_dir_name . startswith ( ( [string] , [string] ) ) : [EOL] if Path ( join ( join ( parent_dir , sub_dir_name ) , [string] ) ) . is_file ( ) : [EOL] sub_dir = join ( parent_dir , sub_dir_name ) [EOL] module_path = f"{ parent_mod } [string] { sub_dir_name } [string] " [EOL] module = import_module ( module_path , [string] ) [EOL] _router = getattr ( module , [string] , None ) [EOL] if _router : [EOL] _options = getattr ( module , [string] , { } ) [EOL] router = ( _router , _options ) [EOL] _routers . append ( router ) [EOL] else : [EOL] print ( f" [string] { module_path }" ) [EOL] _routers = _routers + extact_routers ( join ( parent_dir , sub_dir_name ) , f"{ parent_mod } [string] { sub_dir_name }" ) [EOL] return _routers [EOL] [EOL] [EOL] for r in extact_routers ( api_dir ( [string] ) , [string] ) : [EOL] routers . append ( r ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import boucanpy [EOL] import builtins [EOL] from datetime import datetime [EOL] from typing import List [EOL] [EOL] from fastapi import APIRouter , Depends , HTTPException , Query [EOL] from boucanpy . core import logger , only , abort [EOL] from boucanpy . core . security import ( ScopedTo , TokenPayload , create_bearer_token , current_user , ) [EOL] from boucanpy . db . models . user import User [EOL] from boucanpy . db . models . dns_server import DnsServer [EOL] from boucanpy . db . models . http_server import HttpServer [EOL] [EOL] from boucanpy . core . api_token import ( ApiTokensResponse , ApiTokenResponse , ApiTokenRepo , ApiTokenCreateForm , ApiTokenData , SensitiveApiTokenResponse , SensitiveApiTokenData , ) [EOL] from boucanpy . core . dns_server import DnsServerRepo [EOL] from boucanpy . core . http_server import HttpServerRepo [EOL] [EOL] from boucanpy . core import SortQS , PaginationQS , BaseResponse [EOL] [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ router . post ( [string] , name = [string] , response_model = ApiTokenResponse ) async def sync ( api_token_repo = Depends ( ApiTokenRepo ( ) ) , dns_server_repo = Depends ( DnsServerRepo ( ) ) , http_server_repo = Depends ( HttpServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] if [string] in token . scopes or [string] in token . scopes : [EOL] abort_for_no_server_names ( token ) [EOL] if ( len ( token . payload . dns_server_name ) > [number] [EOL] and len ( token . payload . http_server_name ) > [number] ) : [EOL] dns_server = create_or_get_dns_server ( token , dns_server_repo ) [EOL] http_server = create_or_get_http_server ( token , http_server_repo ) [EOL] api_token_data = create_or_get_api_token_for_all_nodes ( token , api_token_repo , dns_server , http_server ) [EOL] elif len ( token . payload . dns_server_name ) > [number] : [EOL] dns_server = create_or_get_dns_server ( token , dns_server_repo ) [EOL] api_token_data = create_or_get_api_token_for_dns_server ( token , api_token_repo , dns_server ) [EOL] [EOL] elif len ( token . payload . http_server_name ) > [number] : [EOL] http_server = create_or_get_http_server ( token , http_server_repo ) [EOL] api_token_data = create_or_get_api_token_for_http_server ( token , api_token_repo , http_server ) [EOL] else : [EOL] [comment] [EOL] raise HTTPException ( [number] , detail = [string] ) [EOL] [EOL] return ApiTokenResponse ( api_token = api_token_data ) [EOL] [EOL] else : [EOL] raise HTTPException ( [number] , detail = [string] ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = ApiTokensResponse ) async def index ( sort_qs = Depends ( SortQS ) , pagination = Depends ( PaginationQS ) , api_token_repo = Depends ( ApiTokenRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] includes = only ( includes , [ [string] , [string] ] , values = True ) [EOL] [EOL] pg , items = ( api_token_repo . loads ( includes ) . strict ( ) . sort ( sort_qs ) . paginate ( pagination ) . includes ( includes ) . data ( ) ) [EOL] return ApiTokensResponse ( pagination = pg , api_tokens = items ) [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] , response_model = ApiTokenResponse ) async def store ( form , api_token_repo = Depends ( ApiTokenRepo ( ) ) , dns_server_repo = Depends ( DnsServerRepo ( ) ) , http_server_repo = Depends ( HttpServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , user = Depends ( current_user ) , ) : [EOL] if form . dns_server_id and form . dns_server_id > [number] : [EOL] dns_server_name = ( dns_server_repo . first_or_fail ( id = form . dns_server_id ) . results ( ) . name ) [EOL] if form . http_server_id and form . http_server_id > [number] : [EOL] http_server_name = ( http_server_repo . first_or_fail ( id = form . http_server_id ) . results ( ) . name ) [EOL] scopes = [ ] [EOL] for requested_scope in form . scopes . split ( [string] ) : [EOL] request_scope_satisfied = False [EOL] for user_token in token . scopes : [EOL] [comment] [EOL] [comment] [EOL] if user_token in requested_scope : [EOL] request_scope_satisfied = True [EOL] if not request_scope_satisfied : [EOL] logger . warning ( f" [string] { requested_scope }" ) [EOL] raise HTTPException ( [number] , detail = [string] ) [EOL] else : [EOL] scopes . append ( requested_scope ) [EOL] [EOL] [comment] [EOL] [EOL] token = create_bearer_token ( data = { [string] : user . id , [string] : [string] . join ( scopes ) , [string] : dns_server_name , [string] : http_server_name , } ) [EOL] [EOL] data = { [string] : [string] . join ( scopes ) , [string] : str ( token ) , [string] : form . expires_at , [string] : form . dns_server_id , [string] : form . http_server_id , } [EOL] [EOL] api_token = api_token_repo . create ( data ) . data ( ) [EOL] return ApiTokenResponse ( api_token = api_token ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = ApiTokenResponse ) async def show ( api_token_id , api_token_repo = Depends ( ApiTokenRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] [EOL] includes = only ( includes , [ [string] , [string] ] , values = True ) [EOL] [EOL] if ( not api_token_repo . loads ( includes ) . strict ( ) . includes ( includes ) . exists ( api_token_id ) ) : [EOL] raise HTTPException ( [number] , detail = [string] ) [EOL] api_token = api_token_repo . data ( ) [EOL] return ApiTokenResponse ( api_token = api_token ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = SensitiveApiTokenResponse , ) async def sensitive ( api_token_id , api_token_repo = Depends ( ApiTokenRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] [EOL] includes = only ( includes , [ [string] , [string] ] , values = True ) [EOL] [EOL] [comment] [EOL] if not api_token_repo . exists ( api_token_id ) : [EOL] raise HTTPException ( [number] , detail = [string] ) [EOL] api_token = ( api_token_repo . loads ( includes ) . set_data_model ( SensitiveApiTokenData ) . includes ( includes ) . data ( ) ) [EOL] return SensitiveApiTokenResponse ( api_token = api_token ) [EOL] [EOL] [EOL] @ router . delete ( [string] , response_model = BaseResponse ) async def destroy ( api_token_id , api_token_repo = Depends ( ApiTokenRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] messages = [ { [string] : [string] , [string] : [string] } ] [EOL] if not api_token_repo . exists ( api_token_id ) : [EOL] return BaseResponse ( messages = messages ) [EOL] api_token_repo . deactivate ( api_token_id ) [EOL] return BaseResponse ( messages = messages ) [EOL] [EOL] [EOL] def abort_for_no_server_names ( token ) : [EOL] if not len ( token . payload . dns_server_name ) or not len ( token . payload . http_server_name ) : [EOL] abort ( code = [number] , msg = [string] , debug = [string] , ) [EOL] [EOL] [EOL] def create_or_get_api_token_for_all_nodes ( token , api_token_repo , dns_server , http_server , ) : [EOL] scopes = token . scopes [EOL] [EOL] if not api_token_repo . exists ( token = token . token ) : [EOL] api_token_repo . clear ( ) [EOL] logger . info ( [string] ) [EOL] return api_token_repo . create ( dict ( token = token . token , scopes = [string] . join ( scopes ) , dns_server_id = dns_server . id , http_server_id = http_server . id , expires_at = datetime . utcfromtimestamp ( float ( token . exp ) ) , ) ) . data ( ) [EOL] else : [EOL] logger . info ( [string] ) [EOL] return api_token_repo . data ( ) [EOL] [EOL] [EOL] def create_or_get_dns_server ( token , dns_server_repo ) : [EOL] if not dns_server_repo . exists ( name = token . payload . dns_server_name . lower ( ) ) : [EOL] dns_server_repo . clear ( ) [EOL] logger . info ( [string] ) [EOL] return dns_server_repo . create ( dict ( name = token . payload . dns_server_name . lower ( ) ) ) . results ( ) [EOL] else : [EOL] return dns_server_repo . results ( ) [EOL] [EOL] [EOL] def create_or_get_api_token_for_dns_server ( token , api_token_repo , dns_server ) : [EOL] scopes = token . scopes [EOL] [EOL] if not api_token_repo . exists ( token = token . token ) : [EOL] api_token_repo . clear ( ) [EOL] logger . info ( [string] ) [EOL] return api_token_repo . create ( dict ( token = token . token , scopes = [string] . join ( scopes ) , dns_server = dns_server , expires_at = datetime . utcfromtimestamp ( float ( token . exp ) ) , ) ) . data ( ) [EOL] else : [EOL] logger . info ( [string] ) [EOL] return api_token_repo . loads ( [string] ) . includes ( [string] ) . data ( ) [EOL] [EOL] [EOL] def create_or_get_http_server ( token , http_server_repo ) : [EOL] if not http_server_repo . exists ( name = token . payload . http_server_name . lower ( ) ) : [EOL] http_server_repo . clear ( ) [EOL] logger . info ( [string] ) [EOL] return http_server_repo . create ( dict ( name = token . payload . http_server_name . lower ( ) ) ) . results ( ) [EOL] else : [EOL] return http_server_repo . results ( ) [EOL] [EOL] [EOL] def create_or_get_api_token_for_http_server ( token , api_token_repo , http_server ) : [EOL] scopes = token . scopes [EOL] [EOL] if not api_token_repo . exists ( token = token . token ) : [EOL] api_token_repo . clear ( ) [EOL] logger . info ( [string] ) [EOL] return api_token_repo . create ( dict ( token = token . token , scopes = [string] . join ( scopes ) , http_server = http_server , expires_at = datetime . utcfromtimestamp ( float ( token . exp ) ) , ) ) . data ( ) [EOL] else : [EOL] logger . info ( [string] ) [EOL] return api_token_repo . loads ( [string] ) . includes ( [string] ) . data ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.core.api_token.ApiTokenData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.db.models.dns_server.DnsServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.core.api_token.ApiTokenData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.db.models.http_server.HttpServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.core.api_token.ApiTokenData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import starlette [EOL] import builtins [EOL] import boucanpy [EOL] from fastapi import APIRouter , Depends , Query [EOL] from typing import List [EOL] from starlette . responses import RedirectResponse [EOL] from starlette . requests import Request [EOL] from boucanpy . core import only , logger [EOL] from boucanpy . core . security import ScopedTo , TokenPayload [EOL] [EOL] from boucanpy . core . dns_record import ( DnsRecordsResponse , DnsRecordResponse , DnsRecordRepo , DnsRecordForZoneCreateForm , ) [EOL] [EOL] from boucanpy . core import SortQS , PaginationQS , BaseResponse [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = DnsRecordsResponse ) async def index ( sort_qs = Depends ( SortQS ) , pagination = Depends ( PaginationQS ) , dns_record_repo = Depends ( DnsRecordRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] includes = only ( includes , [ [string] ] , values = True ) [EOL] [EOL] pg , items = ( dns_record_repo . loads ( [string] ) . sort ( sort_qs ) . paginate ( pagination ) . includes ( includes ) . data ( ) ) [EOL] [EOL] return DnsRecordsResponse ( pagination = pg , dns_records = items ) [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] ) async def store ( request , form = Depends ( ) ) : [EOL] return RedirectResponse ( url = request . url_for ( [string] , zone_id = form . zone_id ) , status_code = [number] , ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = DnsRecordResponse , ) async def show ( dns_record_id , dns_record_repo = Depends ( DnsRecordRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] includes = only ( includes , [ [string] ] , values = True ) [EOL] [EOL] item = ( dns_record_repo . loads ( [string] ) . first_or_fail ( id = dns_record_id ) . includes ( includes ) . data ( ) ) [EOL] [EOL] return DnsRecordResponse ( dns_record = item ) [EOL] [EOL] [EOL] [comment] [EOL] @ router . put ( [string] , name = [string] ) async def update ( dns_record_id , request , form = Depends ( ) ) : [EOL] return RedirectResponse ( url = request . url_for ( [string] , zone_id = form . zone_id , dns_record_id = dns_record_id ) , status_code = [number] , ) [EOL] [EOL] [EOL] @ router . delete ( [string] , name = [string] , response_model = BaseResponse , ) async def destroy ( dns_record_id , dns_record_repo = Depends ( DnsRecordRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] [EOL] dns_record_repo . first_or_fail ( id = dns_record_id ) . delete ( ) [EOL] messages = [ { [string] : [string] , [string] : [string] } ] [EOL] return BaseResponse ( messages = messages ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import fastapi [EOL] import starlette [EOL] from fastapi import APIRouter , Depends [EOL] from fastapi . security import OAuth2PasswordRequestForm [EOL] from starlette . responses import RedirectResponse [EOL] from starlette . requests import Request [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] ) async def login ( request , form = Depends ( ) ) : [EOL] return RedirectResponse ( url = request . url_for ( [string] ) , status_code = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] import boucanpy [EOL] from fastapi import APIRouter , Depends , HTTPException [EOL] from fastapi . security import OAuth2PasswordRequestForm [EOL] from boucanpy . core . auth import PasswordAuthResponse [EOL] from boucanpy . db . models . user import User [EOL] [EOL] from boucanpy . core . security import ( create_bearer_token , current_user , TokenPayload , ScopedTo , ) [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] , response_model = PasswordAuthResponse ) async def login ( token = Depends ( ScopedTo ( [string] ) ) , user = Depends ( current_user ) , ) : [EOL] token = create_bearer_token ( data = { [string] : token . sub , [string] : [string] . join ( token . scopes ) } ) [EOL] return PasswordAuthResponse ( token_type = [string] , access_token = str ( token ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import boucanpy [EOL] from sqlalchemy import literal [EOL] from fastapi import APIRouter , Depends , Query [EOL] from typing import List [EOL] [EOL] from boucanpy . core import logger , abort , only [EOL] from boucanpy . core . security import ScopedTo , TokenPayload [EOL] from boucanpy . core import SortQS , PaginationQS [EOL] from boucanpy . core . http_server import HttpServerRepo [EOL] from boucanpy . core . zone import ZoneRepo [EOL] [EOL] from boucanpy . core . http_request import ( HttpRequestRepo , HttpRequestsResponse , HttpRequestResponse , HttpRequestData , HttpRequestCreateForm , ) [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = HttpRequestsResponse ) async def index ( sort_qs = Depends ( SortQS ) , pagination = Depends ( PaginationQS ) , http_request_repo = Depends ( HttpRequestRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] pg , items = ( http_request_repo . loads ( [string] ) . sort ( sort_qs ) . includes ( [string] ) . paginate ( pagination ) . data ( ) ) [EOL] return HttpRequestsResponse ( pagination = pg , http_requests = items ) [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] , response_model = HttpRequestResponse ) async def store ( form , http_request_repo = Depends ( HttpRequestRepo ( ) ) , zone_repo = Depends ( ZoneRepo ( ) ) , http_server_repo = Depends ( HttpServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] [EOL] http_server_id = ( http_server_repo . first_or_fail ( name = form . http_server_name . lower ( ) ) . results ( ) . id ) [EOL] [EOL] zone = ( zone_repo . filter ( literal ( form . name . lower ( ) ) . contains ( zone_repo . label ( [string] ) ) ) . first ( ) . results ( ) ) [EOL] [EOL] zone_id = zone . id if zone else None [EOL] [EOL] data = only ( dict ( form ) , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] [EOL] data [ [string] ] = data [ [string] ] . lower ( ) [EOL] data [ [string] ] = data [ [string] ] . upper ( ) [EOL] [EOL] data [ [string] ] = http_server_id [EOL] data [ [string] ] = zone_id [EOL] logger . info ( [string] ) [EOL] http_request = http_request_repo . create ( data ) . data ( ) [EOL] [EOL] return HttpRequestResponse ( http_request = http_request ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = HttpRequestResponse , ) async def show ( http_request_id , http_request_repo = Depends ( HttpRequestRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] [comment] [EOL] [comment] [EOL] includes = only ( includes , [ [string] , [string] ] , values = True ) [EOL] [EOL] http_request = ( http_request_repo . loads ( includes ) . get_or_fail ( http_request_id ) . includes ( includes ) . data ( ) ) [EOL] return HttpRequestResponse ( http_request = http_request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import boucanpy [EOL] from typing import List [EOL] from fastapi import APIRouter , Depends , Query [EOL] from boucanpy . core import logger , only , abort , abort_for_input [EOL] from boucanpy . core . security import ScopedTo , TokenPayload [EOL] from boucanpy . core import PaginationQS , SortQS [EOL] from boucanpy . core . dns_server import ( DnsServerRepo , DnsServersResponse , DnsServerResponse , DnsServerCreateForm , ) [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = DnsServersResponse ) async def index ( sort_qs = Depends ( SortQS ) , pagination = Depends ( PaginationQS ) , dns_server_repo = Depends ( DnsServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , search = Query ( None ) , includes = Query ( None ) , ) : [EOL] includes = only ( includes , [ [string] ] , values = True ) [EOL] [EOL] pg , items = ( dns_server_repo . loads ( includes ) . includes ( includes ) . search ( search , searchable = [ [string] , [string] ] ) . paginate ( pagination ) . data ( ) ) [EOL] return DnsServersResponse ( pagination = pg , dns_servers = items ) [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] , response_model = DnsServerResponse ) async def store ( form , dns_server_repo = Depends ( DnsServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] if dns_server_repo . exists ( name = form . name . lower ( ) ) : [EOL] abort_for_input ( [string] , [string] ) [EOL] [EOL] data = only ( dict ( form ) , [ [string] ] ) [EOL] [EOL] data [ [string] ] = data [ [string] ] . lower ( ) [EOL] [EOL] item = dns_server_repo . create ( data ) . data ( ) [EOL] return DnsServerResponse ( dns_server = item ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = DnsServerResponse ) async def show ( dns_server , dns_server_repo = Depends ( DnsServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] includes = only ( includes , [ [string] ] , values = True ) [EOL] [EOL] dns_server_id_label = dns_server_repo . label ( [string] ) [EOL] [EOL] try : [EOL] dns_server = int ( dns_server ) [EOL] label = dns_server_id_label [EOL] except ValueError : [EOL] label = dns_server_repo . label ( [string] ) [EOL] [EOL] [comment] [EOL] item = ( dns_server_repo . loads ( includes ) . filter ( label == dns_server ) . first_or_fail ( ) . includes ( includes ) . data ( ) ) [EOL] [EOL] return DnsServerResponse ( dns_server = item ) [EOL] [EOL] [EOL] [comment] [EOL] @ router . put ( [string] , name = [string] , response_model = DnsServerResponse , ) async def update ( dns_server , form , dns_server_repo = Depends ( DnsServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] [EOL] data = only ( dict ( form ) , [ [string] ] ) [EOL] data [ [string] ] = data [ [string] ] . lower ( ) [EOL] [EOL] dns_server_id_label = dns_server_repo . label ( [string] ) [EOL] [EOL] try : [EOL] dns_server = int ( dns_server ) [EOL] label = dns_server_id_label [EOL] except ValueError : [EOL] label = dns_server_repo . label ( [string] ) [EOL] [EOL] [comment] [EOL] item = ( dns_server_repo . filter ( label == dns_server ) . first_or_fail ( ) . update ( data ) . data ( ) ) [EOL] [EOL] return DnsServerResponse ( dns_server = item ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import boucanpy [EOL] import builtins [EOL] from typing import List [EOL] from fastapi import APIRouter , Depends , Query [EOL] from boucanpy . core import only [EOL] from boucanpy . core . security import ScopedTo , TokenPayload [EOL] from boucanpy . db . models . zone import Zone [EOL] from boucanpy . core import SortQS , PaginationQS , BaseResponse [EOL] from boucanpy . core . zone import ( ZoneRepo , ZonesResponse , ZoneResponse , ZoneData , ZoneCreateForm , ) [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = ZonesResponse ) async def index ( dns_server , sort_qs = Depends ( SortQS ) , search = Query ( None ) , pagination = Depends ( PaginationQS ) , zone_repo = Depends ( ZoneRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] [EOL] includes = only ( includes , [ [string] ] , values = True ) [EOL] [EOL] [comment] [EOL] zone_dns_server_id_label = zone_repo . label ( [string] ) [EOL] [EOL] try : [EOL] dns_server = int ( dns_server ) [EOL] label = zone_dns_server_id_label [EOL] except ValueError : [EOL] label = zone_repo . label ( [string] ) [EOL] [EOL] pg , items = ( zone_repo . search ( search ) . loads ( includes ) . filter_or ( label == dns_server , zone_dns_server_id_label . is_ ( None ) ) . sort ( sort_qs ) . paginate ( pagination ) . includes ( includes ) . data ( ) ) [EOL] return ZonesResponse ( pagination = pg , zones = items ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import boucanpy [EOL] from sqlalchemy import literal [EOL] from fastapi import APIRouter , Depends , Query [EOL] from typing import List [EOL] [EOL] from boucanpy . core import logger , abort , only [EOL] from boucanpy . core . security import ScopedTo , TokenPayload [EOL] from boucanpy . core import SortQS , PaginationQS [EOL] from boucanpy . core . dns_server import DnsServerRepo [EOL] from boucanpy . core . zone import ZoneRepo [EOL] [EOL] from boucanpy . core . dns_request import ( DnsRequestRepo , DnsRequestsResponse , DnsRequestResponse , DnsRequestData , DnsRequestCreateForm , ) [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = DnsRequestsResponse ) async def index ( sort_qs = Depends ( SortQS ) , pagination = Depends ( PaginationQS ) , dns_request_repo = Depends ( DnsRequestRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] pg , items = ( dns_request_repo . loads ( [string] ) . sort ( sort_qs ) . paginate ( pagination ) . includes ( [string] ) . data ( ) ) [EOL] return DnsRequestsResponse ( pagination = pg , dns_requests = items ) [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] , response_model = DnsRequestResponse ) async def store ( form , dns_request_repo = Depends ( DnsRequestRepo ( ) ) , zone_repo = Depends ( ZoneRepo ( ) ) , dns_server_repo = Depends ( DnsServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] [EOL] dns_server_id = ( dns_server_repo . first_or_fail ( name = form . dns_server_name . lower ( ) ) . results ( ) . id ) [EOL] [EOL] zone = ( zone_repo . filter ( literal ( form . name . lower ( ) ) . contains ( zone_repo . label ( [string] ) ) ) . first ( ) . results ( ) ) [EOL] [EOL] zone_id = zone . id if zone else None [EOL] [EOL] data = only ( dict ( form ) , [ [string] , [string] , [string] , [string] , [string] , [string] ] , ) [EOL] [EOL] data [ [string] ] = data [ [string] ] . lower ( ) [EOL] data [ [string] ] = data [ [string] ] . upper ( ) [EOL] [EOL] data [ [string] ] = dns_server_id [EOL] data [ [string] ] = zone_id [EOL] logger . info ( [string] ) [EOL] dns_request = dns_request_repo . create ( data ) . data ( ) [EOL] [EOL] return DnsRequestResponse ( dns_request = dns_request ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = DnsRequestResponse , ) async def show ( dns_request_id , dns_request_repo = Depends ( DnsRequestRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] [comment] [EOL] [comment] [EOL] includes = only ( includes , [ [string] , [string] ] , values = True ) [EOL] [EOL] dns_request = ( dns_request_repo . loads ( includes ) . get_or_fail ( dns_request_id ) . includes ( includes ) . data ( ) ) [EOL] return DnsRequestResponse ( dns_request = dns_request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from fastapi import APIRouter [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] ) async def login ( ) : [EOL] return { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import boucanpy [EOL] import builtins [EOL] from typing import List [EOL] from boucanpy . core import Depends [EOL] from fastapi import APIRouter , Query [EOL] from boucanpy . db . models . user import User [EOL] from boucanpy . core . security import ScopedTo , hash_password , TokenPayload , current_user [EOL] from boucanpy . core import ( PaginationQS , SortQS , BaseResponse , abort , only , abort_for_input , logger , ) [EOL] from boucanpy . core . user import ( UserRepo , UsersResponse , UserResponse , UserData , UserCreateForm , UserEditForm , ) [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = UsersResponse ) async def index ( sort_qs = Depends ( SortQS ) , pagination = Depends ( PaginationQS ) , user_repo = Depends ( UserRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] pg , items = user_repo . sort ( sort_qs ) . paginate ( pagination ) . data ( ) [EOL] return UsersResponse ( pagination = pg , users = items ) [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] , response_model = UserResponse ) async def store ( form , user_repo = Depends ( UserRepo ( ) ) , token = Depends ( ScopedTo ( [string] , [string] , satisfy = [string] ) ) , ) : [EOL] [EOL] if user_repo . exists ( email = form . email ) : [EOL] abort_for_input ( [string] , [string] ) [EOL] [EOL] user_repo . clear ( ) [EOL] [EOL] [comment] [EOL] data = { [string] : form . email , [string] : hash_password ( form . password ) , [string] : getattr ( form , [string] , True ) , [string] : getattr ( form , [string] , False ) , } [EOL] item = user_repo . create ( data ) . data ( ) [EOL] return UserResponse ( user = item ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = UserResponse ) async def show ( user_id , user_repo = Depends ( UserRepo ( ) ) , token = Depends ( ScopedTo ( [string] , [string] ) ) , includes = Query ( None ) , ) : [EOL] includes = only ( includes , [ ] , values = True ) [EOL] [EOL] item = user_repo . loads ( includes ) . get_or_fail ( user_id ) . includes ( includes ) . data ( ) [EOL] return UserResponse ( user = item ) [EOL] [EOL] [EOL] @ router . put ( [string] , name = [string] , response_model = UserResponse ) async def update ( user_id , form , user_repo = Depends ( UserRepo ( ) ) , token = Depends ( ScopedTo ( [string] , [string] , satisfy = [string] ) ) , ) : [EOL] [EOL] email = getattr ( form , [string] , None ) [EOL] if email : [EOL] for u in user_repo . new ( ) . all ( ) . results ( ) : [EOL] print ( [string] , u . id , u . email , u ) [EOL] existing = user_repo . new ( ) . first ( email = email ) . results ( ) [EOL] if existing and existing . id != user_id : [EOL] abort_for_input ( msg = [string] , code = [number] , field = [string] ) [EOL] [EOL] data = only ( form , [ [string] , [string] , [string] ] ) [EOL] [EOL] if getattr ( form , [string] , None ) : [EOL] data [ [string] ] = hash_password ( form . password ) [EOL] [EOL] item = user_repo . new ( ) . get_or_fail ( user_id ) . update ( data ) . data ( ) [EOL] return UserResponse ( user = item ) [EOL] [EOL] [EOL] @ router . put ( [string] , name = [string] , response_model = UserResponse ) async def activate ( user_id , user_repo = Depends ( UserRepo ( ) ) , token = Depends ( ScopedTo ( [string] , [string] ) ) , ) : [EOL] [EOL] user = user_repo . get_or_fail ( user_id ) . update ( { [string] : True } ) . data ( ) [EOL] return UserResponse ( user = user ) [EOL] [EOL] [EOL] @ router . delete ( [string] , response_model = BaseResponse ) async def destroy ( user_id , user_repo = Depends ( UserRepo ( ) ) , token = Depends ( ScopedTo ( [string] , [string] , satisfy = [string] ) ) , user = Depends ( current_user ) , ) : [EOL] if user_id == user . id : [EOL] abort ( [number] , msg = [string] ) [EOL] [EOL] remaining_supers = len ( user_repo . filter ( user_repo . label ( [string] ) == True , user_repo . label ( [string] ) == True , user_repo . label ( [string] ) != user_id , ) . all ( ) . results ( ) ) [EOL] [EOL] if remaining_supers < [number] : [EOL] abort ( [number] , msg = [string] ) [EOL] [EOL] user_repo . clear ( ) [EOL] [EOL] messages = [ { [string] : [string] , [string] : [string] } ] [EOL] if not user_repo . exists ( id = user_id ) : [EOL] return BaseResponse ( messages = messages ) [EOL] [EOL] user_repo . deactivate ( user_id ) [EOL] return BaseResponse ( messages = messages ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import boucanpy [EOL] from typing import List [EOL] from fastapi import APIRouter , Depends , Query [EOL] from boucanpy . core import logger , only , abort , abort_for_input [EOL] from boucanpy . core . security import ScopedTo , TokenPayload [EOL] from boucanpy . core import PaginationQS , SortQS [EOL] from boucanpy . core . http_server import ( HttpServerRepo , HttpServersResponse , HttpServerResponse , HttpServerCreateForm , ) [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = HttpServersResponse ) async def index ( sort_qs = Depends ( SortQS ) , pagination = Depends ( PaginationQS ) , http_server_repo = Depends ( HttpServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , search = Query ( None ) , includes = Query ( None ) , ) : [EOL] includes = only ( includes , [ [string] ] , values = True ) [EOL] [EOL] pg , items = ( http_server_repo . loads ( includes ) . includes ( includes ) . search ( search , searchable = [ [string] , [string] ] ) . paginate ( pagination ) . data ( ) ) [EOL] return HttpServersResponse ( pagination = pg , http_servers = items ) [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] , response_model = HttpServerResponse ) async def store ( form , http_server_repo = Depends ( HttpServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] if http_server_repo . exists ( name = form . name . lower ( ) ) : [EOL] abort_for_input ( [string] , [string] ) [EOL] [EOL] data = only ( dict ( form ) , [ [string] ] ) [EOL] [EOL] data [ [string] ] = data [ [string] ] . lower ( ) [EOL] [EOL] item = http_server_repo . create ( data ) . data ( ) [EOL] return HttpServerResponse ( http_server = item ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = HttpServerResponse , ) async def show ( http_server , http_server_repo = Depends ( HttpServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] includes = only ( includes , [ [string] ] , values = True ) [EOL] [EOL] http_server_id_label = http_server_repo . label ( [string] ) [EOL] [EOL] try : [EOL] http_server = int ( http_server ) [EOL] label = http_server_id_label [EOL] except ValueError : [EOL] label = http_server_repo . label ( [string] ) [EOL] [EOL] [comment] [EOL] item = ( http_server_repo . loads ( includes ) . filter ( label == http_server ) . first_or_fail ( ) . includes ( includes ) . data ( ) ) [EOL] [EOL] return HttpServerResponse ( http_server = item ) [EOL] [EOL] [EOL] [comment] [EOL] @ router . put ( [string] , name = [string] , response_model = HttpServerResponse , ) async def update ( http_server , form , http_server_repo = Depends ( HttpServerRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] [EOL] data = only ( dict ( form ) , [ [string] ] ) [EOL] data [ [string] ] = data [ [string] ] . lower ( ) [EOL] [EOL] http_server_id_label = http_server_repo . label ( [string] ) [EOL] [EOL] try : [EOL] http_server = int ( http_server ) [EOL] label = http_server_id_label [EOL] except ValueError : [EOL] label = http_server_repo . label ( [string] ) [EOL] [EOL] [comment] [EOL] item = ( http_server_repo . filter ( label == http_server ) . first_or_fail ( ) . update ( data ) . data ( ) ) [EOL] [EOL] return HttpServerResponse ( http_server = item ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import boucanpy [EOL] from typing import List [EOL] from textwrap import dedent [EOL] from dnslib import RR , DNSRecord [EOL] from dnslib . dns import DNSError [EOL] from fastapi import APIRouter , Depends , Query [EOL] from boucanpy . core import only [EOL] from boucanpy . core . security import ScopedTo , TokenPayload [EOL] from boucanpy . core import SortQS , PaginationQS [EOL] [EOL] from boucanpy . dns . parser import RecordParser [EOL] [EOL] from boucanpy . core . dns_record import ( DnsRecordsResponse , DnsRecordResponse , DnsRecordRepo , DnsRecordForZoneCreateForm , DnsRecordsDigResponse , ) [EOL] from boucanpy . core . zone import ZoneRepo [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = DnsRecordsResponse ) async def index ( zone_id , sort_qs = Depends ( SortQS ) , pagination = Depends ( PaginationQS ) , dns_record_repo = Depends ( DnsRecordRepo ( ) ) , zone_repo = Depends ( ZoneRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] zone_repo . exists ( id = zone_id , or_fail = True ) [EOL] [EOL] includes = only ( includes , [ [string] ] , values = True ) [EOL] [EOL] pg , items = ( dns_record_repo . loads ( [string] ) . sort ( sort_qs ) . filter_by ( zone_id = zone_id ) . paginate ( pagination ) . includes ( includes ) . data ( ) ) [EOL] return DnsRecordsResponse ( pagination = pg , dns_records = items ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = DnsRecordsDigResponse , ) async def dig ( zone_id , zone_repo = Depends ( ZoneRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] zone = zone_repo . includes ( [string] ) . first_or_fail ( id = zone_id ) . results ( ) [EOL] print ( zone ) [EOL] print ( zone . dns_records ) [EOL] [comment] [EOL] rrs = RecordParser . from_zone ( zone ) . get_rrs ( ) [EOL] dig = DNSRecord ( rr = rrs ) . toZone ( ) [EOL] return DnsRecordsDigResponse ( dig = dig ) [EOL] [EOL] [EOL] @ router . post ( [string] , name = [string] , response_model = DnsRecordsDigResponse ) async def store ( zone_id , form , dns_record_repo = Depends ( DnsRecordRepo ( ) ) , zone_repo = Depends ( ZoneRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] zone_repo . exists ( id = zone_id , or_fail = True ) [EOL] [EOL] data = only ( dict ( form ) , [ [string] , [string] ] ) [EOL] data [ [string] ] = zone_id [EOL] [EOL] item = dns_record_repo . create ( data ) . data ( ) [EOL] return DnsRecordResponse ( dns_record = item ) [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] , response_model = DnsRecordResponse , ) async def show ( zone_id , dns_record_id , dns_record_repo = Depends ( DnsRecordRepo ( ) ) , zone_repo = Depends ( ZoneRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , includes = Query ( None ) , ) : [EOL] zone_repo . exists ( id = zone_id , or_fail = True ) [EOL] [EOL] includes = only ( includes , [ [string] ] , values = True ) [EOL] [EOL] item = ( dns_record_repo . loads ( [string] ) . filter_by ( zone_id = zone_id ) . first_or_fail ( id = dns_record_id ) . includes ( includes ) . data ( ) ) [EOL] [EOL] return DnsRecordResponse ( dns_record = item ) [EOL] [EOL] [EOL] @ router . put ( [string] , name = [string] , response_model = DnsRecordResponse , ) async def update ( zone_id , dns_record_id , form , dns_record_repo = Depends ( DnsRecordRepo ( ) ) , zone_repo = Depends ( ZoneRepo ( ) ) , token = Depends ( ScopedTo ( [string] ) ) , ) : [EOL] [comment] [EOL] zone_repo . exists ( id = zone_id , or_fail = True ) [EOL] [EOL] data = only ( form , [ [string] , [string] ] ) [EOL] [EOL] item = dns_record_repo . first_or_fail ( id = dns_record_id ) . update ( data ) . data ( ) [EOL] [EOL] return DnsRecordResponse ( dns_record = item ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from fastapi import APIRouter [EOL] import aioredis [EOL] from boucanpy . broadcast import make_redis , make_broadcast_url [EOL] [EOL] router = APIRouter ( ) [EOL] options = { [string] : [string] } [EOL] [EOL] [EOL] @ router . get ( [string] , name = [string] ) async def ws_test ( ) : [EOL] publisher = await aioredis . create_redis ( make_broadcast_url ( ) ) [EOL] res = await publisher . publish_json ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] return { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Union , Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import alembic [EOL] from os import environ [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] LIB_LOGGERS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def make_logger ( ) : [EOL] handler = logging . StreamHandler ( ) [EOL] handler . setLevel ( logging . INFO ) [EOL] log_level = environ . get ( [string] , [string] ) . upper ( ) [EOL] log_format = environ . get ( [string] , [string] ) . upper ( ) [EOL] if log_format == [string] or log_format == [string] : [EOL] handler . setFormatter ( logging . Formatter ( [string] , datefmt = [string] , ) ) [EOL] else : [EOL] handler . setFormatter ( logging . Formatter ( [string] ) ) [EOL] [EOL] level = getattr ( logging , log_level , [string] ) [EOL] logger = logging . getLogger ( ) [EOL] logger . addHandler ( handler ) [EOL] logger . setLevel ( level ) [EOL] logger . debug ( [string] ) [EOL] return logger , handler [EOL] [EOL] [EOL] logger , handler = make_logger ( ) [EOL] [EOL] [comment] [EOL] def get_logger ( ) : [EOL] global logger [EOL] return logger [EOL] [EOL] [EOL] def get_handler ( ) : [EOL] global handler [EOL] return handler [EOL] [EOL] [EOL] def set_log_format ( format_ = [string] ) : [EOL] get_logger ( ) . debug ( f" [string] { format_ }" ) [EOL] [EOL] if format_ == [string] or format_ == [string] : [EOL] formatter = logging . Formatter ( [string] , datefmt = [string] , ) [EOL] else : [EOL] formatter = logging . Formatter ( [string] ) [EOL] [EOL] get_handler ( ) . setFormatter ( formatter ) [EOL] get_logger ( ) . debug ( [string] ) [EOL] [EOL] if format_ == [string] or format_ == [string] : [EOL] lib_formatter = logging . Formatter ( [string] , datefmt = [string] , ) [EOL] else : [EOL] lib_formatter = logging . Formatter ( [string] ) [EOL] [EOL] get_logger ( ) . debug ( f" [string] { format_ } [string] " ) [EOL] [EOL] for l in LIB_LOGGERS : [EOL] sl = logging . getLogger ( l ) [EOL] for h in sl . handlers : [EOL] h . setFormatter ( lib_formatter ) [EOL] [EOL] [EOL] def set_log_level ( level , second_level = None ) : [EOL] second_level = second_level or level [EOL] get_logger ( ) . debug ( f" [string] { level } [string] { second_level }" ) [EOL] get_logger ( ) . setLevel ( getattr ( logging , level . upper ( ) , [string] ) ) [EOL] get_handler ( ) . setLevel ( getattr ( logging , level . upper ( ) , [string] ) ) [EOL] [EOL] get_logger ( ) . debug ( [string] ) [EOL] [EOL] get_logger ( ) . info ( f" [string] { second_level . upper ( ) }" ) [EOL] [EOL] for l in LIB_LOGGERS : [EOL] sl = logging . getLogger ( l ) [EOL] sl . setLevel ( getattr ( logging , second_level . upper ( ) , [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def get_uvicorn_logging ( level , second_level , format_ ) : [EOL] if format_ == [string] or format_ == [string] : [EOL] uvicorn_default_format = [string] [EOL] uvicorn_access_format = [string] [EOL] else : [EOL] uvicorn_default_format = [string] [EOL] uvicorn_access_format = ( [string] ) [EOL] [EOL] if hasattr ( logging , level . upper ( ) ) : [EOL] level = level . upper ( ) [EOL] else : [EOL] level = [string] [EOL] [EOL] logging_config = { [string] : [number] , [string] : False , [string] : { [string] : { [string] : [string] , [string] : uvicorn_default_format , } , [string] : { [string] : [string] , [string] : uvicorn_access_format , } , } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , } , [string] : { [string] : { [string] : [ [string] ] , [string] : level } , [string] : { [string] : level } , [string] : { [string] : [ [string] ] , [string] : level , [string] : False , } , } , } [EOL] [EOL] if hasattr ( logging , second_level . upper ( ) ) : [EOL] second_level = second_level . upper ( ) [EOL] else : [EOL] second_level = [string] [EOL] [EOL] for l in LIB_LOGGERS : [EOL] if l not in logging_config [ [string] ] . keys ( ) : [EOL] logging_config [ [string] ] [ l ] = { [string] : second_level , } [EOL] return logging_config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
NORMAL_SCOPES = [string] [EOL] SUPER_SCOPES = [string] [comment] [EOL] PUBLISH_SCOPES = [string] [EOL] NODE_SCOPES = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from fastapi import Depends as FADepends [EOL] [EOL] [EOL] def Depends ( * args , ** kwargs ) : [EOL] return FADepends ( * args , ** kwargs ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . logger import ( logger , set_log_level , make_logger , set_log_format , get_uvicorn_logging , ) [EOL] [EOL] [EOL] from . utils import ( only , only_values , abort , abort_for_input , is_valid_domain , is_valid_ipv4address , ) [EOL] [EOL] from . token import Token , TokenPayloadDict , TokenPayload [EOL] from . pagination . qs import PaginationQS [EOL] from . base import SortQS , BaseResponse , MessageResponse [EOL] from . types import ( ConstrainedEmailStr , ConstrainedSecretStr , ConstrainedTokenStr , DnsRecordStr , ) [EOL] [EOL] from . enums import * [EOL] [EOL] from . depends import Depends [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class PaginationQS : [EOL] def __init__ ( self , page = [number] , per_page = [number] ) : [EOL] self . page = page [EOL] self . per_page = per_page [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0
from pydantic import BaseModel [EOL] from boucanpy . core . pagination . data import PaginationData [EOL] [EOL] [EOL] class PaginationResponse ( PaginationData ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from pydantic import BaseModel [EOL] [EOL] [EOL] class PaginationData ( BaseModel ) : [EOL] page = ... [EOL] per_page = ... [EOL] total = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
from . qs import PaginationQS [EOL] from . data import PaginationData [EOL] from . responses import PaginationResponse [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Optional [EOL] from pydantic import BaseModel [EOL] [EOL] [EOL] class Token ( BaseModel ) : [EOL] access_token = ... [EOL] token_type = ... [EOL] [EOL] [EOL] class TokenPayloadDict ( BaseModel ) : [EOL] sub = None [EOL] exp = None [EOL] scopes = ... [EOL] dns_server_name = [string] [EOL] http_server_name = [string] [EOL] [EOL] [EOL] class TokenPayload ( BaseModel ) : [EOL] sub = None [EOL] exp = None [EOL] token = [string] [EOL] scopes = ... [EOL] payload = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $TokenPayloadDict$ 0 0 0
from . data import Token , TokenPayloadDict , TokenPayload [EOL]	0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] from pydantic import BaseModel [EOL] [EOL] [EOL] class PasswordAuthResponse ( BaseModel ) : [EOL] token_type = ... [EOL] access_token = ... [EOL] ws_access_token = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0
from . forms import PasswordAuthForm , MfaAuthForm [EOL] from . responses import PasswordAuthResponse [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from pydantic import BaseModel , SecretStr , constr [EOL] from boucanpy . core import ( ConstrainedEmailStr , ConstrainedSecretStr , ConstrainedTokenStr , ) [EOL] [EOL] [EOL] class PasswordAuthForm ( BaseModel ) : [EOL] username = ... [EOL] password = ... [comment] [EOL] [EOL] [EOL] class MfaAuthForm ( BaseModel ) : [EOL] token = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.core.ConstrainedEmailStr$ 0 0 0 $boucanpy.core.ConstrainedSecretStr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.core.ConstrainedTokenStr$ 0 0 0
from typing import List , Optional [EOL] import typing [EOL] import boucanpy [EOL] from typing import List , Optional [EOL] [EOL] from pydantic import BaseModel [EOL] from boucanpy . core . pagination . responses import PaginationResponse [EOL] [EOL] [EOL] class MessageResponse ( BaseModel ) : [EOL] text = ... [EOL] type = ... [EOL] [EOL] [EOL] class BaseResponse ( BaseModel ) : [EOL] messages = [ ] [EOL] pagination = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[MessageResponse]$ 0 0 0 0 $typing.Optional[boucanpy.core.pagination.responses.PaginationResponse]$ 0 0 0
from . responses import BaseResponse , MessageResponse [EOL] from . qs import SortQS [EOL] from . data import BaseDataModel [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] from pydantic import BaseModel as PydanticBaseModel [EOL] [EOL] [EOL] class BaseDataModel ( PydanticBaseModel ) : [EOL] class Config : [EOL] orm_mode = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
import builtins [EOL] from typing import Type , List , Dict , Any [EOL] import typing [EOL] import sqlalchemy [EOL] import boucanpy [EOL] from os import environ [EOL] from typing import Optional , List [EOL] from fastapi import Depends [EOL] [EOL] from sqlalchemy import or_ , desc , func , cast , String [EOL] from sqlalchemy . dialects import postgresql [EOL] from sqlalchemy . orm import Session , joinedload , raiseload [EOL] [EOL] from boucanpy . core import logger , abort [EOL] from boucanpy . db . session import async_session [EOL] from boucanpy . db . pagination import Pagination [EOL] from boucanpy . core . pagination . data import PaginationData [EOL] [EOL] [EOL] class BaseRepo : [EOL] default_model = None [EOL] default_data_model = None [EOL] default_loads = [ ] [EOL] default_fitlers = [ ] [EOL] [EOL] def __init__ ( self , db = None , ** kwargs ) : [EOL] self . db = db [EOL] self . _query = None [EOL] self . _results = None [EOL] self . _data_model = None [EOL] self . _model = None [EOL] self . _is_paginated = False [EOL] self . _is_list = False [comment] [EOL] self . _options = [ ] [EOL] self . _includes = { } [EOL] [EOL] [comment] [EOL] async def __call__ ( self , db = Depends ( async_session ) ) : [EOL] return self . new ( db = db ) [EOL] [EOL] def new ( self , db = None , ** kwargs ) : [EOL] db = db or self . db [EOL] return self . __class__ ( db = db , ** kwargs ) [EOL] [EOL] [comment] [EOL] def results ( self ) : [EOL] return self . _results [EOL] [EOL] def set_results ( self , results ) : [EOL] [comment] [EOL] self . _results = results [EOL] return self [EOL] [EOL] def loads ( self , load ) : [EOL] if not load : [EOL] return self [EOL] if isinstance ( load , list ) : [EOL] for _load in load : [EOL] self . _options . append ( self . _loader ( _load ) ) [EOL] elif isinstance ( load , str ) : [EOL] self . _options . append ( self . _loader ( load ) ) [EOL] else : [EOL] raise Exception ( f" [string] { load }" ) [EOL] return self [EOL] [EOL] def _loader ( self , load ) : [EOL] if isinstance ( load , str ) : [EOL] if hasattr ( self , [string] + load ) : [EOL] return getattr ( self , [string] + load ) ( ) [EOL] elif [string] in load : [EOL] under_load = load . replace ( [string] , [string] ) [EOL] if hasattr ( self , [string] + under_load ) : [EOL] return getattr ( self , [string] + under_load ) ( ) [EOL] return self . _loader_chain ( load ) [EOL] elif load in self . model ( ) . __mapper__ . relationships . keys ( ) : [EOL] return joinedload ( self . label ( load ) ) [EOL] else : [EOL] raise Exception ( f" [string] { load }" ) [EOL] return load [EOL] [EOL] def _loader_chain ( self , load ) : [EOL] chain = None [EOL] parent = self . model ( ) [EOL] for part in load . split ( [string] ) : [EOL] chain = ( chain . joinedload ( getattr ( parent , part ) ) [EOL] if chain [EOL] else joinedload ( getattr ( parent , part ) ) ) [EOL] parent = self . _get_relationship_model ( part , parent ) [EOL] [EOL] return chain [EOL] [EOL] def _get_relationship_model ( self , name , model = None ) : [EOL] model = model or self . model ( ) [EOL] [comment] [EOL] [comment] [EOL] return getattr ( model . __mapper__ . relationships , name ) . mapper . class_ [EOL] [EOL] def strict ( self , rel = [string] ) : [EOL] self . _options . append ( raiseload ( rel ) ) [EOL] return self [EOL] [EOL] def includes ( self , prop , key = None ) : [EOL] if not prop : [EOL] return self [EOL] if isinstance ( prop , list ) : [EOL] for _prop in prop : [EOL] if isinstance ( _prop , tuple ) : [EOL] self . _includes [ _prop [ [number] ] ] = _prop [ [number] ] [EOL] else : [EOL] self . _includes [ _prop ] = _prop [EOL] elif isinstance ( prop , dict ) : [EOL] for include_prop , include_key in prop . items ( ) : [EOL] self . _includes [ include_prop ] = include_key [EOL] else : [EOL] key = key or prop [EOL] self . _includes [ prop ] = key [EOL] return self [EOL] [EOL] [comment] [EOL] def data ( self ) : [EOL] if self . _is_paginated : [EOL] return self . paginated_data ( ) [EOL] if self . _is_list : [EOL] return [ self . to_data ( r ) for r in self . results ( ) ] [EOL] return self . to_data ( self . results ( ) ) [EOL] [EOL] def paginated_data ( self ) : [EOL] return ( PaginationData ( page = self . _results . page , per_page = self . _results . per_page , total = self . _results . total , ) , [ self . to_data ( r ) for r in self . _results . items ] , ) [EOL] [EOL] def to_data ( self , item ) : [EOL] if not item : [EOL] return None [EOL] attrs = self . to_dict ( item ) [EOL] return self . data_model ( ) ( ** attrs ) [EOL] [EOL] def to_dict ( self , item ) : [EOL] type_str = str ( type ( item ) ) [EOL] root_data = item . as_dict ( ) if hasattr ( item , [string] ) else dict ( item ) [EOL] [EOL] self . debug ( f" [string] { type_str } [string] { str ( root_data ) }" ) [EOL] self . debug ( f" [string] { str ( self . _includes . keys ( ) ) }" ) [EOL] for name in self . _includes . keys ( ) : [EOL] if name not in root_data : [EOL] if not hasattr ( item , name ) : [EOL] self . debug ( f" [string] { str ( name ) } [string] { str ( item ) }" ) [EOL] continue [EOL] [comment] [EOL] elif not getattr ( item , name ) : [EOL] prop_key = self . _includes [ name ] [EOL] root_data [ prop_key ] = None [EOL] else : [EOL] prop = getattr ( item , name ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( prop , list ) : [EOL] prop_data = [ ] [EOL] for prop_item in prop : [EOL] [comment] [EOL] prop_item_data = ( prop_item . as_dict ( ) [EOL] if hasattr ( prop_item , [string] ) [EOL] else dict ( prop_item ) ) [EOL] prop_data . append ( prop_item_data ) [EOL] [comment] [EOL] else : [EOL] prop_data = ( prop . as_dict ( ) if hasattr ( prop , [string] ) else dict ( prop ) ) [EOL] prop_key = self . _includes [ name ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] root_data [ prop_key ] = prop_data [EOL] return root_data [EOL] [EOL] [comment] [EOL] def exists ( self , id = None , or_fail = False , ** kwargs ) : [EOL] if id and not kwargs : [EOL] self . filter_by ( id = id ) [EOL] elif kwargs : [EOL] self . filter_by ( ** kwargs ) [EOL] self . debug ( f" [string] { self . compiled ( ) } [string] { self . __class__ . __name__ }" ) [EOL] results = self . final ( ) . first ( ) [EOL] if or_fail and not results : [EOL] abort ( [number] , f" [string] { self . __class__ . __name__ }" ) [EOL] self . _results = results [EOL] return bool ( self . _results ) [EOL] [EOL] def exists_or_fail ( self , ** kwargs ) : [EOL] return self . exists ( or_fail = True , ** kwargs ) [EOL] [EOL] def first ( self , or_fail = False , ** kwargs ) : [EOL] if kwargs : [EOL] self . filter_by ( ** kwargs ) [EOL] self . debug ( f" [string] { self . compiled ( ) } [string] { self . __class__ . __name__ }" ) [EOL] results = self . final ( ) . first ( ) [EOL] if or_fail : [EOL] if not results : [EOL] abort ( [number] , f" [string] { self . __class__ . __name__ }" ) [EOL] self . _results = results [EOL] return self [EOL] [EOL] def first_or_fail ( self , ** kwargs ) : [EOL] return self . first ( or_fail = True , ** kwargs ) [EOL] [EOL] def get ( self , id , or_fail = False ) : [EOL] return self . first ( id = id , or_fail = or_fail ) [EOL] [EOL] def get_or_fail ( self , id ) : [EOL] return self . get ( id , or_fail = True ) [EOL] [EOL] def all ( self , ** kwargs ) : [EOL] if kwargs : [EOL] self . filter_by ( ** kwargs ) [EOL] self . debug ( f" [string] { self . compiled ( ) } [string] { self . __class__ . __name__ }" ) [EOL] [EOL] self . _results = self . final ( ) . all ( ) [EOL] self . _is_list = True [EOL] return self [EOL] [EOL] def paginate ( self , pagination ) : [EOL] self . debug ( f" [string] { self . compiled ( ) } [string] { self . __class__ . __name__ }" ) [EOL] self . _results = self . final ( ) . paginate ( page = pagination . page , per_page = pagination . per_page , count = True ) [EOL] self . _is_paginated = True [EOL] return self [EOL] [EOL] [comment] [EOL] [EOL] def search ( self , search , searchable = None ) : [EOL] if not search : [EOL] return self [EOL] [EOL] if not searchable : [EOL] searchable = self . model ( ) . __searchable__ [EOL] [EOL] if not searchable : [EOL] raise Exception ( f" [string] { search_qs }" ) [EOL] [EOL] [comment] [EOL] clauses = [ ] [EOL] for col in searchable : [EOL] if col == [string] or col . endswith ( ( [string] , [string] ) ) : [EOL] label = cast ( self . label ( col ) , String ) [EOL] else : [EOL] label = func . lower ( self . label ( col ) ) [EOL] clauses . append ( label . contains ( search ) ) [EOL] [EOL] self . filter_or ( * clauses ) [EOL] [EOL] return self [EOL] [EOL] def sort ( self , sort_qs ) : [EOL] sort = self . get_sort_by ( sort_qs . sort_by ) [EOL] if sort_qs . sort_dir . lower ( ) == [string] : [EOL] sort = desc ( sort ) [EOL] self . _query = self . query ( ) . order_by ( sort ) [EOL] return self [EOL] [EOL] def get_sort_by ( self , key ) : [EOL] return self . label ( key ) [EOL] [EOL] def filters ( self , key , * args , ** kwargs ) : [EOL] if hasattr ( self , [string] + key ) : [EOL] getattr ( self , [string] + key ) ( * args , ** kwargs ) [EOL] return self [EOL] [EOL] def filter_or ( self , * args , ** kwargs ) : [EOL] self . _query = self . query ( ) . filter ( or_ ( * args , ** kwargs ) ) [EOL] return self [EOL] [EOL] def filter_by ( self , ** kwargs ) : [EOL] self . _query = self . query ( ) . filter_by ( ** kwargs ) [EOL] [comment] [EOL] return self [EOL] [EOL] def filter ( self , * args , ** kwargs ) : [EOL] self . _query = self . query ( ) . filter ( * args , ** kwargs ) [EOL] [comment] [EOL] return self [EOL] [EOL] [comment] [EOL] def deactivate ( self , id ) : [EOL] self . get ( id ) [EOL] self . update ( { [string] : False } ) [EOL] return self [EOL] [EOL] def update ( self , data ) : [EOL] [comment] [EOL] try : [EOL] instance = self . results ( ) [EOL] if not isinstance ( data , dict ) : [EOL] data = dict ( data ) [EOL] for attr , value in data . items ( ) : [EOL] setattr ( instance , attr , value ) [EOL] self . db . add ( instance ) [EOL] self . db . commit ( ) [EOL] self . db . flush ( ) [EOL] self . _results = instance [EOL] return self [EOL] except Exception as e : [EOL] self . db . rollback ( ) [EOL] raise e [EOL] [EOL] def create ( self , data ) : [EOL] try : [EOL] if not isinstance ( data , dict ) : [EOL] data = dict ( data ) [EOL] instance = self . model ( ) ( ** data ) [EOL] self . db . add ( instance ) [EOL] self . db . commit ( ) [EOL] self . db . flush ( ) [EOL] self . _results = instance [EOL] return self [EOL] except Exception as e : [EOL] self . db . rollback ( ) [EOL] raise e [EOL] [EOL] def delete ( self ) : [EOL] try : [EOL] instance = self . results ( ) [EOL] self . db . delete ( instance ) [EOL] self . db . commit ( ) [EOL] self . db . flush ( ) [EOL] self . _results = instance [EOL] return self [EOL] except Exception as e : [EOL] self . db . rollback ( ) [EOL] raise e [EOL] [EOL] [comment] [EOL] [EOL] def final ( self , attach = True ) : [EOL] self . _query = self . query ( ) . options ( * self . _options ) [EOL] return self . query ( ) [EOL] [EOL] def query ( self ) : [EOL] if not self . _query : [EOL] [comment] [EOL] self . _query = self . db . query ( self . model ( ) ) [EOL] self . loads ( self . default_loads ) [EOL] return self . _query [EOL] [EOL] def compiled ( self ) : [EOL] return ( str ( self . query ( ) . statement . compile ( dialect = postgresql . base . PGDialect ( ) , compile_kwargs = { [string] : True } , ) ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] [EOL] def set_data_model ( self , data_model ) : [EOL] self . _data_model = data_model [EOL] return self [EOL] [EOL] def label ( self , key ) : [EOL] if [string] not in key : [EOL] return getattr ( self . model ( ) , key ) [EOL] parent = self . model ( ) [EOL] parts = key . split ( [string] ) [EOL] final_index = len ( parts ) - [number] [EOL] for i , part in enumerate ( parts ) : [EOL] if i == final_index : [EOL] return getattr ( parent , part ) [EOL] parent = self . _get_relationship_model ( part , parent ) [EOL] raise Exception ( f" [string] { key }" ) [EOL] [EOL] def model ( self ) : [EOL] return self . _model or self . default_model [EOL] [EOL] def data_model ( self ) : [EOL] return self . _data_model or self . default_data_model [EOL] [EOL] def debug ( self , msg ) : [EOL] [comment] [EOL] if int ( environ . get ( [string] , [number] ) ) == [number] : [EOL] logger . debug ( msg ) [EOL] [EOL] def clear ( self ) : [EOL] self . _query = None [EOL] self . _results = None [EOL] self . _data_model = None [EOL] self . _model = None [EOL] self . _is_paginated = False [EOL] self . _is_list = False [comment] [EOL] self . _options = [ ] [EOL] self . _includes = { } [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.orm.Session$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.orm.Session$ 0 $sqlalchemy.orm.Session$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class SortQS : [EOL] def __init__ ( self , sort_by = [string] , sort_dir = [string] ) : [EOL] self . sort_by = sort_by [EOL] self . sort_dir = sort_dir [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0
from . repos import HttpRequestRepo [EOL] from . responses import HttpRequestResponse , HttpRequestsResponse [EOL] from . data import HttpRequestData [EOL] from . forms import HttpRequestCreateForm [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] [EOL] from pydantic import BaseModel [EOL] [EOL] from boucanpy . core . base . responses import BaseResponse [EOL] from boucanpy . core . http_request . data import HttpRequestData [EOL] [EOL] [EOL] class HttpRequestResponse ( BaseResponse ) : [EOL] http_request = ... [EOL] [EOL] [EOL] class HttpRequestsResponse ( BaseResponse ) : [EOL] http_requests = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.core.http_request.data.HttpRequestData$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[boucanpy.core.http_request.data.HttpRequestData]$ 0 0 0
from boucanpy . core . types import HttpRequestData [EOL]	0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import os [EOL] from pathlib import Path [EOL] from dotenv import load_dotenv [EOL] from . paths import env_dir [EOL] from boucanpy . core . logger import logger [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def setenv ( key , val ) : [EOL] os . environ [ key ] = val [EOL] [EOL] [EOL] def getenv ( key , default = None , optional = False ) : [EOL] val = os . getenv ( key , default ) [EOL] if not val and not optional : [EOL] raise Exception ( f" [string] { key } [string] " ) [EOL] return val [EOL] [EOL] [EOL] def getenv_bool ( var_name , default = False , optional = False ) : [EOL] result = default_value [EOL] env_value = os . getenv ( var_name ) [EOL] if env_value is not None : [EOL] result = env_value . upper ( ) in ( [string] , [string] ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from os . path import abspath , dirname , join [EOL] [EOL] _utils_dir = abspath ( dirname ( __file__ ) ) [EOL] [EOL] [EOL] def _ajoin ( target , path ) : [EOL] return abspath ( join ( target , path ) ) [EOL] [EOL] [EOL] def core_dir ( path = None ) : [EOL] if not path : [EOL] return _ajoin ( _utils_dir , [string] ) [EOL] return _ajoin ( core_dir ( ) , path ) [EOL] [EOL] [EOL] def project_dir ( path = None ) : [EOL] if not path : [EOL] return _ajoin ( core_dir ( ) , [string] ) [EOL] return _ajoin ( project_dir ( ) , path ) [EOL] [EOL] [EOL] def storage_dir ( path = None ) : [EOL] if not path : [EOL] return project_dir ( [string] ) [EOL] return _ajoin ( storage_dir ( ) , path ) [EOL] [EOL] [EOL] def root_dir ( path = None ) : [EOL] if not path : [EOL] return _ajoin ( project_dir ( ) , [string] ) [EOL] return _ajoin ( root_dir ( ) , path ) [EOL] [EOL] [EOL] def cli_dir ( path = None ) : [EOL] if not path : [EOL] return project_dir ( [string] ) [EOL] return _ajoin ( cli_dir ( ) , path ) [EOL] [EOL] [EOL] def dns_dir ( path = None ) : [EOL] if not path : [EOL] return project_dir ( [string] ) [EOL] return _ajoin ( dns_dir ( ) , path ) [EOL] [EOL] [EOL] def api_dir ( path = None ) : [EOL] if not path : [EOL] return project_dir ( [string] ) [EOL] return _ajoin ( api_dir ( ) , path ) [EOL] [EOL] [EOL] def db_dir ( path = None ) : [EOL] if not path : [EOL] return project_dir ( [string] ) [EOL] return _ajoin ( db_dir ( ) , path ) [EOL] [EOL] [EOL] def webui_dir ( path = None ) : [EOL] if not path : [EOL] return root_dir ( [string] ) [EOL] return _ajoin ( webui_dir ( ) , path ) [EOL] [EOL] [EOL] def landing_dir ( path = None ) : [EOL] if not path : [EOL] return root_dir ( [string] ) [EOL] return _ajoin ( landing_dir ( ) , path ) [EOL] [EOL] [EOL] def test_dir ( path = None ) : [EOL] if not path : [EOL] return project_dir ( [string] ) [EOL] return _ajoin ( test_dir ( ) , path ) [EOL] [EOL] [EOL] def env_dir ( path = None ) : [EOL] if not path : [EOL] return root_dir ( [string] ) [EOL] return _ajoin ( env_dir ( ) , path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] def snake_to_title ( target ) : [EOL] return [string] . join ( segment . title ( ) for segment in target . split ( [string] ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . formatting import snake_to_title [EOL] from . paths import ( env_dir , test_dir , landing_dir , webui_dir , db_dir , api_dir , dns_dir , cli_dir , root_dir , storage_dir , project_dir , core_dir , ) [EOL] from . env import setenv , getenv , getenv_bool [EOL] from . helpers import only , only_values , abort , abort_for_input [EOL] from . validating import is_valid_domain , is_valid_ipv4address [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . repos import UserRepo [EOL] from . responses import UserResponse , UsersResponse [EOL] from . data import UserData [EOL] from . forms import UserCreateForm , UserEditForm [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from datetime import datetime [EOL] from pydantic import BaseModel [EOL] [EOL] [EOL] class UserData ( BaseModel ) : [EOL] id = ... [EOL] email = ... [EOL] is_superuser = ... [EOL] is_active = ... [EOL] created_at = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $datetime.datetime$ 0 0 0
from typing import Optional [EOL] from pydantic import BaseModel , ValidationError , validator , constr [EOL] from boucanpy . core import ConstrainedEmailStr , ConstrainedSecretStr [EOL] [EOL] [EOL] class UserCreateForm ( BaseModel ) : [EOL] email = ... [EOL] is_superuser = ... [EOL] password = ... [EOL] password_confirm = ... [EOL] [EOL] @ validator ( [string] ) def passwords_match ( cls , v , values , ** kwargs ) : [EOL] if [string] in values and v != values [ [string] ] : [EOL] raise ValueError ( [string] ) [EOL] return v [EOL] [EOL] @ validator ( [string] ) def email_is_lower ( cls , v , values , ** kwargs ) : [EOL] if not v : [EOL] return [string] [EOL] return v . lower ( ) [EOL] [EOL] [EOL] class UserEditForm ( BaseModel ) : [EOL] email = ... [EOL] is_superuser = ... [EOL] password = ... [EOL] password_confirm = ... [EOL] [EOL] @ validator ( [string] ) def passwords_match ( cls , v , values , ** kwargs ) : [EOL] if [string] in values and v != values [ [string] ] : [EOL] raise ValueError ( [string] ) [EOL] return v [EOL] [EOL] @ validator ( [string] ) def email_is_lower ( cls , v , values , ** kwargs ) : [EOL] if not v : [EOL] return [string] [EOL] return v . lower ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.core.ConstrainedEmailStr$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $boucanpy.core.ConstrainedSecretStr$ 0 0 0 $boucanpy.core.ConstrainedSecretStr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[boucanpy.core.ConstrainedEmailStr]$ 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 $typing.Optional[boucanpy.core.ConstrainedSecretStr]$ 0 0 0 $typing.Optional[boucanpy.core.ConstrainedSecretStr]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] [EOL] from pydantic import BaseModel [EOL] [EOL] from boucanpy . core . base . responses import BaseResponse [EOL] from boucanpy . core . user . data import UserData [EOL] [EOL] [EOL] class UserResponse ( BaseResponse ) : [EOL] user = ... [EOL] [EOL] [EOL] class UsersResponse ( BaseResponse ) : [EOL] users = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $boucanpy.core.user.data.UserData$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[boucanpy.core.user.data.UserData]$ 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from boucanpy . api . api import api [EOL] from starlette . testclient import TestClient [EOL] [EOL] client = TestClient ( api ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from tests . integration . client import client [EOL] [EOL] [EOL] def test_status ( ) : [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from boucanpy . db . factories import factory [EOL] from boucanpy . core . security import create_bearer_token [EOL] from boucanpy . core import SUPER_SCOPES , NORMAL_SCOPES [EOL] import sys [EOL] [EOL] [EOL] def test_superuser_can_create_user ( client , session ) : [EOL] auth = factory ( [string] , session = session ) . create ( ) [EOL] [EOL] token = create_bearer_token ( data = { [string] : auth . id , [string] : SUPER_SCOPES } ) [EOL] bearer = [string] + str ( token ) [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] response = client . post ( [string] , json = data , headers = { [string] : [string] , [string] : bearer } , ) [EOL] assert response . status_code == [number] [EOL] assert response . json ( ) [ [string] ] [ [string] ] == data [ [string] ] [EOL] [EOL] [EOL] def test_mismatching_passwords_causes_failure ( client , session ) : [EOL] auth = factory ( [string] , session = session ) . create ( ) [EOL] [EOL] token = create_bearer_token ( data = { [string] : auth . id , [string] : SUPER_SCOPES } ) [EOL] bearer = [string] + str ( token ) [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] response = client . post ( [string] , json = data , headers = { [string] : [string] , [string] : bearer } , ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_short_password_causes_failure ( client , session ) : [EOL] auth = factory ( [string] , session = session ) . create ( ) [EOL] [EOL] token = create_bearer_token ( data = { [string] : auth . id , [string] : SUPER_SCOPES } ) [EOL] bearer = [string] + str ( token ) [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] response = client . post ( [string] , json = data , headers = { [string] : [string] , [string] : bearer } , ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_common_or_bad_password_causes_failure ( client , session ) : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] def test_short_email_causes_failure ( client , session ) : [EOL] auth = factory ( [string] , session = session ) . create ( ) [EOL] [EOL] token = create_bearer_token ( data = { [string] : auth . id , [string] : SUPER_SCOPES } ) [EOL] bearer = [string] + str ( token ) [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] response = client . post ( [string] , json = data , headers = { [string] : [string] , [string] : bearer } , ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_username_is_not_valid_email_format_causes_failure ( client , session ) : [EOL] auth = factory ( [string] , session = session ) . create ( ) [EOL] [EOL] token = create_bearer_token ( data = { [string] : auth . id , [string] : SUPER_SCOPES } ) [EOL] bearer = [string] + str ( token ) [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] response = client . post ( [string] , json = data , headers = { [string] : [string] , [string] : bearer } , ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_regular_user_cannot_create_user ( client , session ) : [EOL] auth = factory ( [string] , session = session ) . create ( ) [EOL] [EOL] token = create_bearer_token ( data = { [string] : auth . id , [string] : NORMAL_SCOPES } ) [EOL] bearer = [string] + str ( token ) [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] response = client . post ( [string] , json = data , headers = { [string] : [string] , [string] : bearer } , ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_unauthed_user_cannot_create_user ( client , session ) : [EOL] bearer = [string] [EOL] data = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] response = client . post ( [string] , json = data , headers = { [string] : [string] , [string] : bearer } , ) [EOL] assert response . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from boucanpy . db . factories import factory [EOL] from boucanpy . db . models import model [EOL] [EOL] from boucanpy . core . security import create_bearer_token [EOL] from boucanpy . core import SUPER_SCOPES , NORMAL_SCOPES [EOL] import sys [EOL] [EOL] [EOL] def test_superuser_can_update_user ( client , session ) : [EOL] auth = factory ( [string] , session = session ) . create ( ) [EOL] target = factory ( [string] , session = session ) . create ( email = [string] ) [EOL] [EOL] token = create_bearer_token ( data = { [string] : auth . id , [string] : SUPER_SCOPES } ) [EOL] bearer = [string] + str ( token ) [EOL] [EOL] data = { [string] : [string] } [EOL] [EOL] response = client . put ( f" [string] { str ( target . id ) }" , json = data , headers = { [string] : [string] , [string] : bearer } , ) [EOL] assert response . status_code == [number] [EOL] assert response . json ( ) [ [string] ] [ [string] ] == data [ [string] ] [EOL] [EOL] [EOL] def test_email_must_not_already_exist_or_failure ( client , session ) : [EOL] auth = factory ( [string] , session = session ) . create ( ) [EOL] existing = factory ( [string] , session = session ) . create ( email = [string] ) [EOL] target = factory ( [string] , session = session ) . create ( email = [string] ) [EOL] [EOL] token = create_bearer_token ( data = { [string] : auth . id , [string] : SUPER_SCOPES } ) [EOL] bearer = [string] + str ( token ) [EOL] [EOL] data = { [string] : existing . email } [EOL] [EOL] response = client . put ( f" [string] { str ( target . id ) }" , json = data , headers = { [string] : [string] , [string] : bearer } , ) [EOL] assert response . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0