from typing import Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import setuptools [EOL] [EOL] description = [string] [EOL] [EOL] with open ( [string] , [string] ) as readme : [EOL] long_description = readme . read ( ) [EOL] [EOL] GITHUB = [string] [EOL] DOCS = [string] [EOL] CHANGELOG = f"{ GITHUB } [string] " [EOL] [EOL] INSTALL_REQUIRES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] EXTRAS_REQUIRE = { [string] : [ [string] ] , [string] : [ [string] ] } [EOL] EXTRAS_REQUIRE [ [string] ] = [ req for reqs in EXTRAS_REQUIRE . values ( ) for req in reqs ] [EOL] [EOL] setuptools . setup ( name = [string] , version = [string] , author = [string] , author_email = [string] , description = description , long_description = long_description , long_description_content_type = [string] , packages = setuptools . find_packages ( ) , install_requires = INSTALL_REQUIRES , extras_require = EXTRAS_REQUIRE , python_requires = [string] , url = DOCS , project_urls = { [string] : GITHUB , [string] : DOCS , [string] : CHANGELOG , } , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Optional , Callable , Tuple , TypeVar , Any , Type [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import warnings [EOL] from functools import partial , wraps [EOL] from inspect import cleandoc , isclass [EOL] import typing [EOL] [EOL] _F = typing . TypeVar ( [string] , bound = typing . Callable ) [EOL] _T = typing . TypeVar ( [string] ) [EOL] _FT = typing . Union [ _F , typing . Type [ _T ] ] [EOL] [EOL] [EOL] def deprecated ( since , removal , alternative , update_doc = True , warn_on_instanciate = False , ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( alternative , tuple ) : [EOL] name , link = alternative [EOL] alternative = f" [string] { name } [string] { link } [string] " [EOL] [EOL] def get_message ( obj ) : [EOL] return ( f" [string] { obj . __name__ } [string] { since } [string] " f" [string] { removal } [string] { alternative } [string] " ) [EOL] [EOL] def show_warning ( obj ) : [EOL] warnings . simplefilter ( [string] , DeprecationWarning ) [EOL] warnings . warn ( get_message ( obj ) , category = DeprecationWarning , stacklevel = [number] ) [EOL] warnings . simplefilter ( [string] , DeprecationWarning ) [EOL] [EOL] def get_doc_warning ( obj ) : [EOL] return f" [string] { get_message ( obj ) } [string] " [EOL] [EOL] def add_warning ( obj ) : [EOL] if isclass ( obj ) : [EOL] cls = typing . cast ( typing . Type , obj ) [EOL] [EOL] if warn_on_instanciate : [EOL] [EOL] class wrapped ( cls ) : [comment] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] show_warning ( obj ) [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] wrapped . __name__ = cls . __name__ [EOL] wrapped . __doc__ = cls . __doc__ [EOL] [EOL] else : [EOL] wrapped = cls [comment] [EOL] [EOL] else : [EOL] func = typing . cast ( typing . Callable , obj ) [EOL] [EOL] @ wraps ( func ) def wrapped ( * args , ** kwargs ) : [EOL] show_warning ( func ) [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] if update_doc : [EOL] header , _ , body = cleandoc ( obj . __doc__ or [string] ) . partition ( [string] ) [EOL] wrapped . __doc__ = [string] . join ( [ header , get_doc_warning ( obj ) , body ] ) [EOL] [EOL] return wrapped [EOL] [EOL] return add_warning [EOL] [EOL] [EOL] class ReplacedBy : [EOL] def __init__ ( self , since , removal , obj_root = [string] , doc_root = [string] ) : [EOL] self . _obj_root = obj_root [EOL] self . _doc_root = doc_root [EOL] self . _factory = partial ( deprecated , since = since , removal = removal ) [EOL] [EOL] def __call__ ( self , name , fragment = None ) : [EOL] alternative = ... [EOL] if fragment is not None : [EOL] alternative = ( self . _obj_root + name , self . _doc_root + fragment ) [EOL] else : [EOL] alternative = self . _obj_root + name [EOL] return self . _factory ( alternative = alternative ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_FT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Union[builtins.str,typing.Tuple[typing.Any,...]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[builtins.str,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[builtins.str,typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Union[builtins.str,typing.Tuple[typing.Any,...]]$ 0 $typing.Union[builtins.str,typing.Tuple[typing.Any,...]]$ 0 0
from typing import Dict , Callable , Tuple , List , Any , Type [EOL] import builtins [EOL] import typesystem [EOL] import bocadillo [EOL] import inspect [EOL] import typing [EOL] import decimal [EOL] import inspect [EOL] from datetime import date , datetime , time [EOL] from functools import wraps [EOL] import typing [EOL] [EOL] import typesystem [EOL] [EOL] FIELD_ALIASES = { int : typesystem . Integer , float : typesystem . Float , bool : typesystem . Boolean , decimal . Decimal : typesystem . Decimal , date : typesystem . Date , time : typesystem . Time , datetime : typesystem . DateTime , } [EOL] [EOL] [EOL] class PathConversionError ( typesystem . ValidationError ) : [EOL] pass [EOL] [EOL] [EOL] class Converter : [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , func ) : [EOL] self . func = func [EOL] self . signature = inspect . signature ( self . func ) [EOL] [EOL] self . annotations = { param . name : param . annotation for param in self . signature . parameters . values ( ) if param . annotation is not inspect . Parameter . empty } [EOL] self . required_params = set ( param . name for param in self . signature . parameters . values ( ) if param . default is inspect . Parameter . empty ) [EOL] [EOL] def convert ( self , args , kwargs ) : [EOL] bound = self . signature . bind ( * args , ** kwargs ) [EOL] [EOL] errors = [ ] [EOL] [EOL] for param_name , value in bound . arguments . items ( ) : [EOL] try : [EOL] annotation = self . annotations [ param_name ] [EOL] except KeyError : [EOL] continue [EOL] [EOL] [comment] [EOL] if isinstance ( annotation , typesystem . Field ) : [EOL] field = annotation [EOL] else : [EOL] try : [EOL] field = FIELD_ALIASES [ annotation ] ( ) [EOL] except KeyError : [EOL] continue [EOL] [EOL] [comment] [EOL] try : [EOL] value = field . validate ( value ) [EOL] except typesystem . ValidationError as exc : [EOL] [comment] [EOL] [comment] [EOL] errors . extend ( exc . messages ( add_prefix = param_name ) ) [EOL] else : [EOL] bound . arguments [ param_name ] = value [EOL] [EOL] if errors : [EOL] raise PathConversionError ( messages = errors ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] bound . apply_defaults ( ) [EOL] [EOL] return bound . args , bound . kwargs [EOL] [EOL] [EOL] class ViewConverter ( Converter ) : [EOL] [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , func ) : [EOL] super ( ) . __init__ ( func ) [EOL] [EOL] self . query_parameters = set ( param . name for param in self . signature . parameters . values ( ) if param . default is not inspect . Parameter . empty ) [EOL] [EOL] def get_query_params ( self , args , kwargs ) : [EOL] raise NotImplementedError [EOL] [EOL] def convert ( self , args , kwargs ) : [EOL] query_params = self . get_query_params ( args , kwargs ) [EOL] [EOL] for param_name in self . query_parameters : [EOL] if param_name in query_params : [EOL] kwargs [ param_name ] = query_params [ param_name ] [EOL] [EOL] return super ( ) . convert ( args , kwargs ) [EOL] [EOL] [EOL] def convert_arguments ( func , converter_class ) : [EOL] converter = converter_class ( func ) [EOL] [EOL] @ wraps ( func ) async def converted ( * args , ** kwargs ) : [EOL] args , kwargs = converter . convert ( args , kwargs ) [EOL] return await func ( * args , ** kwargs ) [EOL] [EOL] return converted [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Type,typesystem.Field]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.tuple,builtins.dict]$ 0 0 0 $builtins.tuple$ 0 $builtins.dict$ 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 $builtins.dict$ 0 0 0 $typing.List[typesystem.ValidationError]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $inspect.BoundArguments$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Type,typesystem.Field]$ 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typesystem.ValidationError]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typesystem.ValidationError]$ 0 0 0 0 0 0 0 $typing.List[typesystem.ValidationError]$ 0 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 0 0 $inspect.BoundArguments$ 0 $builtins.tuple$ 0 $inspect.BoundArguments$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.tuple$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.tuple,builtins.dict]$ 0 0 0 $builtins.tuple$ 0 $builtins.dict$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.tuple$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.dict$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 $builtins.dict$ 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Awaitable , Callable , MutableMapping , Any , Type [EOL] import bocadillo [EOL] import typing [EOL] import request [EOL] import response [EOL] import typing [EOL] [EOL] from . request import Request [EOL] from . response import Response [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from . applications import App [EOL] [EOL] [comment] [EOL] Scope = dict [EOL] Event = typing . MutableMapping [ str , typing . Any ] [EOL] Receive = typing . Callable [ [ ] , typing . Awaitable [ Event ] ] [EOL] Send = typing . Callable [ [ Event ] , None ] [EOL] [EOL] [EOL] class ASGIApp : [EOL] def __call__ ( self , scope , receive , send ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] [comment] [EOL] Handler = typing . Callable [ [ Request , Response , typing . Any ] , typing . Awaitable [ None ] ] [EOL] ErrorHandler = typing . Callable [ [ Request , Response , BaseException ] , typing . Awaitable [ None ] ] [EOL] [EOL] [EOL] class HTTPApp : [EOL] async def __call__ ( self , req , res ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] [comment] [EOL] EventHandler = typing . Callable [ [ ] , typing . Awaitable [ None ] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Scope$ 0 $Receive$ 0 $Send$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $response.Response$ 0 0 0 $request.Request$ 0 $response.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , AsyncGenerator [EOL] import builtins [EOL] import typing [EOL] from json import JSONDecodeError [EOL] import typing [EOL] [EOL] from starlette . requests import Request as _Request , ClientDisconnect as _CD [EOL] [EOL] [EOL] ClientDisconnect = _CD [EOL] [EOL] [EOL] class Request ( _Request ) : [EOL] [docstring] [EOL] [EOL] async def json ( self ) : [EOL] [docstring] [EOL] try : [EOL] return await super ( ) . json ( ) [EOL] except JSONDecodeError : [EOL] from . errors import HTTPError [comment] [EOL] [EOL] raise HTTPError ( [number] , detail = [string] ) [EOL] [EOL] async def __aiter__ ( self ) : [EOL] async for chunk in self . stream ( ) : [EOL] yield chunk [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncGenerator[builtins.bytes,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Callable , Optional , List , Any , Type [EOL] import bocadillo [EOL] import typing [EOL] import converters [EOL] import os [EOL] import typing [EOL] [EOL] import typesystem [EOL] from starlette . middleware . cors import CORSMiddleware [EOL] from starlette . middleware . gzip import GZipMiddleware [EOL] from starlette . middleware . httpsredirect import HTTPSRedirectMiddleware [EOL] from starlette . middleware . trustedhost import TrustedHostMiddleware [EOL] [EOL] from . config import SettingsError , settings [EOL] from . constants import DEFAULT_CORS_CONFIG [EOL] from . converters import PathConversionError [EOL] from . errors import HTTPError [EOL] from . injection import STORE , discover_providers [EOL] from . staticfiles import static [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from . applications import App [EOL] [EOL] PluginFunction = typing . Callable [ [ [string] ] , None ] [EOL] [EOL] _BUILTIN_PLUGINS = [ ] [EOL] _MISSING = object ( ) [EOL] [EOL] [EOL] def _builtin ( func ) : [EOL] _BUILTIN_PLUGINS . append ( func ) [EOL] return func [EOL] [EOL] [EOL] @ _builtin def use_providers ( app ) : [EOL] [docstring] [EOL] modules = settings . get ( [string] ) [EOL] if not modules : [EOL] return [EOL] [EOL] discover_providers ( * modules ) [EOL] STORE . freeze ( ) [EOL] app . on ( [string] , STORE . enter_session ) [EOL] app . on ( [string] , STORE . exit_session ) [EOL] [EOL] [EOL] @ _builtin def use_allowed_hosts ( app ) : [EOL] [docstring] [EOL] allowed_hosts = settings . get ( [string] ) [EOL] if allowed_hosts is None : [EOL] allowed_hosts = [ [string] ] [EOL] [EOL] app . add_middleware ( TrustedHostMiddleware , allowed_hosts = allowed_hosts ) [EOL] [EOL] [EOL] @ _builtin def use_cors ( app ) : [EOL] [docstring] [EOL] cors = settings . get ( [string] ) [EOL] [EOL] if cors is None : [EOL] return [EOL] [EOL] if cors is True : [EOL] cors = dict ( DEFAULT_CORS_CONFIG ) [EOL] [EOL] app . add_middleware ( CORSMiddleware , ** cors ) [EOL] [EOL] [EOL] @ _builtin def use_gzip ( app ) : [EOL] [docstring] [EOL] if not settings . get ( [string] , False ) : [EOL] return [EOL] [EOL] gzip_min_size = settings . get ( [string] , [number] ) [EOL] app . add_middleware ( GZipMiddleware , minimum_size = gzip_min_size ) [EOL] [EOL] [EOL] @ _builtin def use_hsts ( app ) : [EOL] [docstring] [EOL] if not settings . get ( [string] ) : [EOL] return [EOL] [EOL] app . add_middleware ( HTTPSRedirectMiddleware ) [EOL] [EOL] [EOL] @ _builtin def use_sessions ( app ) : [EOL] [docstring] [EOL] sessions = settings . get ( [string] ) [EOL] [EOL] if sessions is None : [EOL] return [EOL] [EOL] try : [EOL] from starlette . middleware . sessions import SessionMiddleware [EOL] except ImportError as exc : [comment] [EOL] if [string] in str ( exc ) : [EOL] raise ImportError ( [string] [string] ) from exc [EOL] raise exc from None [EOL] [EOL] if sessions is True : [EOL] sessions = { [string] : os . getenv ( [string] ) } [EOL] [EOL] if not sessions . get ( [string] ) : [EOL] raise SettingsError ( [string] ) [EOL] [EOL] app . add_middleware ( SessionMiddleware , ** sessions ) [EOL] [EOL] [EOL] @ _builtin def use_staticfiles ( app ) : [EOL] [docstring] [EOL] static_root = settings . get ( [string] , [string] ) [EOL] static_dir = settings . get ( [string] , [string] ) [EOL] static_config = settings . get ( [string] , { } ) [EOL] [EOL] if static_dir is None : [EOL] return [EOL] [EOL] app . mount ( static_root , static ( static_dir , ** static_config ) ) [EOL] [EOL] [EOL] @ _builtin def use_path_conversion_error_handling ( app ) : [EOL] @ app . error_handler ( PathConversionError ) async def on_path_conversion_error ( req , res , exc ) : [EOL] raise HTTPError ( [number] , detail = dict ( exc ) ) [EOL] [EOL] [EOL] @ _builtin def use_typesystem_validation_error_handling ( app ) : [EOL] [docstring] [EOL] if not settings . get ( [string] , True ) : [EOL] return [EOL] [EOL] @ app . error_handler ( typesystem . ValidationError ) async def handle_validation_error ( req , res , exc ) : [EOL] res . status_code = [number] [EOL] res . json = HTTPError ( [number] , detail = dict ( exc ) ) . as_json ( ) [EOL] [EOL] [EOL] def setup_plugins ( app ) : [EOL] plugin_entries = _BUILTIN_PLUGINS + settings . get ( [string] , [ ] ) [EOL] for entry in plugin_entries : [EOL] if isinstance ( entry , dict ) : [EOL] for plugin_func , condition in entry . items ( ) : [EOL] if condition : [EOL] plugin_func ( app ) [EOL] else : [EOL] plugin_func = entry [EOL] plugin_func ( app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import multiprocessing [EOL] import builtins [EOL] import bocadillo [EOL] import starlette [EOL] import typing [EOL] import random [EOL] import sys [EOL] import typing [EOL] from multiprocessing import Event , Process [EOL] [EOL] import uvicorn [EOL] from starlette . testclient import TestClient [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from . applications import App [EOL] [EOL] try : [EOL] import pytest [EOL] except ImportError : [comment] [EOL] pytest = None [EOL] [EOL] [EOL] def create_client ( app , ** kwargs ) : [EOL] [docstring] [EOL] return TestClient ( app , ** kwargs ) [EOL] [EOL] [EOL] class ServerURL ( str ) : [EOL] def __call__ ( self , path ) : [EOL] return self + path [EOL] [EOL] [EOL] class LiveServer : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , app , ready_timeout = [number] , stop_timeout = [number] , ** kwargs , ) : [EOL] kwargs . setdefault ( [string] , [string] ) [EOL] kwargs . setdefault ( [string] , random . randint ( [number] , [number] ) ) [EOL] [EOL] self . app = app [EOL] self . kwargs = kwargs [EOL] self . ready_timeout = ready_timeout [EOL] self . stop_timeout = stop_timeout [EOL] self . _process = None [EOL] self . _ready = None [EOL] [EOL] @ property def url ( self ) : [EOL] host = self . kwargs [ [string] ] [EOL] port = self . kwargs [ [string] ] [EOL] return ServerURL ( f" [string] { host } [string] { port }" ) [EOL] [EOL] async def callback_notify ( self ) : [EOL] [comment] [EOL] self . _ready . set ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] if pytest is not None and sys . version_info >= ( [number] , [number] ) : [EOL] pytest . skip ( [string] ) [EOL] [EOL] self . _ready = Event ( ) [EOL] self . _process = Process ( target = uvicorn . run , args = ( self . app , ) , kwargs = { [string] : self . callback_notify , ** self . kwargs } , ) [EOL] self . _process . start ( ) [EOL] [EOL] if not self . _ready . wait ( self . ready_timeout ) : [comment] [EOL] raise TimeoutError ( f" [string] { self . ready_timeout } [string] " ) [EOL] [EOL] return self [EOL] [EOL] def __exit__ ( self , * args ) : [EOL] self . _process . terminate ( ) [EOL] self . _process . join ( self . stop_timeout ) [EOL] if self . _process . exitcode is None : [comment] [EOL] raise TimeoutError ( f" [string] { self . stop_timeout } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $multiprocessing.Process$ 0 0 0 0 0 $multiprocessing.Event$ 0 0 0 0 0 0 0 $ServerURL$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multiprocessing.context.Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multiprocessing.context.Process$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from aiodine import Store , scopes [EOL] [EOL] [comment] [EOL] STORE = Store ( scope_aliases = { [string] : scopes . FUNCTION , [string] : scopes . SESSION } , providers_module = [string] , default_scope = scopes . FUNCTION , ) [EOL] provider = STORE . provider [EOL] discover_providers = STORE . discover [EOL] useprovider = STORE . useprovider [EOL] consumer = STORE . consumer [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0
from . applications import App [EOL] from . compat import ExpectedAsync [EOL] from . config import SettingsError , configure , settings [EOL] from . errors import HTTPError [EOL] from . injection import discover_providers , provider , useprovider [EOL] from . middleware import Middleware [EOL] from . redirection import Redirect [EOL] from . request import ClientDisconnect , Request [EOL] from . response import Response [EOL] from . routing import Router [EOL] from . sse import server_event [EOL] from . staticfiles import static [EOL] from . templates import Templates [EOL] from . testing import LiveServer , create_client [EOL] from . websockets import WebSocket , WebSocketDisconnect [EOL] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Tuple , Any , Union [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] import jinja2 [EOL] import pathlib [EOL] import typing [EOL] from contextlib import contextmanager [EOL] [EOL] from jinja2 import Environment , FileSystemLoader , Template [EOL] [EOL] [EOL] class Templates : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , * args , directory = [string] , context = None ) : [EOL] if context is None : [EOL] context = { } [EOL] self . _directory = str ( directory ) [EOL] self . _environment = Environment ( loader = FileSystemLoader ( [ self . directory ] ) , autoescape = True ) [EOL] self . _environment . globals . update ( context ) [EOL] [EOL] @ property def directory ( self ) : [EOL] return self . _directory [EOL] [EOL] @ directory . setter def directory ( self , directory ) : [EOL] self . _directory = directory [EOL] self . _loader . searchpath = [ self . _directory ] [comment] [EOL] [EOL] @ property def context ( self ) : [EOL] return self . _environment . globals [EOL] [EOL] @ context . setter def context ( self , context ) : [EOL] self . _environment . globals = context [EOL] [EOL] @ property def _loader ( self ) : [EOL] return typing . cast ( FileSystemLoader , self . _environment . loader ) [EOL] [EOL] def _get_template ( self , name ) : [EOL] return self . _environment . get_template ( name ) [EOL] [EOL] @ contextmanager def _enable_async ( self ) : [EOL] [comment] [EOL] self . _environment . is_async = True [EOL] try : [EOL] yield [EOL] finally : [EOL] self . _environment . is_async = False [EOL] [EOL] async def render ( self , filename , * args , ** kwargs ) : [EOL] [docstring] [EOL] with self . _enable_async ( ) : [EOL] return await self . _get_template ( filename ) . render_async ( * args , ** kwargs ) [EOL] [EOL] def render_sync ( self , filename , * args , ** kwargs ) : [EOL] [docstring] [EOL] return self . _get_template ( filename ) . render ( * args , ** kwargs ) [EOL] [EOL] def render_string ( self , source , * args , ** kwargs ) : [EOL] [docstring] [EOL] template = self . _environment . from_string ( source = source ) [EOL] return template . render ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $jinja2.FileSystemLoader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.Template$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.dict$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.dict$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.dict$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.dict$ 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.dict$ 0 0 $typing.Any$ 0 0 0 0 0 $jinja2.environment.Template$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $jinja2.environment.Template$ 0 0 0 0 $builtins.dict$ 0 0 $typing.Any$ 0 0
from typing import Dict , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import typing [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from . applications import App [EOL] [EOL] [EOL] class SettingsError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Settings : [EOL] def __init__ ( self , obj ) : [EOL] for setting in dir ( obj ) : [EOL] if not setting . isupper ( ) or setting . startswith ( [string] ) : [EOL] continue [EOL] value = getattr ( obj , setting ) [EOL] setattr ( self , setting , value ) [EOL] [EOL] [EOL] class LazySettings : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _wrapped = None [EOL] [EOL] def configure ( self , obj = None , ** options ) : [EOL] if self . configured : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] wrapped = Settings ( obj ) [EOL] [EOL] for name , option in options . items ( ) : [EOL] assert name . isupper ( ) [EOL] setattr ( wrapped , name , option ) [EOL] [EOL] self . _wrapped = wrapped [EOL] [EOL] @ property def configured ( self ) : [EOL] return self . _wrapped is not None [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] if not self . configured : [EOL] raise SettingsError ( f" [string] { name } [string] " ) [EOL] [EOL] value = getattr ( self . _wrapped , name ) [EOL] [EOL] self . __dict__ [ name ] = value [comment] [EOL] [EOL] return value [EOL] [EOL] def __setattr__ ( self , name , value ) : [EOL] if name == [string] : [EOL] self . __dict__ . clear ( ) [EOL] else : [EOL] self . __dict__ . pop ( name , None ) [comment] [EOL] super ( ) . __setattr__ ( name , value ) [EOL] [EOL] def __contains__ ( self , name ) : [EOL] return name in self . __dict__ [EOL] [EOL] def get ( self , name , default = None ) : [EOL] return getattr ( self , name , default ) [EOL] [EOL] def _clear ( self ) : [EOL] self . _wrapped = None [EOL] [EOL] [EOL] settings = LazySettings ( ) [comment] [EOL] [EOL] [EOL] def configure ( app , settings_obj = None , ** kwargs ) : [EOL] [docstring] [EOL] from . plugins import setup_plugins [EOL] [EOL] if settings_obj is None : [EOL] settings_obj = kwargs . pop ( [string] , None ) [EOL] kwargs = { key . upper ( ) : value for key , value in kwargs . items ( ) } [EOL] settings . configure ( obj = settings_obj , ** kwargs ) [EOL] setup_plugins ( app ) [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.config.LazySettings$ 0 0 0 0 0 0 0 0 0 $"App"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.config.LazySettings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Optional , Tuple , List , Type [EOL] import compat [EOL] import app_types [EOL] import builtins [EOL] import bocadillo [EOL] import routing [EOL] import typing [EOL] import typing [EOL] [EOL] from . app_types import ASGIApp , ErrorHandler , EventHandler , Receive , Scope , Send [EOL] from . compat import WSGIApp , is_asgi3 [EOL] from . config import settings [EOL] from . contrib . pydocmd import DocsMeta [EOL] from . error_handlers import error_to_json , error_to_text [EOL] from . errors import HTTPError [EOL] from . injection import STORE [EOL] from . middleware import ( ExceptionMiddleware , RequestResponseMiddleware , ServerErrorMiddleware , ) [EOL] from . routing import Router [EOL] [EOL] [EOL] class App ( metaclass = DocsMeta ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name = None ) : [EOL] self . name = name [EOL] [EOL] self . router = Router ( ) [EOL] [EOL] self . _exception_middleware = ExceptionMiddleware ( self . router , handlers = { HTTPError : error_to_json } ) [EOL] self . _asgi = RequestResponseMiddleware ( ServerErrorMiddleware ( self . _exception_middleware , handler = error_to_text ) ) [EOL] [EOL] [comment] [EOL] @ self . on ( [string] ) async def check_app ( ) : [EOL] if not settings . configured : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] STORE . discover_default ( ) [EOL] [EOL] def include_router ( self , router , prefix = [string] ) : [EOL] [docstring] [EOL] return self . router . include ( router , prefix = prefix ) [EOL] [EOL] def mount ( self , prefix , app ) : [EOL] [docstring] [EOL] return self . router . mount ( prefix , app ) [EOL] [EOL] def route ( self , pattern , methods = None ) : [EOL] [docstring] [EOL] return self . router . route ( pattern , methods = methods ) [EOL] [EOL] def websocket_route ( self , pattern , * , auto_accept = True , value_type = None , receive_type = None , send_type = None , caught_close_codes = None , ) : [EOL] [docstring] [EOL] return self . router . websocket_route ( pattern , auto_accept = auto_accept , value_type = value_type , receive_type = receive_type , send_type = send_type , caught_close_codes = caught_close_codes , ) [EOL] [EOL] def add_error_handler ( self , exception_cls , handler ) : [EOL] [docstring] [EOL] self . _exception_middleware . add_exception_handler ( exception_cls , handler ) [EOL] [EOL] def error_handler ( self , exception_cls ) : [EOL] [docstring] [EOL] [EOL] def wrapper ( handler ) : [EOL] self . add_error_handler ( exception_cls , handler ) [EOL] return handler [EOL] [EOL] return wrapper [EOL] [EOL] def add_middleware ( self , middleware_cls , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] if not is_asgi3 ( middleware_cls ) : [EOL] raise ValueError ( f" [string] { middleware_cls . __name__ } [string] " [string] [string] ) [EOL] [EOL] self . _exception_middleware . app = middleware_cls ( self . _exception_middleware . app , ** kwargs ) [EOL] [EOL] def on ( self , event , handler = None ) : [EOL] [docstring] [EOL] return self . router . on ( event , handler = handler ) [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] await self . _asgi ( scope , receive , send ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $bocadillo.routing.Router$ 0 0 0 0 0 0 0 0 $bocadillo.middleware.ExceptionMiddleware$ 0 0 0 0 0 $bocadillo.routing.Router$ 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.middleware.RequestResponseMiddleware$ 0 0 0 0 0 0 0 $bocadillo.middleware.ExceptionMiddleware$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $routing.Router$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $routing.Router$ 0 0 0 $routing.Router$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Union["App",app_types.ASGIApp,compat.WSGIApp]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Union["App",app_types.ASGIApp,compat.WSGIApp]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Tuple[builtins.int]$ 0 $typing.Tuple[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.BaseException]$ 0 $app_types.ErrorHandler$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.BaseException]$ 0 $app_types.ErrorHandler$ 0 0 0 0 0 0 0 0 $typing.Type[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[app_types.EventHandler]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[app_types.EventHandler]$ 0 $typing.Optional[app_types.EventHandler]$ 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0
from typing import AsyncIterable , Callable , Any , Type [EOL] import builtins [EOL] import typing [EOL] import request [EOL] import typing [EOL] import inspect [EOL] [EOL] from . request import Request , ClientDisconnect [EOL] [EOL] Stream = typing . AsyncIterable [ typing . AnyStr ] [EOL] StreamFunc = typing . Callable [ [ ] , Stream ] [EOL] [EOL] [EOL] def stream_until_disconnect ( req , source , raise_on_disconnect ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] assert inspect . isasyncgen ( source ) [EOL] [EOL] async def stream ( ) : [EOL] async for item in source : [EOL] if not await req . is_disconnected ( ) : [EOL] yield item [EOL] continue [EOL] [EOL] if raise_on_disconnect : [EOL] try : [EOL] await source . athrow ( ClientDisconnect ) [EOL] except StopAsyncIteration : [EOL] [comment] [EOL] [comment] [EOL] break [EOL] else : [EOL] break [EOL] [EOL] return stream ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Stream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import compat [EOL] import builtins [EOL] from os . path import exists [EOL] [EOL] from whitenoise import WhiteNoise [EOL] [EOL] from . compat import WSGIApp , empty_wsgi_app [EOL] [EOL] [EOL] def static ( root , ** kwargs ) : [EOL] [docstring] [EOL] if exists ( root ) : [EOL] kwargs [ [string] ] = root [EOL] return WhiteNoise ( empty_wsgi_app ( ) , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $compat.WSGIApp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , TypeVar , Tuple , List , Any [EOL] import app_types [EOL] import builtins [EOL] import websockets [EOL] import bocadillo [EOL] import typing [EOL] import typing [EOL] [EOL] from starlette . datastructures import URL [EOL] from starlette . middleware . wsgi import WSGIMiddleware [EOL] from starlette . routing import Lifespan [EOL] from starlette . websockets import WebSocketClose [EOL] [EOL] from . app_types import ASGIApp , EventHandler , Receive , Scope , Send [EOL] from . config import settings [EOL] from . errors import HTTPError [EOL] from . redirection import Redirect [EOL] from . urlparse import Parser [EOL] from . views import View [EOL] from . websockets import WebSocket , WebSocketView [EOL] [EOL] _V = typing . TypeVar ( [string] ) [EOL] [EOL] [EOL] def _join ( prefix , path ) : [EOL] return prefix + path [EOL] [EOL] [EOL] class BaseRoute ( typing . Generic [ _V ] ) : [EOL] def matches ( self , scope ) : [EOL] raise NotImplementedError [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class Patterned ( typing . Generic [ _V ] ) : [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , pattern , view ) : [EOL] self . _parser = Parser ( pattern ) [EOL] self . view = view [EOL] [EOL] @ property def pattern ( self ) : [EOL] return self . _parser . pattern [EOL] [EOL] [EOL] class HTTPRoute ( BaseRoute , Patterned [ View ] ) : [EOL] def matches ( self , scope ) : [EOL] if scope [ [string] ] != [string] : [EOL] return False , { } [EOL] params = self . _parser . parse ( scope [ [string] ] ) [EOL] if params is None : [EOL] return False , { } [EOL] return True , { [string] : params } [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] req , res = scope [ [string] ] , scope [ [string] ] [EOL] await self . view ( req , res , ** scope [ [string] ] ) [EOL] [EOL] [EOL] class WebSocketRoute ( BaseRoute , Patterned [ WebSocketView ] ) : [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , pattern , view , ** kwargs ) : [EOL] super ( ) . __init__ ( pattern , view ) [EOL] self . ws_kwargs = kwargs [EOL] [EOL] def matches ( self , scope ) : [EOL] if scope [ [string] ] != [string] : [EOL] return False , { } [EOL] params = self . _parser . parse ( scope [ [string] ] ) [EOL] if params is None : [EOL] return False , { } [EOL] return True , { [string] : params } [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] ws = WebSocket ( scope , receive , send , ** self . ws_kwargs ) [EOL] await self . view ( ws , ** scope [ [string] ] ) [EOL] [EOL] [EOL] class Mount ( BaseRoute ) : [EOL] def __init__ ( self , path , app ) : [EOL] if not path . startswith ( [string] ) : [EOL] path = [string] + path [EOL] path = path . rstrip ( [string] ) [EOL] [EOL] self . app = app [EOL] self . path = path [EOL] self . _parser = Parser ( self . path + [string] ) [EOL] [EOL] def matches ( self , scope ) : [EOL] path = scope [ [string] ] [EOL] [EOL] if path == self . path + [string] : [EOL] params = { [string] : [string] } [EOL] else : [EOL] params = self . _parser . parse ( path ) [EOL] [EOL] if params is not None : [EOL] remaining_path = [string] + params [ [string] ] [EOL] matched_path = path [ : - len ( remaining_path ) ] [EOL] child_scope = { [string] : remaining_path , [string] : scope . get ( [string] , [string] ) + matched_path , } [EOL] return True , child_scope [EOL] [EOL] return False , { } [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] try : [EOL] await self . app ( scope , receive , send ) [EOL] except TypeError : [EOL] app = WSGIMiddleware ( self . app ) [EOL] await app ( scope , receive , send ) [EOL] [EOL] [EOL] class Router : [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . routes = [ ] [EOL] self . lifespan = Lifespan ( ) [EOL] [EOL] def add_route ( self , route ) : [EOL] self . routes . append ( route ) [EOL] [EOL] def include ( self , other , prefix = [string] ) : [EOL] [docstring] [EOL] for route in other . routes : [EOL] assert isinstance ( route , ( HTTPRoute , WebSocketRoute , Mount ) ) [EOL] if prefix : [EOL] if isinstance ( route , HTTPRoute ) : [EOL] route = HTTPRoute ( pattern = _join ( prefix , route . pattern ) , view = route . view ) [EOL] elif isinstance ( route , WebSocketRoute ) : [EOL] route = WebSocketRoute ( pattern = _join ( prefix , route . pattern ) , view = route . view , ** route . ws_kwargs , ) [EOL] else : [EOL] route = Mount ( path = _join ( prefix , route . path ) , app = route . app ) [EOL] self . add_route ( route ) [EOL] [EOL] def mount ( self , path , app ) : [EOL] [docstring] [EOL] return self . add_route ( Mount ( path , app ) ) [EOL] [EOL] def on ( self , event , handler = None ) : [EOL] if handler is None : [EOL] [EOL] def register ( func ) : [EOL] self . lifespan . add_event_handler ( event , func ) [EOL] return func [EOL] [EOL] return register [EOL] [EOL] self . lifespan . add_event_handler ( event , handler ) [EOL] return handler [EOL] [EOL] def route ( self , pattern , methods = None ) : [EOL] [docstring] [EOL] [EOL] def decorate ( view ) : [EOL] view = View ( view , methods = methods ) [EOL] route = HTTPRoute ( pattern , view ) [EOL] self . add_route ( route ) [EOL] return route [EOL] [EOL] return decorate [EOL] [EOL] def websocket_route ( self , pattern , * , auto_accept = True , value_type = None , receive_type = None , send_type = None , caught_close_codes = None , ) : [EOL] [docstring] [EOL] [EOL] def decorate ( view ) : [EOL] view = WebSocketView ( view ) [EOL] route = WebSocketRoute ( pattern , view , auto_accept = auto_accept , value_type = value_type , receive_type = receive_type , send_type = send_type , caught_close_codes = caught_close_codes , ) [EOL] self . add_route ( route ) [EOL] return route [EOL] [EOL] return decorate [EOL] [EOL] def _find_route ( self , scope ) : [EOL] for route in self . routes : [EOL] matches , child_scope = route . matches ( scope ) [EOL] if matches : [EOL] scope . update ( child_scope ) [EOL] return route [EOL] return None [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] scope [ [string] ] = send [comment] [EOL] [EOL] if scope [ [string] ] == [string] : [EOL] await self . lifespan ( scope , receive , send ) [EOL] return [EOL] [EOL] route = self . _find_route ( scope ) [EOL] [EOL] if route is not None : [EOL] try : [EOL] await route ( scope , receive , send ) [EOL] return [EOL] except Redirect as exc : [EOL] scope [ [string] ] = exc . response [EOL] return [EOL] [EOL] try_http_redirect = ( scope [ [string] ] == [string] [EOL] and not scope [ [string] ] . endswith ( [string] ) [EOL] and redirect_trailing_slash_enabled ( ) ) [EOL] [EOL] if try_http_redirect : [EOL] redirect_scope = dict ( scope ) [EOL] redirect_scope [ [string] ] += [string] [EOL] route = self . _find_route ( redirect_scope ) [EOL] if route is not None : [EOL] redirect_url = URL ( scope = redirect_scope ) [EOL] scope [ [string] ] = Redirect ( str ( redirect_url ) ) . response [EOL] return [EOL] [EOL] if scope [ [string] ] == [string] : [EOL] await WebSocketClose ( code = [number] ) ( receive , send ) [EOL] return [EOL] [EOL] raise HTTPError ( [number] ) [EOL] [EOL] [EOL] def redirect_trailing_slash_enabled ( ) : [EOL] return settings . get ( [string] , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Variable[bocadillo.routing._V]$ 0 0 0 0 0 $bocadillo.urlparse.Parser$ 0 0 0 0 0 0 0 0 $Variable[bocadillo.routing._V]$ 0 $Variable[bocadillo.routing._V]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bool,app_types.Scope]$ 0 0 0 $app_types.Scope$ 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $websockets.WebSocketView$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $websockets.WebSocketView$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bool,app_types.Scope]$ 0 0 0 $app_types.Scope$ 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 $bocadillo.websockets.WebSocket$ 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.websockets.WebSocket$ 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $bocadillo.app_types.ASGIApp$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $bocadillo.app_types.ASGIApp$ 0 $bocadillo.app_types.ASGIApp$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $bocadillo.urlparse.Parser$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Tuple[builtins.bool,builtins.dict]$ 0 0 0 $builtins.dict$ 0 0 0 $typing.Any$ 0 $builtins.dict$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[BaseRoute]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $BaseRoute$ 0 0 0 0 0 0 0 0 0 $BaseRoute$ 0 0 0 0 0 0 0 0 $"Router"$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $bocadillo.routing.Mount$ 0 $"Router"$ 0 0 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 0 $builtins.str$ 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 0 $builtins.str$ 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 0 $builtins.str$ 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 0 0 $bocadillo.routing.Mount$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $app_types.ASGIApp$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $app_types.ASGIApp$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[app_types.EventHandler]$ 0 0 0 0 0 0 $typing.Optional[app_types.EventHandler]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[app_types.EventHandler]$ 0 0 0 $typing.Optional[app_types.EventHandler]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $WebSocketRoute$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $bocadillo.routing.WebSocketRoute$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $bocadillo.routing.WebSocketRoute$ 0 0 0 $bocadillo.routing.WebSocketRoute$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $WebSocketRoute$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $bocadillo.routing.WebSocketRoute$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.routing.WebSocketRoute$ 0 0 0 $bocadillo.routing.WebSocketRoute$ 0 0 0 0 0 0 0 $typing.Optional[BaseRoute]$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 $app_types.Scope$ 0 0 0 0 $app_types.Send$ 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 0 0 $typing.Optional[bocadillo.routing.BaseRoute[typing.Any]]$ 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 $typing.Optional[bocadillo.routing.BaseRoute[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[bocadillo.routing.BaseRoute[typing.Any]]$ 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $app_types.Scope$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Optional[bocadillo.routing.BaseRoute[typing.Any]]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Optional[bocadillo.routing.BaseRoute[typing.Any]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $app_types.Scope$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import os [EOL] from contextlib import contextmanager [EOL] [EOL] [EOL] @ contextmanager def override_env ( variable , value ) : [EOL] [docstring] [EOL] initial = os . environ . get ( variable , None ) [EOL] os . environ [ variable ] = value [EOL] try : [EOL] yield [EOL] finally : [EOL] os . environ . pop ( variable ) [EOL] if initial is not None : [EOL] os . environ [ variable ] = initial [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Tuple , Any , Pattern [EOL] import builtins [EOL] import typing [EOL] import re [EOL] import typing [EOL] [EOL] PARAM_RE = re . compile ( [string] ) [EOL] WILDCARD = [string] [EOL] [EOL] CONVERTER_PATTERNS = { [string] : [string] } [EOL] [EOL] [EOL] def convert_part ( name , converter ) : [EOL] try : [EOL] return CONVERTER_PATTERNS [ converter ] [EOL] except KeyError as exc : [EOL] raise TypeError ( f" [string] { converter } [string] " f" [string] { name } [string] " f" [string] { [string] . join ( CONVERTER_PATTERNS ) }" ) from exc [EOL] [EOL] [EOL] def compile_path ( pattern ) : [EOL] regex = [string] [EOL] path_format = [string] [EOL] idx = [number] [EOL] [EOL] for match in PARAM_RE . finditer ( pattern ) : [EOL] declaration , = match . groups ( default = [string] ) [EOL] name , sep , converter = declaration . partition ( [string] ) [EOL] has_converter = sep == [string] [EOL] [EOL] regex += pattern [ idx : match . start ( ) ] [EOL] if not name : [EOL] expr = [string] [EOL] else : [EOL] part = convert_part ( name , converter ) if has_converter else [string] [EOL] expr = rf" [string] { name } [string] { part }" [EOL] regex += rf" [string] { expr } [string] " [EOL] [EOL] path_format += pattern [ idx : match . start ( ) ] [EOL] path_format += [string] % name [EOL] [EOL] idx = match . end ( ) [EOL] [EOL] regex += pattern [ idx : ] + [string] [EOL] path_format += pattern [ idx : ] [EOL] [EOL] return re . compile ( regex ) , path_format [EOL] [EOL] [EOL] class Parser : [EOL] def __init__ ( self , pattern ) : [EOL] if pattern != WILDCARD and not pattern . startswith ( [string] ) : [EOL] pattern = f" [string] { pattern }" [EOL] self . regex , self . pattern = compile_path ( pattern ) [EOL] [EOL] def parse ( self , value ) : [EOL] match = self . regex . match ( value ) [EOL] if match is None : [EOL] return None [EOL] return match . groupdict ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Pattern,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.dict]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Union , Literal , Callable , Tuple , Any [EOL] import app_types [EOL] import builtins [EOL] import bocadillo [EOL] import typing_extensions [EOL] import typing [EOL] import traceback [EOL] import typing [EOL] [EOL] import typesystem [EOL] from starlette . datastructures import URL , Headers , QueryParams [EOL] from starlette . websockets import WebSocket as StarletteWebSocket [EOL] from starlette . websockets import WebSocketDisconnect as _WebSocketDisconnect [EOL] [EOL] from . app_types import Event , Receive , Scope , Send [EOL] from . compat import asyncnullcontext , check_async [EOL] from . constants import WEBSOCKET_CLOSE_CODES [EOL] from . converters import ViewConverter , convert_arguments [EOL] from . injection import consumer [EOL] [EOL] [EOL] class WebSocket : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] __default_receive_type__ = [string] [EOL] __default_send_type__ = [string] [EOL] [EOL] url = ... [EOL] headers = ... [EOL] query_params = ... [EOL] [EOL] def __init__ ( self , scope , receive , send , auto_accept = True , value_type = None , receive_type = None , send_type = None , caught_close_codes = None , ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _ws = StarletteWebSocket ( scope , receive = receive , send = send ) [EOL] [EOL] if caught_close_codes is None : [EOL] caught_close_codes = ( [number] , [number] ) [EOL] if caught_close_codes is all : [EOL] caught_close_codes = tuple ( WEBSOCKET_CLOSE_CODES ) [EOL] self . caught_close_codes = caught_close_codes [EOL] [EOL] self . auto_accept = auto_accept [EOL] self . __accepted = False [EOL] [EOL] if value_type is not None : [EOL] receive_type = send_type = value_type [EOL] else : [EOL] receive_type = receive_type or self . __default_receive_type__ [EOL] send_type = send_type or self . __default_send_type__ [EOL] [EOL] self . receive_type = receive_type [EOL] self . send_type = send_type [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return getattr ( self . _ws , name ) [EOL] [EOL] [comment] [EOL] [EOL] async def accept ( self , subprotocol = None ) : [EOL] [docstring] [EOL] return await self . _ws . accept ( subprotocol = subprotocol ) [EOL] [EOL] async def reject ( self ) : [EOL] [docstring] [EOL] return await self . close ( code = [number] ) [EOL] [EOL] async def close ( self , code = [number] ) : [EOL] [docstring] [EOL] return await self . _ws . close ( code = code ) [EOL] [EOL] async def ensure_closed ( self , code = [number] ) : [EOL] [docstring] [EOL] try : [EOL] await self . close ( code = code ) [EOL] except RuntimeError : [EOL] [comment] [EOL] pass [EOL] [EOL] [comment] [EOL] [EOL] async def receive_text ( self ) : [EOL] [docstring] [EOL] return await self . _ws . receive_text ( ) [EOL] [EOL] async def send_text ( self , data ) : [EOL] [docstring] [EOL] return await self . _ws . send_text ( data ) [EOL] [EOL] async def receive_bytes ( self ) : [EOL] [docstring] [EOL] return await self . _ws . receive_bytes ( ) [EOL] [EOL] async def send_bytes ( self , data ) : [EOL] [docstring] [EOL] return await self . _ws . send_bytes ( data ) [EOL] [EOL] async def receive_json ( self ) : [EOL] [docstring] [EOL] return await self . _ws . receive_json ( ) [EOL] [EOL] async def send_json ( self , data ) : [EOL] [docstring] [EOL] return await self . _ws . send_json ( data ) [EOL] [EOL] async def receive_event ( self ) : [EOL] [docstring] [EOL] return await self . _ws . receive ( ) [EOL] [EOL] async def send_event ( self , event ) : [EOL] [docstring] [EOL] return await self . _ws . send ( event ) [EOL] [EOL] async def receive ( self ) : [EOL] [docstring] [EOL] receiver = getattr ( self , f" [string] { self . receive_type }" ) [EOL] return await receiver ( ) [EOL] [EOL] async def send ( self , message ) : [EOL] [docstring] [EOL] sender = getattr ( self , f" [string] { self . send_type }" ) [EOL] return await sender ( message ) [EOL] [EOL] [comment] [EOL] [EOL] async def __aenter__ ( self , * args , ** kwargs ) : [EOL] if not self . __accepted : [EOL] await self . accept ( ) [EOL] self . __accepted = True [EOL] return self [EOL] [EOL] async def __aexit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] if exc_type == WebSocketDisconnect : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return exc_val . code in self . caught_close_codes [EOL] [EOL] [comment] [EOL] code = [number] if exc_type is None else [number] [EOL] [comment] [EOL] [comment] [EOL] await self . ensure_closed ( code ) [EOL] [EOL] [comment] [EOL] [EOL] async def __aiter__ ( self ) : [EOL] while True : [EOL] yield await self . receive ( ) [EOL] [EOL] [EOL] class WebSocketConverter ( ViewConverter ) : [EOL] def get_query_params ( self , args , kwargs ) : [EOL] ws = args [ [number] ] [EOL] return ws . query_params [EOL] [EOL] [EOL] class WebSocketView : [EOL] [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , func ) : [EOL] check_async ( func , reason = f" [string] { func . __name__ } [string] " , ) [EOL] func = convert_arguments ( func , converter_class = WebSocketConverter ) [EOL] func = consumer ( func ) [EOL] self . func = func [EOL] [EOL] async def __call__ ( self , ws , ** params ) : [EOL] context = ws if ws . auto_accept else asyncnullcontext ( ) [EOL] try : [EOL] async with context : [EOL] try : [EOL] await self . func ( ws , ** params ) [comment] [EOL] except typesystem . ValidationError : [EOL] await ws . ensure_closed ( [number] ) [EOL] traceback . print_exc ( ) [EOL] except BaseException : [EOL] traceback . print_exc ( ) [EOL] await ws . ensure_closed ( [number] ) [EOL] raise [EOL] [EOL] [EOL] WebSocketDisconnect = _WebSocketDisconnect [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $starlette.datastructures.URL$ 0 0 0 $starlette.datastructures.Headers$ 0 0 0 $starlette.datastructures.QueryParams$ 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 $app_types.Send$ 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Union[builtins.dict,builtins.list]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.dict,builtins.list]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.dict,builtins.list]$ 0 0 0 0 0 $app_types.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app_types.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $app_types.Event$ 0 0 0 0 0 $typing.Union[builtins.str,builtins.bytes,builtins.list,builtins.dict]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.tuple$ 0 $builtins.dict$ 0 0 0 $WebSocket$ 0 $builtins.tuple$ 0 0 0 0 0 $WebSocket$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 $WebSocket$ 0 0 0 0 0 0 $typing.Union[bocadillo.compat.asyncnullcontext,bocadillo.websockets.WebSocket]$ 0 $WebSocket$ 0 $WebSocket$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[bocadillo.compat.asyncnullcontext,bocadillo.websockets.WebSocket]$ 0 0 0 0 0 0 0 0 0 0 $WebSocket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $WebSocket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $WebSocket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , TypeVar , Tuple , List , Any , Type [EOL] import inspect [EOL] import typing [EOL] import builtins [EOL] import inspect [EOL] import typing [EOL] [EOL] try : [EOL] [comment] [EOL] from contextlib import nullcontext [comment] [EOL] except ImportError : [comment] [EOL] from contextlib import contextmanager [EOL] [EOL] @ contextmanager def nullcontext ( enter_result = None ) : [EOL] yield enter_result [EOL] [EOL] [EOL] _V = typing . TypeVar ( [string] ) [EOL] [EOL] [EOL] class ExpectedAsync ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] def check_async ( func , reason ) : [EOL] if not inspect . iscoroutinefunction ( func ) : [EOL] message = f"{ reason } [string] " [EOL] raise ExpectedAsync ( message ) [EOL] [EOL] [EOL] def is_asgi3 ( app ) : [EOL] sig = inspect . signature ( app . __call__ ) [EOL] return [string] in sig . parameters or [string] in sig . parameters [EOL] [EOL] [EOL] [comment] [EOL] class asyncnullcontext : [EOL] def __init__ ( self , enter_result = None ) : [EOL] self . _result = enter_result [EOL] [EOL] async def __aenter__ ( self ) : [EOL] return self . _result [EOL] [EOL] async def __aexit__ ( self , * args ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [EOL] Environ = dict [EOL] StartResponse = typing . Callable [ [ str , typing . List [ str ] ] , None ] [EOL] WSGIApp = typing . Callable [ [ Environ , StartResponse ] , typing . List [ bytes ] ] [EOL] [EOL] [EOL] def empty_wsgi_app ( ) : [EOL] [docstring] [EOL] [EOL] def wsgi ( environ , start_response ) : [EOL] status = [string] [EOL] body = [string] [EOL] headers = [ ( [string] , [string] ) ] [EOL] start_response ( status , headers ) [EOL] return [ body ] [EOL] [EOL] return wsgi [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $WSGIApp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Optional [EOL] import errors [EOL] import typing [EOL] import request [EOL] import response [EOL] from . request import Request [EOL] from . response import Response [EOL] from . errors import HTTPError [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] async def error_to_html ( req , res , exc ) : [EOL] [docstring] [EOL] res . status_code = exc . status_code [EOL] html = f" [string] { exc . title } [string] " [EOL] if exc . detail : [EOL] html += f" [string] { exc . detail } [string] " [EOL] res . html = html [EOL] [EOL] [EOL] async def error_to_json ( req , res , exc ) : [EOL] [docstring] [EOL] res . status_code = exc . status_code [EOL] res . json = exc . as_json ( ) [EOL] [EOL] [EOL] async def error_to_text ( req , res , exc ) : [EOL] [docstring] [EOL] res . status_code = exc . status_code [EOL] text = exc . title [EOL] if exc . detail : [EOL] text += f" [string] { exc . detail }" [EOL] res . text = text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Sequence , Tuple , List , Any [EOL] import builtins [EOL] import typing [EOL] from json import dumps [EOL] import typing [EOL] [EOL] [EOL] class server_event ( str ) : [EOL] [docstring] [EOL] [EOL] def __new__ ( cls , name = None , * , data = None , json = None , id = None , ) : [EOL] if json is not None : [EOL] data = dumps ( json ) [EOL] [EOL] parts = [ ( [string] , id ) , ( [string] , name ) ] [EOL] [EOL] if isinstance ( data , str ) : [EOL] parts . append ( ( [string] , data ) ) [EOL] elif data is not None : [EOL] for item in data : [EOL] parts . append ( ( [string] , item ) ) [EOL] [EOL] sse_message = ( [string] . join ( f"{ field } [string] { value }" for field , value in parts if value is not None ) + [string] ) [EOL] [EOL] return super ( ) . __new__ ( cls , sse_message ) [EOL] [EOL] [comment] [EOL] def __init__ ( self , name = None , * , data = None , json = None , id = None , ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Sequence[typing.Any],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Sequence[typing.Any],builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Sequence[typing.Any],builtins.str]$ 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 $typing.Union[typing.Sequence[typing.Any],builtins.str]$ 0 0 0 0 $typing.Union[typing.Sequence[typing.Any],builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Union[typing.Sequence[typing.Any],builtins.str]$ 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[builtins.str,typing.Sequence]$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0
from typing import Dict , Awaitable , Callable , Optional , Tuple , Any , Type [EOL] import app_types [EOL] import builtins [EOL] import bocadillo [EOL] import request [EOL] import response [EOL] import typing [EOL] import typing [EOL] [EOL] from . app_types import ASGIApp , ErrorHandler , Receive , Scope , Send [EOL] from . compat import check_async [EOL] from . errors import HTTPError [EOL] from . request import Request [EOL] from . response import Response [EOL] [EOL] if typing . TYPE_CHECKING : [comment] [EOL] from . applications import App [EOL] [EOL] [EOL] class MiddlewareMeta ( type ) : [EOL] def __new__ ( mcs , name , bases , namespace ) : [EOL] cls = super ( ) . __new__ ( mcs , name , bases , namespace ) [EOL] for callback in [string] , [string] : [EOL] check_async ( getattr ( cls , callback ) , reason = [string] , ) [EOL] return cls [EOL] [EOL] [EOL] class Middleware ( metaclass = MiddlewareMeta ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , inner ) : [EOL] self . inner = inner [EOL] [EOL] async def before_dispatch ( self , req , res ) : [EOL] [docstring] [EOL] [EOL] async def after_dispatch ( self , req , res ) : [EOL] [docstring] [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] assert scope [ [string] ] == [string] [EOL] [EOL] req , res = scope [ [string] ] , scope [ [string] ] [EOL] [EOL] before_res = await self . before_dispatch ( req , res ) [EOL] [EOL] if before_res is not None : [EOL] scope [ [string] ] = before_res [EOL] return [EOL] [EOL] await self . inner ( scope , receive , send ) [EOL] await self . after_dispatch ( req , res ) [EOL] [EOL] [EOL] class ExceptionMiddleware : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , app , handlers , ) : [EOL] self . app = app [EOL] self . _exception_handlers = handlers [EOL] [EOL] def add_exception_handler ( self , exception_class , handler ) : [EOL] assert issubclass ( exception_class , BaseException ) , f" [string] { type ( exception_class ) }" [EOL] check_async ( handler , reason = f" [string] { handler . __name__ } [string] " , ) [EOL] self . _exception_handlers [ exception_class ] = handler [EOL] [EOL] def _get_exception_handler ( self , exc ) : [EOL] try : [EOL] return self . _exception_handlers [ type ( exc ) ] [EOL] except KeyError : [EOL] for cls , handler in self . _exception_handlers . items ( ) : [EOL] if isinstance ( exc , cls ) : [EOL] return handler [EOL] return None [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] try : [EOL] await self . app ( scope , receive , send ) [EOL] except BaseException as exc : [comment] [EOL] if scope [ [string] ] != [string] : [EOL] raise exc from None [EOL] [EOL] req , res = scope [ [string] ] , scope [ [string] ] [EOL] [EOL] while exc is not None : [EOL] handler = self . _get_exception_handler ( exc ) [EOL] if handler is None : [EOL] raise exc from None [EOL] try : [EOL] await handler ( req , res , exc ) [EOL] except BaseException as sub_exc : [comment] [EOL] exc = sub_exc [EOL] else : [EOL] exc = None [EOL] [EOL] [EOL] class ServerErrorMiddleware : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , app , handler ) : [EOL] self . app = app [EOL] self . handler = handler [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] try : [EOL] await self . app ( scope , receive , send ) [EOL] except BaseException as exc : [EOL] if scope [ [string] ] != [string] : [EOL] raise exc from None [EOL] req , res = scope [ [string] ] , scope [ [string] ] [EOL] await self . handler ( req , res , HTTPError ( [number] ) ) [EOL] raise exc from None [EOL] [EOL] [EOL] class RequestResponseMiddleware : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , app ) : [EOL] self . app = app [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] if scope [ [string] ] != [string] : [EOL] await self . app ( scope , receive , send ) [EOL] return [EOL] [EOL] response_started = False [EOL] [EOL] async def sentinel_send ( message ) : [EOL] nonlocal response_started [EOL] if message [ [string] ] == [string] : [EOL] response_started = True [EOL] await send ( message ) [EOL] [EOL] req = Request ( scope , receive ) [EOL] scope [ [string] ] = req [EOL] scope [ [string] ] = Response ( req ) [EOL] [EOL] try : [EOL] await self . app ( scope , receive , sentinel_send ) [EOL] finally : [EOL] if not response_started : [EOL] res = scope [ [string] ] [EOL] refreshed_send = scope . get ( [string] , send ) [EOL] await res ( scope , receive , refreshed_send ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[response.Response]$ 0 0 0 $request.Request$ 0 $response.Response$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $request.Request$ 0 $response.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 $app_types.Scope$ 0 0 0 0 0 $typing.Optional[bocadillo.response.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[bocadillo.response.Response]$ 0 0 0 0 0 $app_types.Scope$ 0 0 0 0 $typing.Optional[bocadillo.response.Response]$ 0 0 0 0 0 0 0 0 0 $app_types.Scope$ 0 $app_types.Receive$ 0 $app_types.Send$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $bocadillo.app_types.ASGIApp$ 0 $typing.Dict[typing.Type[builtins.BaseException],app_types.ErrorHandler]$ 0 0 0 0 0 0 $bocadillo.app_types.ASGIApp$ 0 $bocadillo.app_types.ASGIApp$ 0 0 0 $typing.Dict[typing.Type[builtins.BaseException],typing.Callable[[bocadillo.request.Request,bocadillo.response.Response,builtins.BaseException],typing.Awaitable[None]]]$ 0 $typing.Dict[typing.Type[builtins.BaseException],app_types.ErrorHandler]$ 0 0 0 $None$ 0 0 0 $typing.Type[builtins.BaseException]$ 0 $app_types.ErrorHandler$ 0 0 0 0 0 0 $typing.Type[builtins.BaseException]$ 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.BaseException]$ 0 0 0 0 0 $app_types.ErrorHandler$ 0 0 0 0 0 0 $app_types.ErrorHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.BaseException]$ 0 0 $app_types.ErrorHandler$ 0 0 0 $typing.Optional[app_types.ErrorHandler]$ 0 0 0 $builtins.BaseException$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.BaseException$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.BaseException$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Optional[typing.Callable[[bocadillo.request.Request,bocadillo.response.Response,builtins.BaseException],typing.Awaitable[None]]]$ 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Callable[[bocadillo.request.Request,bocadillo.response.Response,builtins.BaseException],typing.Awaitable[None]]]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[typing.Callable[[bocadillo.request.Request,bocadillo.response.Response,builtins.BaseException],typing.Awaitable[None]]]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $bocadillo.app_types.ASGIApp$ 0 $typing.Callable[[bocadillo.request.Request,bocadillo.response.Response,builtins.BaseException],typing.Awaitable[None]]$ 0 0 0 0 0 $bocadillo.app_types.ASGIApp$ 0 $bocadillo.app_types.ASGIApp$ 0 0 0 $typing.Callable[[bocadillo.request.Request,bocadillo.response.Response,builtins.BaseException],typing.Awaitable[None]]$ 0 $typing.Callable[[bocadillo.request.Request,bocadillo.response.Response,builtins.BaseException],typing.Awaitable[None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $builtins.str$ 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $bocadillo.request.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.request.Request$ 0 0 0 0 0 0 0 0 $bocadillo.request.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0
from typing import Tuple [EOL] import starlette [EOL] import builtins [EOL] import typing [EOL] from starlette . responses import RedirectResponse [EOL] [EOL] [EOL] class Redirect ( Exception ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , url , permanent = False ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _url = url [EOL] self . _permanent = permanent [EOL] [EOL] @ property def status_code ( self ) : [EOL] return [number] if self . _permanent else [number] [EOL] [EOL] @ property def response ( self ) : [EOL] return RedirectResponse ( url = self . _url , status_code = self . status_code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $starlette.responses.RedirectResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Tuple , List , Any [EOL] import builtins [EOL] import typing [EOL] import typing [EOL] [EOL] ALL_HTTP_METHODS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] DEFAULT_CORS_CONFIG = { [string] : [ ] , [string] : [ [string] ] } [EOL] [EOL] [comment] [EOL] WEBSOCKET_CLOSE_CODES = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , } [EOL] [EOL] [EOL] class CONTENT_TYPE : [EOL] PLAIN_TEXT = [string] [EOL] HTML = [string] [EOL] JSON = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Tuple , Any , Union [EOL] import builtins [EOL] import typing [EOL] import http [EOL] from http import HTTPStatus [EOL] import typing [EOL] [EOL] [EOL] class HTTPError ( Exception ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , status , detail = [string] ) : [EOL] if isinstance ( status , int ) : [EOL] status = HTTPStatus ( status ) [EOL] else : [EOL] assert isinstance ( status , HTTPStatus ) , f" [string] { type ( status ) }" [EOL] self . _status = status [EOL] self . detail = detail [EOL] [EOL] @ property def status_code ( self ) : [EOL] [docstring] [EOL] return self . _status . value [EOL] [EOL] @ property def status_phrase ( self ) : [EOL] [docstring] [EOL] return self . _status . phrase [EOL] [EOL] @ property def title ( self ) : [EOL] [docstring] [EOL] return f"{ self . status_code } [string] { self . status_phrase }" [EOL] [EOL] def as_json ( self ) : [EOL] data = { [string] : self . title , [string] : self . status_code } [EOL] if self . detail : [EOL] data [ [string] ] = self . detail [EOL] return data [EOL] [EOL] def __str__ ( self ) : [EOL] return self . title [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , Tuple , List , Any , Type [EOL] import builtins [EOL] import typing [EOL] import inspect [EOL] import typing [EOL] [EOL] from . import injection [EOL] from . app_types import Handler [EOL] from . compat import check_async [EOL] from . constants import ALL_HTTP_METHODS [EOL] from . converters import ViewConverter , convert_arguments [EOL] from . errors import HTTPError [EOL] [EOL] MethodsParam = typing . Union [ typing . List [ str ] , all ] [comment] [EOL] [EOL] [EOL] class HandlerDoesNotExist ( Exception ) : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] class HTTPConverter ( ViewConverter ) : [EOL] def get_query_params ( self , args , kwargs ) : [EOL] req = args [ [number] ] [EOL] return req . query_params [EOL] [EOL] [EOL] def get_handlers ( obj ) : [EOL] if hasattr ( obj , [string] ) : [EOL] return { method : obj . handle for method in ALL_HTTP_METHODS } [EOL] return { method : getattr ( obj , method ) for method in ALL_HTTP_METHODS if hasattr ( obj , method ) } [EOL] [EOL] [EOL] class View : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] get = ... [EOL] post = ... [EOL] put = ... [EOL] patch = ... [EOL] delete = ... [EOL] head = ... [EOL] options = ... [EOL] handle = ... [EOL] [EOL] def __init__ ( self , obj , methods = None ) : [EOL] if isinstance ( obj , View ) : [EOL] raise NotImplementedError [EOL] if inspect . isclass ( obj ) : [EOL] [comment] [EOL] name = obj . __name__ [EOL] class_based = True [EOL] handlers = get_handlers ( obj ( ) ) [EOL] elif callable ( obj ) : [EOL] [comment] [EOL] name = obj . __name__ [EOL] class_based = False [EOL] if methods is None : [EOL] methods = [ [string] ] [EOL] if methods is all : [EOL] methods = [ [string] ] [EOL] else : [EOL] methods = [ m . lower ( ) for m in methods ] [EOL] handlers = { method : obj for method in methods } [EOL] else : [EOL] [comment] [EOL] name = obj . __class__ . __name__ [EOL] class_based = True [EOL] handlers = get_handlers ( obj ) [EOL] [EOL] for method , handler in handlers . items ( ) : [EOL] full_name = f"{ name } [string] { method . lower ( ) }" if class_based else name [EOL] check_async ( handler , reason = ( f" [string] { full_name } [string] " ) ) [EOL] [EOL] copy_get_to_head = [string] in handlers and [string] not in handlers [EOL] if copy_get_to_head : [EOL] handlers [ [string] ] = handlers [ [string] ] [EOL] [EOL] for method , handler in handlers . items ( ) : [EOL] handler = convert_arguments ( handler , converter_class = HTTPConverter ) [EOL] handler = injection . consumer ( handler ) [EOL] setattr ( self , method , handler ) [EOL] [EOL] async def __call__ ( self , req , res , ** params ) : [EOL] try : [EOL] handler = getattr ( self , [string] ) [EOL] except AttributeError : [EOL] try : [EOL] handler = getattr ( self , req . method . lower ( ) ) [EOL] except AttributeError : [EOL] raise HTTPError ( [number] ) [EOL] await handler ( req , res , ** params ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app_types.Handler$ 0 0 0 $app_types.Handler$ 0 0 0 $app_types.Handler$ 0 0 0 $app_types.Handler$ 0 0 0 $app_types.Handler$ 0 0 0 $app_types.Handler$ 0 0 0 $app_types.Handler$ 0 0 0 $app_types.Handler$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import typing [EOL] class DocsMeta ( type ) : [comment] [EOL] [docstring] [EOL] [EOL] def __new__ ( mcs , name , bases , namespace ) : [EOL] mcs . _prepare_for_docs ( bases , namespace ) [EOL] cls = super ( ) . __new__ ( mcs , name , bases , namespace ) [EOL] return cls [EOL] [EOL] @ classmethod def _prepare_for_docs ( mcs , bases , namespace ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for base in bases : [EOL] for key , value in base . __dict__ . items ( ) : [EOL] if key . startswith ( [string] ) : [EOL] [comment] [EOL] continue [EOL] if key in namespace : [EOL] [comment] [EOL] continue [EOL] namespace [ key ] = value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] from bocadillo . utils import override_env [EOL] [EOL] [EOL] def test_override_env ( ) : [EOL] var = [string] [EOL] [EOL] def getvar ( ) : [EOL] return os . getenv ( var ) [EOL] [EOL] initial = getvar ( ) [EOL] [EOL] with override_env ( var , [string] ) : [EOL] with override_env ( var , [string] ) : [EOL] assert getvar ( ) == [string] [EOL] assert getvar ( ) == [string] [EOL] [EOL] assert getvar ( ) == initial [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from starlette . datastructures import FormData [EOL] [EOL] from bocadillo import App [EOL] from bocadillo . constants import ALL_HTTP_METHODS [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ALL_HTTP_METHODS ) def test_method ( app , client , method ) : [EOL] req_method = None [EOL] [EOL] @ app . route ( [string] ) class Index : [EOL] async def handle ( self , req , res ) : [EOL] nonlocal req_method [EOL] req_method = req . method [EOL] [EOL] r = getattr ( client , method ) ( [string] ) [EOL] assert req_method . lower ( ) == method . lower ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , False ) , ] , ) def test_url ( app , client , attr , value ) : [EOL] url = None [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] nonlocal url [EOL] url = req . url [EOL] [EOL] client . get ( [string] , params = { [string] : [string] } ) [EOL] assert url is not None [EOL] [EOL] if attr is None : [EOL] assert url == value [EOL] else : [EOL] assert getattr ( url , attr ) == value [EOL] [EOL] [EOL] def test_headers ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] [comment] [EOL] assert req . headers [ [string] ] == [string] [EOL] with pytest . raises ( KeyError ) : [EOL] req . headers [ [string] ] [EOL] [EOL] [comment] [EOL] assert req . headers [ [string] ] == req . headers [ [string] ] == [string] [EOL] [EOL] [comment] [EOL] assert req . headers . get ( [string] , [number] ) == [number] [EOL] [EOL] r = client . get ( [string] , headers = { [string] : [string] } ) [EOL] assert r . status_code == [number] [EOL] [EOL] [EOL] def test_query_params ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] assert req . url . query == [string] [EOL] [EOL] [comment] [EOL] assert req . query_params [ [string] ] == [string] [EOL] with pytest . raises ( KeyError ) : [EOL] req . query_params [ [string] ] [EOL] [EOL] [comment] [EOL] assert req . query_params . get ( [string] ) == [string] [EOL] assert req . query_params . get ( [string] ) is None [EOL] [EOL] [comment] [EOL] last_item = [string] [EOL] assert req . query_params [ [string] ] == last_item [EOL] assert req . query_params . getlist ( [string] ) == [ [string] , [string] , [string] ] [EOL] [EOL] r = client . get ( [string] , params = { [string] : [string] , [string] : [ [string] , [string] , [string] ] } ) [EOL] assert r . status_code == [number] [EOL] [EOL] [EOL] def test_raw_body ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] body = await req . body ( ) [EOL] assert isinstance ( body , bytes ) [EOL] res . content = body [EOL] [EOL] r = client . get ( [string] , data = [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . content == [string] [EOL] [EOL] [EOL] def test_form_body ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] form = await req . form ( ) [EOL] assert isinstance ( form , FormData ) [EOL] [comment] [EOL] res . json = dict ( form ) [EOL] [EOL] r = client . get ( [string] , data = { [string] : [string] } ) [EOL] assert r . status_code == [number] [EOL] assert r . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) , ( [string] , [number] ) ] ) def test_json_body ( app , client , data , status ) : [EOL] @ app . route ( [string] ) class Index : [EOL] async def post ( self , req , res ) : [EOL] res . json = await req . json ( ) [EOL] [EOL] assert client . post ( [string] , data = data ) . status_code == status [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ lambda req : req , lambda req : req . stream ( ) ] ) def test_stream_request ( app , client , get_stream ) : [EOL] @ app . route ( [string] ) class Index : [EOL] async def get ( self , req , res ) : [EOL] chunks = [ chunk . decode ( ) async for chunk in get_stream ( req ) if chunk ] [EOL] res . json = chunks [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] message = [string] [EOL] [EOL] def stream ( ) : [EOL] for _ in range ( [number] ) : [EOL] yield message [EOL] [EOL] response = client . get ( [string] , data = stream ( ) ) [EOL] assert response . json ( ) == [ message ] * [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] from starlette . responses import PlainTextResponse [EOL] [EOL] from bocadillo import App , HTTPError [EOL] [EOL] [EOL] class ASGIMiddleware : [EOL] def __init__ ( self , app ) : [EOL] self . app = app [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] await self . app ( scope , receive , send ) [EOL] [EOL] [EOL] def test_asgi_middleware ( app , client ) : [EOL] params = None [EOL] received_app = False [EOL] called = False [EOL] [EOL] class Middleware ( ASGIMiddleware ) : [EOL] def __init__ ( self , app , ** kwargs ) : [EOL] super ( ) . __init__ ( app ) [EOL] nonlocal params , received_app [EOL] params = kwargs [EOL] received_app = isinstance ( app , App ) [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] nonlocal called [EOL] called = True [EOL] await super ( ) . __call__ ( scope , receive , send ) [EOL] [EOL] app . add_middleware ( Middleware , hello = [string] ) [EOL] assert not received_app [EOL] assert params == { [string] : [string] } [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] client . get ( [string] ) [EOL] assert called [EOL] [EOL] [EOL] def test_send_response_in_middleware ( app , client ) : [EOL] class Middleware ( ASGIMiddleware ) : [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] response = PlainTextResponse ( [string] ) [EOL] await response ( scope , receive , send ) [EOL] [EOL] app . add_middleware ( Middleware ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] def test_error_handling ( app , client ) : [EOL] class NotAvailableMiddleware ( ASGIMiddleware ) : [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] raise HTTPError ( [number] ) [EOL] [EOL] app . add_middleware ( NotAvailableMiddleware ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert [string] in r . text [EOL] [EOL] [EOL] def test_middleware_called_if_routed_to_sub_app ( app , client ) : [EOL] called = False [EOL] [EOL] class Middleware : [EOL] def __init__ ( self , app ) : [EOL] self . app = app [EOL] [EOL] async def __call__ ( self , scope , receive , send ) : [EOL] nonlocal called [EOL] called = True [EOL] await self . app ( scope , receive , send ) [EOL] [EOL] app . add_middleware ( Middleware ) [EOL] [EOL] sub = App ( ) [EOL] [EOL] @ sub . route ( [string] ) async def sub_index ( req , res ) : [EOL] pass [EOL] [EOL] app . mount ( [string] , sub ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert called [EOL] [EOL] [EOL] def test_asgi2_middleware_not_supported ( app ) : [EOL] class Middleware ( ASGIMiddleware ) : [EOL] def __call__ ( self , scope ) : [EOL] pass [EOL] [EOL] with pytest . raises ( ValueError ) as ctx : [EOL] app . add_middleware ( Middleware ) [EOL] [EOL] error = str ( ctx . value ) . lower ( ) [EOL] for phrase in [string] , [string] , [string] , [string] : [EOL] assert phrase in error [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import configure , create_client [EOL] [EOL] [EOL] def test_if_gzip_enabled_then_response_is_compressed ( raw_app ) : [EOL] app = configure ( raw_app , gzip = True , gzip_min_size = [number] ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] client = create_client ( app ) [EOL] r = client . get ( [string] , headers = { [string] : [string] } ) [EOL] assert r . status_code == [number] [EOL] assert [string] in r . headers [EOL] assert r . headers [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import App [EOL] [EOL] [EOL] def test_default_response_is_success_empty_text ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . text == [string] [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_if_status_code_is_no_content_then_no_content_type_set ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . status_code = [number] [EOL] pass [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert not response . text [EOL] assert response . headers . get ( [string] ) is None [EOL] [EOL] [EOL] def test_content_type_defaults_to_plaintext ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . content = [string] [EOL] [comment] [EOL] res . headers . pop ( [string] , None ) [EOL] pass [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . headers [ [string] ] == [string] [EOL] [EOL] [EOL] def test_if_text_set_then_response_is_plain_text ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . text = [string] [EOL] pass [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . headers [ [string] ] == [string] [EOL] assert response . text == [string] [EOL] [EOL] [EOL] def test_if_json_set_then_response_is_json ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . json = { [string] : [string] } [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . json ( ) == { [string] : [string] } [EOL] [EOL] [EOL] def test_if_html_set_then_response_is_html ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . html = [string] [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . headers [ [string] ] == [string] [EOL] assert response . text == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ [ ( [string] , { [string] : [string] } ) , ( [string] , [string] ) ] , [string] , lambda r : r . text == [string] , ] , [ [ ( [string] , [string] ) , ( [string] , { [string] : [string] } ) ] , [string] , lambda r : r . json ( ) == { [string] : [string] } , ] , ] , ) def test_last_response_setter_called_has_priority ( app , client , contents , content_type , check_content ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] for attr , value in contents : [EOL] setattr ( res , attr , value ) [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . headers [ [string] ] == content_type [EOL] assert check_content ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import configure , create_client [EOL] [EOL] [EOL] def test_if_host_not_allowed_then_400 ( raw_app ) : [EOL] app = configure ( raw_app , allowed_hosts = [ [string] ] ) [EOL] client = create_client ( app ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import SettingsError , configure , create_client [EOL] from bocadillo . utils import override_env [EOL] [EOL] [EOL] def test_sessions_enabled_no_secret_key ( raw_app ) : [EOL] with pytest . raises ( SettingsError ) : [EOL] configure ( raw_app , sessions = True ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_sessions_enabled_secret_key_empty ( raw_app , from_env ) : [EOL] if from_env : [EOL] with override_env ( [string] , [string] ) : [EOL] with pytest . raises ( SettingsError ) : [EOL] configure ( raw_app , sessions = True ) [EOL] else : [EOL] with pytest . raises ( SettingsError ) : [EOL] configure ( raw_app , sessions = { [string] : [string] } ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_sessions_enabled_secret_key_present ( raw_app , from_env ) : [EOL] if from_env : [EOL] with override_env ( [string] , [string] ) : [EOL] app = configure ( raw_app , sessions = True ) [EOL] else : [EOL] app = configure ( raw_app , sessions = { [string] : [string] } ) [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) async def set_session ( req , res ) : [EOL] req . session [ [string] ] = [string] [EOL] res . text = [string] [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] data = req . session [ [string] ] [EOL] res . text = f" [string] { data }" [EOL] [EOL] client = create_client ( app ) [EOL] client . post ( [string] ) [EOL] response = client . get ( [string] ) [EOL] assert [string] in response . text [EOL] assert [string] in response . cookies [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import App [EOL] [EOL] [EOL] def test_startup_and_shutdown ( app , client ) : [EOL] message = None [EOL] [EOL] @ app . on ( [string] ) async def setup ( ) : [EOL] nonlocal message [EOL] message = [string] [EOL] [EOL] @ app . on ( [string] ) async def cleanup ( ) : [EOL] nonlocal message [EOL] message = None [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . text = message [EOL] [EOL] [comment] [EOL] [comment] [EOL] with client : [EOL] assert message == [string] [EOL] response = client . get ( [string] ) [EOL] assert response . text == [string] [EOL] assert message is None [EOL] [EOL] [EOL] def test_sync_handler ( app , client ) : [EOL] message = None [EOL] [EOL] @ app . on ( [string] ) def setup ( ) : [EOL] nonlocal message [EOL] message = [string] [EOL] [EOL] with client : [EOL] assert message == [string] [EOL] [EOL] [EOL] def test_non_decorator_syntax ( app , client ) : [EOL] message = None [EOL] [EOL] async def setup ( ) : [EOL] nonlocal message [EOL] message = [string] [EOL] [EOL] app . on ( [string] , setup ) [EOL] [EOL] with client : [EOL] assert message == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import App [EOL] [EOL] [EOL] def test_background_task_is_executed ( app , client ) : [EOL] executed = False [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] @ res . background async def notify_executed ( ) : [EOL] nonlocal executed [EOL] executed = True [EOL] [EOL] res . text = [string] [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . text == [string] [EOL] assert executed [EOL] [EOL] [EOL] def test_background_task_is_executed_after_response_is_sent ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] @ res . background async def send_bar ( ) : [EOL] res . text = [string] [EOL] [EOL] res . text = [string] [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . text == [string] [EOL] [EOL] [EOL] def test_can_pass_extra_kwargs ( app , client ) : [EOL] called = False [EOL] [EOL] async def set_called ( what ) : [EOL] nonlocal called [EOL] called = what [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . background ( set_called , [string] ) [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert called == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] from http import HTTPStatus [EOL] [EOL] import pytest [EOL] [EOL] from bocadillo import App , create_client , ExpectedAsync , HTTPError [EOL] from bocadillo . error_handlers import error_to_html , error_to_json , error_to_text [EOL] [EOL] [EOL] def test_async_check ( app ) : [EOL] def handle_key_error ( req , res , params ) : [EOL] pass [EOL] [EOL] with pytest . raises ( ExpectedAsync ) : [EOL] app . add_error_handler ( KeyError , handle_key_error ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) def test_if_http_error_is_raised_then_automatic_response_is_sent ( app , client , status ) : [EOL] status , phrase = status . split ( [string] , [number] ) [EOL] status_code = int ( status ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] raise HTTPError ( status_code ) [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == status_code [EOL] assert phrase in response . text [EOL] [EOL] [EOL] class MyKeyError ( KeyError ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( KeyError , True ) , ( MyKeyError , True ) , ( ValueError , False ) , ( AttributeError , False ) , ] , ) def test_custom_error_handler ( app , exception_cls , success ) : [EOL] called = False [EOL] [EOL] @ app . error_handler ( KeyError ) async def on_key_error ( req , res , exc ) : [EOL] nonlocal called [EOL] res . text = [string] [EOL] called = True [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] raise exception_cls ( [string] ) [EOL] [EOL] client = create_client ( app , raise_server_exceptions = False ) [EOL] [EOL] response = client . get ( [string] ) [EOL] assert called is success [EOL] if success : [EOL] assert response . status_code == [number] [EOL] assert response . text == [string] [EOL] else : [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ pytest . fixture ( params = [ [string] , [string] ] ) def detail ( request ) : [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( error_to_html , lambda res : res . text , lambda detail : [string] . format ( f" [string] { detail } [string] " if detail else [string] ) , ) , ( error_to_json , lambda res : res . json ( ) , lambda detail : ( { [string] : [string] , [string] : detail , [string] : [number] } [EOL] if detail [EOL] else { [string] : [string] , [string] : [number] } ) , ) , ( error_to_text , lambda res : res . text , lambda detail : [string] . format ( f" [string] { detail }" if detail else [string] ) , ) , ] , ) def test_builtin_handlers ( app , client , detail , handler , content , expected ) : [EOL] app . add_error_handler ( HTTPError , handler ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] raise HTTPError ( [number] , detail = detail ) [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert content ( response ) == expected ( detail ) [EOL] [EOL] [EOL] def test_http_error_status_must_be_int_or_http_status ( ) : [EOL] HTTPError ( [number] ) [EOL] HTTPError ( HTTPStatus . NOT_FOUND ) [EOL] [EOL] with pytest . raises ( AssertionError ) as ctx : [EOL] HTTPError ( [string] ) [EOL] [EOL] assert [string] in str ( ctx . value ) [EOL] [EOL] [EOL] def test_http_error_str_representation ( ) : [EOL] assert str ( HTTPError ( [number] , detail = [string] ) ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import configure , create_client [EOL] [EOL] [EOL] def test_if_hsts_enabled_and_request_is_on_http_then_redirects_to_https ( raw_app ) : [EOL] app = configure ( raw_app , hsts = True ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] client = create_client ( app ) [EOL] response = client . get ( [string] , allow_redirects = False ) [EOL] assert [number] <= response . status_code <= [number] [EOL] assert response . headers [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import App [EOL] [EOL] [EOL] def test_attachment ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . text = [string] [EOL] res . attachment = [string] [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert ( response . headers [ [string] ] == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import configure , create_client , settings [EOL] [EOL] [EOL] def test_basic ( raw_app ) : [EOL] def use_foo ( app ) : [EOL] @ app . route ( [string] ) async def foo ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] app = configure ( raw_app , plugins = [ use_foo ] ) [EOL] client = create_client ( app ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] def test_use_settings ( raw_app ) : [EOL] def use_hello ( app ) : [EOL] hello_message = getattr ( settings , [string] ) [EOL] [EOL] @ app . route ( [string] ) async def foo ( req , res ) : [EOL] res . text = hello_message [EOL] [EOL] app = configure ( raw_app , plugins = [ use_hello ] , hello_message = [string] ) [EOL] client = create_client ( app ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_conditional_plugin ( raw_app , should_use ) : [EOL] used = False [EOL] [EOL] def use_hello ( _ ) : [EOL] nonlocal used [EOL] used = True [EOL] [EOL] configure ( raw_app , plugins = [ { use_hello : should_use } ] ) [EOL] assert used is should_use [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import App [EOL] from bocadillo . constants import ALL_HTTP_METHODS [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ [string] , [string] ] , [string] , [number] ) , ( [ [string] ] , [string] , [number] ) , ( [ ] , [string] , [number] ) ] , ) def test_allowed_methods ( app , client , methods , method , status ) : [EOL] @ app . route ( [string] , methods = methods ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] response = getattr ( client , method ) ( [string] ) [EOL] assert response . status_code == status [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] ] ) def test_unsafe_methods_not_supported_by_default ( app , client , method ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] response = getattr ( client , method ) ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_if_get_implemented_then_head_mapped ( app , client ) : [EOL] @ app . route ( [string] ) class Index : [EOL] async def get ( self , req , res ) : [EOL] pass [EOL] [EOL] assert client . head ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] def test_if_get_in_function_view_methods_then_head_mapped ( app , client ) : [EOL] @ app . route ( [string] , methods = [ [string] ] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] assert client . head ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] def test_if_methods_is_all_then_all_methods_allowed ( app , client ) : [EOL] @ app . route ( [string] , methods = all ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] for method in ALL_HTTP_METHODS : [EOL] assert getattr ( client , method ) ( [string] ) . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import multiprocessing [EOL] import builtins [EOL] import bocadillo [EOL] import requests [EOL] import typing [EOL] from asyncio import sleep [EOL] from multiprocessing import Value [EOL] from time import sleep as sync_sleep [EOL] [EOL] import pytest [EOL] import requests [EOL] [EOL] from bocadillo import App , ClientDisconnect , LiveServer [EOL] [EOL] from . utils import stops_incrementing [EOL] [EOL] [EOL] def test_stream_response ( app , client ) : [EOL] background_called = False [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res , word ) : [EOL] @ res . stream async def stream_word ( ) : [EOL] for character in word : [EOL] yield character [EOL] await sleep ( [number] ) [EOL] [EOL] [comment] [EOL] [EOL] res . headers [ [string] ] = [string] [EOL] res . status_code = [number] [EOL] [EOL] @ res . background async def do_later ( ) : [EOL] nonlocal background_called [EOL] background_called = True [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . text == [string] [EOL] assert r . headers [ [string] ] == [string] [EOL] assert r . status_code == [number] [EOL] assert background_called [EOL] [comment] [EOL] assert [string] not in r . headers [EOL] [EOL] [EOL] def test_stream_func_must_be_async_generator_function ( app ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] @ res . stream def foo ( ) : [EOL] pass [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] @ res . stream async def bar ( ) : [EOL] pass [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] @ res . stream def baz ( ) : [EOL] yield [string] [EOL] [EOL] [EOL] def test_stop_on_client_disconnect ( app ) : [EOL] sent = Value ( [string] , [number] ) [EOL] [EOL] @ app . route ( [string] ) async def infinity ( req , res ) : [EOL] @ res . stream async def stream ( ) : [EOL] nonlocal sent [EOL] while True : [EOL] yield [string] [EOL] sent . value += [number] [EOL] [EOL] with LiveServer ( app ) as server : [EOL] r = requests . get ( server . url ( [string] ) , stream = True ) [EOL] assert r . status_code == [number] [EOL] assert stops_incrementing ( counter = sent , response = r ) [EOL] [EOL] [EOL] def test_raise_on_disconnect ( app ) : [EOL] caught = Value ( [string] , [number] ) [EOL] [EOL] @ app . route ( [string] ) async def infinity ( req , res ) : [EOL] @ res . stream ( raise_on_disconnect = True ) async def stream ( ) : [EOL] nonlocal caught [EOL] try : [EOL] while True : [EOL] yield [string] [EOL] except ClientDisconnect : [EOL] caught . value = [number] [EOL] [EOL] with LiveServer ( app ) as server : [EOL] r = requests . get ( server . url ( [string] ) , stream = True ) [EOL] assert r . status_code == [number] [EOL] r . close ( ) [EOL] sync_sleep ( [number] ) [EOL] assert caught . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import App [EOL] [EOL] [EOL] def test_chunked_response ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . chunked = True [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . headers [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import App [EOL] [EOL] [EOL] def test_root_wildcard ( app , client ) : [EOL] @ app . route ( [string] ) async def root ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] def test_wildcard ( app , client ) : [EOL] @ app . route ( [string] ) async def foo_bar ( req , res ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] [EOL] [EOL] def test_if_wildcard_first_then_other_routes_wont_match ( app , client ) : [EOL] @ app . route ( [string] ) async def foo_all ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] @ app . route ( [string] ) async def foo_bar ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ) def test_if_wildcard_last_then_matches_by_default ( app , client , path , text ) : [EOL] @ app . route ( [string] ) async def foo_bar ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] @ app . route ( [string] ) async def foo_all ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] r = client . get ( path ) [EOL] assert r . status_code == [number] [EOL] assert r . text == text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import configure , create_client , static [EOL] [EOL] FILE_DIR = [string] [EOL] FILE_NAME = [string] [EOL] FILE_CONTENTS = [string] [EOL] [EOL] [EOL] def _create_asset ( static_dir ) : [EOL] asset = static_dir . mkdir ( FILE_DIR ) . join ( FILE_NAME ) [EOL] asset . write ( FILE_CONTENTS ) [EOL] return asset [EOL] [EOL] [EOL] def test_assets_are_served_at_static_by_default ( raw_app , tmpdir_factory ) : [EOL] static_dir = tmpdir_factory . mktemp ( [string] ) [EOL] _create_asset ( static_dir ) [EOL] [EOL] app = configure ( raw_app , static_dir = str ( static_dir ) ) [EOL] client = create_client ( app ) [EOL] [EOL] response = client . get ( f" [string] { FILE_DIR } [string] { FILE_NAME }" ) [EOL] assert response . status_code == [number] [EOL] assert response . text == FILE_CONTENTS [EOL] [EOL] [EOL] def test_if_asset_does_not_exist_then_404 ( client ) : [EOL] assert client . get ( f" [string] { FILE_DIR } [string] { FILE_NAME }" ) . status_code == [number] [EOL] [EOL] [EOL] def test_customize_static_root ( raw_app , tmpdir_factory ) : [EOL] static_dir = tmpdir_factory . mktemp ( [string] ) [EOL] _create_asset ( static_dir ) [EOL] [EOL] app = configure ( raw_app , static_dir = str ( static_dir ) , static_root = [string] ) [EOL] client = create_client ( app ) [EOL] [EOL] assert client . get ( f" [string] { FILE_DIR } [string] { FILE_NAME }" ) . status_code == [number] [EOL] response = client . get ( f" [string] { FILE_DIR } [string] { FILE_NAME }" ) [EOL] assert response . status_code == [number] [EOL] assert response . text == FILE_CONTENTS [EOL] [EOL] [EOL] def test_if_static_dir_is_none_then_no_assets_served ( raw_app , tmpdir_factory ) : [EOL] static_dir = tmpdir_factory . mktemp ( [string] ) [EOL] _create_asset ( static_dir ) [EOL] [EOL] app = configure ( raw_app , static_dir = None ) [EOL] client = create_client ( app ) [EOL] [EOL] assert client . get ( f" [string] { FILE_DIR } [string] { FILE_NAME }" ) . status_code == [number] [EOL] [EOL] [EOL] def test_mount_extra_static_files_dirs ( raw_app , tmpdir_factory ) : [EOL] static_dir = tmpdir_factory . mktemp ( [string] ) [EOL] _create_asset ( static_dir ) [EOL] [EOL] app = configure ( raw_app , static_dir = None ) [EOL] app . mount ( [string] , static ( str ( static_dir ) ) ) [EOL] client = create_client ( app ) [EOL] [EOL] response = client . get ( f" [string] { FILE_DIR } [string] { FILE_NAME }" ) [EOL] assert response . status_code == [number] [EOL] assert response . text == FILE_CONTENTS [EOL] [EOL] [EOL] def test_if_static_dir_does_not_exist_then_no_files_mounted ( raw_app ) : [EOL] with pytest . warns ( None ) as record : [EOL] configure ( raw_app , static_dir = [string] ) [EOL] assert len ( record ) == [number] [EOL] [EOL] [EOL] def test_whitenoise_config ( raw_app ) : [EOL] app = configure ( raw_app , static_root = [string] , static_config = { [string] : [number] } ) [EOL] whitenoise = next ( route . app for route in app . router . routes if hasattr ( route , [string] ) and route . path == [string] ) [EOL] assert whitenoise . max_age == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import tests [EOL] import conftest [EOL] import bocadillo [EOL] import pytest [EOL] from bocadillo import App [EOL] from jinja2 . exceptions import TemplateNotFound [EOL] [EOL] from bocadillo import Templates [EOL] [EOL] from . conftest import TemplateWrapper , create_template [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_render ( template_file , templates ) : [EOL] html = await templates . render ( template_file . name , ** template_file . context ) [EOL] assert html == template_file . rendered [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_render_using_dict ( template_file , templates ) : [EOL] html = await templates . render ( template_file . name , template_file . context ) [EOL] assert html == template_file . rendered [EOL] [EOL] [EOL] def test_render_sync ( template_file , templates ) : [EOL] html = templates . render_sync ( template_file . name , ** template_file . context ) [EOL] assert html == template_file . rendered [EOL] [EOL] [EOL] def test_render_string ( templates ) : [EOL] html = templates . render_string ( [string] , title = [string] ) [EOL] assert html == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_modify_templates_dir ( templates , tmpdir_factory ) : [EOL] template = create_template ( templates , tmpdir_factory , dirname = [string] ) [EOL] html = await templates . render ( template . name , ** template . context ) [EOL] assert html == template . rendered [EOL] [EOL] [EOL] def test_modify_context ( ) : [EOL] templates = Templates ( context = { [string] : [string] } ) [EOL] templates . context = { [string] : [string] } [EOL] templates . context [ [string] ] = [string] [EOL] assert ( templates . render_string ( [string] ) == [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_if_template_does_not_exist_then_not_found_raised ( templates ) : [EOL] with pytest . raises ( TemplateNotFound ) : [EOL] await templates . render ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import App , configure , useprovider , WebSocket [EOL] [EOL] [EOL] @ pytest . fixture def app ( raw_app ) : [EOL] return configure ( raw_app , provider_modules = [ [string] ] ) [EOL] [EOL] [EOL] async def say_hi ( req , res , hello ) : [EOL] res . text = hello [EOL] [EOL] [EOL] class SayHi : [EOL] async def get ( self , req , res , hello ) : [EOL] res . text = hello [EOL] [EOL] [EOL] async def say_hi_to ( req , res , hello_format , who ) : [EOL] res . text = hello_format . format ( who = who ) [EOL] [EOL] [EOL] class SayHiTo : [EOL] async def get ( self , req , res , hello_format , who ) : [EOL] res . text = hello_format . format ( who = who ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( say_hi , SayHi ) ) def test_basic ( app , client , view ) : [EOL] app . route ( [string] ) ( view ) [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( say_hi_to , SayHiTo ) ) def test_with_route_parameter ( app , client , view ) : [EOL] app . route ( [string] ) ( view ) [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] def test_provider_name ( app , client ) : [EOL] @ app . route ( [string] ) async def say_foo ( req , res , foo ) : [EOL] res . text = foo [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] def test_websocket_clients_example ( app , client ) : [EOL] @ app . websocket_route ( [string] ) async def chat ( ws , clients ) : [EOL] clients . add ( ws ) [EOL] try : [EOL] await ws . send_text ( str ( len ( clients ) ) ) [EOL] await ws . receive_text ( ) [EOL] finally : [EOL] clients . remove ( ws ) [EOL] [EOL] @ app . route ( [string] ) async def client_count ( req , res , clients ) : [EOL] res . json = { [string] : len ( clients ) } [EOL] [EOL] with client . websocket_connect ( [string] ) as ws : [EOL] assert ws . receive_text ( ) == [string] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . json ( ) == { [string] : [number] } [EOL] [EOL] [EOL] def test_useprovider ( app , client ) : [EOL] @ app . route ( [string] ) @ useprovider ( [string] ) async def index ( req , res , spy ) : [EOL] res . json = spy [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . json ( ) [ [string] ] is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import App , Redirect [EOL] [EOL] [EOL] def _setup_views_with_redirect ( app , permanent = None , ** kwargs ) : [EOL] @ app . route ( [string] ) async def home ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] if permanent : [EOL] raise Redirect ( permanent = True , ** kwargs ) [EOL] raise Redirect ( ** kwargs ) [EOL] [EOL] [EOL] def test_redirection_is_temporary_by_default ( app , client ) : [EOL] _setup_views_with_redirect ( app , url = [string] ) [EOL] response = client . get ( [string] , allow_redirects = False ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_permanent_redirect ( app , client ) : [EOL] _setup_views_with_redirect ( app , permanent = True , url = [string] ) [EOL] response = client . get ( [string] , allow_redirects = False ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_redirect_to_internal_url ( app , client ) : [EOL] @ app . route ( [string] ) async def about ( req , res , who ) : [EOL] res . text = who [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] raise Redirect ( [string] ) [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . text == [string] [EOL] [EOL] [EOL] def test_if_redirect_to_non_matching_internal_url_then_404 ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] raise Redirect ( [string] ) [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_redirect_to_external_url ( app , client ) : [EOL] external_url = [string] [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] raise Redirect ( external_url ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] response = client . get ( [string] , allow_redirects = False ) [EOL] assert response . status_code == [number] [EOL] assert response . headers [ [string] ] == external_url [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import configure , create_client [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [ [string] , [string] ] , [ ( [string] , True ) , ( [string] , True ) , ( [string] , False ) ] , ) def test_allow_origin ( raw_app , origin , allowed ) : [EOL] app = configure ( raw_app , cors = { [string] : [ [string] , [string] ] } ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] client = create_client ( app ) [EOL] r = client . get ( [string] , headers = { [string] : origin } ) [EOL] [EOL] assert r . text == [string] [EOL] assert r . status_code == [number] if allowed else [number] [EOL] [EOL] if allowed : [comment] [EOL] assert [string] in r . headers [EOL] assert r . headers [ [string] ] == origin [EOL] else : [comment] [EOL] assert [string] not in r . headers [EOL] [EOL] [EOL] def test_no_allowed_origins_by_default ( raw_app ) : [EOL] app = configure ( raw_app , cors = True ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] client = create_client ( app ) [EOL] r = client . options ( [string] , headers = { [string] : [string] , [string] : [string] , } , ) [EOL] assert r . status_code == [number] , r . text [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , True ) , ( [string] , False ) ] ) def test_allow_method ( raw_app , method , allowed ) : [EOL] app = configure ( raw_app , cors = { [string] : [ [string] ] , [string] : [ [string] ] } , ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] client = create_client ( app ) [EOL] r = client . options ( [string] , headers = { [string] : [string] , [string] : method , } , ) [EOL] assert r . status_code == [number] if allowed else [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Union [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] import bocadillo [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] from bocadillo import App [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def fixture_txt ( tmp_path ) : [EOL] txt = tmp_path / [string] [EOL] txt . write_text ( [string] ) [EOL] assert txt . name == [string] [EOL] return txt [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False , None ) ) def test_file_response ( app , client , txt , attach ) : [EOL] kwargs = { } if attach is None else { [string] : attach } [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . file ( str ( txt ) , ** kwargs ) [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . text == txt . read_text ( ) [EOL] if attach is False : [EOL] assert [string] not in response . headers [EOL] else : [EOL] assert ( response . headers [ [string] ] == f" [string] { txt . name } [string] " ) [EOL] [EOL] [EOL] def test_if_file_does_not_exist_then_fail ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . file ( [string] ) [EOL] [EOL] with pytest . raises ( RuntimeError ) as ctx : [EOL] client . get ( [string] ) [EOL] [EOL] assert [string] in str ( ctx . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import multiprocessing [EOL] import builtins [EOL] import bocadillo [EOL] import requests [EOL] import typing [EOL] from multiprocessing import Value [EOL] from time import sleep [EOL] [EOL] import pytest [EOL] import requests [EOL] [EOL] from bocadillo import App , ClientDisconnect , LiveServer , server_event [EOL] [EOL] from . utils import stops_incrementing [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [ ( ) , { [string] : [string] } , [ [string] , [string] ] ] , [ ( ) , { [string] : [string] , [string] : [number] } , [ [string] , [string] , [string] ] ] , [ ( [string] , ) , { [string] : [number] , [string] : [string] } , [ [string] , [string] , [string] , [string] ] , ] , [ ( [string] , ) , { [string] : [number] , [string] : { [string] : [string] } } , [ [string] , [string] , [string] , [string] ] , ] , [ ( ) , { [string] : [ [string] , [string] ] } , [ [string] , [string] , [string] ] ] , ] , ) def test_send_event ( app , client , args , kwargs , lines ) : [EOL] @ app . route ( [string] ) async def view_with_events ( req , res ) : [EOL] @ res . event_stream async def generate_events ( ) : [EOL] yield server_event ( * args , ** kwargs ) [EOL] [EOL] r = client . get ( [string] , stream = True ) [EOL] assert r . status_code == [number] [EOL] stream = r . iter_lines ( ) [EOL] [EOL] received = [ next ( stream ) . decode ( ) for _ in lines ] [EOL] assert received == lines [EOL] [EOL] with pytest . raises ( StopIteration ) : [EOL] next ( stream ) [EOL] [EOL] [EOL] def test_sse_headers_are_set ( app , client ) : [EOL] @ app . route ( [string] ) async def view_with_events ( req , res ) : [EOL] @ res . event_stream async def generate_events ( ) : [EOL] yield server_event ( name = [string] ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . headers [ [string] ] == [string] [EOL] assert r . headers [ [string] ] == [string] [EOL] assert r . headers [ [string] ] == [string] [EOL] [EOL] [EOL] def test_cache_control_header_not_replaced_if_manually_set ( app , client ) : [EOL] @ app . route ( [string] ) async def sse ( req , res ) : [EOL] res . headers [ [string] ] = [string] [EOL] [EOL] @ res . event_stream async def generate_events ( ) : [EOL] yield server_event ( [string] ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . headers [ [string] ] == [string] [EOL] [EOL] [EOL] def test_stop_on_client_disconnect ( app ) : [EOL] num_sent = Value ( [string] , [number] ) [EOL] [EOL] @ app . route ( [string] ) async def sse ( req , res ) : [EOL] @ res . event_stream async def events ( ) : [EOL] nonlocal num_sent [EOL] while True : [EOL] yield server_event ( [string] ) [EOL] num_sent . value += [number] [EOL] [EOL] with LiveServer ( app ) as server : [EOL] r = requests . get ( f"{ server . url } [string] " , stream = True ) [EOL] assert r . status_code == [number] [EOL] assert stops_incrementing ( counter = num_sent , response = r ) [EOL] [EOL] [EOL] def test_raise_client_disconnects ( app ) : [EOL] caught = Value ( [string] , [number] ) [EOL] [EOL] @ app . route ( [string] ) async def sse ( req , res ) : [EOL] @ res . event_stream ( raise_on_disconnect = True ) async def events ( ) : [EOL] nonlocal caught [EOL] try : [EOL] while True : [EOL] yield server_event ( [string] ) [EOL] except ClientDisconnect : [EOL] caught . value = [number] [EOL] [EOL] with LiveServer ( app ) as server : [EOL] r = requests . get ( f"{ server . url } [string] " , stream = True ) [EOL] assert r . status_code == [number] [EOL] r . close ( ) [EOL] sleep ( [number] ) [EOL] assert caught . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import App , Router , WebSocketDisconnect , configure , create_client [EOL] [EOL] [EOL] def test_index_returns_404_by_default ( app , client ) : [EOL] assert client . get ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] def test_if_route_not_registered_then_404 ( app , client ) : [EOL] assert client . get ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] def test_if_route_registered_then_not_404 ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] assert client . get ( [string] ) . status_code != [number] [EOL] [EOL] [EOL] def test_default_status_code_is_200_on_routes ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] assert client . get ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] def test_leading_slash_is_added_if_not_present ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] assert client . get ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] def test_trailing_slash_not_redirected ( app , client ) : [EOL] @ app . route ( [string] ) async def foo ( req , res ) : [EOL] pass [EOL] [EOL] assert client . get ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( None , True , False ) ) def test_redirect_trailing_slash ( raw_app , redirect ) : [EOL] settings = { } [EOL] if redirect is not None : [EOL] settings [ [string] ] = redirect [EOL] [EOL] app = configure ( raw_app , ** settings ) [EOL] client = create_client ( app ) [EOL] [EOL] @ app . route ( [string] ) async def foo ( req , res ) : [EOL] pass [EOL] [EOL] r = client . get ( [string] , allow_redirects = False ) [EOL] [EOL] if redirect or redirect is None : [EOL] assert r . status_code == [number] [EOL] else : [EOL] assert r . status_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ] , ) def test_include_router_http ( app , client , path , status ) : [EOL] router = Router ( ) [EOL] [EOL] @ router . route ( [string] ) async def get_tacos ( req , res ) : [EOL] pass [EOL] [EOL] @ router . route ( [string] ) async def get_taco ( req , res , pk ) : [EOL] pass [EOL] [EOL] [comment] [EOL] @ app . route ( [string] ) async def gluten_free_tacos ( req , res ) : [EOL] pass [EOL] [EOL] app . include_router ( router , prefix = [string] ) [EOL] [EOL] assert client . get ( path ) . status_code == status [EOL] [EOL] [EOL] def test_include_router_no_prefix ( app , client ) : [EOL] router = Router ( ) [EOL] [EOL] @ router . route ( [string] ) async def foo ( req , res ) : [EOL] pass [EOL] [EOL] app . include_router ( router ) [EOL] [EOL] assert client . get ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , False ) , ( [string] , False ) , ( [string] , False ) , ( [string] , True ) , ( [string] , False ) , ] , ) def test_include_router_websocket ( app , client , path , success ) : [EOL] router = Router ( ) [EOL] [EOL] @ router . websocket_route ( [string] ) async def chat ( ws ) : [EOL] await ws . send ( [string] ) [EOL] [EOL] app . include_router ( router , prefix = [string] ) [EOL] [EOL] def connect ( ) : [EOL] with client . websocket_connect ( path ) as ws : [EOL] assert ws . receive_text ( ) == [string] [EOL] [EOL] if success : [EOL] connect ( ) [EOL] else : [EOL] with pytest . raises ( WebSocketDisconnect ) as ctx : [EOL] connect ( ) [EOL] assert ctx . value . code == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) , ( [string] , [number] ) ] ) def test_include_router_nested_apps ( app , client , path , status ) : [EOL] other = App ( ) [EOL] [EOL] @ other . route ( [string] ) async def foo ( req , res ) : [EOL] pass [EOL] [EOL] router = Router ( ) [EOL] router . mount ( [string] , other ) [EOL] [EOL] app . include_router ( router , prefix = [string] ) [EOL] [EOL] assert client . get ( path ) . status_code == status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import typing [EOL] import tests [EOL] import bocadillo [EOL] import pytest [EOL] import typesystem [EOL] [EOL] from bocadillo import configure , create_client [EOL] [EOL] [EOL] class Todo ( typesystem . Schema ) : [EOL] title = typesystem . String ( max_length = [number] ) [EOL] done = typesystem . Boolean ( default = False ) [EOL] [EOL] [EOL] def test_handle_validation_errors ( app , client ) : [EOL] @ app . route ( [string] ) class TodoList : [EOL] async def post ( self , req , res ) : [EOL] todo = Todo . validate ( await req . json ( ) ) [EOL] res . json = dict ( todo ) [EOL] [EOL] r = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert r . status_code == [number] [EOL] assert r . json ( ) == { [string] : [string] , [string] : False } [EOL] [EOL] r = client . post ( [string] , json = { [string] : [string] * [number] } ) [EOL] assert r . status_code == [number] [EOL] assert r . json ( ) [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] def test_disable_validation_error_handling ( raw_app ) : [EOL] app = configure ( raw_app , handle_typesystem_validation_errors = False ) [EOL] client = create_client ( app ) [EOL] [EOL] @ app . route ( [string] ) class TodoList : [EOL] async def post ( self , req , res ) : [EOL] todo = Todo . validate ( await req . json ( ) ) [EOL] res . json = dict ( todo ) [EOL] [EOL] with pytest . raises ( typesystem . ValidationError ) : [EOL] client . post ( [string] , json = { [string] : [string] * [number] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_json_validation_errors.Todo]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_json_validation_errors.Todo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import pytest [EOL] [EOL] from bocadillo import configure , create_client , settings [EOL] [EOL] [EOL] def test_cannot_reconfigure ( app ) : [EOL] with pytest . raises ( RuntimeError ) : [EOL] configure ( app ) [EOL] [EOL] [EOL] def test_must_be_configured_to_serve ( raw_app ) : [EOL] @ raw_app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] with pytest . raises ( RuntimeError ) as ctx : [EOL] with create_client ( raw_app ) : [EOL] pass [EOL] [EOL] assert [string] in str ( ctx . value ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_settings ( raw_app , positional ) : [EOL] class Settings : [EOL] ONE = [string] [EOL] _IGNORED = [string] [EOL] ignored_too = [string] [EOL] [EOL] args = [ raw_app ] [EOL] kwargs = { [string] : [string] , [string] : Settings ( ) } [EOL] if positional : [EOL] args . append ( kwargs . pop ( [string] ) ) [EOL] [EOL] configure ( * args , ** kwargs ) [EOL] [EOL] assert settings . ONE == [string] [EOL] assert settings . TWO == [string] [EOL] for name in [string] , [string] , [string] , [string] , [string] : [EOL] assert name not in settings [EOL] [EOL] settings . ONE = [number] [EOL] assert settings . ONE == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import App [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_mount ( app , client , path ) : [EOL] other = App ( ) [EOL] [EOL] requested_path = None [EOL] [EOL] async def view ( req , res ) : [EOL] nonlocal requested_path [EOL] requested_path = req . url . path [EOL] [EOL] other . route ( [string] ) ( view ) [EOL] other . route ( [string] ) ( view ) [EOL] [EOL] app . mount ( [string] , other ) [EOL] [EOL] r = client . get ( path ) [EOL] assert r . status_code == [number] [EOL] assert requested_path is not None [EOL] assert requested_path . rstrip ( [string] ) == path [EOL] [EOL] [EOL] def test_mount_route_parameter ( app , client ) : [EOL] other = App ( ) [EOL] [EOL] @ other . route ( [string] ) async def get_item ( req , res , pk ) : [EOL] res . json = { [string] : pk } [EOL] [EOL] app . mount ( [string] , other ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . json ( ) == { [string] : [number] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def test_import_package ( ) : [EOL] import bocadillo [EOL]	0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import typing [EOL] [EOL] import pytest [EOL] [EOL] from bocadillo import App , configure , create_client , Templates , settings [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def fixture_raw_app ( request ) : [EOL] settings . _clear ( ) [EOL] return App ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def fixture_app ( raw_app ) : [EOL] configure ( raw_app ) [EOL] return raw_app [EOL] [EOL] [EOL] @ pytest . fixture def client ( app ) : [EOL] return create_client ( app ) [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def fixture_templates ( ) : [EOL] return Templates ( ) [EOL] [EOL] [EOL] class TemplateWrapper ( typing . NamedTuple ) : [EOL] name = ... [EOL] context = ... [EOL] rendered = ... [EOL] root = ... [EOL] [EOL] [EOL] def create_template ( templates , tmpdir_factory , dirname ) : [EOL] templates_dir = tmpdir_factory . mktemp ( dirname ) [EOL] [EOL] template = templates_dir . join ( [string] ) [EOL] template . write ( [string] ) [EOL] [EOL] templates . directory = str ( templates_dir ) [EOL] [EOL] return TemplateWrapper ( name = [string] , context = { [string] : [string] } , rendered = [string] , root = str ( templates_dir ) , ) [EOL] [EOL] [EOL] @ pytest . fixture def template_file ( templates , tmpdir_factory ) : [EOL] return create_template ( templates , tmpdir_factory , dirname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $TemplateWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TemplateWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import bocadillo [EOL] import pytest [EOL] [EOL] from bocadillo import App , ExpectedAsync [EOL] from bocadillo . constants import ALL_HTTP_METHODS [EOL] [EOL] [EOL] def test_function_based_view ( app , client ) : [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] assert client . get ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] def test_async_check ( app ) : [EOL] def index ( req , res ) : [EOL] pass [EOL] [EOL] with pytest . raises ( ExpectedAsync ) : [EOL] app . route ( [string] ) ( index ) [EOL] [EOL] class Index : [EOL] def get ( self , req , res ) : [EOL] pass [EOL] [EOL] with pytest . raises ( ExpectedAsync ) : [EOL] app . route ( [string] ) ( Index ) [EOL] [EOL] [EOL] def test_can_register_class_based_view ( app ) : [EOL] @ app . route ( [string] ) class Index : [EOL] pass [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ALL_HTTP_METHODS ) def test_if_method_not_implemented_then_405 ( app , client , method ) : [EOL] @ app . route ( [string] ) class Index : [EOL] pass [EOL] [EOL] response = getattr ( client , method ) ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] def test_if_method_implemented_then_as_normal ( app , client ) : [EOL] @ app . route ( [string] ) class Index : [EOL] async def get ( self , req , res ) : [EOL] res . text = [string] [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . text == [string] [EOL] [EOL] [EOL] def test_if_handle_is_implemented_then_bypasses_other_methods ( app , client ) : [EOL] @ app . route ( [string] ) class Index : [EOL] async def handle ( self , req , res ) : [EOL] res . text = [string] [EOL] [EOL] async def get ( self , req , res ) : [EOL] res . text = [string] [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . text == [string] [EOL] [EOL] [EOL] def test_view_from_obj ( app , client ) : [EOL] class MyView : [EOL] async def get ( self , req , res ) : [EOL] pass [EOL] [EOL] app . route ( [string] ) ( MyView ( ) ) [EOL] assert client . get ( [string] ) . status_code == [number] [EOL] [EOL] [EOL] def test_parameter_is_passed_as_keyword_argument ( app , client ) : [EOL] @ app . route ( [string] ) async def greet ( req , res , person ) : [EOL] res . text = person [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . text == [string] [EOL] [EOL] [EOL] def test_match_path ( app , client ) : [EOL] @ app . route ( [string] ) async def items ( req , res , pk ) : [EOL] res . text = f" [string] { pk }" [EOL] [EOL] @ app . route ( [string] ) async def item_owner ( req , res , pk ) : [EOL] res . text = [string] [EOL] [EOL] @ app . route ( [string] ) async def item_with_path ( req , res , sink ) : [EOL] res . text = sink [EOL] [EOL] assert client . get ( [string] ) . text == [string] [EOL] assert client . get ( [string] ) . text == [string] [EOL] assert client . get ( [string] ) . text == [string] [EOL] [EOL] [EOL] def test_unknown_specifier ( app ) : [EOL] with pytest . raises ( TypeError ) as ctx : [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res , x ) : [EOL] pass [EOL] [EOL] error = str ( ctx . value ) . lower ( ) [EOL] for phrase in [string] , [string] , [string] : [EOL] assert phrase in error [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import multiprocessing [EOL] import requests [EOL] import typing [EOL] import builtins [EOL] import time [EOL] import typing [EOL] from contextlib import contextmanager [EOL] from multiprocessing import Value [EOL] [EOL] import requests [EOL] [EOL] [EOL] @ contextmanager def function_hooks ( expected_before = True , expected_after = True ) : [EOL] flags = { [string] : False , [string] : False } [EOL] [EOL] async def before ( req , res , params , value = expected_before ) : [EOL] nonlocal flags [EOL] assert not flags [ [string] ] [EOL] flags [ [string] ] = value [EOL] [EOL] async def after ( req , res , params , value = expected_after ) : [EOL] nonlocal flags [EOL] assert flags [ [string] ] [EOL] flags [ [string] ] = value [EOL] [EOL] yield before , after [EOL] [EOL] assert flags [ [string] ] is expected_before [EOL] assert flags [ [string] ] is expected_after [EOL] [EOL] [EOL] @ contextmanager def class_hooks ( ) : [EOL] flags = { [string] : False , [string] : False } [EOL] [EOL] class SetFlag : [EOL] def __init__ ( self , flag , value ) : [EOL] self . flag = flag [EOL] self . value = value [EOL] [EOL] async def __call__ ( self , req , res , params ) : [EOL] nonlocal flags [EOL] flags [ self . flag ] = self . value [EOL] [EOL] yield SetFlag ( [string] , True ) , SetFlag ( [string] , True ) [EOL] [EOL] assert flags [ [string] ] [EOL] assert flags [ [string] ] [EOL] [EOL] [EOL] def stops_incrementing ( counter , response , tolerance = [number] ) : [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def wait_for_events ( expect_many = False ) : [EOL] nonlocal counter [EOL] num_before = counter . value [EOL] time . sleep ( [number] ) [EOL] num_after = counter . value [EOL] if expect_many : [EOL] assert num_after - num_before >= [number] * tolerance , ( num_after , num_before , tolerance , ) [EOL] return num_after [EOL] [EOL] sent_before_closing = wait_for_events ( expect_many = True ) [EOL] response . close ( ) [EOL] sent_after_closing = wait_for_events ( ) - sent_before_closing [EOL] assert sent_after_closing <= tolerance , ( sent_after_closing , tolerance ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import App [EOL] [EOL] [EOL] def test_json_response ( app , client ) : [EOL] data = { [string] : [string] } [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . json = data [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . headers [ [string] ] == [string] [EOL] assert response . json ( ) == data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import bocadillo [EOL] from asyncio import sleep [EOL] from contextlib import contextmanager [EOL] [EOL] import pytest [EOL] [EOL] from bocadillo import App , ExpectedAsync , HTTPError , Middleware [EOL] [EOL] [EOL] def test_async_check ( app ) : [EOL] with pytest . raises ( ExpectedAsync ) : [EOL] [EOL] class BeforeMiddleware ( Middleware ) : [EOL] def before_dispatch ( self ) : [EOL] pass [EOL] [EOL] with pytest . raises ( ExpectedAsync ) : [EOL] [EOL] class AfterMiddleware ( Middleware ) : [EOL] def after_dispatch ( self ) : [EOL] pass [EOL] [EOL] [EOL] @ contextmanager def build_middleware ( expect_kwargs = None , expect_call_after = True ) : [EOL] called = { [string] : False , [string] : False } [EOL] kwargs = None [EOL] [EOL] class SetCalled ( Middleware ) : [EOL] def __init__ ( self , inner , ** kw ) : [EOL] super ( ) . __init__ ( inner ) [EOL] nonlocal kwargs [EOL] kwargs = kw [EOL] [EOL] async def before_dispatch ( self , req , res ) : [EOL] nonlocal called [EOL] await sleep ( [number] ) [EOL] called [ [string] ] = True [EOL] [EOL] async def after_dispatch ( self , req , res ) : [EOL] nonlocal called [EOL] await sleep ( [number] ) [EOL] called [ [string] ] = True [EOL] [EOL] yield SetCalled [EOL] [EOL] assert called [ [string] ] is True [EOL] assert called [ [string] ] is expect_call_after [EOL] [EOL] if expect_kwargs is not None : [EOL] kwargs . pop ( [string] , None ) [comment] [EOL] assert kwargs == expect_kwargs [EOL] [EOL] [EOL] def test_if_middleware_is_added_then_it_is_called ( app , client ) : [EOL] with build_middleware ( ) as middleware : [EOL] app . add_middleware ( middleware ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] client . get ( [string] ) [EOL] [EOL] [EOL] def test_extra_kwargs ( app , client ) : [EOL] kwargs = { [string] : [string] } [EOL] with build_middleware ( expect_kwargs = kwargs ) as middleware : [EOL] app . add_middleware ( middleware , ** kwargs ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] client . get ( [string] ) [EOL] [EOL] [EOL] def test_only_before_dispatch_is_called_if_method_not_allowed ( app , client ) : [EOL] with build_middleware ( expect_call_after = False ) as middleware : [EOL] app . add_middleware ( middleware ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] response = client . put ( [string] ) [EOL] assert response . status_code == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_errors_raised_in_callback_are_handled ( app , client , when ) : [EOL] class CustomError ( Exception ) : [EOL] pass [EOL] [EOL] @ app . error_handler ( CustomError ) async def handle_error ( req , res , exception ) : [EOL] res . text = [string] [EOL] [EOL] class MiddlewareWithErrors ( Middleware ) : [EOL] async def before_dispatch ( self , req , res ) : [EOL] if when == [string] : [EOL] raise CustomError [EOL] [EOL] async def after_dispatch ( self , req , res ) : [EOL] if when == [string] : [EOL] raise CustomError [EOL] [EOL] app . add_middleware ( MiddlewareWithErrors ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] def test_middleware_uses_registered_http_error_handler ( app , client ) : [EOL] @ app . error_handler ( HTTPError ) async def custom ( req , res , exc ) : [EOL] res . status_code = exc . status_code [EOL] res . text = [string] [EOL] [EOL] class NopeMiddleware ( Middleware ) : [EOL] async def before_dispatch ( self , req , res ) : [EOL] raise HTTPError ( [number] ) [EOL] [EOL] app . add_middleware ( NopeMiddleware ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] pass [EOL] [EOL] response = client . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . text == [string] [EOL] [EOL] [EOL] def test_return_response_in_before_hook ( app , client ) : [EOL] class NopeMiddleware ( Middleware ) : [EOL] async def before_dispatch ( self , req , res ) : [EOL] res . text = [string] [EOL] return res [EOL] [EOL] app . add_middleware ( NopeMiddleware ) [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] [comment] [EOL] assert False [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL] [EOL] [EOL] def test_middleware_called_if_routed_to_sub_app ( app , client ) : [EOL] with build_middleware ( ) as middleware : [EOL] app . add_middleware ( middleware ) [EOL] [EOL] sub = App ( ) [EOL] [EOL] @ sub . route ( [string] ) async def home ( req , res ) : [EOL] res . text = [string] [EOL] [EOL] app . mount ( [string] , sub ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert r . text == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from bocadillo import provider [EOL] [EOL] [EOL] @ provider async def hello_format ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ provider async def hello ( hello_format ) : [EOL] return hello_format . format ( who = [string] ) [EOL] [EOL] [EOL] @ provider ( name = [string] ) async def provide_foo ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ provider ( scope = [string] ) async def clients ( ) : [EOL] return set ( ) [EOL] [EOL] [EOL] CALLED = False [EOL] [EOL] [EOL] @ provider async def spy ( ) : [EOL] return { [string] : CALLED } [EOL] [EOL] [EOL] @ provider async def set_called ( ) : [EOL] global CALLED [EOL] CALLED = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0
from invoke import task [EOL] [EOL] [EOL] @ task def install ( c ) : [EOL] c . run ( [string] ) [EOL] c . run ( [string] ) [EOL] [EOL] [EOL] @ task def test ( c ) : [EOL] c . run ( [string] ) [EOL] [EOL] [EOL] @ task def coverage ( c , missing = False ) : [EOL] command = [string] [EOL] if missing : [EOL] command += [string] [EOL] c . run ( command ) [EOL] [EOL] [EOL] @ task def ci ( c ) : [EOL] c . run ( [string] ) [EOL] coverage ( c ) [EOL] [EOL] [EOL] @ task def apiref ( c ) : [EOL] c . run ( [string] ) [EOL] [EOL] [EOL] @ task def bumpversion ( c , level ) : [EOL] c . run ( [string] ) [EOL] c . run ( f" [string] { level }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from bocadillo import create_client , settings [EOL] [EOL] [EOL] def test_todos ( ) : [EOL] settings . _clear ( ) [EOL] from todos . asgi import app [EOL] [EOL] client = create_client ( app ) [EOL] [EOL] r = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert r . status_code == [number] [EOL] assert r . json ( ) == { [string] : [string] , [string] : False } [EOL] [EOL] r = client . post ( [string] , json = { [string] : [string] } , ) [EOL] assert r . status_code == [number] [EOL] assert [string] in r . json ( ) [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from bocadillo import configure [EOL] from . app import app [EOL] [EOL] configure ( app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import App [EOL] from . models import Todo [EOL] [EOL] app = App ( ) [EOL] [EOL] [EOL] @ app . route ( [string] ) class TodoList : [EOL] async def post ( self , req , res ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] todo = Todo . validate ( await req . json ( ) ) [EOL] [EOL] [comment] [EOL] [EOL] res . json = dict ( todo ) [EOL] res . status_code = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import Type [EOL] import validation [EOL] import typing [EOL] import docs [EOL] import typesystem [EOL] [EOL] [EOL] class Todo ( typesystem . Schema ) : [EOL] title = typesystem . String ( max_length = [number] ) [EOL] done = typesystem . Boolean ( default = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Dict , Any , Union , List [EOL] import typing [EOL] import bocadillo [EOL] from bocadillo import App , configure [EOL] from . import settings [EOL] [EOL] app = App ( ) [EOL] configure ( app , settings ) [EOL] [EOL] [EOL] TODOS = [ { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } , ] [EOL] [EOL] [EOL] @ app . route ( [string] ) async def get_unseen_todos ( req , res ) : [EOL] last_id = req . session . get ( [string] , - [number] ) [EOL] unseen_todos = TODOS [ last_id + [number] : ] [EOL] [EOL] if unseen_todos : [EOL] req . session [ [string] ] = unseen_todos [ - [number] ] [ [string] ] [EOL] [EOL] res . json = unseen_todos [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) async def create_todo ( req , res ) : [EOL] json = await req . json ( ) [EOL] todo = { [string] : len ( TODOS ) + [number] , [string] : json [ [string] ] } [EOL] TODOS . append ( todo ) [EOL] res . status_code = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] import pytest [EOL] [EOL] from bocadillo import create_client , settings [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True , scope = [string] ) def setup_env ( ) : [EOL] os . environ [ [string] ] = [string] [EOL] yield [EOL] os . environ . pop ( [string] ) [EOL] [EOL] [EOL] def test_todos ( ) : [EOL] settings . _clear ( ) [EOL] from . app import app [EOL] [EOL] client = create_client ( app ) [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert len ( r . json ( ) ) == [number] [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert len ( r . json ( ) ) == [number] [EOL] [EOL] r = client . post ( [string] , json = { [string] : [string] } ) [EOL] assert r . status_code == [number] [EOL] [EOL] r = client . get ( [string] ) [EOL] assert r . status_code == [number] [EOL] assert len ( r . json ( ) ) == [number] [EOL] assert r . json ( ) [ [number] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] from starlette . config import Config [EOL] from starlette . datastructures import Secret [EOL] [EOL] config = Config ( [string] ) [EOL] [EOL] SESSIONS = { [string] : config ( [string] , cast = Secret ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] import builtins [EOL] import bocadillo [EOL] from bocadillo import App , provider , Templates [EOL] [EOL] app = App ( ) [EOL] templates = Templates ( ) [EOL] [EOL] [EOL] @ provider ( scope = [string] ) async def history ( ) : [EOL] return [ ] [EOL] [EOL] [EOL] @ provider ( scope = [string] ) async def clients ( ) : [EOL] return set ( ) [EOL] [EOL] [EOL] @ app . websocket_route ( [string] , value_type = [string] ) async def chat ( ws , history , clients ) : [EOL] [comment] [EOL] print ( [string] , ws ) [EOL] clients . add ( ws ) [EOL] [EOL] [comment] [EOL] for message in history : [EOL] await ws . send ( message ) [EOL] [EOL] try : [EOL] [comment] [EOL] async for message in ws : [EOL] print ( [string] , message ) [EOL] history . append ( message ) [EOL] if message [ [string] ] == [string] : [EOL] for client in clients : [EOL] await client . send ( message ) [EOL] finally : [EOL] print ( [string] , ws ) [EOL] clients . remove ( ws ) [EOL] [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . html = await templates . render ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 $bocadillo.templates.Templates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.set$ 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.templates.Templates$ 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] import asyncio [EOL] from contextlib import suppress [EOL] import websockets [EOL] [EOL] [EOL] async def client ( url ) : [EOL] async with websockets . connect ( url ) as websocket : [EOL] while True : [EOL] message = input ( [string] ) [EOL] await websocket . send ( message ) [EOL] response = await websocket . recv ( ) [EOL] print ( response ) [EOL] [EOL] [EOL] with suppress ( KeyboardInterrupt ) : [EOL] [comment] [EOL] asyncio . run ( client ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
def test_connect_and_converse ( client ) : [EOL] with client . websocket_connect ( [string] ) as ws : [EOL] ws . send_text ( [string] ) [EOL] assert ws . receive_text ( ) == [string] [EOL] [EOL] [EOL] def test_client_count ( client ) : [EOL] assert client . get ( [string] ) . json ( ) == { [string] : [number] } [EOL] [EOL] with client . websocket_connect ( [string] ) : [EOL] assert client . get ( [string] ) . json ( ) == { [string] : [number] } [EOL] [EOL] assert client . get ( [string] ) . json ( ) == { [string] : [number] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] from bocadillo import provider , create_client [EOL] [EOL] from chatbot . app import app [EOL] [EOL] [EOL] @ provider def diego ( ) : [EOL] class EchoDiego : [EOL] def get_response ( self , query ) : [EOL] return query [EOL] [EOL] return EchoDiego ( ) [EOL] [EOL] [EOL] @ pytest . fixture def client ( ) : [EOL] return create_client ( app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from contextlib import contextmanager [EOL] [EOL] from bocadillo import provider [EOL] [EOL] [EOL] @ provider ( scope = [string] ) def diego ( ) : [EOL] from . bot import diego [EOL] [EOL] return diego [EOL] [EOL] [EOL] @ provider ( scope = [string] ) def clients ( ) : [EOL] return set ( ) [EOL] [EOL] [EOL] @ provider def save_client ( clients ) : [EOL] @ contextmanager def _save ( ws ) : [EOL] clients . add ( ws ) [EOL] try : [EOL] yield ws [EOL] finally : [EOL] clients . remove ( ws ) [EOL] [EOL] return _save [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import bocadillo [EOL] [docstring] [EOL] from bocadillo import App [EOL] [EOL] app = App ( ) [EOL] [EOL] [EOL] @ app . websocket_route ( [string] ) async def converse ( ws , diego , save_client ) : [EOL] with save_client ( ws ) : [EOL] async for message in ws : [EOL] response = diego . get_response ( message ) [EOL] await ws . send ( str ( response ) ) [EOL] [EOL] [EOL] @ app . route ( [string] ) async def client_count ( req , res , clients ) : [EOL] res . json = { [string] : len ( clients ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from bocadillo import configure [EOL] from . app import app [EOL] from . import settings [EOL] [EOL] configure ( app , settings ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from starlette . config import Config [EOL] [EOL] config = Config ( [string] ) [EOL] [EOL] PROVIDER_MODULES = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] from chatterbot import ChatBot [EOL] from chatterbot . trainers import ChatterBotCorpusTrainer [EOL] [EOL] diego = ChatBot ( [string] ) [EOL] [EOL] trainer = ChatterBotCorpusTrainer ( diego ) [EOL] trainer . train ( [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
import bocadillo [EOL] from datetime import datetime [EOL] from asyncio import sleep [EOL] from bocadillo import App , server_event [EOL] [EOL] app = App ( ) [EOL] [EOL] [EOL] @ app . route ( [string] ) async def clock ( req , res ) : [EOL] @ res . event_stream async def stream ( ) : [EOL] while True : [EOL] millis = datetime . now ( ) . timestamp ( ) * [number] [EOL] yield server_event ( data = str ( millis ) ) [EOL] await sleep ( [number] ) [EOL] [EOL] [EOL] @ app . route ( [string] ) async def index ( req , res ) : [EOL] res . html = [string] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bocadillo.applications.App$ 0 0 0 0 0