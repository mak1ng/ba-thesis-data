[comment] [EOL] from typing import Any , List , Dict [EOL] import typing [EOL] import argparse [EOL] import subprocess [EOL] import builtins [EOL] import pathlib [EOL] [docstring] [EOL] import argparse [EOL] import os [EOL] import pathlib [EOL] import subprocess [EOL] import sys [EOL] import tempfile [EOL] [EOL] [EOL] [comment] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] , action = [string] ) [EOL] args = parser . parse_args ( ) [EOL] overwrite = bool ( args . overwrite ) [EOL] [EOL] here = pathlib . Path ( os . path . abspath ( __file__ ) ) . parent [EOL] src_dir = here . parent . parent . parent . parent [EOL] [EOL] env = os . environ . copy ( ) [EOL] if [string] in env : [EOL] env [ [string] ] = [string] . format ( src_dir , env [ [string] ] ) [EOL] else : [EOL] env [ [string] ] = ( here / [string] ) . as_posix ( ) [EOL] [EOL] pths = sorted ( here . glob ( [string] ) ) [EOL] [EOL] for subpth in here . iterdir ( ) : [EOL] if subpth . is_dir ( ) and not subpth . name . startswith ( [string] ) : [EOL] pths . extend ( subpth . glob ( [string] ) ) [EOL] [EOL] pths = [ x for x in pths if [string] not in x . as_posix ( ) ] [EOL] [EOL] [comment] [EOL] subprocess . check_call ( [ [string] , [string] ] , env = env , cwd = here . as_posix ( ) ) [EOL] [EOL] [comment] [EOL] for pth in pths : [EOL] if overwrite : [EOL] retcode = subprocess . call ( [ [string] , [string] , [string] , pth . as_posix ( ) ] , env = env ) [EOL] if retcode != [number] : [EOL] raise RuntimeError ( [string] . format ( pth ) ) [EOL] else : [EOL] out = subprocess . check_output ( [ [string] , [string] , [string] , pth . as_posix ( ) ] , env = env ) [EOL] if len ( out ) != [number] : [EOL] print ( [string] . format ( pth ) ) [EOL] return [number] [EOL] [EOL] [comment] [EOL] for pth in pths : [EOL] if overwrite : [EOL] retcode = subprocess . call ( [ [string] , [string] , pth . as_posix ( ) ] ) [EOL] if retcode != [number] : [EOL] raise RuntimeError ( [string] . format ( pth ) ) [EOL] else : [EOL] with tempfile . NamedTemporaryFile ( ) as tmpfile : [EOL] file = tmpfile . file [comment] [EOL] retcode = subprocess . call ( [ [string] , pth . as_posix ( ) ] , universal_newlines = True , env = env , stdout = file ) [EOL] if retcode != [number] : [EOL] raise RuntimeError ( [string] . format ( pth ) ) [EOL] [EOL] file . flush ( ) [EOL] proc = subprocess . Popen ( [ [string] , tmpfile . name , pth . as_posix ( ) ] , stderr = subprocess . STDOUT , stdout = subprocess . PIPE , universal_newlines = True ) [EOL] [EOL] out , _ = proc . communicate ( ) [EOL] if proc . returncode != [number] : [EOL] raise RuntimeError ( [string] . format ( pth , out ) ) [EOL] [EOL] packages = [ pathlib . Path ( line ) for line in subprocess . check_output ( [ [string] , [string] , [string] ] , universal_newlines = True , env = env ) . splitlines ( ) if line . strip ( ) ] [EOL] [EOL] packages = [ pkg for pkg in packages if [string] not in pkg . parents ] [EOL] [EOL] subprocess . check_call ( [ [string] , [string] ] + [ pkg . as_posix ( ) for pkg in packages ] , env = env , cwd = here . as_posix ( ) ) [EOL] [EOL] subprocess . check_call ( [ [string] ] + [ pkg . as_posix ( ) for pkg in packages ] , env = env , cwd = here . as_posix ( ) ) [EOL] [EOL] subprocess . check_call ( [ [string] ] + [ pkg . as_posix ( ) for pkg in packages ] , env = env , cwd = here . as_posix ( ) ) [EOL] [EOL] for pkg in packages : [EOL] subprocess . check_call ( [ [string] , [string] , pkg . as_posix ( ) ] , env = env , cwd = here . as_posix ( ) ) [EOL] [EOL] subprocess . check_call ( [ [string] , [string] , [string] ] , env = env , cwd = here . as_posix ( ) ) [EOL] [EOL] [comment] [EOL] version_rel = subprocess . check_output ( [ [string] , [string] , [string] , [string] ] , cwd = here . as_posix ( ) , env = env , universal_newlines = True ) . strip ( ) [EOL] version_ctl = subprocess . check_output ( [ [string] , [string] , [string] , [string] ] , cwd = here . as_posix ( ) , env = env , universal_newlines = True ) . strip ( ) [EOL] if version_ctl != version_rel : [EOL] raise RuntimeError ( [string] [string] . format ( version_rel , version_ctl ) ) [EOL] [EOL] [comment] [EOL] changelog_pth = here / [string] [EOL] with changelog_pth . open ( [string] ) as fid : [EOL] changelog_lines = fid . read ( ) . splitlines ( ) [EOL] [EOL] if len ( changelog_lines ) < [number] : [EOL] raise RuntimeError ( [string] . format ( changelog_pth , len ( changelog_lines ) ) ) [EOL] [EOL] [comment] [EOL] changelog_version = changelog_lines [ [number] ] [EOL] [EOL] if version_ctl != changelog_version : [EOL] raise AssertionError ( ( [string] [string] ) . format ( changelog_pth , changelog_version , version_ctl ) ) [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict [EOL] import argparse [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import os [EOL] import pathlib [EOL] import shutil [EOL] import subprocess [EOL] import sys [EOL] import tempfile [EOL] import textwrap [EOL] [EOL] [EOL] [comment] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] , required = True ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] release_dir = pathlib . Path ( args . release_dir ) [EOL] [EOL] release_dir . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] bin_dir = release_dir / [string] [EOL] bin_dir . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] pkg_dir = release_dir / [string] [EOL] pkg_dir . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] env = os . environ . copy ( ) [EOL] if [string] in env : [EOL] env [ [string] ] = [string] . format ( release_dir . as_posix ( ) , env [ [string] ] ) [EOL] else : [EOL] env [ [string] ] = release_dir . as_posix ( ) [EOL] [EOL] env [ [string] ] = bin_dir . as_posix ( ) [EOL] env [ [string] ] = pkg_dir . as_posix ( ) [EOL] [EOL] [comment] [EOL] script_dir = pathlib . Path ( os . path . dirname ( os . path . realpath ( __file__ ) ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] . format ( env [ [string] ] ) ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] , [string] ] , env = env , cwd = script_dir . as_posix ( ) ) [EOL] [EOL] go_bin_dir = release_dir / [string] [EOL] mailgun_relayery_pth = go_bin_dir / [string] [EOL] [EOL] [comment] [EOL] version = subprocess . check_output ( [ mailgun_relayery_pth . as_posix ( ) , [string] ] , universal_newlines = True ) . strip ( ) [EOL] [EOL] filenames = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] . format ( release_dir ) ) [EOL] with tempfile . TemporaryDirectory ( ) as tmp_dir : [EOL] bin_package_dir = pathlib . Path ( tmp_dir ) / [string] . format ( version ) [EOL] [EOL] ( bin_package_dir / [string] ) . mkdir ( parents = True ) [EOL] [EOL] for filename in filenames : [EOL] source_pth = go_bin_dir / filename [EOL] target_pth = bin_package_dir / [string] / filename [EOL] shutil . copy ( source_pth . as_posix ( ) , target_pth . as_posix ( ) ) [EOL] [EOL] tar_path = bin_package_dir . parent / [string] . format ( version ) [EOL] [EOL] subprocess . check_call ( [ [string] , [string] , tar_path . as_posix ( ) , [string] . format ( version ) ] , cwd = bin_package_dir . parent . as_posix ( ) ) [EOL] [EOL] shutil . move ( tar_path . as_posix ( ) , ( release_dir / tar_path . name ) . as_posix ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] . format ( release_dir ) ) [EOL] with tempfile . TemporaryDirectory ( ) as tmp_dir : [EOL] deb_package_dir = pathlib . Path ( tmp_dir ) / [string] . format ( version ) [EOL] [EOL] ( deb_package_dir / [string] ) . mkdir ( parents = True ) [EOL] for filename in filenames : [EOL] source_pth = go_bin_dir / filename [EOL] target_pth = deb_package_dir / [string] / filename [EOL] [EOL] shutil . copy ( source_pth . as_posix ( ) , target_pth . as_posix ( ) ) [EOL] [EOL] control_pth = deb_package_dir / [string] [EOL] control_pth . parent . mkdir ( parents = True ) [EOL] [EOL] control_pth . write_text ( textwrap . dedent ( [string] . format ( version = version ) ) ) [EOL] [EOL] subprocess . check_call ( [ [string] , [string] , deb_package_dir . as_posix ( ) ] , cwd = deb_package_dir . parent . as_posix ( ) , stdout = subprocess . DEVNULL ) [EOL] [EOL] deb_pth = deb_package_dir . parent / [string] . format ( version ) [EOL] [EOL] shutil . move ( deb_pth . as_posix ( ) , ( release_dir / deb_pth . name ) . as_posix ( ) ) [EOL] [EOL] print ( [string] . format ( release_dir ) ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pathlib [EOL] [docstring] [EOL] import pathlib [EOL] [EOL] import icontract [EOL] import lmdb [EOL] [EOL] [comment] [EOL] DB_CHANNEL_KEY = [string] . encode ( ) [comment] [EOL] [EOL] [comment] [EOL] DB_TIMESTAMP_KEY = [string] . encode ( ) [comment] [EOL] [EOL] [EOL] @ icontract . require ( lambda database_dir : database_dir . exists ( ) ) def initialize_environment ( database_dir ) : [EOL] [docstring] [EOL] with lmdb . open ( path = database_dir . as_posix ( ) , map_size = [number] * [number] * [number] * [number] , max_dbs = [number] , readonly = False ) as env : [EOL] env . open_db ( DB_CHANNEL_KEY , create = True ) [EOL] env . open_db ( DB_TIMESTAMP_KEY , create = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Optional [EOL] import typing [EOL] import builtins [EOL] import subprocess [EOL] [docstring] [EOL] import subprocess [EOL] from typing import Optional [EOL] [EOL] import time [EOL] [EOL] import tests . siger [EOL] [EOL] [EOL] class terminating : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , proc , timeout = None ) : [EOL] [docstring] [EOL] self . proc = proc [EOL] self . timeout = timeout [EOL] [EOL] def __enter__ ( self ) : [EOL] return self . proc [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] terminate_or_kill ( proc = self . proc , timeout = self . timeout ) [EOL] [EOL] [EOL] def sleep_while_process ( proc , seconds ) : [EOL] [docstring] [EOL] elapsed = [number] [EOL] while proc . poll ( ) is None and elapsed < seconds : [EOL] sleep_for ( seconds = [number] ) [EOL] elapsed += [number] [EOL] [EOL] [EOL] def terminate_or_kill ( proc , timeout = None ) : [EOL] [docstring] [EOL] if proc . poll ( ) is None : [EOL] proc . terminate ( ) [EOL] try : [EOL] proc . wait ( timeout = timeout ) [EOL] except subprocess . TimeoutExpired : [EOL] proc . kill ( ) [EOL] proc . communicate ( ) [EOL] [EOL] [EOL] def sleep_for ( seconds ) : [EOL] [docstring] [EOL] if seconds <= [number] : [EOL] return [EOL] [EOL] rest = seconds [EOL] while rest > [number] : [EOL] if rest > [number] : [EOL] sleep = [number] [EOL] else : [EOL] sleep = rest [EOL] [EOL] rest -= sleep [EOL] [EOL] time . sleep ( sleep ) [EOL] if tests . siger . Siger . done ( ) : [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $subprocess.Popen[typing.Any]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $subprocess.Popen$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import signal [EOL] [EOL] import logthis [EOL] [EOL] [EOL] class Siger : [EOL] [docstring] [EOL] [EOL] __done = False [EOL] [EOL] @ staticmethod def initialize_signal_handlers ( ) : [EOL] [docstring] [EOL] signal . signal ( signal . SIGINT , Siger . signal_handler ) [EOL] signal . signal ( signal . SIGTERM , Siger . signal_handler ) [EOL] [EOL] @ staticmethod def signal_handler ( signalnum , frame ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] signalstr = signal . Signals ( signalnum ) . name [comment] [EOL] logthis . say ( [string] . format ( signalnum , signalstr ) ) [EOL] Siger . __done = True [EOL] [EOL] @ staticmethod def done ( ) : [EOL] [docstring] [EOL] return Siger . __done [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0