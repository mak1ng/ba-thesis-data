from videoarchiver . video_archiver import VideoArchiver [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] VideoArchiver . execute ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from tests . testlibraries . instance_resource import COOKIES_STREAMING_EXAMPLE [EOL] from videoarchiver . cookie_converter import CookieConverter [EOL] [EOL] [EOL] class TestCookieConverter : [EOL] @ staticmethod def test_convert_cookie_dict_to_string ( ) : [EOL] assert CookieConverter . convert_requests_cookie_jar_to_string ( COOKIES_STREAMING_EXAMPLE ) == ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import m3u8 [EOL] [EOL] from tests . testlibraries . instance_resource import FILE_PLAYLIST_TEST_DATA , URL_PLAYLIST , URI_EXAMPLE , PLAYLIST_2800000 , PLAYLIST_1700000 [EOL] from videoarchiver . m3u8_handler import M3U8Handler [EOL] [EOL] [EOL] class TestM3U8Handler : [EOL] @ staticmethod def test_extract_highest_quality_streaming_url ( ) : [EOL] m3u8_object = m3u8 . loads ( FILE_PLAYLIST_TEST_DATA . read_text ( ) , URL_PLAYLIST ) [EOL] assert M3U8Handler . extract_highest_quality_streaming_url ( m3u8_object ) . uri == URI_EXAMPLE [EOL] [EOL] @ staticmethod def test_return_higher_quality ( ) : [EOL] M3U8Handler . return_higher_quality ( PLAYLIST_2800000 , PLAYLIST_1700000 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from videoarchiver . windows import Windows [EOL] [EOL] [EOL] class TestWindows : [EOL] @ staticmethod def test_replace_disallow_character ( ) : [EOL] assert Windows . replace_disallow_character ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import videoarchiver [EOL] from tests . testlibraries . instance_resource import InstanceResource [EOL] from videoarchiver import Config [EOL] [EOL] [EOL] class TestConfig : [EOL] @ staticmethod def test_load ( ) : [EOL] config = Config ( ) [EOL] config . load ( InstanceResource . PATH_FILE_CONFIG_FOR_TEST ) [EOL] config_tb_asahi = config . tv_asahi [EOL] assert config_tb_asahi . mail_address == [string] [EOL] assert config_tb_asahi . password == [string] [EOL] [comment] [EOL] assert config_tb_asahi . list_program_id [ [number] ] == [string] [EOL] assert config_tb_asahi . list_program_id [ [number] ] == [string] [EOL] config_niconico = config . niconico [EOL] assert config_niconico . mail_address == [string] [EOL] assert config_niconico . password == [string] [EOL] assert config_niconico . list_program_id [ [number] ] == [string] [EOL] assert config_niconico . list_program_id [ [number] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.config.Config$ 0 0 0 0 0 $videoarchiver.config.Config$ 0 0 0 0 0 0 0 0 $videoarchiver.config.TvAsahiConfig$ 0 $videoarchiver.config.Config$ 0 0 0 0 $videoarchiver.config.TvAsahiConfig$ 0 0 0 0 0 0 $videoarchiver.config.TvAsahiConfig$ 0 0 0 0 0 0 0 0 $videoarchiver.config.TvAsahiConfig$ 0 0 0 0 0 0 0 0 0 $videoarchiver.config.TvAsahiConfig$ 0 0 0 0 0 0 0 0 $videoarchiver.config.NiconicoConfig$ 0 $videoarchiver.config.Config$ 0 0 0 0 $videoarchiver.config.NiconicoConfig$ 0 0 0 0 0 0 $videoarchiver.config.NiconicoConfig$ 0 0 0 0 0 0 $videoarchiver.config.NiconicoConfig$ 0 0 0 0 0 0 0 0 0 $videoarchiver.config.NiconicoConfig$ 0 0 0 0 0 0 0 0
	0
import pytest [EOL] [EOL] from tests . testlibraries . instance_resource import InstanceResource [EOL] from videoarchiver import CONFIG [EOL] [EOL] [EOL] @ pytest . fixture def yaml_config_load ( ) : [EOL] [docstring] [EOL] CONFIG . load ( InstanceResource . PATH_FILE_CONFIG_FOR_TEST ) [EOL] yield [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import requests [EOL] from requests . cookies import create_cookie [EOL] [EOL] from tests . testlibraries . additional_matcher_factory import AdditionalMatcherFactory [EOL] from tests . testlibraries . cookie_jar_factory import RequestsCookieJarFactory [EOL] from videoarchiver . niconico . client_for_back_end import ClientForBackEnd [EOL] COOKIES_LOGIN_EXAMPLE = RequestsCookieJarFactory . create ( [ create_cookie ( [string] , [string] , domain = [string] , path = [string] , expires = [number] , discard = False , rest = { } , ) , create_cookie ( [string] , [string] , domain = [string] , path = [string] , secure = True , expires = [number] , discard = False , ) , ] ) [EOL] [EOL] [EOL] class TestClientForBackEnd : [EOL] [comment] [EOL] @ staticmethod def test_login ( requests_mock , yaml_config_load ) : [EOL] print ( ) [EOL] mail_address = [string] [EOL] password = [string] [EOL] requests_mock . post ( [string] , cookies = COOKIES_LOGIN_EXAMPLE , additional_matcher = AdditionalMatcherFactory . create_request_data_matcher ( { [string] : mail_address , [string] : password } ) ) [EOL] assert ClientForBackEnd . login ( ) == COOKIES_LOGIN_EXAMPLE [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0
	0
from typing import Dict , Callable [EOL] import typing [EOL] import requests [EOL] import builtins [EOL] from typing import Dict , Callable [EOL] import urllib . parse [EOL] [EOL] from requests import PreparedRequest [EOL] [EOL] [EOL] class AdditionalMatcherFactory : [EOL] [docstring] [EOL] @ staticmethod def create_request_data_matcher ( data ) : [EOL] def additional_matcher ( request ) : [EOL] return request . body == [string] . join ( [ f'{ urllib . parse . quote ( key ) } [string] { urllib . parse . quote ( value ) }' for key , value in data . items ( ) ] ) [EOL] return additional_matcher [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[requests.PreparedRequest],builtins.bool]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $requests.PreparedRequest$ 0 0 0 0 $requests.PreparedRequest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import http [EOL] import typing [EOL] import requests [EOL] from http . cookiejar import Cookie [EOL] from typing import List [EOL] [EOL] from requests . cookies import RequestsCookieJar [EOL] [EOL] [EOL] class RequestsCookieJarFactory : [EOL] @ staticmethod def create ( list_cookie ) : [EOL] cookie_jar = RequestsCookieJar ( ) [EOL] for cookie in list_cookie : [EOL] cookie_jar . set ( cookie . name , cookie . value , domain = cookie . domain , path = cookie . path ) [EOL] return cookie_jar [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 $typing.List[http.cookiejar.Cookie]$ 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 0 0 0 $typing.List[http.cookiejar.Cookie]$ 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0
from typing import Any [EOL] import typing [EOL] import requests [EOL] import builtins [EOL] import pathlib [EOL] from pathlib import Path [EOL] [EOL] [comment] [EOL] import ffmpeg [EOL] from requests . cookies import RequestsCookieJar [EOL] [EOL] from videoarchiver . cookie_converter import CookieConverter [EOL] [EOL] [EOL] class StreamFactory : [EOL] RUN = [string] [EOL] @ staticmethod def create_stream_expect ( cookies_streaming , path_file , uri ) : [EOL] cookies_string = CookieConverter . convert_requests_cookie_jar_to_string ( cookies_streaming ) [EOL] stream = ffmpeg . input ( uri , headers = f' [string] { cookies_string } [string] ' , copytb = [string] ) [EOL] stream = ffmpeg . output ( stream , str ( path_file ) , f = [string] , c = [string] ) [EOL] return stream [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import List [EOL] import videoarchiver [EOL] import typing [EOL] import json [EOL] [EOL] from tests . testlibraries . instance_resource import FILE_JSON_EPISODE_DATA_EXAMPLE_01 [EOL] from videoarchiver . tvasahi . dictionary_converter import DictionaryConverter [EOL] [EOL] [EOL] class TestDictionaryConverter : [EOL] @ staticmethod def test_convert_to_list ( ) : [EOL] [docstring] [EOL] list_episode = DictionaryConverter . convert_to_list ( json . loads ( FILE_JSON_EPISODE_DATA_EXAMPLE_01 . read_text ( encoding = [string] ) ) [ [string] ] ) [EOL] assert list_episode [ [number] ] . episode_name == [string] [EOL] [EOL] @ staticmethod def test_convert_to_model ( ) : [EOL] [docstring] [EOL] episode = DictionaryConverter . convert_to_model ( json . loads ( FILE_JSON_EPISODE_DATA_EXAMPLE_01 . read_text ( encoding = [string] ) ) [ [string] ] [ [number] ] ) [EOL] assert episode . episode_name == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.models.Episode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.models.Episode$ 0 0 0 0 0
from typing import List [EOL] import videoarchiver [EOL] import typing [EOL] from bs4 import BeautifulSoup [EOL] [EOL] from tests . testlibraries . instance_resource import FILE_HTML_PROGRAM_HOME , FILE_HTML_EPISODE , FILE_JSON_EPISODE_DATA_EXAMPLE_01 , FILE_JSON_EPISODE_DATA_EXAMPLE_02 , FILE_JSON_EPISODE_DATA_EXAMPLE_03 , InstanceResource [EOL] from videoarchiver . tvasahi . episode_loader import EpisodeLoader [EOL] from videoarchiver . tvasahi . html_analyzer import HtmlAnalyzer [EOL] [EOL] [EOL] class TestEpisodeLoader : [EOL] @ staticmethod def test_load_backup ( ) : [EOL] list_episode = EpisodeLoader ( InstanceResource . PATH_TEST_RESOURCES ) . load_backup ( [string] ) [EOL] assert len ( list_episode ) == [number] [EOL] assert list_episode [ [number] ] . episode_name == [string] [EOL] [EOL] @ staticmethod def test_list_up_episode ( requests_mock , tmp_path ) : [EOL] program_id_string = [string] [EOL] requests_mock . get ( f' [string] { program_id_string }' , text = FILE_HTML_PROGRAM_HOME . read_text ( encoding = [string] ) ) [EOL] requests_mock . get ( [string] , text = FILE_JSON_EPISODE_DATA_EXAMPLE_01 . read_text ( encoding = [string] ) ) [EOL] requests_mock . get ( [string] , text = FILE_JSON_EPISODE_DATA_EXAMPLE_02 . read_text ( encoding = [string] ) ) [EOL] requests_mock . get ( [string] , text = FILE_JSON_EPISODE_DATA_EXAMPLE_03 . read_text ( encoding = [string] ) ) [EOL] EpisodeLoader ( tmp_path ) . list_up_episode ( program_id_string ) [EOL] [EOL] @ staticmethod def test__list_up_episode ( requests_mock , tmp_path ) : [EOL] requests_mock . get ( [string] , text = FILE_JSON_EPISODE_DATA_EXAMPLE_01 . read_text ( encoding = [string] ) ) [EOL] requests_mock . get ( [string] , text = FILE_JSON_EPISODE_DATA_EXAMPLE_02 . read_text ( encoding = [string] ) ) [EOL] requests_mock . get ( [string] , text = FILE_JSON_EPISODE_DATA_EXAMPLE_03 . read_text ( encoding = [string] ) ) [EOL] html_analyzer = HtmlAnalyzer ( BeautifulSoup ( FILE_HTML_EPISODE . read_text ( encoding = [string] ) , [string] ) ) [EOL] program_id_string = [string] [EOL] with ( tmp_path / f'{ program_id_string } [string] ' ) . open ( [string] , encoding = [string] , newline = [string] ) as file_backup : [EOL] [comment] [EOL] list_episode = EpisodeLoader . _list_up_episode ( file_backup , html_analyzer , program_id_string ) [EOL] assert list_episode [ [number] ] . episode_name == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.html_analyzer.HtmlAnalyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 0 0 0 0 $videoarchiver.tvasahi.html_analyzer.HtmlAnalyzer$ 0 $builtins.str$ 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 0 0 0 0 0
import videoarchiver [EOL] import pytest [EOL] [EOL] from tests . testlibraries . instance_resource import FILE_JAVA_SCRIPT_TEST_DATA [EOL] from videoarchiver . tvasahi . java_script_analyzer import JavaScriptAnalyzer [EOL] [EOL] [EOL] class TestJavaScriptAnalyzer : [EOL] @ staticmethod def test_extract_variable ( ) : [EOL] java_script_analyzer = JavaScriptAnalyzer ( FILE_JAVA_SCRIPT_TEST_DATA . read_text ( encoding = [string] ) ) [EOL] assert java_script_analyzer . extract_variable ( [string] ) == [number] [EOL] assert java_script_analyzer . extract_variable ( [string] ) == [number] [EOL] [EOL] @ staticmethod @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) , ( [string] , [number] ) , ] ) def test_extract_variable_from_definition_line ( definition_line , expected ) : [EOL] [docstring] [EOL] assert JavaScriptAnalyzer . extract_variable_from_definition_line ( definition_line ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.java_script_analyzer.JavaScriptAnalyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.java_script_analyzer.JavaScriptAnalyzer$ 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.java_script_analyzer.JavaScriptAnalyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import typing [EOL] import requests [EOL] from unittest . mock import patch [EOL] [EOL] from bs4 import BeautifulSoup [EOL] import m3u8 [EOL] from m3u8 import Playlist [EOL] [EOL] from tests . testlibraries . additional_matcher_factory import AdditionalMatcherFactory [EOL] from tests . testlibraries . instance_resource import FILE_PLAYLIST_TEST_DATA , FILE_HTML_PROGRAM_HOME , FILE_HTML_EPISODE , BINARY_JPEG_EXAMPLE , COOKIES_DICTIONARY_LOGIN_EXAMPLE , COOKIES_LOGIN_EXAMPLE , COOKIES_STREAMING_EXAMPLE , EPISODE_EXAMPLE , EXTRA_LARGE_IMAGE_URL_EXAMPLE , URL_PLAYLIST , URI_EXAMPLE , M3U8_CONTENT_EXAMPLE , PATH_FILE [EOL] from tests . testlibraries . stream_factory import StreamFactory [EOL] from videoarchiver . tvasahi . client_for_back_end import ClientForBackEnd , Payload [EOL] [EOL] [EOL] class TestClientForBackEnd : [EOL] @ staticmethod def test_login ( requests_mock ) : [EOL] mail_address = [string] [EOL] password = [string] [EOL] requests_mock . post ( [string] , cookies = COOKIES_LOGIN_EXAMPLE , additional_matcher = AdditionalMatcherFactory . create_request_data_matcher ( { [string] : mail_address , [string] : password } ) ) [EOL] assert ClientForBackEnd . login ( ) == COOKIES_LOGIN_EXAMPLE [EOL] [EOL] @ staticmethod def test_request_program_home_page ( requests_mock ) : [EOL] html_episode = FILE_HTML_EPISODE . read_text ( encoding = [string] ) [EOL] program_id_string = [string] [EOL] requests_mock . get ( f' [string] { program_id_string }' , text = html_episode , headers = { [string] : f' [string] { program_id_string }' , [string] : [string] , } , cookies = None ) [EOL] assert ClientForBackEnd . request_program_home_page ( program_id_string ) == BeautifulSoup ( html_episode , [string] ) [EOL] [EOL] @ staticmethod def test_request_episode_home_page ( requests_mock ) : [EOL] html_program_home = FILE_HTML_PROGRAM_HOME . read_text ( encoding = [string] ) [EOL] requests_mock . get ( f' [string] { EPISODE_EXAMPLE . directory } [string] { str ( EPISODE_EXAMPLE . episode_num ) }' , text = html_program_home , headers = { [string] : f' [string] { EPISODE_EXAMPLE . directory }' , [string] : [string] , } , cookies = COOKIES_DICTIONARY_LOGIN_EXAMPLE ) [EOL] assert ClientForBackEnd . request_episode_page ( EPISODE_EXAMPLE , COOKIES_DICTIONARY_LOGIN_EXAMPLE ) == BeautifulSoup ( html_program_home , [string] ) [EOL] [EOL] @ staticmethod def test_request_html ( requests_mock ) : [EOL] request_url = [string] [EOL] html_program_home = FILE_HTML_PROGRAM_HOME . read_text ( encoding = [string] ) [EOL] program_id_string = [string] [EOL] requests_mock . get ( request_url , text = html_program_home , headers = { [string] : f' [string] { program_id_string }' , [string] : [string] , } , cookies = COOKIES_DICTIONARY_LOGIN_EXAMPLE ) [EOL] assert ClientForBackEnd . request_html ( request_url , program_id_string , COOKIES_DICTIONARY_LOGIN_EXAMPLE ) == BeautifulSoup ( html_program_home , [string] ) [EOL] [EOL] @ staticmethod def test_request_cookie ( requests_mock ) : [EOL] requests_mock . get ( URL_PLAYLIST , cookies = COOKIES_STREAMING_EXAMPLE ) [EOL] cookies = ClientForBackEnd . request_cookies ( URL_PLAYLIST ) [EOL] assert cookies == COOKIES_STREAMING_EXAMPLE [EOL] [EOL] @ staticmethod def test_request_playlist ( requests_mock ) : [EOL] requests_mock . get ( URL_PLAYLIST , text = M3U8_CONTENT_EXAMPLE ) [EOL] expected = m3u8 . loads ( FILE_PLAYLIST_TEST_DATA . read_text ( ) , URL_PLAYLIST ) [EOL] actual = ClientForBackEnd . request_playlist ( URL_PLAYLIST ) [EOL] assert actual . dumps ( ) == expected . dumps ( ) [EOL] [EOL] @ staticmethod def test_request_api_list_episode ( requests_mock ) : [EOL] program_id_string = [string] [EOL] program_code = [number] [EOL] limit = [number] [EOL] sort = [number] [EOL] params = { [string] : program_code , [string] : limit , [string] : sort , [string] : [number] , [string] : [number] , } [EOL] json_example = { [string] : [string] } [EOL] requests_mock . get ( [string] + [string] . join ( [ f'{ key } [string] { value }' for key , value in params . items ( ) ] ) , request_headers = { [string] : f' [string] { program_id_string } [string] ' } , json = json_example ) [EOL] assert ClientForBackEnd . request_api_list_episode ( program_id_string , Payload ( program_code , limit , sort ) ) == json_example [EOL] [EOL] @ staticmethod def test_download ( requests_mock ) : [EOL] requests_mock . get ( f' [string] { EXTRA_LARGE_IMAGE_URL_EXAMPLE }' , content = BINARY_JPEG_EXAMPLE ) [EOL] assert ClientForBackEnd . download ( EXTRA_LARGE_IMAGE_URL_EXAMPLE ) == BINARY_JPEG_EXAMPLE [EOL] [EOL] @ staticmethod @ patch ( StreamFactory . RUN ) def test_ffmpeg ( mocked_run ) : [EOL] playlist = Playlist ( URI_EXAMPLE , { [string] : [number] } , None , None ) [EOL] ClientForBackEnd . ffmpeg ( playlist , COOKIES_STREAMING_EXAMPLE , PATH_FILE ) [EOL] mocked_run . assert_called_once_with ( StreamFactory . create_stream_expect ( COOKIES_STREAMING_EXAMPLE , PATH_FILE , URI_EXAMPLE ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from pathlib import Path [EOL] [EOL] from tests . testlibraries . instance_resource import PATH_VIDEO_OUTPUT , EPISODE_EXAMPLE , EXTRA_LARGE_IMAGE_URL_EXAMPLE , InstanceResource [EOL] from videoarchiver import Directory [EOL] from videoarchiver . tvasahi . path_builder import PathBuilder [EOL] [EOL] [EOL] class TestPathBuilder : [EOL] @ staticmethod def test_build_path_archive_directory ( ) : [EOL] assert PathBuilder . build_archive_directory ( Directory . DOWNLOAD . value , EPISODE_EXAMPLE ) == InstanceResource . PATH_PROJECT_HOME / [string] / PATH_VIDEO_OUTPUT [EOL] [EOL] @ staticmethod def test_build_archive_path_for_image ( ) : [EOL] assert PathBuilder . build_archive_image_file ( PATH_VIDEO_OUTPUT , EXTRA_LARGE_IMAGE_URL_EXAMPLE ) == Path ( PATH_VIDEO_OUTPUT / [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from unittest . mock import patch [EOL] [EOL] from tests . testlibraries . instance_resource import PATH_VIDEO_OUTPUT , FILE_HTML_EPISODE , BINARY_JPEG_EXAMPLE , COOKIES_STREAMING_EXAMPLE , EPISODE_EXAMPLE , EXTRA_LARGE_IMAGE_URL_EXAMPLE , URL_PLAYLIST , URI_EXAMPLE , M3U8_CONTENT_EXAMPLE , PATH_FILE [EOL] from tests . testlibraries . stream_factory import StreamFactory [EOL] from videoarchiver . tvasahi . episode_media_archiver import EpisodeMediaArchiver [EOL] [EOL] [EOL] class TestEpisodeMediaArchiver : [EOL] @ staticmethod def test_archive_image_if_has_not_archived ( requests_mock , tmp_path ) : [EOL] requests_mock . get ( f' [string] { EXTRA_LARGE_IMAGE_URL_EXAMPLE }' , content = BINARY_JPEG_EXAMPLE ) [EOL] EpisodeMediaArchiver ( EPISODE_EXAMPLE , tmp_path ) . archive_image_if_has_not_archived ( EXTRA_LARGE_IMAGE_URL_EXAMPLE ) [EOL] assert ( tmp_path / PATH_VIDEO_OUTPUT / [string] ) . read_bytes ( ) == BINARY_JPEG_EXAMPLE [EOL] [EOL] @ staticmethod @ patch ( StreamFactory . RUN ) def test_archive_video_if_has_not_archived ( mocked_run , requests_mock , tmp_path ) : [EOL] requests_mock . get ( [string] , text = FILE_HTML_EPISODE . read_text ( encoding = [string] ) ) [EOL] requests_mock . get ( URL_PLAYLIST , cookies = COOKIES_STREAMING_EXAMPLE , text = M3U8_CONTENT_EXAMPLE ) [EOL] EpisodeMediaArchiver ( EPISODE_EXAMPLE , tmp_path ) . archive_video_if_has_not_archived ( COOKIES_STREAMING_EXAMPLE ) [EOL] mocked_run . assert_called_once_with ( StreamFactory . create_stream_expect ( COOKIES_STREAMING_EXAMPLE , tmp_path / PATH_FILE , URI_EXAMPLE ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import videoarchiver [EOL] from videoarchiver import CONFIG , Directory [EOL] from videoarchiver . niconico . archive_step import ArchiveStep [EOL] from videoarchiver . tvasahi . client_for_back_end import ClientForBackEnd [EOL] [EOL] [EOL] class VideoArchiver : [EOL] @ staticmethod def execute ( ) : [EOL] CONFIG . load ( ) [EOL] archive_step = ArchiveStep ( ClientForBackEnd , Directory . DOWNLOAD . value ) [EOL] archive_step . execute ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.niconico.archive_step.ArchiveStep$ 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.niconico.archive_step.ArchiveStep$ 0 0 0 0 0
import requests [EOL] from abc import abstractmethod , ABC [EOL] [EOL] from requests . cookies import RequestsCookieJar [EOL] [EOL] [EOL] class AbstractClientForBackEnd ( ABC ) : [EOL] @ classmethod @ abstractmethod def login ( cls ) : [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from dataclasses import dataclass , field [EOL] from typing import List [EOL] [EOL] from dataclasses_json import DataClassJsonMixin [EOL] from yamldataclassconfig . config import YamlDataClassConfig [EOL] [EOL] [EOL] @ dataclass class TvAsahiConfig ( DataClassJsonMixin ) : [EOL] [docstring] [EOL] mail_address = None [comment] [EOL] password = None [comment] [EOL] list_program_id = field ( default_factory = list ) [comment] [EOL] [EOL] [EOL] @ dataclass class NiconicoConfig ( DataClassJsonMixin ) : [EOL] [docstring] [EOL] mail_address = None [comment] [EOL] password = None [comment] [EOL] list_program_id = field ( default_factory = list ) [comment] [EOL] [EOL] [EOL] @ dataclass class Config ( YamlDataClassConfig ) : [EOL] [docstring] [EOL] tv_asahi = field ( default = None , metadata = { [string] : { [string] : TvAsahiConfig } } ) [EOL] niconico = field ( default = None , metadata = { [string] : { [string] : NiconicoConfig } } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TvAsahiConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $NiconicoConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] class Windows : [EOL] DICTIONARY_DISALLOW_CHARACTER = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] @ staticmethod def replace_disallow_character ( string ) : [EOL] return string . translate ( str . maketrans ( Windows . DICTIONARY_DISALLOW_CHARACTER ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import m3u8 [EOL] from typing import Optional [EOL] [EOL] from m3u8 import M3U8 , Playlist [EOL] [EOL] [EOL] class M3U8Handler : [EOL] @ classmethod def extract_highest_quality_streaming_url ( cls , m3u8_object ) : [EOL] playlist_highest_quality = None [EOL] for playlist in m3u8_object . playlists : [EOL] playlist_highest_quality = cls . return_higher_quality ( playlist_highest_quality , playlist ) [EOL] [EOL] return playlist_highest_quality [EOL] [EOL] @ staticmethod def return_higher_quality ( playlist_a , playlist_b ) : [EOL] if playlist_a is None or playlist_a . stream_info . bandwidth < playlist_b . stream_info . bandwidth : [EOL] return playlist_b [EOL] return playlist_a [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $m3u8.Playlist$ 0 0 0 $m3u8.M3U8$ 0 0 0 $None$ 0 0 0 0 0 0 $m3u8.M3U8$ 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $m3u8.Playlist$ 0 $m3u8.Playlist$ 0 $m3u8.Playlist$ 0 0 0 0 $m3u8.Playlist$ 0 0 0 $m3u8.Playlist$ 0 0 0 0 0 $m3u8.Playlist$ 0 0 0 0 0 0 0 $m3u8.Playlist$ 0 0 $m3u8.Playlist$ 0
from typing import Type [EOL] import videoarchiver [EOL] import typing [EOL] import pathlib [EOL] from pathlib import Path [EOL] from typing import Type [EOL] [EOL] from videoarchiver . abstract_client_for_back_end import AbstractClientForBackEnd [EOL] [EOL] [EOL] class MembershipSiteArchiveStep : [EOL] [docstring] [EOL] def __init__ ( self , client_for_back_end , path_directory_download ) : [EOL] self . client_for_back_end = client_for_back_end [EOL] self . cookies_login = client_for_back_end . login ( ) [EOL] self . path_directory_download = path_directory_download [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[videoarchiver.abstract_client_for_back_end.AbstractClientForBackEnd]$ 0 $pathlib.Path$ 0 0 0 0 0 $typing.Type[videoarchiver.abstract_client_for_back_end.AbstractClientForBackEnd]$ 0 $typing.Type[videoarchiver.abstract_client_for_back_end.AbstractClientForBackEnd]$ 0 0 0 0 0 $typing.Type[videoarchiver.abstract_client_for_back_end.AbstractClientForBackEnd]$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import requests [EOL] import builtins [EOL] from requests . cookies import RequestsCookieJar [EOL] [EOL] [EOL] class CookieConverter : [EOL] @ staticmethod def convert_requests_cookie_jar_to_string ( requests_cookie_jar ) : [EOL] cookie_dict = requests_cookie_jar . get_dict ( ) [EOL] return [string] . join ( [ f'{ key } [string] { value }' for key , value in cookie_dict . items ( ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $requests.cookies.RequestsCookieJar$ 0 0 0 $typing.Any$ 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
import videoarchiver [EOL] import pathlib [EOL] from enum import Enum [EOL] from pathlib import Path [EOL] [EOL] from videoarchiver . config import Config [EOL] [EOL] CONFIG = Config ( ) [EOL] [EOL] [EOL] class Directory ( Enum ) : [EOL] [docstring] [EOL] DOWNLOAD = Path ( __file__ ) . parent . parent / [string] [EOL] CACHE = Path ( __file__ ) . parent . parent / [string] [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return super ( ) . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from videoarchiver import CONFIG [EOL] from videoarchiver . membership_site_archive_step import MembershipSiteArchiveStep [EOL] from videoarchiver . niconico . client_for_back_end import ClientForBackEnd [EOL] [EOL] [EOL] class ArchiveStep ( MembershipSiteArchiveStep ) : [EOL] [docstring] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] for program_id_string in CONFIG . niconico . list_program_id : [EOL] self . execute_per_program ( program_id_string ) [EOL] [EOL] def execute_per_program ( self , program_id_string ) : [EOL] [docstring] [EOL] url_watch_page = f' [string] { program_id_string }' [EOL] ClientForBackEnd . ffmpeg ( [string] , self . cookies_login , self . path_directory_download / f' [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Type [EOL] import typing [EOL] import requests [EOL] import videoarchiver [EOL] import pathlib [EOL] import builtins [EOL] from pathlib import Path [EOL] [EOL] import ffmpeg [EOL] import requests [EOL] from requests . cookies import RequestsCookieJar [EOL] [EOL] from videoarchiver import CONFIG [EOL] from videoarchiver . abstract_client_for_back_end import AbstractClientForBackEnd [EOL] from videoarchiver . cookie_converter import CookieConverter [EOL] [EOL] [EOL] class ClientForBackEnd ( AbstractClientForBackEnd ) : [EOL] HOST_NAME = [string] [EOL] BASE_URL = [string] + HOST_NAME [EOL] SLASH = [string] [EOL] API_LOGIN = [string] [EOL] [EOL] @ classmethod def login ( cls ) : [EOL] data = { [string] : CONFIG . niconico . mail_address , [string] : CONFIG . niconico . password , } [EOL] response = requests . post ( ClientForBackEnd . BASE_URL + ClientForBackEnd . SLASH + ClientForBackEnd . API_LOGIN , data = data , allow_redirects = False ) [EOL] response . raise_for_status ( ) [EOL] return response . cookies [EOL] [EOL] @ classmethod def ffmpeg ( cls , uri , cookies_streaming , path_file ) : [EOL] cookies_string = CookieConverter . convert_requests_cookie_jar_to_string ( cookies_streaming ) [EOL] stream = ffmpeg . input ( uri , headers = f' [string] { cookies_string } [string] ' , copytb = [string] ) [EOL] stream = ffmpeg . output ( stream , str ( path_file ) , f = [string] , c = [string] ) [EOL] ffmpeg . run ( stream ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $requests.cookies.RequestsCookieJar$ 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
	0
from typing import Any , Dict , Type [EOL] import m3u8 [EOL] import typing [EOL] import requests [EOL] import videoarchiver [EOL] import bs4 [EOL] import pathlib [EOL] import builtins [EOL] from dataclasses import dataclass , asdict [EOL] from pathlib import Path [EOL] [EOL] [comment] [EOL] import ffmpeg [EOL] from bs4 import BeautifulSoup [EOL] import m3u8 [EOL] from m3u8 import M3U8 , Playlist [EOL] import requests [EOL] from requests import Response [EOL] from requests . cookies import RequestsCookieJar [EOL] [EOL] from videoarchiver import CONFIG [EOL] from videoarchiver . abstract_client_for_back_end import AbstractClientForBackEnd [EOL] from videoarchiver . cookie_converter import CookieConverter [EOL] from videoarchiver . tvasahi . models import Episode [EOL] [EOL] [EOL] @ dataclass class Payload : [EOL] key = ... [EOL] limit = ... [EOL] sort = ... [EOL] page = [number] [EOL] bought = [number] [EOL] [EOL] [EOL] class ClientForBackEnd ( AbstractClientForBackEnd ) : [EOL] HOST_NAME = [string] [EOL] BASE_URL = [string] + HOST_NAME [EOL] BASE_URL_DIRECTORY = BASE_URL + [string] [EOL] SLASH = [string] [EOL] API_LIST_EPISODES = [string] [EOL] [EOL] @ classmethod def login ( cls ) : [EOL] data = { [string] : CONFIG . tv_asahi . mail_address , [string] : CONFIG . tv_asahi . password , } [EOL] response = requests . post ( ClientForBackEnd . BASE_URL_DIRECTORY + [string] , data = data , allow_redirects = False ) [EOL] response . raise_for_status ( ) [EOL] return response . cookies [EOL] [EOL] @ classmethod def request_program_home_page ( cls , program_id_string ) : [EOL] return cls . request_html ( cls . BASE_URL_DIRECTORY + cls . SLASH + program_id_string , program_id_string ) [EOL] [EOL] @ classmethod def request_episode_page ( cls , episode , cookies_login ) : [EOL] return cls . request_html ( cls . BASE_URL_DIRECTORY + cls . SLASH + episode . directory + cls . SLASH + str ( episode . episode_num ) , episode . directory , cookies_login ) [EOL] [EOL] @ classmethod def request_html ( cls , request_url , program_id_string , cookies = None ) : [EOL] print ( [string] + request_url ) [EOL] headers = { [string] : cls . BASE_URL_DIRECTORY + cls . SLASH + program_id_string , [string] : cls . BASE_URL } [EOL] response = requests . get ( request_url , headers = headers , cookies = cookies ) [EOL] response . raise_for_status ( ) [EOL] return BeautifulSoup ( response . text , [string] ) [EOL] [EOL] @ classmethod def request_cookies ( cls , request_url ) : [EOL] response = requests . get ( request_url ) [EOL] response . raise_for_status ( ) [EOL] return response . cookies [EOL] [EOL] @ classmethod def request_playlist ( cls , request_url ) : [EOL] response = requests . get ( request_url ) [EOL] response . raise_for_status ( ) [EOL] print ( response . text ) [EOL] return m3u8 . loads ( response . text , response . request . url ) [EOL] [EOL] @ classmethod def request_api_list_episode ( cls , program_id_string , payload ) : [EOL] request_url = cls . BASE_URL_DIRECTORY + cls . SLASH + cls . API_LIST_EPISODES [EOL] print ( [string] + request_url ) [EOL] headers = { [string] : cls . BASE_URL_DIRECTORY + cls . SLASH + program_id_string + cls . SLASH + [string] } [EOL] response = requests . get ( request_url , params = asdict ( payload ) , headers = headers ) [EOL] response . raise_for_status ( ) [EOL] return response . json ( ) [EOL] [EOL] @ classmethod def download ( cls , url ) : [EOL] response = requests . get ( cls . BASE_URL_DIRECTORY + url ) [EOL] response . raise_for_status ( ) [EOL] return response . content [EOL] [EOL] @ classmethod def ffmpeg ( cls , playlist , cookies_streaming , path_file ) : [EOL] cookies_string = CookieConverter . convert_requests_cookie_jar_to_string ( cookies_streaming ) [EOL] stream = ffmpeg . input ( playlist . uri , headers = f' [string] { cookies_string } [string] ' , copytb = [string] ) [EOL] stream = ffmpeg . output ( stream , str ( path_file ) , f = [string] , c = [string] ) [EOL] ffmpeg . run ( stream ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.BeautifulSoup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 $requests.models.Response$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $m3u8.M3U8$ 0 0 0 $builtins.str$ 0 0 0 $requests.Response$ 0 0 0 0 0 $builtins.str$ 0 0 $requests.Response$ 0 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 0 0 $requests.Response$ 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $Payload$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $Payload$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $requests.models.Response$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $requests.models.Response$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $m3u8.Playlist$ 0 $requests.cookies.RequestsCookieJar$ 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 $typing.Any$ 0 0 0 0 0 $m3u8.Playlist$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Dict , Union , Optional , List [EOL] import videoarchiver [EOL] import typing [EOL] import builtins [EOL] from typing import List , Dict , Optional , Union [EOL] [EOL] from videoarchiver . tvasahi . models import Episode [EOL] [EOL] [EOL] class DictionaryConverter : [EOL] @ classmethod def convert_to_list ( cls , list_dictionary_episode ) : [EOL] return [ cls . convert_to_model ( dictionary_episode ) for dictionary_episode in list_dictionary_episode ] [EOL] [EOL] @ staticmethod def convert_to_model ( dict_episode ) : [EOL] dict_episode_lower_case = { k . lower ( ) : v for k , v in dict_episode . items ( ) } [EOL] [comment] [EOL] return Episode . schema ( unknown = [string] ) . load ( dict_episode_lower_case ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 $typing.List[builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.dict]$ 0 0 0 0 0 0 $videoarchiver.tvasahi.models.Episode$ 0 $typing.Dict[builtins.str,typing.Optional[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]$ 0 0 0
from typing import List , Type [EOL] import videoarchiver [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import sys [EOL] from pathlib import Path [EOL] from typing import Type [EOL] [EOL] from videoarchiver import CONFIG [EOL] from videoarchiver . membership_site_archive_step import MembershipSiteArchiveStep [EOL] from videoarchiver . tvasahi . episode_loader import EpisodeLoader [EOL] from videoarchiver . tvasahi . client_for_back_end import ClientForBackEnd [EOL] from videoarchiver . tvasahi . episode_media_archiver import EpisodeMediaArchiver [EOL] [EOL] [EOL] class ArchiveStep ( MembershipSiteArchiveStep ) : [EOL] [docstring] [EOL] def __init__ ( self , client_for_back_end , path_directory_download , path_directory_cache , ) : [EOL] super ( ) . __init__ ( client_for_back_end , path_directory_download ) [EOL] self . episode_loader = EpisodeLoader ( path_directory_cache ) [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] for program_id_string in CONFIG . tv_asahi . list_program_id : [EOL] self . execute_per_program ( program_id_string ) [EOL] [EOL] def execute_per_program ( self , program_id_string ) : [EOL] [docstring] [EOL] list_episode = self . episode_loader . list_up_episode ( program_id_string ) if len ( sys . argv ) >= [number] and [string] in sys . argv else self . episode_loader . load_backup ( program_id_string ) [EOL] for episode in list_episode : [EOL] media_archiver = EpisodeMediaArchiver ( episode , self . path_directory_download ) [EOL] media_archiver . archive_extra_large_image_if_has_not_archived ( ) [EOL] media_archiver . archive_large_image_if_has_not_archived ( ) [EOL] media_archiver . archive_video_if_has_not_archived ( self . cookies_login ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[videoarchiver.tvasahi.client_for_back_end.ClientForBackEnd]$ 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[videoarchiver.tvasahi.client_for_back_end.ClientForBackEnd]$ 0 $pathlib.Path$ 0 0 0 0 $videoarchiver.tvasahi.episode_loader.EpisodeLoader$ 0 0 0 $pathlib.Path$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 $videoarchiver.tvasahi.episode_media_archiver.EpisodeMediaArchiver$ 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.episode_media_archiver.EpisodeMediaArchiver$ 0 0 0 0 0 $videoarchiver.tvasahi.episode_media_archiver.EpisodeMediaArchiver$ 0 0 0 0 0 $videoarchiver.tvasahi.episode_media_archiver.EpisodeMediaArchiver$ 0 0 0 0 0 0 0 0
import builtins [EOL] class JavaScriptAnalyzer : [EOL] def __init__ ( self , java_script ) : [EOL] self . lines_java_script = java_script . splitlines ( ) [EOL] [EOL] def extract_variable ( self , variable_name ) : [EOL] return self . extract_variable_from_definition_line ( self . __find_first_line ( f' [string] { variable_name }' ) ) [EOL] [EOL] def extract_url_playlist ( self ) : [EOL] return self . extract_url_from_definition_line ( self . __find_first_line ( [string] ) ) [EOL] [EOL] def __find_first_line ( self , key_word ) : [EOL] for line_java_script in self . lines_java_script : [EOL] if key_word in line_java_script : [EOL] return line_java_script [EOL] raise ValueError ( f" [string] { key_word } [string] " ) [EOL] [EOL] @ staticmethod def extract_variable_from_definition_line ( definition_line ) : [EOL] [docstring] [EOL] return int ( definition_line . rsplit ( [string] , [number] ) [ [number] ] . strip ( ) . strip ( [string] ) ) [EOL] [EOL] @ staticmethod def extract_url_from_definition_line ( definition_line ) : [EOL] for part in definition_line . rsplit ( [string] ) : [EOL] if part . startswith ( [string] ) : [EOL] return part [EOL] raise ValueError ( f" [string] { definition_line } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
import videoarchiver [EOL] import bs4 [EOL] from bs4 import BeautifulSoup [EOL] [EOL] from videoarchiver . tvasahi . java_script_analyzer import JavaScriptAnalyzer [EOL] [EOL] [EOL] class HtmlAnalyzer : [EOL] def __init__ ( self , soup ) : [EOL] self . java_script_analyzer = JavaScriptAnalyzer ( soup . find ( [string] , id = [string] ) . find ( [string] , type = [string] ) . string ) [EOL] [EOL] def extract_episode_code ( self ) : [EOL] return self . java_script_analyzer . extract_variable ( [string] ) [EOL] [EOL] def extract_sort ( self ) : [EOL] return self . java_script_analyzer . extract_variable ( [string] ) [EOL] [EOL] @ staticmethod def extract_url_playlist ( soup ) : [EOL] for script in soup . find_all ( [string] , type = [string] ) : [EOL] if script . string : [EOL] java_script_analyzer = JavaScriptAnalyzer ( script . string ) [EOL] try : [EOL] return java_script_analyzer . extract_url_playlist ( ) [EOL] except ValueError : [EOL] continue [EOL] raise ValueError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.BeautifulSoup$ 0 0 0 0 0 $videoarchiver.tvasahi.java_script_analyzer.JavaScriptAnalyzer$ 0 0 0 $bs4.BeautifulSoup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.java_script_analyzer.JavaScriptAnalyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.java_script_analyzer.JavaScriptAnalyzer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import TextIO , Dict , Any , List [EOL] import videoarchiver [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] from pathlib import Path [EOL] from typing import List , TextIO [EOL] [EOL] import yaml [EOL] [EOL] from videoarchiver . tvasahi . dictionary_converter import DictionaryConverter [EOL] from videoarchiver . tvasahi . html_analyzer import HtmlAnalyzer [EOL] from videoarchiver . tvasahi . models import Episode [EOL] from videoarchiver . tvasahi . client_for_back_end import ClientForBackEnd , Payload [EOL] [EOL] [EOL] class EpisodeLoader : [EOL] def __init__ ( self , path_directory_cache ) : [EOL] self . path_directory_cache = path_directory_cache [EOL] [EOL] def load_backup ( self , program_id_string ) : [EOL] with ( self . path_directory_cache / f'{ program_id_string } [string] ' ) . open ( [string] , encoding = [string] , newline = [string] ) as file_backup : [EOL] list_dictionary_episode = yaml . safe_load ( file_backup ) [EOL] return DictionaryConverter . convert_to_list ( list_dictionary_episode ) [EOL] [EOL] def list_up_episode ( self , program_id_string ) : [EOL] html_analyzer = HtmlAnalyzer ( ClientForBackEnd . request_program_home_page ( program_id_string ) ) [EOL] with ( self . path_directory_cache / f'{ program_id_string } [string] ' ) . open ( [string] , encoding = [string] , newline = [string] ) as file_backup : [EOL] [comment] [EOL] [comment] [EOL] return self . _list_up_episode ( file_backup , html_analyzer , program_id_string ) [comment] [EOL] [EOL] @ classmethod def _list_up_episode ( cls , file_backup , html_analyzer , program_id_string ) : [EOL] program_code = html_analyzer . extract_episode_code ( ) [EOL] sort = html_analyzer . extract_sort ( ) [EOL] max_page = None [EOL] current_page = [number] [EOL] list_episode = [ ] [EOL] while max_page is None or max_page >= current_page : [EOL] dictionary_json = ClientForBackEnd . request_api_list_episode ( program_id_string , Payload ( program_code , [number] , sort , current_page ) ) [EOL] list_dictionary_episode = dictionary_json [ [string] ] [EOL] file_backup . write ( yaml . dump ( list_dictionary_episode , allow_unicode = True , default_flow_style = False ) ) [EOL] list_episode . extend ( DictionaryConverter . convert_to_list ( list_dictionary_episode ) ) [EOL] max_page = dictionary_json [ [string] ] [ [string] ] [EOL] current_page += [number] [EOL] return list_episode [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 $builtins.str$ 0 0 0 $videoarchiver.tvasahi.html_analyzer.HtmlAnalyzer$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.html_analyzer.HtmlAnalyzer$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[videoarchiver.tvasahi.models.Episode]$ 0 0 0 $typing.TextIO$ 0 $videoarchiver.tvasahi.html_analyzer.HtmlAnalyzer$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $videoarchiver.tvasahi.html_analyzer.HtmlAnalyzer$ 0 0 0 0 0 $typing.Any$ 0 $videoarchiver.tvasahi.html_analyzer.HtmlAnalyzer$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import List [EOL] import videoarchiver [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] from pathlib import Path [EOL] [EOL] from videoarchiver . tvasahi . models import Episode [EOL] [EOL] [EOL] class PathBuilder : [EOL] @ classmethod def build_archive_directory ( cls , path_directory_cache , episode ) : [EOL] return path_directory_cache / episode . program_name / ( f'{ episode . episode_num : [string] } [string] { episode . episode_name_for_windows_path }' ) [EOL] [EOL] @ classmethod def build_archive_image_file ( cls , path_archive_directory , url ) : [EOL] list_part_url = url . rsplit ( [string] , [number] ) [EOL] list_part_file_name = list_part_url [ [number] ] . rsplit ( [string] , [number] ) [EOL] return path_archive_directory / f'{ list_part_file_name [ [number] ] } [string] { list_part_url [ [number] ] } [string] { list_part_file_name [ [number] ] }' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $videoarchiver.tvasahi.models.Episode$ 0 0 0 0 $pathlib.Path$ 0 $videoarchiver.tvasahi.models.Episode$ 0 0 0 0 0 $videoarchiver.tvasahi.models.Episode$ 0 0 0 0 0 0 0 $videoarchiver.tvasahi.models.Episode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import requests [EOL] import videoarchiver [EOL] import pathlib [EOL] import builtins [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] from requests . cookies import RequestsCookieJar [EOL] [EOL] from videoarchiver . m3u8_handler import M3U8Handler [EOL] from videoarchiver . tvasahi . path_builder import PathBuilder [EOL] from videoarchiver . tvasahi . client_for_back_end import ClientForBackEnd [EOL] from videoarchiver . tvasahi . html_analyzer import HtmlAnalyzer [EOL] from videoarchiver . tvasahi . models import Episode [EOL] [EOL] [EOL] class EpisodeMediaArchiver : [EOL] def __init__ ( self , episode , path_directory_download ) : [EOL] self . episode = episode [EOL] self . path_archive_directory = PathBuilder . build_archive_directory ( path_directory_download , episode ) [EOL] os . makedirs ( str ( self . path_archive_directory ) , exist_ok = True ) [EOL] [EOL] def archive_large_image_if_has_not_archived ( self ) : [EOL] self . archive_image_if_has_not_archived ( self . episode . large_image_url ) [EOL] [EOL] def archive_extra_large_image_if_has_not_archived ( self ) : [EOL] self . archive_image_if_has_not_archived ( self . episode . extra_large_image_url ) [EOL] [EOL] def archive_image_if_has_not_archived ( self , url ) : [EOL] path = PathBuilder . build_archive_image_file ( self . path_archive_directory , url ) [EOL] if path . exists ( ) : [EOL] print ( f' [string] { str ( path ) }' ) [EOL] return [EOL] with path . open ( [string] ) as file_image : [EOL] file_image . write ( ClientForBackEnd . download ( url ) ) [EOL] [EOL] def archive_video_if_has_not_archived ( self , cookies_login ) : [EOL] path_file = self . path_archive_directory / f'{ self . episode . episode_name_for_windows_path } [string] ' [EOL] if path_file . exists ( ) : [EOL] print ( f' [string] { str ( path_file ) }' ) [EOL] return [EOL] soup = ClientForBackEnd . request_episode_page ( self . episode , cookies_login ) [EOL] url_playlist = HtmlAnalyzer . extract_url_playlist ( soup ) [EOL] cookies_streaming = ClientForBackEnd . request_cookies ( url_playlist ) [EOL] m3u8_object = ClientForBackEnd . request_playlist ( url_playlist ) [EOL] playlist_highest_quality = M3U8Handler . extract_highest_quality_streaming_url ( m3u8_object ) [EOL] ClientForBackEnd . ffmpeg ( playlist_highest_quality , cookies_streaming , path_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $videoarchiver.tvasahi.models.Episode$ 0 $pathlib.Path$ 0 0 0 0 0 $videoarchiver.tvasahi.models.Episode$ 0 $videoarchiver.tvasahi.models.Episode$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $videoarchiver.tvasahi.models.Episode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.cookies.RequestsCookieJar$ 0 $typing.Any$ 0 0