[comment] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] import pathlib [EOL] from setuptools import setup , find_packages [EOL] from setuptools . command . test import test as TestCommand [EOL] import versioneer [EOL] [EOL] [comment] [EOL] HERE = pathlib . Path ( __file__ ) . parent [EOL] [EOL] DESCRIPTION = [string] [EOL] LONG_DESCRIPTION = HERE . joinpath ( [string] ) . read_text ( ) [EOL] [EOL] DISTNAME = [string] [EOL] LICENSE = [string] [EOL] AUTHOR = [string] [EOL] EMAIL = [string] [EOL] URL = [string] [EOL] DOWNLOAD_URL = [string] [EOL] PROJECT_URLS = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] REQUIRES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] CLASSIFIERS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class NoopTestCommand ( TestCommand ) : [EOL] def __init__ ( self , dist ) : [EOL] print ( [string] [string] ) [EOL] [EOL] [EOL] cmdclass = versioneer . get_cmdclass ( ) [EOL] cmdclass . update ( { [string] : NoopTestCommand } ) [EOL] [EOL] setup ( name = DISTNAME , maintainer = AUTHOR , version = versioneer . get_version ( ) , packages = find_packages ( exclude = ( [string] , ) ) , maintainer_email = EMAIL , description = DESCRIPTION , license = LICENSE , cmdclass = cmdclass , url = URL , download_url = DOWNLOAD_URL , project_urls = PROJECT_URLS , long_description = LONG_DESCRIPTION , long_description_content_type = [string] , classifiers = CLASSIFIERS , python_requires = [string] , install_requires = REQUIRES , zip_safe = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0
[EOL] [comment] [EOL] [EOL] from typing import Dict , Any , List , Set , Optional , Match [EOL] import typing [EOL] import io [EOL] import subprocess [EOL] import versioneer [EOL] [docstring] [EOL] [EOL] from __future__ import print_function [EOL] try : [EOL] import configparser [EOL] except ImportError : [EOL] import ConfigParser as configparser [EOL] import errno [EOL] import json [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import sys [EOL] [EOL] [EOL] class VersioneerConfig : [EOL] [docstring] [EOL] [EOL] [EOL] def get_root ( ) : [EOL] [docstring] [EOL] root = os . path . realpath ( os . path . abspath ( os . getcwd ( ) ) ) [EOL] setup_py = os . path . join ( root , [string] ) [EOL] versioneer_py = os . path . join ( root , [string] ) [EOL] if not ( os . path . exists ( setup_py ) or os . path . exists ( versioneer_py ) ) : [EOL] [comment] [EOL] root = os . path . dirname ( os . path . realpath ( os . path . abspath ( sys . argv [ [number] ] ) ) ) [EOL] setup_py = os . path . join ( root , [string] ) [EOL] versioneer_py = os . path . join ( root , [string] ) [EOL] if not ( os . path . exists ( setup_py ) or os . path . exists ( versioneer_py ) ) : [EOL] err = ( [string] [string] [string] [string] [string] ) [EOL] raise VersioneerBadRootError ( err ) [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] me = os . path . realpath ( os . path . abspath ( __file__ ) ) [EOL] me_dir = os . path . normcase ( os . path . splitext ( me ) [ [number] ] ) [EOL] vsr_dir = os . path . normcase ( os . path . splitext ( versioneer_py ) [ [number] ] ) [EOL] if me_dir != vsr_dir : [EOL] print ( [string] % ( os . path . dirname ( me ) , versioneer_py ) ) [EOL] except NameError : [EOL] pass [EOL] return root [EOL] [EOL] [EOL] def get_config_from_root ( root ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] setup_cfg = os . path . join ( root , [string] ) [EOL] parser = configparser . SafeConfigParser ( ) [EOL] with open ( setup_cfg , [string] ) as f : [EOL] parser . readfp ( f ) [EOL] VCS = parser . get ( [string] , [string] ) [comment] [EOL] [EOL] def get ( parser , name ) : [EOL] if parser . has_option ( [string] , name ) : [EOL] return parser . get ( [string] , name ) [EOL] return None [EOL] cfg = VersioneerConfig ( ) [EOL] cfg . VCS = VCS [EOL] cfg . style = get ( parser , [string] ) or [string] [EOL] cfg . versionfile_source = get ( parser , [string] ) [EOL] cfg . versionfile_build = get ( parser , [string] ) [EOL] cfg . tag_prefix = get ( parser , [string] ) [EOL] if cfg . tag_prefix in ( [string] , [string] ) : [EOL] cfg . tag_prefix = [string] [EOL] cfg . parentdir_prefix = get ( parser , [string] ) [EOL] cfg . verbose = get ( parser , [string] ) [EOL] return cfg [EOL] [EOL] [EOL] class NotThisMethod ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] LONG_VERSION_PY = { } [EOL] HANDLERS = { } [EOL] [EOL] [EOL] def register_vcs_handler ( vcs , method ) : [comment] [EOL] [docstring] [EOL] def decorate ( f ) : [EOL] [docstring] [EOL] if vcs not in HANDLERS : [EOL] HANDLERS [ vcs ] = { } [EOL] HANDLERS [ vcs ] [ method ] = f [EOL] return f [EOL] return decorate [EOL] [EOL] [EOL] def run_command ( commands , args , cwd = None , verbose = False , hide_stderr = False , env = None ) : [EOL] [docstring] [EOL] assert isinstance ( commands , list ) [EOL] p = None [EOL] for c in commands : [EOL] try : [EOL] dispcmd = str ( [ c ] + args ) [EOL] [comment] [EOL] p = subprocess . Popen ( [ c ] + args , cwd = cwd , env = env , stdout = subprocess . PIPE , stderr = ( subprocess . PIPE if hide_stderr [EOL] else None ) ) [EOL] break [EOL] except EnvironmentError : [EOL] e = sys . exc_info ( ) [ [number] ] [EOL] if e . errno == errno . ENOENT : [EOL] continue [EOL] if verbose : [EOL] print ( [string] % dispcmd ) [EOL] print ( e ) [EOL] return None , None [EOL] else : [EOL] if verbose : [EOL] print ( [string] % ( commands , ) ) [EOL] return None , None [EOL] stdout = p . communicate ( ) [ [number] ] . strip ( ) [EOL] if sys . version_info [ [number] ] >= [number] : [EOL] stdout = stdout . decode ( ) [EOL] if p . returncode != [number] : [EOL] if verbose : [EOL] print ( [string] % dispcmd ) [EOL] print ( [string] % stdout ) [EOL] return None , p . returncode [EOL] return stdout , p . returncode [EOL] [EOL] [EOL] LONG_VERSION_PY [ [string] ] = [string] [EOL] [EOL] [EOL] @ register_vcs_handler ( [string] , [string] ) def git_get_keywords ( versionfile_abs ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] keywords = { } [EOL] try : [EOL] f = open ( versionfile_abs , [string] ) [EOL] for line in f . readlines ( ) : [EOL] if line . strip ( ) . startswith ( [string] ) : [EOL] mo = re . search ( [string] , line ) [EOL] if mo : [EOL] keywords [ [string] ] = mo . group ( [number] ) [EOL] if line . strip ( ) . startswith ( [string] ) : [EOL] mo = re . search ( [string] , line ) [EOL] if mo : [EOL] keywords [ [string] ] = mo . group ( [number] ) [EOL] if line . strip ( ) . startswith ( [string] ) : [EOL] mo = re . search ( [string] , line ) [EOL] if mo : [EOL] keywords [ [string] ] = mo . group ( [number] ) [EOL] f . close ( ) [EOL] except EnvironmentError : [EOL] pass [EOL] return keywords [EOL] [EOL] [EOL] @ register_vcs_handler ( [string] , [string] ) def git_versions_from_keywords ( keywords , tag_prefix , verbose ) : [EOL] [docstring] [EOL] if not keywords : [EOL] raise NotThisMethod ( [string] ) [EOL] date = keywords . get ( [string] ) [EOL] if date is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] date = date . strip ( ) . replace ( [string] , [string] , [number] ) . replace ( [string] , [string] , [number] ) [EOL] refnames = keywords [ [string] ] . strip ( ) [EOL] if refnames . startswith ( [string] ) : [EOL] if verbose : [EOL] print ( [string] ) [EOL] raise NotThisMethod ( [string] ) [EOL] refs = set ( [ r . strip ( ) for r in refnames . strip ( [string] ) . split ( [string] ) ] ) [EOL] [comment] [EOL] [comment] [EOL] TAG = [string] [EOL] tags = set ( [ r [ len ( TAG ) : ] for r in refs if r . startswith ( TAG ) ] ) [EOL] if not tags : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tags = set ( [ r for r in refs if re . search ( [string] , r ) ] ) [EOL] if verbose : [EOL] print ( [string] % [string] . join ( refs - tags ) ) [EOL] if verbose : [EOL] print ( [string] % [string] . join ( sorted ( tags ) ) ) [EOL] for ref in sorted ( tags ) : [EOL] [comment] [EOL] if ref . startswith ( tag_prefix ) : [EOL] r = ref [ len ( tag_prefix ) : ] [EOL] if verbose : [EOL] print ( [string] % r ) [EOL] return { [string] : r , [string] : keywords [ [string] ] . strip ( ) , [string] : False , [string] : None , [string] : date } [EOL] [comment] [EOL] if verbose : [EOL] print ( [string] ) [EOL] return { [string] : [string] , [string] : keywords [ [string] ] . strip ( ) , [string] : False , [string] : [string] , [string] : None } [EOL] [EOL] [EOL] @ register_vcs_handler ( [string] , [string] ) def git_pieces_from_vcs ( tag_prefix , root , verbose , run_command = run_command ) : [EOL] [docstring] [EOL] GITS = [ [string] ] [EOL] if sys . platform == [string] : [EOL] GITS = [ [string] , [string] ] [EOL] [EOL] out , rc = run_command ( GITS , [ [string] , [string] ] , cwd = root , hide_stderr = True ) [EOL] if rc != [number] : [EOL] if verbose : [EOL] print ( [string] % root ) [EOL] raise NotThisMethod ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] describe_out , rc = run_command ( GITS , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] % tag_prefix ] , cwd = root ) [EOL] [comment] [EOL] if describe_out is None : [EOL] raise NotThisMethod ( [string] ) [EOL] describe_out = describe_out . strip ( ) [EOL] full_out , rc = run_command ( GITS , [ [string] , [string] ] , cwd = root ) [EOL] if full_out is None : [EOL] raise NotThisMethod ( [string] ) [EOL] full_out = full_out . strip ( ) [EOL] [EOL] pieces = { } [EOL] pieces [ [string] ] = full_out [EOL] pieces [ [string] ] = full_out [ : [number] ] [comment] [EOL] pieces [ [string] ] = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] git_describe = describe_out [EOL] [EOL] [comment] [EOL] dirty = git_describe . endswith ( [string] ) [EOL] pieces [ [string] ] = dirty [EOL] if dirty : [EOL] git_describe = git_describe [ : git_describe . rindex ( [string] ) ] [EOL] [EOL] [comment] [EOL] [EOL] if [string] in git_describe : [EOL] [comment] [EOL] mo = re . search ( [string] , git_describe ) [EOL] if not mo : [EOL] [comment] [EOL] pieces [ [string] ] = ( [string] % describe_out ) [EOL] return pieces [EOL] [EOL] [comment] [EOL] full_tag = mo . group ( [number] ) [EOL] if not full_tag . startswith ( tag_prefix ) : [EOL] if verbose : [EOL] fmt = [string] [EOL] print ( fmt % ( full_tag , tag_prefix ) ) [EOL] pieces [ [string] ] = ( [string] % ( full_tag , tag_prefix ) ) [EOL] return pieces [EOL] pieces [ [string] ] = full_tag [ len ( tag_prefix ) : ] [EOL] [EOL] [comment] [EOL] pieces [ [string] ] = int ( mo . group ( [number] ) ) [EOL] [EOL] [comment] [EOL] pieces [ [string] ] = mo . group ( [number] ) [EOL] [EOL] else : [EOL] [comment] [EOL] pieces [ [string] ] = None [EOL] count_out , rc = run_command ( GITS , [ [string] , [string] , [string] ] , cwd = root ) [EOL] pieces [ [string] ] = int ( count_out ) [comment] [EOL] [EOL] [comment] [EOL] date = run_command ( GITS , [ [string] , [string] , [string] , [string] ] , cwd = root ) [ [number] ] . strip ( ) [EOL] pieces [ [string] ] = date . strip ( ) . replace ( [string] , [string] , [number] ) . replace ( [string] , [string] , [number] ) [EOL] [EOL] return pieces [EOL] [EOL] [EOL] def do_vcs_install ( manifest_in , versionfile_source , ipy ) : [EOL] [docstring] [EOL] GITS = [ [string] ] [EOL] if sys . platform == [string] : [EOL] GITS = [ [string] , [string] ] [EOL] files = [ manifest_in , versionfile_source ] [EOL] if ipy : [EOL] files . append ( ipy ) [EOL] try : [EOL] me = __file__ [EOL] if me . endswith ( [string] ) or me . endswith ( [string] ) : [EOL] me = os . path . splitext ( me ) [ [number] ] + [string] [EOL] versioneer_file = os . path . relpath ( me ) [EOL] except NameError : [EOL] versioneer_file = [string] [EOL] files . append ( versioneer_file ) [EOL] present = False [EOL] try : [EOL] f = open ( [string] , [string] ) [EOL] for line in f . readlines ( ) : [EOL] if line . strip ( ) . startswith ( versionfile_source ) : [EOL] if [string] in line . strip ( ) . split ( ) [ [number] : ] : [EOL] present = True [EOL] f . close ( ) [EOL] except EnvironmentError : [EOL] pass [EOL] if not present : [EOL] f = open ( [string] , [string] ) [EOL] f . write ( [string] % versionfile_source ) [EOL] f . close ( ) [EOL] files . append ( [string] ) [EOL] run_command ( GITS , [ [string] , [string] ] + files ) [EOL] [EOL] [EOL] def versions_from_parentdir ( parentdir_prefix , root , verbose ) : [EOL] [docstring] [EOL] rootdirs = [ ] [EOL] [EOL] for i in range ( [number] ) : [EOL] dirname = os . path . basename ( root ) [EOL] if dirname . startswith ( parentdir_prefix ) : [EOL] return { [string] : dirname [ len ( parentdir_prefix ) : ] , [string] : None , [string] : False , [string] : None , [string] : None } [EOL] else : [EOL] rootdirs . append ( root ) [EOL] root = os . path . dirname ( root ) [comment] [EOL] [EOL] if verbose : [EOL] print ( [string] % ( str ( rootdirs ) , parentdir_prefix ) ) [EOL] raise NotThisMethod ( [string] ) [EOL] [EOL] [EOL] SHORT_VERSION_PY = [string] [EOL] [EOL] [EOL] def versions_from_file ( filename ) : [EOL] [docstring] [EOL] try : [EOL] with open ( filename ) as f : [EOL] contents = f . read ( ) [EOL] except EnvironmentError : [EOL] raise NotThisMethod ( [string] ) [EOL] mo = re . search ( [string] , contents , re . M | re . S ) [EOL] if not mo : [EOL] mo = re . search ( [string] , contents , re . M | re . S ) [EOL] if not mo : [EOL] raise NotThisMethod ( [string] ) [EOL] return json . loads ( mo . group ( [number] ) ) [EOL] [EOL] [EOL] def write_to_version_file ( filename , versions ) : [EOL] [docstring] [EOL] os . unlink ( filename ) [EOL] contents = json . dumps ( versions , sort_keys = True , indent = [number] , separators = ( [string] , [string] ) ) [EOL] with open ( filename , [string] ) as f : [EOL] f . write ( SHORT_VERSION_PY % contents ) [EOL] [EOL] print ( [string] % ( filename , versions [ [string] ] ) ) [EOL] [EOL] [EOL] def plus_or_dot ( pieces ) : [EOL] [docstring] [EOL] if [string] in pieces . get ( [string] , [string] ) : [EOL] return [string] [EOL] return [string] [EOL] [EOL] [EOL] def render_pep440 ( pieces ) : [EOL] [docstring] [EOL] if pieces [ [string] ] : [EOL] rendered = pieces [ [string] ] [EOL] if pieces [ [string] ] or pieces [ [string] ] : [EOL] rendered += plus_or_dot ( pieces ) [EOL] rendered += [string] % ( pieces [ [string] ] , pieces [ [string] ] ) [EOL] if pieces [ [string] ] : [EOL] rendered += [string] [EOL] else : [EOL] [comment] [EOL] rendered = [string] % ( pieces [ [string] ] , pieces [ [string] ] ) [EOL] if pieces [ [string] ] : [EOL] rendered += [string] [EOL] return rendered [EOL] [EOL] [EOL] def render_pep440_pre ( pieces ) : [EOL] [docstring] [EOL] if pieces [ [string] ] : [EOL] rendered = pieces [ [string] ] [EOL] if pieces [ [string] ] : [EOL] rendered += [string] % pieces [ [string] ] [EOL] else : [EOL] [comment] [EOL] rendered = [string] % pieces [ [string] ] [EOL] return rendered [EOL] [EOL] [EOL] def render_pep440_post ( pieces ) : [EOL] [docstring] [EOL] if pieces [ [string] ] : [EOL] rendered = pieces [ [string] ] [EOL] if pieces [ [string] ] or pieces [ [string] ] : [EOL] rendered += [string] % pieces [ [string] ] [EOL] if pieces [ [string] ] : [EOL] rendered += [string] [EOL] rendered += plus_or_dot ( pieces ) [EOL] rendered += [string] % pieces [ [string] ] [EOL] else : [EOL] [comment] [EOL] rendered = [string] % pieces [ [string] ] [EOL] if pieces [ [string] ] : [EOL] rendered += [string] [EOL] rendered += [string] % pieces [ [string] ] [EOL] return rendered [EOL] [EOL] [EOL] def render_pep440_old ( pieces ) : [EOL] [docstring] [EOL] if pieces [ [string] ] : [EOL] rendered = pieces [ [string] ] [EOL] if pieces [ [string] ] or pieces [ [string] ] : [EOL] rendered += [string] % pieces [ [string] ] [EOL] if pieces [ [string] ] : [EOL] rendered += [string] [EOL] else : [EOL] [comment] [EOL] rendered = [string] % pieces [ [string] ] [EOL] if pieces [ [string] ] : [EOL] rendered += [string] [EOL] return rendered [EOL] [EOL] [EOL] def render_git_describe ( pieces ) : [EOL] [docstring] [EOL] if pieces [ [string] ] : [EOL] rendered = pieces [ [string] ] [EOL] if pieces [ [string] ] : [EOL] rendered += [string] % ( pieces [ [string] ] , pieces [ [string] ] ) [EOL] else : [EOL] [comment] [EOL] rendered = pieces [ [string] ] [EOL] if pieces [ [string] ] : [EOL] rendered += [string] [EOL] return rendered [EOL] [EOL] [EOL] def render_git_describe_long ( pieces ) : [EOL] [docstring] [EOL] if pieces [ [string] ] : [EOL] rendered = pieces [ [string] ] [EOL] rendered += [string] % ( pieces [ [string] ] , pieces [ [string] ] ) [EOL] else : [EOL] [comment] [EOL] rendered = pieces [ [string] ] [EOL] if pieces [ [string] ] : [EOL] rendered += [string] [EOL] return rendered [EOL] [EOL] [EOL] def render ( pieces , style ) : [EOL] [docstring] [EOL] if pieces [ [string] ] : [EOL] return { [string] : [string] , [string] : pieces . get ( [string] ) , [string] : None , [string] : pieces [ [string] ] , [string] : None } [EOL] [EOL] if not style or style == [string] : [EOL] style = [string] [comment] [EOL] [EOL] if style == [string] : [EOL] rendered = render_pep440 ( pieces ) [EOL] elif style == [string] : [EOL] rendered = render_pep440_pre ( pieces ) [EOL] elif style == [string] : [EOL] rendered = render_pep440_post ( pieces ) [EOL] elif style == [string] : [EOL] rendered = render_pep440_old ( pieces ) [EOL] elif style == [string] : [EOL] rendered = render_git_describe ( pieces ) [EOL] elif style == [string] : [EOL] rendered = render_git_describe_long ( pieces ) [EOL] else : [EOL] raise ValueError ( [string] % style ) [EOL] [EOL] return { [string] : rendered , [string] : pieces [ [string] ] , [string] : pieces [ [string] ] , [string] : None , [string] : pieces . get ( [string] ) } [EOL] [EOL] [EOL] class VersioneerBadRootError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] def get_versions ( verbose = False ) : [EOL] [docstring] [EOL] if [string] in sys . modules : [EOL] [comment] [EOL] del sys . modules [ [string] ] [EOL] [EOL] root = get_root ( ) [EOL] cfg = get_config_from_root ( root ) [EOL] [EOL] assert cfg . VCS is not None , [string] [EOL] handlers = HANDLERS . get ( cfg . VCS ) [EOL] assert handlers , [string] % cfg . VCS [EOL] verbose = verbose or cfg . verbose [EOL] assert cfg . versionfile_source is not None , [string] [EOL] assert cfg . tag_prefix is not None , [string] [EOL] [EOL] versionfile_abs = os . path . join ( root , cfg . versionfile_source ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] get_keywords_f = handlers . get ( [string] ) [EOL] from_keywords_f = handlers . get ( [string] ) [EOL] if get_keywords_f and from_keywords_f : [EOL] try : [EOL] keywords = get_keywords_f ( versionfile_abs ) [EOL] ver = from_keywords_f ( keywords , cfg . tag_prefix , verbose ) [EOL] if verbose : [EOL] print ( [string] % ver ) [EOL] return ver [EOL] except NotThisMethod : [EOL] pass [EOL] [EOL] try : [EOL] ver = versions_from_file ( versionfile_abs ) [EOL] if verbose : [EOL] print ( [string] % ( versionfile_abs , ver ) ) [EOL] return ver [EOL] except NotThisMethod : [EOL] pass [EOL] [EOL] from_vcs_f = handlers . get ( [string] ) [EOL] if from_vcs_f : [EOL] try : [EOL] pieces = from_vcs_f ( cfg . tag_prefix , root , verbose ) [EOL] ver = render ( pieces , cfg . style ) [EOL] if verbose : [EOL] print ( [string] % ver ) [EOL] return ver [EOL] except NotThisMethod : [EOL] pass [EOL] [EOL] try : [EOL] if cfg . parentdir_prefix : [EOL] ver = versions_from_parentdir ( cfg . parentdir_prefix , root , verbose ) [EOL] if verbose : [EOL] print ( [string] % ver ) [EOL] return ver [EOL] except NotThisMethod : [EOL] pass [EOL] [EOL] if verbose : [EOL] print ( [string] ) [EOL] [EOL] return { [string] : [string] , [string] : None , [string] : None , [string] : [string] , [string] : None } [EOL] [EOL] [EOL] def get_version ( ) : [EOL] [docstring] [EOL] return get_versions ( ) [ [string] ] [EOL] [EOL] [EOL] def get_cmdclass ( ) : [EOL] [docstring] [EOL] if [string] in sys . modules : [EOL] del sys . modules [ [string] ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] cmds = { } [EOL] [EOL] [comment] [EOL] from distutils . core import Command [EOL] [EOL] class cmd_version ( Command ) : [EOL] description = [string] [EOL] user_options = [ ] [EOL] boolean_options = [ ] [EOL] [EOL] def initialize_options ( self ) : [EOL] pass [EOL] [EOL] def finalize_options ( self ) : [EOL] pass [EOL] [EOL] def run ( self ) : [EOL] vers = get_versions ( verbose = True ) [EOL] print ( [string] % vers [ [string] ] ) [EOL] print ( [string] % vers . get ( [string] ) ) [EOL] print ( [string] % vers . get ( [string] ) ) [EOL] print ( [string] % vers . get ( [string] ) ) [EOL] if vers [ [string] ] : [EOL] print ( [string] % vers [ [string] ] ) [EOL] cmds [ [string] ] = cmd_version [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if [string] in sys . modules : [EOL] from setuptools . command . build_py import build_py as _build_py [EOL] else : [EOL] from distutils . command . build_py import build_py as _build_py [EOL] [EOL] class cmd_build_py ( _build_py ) : [EOL] def run ( self ) : [EOL] root = get_root ( ) [EOL] cfg = get_config_from_root ( root ) [EOL] versions = get_versions ( ) [EOL] _build_py . run ( self ) [EOL] [comment] [EOL] [comment] [EOL] if cfg . versionfile_build : [EOL] target_versionfile = os . path . join ( self . build_lib , cfg . versionfile_build ) [EOL] print ( [string] % target_versionfile ) [EOL] write_to_version_file ( target_versionfile , versions ) [EOL] cmds [ [string] ] = cmd_build_py [EOL] [EOL] if [string] in sys . modules : [comment] [EOL] from cx_Freeze . dist import build_exe as _build_exe [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class cmd_build_exe ( _build_exe ) : [EOL] def run ( self ) : [EOL] root = get_root ( ) [EOL] cfg = get_config_from_root ( root ) [EOL] versions = get_versions ( ) [EOL] target_versionfile = cfg . versionfile_source [EOL] print ( [string] % target_versionfile ) [EOL] write_to_version_file ( target_versionfile , versions ) [EOL] [EOL] _build_exe . run ( self ) [EOL] os . unlink ( target_versionfile ) [EOL] with open ( cfg . versionfile_source , [string] ) as f : [EOL] LONG = LONG_VERSION_PY [ cfg . VCS ] [EOL] f . write ( LONG % { [string] : [string] , [string] : cfg . style , [string] : cfg . tag_prefix , [string] : cfg . parentdir_prefix , [string] : cfg . versionfile_source , } ) [EOL] cmds [ [string] ] = cmd_build_exe [EOL] del cmds [ [string] ] [EOL] [EOL] if [string] in sys . modules : [comment] [EOL] try : [EOL] from py2exe . distutils_buildexe import py2exe as _py2exe [comment] [EOL] except ImportError : [EOL] from py2exe . build_exe import py2exe as _py2exe [comment] [EOL] [EOL] class cmd_py2exe ( _py2exe ) : [EOL] def run ( self ) : [EOL] root = get_root ( ) [EOL] cfg = get_config_from_root ( root ) [EOL] versions = get_versions ( ) [EOL] target_versionfile = cfg . versionfile_source [EOL] print ( [string] % target_versionfile ) [EOL] write_to_version_file ( target_versionfile , versions ) [EOL] [EOL] _py2exe . run ( self ) [EOL] os . unlink ( target_versionfile ) [EOL] with open ( cfg . versionfile_source , [string] ) as f : [EOL] LONG = LONG_VERSION_PY [ cfg . VCS ] [EOL] f . write ( LONG % { [string] : [string] , [string] : cfg . style , [string] : cfg . tag_prefix , [string] : cfg . parentdir_prefix , [string] : cfg . versionfile_source , } ) [EOL] cmds [ [string] ] = cmd_py2exe [EOL] [EOL] [comment] [EOL] if [string] in sys . modules : [EOL] from setuptools . command . sdist import sdist as _sdist [EOL] else : [EOL] from distutils . command . sdist import sdist as _sdist [EOL] [EOL] class cmd_sdist ( _sdist ) : [EOL] def run ( self ) : [EOL] versions = get_versions ( ) [EOL] self . _versioneer_generated_versions = versions [EOL] [comment] [EOL] [comment] [EOL] self . distribution . metadata . version = versions [ [string] ] [EOL] return _sdist . run ( self ) [EOL] [EOL] def make_release_tree ( self , base_dir , files ) : [EOL] root = get_root ( ) [EOL] cfg = get_config_from_root ( root ) [EOL] _sdist . make_release_tree ( self , base_dir , files ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] target_versionfile = os . path . join ( base_dir , cfg . versionfile_source ) [EOL] print ( [string] % target_versionfile ) [EOL] write_to_version_file ( target_versionfile , self . _versioneer_generated_versions ) [EOL] cmds [ [string] ] = cmd_sdist [EOL] [EOL] return cmds [EOL] [EOL] [EOL] CONFIG_ERROR = [string] [EOL] [EOL] SAMPLE_CONFIG = [string] [EOL] [EOL] INIT_PY_SNIPPET = [string] [EOL] [EOL] [EOL] def do_setup ( ) : [EOL] [docstring] [EOL] root = get_root ( ) [EOL] try : [EOL] cfg = get_config_from_root ( root ) [EOL] except ( EnvironmentError , configparser . NoSectionError , configparser . NoOptionError ) as e : [EOL] if isinstance ( e , ( EnvironmentError , configparser . NoSectionError ) ) : [EOL] print ( [string] , file = sys . stderr ) [EOL] with open ( os . path . join ( root , [string] ) , [string] ) as f : [EOL] f . write ( SAMPLE_CONFIG ) [EOL] print ( CONFIG_ERROR , file = sys . stderr ) [EOL] return [number] [EOL] [EOL] print ( [string] % cfg . versionfile_source ) [EOL] with open ( cfg . versionfile_source , [string] ) as f : [EOL] LONG = LONG_VERSION_PY [ cfg . VCS ] [EOL] f . write ( LONG % { [string] : [string] , [string] : cfg . style , [string] : cfg . tag_prefix , [string] : cfg . parentdir_prefix , [string] : cfg . versionfile_source , } ) [EOL] [EOL] ipy = os . path . join ( os . path . dirname ( cfg . versionfile_source ) , [string] ) [EOL] if os . path . exists ( ipy ) : [EOL] try : [EOL] with open ( ipy , [string] ) as f : [EOL] old = f . read ( ) [EOL] except EnvironmentError : [EOL] old = [string] [EOL] if INIT_PY_SNIPPET not in old : [EOL] print ( [string] % ipy ) [EOL] with open ( ipy , [string] ) as f : [EOL] f . write ( INIT_PY_SNIPPET ) [EOL] else : [EOL] print ( [string] % ipy ) [EOL] else : [EOL] print ( [string] % ipy ) [EOL] ipy = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] manifest_in = os . path . join ( root , [string] ) [EOL] simple_includes = set ( ) [EOL] try : [EOL] with open ( manifest_in , [string] ) as f : [EOL] for line in f : [EOL] if line . startswith ( [string] ) : [EOL] for include in line . split ( ) [ [number] : ] : [EOL] simple_includes . add ( include ) [EOL] except EnvironmentError : [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] not in simple_includes : [EOL] print ( [string] ) [EOL] with open ( manifest_in , [string] ) as f : [EOL] f . write ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] if cfg . versionfile_source not in simple_includes : [EOL] print ( [string] % cfg . versionfile_source ) [EOL] with open ( manifest_in , [string] ) as f : [EOL] f . write ( [string] % cfg . versionfile_source ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] do_vcs_install ( manifest_in , cfg . versionfile_source , ipy ) [EOL] return [number] [EOL] [EOL] [EOL] def scan_setup_py ( ) : [EOL] [docstring] [EOL] found = set ( ) [EOL] setters = False [EOL] errors = [number] [EOL] with open ( [string] , [string] ) as f : [EOL] for line in f . readlines ( ) : [EOL] if [string] in line : [EOL] found . add ( [string] ) [EOL] if [string] in line : [EOL] found . add ( [string] ) [EOL] if [string] in line : [EOL] found . add ( [string] ) [EOL] if [string] in line : [EOL] setters = True [EOL] if [string] in line : [EOL] setters = True [EOL] if len ( found ) != [number] : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] errors += [number] [EOL] if setters : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] errors += [number] [EOL] return errors [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cmd = sys . argv [ [number] ] [EOL] if cmd == [string] : [EOL] errors = do_setup ( ) [EOL] errors += scan_setup_py ( ) [EOL] if errors : [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Union [EOL] import logging [EOL] import pprint [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from collections . abc import Mapping [EOL] import logging [EOL] from pathlib import Path [EOL] import pprint [EOL] import yaml [EOL] from typing import Union [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class FancyConfig ( Mapping ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path_config_to_load = ( Path . home ( ) . joinpath ( [string] ) ) , default_config_path = ( Path ( __file__ ) . resolve ( ) . parent . joinpath ( [string] ) ) ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] if isinstance ( path_config_to_load , str ) : [EOL] path_config_to_load = Path ( path_config_to_load ) . resolve ( ) [EOL] [EOL] if isinstance ( default_config_path , str ) : [EOL] default_config_path = Path ( default_config_path ) . resolve ( ) [EOL] [EOL] if not path_config_to_load . exists ( ) : [EOL] LOGGER . info ( ( f' [string] ' f' [string] { default_config_path }' ) ) [EOL] [comment] [EOL] path_config_to_load . parent . mkdir ( parents = True , exist_ok = True ) [EOL] [comment] [EOL] path_config_to_load . write_bytes ( default_config_path . read_bytes ( ) ) [EOL] [EOL] with path_config_to_load . open ( mode = [string] , encoding = [string] ) as yaml_config_file : [EOL] self . _config = yaml . safe_load ( yaml_config_file ) [EOL] [EOL] def __getitem__ ( self , item ) : [EOL] [docstring] [EOL] try : [EOL] return self . _config [ item ] [EOL] except KeyError : [EOL] LOGGER . error ( f' [string] { item } [string] ' ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] return iter ( self . _config ) [EOL] [EOL] def __len__ ( self ) : [EOL] [docstring] [EOL] return len ( self . _config ) [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return f'{ super ( ) . __repr__ } [string] { str ( self . _config ) }' [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] pretty = pprint . PrettyPrinter ( indent = [number] ) [EOL] return pretty . pformat ( self . _config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pprint.PrettyPrinter$ 0 0 0 0 0 0 0 0 0 0 0 $pprint.PrettyPrinter$ 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from . _version import get_versions [EOL] [EOL] [comment] [EOL] from . import plot [EOL] [EOL] from . fancy import ( avg_dicts , cast_to_category_pd , concat_with_categories , dates_split , get_peaks , idict , kwargs_2_list , log_df , mem_usage_pd , normalization_pd , parse_date , pipe_multiprocessing_pd , read_sql_by_chunks , size_2_square , sliding_window , value_2_list , ) [EOL] [EOL] from . config import FancyConfig [EOL] [EOL] [comment] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] [comment] [EOL] FORMAT = [string] [EOL] logging . basicConfig ( format = FORMAT , level = logging . INFO ) [EOL] [EOL] __version__ = get_versions ( ) [ [string] ] [EOL] del get_versions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . plot import ( get_n_colors , plot_cluster , plot_confusion_matrix , plot_correlation , plot_counter , plot_history , plot_kmeans , plot_pca_explained_variance_ratio , plot_pie , plot_predictions , plot_series , plot_true_vs_pred , set_thousands_separator , ) [EOL] [EOL] [comment] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import pathlib [EOL] import typing [EOL] import bff [EOL] [docstring] [EOL] import filecmp [EOL] from pathlib import Path [EOL] import unittest [EOL] import unittest . mock [EOL] import os [EOL] [EOL] from bff . config import FancyConfig [EOL] [EOL] [EOL] class TestiFancyConfig ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_create_config ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] __ = FancyConfig ( ) [EOL] [EOL] default_path_ok = Path ( __file__ ) . resolve ( ) . parent . parent . joinpath ( [string] ) [EOL] default_path_ko = Path . home ( ) . resolve ( ) . joinpath ( [string] ) [EOL] [EOL] dest = Path ( __file__ ) . resolve ( ) . parent . joinpath ( [string] ) [EOL] config_a = FancyConfig ( dest , default_path_ok ) [EOL] [EOL] [comment] [EOL] self . assertTrue ( filecmp . cmp ( dest , default_path_ok ) ) [EOL] [EOL] [comment] [EOL] path_conf_b = Path ( __file__ ) . resolve ( ) . parent . joinpath ( [string] ) [EOL] with path_conf_b . open ( mode = [string] , encoding = [string] ) as f : [EOL] f . write ( [string] ) [EOL] config_b = FancyConfig ( dest , path_conf_b ) [EOL] [EOL] self . assertFalse ( filecmp . cmp ( dest , path_conf_b ) ) [EOL] [comment] [EOL] self . assertEqual ( config_a , config_b ) [EOL] [comment] [EOL] self . assertEqual ( len ( config_b ) , [number] ) [EOL] [EOL] [comment] [EOL] print_pretty = ( [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] self . assertEqual ( str ( config_b ) , print_pretty ) [EOL] [EOL] print_repr = ( [string] [string] [string] ) [EOL] [EOL] self . assertEqual ( repr ( config_b ) . split ( [string] ) [ [number] ] , print_repr ) [EOL] [EOL] [comment] [EOL] dest . unlink ( ) [EOL] path_conf_b . unlink ( ) [EOL] [EOL] [comment] [EOL] config_c = FancyConfig ( path_conf_b , default_path_ok ) [EOL] self . assertEqual ( config_a , config_c ) [EOL] [EOL] [comment] [EOL] path_conf_b . unlink ( ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( FileNotFoundError ) : [EOL] FancyConfig ( dest , default_path_ko ) [EOL] [EOL] def test_access_config ( self ) : [EOL] [docstring] [EOL] default_path_ok = Path ( __file__ ) . resolve ( ) . parent . parent . joinpath ( [string] ) [EOL] dest = Path ( __file__ ) . resolve ( ) . parent . joinpath ( [string] ) [EOL] config = FancyConfig ( dest , default_path_ok ) [EOL] [EOL] self . assertEqual ( config [ [string] ] , [string] ) [EOL] self . assertEqual ( config [ [string] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( config [ [string] ] [ [string] ] , [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] with unittest . mock . patch ( [string] ) as mock_logging : [EOL] __ = config [ [string] ] [EOL] mock_logging . assert_called_with ( [string] ) [EOL] [EOL] [comment] [EOL] dest . unlink ( ) [EOL] [EOL] [comment] [EOL] default_path_ok_str = os . path . join ( Path ( __file__ ) . resolve ( ) . parent . parent , [string] ) [EOL] dest_str = os . path . join ( Path ( __file__ ) . resolve ( ) . parent , [string] ) [EOL] config = FancyConfig ( dest_str , default_path_ok_str ) [EOL] [EOL] self . assertEqual ( config [ [string] ] , [string] ) [EOL] self . assertEqual ( config [ [string] ] [ [string] ] , [string] ) [EOL] self . assertEqual ( config [ [string] ] [ [string] ] , [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] Path ( dest_str ) . unlink ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 $bff.config.FancyConfig$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bff.config.FancyConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Type , Tuple , Union , Any , List , Set , Sequence [EOL] import typing [EOL] import datetime [EOL] import tests [EOL] [docstring] [EOL] import datetime [EOL] import unittest [EOL] import unittest . mock [EOL] import sys [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] from numpy . testing import assert_array_equal [EOL] import pandas as pd [EOL] from pandas . api . types import CategoricalDtype [EOL] import pandas . util . testing as tm [EOL] from sklearn . preprocessing import StandardScaler [EOL] [EOL] from bff . fancy import ( avg_dicts , cast_to_category_pd , concat_with_categories , dates_split , get_peaks , idict , kwargs_2_list , log_df , mem_usage_pd , normalization_pd , parse_date , pipe_multiprocessing_pd , size_2_square , sliding_window , value_2_list ) [EOL] [EOL] [EOL] def df_dummy_func_one ( df , i = [number] ) : [EOL] [docstring] [EOL] df = df . assign ( d = None ) [EOL] for row in df . itertuples ( ) : [EOL] df . at [ row . Index , [string] ] = df . at [ row . Index , [string] ] + i [EOL] return df [EOL] [EOL] [EOL] def df_dummy_func_two ( df , i = [number] ) : [EOL] [docstring] [EOL] return df . assign ( d = lambda x : x [ [string] ] ** i ) [EOL] [EOL] [EOL] class TestFancy ( unittest . TestCase ) : [EOL] [docstring] [EOL] [comment] [EOL] columns = [ [string] , [string] , [string] ] [EOL] df = pd . DataFrame ( [ [ [string] , [number] , [string] ] , [ [string] , [number] , [string] ] , [ [string] , [number] , [string] ] , [ [string] , [number] , [string] ] , [ [string] , [number] , [string] ] ] , columns = columns ) [EOL] [EOL] def test_avg_dicts ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] dic_std_a = { [string] : [number] , [string] : [number] } [EOL] dic_std_b = { [string] : [number] , [string] : [number] } [EOL] dic_std_c = { [string] : [number] , [string] : [number] } [EOL] res_std = avg_dicts ( dic_std_a , dic_std_b , dic_std_c ) [EOL] self . assertEqual ( res_std [ [string] ] , ( dic_std_a [ [string] ] + dic_std_b [ [string] ] + dic_std_c [ [string] ] ) / [number] ) [EOL] self . assertEqual ( res_std [ [string] ] , ( dic_std_a [ [string] ] + dic_std_b [ [string] ] + dic_std_c [ [string] ] ) / [number] ) [EOL] [EOL] [comment] [EOL] dic_miss_d = { [string] : [number] , [string] : [number] } [EOL] dic_miss_e = { [string] : [number] , [string] : [number] } [EOL] res_missing_key = avg_dicts ( dic_std_a , dic_miss_d , dic_miss_e ) [EOL] self . assertEqual ( res_missing_key [ [string] ] , ( dic_std_a [ [string] ] + dic_miss_d [ [string] ] ) / [number] ) [EOL] self . assertEqual ( res_missing_key [ [string] ] , ( dic_miss_d [ [string] ] + dic_miss_e [ [string] ] ) / [number] ) [EOL] self . assertEqual ( res_missing_key [ [string] ] , ( dic_miss_e [ [string] ] ) / [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] dic_str_f = { [string] : [number] , [string] : [string] } [EOL] [comment] [EOL] dic_str_g = { [string] : [number] , [string] : [ [number] , [number] , [number] ] } [EOL] self . assertRaises ( TypeError , avg_dicts , dic_std_a , dic_str_f ) [EOL] self . assertRaises ( TypeError , avg_dicts , dic_std_a , dic_std_b , dic_str_g ) [EOL] [EOL] def test_cast_to_category_pd ( self ) : [EOL] [docstring] [EOL] original_types = { [string] : np . dtype ( [string] ) , [string] : np . dtype ( [string] ) , [string] : np . dtype ( [string] ) } [EOL] self . assertDictEqual ( self . df . dtypes . to_dict ( ) , original_types ) [EOL] [EOL] df_optimized = cast_to_category_pd ( self . df ) [EOL] [EOL] tm . assert_frame_equal ( self . df , df_optimized , check_dtype = False , check_categorical = False ) [EOL] [EOL] country_type = CategoricalDtype ( categories = [ [string] , [string] ] , ordered = False ) [EOL] optimized_types = { [string] : np . dtype ( [string] ) , [string] : np . dtype ( [string] ) , [string] : country_type } [EOL] self . assertDictEqual ( df_optimized . dtypes . to_dict ( ) , optimized_types ) [EOL] [EOL] [comment] [EOL] df_unhashable = self . df . copy ( ) . assign ( dummy = None ) [EOL] for row in df_unhashable . itertuples ( ) : [EOL] df_unhashable . at [ row . Index , [string] ] = np . array ( [ [number] , [number] , [number] ] ) [EOL] df_unhashable_optimized = cast_to_category_pd ( df_unhashable ) [EOL] tm . assert_frame_equal ( df_unhashable , df_unhashable_optimized , check_dtype = False , check_categorical = False ) [EOL] [comment] [EOL] optimized_types [ [string] ] = np . dtype ( [string] ) [EOL] self . assertDictEqual ( df_unhashable_optimized . dtypes . to_dict ( ) , optimized_types ) [EOL] [EOL] def test_concat_with_categories ( self ) : [EOL] [docstring] [EOL] column_types = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] columns = list ( column_types . keys ( ) ) [EOL] df_left = pd . DataFrame ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] , columns = columns ) . astype ( column_types ) [EOL] df_right = pd . DataFrame ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] , columns = columns ) . astype ( column_types ) [EOL] df_res = pd . DataFrame ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] , columns = columns ) . astype ( column_types ) [EOL] df_concat = concat_with_categories ( df_left , df_right , ignore_index = True ) [EOL] [comment] [EOL] tm . assert_frame_equal ( df_res , df_concat ) [EOL] [comment] [EOL] self . assertTrue ( pd . api . types . is_object_dtype ( df_concat [ [string] ] ) ) [EOL] self . assertTrue ( pd . api . types . is_categorical_dtype ( df_concat [ [string] ] ) ) [EOL] self . assertTrue ( pd . api . types . is_categorical_dtype ( df_concat [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] df_left_wrong = pd . DataFrame ( [ [ [string] , [string] , [string] ] ] , columns = [ [string] , [string] , [string] ] ) [EOL] self . assertRaises ( AssertionError , concat_with_categories , df_left_wrong , df_right ) [EOL] [EOL] def test_dates_split ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] d_start = datetime . datetime ( [number] , [number] , [number] ) [EOL] d_end = datetime . datetime ( [number] , [number] , [number] ) [EOL] ranges_1 = dates_split ( d_start , d_end , [number] ) [EOL] res_1 = [ ( datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) ) , ( datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) ) , ( datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) ) ] [EOL] self . assertListEqual ( ranges_1 , res_1 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] d_start = datetime . datetime ( [number] , [number] , [number] ) [EOL] d_end = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] ranges_2 = dates_split ( d_start , d_end , [number] ) [EOL] res_2 = [ ( datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) , ( datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) ] [EOL] self . assertListEqual ( ranges_2 , res_2 ) [EOL] [EOL] def test_get_peaks ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] values = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] dates = pd . date_range ( [string] , periods = len ( values ) , freq = [string] ) [EOL] s = pd . Series ( values , index = dates ) [EOL] [EOL] [comment] [EOL] peak_dates , peak_values = get_peaks ( s ) [EOL] [EOL] peak_dates_res = [ np . datetime64 ( [string] ) , np . datetime64 ( [string] ) ] [EOL] peak_values_res = [ [number] , [number] ] [EOL] [EOL] assert_array_equal ( peak_dates , peak_dates_res ) [EOL] assert_array_equal ( peak_values , peak_values_res ) [EOL] [EOL] [comment] [EOL] self . assertRaises ( AssertionError , get_peaks , pd . Series ( values , index = range ( len ( values ) ) ) ) [EOL] [EOL] def test_idict ( self ) : [EOL] [docstring] [EOL] valid_dict = { [number] : [number] , [number] : [number] , [number] : [number] } [EOL] another_valid_dict = { [string] : [number] , [number] : [string] , [number] : [string] } [EOL] dataloss_dict = { [number] : [number] , [number] : [number] , [number] : [number] } [EOL] invalid_dict = { [number] : [ [number] ] , [number] : [ [number] ] , [number] : [ [number] ] } [EOL] [EOL] self . assertEqual ( idict ( valid_dict ) , { [number] : [number] , [number] : [number] , [number] : [number] } ) [EOL] self . assertEqual ( idict ( another_valid_dict ) , { [number] : [string] , [string] : [number] , [string] : [number] } ) [EOL] self . assertEqual ( idict ( dataloss_dict ) , { [number] : [number] , [number] : [number] } ) [EOL] self . assertRaises ( TypeError , idict , invalid_dict ) [EOL] [EOL] def test_kwargs_2_list ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertEqual ( kwargs_2_list ( seq = [ [number] , [number] , [number] ] ) , { [string] : [ [number] , [number] , [number] ] } ) [EOL] [comment] [EOL] self . assertEqual ( kwargs_2_list ( age = [number] ) , { [string] : [ [number] ] } ) [EOL] [comment] [EOL] self . assertEqual ( kwargs_2_list ( name = [string] ) , { [string] : [ [string] ] } ) [EOL] [comment] [EOL] self . assertEqual ( kwargs_2_list ( children = ( [string] , [number] ) ) , { [string] : ( [string] , [number] ) } ) [EOL] [comment] [EOL] self . assertEqual ( kwargs_2_list ( info = { [string] : [string] , [string] : [number] } ) , { [string] : [ { [string] : [string] , [string] : [number] } ] } ) [EOL] [comment] [EOL] self . assertRaises ( TypeError , kwargs_2_list , [ [number] , [number] , [number] ] ) [EOL] [comment] [EOL] self . assertEqual ( kwargs_2_list ( name = [string] , age = [number] , children = ( [string] , [number] ) ) , { [string] : [ [string] ] , [string] : [ [number] ] , [string] : ( [string] , [number] ) } ) [EOL] [EOL] def test_log_df ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] with unittest . mock . patch ( [string] ) as mock_logging : [EOL] log_df ( self . df ) [EOL] mock_logging . assert_called_with ( f'{ self . df . shape }' ) [EOL] [EOL] [comment] [EOL] df = tm . makeDataFrame ( ) . head ( ) [EOL] with unittest . mock . patch ( [string] ) as mock_logging : [EOL] df_res = ( df . assign ( E = [number] ) . pipe ( log_df , lambda x : x . shape , [string] ) ) [EOL] mock_logging . assert_called_with ( f' [string] { df_res . shape }' ) [EOL] [EOL] [comment] [EOL] with unittest . mock . patch ( [string] ) as mock_logging : [EOL] df_res = ( df . assign ( F = [number] ) . pipe ( log_df , lambda x : x . shape , [string] ) ) [EOL] mock_logging . assert_called_with ( f' [string] { df_res . shape }' ) [EOL] [EOL] def test_mem_usage_pd ( self ) : [EOL] [docstring] [EOL] df = pd . DataFrame ( { [string] : [ f' [string] { i }' for i in range ( [number] ) ] , [string] : range ( [number] ) , [string] : [ float ( i ) for i in range ( [number] ) ] } ) . set_index ( [string] ) [EOL] [EOL] test_1 = mem_usage_pd ( df , details = False ) [EOL] res_1 = { [string] : [string] } [EOL] self . assertDictEqual ( test_1 , res_1 ) [EOL] [EOL] test_2 = mem_usage_pd ( df ) [EOL] res_2 = { [string] : { [string] , [string] } , [string] : { [string] , np . dtype ( [string] ) } , [string] : { [string] , np . dtype ( [string] ) } , [string] : [string] } [EOL] self . assertDictEqual ( test_2 , res_2 ) [EOL] [EOL] serie = df . reset_index ( ) [ [string] ] [EOL] [EOL] test_3 = mem_usage_pd ( serie , details = False ) [EOL] res_3 = { [string] : [string] } [EOL] self . assertDictEqual ( test_3 , res_3 ) [EOL] [EOL] [comment] [EOL] with unittest . mock . patch ( [string] ) as mock_logging : [EOL] mem_usage_pd ( serie , details = True ) [EOL] mock_logging . assert_called_with ( [string] ) [EOL] [EOL] [comment] [EOL] self . assertRaises ( AttributeError , mem_usage_pd , { [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_normalization_pd ( self ) : [EOL] [docstring] [EOL] data = { [string] : [ [number] , [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] , [number] ] , [string] : [ [string] , [string] , [string] , [string] , [string] ] } [EOL] df = pd . DataFrame ( data ) [EOL] [EOL] [comment] [EOL] df_std = df . pipe ( normalization_pd , columns = [ [string] ] , scaler = StandardScaler ) [EOL] data_std = data . copy ( ) [EOL] data_std [ [string] ] = [ [number] , - [number] , - [number] , - [number] , [number] ] [EOL] df_std_res = pd . DataFrame ( data_std ) . astype ( { [string] : np . float32 } ) [EOL] tm . assert_frame_equal ( df_std , df_std_res , check_dtype = True , check_categorical = False ) [EOL] [EOL] [comment] [EOL] df_min_max = normalization_pd ( df , suffix = [string] , feature_range = ( [number] , [number] ) , new_type = np . float64 ) [EOL] data_min_max = data . copy ( ) [EOL] data_min_max [ [string] ] = [ [number] , [number] , [number] , [number] , [number] ] [EOL] data_min_max [ [string] ] = [ [number] , [number] , [number] , [number] , [number] ] [EOL] df_min_max_res = pd . DataFrame ( data_min_max ) [EOL] tm . assert_frame_equal ( df_min_max , df_min_max_res , check_dtype = True , check_categorical = False ) [EOL] [EOL] def test_parse_date ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] @ parse_date def dummy_function ( ** kwargs ) : [EOL] return kwargs [EOL] [EOL] list_parses = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] list_results = [ datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , datetime . datetime ( [number] , [number] , [number] , [number] , [number] ) ] [EOL] [EOL] for parse , result in zip ( list_parses , list_results ) : [EOL] self . assertEqual ( dummy_function ( date = parse ) [ [string] ] , result ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ parse_date ( date_fields = [ [string] , [string] ] ) def dummy_function_custom ( ** kwargs ) : [EOL] return kwargs [EOL] [EOL] parse_1 = dummy_function_custom ( date_start = [string] , date_end = [string] ) [EOL] self . assertEqual ( parse_1 [ [string] ] , datetime . datetime ( [number] , [number] , [number] ) ) [EOL] self . assertEqual ( parse_1 [ [string] ] , datetime . datetime ( [number] , [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( dummy_function ( date = [string] ) [ [string] ] , [string] ) [EOL] [EOL] def test_pipe_multiprocessing_pd_one ( self ) : [EOL] [docstring] [EOL] [EOL] df_a = pd . DataFrame ( { [string] : [ [number] , [number] , [number] ] } ) [EOL] [EOL] tm . assert_frame_equal ( pipe_multiprocessing_pd ( df_a , df_dummy_func_one , nb_proc = [number] ) , pd . DataFrame ( { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] } ) , check_dtype = False , check_categorical = False ) [EOL] tm . assert_frame_equal ( pipe_multiprocessing_pd ( df_a , df_dummy_func_one , i = [number] , nb_proc = [number] ) , pd . DataFrame ( { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] } ) , check_dtype = False , check_categorical = False ) [EOL] [EOL] def test_pipe_multiprocessing_pd_two ( self ) : [EOL] [docstring] [EOL] df_a = pd . DataFrame ( { [string] : [ [number] , [number] , [number] ] } ) [EOL] [EOL] tm . assert_frame_equal ( pipe_multiprocessing_pd ( df_a , df_dummy_func_two , nb_proc = [number] ) , pd . DataFrame ( { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] } ) , check_dtype = False , check_categorical = False ) [EOL] [EOL] tm . assert_frame_equal ( pipe_multiprocessing_pd ( df_a , df_dummy_func_two , i = [number] , nb_proc = [number] ) , pd . DataFrame ( { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] } ) , check_dtype = False , check_categorical = False ) [EOL] [EOL] def test_size_2_square ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertEqual ( size_2_square ( [number] ) , ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( size_2_square ( [number] ) , ( [number] , [number] ) ) [EOL] [EOL] def test_sliding_window ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertEqual ( list ( sliding_window ( [string] , [number] , [number] ) ) , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] res_np_1 = list ( sliding_window ( np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) , [number] , [number] ) ) [EOL] np . testing . assert_array_equal ( res_np_1 [ [number] ] , np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] np . testing . assert_array_equal ( res_np_1 [ [number] ] , np . array ( [ [number] ] ) ) [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( list ( sliding_window ( [string] , [number] , [number] ) ) , [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( list ( sliding_window ( [string] , [number] , [number] ) ) , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( list ( sliding_window ( [string] , [number] , [number] ) ) , [ [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( list ( sliding_window ( [string] , [number] , [number] ) ) , [ [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( list ( sliding_window ( [string] , [number] , [number] ) ) , [ [string] , [string] ] ) [EOL] self . assertEqual ( list ( sliding_window ( [string] , [number] , [number] ) ) , [ [string] , [string] ] ) [EOL] self . assertEqual ( list ( sliding_window ( [string] , [number] , [number] ) ) , [ [string] , [string] ] ) [EOL] [comment] [EOL] seq_1 = [string] [EOL] res_1 = [ [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( list ( sliding_window ( seq_1 , [number] , [number] ) ) , res_1 ) [EOL] res_2 = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( list ( sliding_window ( seq_1 , [number] , [number] ) ) , res_2 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with self . assertRaises ( TypeError ) : [EOL] list ( sliding_window ( [number] , [number] , [number] ) ) [EOL] [comment] [EOL] with self . assertRaises ( TypeError ) : [EOL] list ( sliding_window ( seq_1 , [number] , [number] ) ) [EOL] with self . assertRaises ( TypeError ) : [EOL] list ( sliding_window ( seq_1 , [number] , [string] ) ) [EOL] [comment] [EOL] with self . assertRaises ( TypeError ) : [EOL] list ( sliding_window ( seq_1 , [number] , [number] ) ) [EOL] with self . assertRaises ( TypeError ) : [EOL] list ( sliding_window ( seq_1 , [string] , [number] ) ) [EOL] [comment] [EOL] [comment] [EOL] with self . assertRaises ( ValueError ) : [EOL] list ( sliding_window ( seq_1 , [number] , [number] ) ) [EOL] with self . assertRaises ( ValueError ) : [EOL] list ( sliding_window ( seq_1 , - [number] , - [number] ) ) [EOL] [comment] [EOL] with self . assertRaises ( ValueError ) : [EOL] list ( sliding_window ( seq_1 , [number] , [number] ) ) [EOL] with self . assertRaises ( ValueError ) : [EOL] list ( sliding_window ( seq_1 , [number] , - [number] ) ) [EOL] [comment] [EOL] [comment] [EOL] with self . assertRaises ( ValueError ) : [EOL] list ( sliding_window ( [string] , [number] , [number] ) ) [EOL] [EOL] def test_value_2_list ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertEqual ( value_2_list ( [ [number] , [number] , [number] ] ) , [ [number] , [number] , [number] ] ) [EOL] [comment] [EOL] self . assertEqual ( value_2_list ( [number] ) , [ [number] ] ) [EOL] [comment] [EOL] self . assertEqual ( value_2_list ( [string] ) , [ [string] ] ) [EOL] [comment] [EOL] self . assertEqual ( value_2_list ( ( [string] , [number] ) ) , ( [string] , [number] ) ) [EOL] [comment] [EOL] self . assertEqual ( value_2_list ( { [string] : [string] , [string] : [number] } ) , [ { [string] : [string] , [string] : [number] } ] ) [EOL] [comment] [EOL] __ , axes_a = plt . subplots ( nrows = [number] , ncols = [number] ) [EOL] self . assertEqual ( len ( value_2_list ( axes_a ) ) , [number] ) [EOL] [comment] [EOL] __ , axes_b = plt . subplots ( nrows = [number] , ncols = [number] ) [EOL] self . assertEqual ( len ( value_2_list ( axes_b ) ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] from pkg_resources import load_entry_point [EOL] sys . exit ( load_entry_point ( [string] , [string] , [string] ) ( ) ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_fancy.TestFancy]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Dict[builtins.str,builtins.float]$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Tuple[datetime.datetime,datetime.datetime]]$ 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 $typing.List[typing.Tuple[datetime.datetime,datetime.datetime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Tuple[datetime.datetime,datetime.datetime]]$ 0 $typing.List[typing.Tuple[datetime.datetime,datetime.datetime]]$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Tuple[datetime.datetime,datetime.datetime]]$ 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 $typing.List[typing.Tuple[datetime.datetime,datetime.datetime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Tuple[datetime.datetime,datetime.datetime]]$ 0 $typing.List[typing.Tuple[datetime.datetime,datetime.datetime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Union[builtins.int,builtins.str],typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Union[builtins.int,builtins.str],typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Set[typing.Any],builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Set[typing.Any],builtins.str]]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Set[typing.Any],builtins.str]]$ 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Set[typing.Any],builtins.str]]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Set[typing.Any],builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Set[typing.Any],builtins.str]]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Dict , List , Type , Any [EOL] import typing [EOL] import tests [EOL] [docstring] [EOL] from collections import Counter [EOL] import unittest [EOL] import unittest . mock [EOL] import matplotlib . cm as cm [EOL] import matplotlib . pyplot as plt [EOL] from matplotlib . ticker import FuncFormatter [EOL] import numpy as np [EOL] import pandas as pd [EOL] import pytest [EOL] from sklearn import datasets [EOL] from sklearn . cluster import KMeans [EOL] from sklearn . decomposition import PCA [EOL] from sklearn . manifold import TSNE [EOL] [EOL] import bff . plot as bplt [EOL] [EOL] [EOL] class TestPlot ( unittest . TestCase ) : [EOL] [docstring] [EOL] [comment] [EOL] np . random . seed ( [number] ) [EOL] [EOL] history = { [string] : [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] } [EOL] [EOL] history_without_val = { k : v for k , v in history . items ( ) if k in [ [string] , [string] ] } [EOL] history_mult = { k : v [ : - [number] ] for k , v in history . items ( ) } [EOL] [EOL] y_true = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] y_pred = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] y_true_matrix = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] y_pred_matrix = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] y_true_matrix_cat = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] y_pred_matrix_cat = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] AXIS = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] data = ( pd . DataFrame ( np . random . randint ( [number] , [number] , size = ( [number] * [number] , [number] ) ) , columns = AXIS . keys ( ) ) . set_index ( pd . date_range ( [string] , periods = [number] * [number] , freq = [string] ) ) . rename_axis ( [string] ) ) [EOL] [EOL] [comment] [EOL] data_miss = ( data . drop ( pd . date_range ( [string] , [string] , freq = [string] ) ) . drop ( pd . date_range ( [string] , [string] , freq = [string] ) ) . drop ( pd . date_range ( [string] , [string] , freq = [string] ) ) ) [EOL] [comment] [EOL] counter = Counter ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [comment] [EOL] counter_pie = Counter ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [comment] [EOL] dict_to_plot = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] dict_to_plot_numerical = { [number] : [number] , [number] : [number] , [number] : [number] } [EOL] [EOL] [comment] [EOL] X , y = datasets . make_circles ( n_samples = [number] , factor = [number] , noise = [number] , random_state = [number] ) [EOL] df = pd . DataFrame ( X ) . assign ( label = y ) [EOL] tsne = TSNE ( n_iter = [number] ) [EOL] tsne_results = tsne . fit_transform ( df . drop ( [string] , axis = [string] ) ) [EOL] df_tsne = df [ [ [string] ] ] . assign ( col_1 = tsne_results [ : , [number] ] , col_2 = tsne_results [ : , [number] ] ) [EOL] [EOL] [comment] [EOL] pca = PCA ( n_components = [number] ) . fit_transform ( tsne_results ) [EOL] kmeans = KMeans ( n_clusters = [number] , random_state = [number] ) . fit ( pca ) [EOL] df_kmeans = pd . DataFrame ( { [string] : pca [ : , [number] ] , [string] : pca [ : , [number] ] , [string] : kmeans . predict ( pca ) } ) [EOL] [EOL] def test_get_n_colors ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . assertRaises ( AssertionError , bplt . get_n_colors , [number] , [string] ) [EOL] [EOL] colors = bplt . get_n_colors ( [number] ) [EOL] res = [ np . array ( [ [number] , [number] , [number] , [number] ] ) , np . array ( [ [number] , [number] , [number] , [number] ] ) , np . array ( [ [number] , [number] , [number] , [number] ] ) ] [EOL] np . testing . assert_allclose ( colors , res ) [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_cluster ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_cluster ( self . df_tsne , label_col = [string] , labels = [ [string] , [string] ] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_cluster_with_colors ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_cluster ( self . df_tsne , label_col = [string] , colors = [ [string] , [string] ] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_cluster_without_label ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_cluster ( self . df_tsne ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_cluster_without_label_with_color ( self ) : [EOL] [docstring] [EOL] cmap = cm . get_cmap ( [string] ) [EOL] colors = list ( cmap ( np . linspace ( [number] , [number] , self . df_tsne . shape [ [number] ] ) ) ) [EOL] ax = bplt . plot_cluster ( self . df_tsne , colors = colors , label_x = [string] , label_y = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_cluster_warning_colors ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] with unittest . mock . patch ( [string] ) as mock_logging : [EOL] ax = bplt . plot_cluster ( self . df_tsne , label_col = [string] , colors = [ [string] ] ) [EOL] mock_logging . assert_called_with ( [string] [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_cluster_warning_labels ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] with unittest . mock . patch ( [string] ) as mock_logging : [EOL] ax = bplt . plot_cluster ( self . df_tsne , label_col = [string] , labels = [string] ) [EOL] mock_logging . assert_called_with ( [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_annotation_fmt ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix , normalize = [string] , annotation_fmt = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_cbar_fmt ( self ) : [EOL] [docstring] [EOL] cbar_fmt = FuncFormatter ( lambda x , p : format ( float ( x ) , [string] ) ) [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix , normalize = [string] , cbar_fmt = cbar_fmt ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_fmt_thousand ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix * [number] , self . y_pred_matrix * [number] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_labels_filter ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix , labels_filter = [ [number] , [number] ] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_normalize ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix , normalize = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_sample_weight ( self ) : [EOL] [docstring] [EOL] weights = range ( [number] , len ( self . y_true_matrix ) + [number] ) [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix , sample_weight = weights ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_stats_acc ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix , stats = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_stats_error ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] with unittest . mock . patch ( [string] ) as mock_logging : [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix_cat , self . y_pred_matrix_cat , stats = [string] ) [EOL] mock_logging . assert_called_with ( [string] [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_stats_prec ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix , stats = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_stats_fscore ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix_cat , self . y_pred_matrix_cat , stats = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_ticklabels_cat ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix_cat , self . y_pred_matrix_cat ) [EOL] [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_ticklabels_false ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix , ticklabels = False ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_confusion_matrix_ticklabels_n_labels ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_confusion_matrix ( self . y_true_matrix , self . y_pred_matrix , ticklabels = [number] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_correlation ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_correlation ( self . data ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_correlation_with_ax ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] df_tmp = pd . DataFrame ( { [string] : [ [number] , [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] , [number] ] } ) [EOL] df_corr = df_tmp . corr ( ) [EOL] [EOL] fig , axes = plt . subplots ( nrows = [number] , ncols = [number] , figsize = ( [number] , [number] ) , dpi = [number] ) [EOL] bplt . plot_correlation ( df_corr , already_computed = True , ax = axes [ [number] ] , rotation_xticks = [number] , title = [string] ) [EOL] bplt . plot_correlation ( self . data , ax = axes [ [number] ] , method = [string] ) [EOL] return fig [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_counter ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_counter ( self . counter ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_counter_horizontal ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_counter ( self . counter , vertical = False , threshold = [number] , title = [string] , label_x = [string] , label_y = [string] , grid = [string] , rotation_xticks = [number] , figsize = ( [number] , [number] ) ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_counter_dict ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_counter ( self . dict_to_plot , grid = None ) [EOL] return ax . figure [EOL] [EOL] def test_plot_history ( self ) : [EOL] [docstring] [EOL] self . assertRaises ( AssertionError , bplt . plot_history , self . history , [string] ) [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_default ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_history ( self . history , title = [string] , grid = [string] , figsize = ( [number] , [number] ) ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_with_ax ( self ) : [EOL] [docstring] [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) , dpi = [number] ) [EOL] [comment] [EOL] bplt . plot_history ( self . history , axes = ax ) [EOL] return fig [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_with_metric ( self ) : [EOL] [docstring] [EOL] axes = bplt . plot_history ( self . history , metric = [string] , figsize = ( [number] , [number] ) ) [EOL] return axes [ [number] ] . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_with_metric_twinx ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_history ( self . history , metric = [string] , figsize = ( [number] , [number] ) , twinx = True ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_with_metric_twinx_with_ax ( self ) : [EOL] [docstring] [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) , dpi = [number] ) [EOL] bplt . plot_history ( self . history , metric = [string] , axes = ax , figsize = ( [number] , [number] ) , twinx = True ) [EOL] return fig [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_with_multiple_ticks ( self ) : [EOL] [docstring] [EOL] axes = bplt . plot_history ( self . history_mult , metric = [string] ) [EOL] return axes [ [number] ] . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_without_val ( self ) : [EOL] [docstring] [EOL] axes = bplt . plot_history ( self . history_without_val , metric = [string] ) [EOL] return axes [ [number] ] . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_without_val_twinx ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_history ( self . history_without_val , metric = [string] , twinx = True ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_without_val_and_metric ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_history ( self . history_without_val , color = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_history_without_val_and_metric_twinx ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_history ( self . history_without_val , color = [string] , twinx = True ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_kmeans ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_kmeans ( self . df_kmeans , cmap = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_kmeans_with_centroids ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_kmeans ( self . df_kmeans , centroids = self . kmeans . cluster_centers_ ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_pca_explained_variance_ratio ( self ) : [EOL] [docstring] [EOL] pca = PCA ( n_components = [number] ) [EOL] pca . fit ( np . random . randint ( [number] , [number] , size = ( [number] , [number] ) ) ) [EOL] ax = bplt . plot_pca_explained_variance_ratio ( pca , grid = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_pca_explained_variance_ratio_with_hline ( self ) : [EOL] [docstring] [EOL] pca = PCA ( n_components = [number] ) [EOL] pca . fit ( np . random . randint ( [number] , [number] , size = ( [number] , [number] ) ) ) [EOL] ax = bplt . plot_pca_explained_variance_ratio ( pca , title = [string] , hline = [number] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_pca_explained_variance_ratio_with_limits ( self ) : [EOL] [docstring] [EOL] pca = PCA ( n_components = [number] ) [EOL] pca . fit ( np . random . randint ( [number] , [number] , size = ( [number] , [number] ) ) ) [EOL] ax = bplt . plot_pca_explained_variance_ratio ( pca , lim_x = ( [number] , [number] ) , lim_y = ( [number] , [number] ) ) [EOL] return ax . figure [EOL] [EOL] def test_plot_pie ( self ) : [EOL] [docstring] [EOL] self . assertRaises ( AssertionError , bplt . plot_pie , self . dict_to_plot , colors = [ [string] , [string] ] ) [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_pie_counter ( self ) : [EOL] [docstring] [EOL] data = dict ( self . counter_pie . most_common ( [number] ) ) [EOL] ax = bplt . plot_pie ( data , explode = [number] , title = [string] , startangle = [number] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_pie_full ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_pie ( self . counter_pie , circle = False , title = [string] , loc = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_pie_dict ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_pie ( self . dict_to_plot , colors = [ [string] , [string] , [string] ] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_predictions ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_predictions ( self . y_true , self . y_pred ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_predictions_with_x ( self ) : [EOL] [docstring] [EOL] x_true = pd . date_range ( [string] , periods = len ( self . y_true ) , freq = [string] ) [EOL] x_pred = pd . date_range ( [string] , periods = len ( self . y_pred ) , freq = [string] ) [EOL] ax = bplt . plot_predictions ( self . y_true [ : - [number] ] , self . y_pred , x_true = x_true [ : - [number] ] , x_pred = x_pred , title = [string] ) [EOL] return ax . figure [EOL] [EOL] def test_plot_predictions_wrong_length ( self ) : [EOL] [docstring] [EOL] x_true = pd . date_range ( [string] , periods = len ( self . y_true ) , freq = [string] ) [EOL] x_pred = pd . date_range ( [string] , periods = len ( self . y_pred ) , freq = [string] ) [EOL] self . assertRaises ( AssertionError , bplt . plot_predictions , self . y_true [ : - [number] ] , self . y_pred , x_true = x_true , x_pred = x_pred ) [EOL] [EOL] def test_plot_series ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] columns = [ [string] , [string] , [string] ] [EOL] df_no_date = pd . DataFrame ( [ [ [string] , [number] , [string] ] , [ [string] , [number] , [string] ] , [ [string] , [number] , [string] ] , [ [string] , [number] , [string] ] ] , columns = columns ) [EOL] self . assertRaises ( AssertionError , bplt . plot_series , df_no_date , [string] ) [EOL] [EOL] [comment] [EOL] df_date = pd . DataFrame ( { [string] : pd . date_range ( [string] , periods = [number] , freq = [string] ) , [string] : np . random . randn ( [number] ) } ) . set_index ( [string] ) [EOL] self . assertRaises ( AssertionError , bplt . plot_series , df_date , [string] ) [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_series_all_same_axis ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_series ( self . data , [string] , groupby = [string] , title = [string] , color = self . AXIS [ [string] ] ) [EOL] for k in list ( self . AXIS . keys ( ) ) [ [number] : ] : [EOL] bplt . plot_series ( self . data , k , groupby = [string] , ax = ax , color = self . AXIS [ k ] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_series_mult_axis ( self ) : [EOL] [docstring] [EOL] fig , axes = plt . subplots ( nrows = len ( self . AXIS ) , ncols = [number] , figsize = ( [number] , len ( self . AXIS ) * [number] ) , dpi = [number] ) [EOL] for i , k in enumerate ( self . AXIS . keys ( ) ) : [EOL] bplt . plot_series ( self . data , k , ax = axes [ i ] , title = f' [string] { k }' , color = self . AXIS [ k ] ) [EOL] return fig [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_series_with_peaks ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_series ( self . data , [string] , groupby = [string] , with_peaks = True , title = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_series_with_missing_datetimes ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_series ( self . data_miss , [string] , groupby = [string] , with_missing_datetimes = True , title = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_series_with_missing_datetimes_groupby ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_series ( self . data_miss , [string] , groupby = [string] , with_missing_datetimes = True , title = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_series_with_sem ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_series ( self . data , [string] , groupby = [string] , with_sem = True , title = [string] ) [EOL] return ax . figure [EOL] [EOL] def test_plot_true_vs_pred ( self ) : [EOL] [docstring] [EOL] __ , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) , dpi = [number] ) [EOL] self . assertRaises ( AssertionError , bplt . plot_true_vs_pred , self . y_true , self . y_pred , ax = ax , with_histograms = True ) [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_true_vs_pred_default ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_true_vs_pred ( self . y_true , self . y_pred ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_true_vs_pred_with_ax ( self ) : [EOL] [docstring] [EOL] fig , ax = plt . subplots ( [number] , [number] , figsize = ( [number] , [number] ) , dpi = [number] ) [EOL] bplt . plot_true_vs_pred ( self . y_true , self . y_pred , ax = ax ) [EOL] return fig [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_true_vs_pred_with_correlation ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_true_vs_pred ( self . y_true , self . y_pred , with_correlation = True , marker = [string] , c = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_true_vs_pred_with_histograms ( self ) : [EOL] [docstring] [EOL] axes = bplt . plot_true_vs_pred ( self . y_true , self . y_pred , with_determination = False , with_histograms = True , marker = [string] , c = [string] ) [EOL] return axes [ [number] ] . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_plot_true_vs_pred_with_identity ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_true_vs_pred ( self . y_true , self . y_pred , with_identity = True , marker = [string] , c = [string] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_set_thousands_separator_both ( self ) : [EOL] [docstring] [EOL] ax = bplt . plot_counter ( self . dict_to_plot_numerical , title = [string] ) [EOL] ax = bplt . set_thousands_separator ( ax , nb_decimals = [number] ) [EOL] return ax . figure [EOL] [EOL] @ pytest . mark . mpl_image_compare def test_set_thousands_separator_x ( self ) : [EOL] [docstring] [EOL] fig , axes = plt . subplots ( nrows = [number] , ncols = [number] , sharey = True , figsize = ( [number] , [number] ) , dpi = [number] ) [EOL] bplt . plot_true_vs_pred ( self . y_true , self . y_pred , ax = axes [ [number] ] , title = [string] ) [EOL] bplt . plot_true_vs_pred ( self . y_true , self . y_pred , ax = axes [ [number] ] , title = [string] ) [EOL] bplt . set_thousands_separator ( axes [ [number] ] , [string] , [number] ) [EOL] bplt . set_thousands_separator ( axes , [string] , [number] ) [EOL] return fig [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 $typing.Type[tests.test_plot.TestPlot]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0