from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = open ( [string] ) . read ( ) , long_description_content_type = [string] , author = [string] , author_email = [string] , url = [string] , packages = [ [string] , [string] , [string] , [string] , ] , package_dir = { [string] : [string] , } , package_data = { [string] : [ [string] , [string] ] , [string] : [ [string] ] , } , install_requires = [ [string] , ] , extras_require = { [string] : [ [string] ] , } , tests_require = [ ] , classifiers = [ [string] , [string] , [string] , ] , test_suite = [string] , license = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] from datetime import timedelta [EOL] from typing import Union [EOL] [EOL] ExpireSeconds = Union [ int , float , timedelta ] [EOL] [EOL] [EOL] def to_timedelta ( expire_seconds ) : [EOL] if isinstance ( expire_seconds , ( int , float ) ) : [EOL] return timedelta ( seconds = expire_seconds ) [EOL] return expire_seconds [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] import cachepot [EOL] from typing import Optional [EOL] [EOL] from typing_extensions import Protocol [EOL] [EOL] from cachepot . expire import ExpireSeconds [EOL] [EOL] [EOL] class CacheBackendProtocol ( Protocol ) : [EOL] [EOL] def save ( self , key , value , * , expire_seconds ) : [EOL] ... [EOL] [EOL] def load ( self , key ) : [EOL] ... [EOL] [EOL] def delete ( self , key ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $cachepot.expire.ExpireSeconds$ 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] import cachepot [EOL] import builtins [EOL] import redis [EOL] from typing import Optional , cast [EOL] [EOL] import redis [EOL] [EOL] from cachepot . backend import CacheBackendProtocol [EOL] from cachepot . expire import ExpireSeconds , to_timedelta [EOL] [EOL] [EOL] class RedisCacheBackend ( CacheBackendProtocol ) : [EOL] redis_connection = ... [EOL] [EOL] def __init__ ( self , redis_connection ) : [EOL] self . redis = redis_connection [EOL] [EOL] def save ( self , key , value , * , expire_seconds ) : [EOL] with self . redis . pipeline ( ) as pipe : [EOL] pipe . set ( key , value ) [EOL] pipe . expire ( key , to_timedelta ( expire_seconds ) ) [EOL] pipe . execute ( ) [EOL] [EOL] def load ( self , key ) : [EOL] return cast ( bytes , self . redis . get ( key ) ) [EOL] [EOL] def delete ( self , key ) : [EOL] self . redis . delete ( key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $redis.Redis$ 0 0 0 0 0 0 0 0 0 $redis.Redis$ 0 0 0 0 0 $redis.client.Redis[typing.Any]$ 0 $redis.Redis$ 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 $cachepot.expire.ExpireSeconds$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $cachepot.expire.ExpireSeconds$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0
from typing import Any , Optional [EOL] import datetime [EOL] import builtins [EOL] import cachepot [EOL] import sqlite3 [EOL] import typing [EOL] import pathlib [EOL] import sqlite3 [EOL] from datetime import datetime [EOL] from typing import Optional , Union , cast [EOL] [EOL] from cachepot . backend import CacheBackendProtocol [EOL] from cachepot . expire import ExpireSeconds , to_timedelta [EOL] [EOL] ConnectionLike = Union [ str , pathlib . Path , sqlite3 . Connection ] [EOL] [EOL] [EOL] class SQLiteCacheBackend ( CacheBackendProtocol ) : [EOL] conn = ... [EOL] [EOL] def __init__ ( self , conn ) : [EOL] if isinstance ( conn , str ) : [EOL] conn = sqlite3 . connect ( conn ) [EOL] elif isinstance ( conn , pathlib . Path ) : [EOL] conn = sqlite3 . connect ( conn ) [EOL] conn . text_factory = bytes [EOL] conn . execute ( [string] ) [EOL] conn . execute ( [string] ) [EOL] self . conn = conn [EOL] [EOL] def save ( self , key , value , * , expire_seconds ) : [EOL] expire_at = datetime . now ( ) + to_timedelta ( expire_seconds ) [EOL] self . conn . execute ( [string] , ( key , value , expire_at ) ) [EOL] self . conn . commit ( ) [EOL] [EOL] def load ( self , key ) : [EOL] current_datetime = datetime . now ( ) [EOL] result = self . conn . execute ( [string] , ( key , current_datetime ) ) . fetchone ( ) [EOL] if result : [EOL] return cast ( bytes , result [ [number] ] ) [EOL] return None [EOL] [EOL] def delete ( self , key ) : [EOL] self . conn . execute ( [string] , ( key , ) ) [EOL] self . conn . commit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from cachepot . serializer import SerializerProtocol [EOL] [EOL] [EOL] class StringSerializer ( SerializerProtocol [ str ] ) : [EOL] [EOL] def serialize ( self , data ) : [EOL] return data . encode ( ) [EOL] [EOL] def deserialize ( self , serialized_data ) : [EOL] return serialized_data . decode ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import pickle [EOL] from typing import Any [EOL] [EOL] from cachepot . serializer import SerializerProtocol [EOL] [EOL] [EOL] class PickleSerializer ( SerializerProtocol [ Any ] ) : [EOL] [EOL] def serialize ( self , data ) : [EOL] return pickle . dumps ( data ) [EOL] [EOL] def deserialize ( self , serialized_data ) : [EOL] return pickle . loads ( serialized_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import json [EOL] from typing import Any , Dict , List , Union , cast [EOL] [EOL] from cachepot . serializer import SerializerProtocol [EOL] [EOL] [comment] [EOL] [comment] [EOL] JSONType = Union [ str , int , float , Dict [ str , Any ] , List [ Any ] ] [EOL] [EOL] [EOL] class JSONSerializer ( SerializerProtocol [ JSONType ] ) : [EOL] [EOL] def serialize ( self , data ) : [EOL] return json . dumps ( data , sort_keys = True , separators = ( [string] , [string] ) ) . encode ( ) [EOL] [EOL] def deserialize ( self , serialized_data ) : [EOL] return cast ( JSONType , json . loads ( serialized_data . decode ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $JSONType$ 0 0 0 0 0 0 0 0 $JSONType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $JSONType$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0
import builtins [EOL] import example [EOL] from typing import Any [EOL] [EOL] from cachepot . backend . filesystem import FileSystemCacheBackend [EOL] from cachepot . serializer . json import JSONSerializer , JSONType [EOL] from cachepot . serializer . pickle import PickleSerializer [EOL] from cachepot . serializer . str import StringSerializer [EOL] from cachepot . store import CacheStore [EOL] [EOL] [EOL] class SimpleFileSystemCacheStore ( CacheStore [ str , Any ] ) : [EOL] namespace = ... [EOL] [EOL] def __init__ ( self , namespace , * , directory = [string] , ) : [EOL] super ( ) . __init__ ( namespace = namespace , key_serializer = StringSerializer ( ) , value_serializer = PickleSerializer ( ) , backend = FileSystemCacheBackend ( directory ) , default_expire_seconds = [number] , ) [EOL] [EOL] [EOL] class FileSystemJSONCacheStore ( CacheStore [ str , JSONType ] ) : [EOL] namespace = ... [EOL] [EOL] def __init__ ( self , namespace , * , directory = [string] , ) : [EOL] super ( ) . __init__ ( namespace = namespace , key_serializer = StringSerializer ( ) , value_serializer = JSONSerializer ( ) , backend = FileSystemCacheBackend ( directory ) , default_expire_seconds = [number] , ) [EOL] [EOL] [EOL] def example_usage ( ) : [EOL] cachestore = SimpleFileSystemCacheStore ( [string] , directory = [string] ) [EOL] cachestore . put ( [string] , [number] ) [EOL] assert cachestore . get ( [string] ) == [number] [EOL] cachestore . remove ( [string] ) [EOL] assert cachestore . get ( [string] ) is None [EOL] assert cachestore . proxy ( lambda : [number] ) ( cache_key = [string] ) == [number] [EOL] assert cachestore . proxy ( lambda : [number] ) ( cache_key = [string] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import cachepot [EOL] import tempfile [EOL] import time [EOL] import unittest [EOL] [EOL] from cachepot . backend . filesystem import FileSystemCacheBackend [EOL] from cachepot . serializer . pickle import PickleSerializer [EOL] from cachepot . serializer . str import StringSerializer [EOL] from cachepot . store import CacheStore [EOL] [EOL] [EOL] class TestCacheStore ( unittest . TestCase ) : [EOL] [EOL] def test_basis ( self ) : [EOL] with tempfile . TemporaryDirectory ( ) as tmpdir : [EOL] [EOL] cachestore = CacheStore ( namespace = [string] , key_serializer = StringSerializer ( ) , value_serializer = PickleSerializer ( ) , backend = FileSystemCacheBackend ( tmpdir ) , default_expire_seconds = [number] , ) [EOL] cachestore . put ( [string] , [number] ) [EOL] self . assertEqual ( cachestore . get ( [string] ) , [number] ) [EOL] cachestore . remove ( [string] ) [EOL] self . assertEqual ( cachestore . get ( [string] ) , None ) [EOL] self . assertEqual ( cachestore . proxy ( lambda : [number] ) ( cache_key = [string] ) , [number] ) [EOL] self . assertEqual ( cachestore . proxy ( lambda : [number] ) ( cache_key = [string] ) , [number] ) [EOL] self . assertEqual ( cachestore . get ( [string] ) , [number] ) [EOL] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] self . assertEqual ( cachestore . get ( [string] ) , None ) [EOL] self . assertEqual ( cachestore . proxy ( lambda : [number] ) ( cache_key = [string] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.store.CacheStore[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import unittest [EOL] from datetime import timedelta [EOL] [EOL] from cachepot . expire import to_timedelta [EOL] [EOL] [EOL] class TestExpireSeconds ( unittest . TestCase ) : [EOL] [EOL] def test_to_timedelta ( self ) : [EOL] [comment] [EOL] self . assertEqual ( to_timedelta ( [number] ) , timedelta ( seconds = [number] ) ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( to_timedelta ( [number] ) , timedelta ( seconds = [number] ) ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( timedelta ( days = [number] ) , timedelta ( days = [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import cachepot [EOL] import string [EOL] import unittest [EOL] [EOL] from cachepot . serializer . str import StringSerializer [EOL] [EOL] [EOL] class TestStringSerializer ( unittest . TestCase ) : [EOL] def test_str_serializer ( self ) : [EOL] serializer = StringSerializer ( ) [EOL] [EOL] patterns = [ [string] , string . ascii_letters , string . ascii_lowercase , string . ascii_uppercase , string . digits , string . hexdigits , string . octdigits , string . printable , string . punctuation , string . whitespace , [string] , ] [EOL] [EOL] for original in patterns : [EOL] serialized = serializer . serialize ( original ) [EOL] deserialized = serializer . deserialize ( serialized ) [EOL] self . assertEqual ( deserialized , original ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $cachepot.serializer.str.StringSerializer$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.bytes$ 0 $cachepot.serializer.str.StringSerializer$ 0 0 0 0 0 0 $builtins.str$ 0 $cachepot.serializer.str.StringSerializer$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Any , Dict , Union , List [EOL] import typing [EOL] import cachepot [EOL] import unittest [EOL] [EOL] from cachepot . serializer . json import JSONSerializer [EOL] [EOL] [EOL] class TestJSONSerializer ( unittest . TestCase ) : [EOL] def test_json_serializer ( self ) : [EOL] serializer = JSONSerializer ( ) [EOL] [EOL] patterns = [ { [string] : [number] } , [ [number] , [number] , [number] ] , [number] , [number] , [string] , [ { [string] : { [string] : True } } ] , [ [ [ [ [ [ [ [string] ] ] ] ] ] ] ] , ] [EOL] [EOL] for original in patterns : [EOL] serialized = serializer . serialize ( original ) [comment] [EOL] deserialized = serializer . deserialize ( serialized ) [EOL] self . assertEqual ( deserialized , original ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $cachepot.serializer.json.JSONSerializer$ 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.int],typing.List[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.bool]]],typing.List[typing.List[typing.List[typing.List[typing.List[typing.List[typing.List[builtins.str]]]]]]],typing.List[builtins.int],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.int],typing.List[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.bool]]],typing.List[typing.List[typing.List[typing.List[typing.List[typing.List[typing.List[builtins.str]]]]]]],typing.List[builtins.int],builtins.float,builtins.str]]$ 0 0 $builtins.bytes$ 0 $cachepot.serializer.json.JSONSerializer$ 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Any],typing.List[typing.Any],builtins.float,builtins.int,builtins.str]$ 0 $cachepot.serializer.json.JSONSerializer$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Any],typing.List[typing.Any],builtins.float,builtins.int,builtins.str]$ 0 0 0 0
	0
from typing import Any , Type , Union , List [EOL] import typing [EOL] import tests [EOL] import cachepot [EOL] import unittest [EOL] from dataclasses import dataclass [EOL] [EOL] from cachepot . serializer . pickle import PickleSerializer [EOL] [EOL] [EOL] @ dataclass class A : [EOL] x = ... [EOL] [EOL] [EOL] class TestPickleSerializer ( unittest . TestCase ) : [EOL] def test_pickle_serializer ( self ) : [EOL] serializer = PickleSerializer ( ) [EOL] [EOL] patterns = [ [number] , [string] , str , int , A , A ( x = [number] ) , ] [EOL] [EOL] for original in patterns : [EOL] serialized = serializer . serialize ( original ) [EOL] deserialized = serializer . deserialize ( serialized ) [EOL] self . assertEqual ( deserialized , original ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $cachepot.serializer.pickle.PickleSerializer$ 0 0 0 0 0 0 $typing.List[typing.Union[typing.Type[tests.serializer.test_pickle.A],typing.Type[typing.Union[builtins.int,builtins.str,tests.serializer.test_pickle.A]],builtins.int,builtins.str,tests.serializer.test_pickle.A]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Type[tests.serializer.test_pickle.A],typing.Type[typing.Union[builtins.int,builtins.str,tests.serializer.test_pickle.A]],builtins.int,builtins.str,tests.serializer.test_pickle.A]]$ 0 0 $builtins.bytes$ 0 $cachepot.serializer.pickle.PickleSerializer$ 0 0 0 0 0 0 $typing.Any$ 0 $cachepot.serializer.pickle.PickleSerializer$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
	0
import cachepot [EOL] import pathlib [EOL] import tempfile [EOL] import time [EOL] import unittest [EOL] [EOL] from cachepot . backend . filesystem import FileSystemCacheBackend [EOL] [EOL] [EOL] class TestFileSystemCacheBackend ( unittest . TestCase ) : [EOL] [EOL] def test_various_pathlike ( self ) : [EOL] with tempfile . TemporaryDirectory ( ) as tmpdir : [EOL] cachestore = FileSystemCacheBackend ( pathlib . Path ( tmpdir ) ) [EOL] self . assertEqual ( cachestore . load ( [string] ) , None ) [EOL] cachestore . save ( [string] , [string] , expire_seconds = [number] ) [EOL] self . assertEqual ( cachestore . load ( [string] ) , [string] ) [EOL] cachestore . delete ( [string] ) [EOL] self . assertEqual ( cachestore . load ( [string] ) , None ) [EOL] [EOL] with tempfile . TemporaryDirectory ( ) as tmpdir : [EOL] cachestore = FileSystemCacheBackend ( tmpdir ) [EOL] self . assertEqual ( cachestore . load ( [string] ) , None ) [EOL] cachestore . save ( [string] , [string] , expire_seconds = [number] ) [EOL] self . assertEqual ( cachestore . load ( [string] ) , [string] ) [EOL] cachestore . delete ( [string] ) [EOL] self . assertEqual ( cachestore . load ( [string] ) , None ) [EOL] [EOL] def test_expire ( self ) : [EOL] with tempfile . TemporaryDirectory ( ) as tmpdir : [EOL] cachestore = FileSystemCacheBackend ( pathlib . Path ( tmpdir ) ) [EOL] cachestore . save ( [string] , [string] , expire_seconds = [number] ) [EOL] self . assertEqual ( cachestore . load ( [string] ) , [string] ) [EOL] time . sleep ( [number] ) [EOL] self . assertEqual ( cachestore . load ( [string] ) , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cachepot.backend.filesystem.FileSystemCacheBackend$ 0 0 0 0 0 0 0 0 0