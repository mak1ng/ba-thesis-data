from typing import Literal , Any , Union , Dict [EOL] import server [EOL] import typing [EOL] import typing_extensions [EOL] import models [EOL] import builtins [EOL] from functools import wraps [EOL] import base64 [EOL] import inspect [EOL] import ed25519 [EOL] [EOL] from models import UserAuth [EOL] [EOL] [EOL] def non_null_params ( f ) : [EOL] @ wraps ( f ) def fn ( * args ) : [EOL] for i in range ( [number] , len ( args ) ) : [EOL] if args [ i ] is None : [EOL] argname = inspect . getfullargspec ( f ) . args [ i ] [EOL] raise ValueError ( [string] . format ( argname ) ) [EOL] return f ( * args ) [EOL] return f [EOL] [EOL] [EOL] class CryptoGrenouille : [EOL] [comment] [EOL] OID_ED25519 = [number] [EOL] OID_BYTE = [number] [EOL] IDLEN_BYTE = [number] [EOL] [EOL] def _get_verifying_key_from_user_auth ( self , user_auth ) : [EOL] x509b = base64 . b64decode ( user_auth . public_key ) [EOL] if x509b [ self . OID_BYTE ] != self . OID_ED25519 : [EOL] raise ValueError ( [string] ) [EOL] total_length = [number] if x509b [ self . IDLEN_BYTE ] == [number] else [number] [EOL] id_length = [number] if x509b [ self . IDLEN_BYTE ] == [number] else [number] [EOL] if len ( x509b ) != total_length : [EOL] raise ValueError ( [string] . format ( total_length , len ( x509b ) ) ) [EOL] [comment] [EOL] [comment] [EOL] expected_header = bytes ( [ [number] , ( total_length - [number] ) , [number] , id_length , [number] , [number] , ( [number] * [number] ) + [number] , [number] ] ) [EOL] if x509b [ [number] : len ( expected_header ) ] != expected_header : [EOL] raise ValueError ( [string] ) [EOL] header_scan_idx = len ( expected_header ) + [number] [comment] [EOL] if id_length == [number] : [EOL] if x509b [ header_scan_idx : header_scan_idx + [number] ] != bytes ( [ [number] , [number] ] ) : [EOL] raise ValueError ( [string] ) [EOL] header_scan_idx = header_scan_idx + [number] [EOL] if x509b [ header_scan_idx : header_scan_idx + [number] ] != bytes ( [ [number] , [number] , [number] ] ) : [EOL] raise ValueError ( [string] ) [EOL] header_scan_idx = header_scan_idx + [number] [EOL] return ed25519 . VerifyingKey ( x509b [ header_scan_idx : ] ) [EOL] [EOL] @ non_null_params def validate_user_auth ( self , user_auth ) : [EOL] self . _get_verifying_key_from_user_auth ( user_auth ) [EOL] [EOL] @ non_null_params def verify_message_signature ( self , b64_signature , message , user_auth ) : [EOL] verifying_key = self . _get_verifying_key_from_user_auth ( user_auth ) [EOL] signature = base64 . b64decode ( b64_signature ) [EOL] try : [EOL] verifying_key . verify ( signature , message . encode ( [string] ) ) [EOL] except ed25519 . BadSignatureError : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] strategy_engines = { [string] : CryptoGrenouille ( ) } [EOL] [EOL] [EOL] def with_engine_from_last_argument ( f ) : [EOL] @ wraps ( f ) def fn ( * args ) : [EOL] user_auth = args [ - [number] ] [EOL] strategy = user_auth . authentication_strategy [EOL] engine = strategy_engines [ strategy ] [EOL] if not engine : [EOL] msg = [string] . format ( strategy ) [EOL] raise ValueError ( msg ) [EOL] return f ( * ( args + ( engine , ) ) ) [EOL] return fn [EOL] [EOL] [EOL] class Crypto : [EOL] @ non_null_params @ with_engine_from_last_argument def validate_user_auth ( self , user_auth , engine ) : [EOL] return engine . validate_user_auth ( user_auth ) [EOL] [EOL] @ non_null_params @ with_engine_from_last_argument def verify_message_signature ( self , b64_signature , message , user_auth , engine ) : [EOL] return engine . verify_message_signature ( b64_signature , message , user_auth ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 $builtins.bytes$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $models.UserAuth$ 0 0 0 0 0 0 0 $models.UserAuth$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $models.UserAuth$ 0 0 0 $typing.Any$ 0 0 0 0 0 $models.UserAuth$ 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $models.UserAuth$ 0 0 0 0 0 0 0 0 0 0 $models.UserAuth$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $models.UserAuth$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $models.UserAuth$ 0 0
from typing import Any , Dict [EOL] import logging [EOL] import builtins [EOL] import sqlalchemy [EOL] import typing [EOL] from typing import Dict [EOL] import logging [EOL] [EOL] from sqlalchemy . orm . query import Query [EOL] from sqlalchemy import func [EOL] [EOL] from models import Game , PlayerJoinGameRequest , PlayerInGameStatus [EOL] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def refine_queries ( query , filters ) : [EOL] for k , v in filters . items ( ) : [EOL] query = refine_query ( query , k . lower ( ) , v ) [EOL] return query [EOL] [EOL] [EOL] def refine_query ( query , key , value ) : [EOL] lw = func . lower [EOL] [EOL] if key == [string] : [EOL] query = query . filter ( Game . difficulty == int ( value ) ) [EOL] elif key == [string] : [EOL] query = query . filter ( lw ( Game . universe ) == value . lower ( ) ) [EOL] elif key == [string] : [EOL] query = query . filter ( lw ( Game . gm_user_uuid ) == value . lower ( ) ) [EOL] elif key == [string] : [EOL] query = query . filter ( Game . game_status == value ) [EOL] elif key == [string] : [EOL] query = query . filter ( Game . session_length_in_minutes >= value ) [EOL] elif key == [string] : [EOL] query = query . filter ( Game . session_length_in_minutes <= value ) [EOL] elif key == [string] : [EOL] query = query . filter ( lw ( Game . title ) . like ( [string] . format ( value . lower ( ) ) ) ) [EOL] elif key == [string] and value == [string] : [EOL] query = query . order_by ( Game . difficulty . asc ( ) ) [EOL] elif key == [string] and value == [string] : [EOL] query = query . order_by ( Game . difficulty . desc ( ) ) [EOL] elif key == [string] and value == [string] : [EOL] query = query . order_by ( Game . timestamp_created . asc ( ) ) [EOL] elif key == [string] and value == [string] : [EOL] query = query . order_by ( Game . timestamp_created . desc ( ) ) [EOL] elif key == [string] and value == [string] : [EOL] query = query . order_by ( Game . max_players . asc ( ) ) [EOL] elif key == [string] and value == [string] : [EOL] query = query . order_by ( Game . max_players . desc ( ) ) [EOL] elif key == [string] and value == [string] : [EOL] query = query . order_by ( Game . min_players . asc ( ) ) [EOL] elif key == [string] and value == [string] : [EOL] query = query . order_by ( Game . min_players . desc ( ) ) [EOL] elif key == [string] : [EOL] query = ( query . join ( PlayerJoinGameRequest , PlayerJoinGameRequest . game_uuid == Game . uuid ) . filter ( PlayerJoinGameRequest . user_uuid == value ) . filter ( PlayerJoinGameRequest . request_status == PlayerInGameStatus . REQUEST_TO_JOIN ) ) [EOL] elif key == [string] : [EOL] query = ( query . join ( PlayerJoinGameRequest , PlayerJoinGameRequest . game_uuid == Game . uuid ) . filter ( PlayerJoinGameRequest . user_uuid == value ) . filter ( PlayerJoinGameRequest . request_status == PlayerInGameStatus . CONFIRMED ) ) [EOL] elif key == [string] : [EOL] query = query . filter ( Game . game_status == value ) [EOL] else : [EOL] log . warning ( [string] [string] . format ( key , value ) ) [EOL] return query [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.orm.query.Query$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.orm.query.Query$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from contextlib import contextmanager [EOL] import unittest [EOL] [EOL] from contexts import with_context [EOL] from crypto import Crypto [EOL] from models import UserAuth [EOL] [EOL] [EOL] TEST_MESSAGE = [string] [EOL] TEST_SIGNATURE = [string] [EOL] TEST_PUBLIC_KEY = [string] [EOL] [EOL] [EOL] def with_crypto ( f ) : [EOL] @ contextmanager def mk_crypto ( ) : [EOL] yield Crypto ( ) [EOL] return with_context ( mk_crypto ) ( f ) [EOL] [EOL] [EOL] class CryptoTest ( unittest . TestCase ) : [EOL] @ with_crypto def test_verify_signature_received ( self , crypto ) : [EOL] user_auth = UserAuth ( user_uuid = [string] , public_key = TEST_PUBLIC_KEY , authentication_strategy = [string] ) [EOL] sig_ok = crypto . verify_message_signature ( TEST_SIGNATURE , TEST_MESSAGE , user_auth ) [EOL] self . assertTrue ( sig_ok ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Dict , IO , Any , Type , Generator , TypeVar , Tuple , Callable [EOL] import builtins [EOL] import typing [EOL] import server [EOL] import logging [EOL] import shutil [EOL] import tempfile [EOL] from contextlib import contextmanager [EOL] from functools import wraps [EOL] from inspect import isgeneratorfunction , unwrap [EOL] from typing import Any , Callable , cast , Dict , Generator , IO , Tuple , TypeVar [EOL] [EOL] G = TypeVar ( [string] ) [EOL] S = TypeVar ( [string] ) [EOL] [EOL] [EOL] def is_context_manager ( f ) : [EOL] return isgeneratorfunction ( unwrap ( getattr ( f , [string] , None ) , stop = isgeneratorfunction ) ) [EOL] [EOL] [EOL] CTX = Any [comment] [EOL] CTX_GENERATOR = Callable [ ... , CTX ] [EOL] CTX_GEN_ARGS = Tuple [ Any , ... ] [EOL] CTX_GEN_KWARGS = Dict [ str , Any ] [EOL] DECORATOR_FN = Callable [ [ Callable [ ... , S ] ] , Callable [ ... , S ] ] [EOL] FN_ARGS = Tuple [ Any , ... ] [EOL] FN_KWARGS = Dict [ str , Any ] [EOL] [EOL] [EOL] [comment] [EOL] def mk_with_context_decorator ( ctx_generator , ctx_generator_args_from_fn_args , fn_args_from_fn_args_and_ctx ) : [EOL] [docstring] [EOL] def decorator ( f ) : [EOL] def function_wrapper ( * args , ** kwargs ) : [EOL] context_generator_args , context_generator_kwargs = ctx_generator_args_from_fn_args ( args , kwargs ) [EOL] with ctx_generator ( * context_generator_args , ** context_generator_kwargs ) as ct : [EOL] args , kwargs = fn_args_from_fn_args_and_ctx ( args , kwargs , ct ) [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] @ contextmanager def generator_wrapper ( * args , ** kwargs ) : [EOL] context_generator_args , context_generator_kwargs = ctx_generator_args_from_fn_args ( args , kwargs ) [EOL] with ctx_generator ( * context_generator_args , ** context_generator_kwargs ) as ct : [EOL] args , kwargs = fn_args_from_fn_args_and_ctx ( args , kwargs , ct ) [EOL] with cast ( CTX , f ( * args , ** kwargs ) ) as result : [EOL] yield result [EOL] return wraps ( f ) ( generator_wrapper if is_context_manager ( f ) else function_wrapper ) [EOL] return decorator [EOL] [EOL] [EOL] def with_context ( context_generator , * context_generator_args , ** context_generator_kwargs ) : [EOL] [docstring] [EOL] def ctx_generator_args_from_fn_args ( * _ ) : [EOL] return context_generator_args , context_generator_kwargs [EOL] [EOL] def fn_args_from_fn_args_and_ctx ( fn_args , fn_kwargs , ctx ) : [EOL] return fn_args + cast ( tuple , ctx if isinstance ( ctx , tuple ) else ( ctx , ) ) , fn_kwargs [EOL] return mk_with_context_decorator ( context_generator , ctx_generator_args_from_fn_args , fn_args_from_fn_args_and_ctx ) [EOL] [EOL] [EOL] def with_context_using_instance ( context_generator , * context_generator_args , ** context_generator_kwargs ) : [EOL] [docstring] [EOL] def ctx_generator_args_from_fn_args ( fn_args , _ ) : [EOL] return ( fn_args [ [number] ] , ) + context_generator_args , context_generator_kwargs [EOL] [EOL] def fn_args_from_fn_args_and_ctx ( fn_args , fn_kwargs , ctx ) : [EOL] return fn_args + cast ( tuple , ctx if isinstance ( ctx , tuple ) else ( ctx , ) ) , fn_kwargs [EOL] return mk_with_context_decorator ( context_generator , ctx_generator_args_from_fn_args , fn_args_from_fn_args_and_ctx ) [EOL] [EOL] [EOL] @ contextmanager def tmp_directory_ctx_generator ( maybe_self = None , prefix = [string] ) : [EOL] [docstring] [EOL] working_dir = getattr ( maybe_self , [string] , None ) [EOL] tmpdir = tempfile . mkdtemp ( dir = working_dir , prefix = prefix ) [EOL] try : [EOL] yield tmpdir [EOL] finally : [EOL] try : [EOL] shutil . rmtree ( tmpdir ) [EOL] except Exception as exception : [EOL] logging . warning ( [string] . format ( tmpdir , exception ) ) [EOL] try : [EOL] shutil . rmtree ( tmpdir , ignore_errors = True ) [EOL] except Exception as exc : [EOL] logging . error ( [string] . format ( tmpdir , exc ) ) [EOL] [EOL] [EOL] @ contextmanager def tmp_file_ctx_generator ( maybe_self = None , prefix = [string] ) : [EOL] [docstring] [EOL] working_dir = getattr ( maybe_self , [string] , None ) [EOL] with tempfile . NamedTemporaryFile ( buffering = False , dir = working_dir , prefix = prefix ) as tmpfile : [EOL] yield tmpfile [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DECORATOR_FN$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,S]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[G,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DECORATOR_FN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DECORATOR_FN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.str,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.IO,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0