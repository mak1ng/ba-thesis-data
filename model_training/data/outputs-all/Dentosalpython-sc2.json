from typing import Any [EOL] import typing [EOL] import json [EOL] import portpicker [EOL] [EOL] class Portconfig : [EOL] def __init__ ( self ) : [EOL] self . shared = portpicker . pick_unused_port ( ) [EOL] self . server = [ portpicker . pick_unused_port ( ) for _ in range ( [number] ) ] [EOL] self . players = [ [ portpicker . pick_unused_port ( ) for _ in range ( [number] ) ] for _ in range ( [number] ) ] [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . shared } [string] { self . server } [string] { self . players } [string] " [EOL] [EOL] @ property def as_json ( self ) : [EOL] return json . dumps ( { [string] : self . shared , [string] : self . server , [string] : self . players } ) [EOL] [EOL] @ classmethod def from_json ( cls , json_data ) : [EOL] self = cls . __new__ ( cls ) [EOL] data = json . loads ( json_data ) [EOL] self . shared = data [ [string] ] [EOL] self . server = data [ [string] ] [EOL] self . players = data [ [string] ] [EOL] return self [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0
from functools import wraps [EOL] [EOL] [EOL] def cache_forever ( f ) : [EOL] f . cache = { } [EOL] [EOL] @ wraps ( f ) def inner ( * args ) : [EOL] if args not in f . cache : [EOL] f . cache [ args ] = f ( * args ) [EOL] return f . cache [ args ] [EOL] [EOL] return inner [EOL] [EOL] [EOL] def property_cache_forever ( f ) : [EOL] f . cached = None [EOL] [EOL] @ wraps ( f ) def inner ( self ) : [EOL] if f . cached is None : [EOL] f . cached = f ( self ) [EOL] return f . cached [EOL] [EOL] return property ( inner ) [EOL] [EOL] [EOL] def property_cache_once_per_frame ( f ) : [EOL] [docstring] [EOL] f . frame = - [number] [EOL] f . cache = None [EOL] [EOL] @ wraps ( f ) def inner ( self ) : [EOL] if f . frame != self . state . game_loop : [EOL] f . frame = self . state . game_loop [EOL] f . cache = None [EOL] if f . cache is None : [EOL] f . cache = f ( self ) [EOL] return f . cache [EOL] [EOL] return property ( inner ) [EOL] [EOL] [EOL] def property_immutable_cache ( f ) : [EOL] @ wraps ( f ) def inner ( self ) : [EOL] if f . __name__ not in self . cache : [EOL] self . cache [ f . __name__ ] = f ( self ) [EOL] return self . cache [ f . __name__ ] [EOL] [EOL] return property ( inner ) [EOL] [EOL] [EOL] def property_mutable_cache ( f ) : [EOL] @ wraps ( f ) def inner ( self ) : [EOL] if f . __name__ not in self . cache : [EOL] self . cache [ f . __name__ ] = f ( self ) [EOL] return self . cache [ f . __name__ ] . copy ( ) [EOL] [EOL] return property ( inner ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Tuple , FrozenSet , Set , Callable [EOL] import typing [EOL] import position [EOL] import builtins [EOL] from typing import Callable , Set , FrozenSet , List [EOL] [EOL] from . position import Point2 [EOL] [EOL] [EOL] class PixelMap : [EOL] def __init__ ( self , proto ) : [EOL] self . _proto = proto [EOL] assert self . bits_per_pixel % [number] == [number] , [string] [EOL] assert self . width * self . height * self . bits_per_pixel / [number] == len ( self . _proto . data ) [EOL] self . data = bytearray ( self . _proto . data ) [EOL] [EOL] @ property def width ( self ) : [EOL] return self . _proto . size . x [EOL] [EOL] @ property def height ( self ) : [EOL] return self . _proto . size . y [EOL] [EOL] @ property def bits_per_pixel ( self ) : [EOL] return self . _proto . bits_per_pixel [EOL] [EOL] @ property def bytes_per_pixel ( self ) : [EOL] return self . _proto . bits_per_pixel // [number] [EOL] [EOL] def __getitem__ ( self , pos ) : [EOL] x , y = pos [EOL] [EOL] assert [number] <= x < self . width , f" [string] { x } [string] { self . width }" [EOL] assert [number] <= y < self . height , f" [string] { y } [string] { self . height }" [EOL] [EOL] index = - self . width * y + x [EOL] [comment] [EOL] start = index * self . bytes_per_pixel [EOL] data = self . data [ start : start + self . bytes_per_pixel ] [EOL] return int . from_bytes ( data , byteorder = [string] , signed = False ) [EOL] [EOL] def __setitem__ ( self , pos , val ) : [EOL] [docstring] [EOL] x , y = pos [EOL] [EOL] assert [number] <= x < self . width , f" [string] { x } [string] { self . width }" [EOL] assert [number] <= y < self . height , f" [string] { y } [string] { self . height }" [EOL] [EOL] index = - self . width * y + x [EOL] start = index * self . bytes_per_pixel [EOL] self . data [ start : start + self . bytes_per_pixel ] = val [EOL] [EOL] def is_set ( self , p ) : [EOL] return self [ p ] != [number] [EOL] [EOL] def is_empty ( self , p ) : [EOL] return not self . is_set ( p ) [EOL] [EOL] def invert ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def flood_fill ( self , start_point , pred ) : [EOL] nodes = set ( ) [EOL] queue = [ start_point ] [EOL] [EOL] while queue : [EOL] x , y = queue . pop ( ) [EOL] [EOL] if not ( [number] <= x < self . width and [number] <= y < self . height ) : [EOL] continue [EOL] [EOL] if Point2 ( ( x , y ) ) in nodes : [EOL] continue [EOL] [EOL] if pred ( self [ x , y ] ) : [EOL] nodes . add ( Point2 ( ( x , y ) ) ) [EOL] for a in [ - [number] , [number] , [number] ] : [EOL] for b in [ - [number] , [number] , [number] ] : [EOL] if not ( a == [number] and b == [number] ) : [EOL] queue . append ( Point2 ( ( x + a , y + b ) ) ) [EOL] [EOL] return nodes [EOL] [EOL] def flood_fill_all ( self , pred ) : [EOL] groups = set ( ) [EOL] [EOL] for x in range ( self . width ) : [EOL] for y in range ( self . height ) : [EOL] if any ( ( x , y ) in g for g in groups ) : [EOL] continue [EOL] [EOL] if pred ( self [ x , y ] ) : [EOL] groups . add ( frozenset ( self . flood_fill ( Point2 ( ( x , y ) ) , pred ) ) ) [EOL] [EOL] return groups [EOL] [EOL] def print ( self , wide = False ) : [EOL] for y in range ( self . height ) : [EOL] for x in range ( self . width ) : [EOL] print ( [string] if self . is_set ( ( x , y ) ) else [string] , end = ( [string] if wide else [string] ) ) [EOL] print ( [string] ) [EOL] [EOL] def save_image ( self , filename ) : [EOL] data = [ ( [number] , [number] , self [ x , y ] ) for y in range ( self . height ) for x in range ( self . width ) ] [EOL] from PIL import Image [EOL] [EOL] im = Image . new ( [string] , ( self . width , self . height ) ) [EOL] im . putdata ( data ) [EOL] im . save ( filename ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.bytearray$ 0 0 0 $builtins.bytearray$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytearray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[position.Point2]$ 0 0 0 $position.Point2$ 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 $typing.Set[position.Point2]$ 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 $position.Point2$ 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[position.Point2]$ 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[position.Point2]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[position.Point2]$ 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.bool]$ 0 0 0 0 0 0 $typing.Set[typing.FrozenSet[position.Point2]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,typing.Any]]$ 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class ControlGroup ( set ) : [EOL] def __init__ ( self , units ) : [EOL] super ( ) . __init__ ( { unit . tag for unit in units } ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( tuple ( sorted ( list ( self ) ) ) ) [EOL] [EOL] def select_units ( self , units ) : [EOL] return units . filter ( lambda unit : unit . tag in self ) [EOL] [EOL] def missing_unit_tags ( self , units ) : [EOL] return { t for t in self if units . find_by_tag ( t ) is None } [EOL] [EOL] @ property def amount ( self ) : [EOL] return len ( self ) [EOL] [EOL] @ property def empty ( self ) : [EOL] return self . amount == [number] [EOL] [EOL] def add_unit ( self , unit ) : [EOL] self . add ( unit . tag ) [EOL] [EOL] def add_units ( self , units ) : [EOL] for unit in units : [EOL] self . add_unit ( unit ) [EOL] [EOL] def remove_unit ( self , unit ) : [EOL] self . remove ( unit . tag ) [EOL] [EOL] def remove_units ( self , units ) : [EOL] for unit in units : [EOL] self . remove ( unit . tag ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Union , Set [EOL] import typing [EOL] import builtins [EOL] import sc2 [EOL] import sc2 [EOL] from sc2 import Race [EOL] from sc2 . player import Bot [EOL] [EOL] from sc2 . units import Units [EOL] from sc2 . unit import Unit [EOL] from sc2 . position import Point2 , Point3 [EOL] [EOL] from sc2 . ids . unit_typeid import UnitTypeId [EOL] from sc2 . ids . upgrade_id import UpgradeId [EOL] from sc2 . ids . buff_id import BuffId [EOL] from sc2 . ids . ability_id import AbilityId [EOL] [EOL] from typing import List , Dict , Set , Tuple , Any , Optional , Union [comment] [EOL] [EOL] [docstring] [EOL] [EOL] class MarineSplitChallenge ( sc2 . BotAI ) : [EOL] async def on_step ( self , iteration ) : [EOL] if iteration == [number] : [EOL] await self . on_first_iteration ( ) [EOL] [EOL] actions = [ ] [EOL] [EOL] [comment] [EOL] for unit in self . units ( UnitTypeId . MARINE ) : [EOL] [EOL] if self . known_enemy_units : [EOL] [EOL] [comment] [EOL] if unit . weapon_cooldown <= self . _client . game_step / [number] : [EOL] enemies_in_range = self . known_enemy_units . filter ( lambda u : unit . target_in_range ( u ) ) [EOL] [EOL] [comment] [EOL] if enemies_in_range : [EOL] [comment] [EOL] if self . already_pending_upgrade ( UpgradeId . STIMPACK ) == [number] and not unit . has_buff ( BuffId . STIMPACK ) and unit . health > [number] : [EOL] actions . append ( unit ( AbilityId . EFFECT_STIM ) ) [EOL] [EOL] [EOL] [comment] [EOL] filtered_enemies_in_range = enemies_in_range . of_type ( UnitTypeId . BANELING ) [EOL] [EOL] if not filtered_enemies_in_range : [EOL] filtered_enemies_in_range = enemies_in_range . of_type ( UnitTypeId . ZERGLING ) [EOL] [comment] [EOL] lowest_hp_enemy_in_range = min ( filtered_enemies_in_range , key = lambda u : u . health ) [EOL] actions . append ( unit . attack ( lowest_hp_enemy_in_range ) ) [EOL] [EOL] [comment] [EOL] else : [EOL] closest_enemy = self . known_enemy_units . closest_to ( unit ) [EOL] actions . append ( unit . attack ( closest_enemy ) ) [EOL] [EOL] [EOL] [comment] [EOL] else : [EOL] stutter_step_positions = self . position_around_unit ( unit , distance = [number] ) [EOL] [EOL] [comment] [EOL] stutter_step_positions = { p for p in stutter_step_positions if self . in_pathing_grid ( p ) } [EOL] [EOL] [comment] [EOL] enemies_in_range = self . known_enemy_units . filter ( lambda u : unit . target_in_range ( u , - [number] ) ) [EOL] [EOL] if stutter_step_positions and enemies_in_range : [EOL] retreat_position = max ( stutter_step_positions , key = lambda x : x . distance_to ( enemies_in_range . center ) - x . distance_to ( unit ) ) [EOL] actions . append ( unit . move ( retreat_position ) ) [EOL] [EOL] else : [EOL] print ( [string] . format ( unit , unit . position . rounded ) ) [EOL] [EOL] await self . do_actions ( actions ) [EOL] [EOL] [EOL] [EOL] async def on_first_iteration ( self ) : [EOL] await self . chat_send ( [string] ) [EOL] self . _client . game_step = [number] [comment] [EOL] [EOL] [EOL] [EOL] def position_around_unit ( self , pos , distance = [number] , step_size = [number] , exclude_out_of_bounds = True ) : [EOL] pos = pos . position . to2 . rounded [EOL] positions = { pos . offset ( Point2 ( ( x , y ) ) ) for x in range ( - distance , distance + [number] , step_size ) for y in range ( - distance , distance + [number] , step_size ) if ( x , y ) != ( [number] , [number] ) } [EOL] [comment] [EOL] if exclude_out_of_bounds : [EOL] positions = { p for p in positions if [number] <= p [ [number] ] < self . _game_info . pathing_grid . width and [number] <= p [ [number] ] < self . _game_info . pathing_grid . height } [EOL] return positions [EOL] [EOL] [EOL] def main ( ) : [EOL] sc2 . run_game ( sc2 . maps . get ( [string] ) , [ Bot ( Race . Terran , MarineSplitChallenge ( ) ) , ] , realtime = False , save_replay_as = [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from pathlib import Path [EOL] __all__ = [ p . stem for p in Path ( ) . iterdir ( ) if p . is_file ( ) and p . suffix == [string] and p . stem != [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from pathlib import Path [EOL] __all__ = [ p . stem for p in Path ( ) . iterdir ( ) if p . is_file ( ) and p . suffix == [string] and p . stem != [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from pathlib import Path [EOL] __all__ = [ p . stem for p in Path ( ) . iterdir ( ) if p . is_file ( ) and p . suffix == [string] and p . stem != [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from pathlib import Path [EOL] __all__ = [ p . stem for p in Path ( ) . iterdir ( ) if p . is_file ( ) and p . suffix == [string] and p . stem != [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from functools import reduce [EOL] from operator import or_ [EOL] import random [EOL] [EOL] import sc2 [EOL] from sc2 import Race , Difficulty [EOL] from sc2 . constants import * [EOL] from sc2 . player import Bot , Computer [EOL] from sc2 . data import race_townhalls [EOL] [EOL] import enum [EOL] [EOL] class BroodlordBot ( sc2 . BotAI ) : [EOL] def select_target ( self ) : [EOL] if self . known_enemy_structures . exists : [EOL] return random . choice ( self . known_enemy_structures ) . position [EOL] [EOL] return self . enemy_start_locations [ [number] ] [EOL] [EOL] async def on_step ( self , iteration ) : [EOL] larvae = self . units ( LARVA ) [EOL] forces = self . units ( ZERGLING ) | self . units ( CORRUPTOR ) | self . units ( BROODLORD ) [EOL] [EOL] if self . units ( BROODLORD ) . amount > [number] and iteration % [number] == [number] : [EOL] for unit in forces : [EOL] await self . do ( unit . attack ( self . select_target ( ) ) ) [EOL] [EOL] if self . supply_left < [number] : [EOL] if self . can_afford ( OVERLORD ) and larvae . exists : [EOL] await self . do ( larvae . random . train ( OVERLORD ) ) [EOL] return [EOL] [EOL] if self . units ( GREATERSPIRE ) . ready . exists : [EOL] corruptors = self . units ( CORRUPTOR ) [EOL] [comment] [EOL] if corruptors . exists and corruptors . amount > self . units ( BROODLORD ) . amount : [EOL] if self . can_afford ( BROODLORD ) : [EOL] await self . do ( corruptors . random . train ( BROODLORD ) ) [EOL] elif self . can_afford ( CORRUPTOR ) and larvae . exists : [EOL] await self . do ( larvae . random . train ( CORRUPTOR ) ) [EOL] return [EOL] [EOL] if not self . townhalls . exists : [EOL] for unit in self . units ( DRONE ) | self . units ( QUEEN ) | forces : [EOL] await self . do ( unit . attack ( self . enemy_start_locations [ [number] ] ) ) [EOL] return [EOL] else : [EOL] hq = self . townhalls . first [EOL] [EOL] for queen in self . units ( QUEEN ) . idle : [EOL] abilities = await self . get_available_abilities ( queen ) [EOL] if AbilityId . EFFECT_INJECTLARVA in abilities : [EOL] await self . do ( queen ( EFFECT_INJECTLARVA , hq ) ) [EOL] [EOL] if not ( self . units ( SPAWNINGPOOL ) . exists or self . already_pending ( SPAWNINGPOOL ) ) : [EOL] if self . can_afford ( SPAWNINGPOOL ) : [EOL] await self . build ( SPAWNINGPOOL , near = hq ) [EOL] [EOL] if self . units ( SPAWNINGPOOL ) . ready . exists : [EOL] if not self . units ( LAIR ) . exists and not self . units ( HIVE ) . exists and hq . noqueue : [EOL] if self . can_afford ( LAIR ) : [EOL] await self . do ( hq . build ( LAIR ) ) [EOL] [EOL] if self . units ( LAIR ) . ready . exists : [EOL] if not ( self . units ( INFESTATIONPIT ) . exists or self . already_pending ( INFESTATIONPIT ) ) : [EOL] if self . can_afford ( INFESTATIONPIT ) : [EOL] await self . build ( INFESTATIONPIT , near = hq ) [EOL] [EOL] if not ( self . units ( SPIRE ) . exists or self . already_pending ( SPIRE ) ) : [EOL] if self . can_afford ( SPIRE ) : [EOL] await self . build ( SPIRE , near = hq ) [EOL] [EOL] if self . units ( INFESTATIONPIT ) . ready . exists and not self . units ( HIVE ) . exists and hq . noqueue : [EOL] if self . can_afford ( HIVE ) : [EOL] await self . do ( hq . build ( HIVE ) ) [EOL] [EOL] if self . units ( HIVE ) . ready . exists : [EOL] spires = self . units ( SPIRE ) . ready [EOL] if spires . exists : [EOL] spire = spires . random [EOL] if self . can_afford ( GREATERSPIRE ) and spire . noqueue : [EOL] await self . do ( spire . build ( GREATERSPIRE ) ) [EOL] [EOL] if self . units ( EXTRACTOR ) . amount < [number] and not self . already_pending ( EXTRACTOR ) : [EOL] if self . can_afford ( EXTRACTOR ) : [EOL] drone = self . workers . random [EOL] target = self . state . vespene_geyser . closest_to ( drone . position ) [EOL] err = await self . do ( drone . build ( EXTRACTOR , target ) ) [EOL] [EOL] if hq . assigned_harvesters < hq . ideal_harvesters : [EOL] if self . can_afford ( DRONE ) and larvae . exists : [EOL] larva = larvae . random [EOL] await self . do ( larva . train ( DRONE ) ) [EOL] return [EOL] [EOL] for a in self . units ( EXTRACTOR ) : [EOL] if a . assigned_harvesters < a . ideal_harvesters : [EOL] w = self . workers . closer_than ( [number] , a ) [EOL] if w . exists : [EOL] await self . do ( w . random . gather ( a ) ) [EOL] [EOL] if self . units ( SPAWNINGPOOL ) . ready . exists : [EOL] if not self . units ( QUEEN ) . exists and hq . is_ready and hq . noqueue : [EOL] if self . can_afford ( QUEEN ) : [EOL] await self . do ( hq . train ( QUEEN ) ) [EOL] [EOL] if self . units ( ZERGLING ) . amount < [number] and self . minerals > [number] : [EOL] if larvae . exists and self . can_afford ( ZERGLING ) : [EOL] await self . do ( larvae . random . train ( ZERGLING ) ) [EOL] [EOL] def main ( ) : [EOL] sc2 . run_game ( sc2 . maps . get ( [string] ) , [ Bot ( Race . Zerg , BroodlordBot ( ) ) , Computer ( Race . Terran , Difficulty . Medium ) ] , realtime = False , save_replay_as = [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sc2 [EOL] from sc2 . main import SlidingTimeWindow [EOL] [EOL] def test_sliding_time_window ( ) : [EOL] stw = SlidingTimeWindow ( [number] ) [EOL] [EOL] stw . push ( [number] ) [EOL] assert stw . sum == [number] [EOL] [EOL] stw . push ( [number] ) [EOL] assert stw . sum == [number] [EOL] [EOL] stw . push ( [number] ) [EOL] assert stw . sum == [number] [EOL] [EOL] stw . push ( [number] ) [EOL] assert stw . sum == [number] [EOL] [EOL] stw . push ( [number] ) [EOL] assert stw . sum == [number] [EOL] [EOL] [comment] [EOL] [EOL] stw . push ( [number] ) [EOL] assert stw . sum == [number] [EOL] [EOL] stw . push ( [number] ) [EOL] assert stw . sum == [number] [EOL] [EOL] stw . push ( [number] ) [EOL] assert stw . sum == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0