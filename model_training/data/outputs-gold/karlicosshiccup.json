[comment] [EOL] [comment] [EOL] [docstring] [EOL] import sys [EOL] [EOL] from pkg_resources import require , VersionConflict [EOL] from setuptools import setup [EOL] [EOL] try : [EOL] require ( [string] ) [EOL] except VersionConflict : [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] setup ( package_data = { [string] : [ [string] ] , } , use_pyscaffold = True , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , List , Dict [EOL] import datetime [EOL] import tests [EOL] import lxml [EOL] import typing [EOL] import builtins [EOL] import re [EOL] [EOL] from lxml import etree as ET [EOL] [EOL] from hiccup import Hiccup , xfind , xfind_all [EOL] from hiccup import IfParentType , IfName [EOL] [EOL] __author__ = [string] [EOL] __copyright__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [EOL] def as_xml ( obj ) : [EOL] return Hiccup ( ) . as_xml ( obj ) [EOL] [EOL] [EOL] class Xml : [EOL] [docstring] [EOL] def __init__ ( self , xmls ) : [EOL] self . xml = ET . fromstring ( re . sub ( [string] , [string] , xmls , flags = re . MULTILINE ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return Xml . elements_equal ( self . xml , other ) [EOL] [EOL] [comment] [EOL] @ staticmethod def elements_equal ( e1 , e2 ) : [EOL] def without_pyid ( attrs ) : [EOL] return { k : v for k , v in attrs . items ( ) if k != [string] } [EOL] [EOL] if e1 . tag != e2 . tag : [EOL] return False [EOL] if e1 . text != e2 . text : [EOL] return False [EOL] if e1 . tail != e2 . tail : [EOL] return False [EOL] if without_pyid ( e1 . attrib ) != without_pyid ( e2 . attrib ) : [EOL] return False [EOL] if len ( e1 ) != len ( e2 ) : [EOL] return False [EOL] [EOL] ch1 = sorted ( e1 , key = lambda e : e . tag ) [EOL] ch2 = sorted ( e2 , key = lambda e : e . tag ) [EOL] return all ( Xml . elements_equal ( c1 , c2 ) for c1 , c2 in zip ( ch1 , ch2 ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_as_xml ( ) : [EOL] assert as_xml ( [string] ) == Xml ( [string] ) [EOL] assert as_xml ( [ [string] , [string] ] ) == Xml ( [string] ) [EOL] [EOL] [EOL] class Simple : [EOL] def __init__ ( self , value ) : [EOL] self . value = value [EOL] [EOL] @ property def prop ( self ) : [EOL] return [string] + self . value [EOL] [EOL] [EOL] def test_simple ( ) : [EOL] xx = Simple ( [string] ) [EOL] assert as_xml ( xx ) == Xml ( [string] ) [EOL] [EOL] res = xfind ( xx , [string] ) [EOL] assert res == [string] [EOL] [EOL] [EOL] def test_simple_prop ( ) : [EOL] xx = Simple ( [string] ) [EOL] [EOL] res = xfind ( xx , [string] ) [EOL] assert res == [string] [EOL] [EOL] [EOL] class Tree : [EOL] def __init__ ( self , node , * children ) : [EOL] self . node = node [EOL] self . children = children [EOL] [EOL] [EOL] def test_tree ( ) : [EOL] left = Tree ( [string] ) [EOL] right = Tree ( [string] ) [EOL] tt = Tree ( [string] , left , right ) [EOL] assert as_xml ( tt ) == Xml ( [string] ) [EOL] [EOL] res = xfind ( tt , [string] ) [EOL] assert res is tt [EOL] [EOL] resl = xfind_all ( tt , [string] ) [EOL] assert len ( resl ) == [number] [EOL] [comment] [EOL] assert resl == [ tt , left , right ] [EOL] [EOL] [EOL] def test_types ( ) : [EOL] class X : [EOL] def __init__ ( self ) : [EOL] self . first = [number] [EOL] self . second = [number] [EOL] self . third = False [EOL] self . fourth = None [EOL] [EOL] x = X ( ) [EOL] as_xml ( x ) [comment] [EOL] [EOL] [EOL] def test_recursive ( ) : [EOL] class X : [EOL] def __init__ ( self ) : [EOL] self . inf = None [EOL] a = X ( ) [EOL] a . inf = a [EOL] [EOL] h = Hiccup ( ) [EOL] h . exclude ( IfParentType ( X ) , IfName ( [string] ) ) [EOL] [EOL] [comment] [EOL] h . as_xml ( a ) [EOL] [EOL] [EOL] def test_exclude_class ( ) : [EOL] [EOL] class A : [EOL] def __init__ ( self ) : [EOL] self . x = None [EOL] self . b = None [EOL] [EOL] class B : [EOL] def __init__ ( self ) : [EOL] self . xxx = [string] [EOL] [EOL] a = A ( ) [EOL] a . x = [string] [EOL] a . b = B ( ) [EOL] [EOL] h = Hiccup ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert h . as_xml ( a ) == Xml ( [string] ) [EOL] [EOL] h . exclude ( IfParentType ( B ) ) [EOL] [EOL] assert h . as_xml ( a ) == Xml ( [string] ) [EOL] [EOL] [EOL] def test_custom_primitive ( ) : [EOL] from datetime import datetime [EOL] d = datetime ( year = [number] , month = [number] , day = [number] ) [EOL] [EOL] h = Hiccup ( ) [EOL] h . primitive_factory . converters [ datetime ] = lambda x : x . strftime ( [string] ) [EOL] [EOL] assert h . as_xml ( d ) == Xml ( [string] ) [EOL] [EOL] [EOL] def test_name_mapping ( ) : [EOL] class A : [EOL] def __init__ ( self ) : [EOL] pass [EOL] ll = [ A ( ) , A ( ) , ] [EOL] [EOL] h = Hiccup ( ) [EOL] h . type_name_map . maps [ A ] = [string] [EOL] [EOL] assert h . as_xml ( ll ) == Xml ( [string] ) [EOL] [EOL] [EOL] def test_set_str ( ) : [EOL] ss = { [string] , [string] , [string] , } [EOL] [EOL] [comment] [EOL] xfind ( ss , [string] ) [EOL] xfind ( ss , [string] ) [EOL] xfind ( ss , [string] ) [EOL] [EOL] [EOL] def test_error ( ) : [EOL] class A : [EOL] @ property def error ( self ) : [EOL] raise RuntimeError [EOL] a = A ( ) [EOL] [EOL] [comment] [EOL] xfind_all ( a , [string] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_bad_characters ( ) : [EOL] sss = { [string] , } [EOL] [EOL] res = xfind_all ( sss , [string] ) [EOL] [EOL] assert len ( res ) == [number] [EOL] [EOL] [EOL] [comment] [EOL] def test_query_dict ( ) : [EOL] d = { [string] : { [string] : [string] , } } [EOL] [EOL] res = xfind_all ( d , [string] ) [EOL] [EOL] assert len ( res ) == [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_bad_tag_filtered ( ) : [EOL] class A : [EOL] pass [EOL] setattr ( A , [string] , [string] ) [EOL] [EOL] a = A ( ) [EOL] as_xml ( a ) [EOL] [EOL] [EOL] def test_exclude_member ( ) : [EOL] triggered = [ False ] [EOL] [EOL] class A : [EOL] @ property def do_not_include ( self ) : [EOL] triggered [ [number] ] = True [EOL] return [number] [EOL] [EOL] @ property def include ( self ) : [EOL] return [string] [EOL] [EOL] a = A ( ) [EOL] [EOL] h = Hiccup ( ) [EOL] h . exclude ( IfParentType ( A ) , IfName ( [string] ) ) [EOL] assert h . xfind ( a , [string] ) == [string] [EOL] [EOL] assert not triggered [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $lxml.etree.ElementTree$ 0 0 0 0 0 0 0 0 0 0 0 0 $lxml.etree.ElementTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from lxml import etree as ET [EOL] [EOL] [EOL] def pretty ( xml ) : [EOL] return ET . tostring ( xml , pretty_print = True , encoding = [string] ) . splitlines ( ) [EOL] [EOL] [EOL] def pytest_assertrepr_compare ( op , left , right ) : [EOL] from test import Xml [EOL] if isinstance ( right , Xml ) and op == [string] : [EOL] return [ [string] , [string] , * [ [string] + x for x in pretty ( left ) ] , [string] , * [ [string] + x for x in pretty ( right . xml ) ] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0