from typing import Any [EOL] import typing [EOL] import config [EOL] import os [EOL] import logging [EOL] [EOL] import connection . client_core [EOL] import connection . server_core [EOL] from config . config import Settings [EOL] [EOL] [comment] [EOL] os . chdir ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) [EOL] [EOL] settings = Settings ( str ( os . path . join ( [string] , [string] ) ) ) [EOL] [EOL] log_level = getattr ( logging , settings . log_level ) [EOL] logging . basicConfig ( level = log_level , handlers = [ logging . FileHandler ( [string] , mode = [string] ) , logging . StreamHandler ( ) ] ) [EOL] [EOL] if settings . is_server : [EOL] logging . info ( [string] ) [EOL] connection . server_core . main ( settings ) [EOL] else : [EOL] logging . info ( [string] ) [EOL] connection . client_core . main ( settings ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $config.config.Settings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $config.config.Settings$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $config.config.Settings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $config.config.Settings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $config.config.Settings$ 0 0
import messages [EOL] import datetime [EOL] import builtins [EOL] from datetime import datetime as dt [EOL] [EOL] from messages . message_types import MessageType [EOL] [EOL] [EOL] class TimeMessage : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . datetime = dt . now ( ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] type_buf = MessageType . TIME_MESSAGE . to_bytes ( [number] , byteorder = [string] , signed = False ) [EOL] [EOL] [comment] [EOL] ts = int ( dt . now ( ) . timestamp ( ) * [number] ) [EOL] ts_buf = ts . to_bytes ( [number] , byteorder = [string] , signed = False ) [EOL] return type_buf + ts_buf [EOL] [EOL] @ staticmethod def from_bytes ( bb ) : [EOL] msg_type = int . from_bytes ( bb [ [number] : [number] ] , byteorder = [string] , signed = False ) [EOL] assert msg_type == MessageType . TIME_MESSAGE [EOL] assert len ( bb ) == [number] [EOL] [EOL] ts = int . from_bytes ( bb [ [number] : [number] ] , byteorder = [string] , signed = False ) [EOL] time = dt . fromtimestamp ( ts / [number] ) [EOL] [EOL] tm = TimeMessage ( ) [EOL] tm . datetime = time [EOL] return tm [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $messages.time_message.TimeMessage$ 0 0 0 0 0 $messages.time_message.TimeMessage$ 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 $messages.time_message.TimeMessage$ 0
import messages [EOL] import builtins [EOL] from messages . message_types import Command , MessageType [EOL] [EOL] [EOL] class CommandMessage : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , command ) : [EOL] self . command = command [EOL] [EOL] def __bytes__ ( self ) : [EOL] type_buf = MessageType . COMMAND_MESSAGE . to_bytes ( [number] , byteorder = [string] , signed = False ) [EOL] command_buf = self . command . to_bytes ( [number] , byteorder = [string] , signed = False ) [EOL] return type_buf + command_buf [EOL] [EOL] @ staticmethod def from_bytes ( bb ) : [EOL] msg_type = int . from_bytes ( bb [ [number] : [number] ] , byteorder = [string] , signed = False ) [EOL] assert msg_type == MessageType . COMMAND_MESSAGE [EOL] assert len ( bb ) == [number] [EOL] [EOL] command = Command ( int . from_bytes ( bb [ [number] : [number] ] , byteorder = [string] , signed = False ) ) [EOL] return CommandMessage ( command ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $messages.message_types.Command$ 0 0 0 0 0 $messages.message_types.Command$ 0 $messages.message_types.Command$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $messages.message_types.Command$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $messages.message_types.Command$ 0 0
from typing import Union [EOL] import messages [EOL] import typing [EOL] import builtins [EOL] from typing import Union [EOL] [EOL] from messages . message_types import MessageType [EOL] from messages . command_message import CommandMessage [EOL] from messages . time_message import TimeMessage [EOL] from messages . string_message import StringMessage [EOL] [EOL] [EOL] def from_bytes ( bb ) : [EOL] [docstring] [EOL] message_type = int . from_bytes ( bb [ [number] : [number] ] , byteorder = [string] , signed = False ) [EOL] [EOL] if message_type == MessageType . TIME_MESSAGE : [EOL] return TimeMessage . from_bytes ( bb ) [EOL] elif message_type == MessageType . COMMAND_MESSAGE : [EOL] return CommandMessage . from_bytes ( bb ) [EOL] elif message_type == MessageType . STRING_MESSAGE : [EOL] return StringMessage . from_bytes ( bb ) [EOL] else : [EOL] raise Exception ( [string] + str ( message_type ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[messages.command_message.CommandMessage,messages.time_message.TimeMessage,messages.string_message.StringMessage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from enum import IntEnum [EOL] [EOL] [EOL] class MessageType ( IntEnum ) : [EOL] TIME_MESSAGE = [number] , [EOL] COMMAND_MESSAGE = [number] , [EOL] STRING_MESSAGE = [number] , [EOL] [EOL] [EOL] class Command ( IntEnum ) : [EOL] [comment] [EOL] START = [number] , [EOL] [EOL] [comment] [EOL] [comment] [EOL] CYA = [number] , [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] COMMAND = [number] , [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] from messages . message_types import MessageType [EOL] [EOL] [EOL] class StringMessage : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , string ) : [EOL] self . string = string [EOL] [EOL] def __bytes__ ( self ) : [EOL] string_buf = self . string . encode ( [string] ) [EOL] type_buf = MessageType . STRING_MESSAGE . to_bytes ( [number] , byteorder = [string] , signed = False ) [EOL] [EOL] return type_buf + string_buf [EOL] [EOL] @ staticmethod def from_bytes ( bb ) : [EOL] msg_type = int . from_bytes ( bb [ [number] : [number] ] , byteorder = [string] , signed = False ) [EOL] assert msg_type == MessageType . STRING_MESSAGE [EOL] [EOL] string = bb [ [number] : ] . decode ( [string] ) [EOL] [EOL] return StringMessage ( string ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 $'StringMessage'$ 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
import configparser [EOL] import configparser [EOL] import sys [EOL] [EOL] [EOL] class Settings : [EOL] [EOL] def __init__ ( self , path , ** kwargs ) : [EOL] if path is not None : [EOL] self . read_config ( path ) [EOL] [EOL] def read_config ( self , path ) : [EOL] config = configparser . ConfigParser ( ) [EOL] config . read ( path ) [EOL] [EOL] try : [EOL] general_config = config [ [string] ] [EOL] network_config = config [ [string] ] [EOL] airodump_config = config [ [string] ] [EOL] storage_config = config [ [string] ] [EOL] [EOL] self . is_server = general_config [ [string] ] . lower ( ) == [string] [EOL] self . log_level = general_config [ [string] ] . upper ( ) [EOL] if self . log_level not in [ [string] , [string] , [string] , [string] ] : [EOL] raise Exception ( f" [string] { self . log_level } [string] " ) [EOL] [EOL] [comment] [EOL] self . server_ip = network_config [ [string] ] [EOL] self . server_port = network_config . getint ( [string] ) [EOL] self . socket_timeout = network_config . getint ( [string] ) [EOL] self . connection_attempts = network_config . getint ( [string] ) [EOL] [EOL] [comment] [EOL] self . zip = storage_config . getboolean ( [string] ) [EOL] self . zip_freq = storage_config . getint ( [string] ) [EOL] self . zip_file_buffer = storage_config . getint ( [string] ) [EOL] if self . zip_file_buffer < [number] : [EOL] raise Exception ( f" [string] { self . log_level } [string] " ) [EOL] self . zip_path = storage_config [ [string] ] [EOL] self . zip_group_size = storage_config . getint ( [string] ) [EOL] [EOL] [comment] [EOL] self . airodump_command = airodump_config [ [string] ] [EOL] ifaces = airodump_config [ [string] ] [EOL] self . airodump_iface_macs = [ x . strip ( ) . lower ( ) for x in ifaces . split ( [string] ) ] [EOL] self . capture_path = airodump_config [ [string] ] [EOL] self . cap_freq = airodump_config . getint ( [string] ) [EOL] [EOL] [EOL] except KeyError as ex : [EOL] print ( [string] + ex . args [ [number] ] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 $configparser.ConfigParser$ 0 0 0 0 $configparser.SectionProxy$ 0 $configparser.ConfigParser$ 0 0 0 0 $configparser.SectionProxy$ 0 $configparser.ConfigParser$ 0 0 0 0 $configparser.SectionProxy$ 0 $configparser.ConfigParser$ 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 $builtins.str$ 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Pattern , Set , List [EOL] import config [EOL] import typing [EOL] import builtins [EOL] import json [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import time [EOL] import zipfile [EOL] [EOL] import config . config [EOL] [EOL] all_cap_csv = re . compile ( [string] ) [EOL] [EOL] [EOL] def save_data ( to_save , path ) : [EOL] with open ( path , [string] ) as save_file : [EOL] save_file . writelines ( json . dumps ( to_save , sort_keys = True , indent = [number] ) ) [EOL] [EOL] [EOL] def load_data ( path ) : [EOL] with open ( path , [string] ) as save_file : [EOL] return json . load ( save_file ) [EOL] [EOL] [EOL] def zip_and_delete ( settings ) : [EOL] os . makedirs ( settings . zip_path , exist_ok = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] zip_ctr = [number] [EOL] while True : [EOL] filename = f' [string] { zip_ctr } [string] ' [EOL] if not os . path . isfile ( os . path . join ( settings . zip_path , filename ) ) : [EOL] break [EOL] zip_ctr += [number] [EOL] [EOL] print ( f" [string] { zip_ctr } [string] " ) [EOL] [EOL] saved_files = set ( ) [EOL] [EOL] while True : [EOL] files = os . listdir ( settings . capture_path ) [EOL] [EOL] zip_list = list ( ) [EOL] candidates = list ( ) [EOL] [EOL] [comment] [EOL] for f in files : [EOL] if f not in saved_files : [EOL] match = all_cap_csv . match ( f ) [EOL] [EOL] if match is not None : [EOL] candidates . append ( match . group ( [number] ) ) [EOL] [EOL] candidates = sorted ( candidates ) [EOL] zip_list = candidates [ : - settings . zip_file_buffer ] [EOL] [EOL] print ( zip_list ) [EOL] [EOL] [comment] [EOL] if len ( zip_list ) >= int ( settings . zip_group_size ) : [EOL] filename = f' [string] { zip_ctr } [string] ' [EOL] with zipfile . ZipFile ( os . path . join ( settings . zip_path , filename ) , [string] ) as zipper : [EOL] for f in zip_list : [EOL] zipper . write ( os . path . join ( settings . capture_path , f ) , f , compress_type = zipfile . ZIP_DEFLATED ) [EOL] saved_files . add ( f ) [EOL] [comment] [EOL] [comment] [EOL] subprocess . call ( [string] . format ( os . path . join ( settings . capture_path , f ) ) , shell = True , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL ) [EOL] [EOL] zip_ctr += [number] [EOL] [EOL] time . sleep ( settings . zip_freq ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import connection [EOL] import typing [EOL] import socket [EOL] import config [EOL] import threading [EOL] import socket [EOL] import logging [EOL] from threading import Thread [EOL] [EOL] from config . config import Settings [EOL] from messages . command_message import CommandMessage [EOL] from messages . message_types import Command [EOL] from messages . time_message import TimeMessage [EOL] from messages . string_message import StringMessage [EOL] from connection . socket_wrapper import SocketWrapper [EOL] [EOL] [EOL] def main ( settings ) : [EOL] [comment] [EOL] [comment] [EOL] server_socket = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] server_port = settings . server_port [EOL] [EOL] [comment] [EOL] server_socket . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] [EOL] server_socket . bind ( ( [string] , server_port ) ) [EOL] server_socket . listen ( [number] ) [EOL] [EOL] while True : [EOL] try : [EOL] logging . info ( [string] ) [EOL] ( client_socket , address ) = server_socket . accept ( ) [EOL] t = Thread ( target = run , args = ( client_socket , address , settings ) ) [EOL] t . start ( ) [EOL] except socket . timeout : [EOL] logging . warn ( [string] ) [EOL] pass [EOL] [EOL] [EOL] def run ( client_socket , address , settings ) : [EOL] [docstring] [EOL] logging . info ( f' [string] { address [ [number] ] } [string] ' ) [EOL] client_socket . settimeout ( settings . socket_timeout ) [EOL] wsock = SocketWrapper ( client_socket ) [EOL] [EOL] try : [EOL] [comment] [EOL] logging . info ( [string] ) [EOL] wsock . send_message ( bytes ( TimeMessage ( ) ) ) [EOL] wsock . send_message ( bytes ( CommandMessage ( Command . COMMAND ) ) ) [EOL] wsock . send_message ( bytes ( StringMessage ( settings . airodump_command ) ) ) [EOL] wsock . send_message ( bytes ( CommandMessage ( Command . START ) ) ) [EOL] [EOL] msg = wsock . receive_message ( ) [EOL] if isinstance ( msg , CommandMessage ) : [EOL] if msg . command == Command . CYA : [EOL] logging . info ( [string] ) [EOL] [comment] [EOL] [EOL] client_socket . close ( ) [EOL] except ConnectionResetError : [EOL] logging . info ( f' [string] { address [ [number] ] } [string] ' ) [EOL] client_socket . close ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List , Optional , Dict [EOL] import connection [EOL] import threading [EOL] import datetime [EOL] import typing [EOL] import socket [EOL] import config [EOL] import builtins [EOL] import datetime as dt [EOL] import logging [EOL] import os [EOL] import shlex [EOL] import socket [EOL] import subprocess [EOL] import threading [EOL] import time [EOL] from typing import Optional [EOL] [EOL] import config . config [EOL] import util . save_files as sf [EOL] from connection . socket_wrapper import SocketWrapper [EOL] from messages . command_message import CommandMessage [EOL] from messages . message_types import Command [EOL] from messages . string_message import StringMessage [EOL] from messages . time_message import TimeMessage [EOL] [EOL] [comment] [EOL] save_path = os . path . join ( [string] , [string] ) [EOL] [EOL] [EOL] def main ( settings ) : [EOL] wlan_thread_stop = threading . Event ( ) [EOL] [EOL] if settings . zip : [EOL] [comment] [EOL] zip_thread = threading . Thread ( target = sf . zip_and_delete , args = ( settings , ) ) [EOL] zip_thread . daemon = True [EOL] zip_thread . start ( ) [EOL] [EOL] try : [EOL] [comment] [EOL] loaded_settings = sf . load_data ( save_path ) [EOL] [EOL] logging . info ( [string] ) [EOL] wlan_thread = threading . Thread ( target = start_wlan_measurement , args = ( settings , wlan_thread_stop , loaded_settings [ [string] ] ) ) [EOL] wlan_thread . daemon = True [EOL] wlan_thread . start ( ) [EOL] [EOL] [comment] [EOL] contact_successful = contact_server ( settings , settings . connection_attempts ) [EOL] except FileNotFoundError : [EOL] [comment] [EOL] [comment] [EOL] contact_successful = contact_server ( settings , None ) [EOL] [EOL] if contact_successful : [EOL] wlan_thread_stop . set ( ) [EOL] [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] wlan_thread_stop = threading . Event ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] start_wlan_measurement ( settings , wlan_thread_stop ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] while (True) : [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def contact_server ( settings , attempts ) : [EOL] [docstring] [EOL] connection_successful = False [EOL] print ( attempts ) [EOL] [EOL] while ( attempts is None or attempts > [number] ) : [EOL] try : [EOL] logging . info ( [string] ) [EOL] sock = socket . create_connection ( ( settings . server_ip , int ( settings . server_port ) ) , timeout = settings . socket_timeout ) [EOL] wsock = SocketWrapper ( sock ) [EOL] [EOL] msg = wsock . receive_message ( ) [EOL] if isinstance ( msg , TimeMessage ) : [EOL] set_time ( msg . datetime ) [EOL] else : [EOL] [comment] [EOL] continue [EOL] [EOL] msg = wsock . receive_message ( ) [EOL] if not isinstance ( msg , CommandMessage ) or not msg . command == Command . COMMAND : [EOL] [comment] [EOL] continue [EOL] [EOL] msg = wsock . receive_message ( ) [EOL] if isinstance ( msg , StringMessage ) : [EOL] [comment] [EOL] settings . airodump_command = msg . string [EOL] sf . save_data ( vars ( settings ) , save_path ) [EOL] else : [EOL] continue [EOL] [EOL] msg = wsock . receive_message ( ) [EOL] if isinstance ( msg , CommandMessage ) : [EOL] if msg . command == Command . START : [EOL] wsock . send_message ( bytes ( CommandMessage ( Command . CYA ) ) ) [EOL] connection_successful = True [EOL] break [EOL] [EOL] except ConnectionRefusedError : [EOL] logging . info ( [string] ) [EOL] logging . info ( [string] ) [EOL] time . sleep ( [number] ) [EOL] except socket . timeout : [EOL] logging . info ( [string] ) [EOL] sock . close ( ) [EOL] finally : [EOL] if isinstance ( attempts , int ) : [EOL] attempts -= [number] [EOL] logging . info ( f' [string] { attempts }' ) [EOL] [EOL] return connection_successful [EOL] [EOL] [EOL] def set_time ( time ) : [EOL] time_string = time . isoformat ( ) [EOL] logging . info ( f' [string] { time_string }' ) [EOL] subprocess . call ( shlex . split ( f" [string] { time_string }" ) ) [EOL] [EOL] [EOL] def start_wlan_measurement ( settings , stop_event , override_command = None ) : [EOL] [comment] [EOL] subprocess . call ( [string] , shell = True ) [EOL] [EOL] output_file = os . path . join ( settings . capture_path , [string] ) [EOL] [EOL] [comment] [EOL] network_dir = os . path . join ( os . sep , [string] , [string] , [string] ) [EOL] ifaces = os . listdir ( network_dir ) [EOL] [EOL] [comment] [EOL] airo_ifaces = [ ] [EOL] for interface in ifaces : [EOL] with open ( os . path . join ( network_dir , interface , [string] ) , [string] ) as f : [EOL] [comment] [EOL] mac_actual = f . readline ( ) . strip ( ) . lower ( ) [EOL] [EOL] for mac_airo in settings . airodump_iface_macs : [EOL] [comment] [EOL] [comment] [EOL] if mac_actual . find ( mac_airo ) == [number] : [EOL] airo_ifaces . append ( interface ) [EOL] break [EOL] [EOL] logging . info ( f' [string] { output_file }' ) [EOL] os . makedirs ( os . path . dirname ( output_file ) , exist_ok = True ) [EOL] [EOL] [comment] [EOL] if override_command is None : [EOL] call_statement = settings . airodump_command . format ( wlans = [string] . join ( airo_ifaces ) , output_file = output_file ) [EOL] else : [EOL] call_statement = override_command . format ( wlans = [string] . join ( airo_ifaces ) , output_file = output_file ) [EOL] logging . info ( f' [string] { call_statement } [string] ' ) [EOL] [EOL] while not stop_event . is_set ( ) : [EOL] print ( call_statement ) [EOL] subprocess . Popen ( shlex . split ( call_statement ) , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL ) [EOL] [EOL] stop_event . wait ( timeout = settings . cap_freq ) [EOL] subprocess . call ( [string] , shell = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
class ConnectionLost ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0