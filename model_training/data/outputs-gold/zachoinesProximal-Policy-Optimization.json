from typing import Any , List [EOL] import typing [EOL] import time , random [EOL] from threading import Thread [EOL] import numpy as np [EOL] import tensorflow as tf [EOL] [EOL] class WorkerThread ( Thread ) : [EOL] def __init__ ( self , group = None , target = None , name = None , args = ( ) , kwargs = { } , Verbose = None ) : [EOL] Thread . __init__ ( self , group , target , name , args , kwargs ) [EOL] self . _return = None [EOL] self . _target = target [EOL] self . _args = args [EOL] self . _kwargs = kwargs [EOL] [EOL] def run ( self ) : [EOL] if self . _target is not None : [EOL] self . _return = self . _target ( * self . _args , ** self . _kwargs ) [EOL] def join ( self , * args ) : [EOL] Thread . join ( self , * args ) [EOL] return self . _return [EOL] [EOL] [comment] [EOL] class Worker ( ) : [EOL] [EOL] def __init__ ( self , network , env , batch_size = [number] , render = True , exploration = [string] ) : [EOL] [EOL] [comment] [EOL] self . _batch_buffer = [ ] [EOL] self . _done = False [EOL] self . _render = render [EOL] self . total_steps = [number] [EOL] self . network = network [EOL] self . env = env [EOL] self . batch_size = batch_size [EOL] self . s = self . env . reset ( ) [EOL] self . NUM_ACTIONS = env . action_space . n [EOL] self . NONE_STATE = np . zeros ( self . env . observation_space . shape ) [EOL] self . exploration = exploration [EOL] [EOL] [EOL] [comment] [EOL] def reset ( self ) : [EOL] self . _batch_buffer = [ ] [EOL] self . _done = False [EOL] self . s = self . env . reset ( ) [EOL] [EOL] [EOL] [comment] [EOL] def run ( self , keep_prob ) : [EOL] batch = [ ] [EOL] while ( len ( batch ) < self . batch_size ) : [EOL] [EOL] [comment] [EOL] if not self . _done : [EOL] self . total_steps += [number] [EOL] [ logits ] , [ action_dist ] , value = self . network . step ( self . s , keep_p = keep_prob ) [EOL] [EOL] action = self . action_select ( logits , temperature = ( [number] - keep_prob ) ) [EOL] s_t , reward , d , stuff = self . env . step ( action ) [EOL] self . _done = d [EOL] [EOL] batch . append ( ( self . s , s_t , reward , value , action , d , logits . tolist ( ) ) ) [EOL] self . s = s_t [EOL] [EOL] [comment] [EOL] if ( self . _render ) : [EOL] self . env . render ( ) [EOL] [EOL] else : [EOL] self . _done = False [EOL] self . s = self . env . reset ( ) [EOL] [EOL] if batch == None or len ( batch ) < self . batch_size : [EOL] print ( [string] ) [EOL] raise [EOL] return batch [EOL] [EOL] [EOL] [EOL] [comment] [EOL] def get_batches ( self ) : [EOL] return self . _batch_buffer [EOL] [EOL] [EOL] [comment] [EOL] def action_select ( self , dist , exploration = [string] , temperature = [number] , epsilon = [number] ) : [EOL] [EOL] [comment] [EOL] if exploration == [string] : [EOL] [EOL] dist = tf . nn . softmax ( dist / ( (temperature) * [number] + [number] ) ) . numpy ( ) [EOL] [EOL] [ probas ] = np . random . multinomial ( [number] , dist , [number] ) [EOL] a = np . argmax ( probas ) [EOL] return a [EOL] [EOL] [EOL] [comment] [EOL] elif exploration == [string] : [EOL] [EOL] return np . argmax ( dist ) [EOL] [EOL] elif exploration == [string] : [EOL] [EOL] [comment] [EOL] if random . random ( ) < ( epsilon * temperature ) : [EOL] [EOL] return random . randint ( [number] , self . NUM_ACTIONS - [number] ) [EOL] [EOL] else : [EOL] dist = tf . nn . softmax ( dist ) . numpy ( ) [EOL] a = np . argmax ( dist ) [EOL] return a [EOL] [EOL] [comment] [EOL] else : [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] noise = tf . random . uniform ( dist . shape ) [EOL] return tf . argmax ( dist - tf . math . log ( - tf . math . log ( noise ) ) ) . numpy ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Any [EOL] import Wrappers [EOL] import typing [EOL] import os [EOL] import sys [EOL] import numpy as np [EOL] import time [EOL] import tensorflow as tf [EOL] [EOL] [comment] [EOL] import gym [EOL] [EOL] [comment] [EOL] import gym [EOL] import gym [EOL] from nes_py . wrappers import JoypadSpace [EOL] import gym_super_mario_bros [EOL] from gym_super_mario_bros . actions import SIMPLE_MOVEMENT , COMPLEX_MOVEMENT [EOL] [EOL] [comment] [EOL] from Wrappers import preprocess [EOL] from Wrappers . Normalize import Normalize [EOL] from Wrappers . Monitor import Monitor [EOL] from Wrappers . Stats import Stats , Collector , AsynchronousPlot [EOL] from Worker import Worker , WorkerThread [EOL] from NN . CNN_LARGE import AC_Model_Large [EOL] from NN . CNN_SMALL import AC_Model_Small [EOL] from Coordinator import Coordinator [EOL] from Wrappers . preprocess import FrameSkip [EOL] [EOL] from Config import config_pacman as config [EOL] [EOL] [EOL] class Test ( ) : [EOL] def __init__ ( self , config = config ) : [EOL] [EOL] [comment] [EOL] np . random . seed ( [number] ) [EOL] tf . random . set_seed ( [number] ) [EOL] [EOL] self . _config = config [EOL] current_dir = os . getcwd ( ) [EOL] model_save_path = current_dir + [string] [EOL] [EOL] [comment] [EOL] env = gym . make ( config [ [string] ] ) [EOL] [EOL] if config [ [string] ] == [string] : [EOL] env = JoypadSpace ( env , COMPLEX_MOVEMENT ) [EOL] env = preprocess . FrameSkip ( env , [number] ) [EOL] env = preprocess . GrayScaleImage ( env , height = [number] , width = [number] , grayscale = True ) [EOL] env = preprocess . FrameStack ( env , [number] ) [EOL] [EOL] NUM_STATE = env . observation_space . shape [EOL] NUM_ACTIONS = env . env . action_space . n [EOL] ACTION_SPACE = env . env . action_space [EOL] [EOL] network_params = ( NUM_STATE , [number] , NUM_ACTIONS , ACTION_SPACE ) [EOL] self . Test_Model = None [EOL] if self . _config [ [string] ] == [string] : [EOL] self . Test_Model = AC_Model_Large ( NUM_STATE , NUM_ACTIONS , self . _config , is_training = False ) [EOL] else : [EOL] self . Test_Model = AC_Model_Small ( NUM_STATE , NUM_ACTIONS , self . _config , is_training = False ) [EOL] [EOL] [comment] [EOL] if not os . path . exists ( model_save_path ) : [EOL] os . makedirs ( model_save_path ) [EOL] else : [EOL] try : [EOL] if ( os . path . exists ( model_save_path + [string] ) ) : [EOL] [EOL] self . Test_Model . load_model_weights ( ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] self . _run ( [number] , env , self . Test_Model , True ) [EOL] [EOL] else : [EOL] raise ( [string] ) [EOL] except : [EOL] print ( [string] ) [EOL] raise [EOL] [EOL] [comment] [EOL] def _run ( self , num_steps , env , network , render ) : [EOL] s = env . reset ( ) [EOL] done = False [EOL] for step in range ( num_steps ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] if not done : [EOL] [ logits ] , d , _ = network . step ( s , [number] ) [EOL] action = self . _action_select ( logits ) [EOL] s_t , reward , d , stuff = env . step ( action ) [EOL] done = d [EOL] s = s_t [EOL] [EOL] [comment] [EOL] if ( render and not done ) : [EOL] env . render ( ) [EOL] [EOL] else : [EOL] done = False [EOL] if (render) : [EOL] s = env . reset ( ) [EOL] env . render ( ) [EOL] print ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] def _action_select ( self , dist ) : [EOL] dist = tf . nn . softmax ( dist ) . numpy ( ) [EOL] a = np . argmax ( dist ) [EOL] return a [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 $typing.Tuple[unknown,builtins.float,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0
[comment] [EOL] from typing import Tuple , Any , List [EOL] import Wrappers [EOL] import Coordinator [EOL] import typing [EOL] import threading [EOL] from multiprocessing import Process [EOL] import os [EOL] import sys [EOL] import imp [EOL] import numpy as np [EOL] import tensorflow as tf [EOL] from tensorflow . python . client import device_lib [EOL] [EOL] [comment] [EOL] import gym [EOL] import gym [EOL] from nes_py . wrappers import JoypadSpace [EOL] import gym_super_mario_bros [EOL] from gym_super_mario_bros . actions import SIMPLE_MOVEMENT , COMPLEX_MOVEMENT [EOL] [EOL] [comment] [EOL] from Wrappers import preprocess [EOL] from Wrappers . Normalize import Normalize , MsPacmanWrapper [EOL] from Wrappers . Monitor import Monitor [EOL] from Wrappers . Stats import Stats , Collector , AsynchronousPlot [EOL] from Worker import Worker , WorkerThread [EOL] from NN . CNN_LARGE import AC_Model_Large [EOL] from NN . CNN_SMALL import AC_Model_Small [EOL] from Coordinator import Coordinator [EOL] from Wrappers . preprocess import FrameSkip [EOL] [EOL] [comment] [EOL] def env_wrapper_import ( class_name , env ) : [EOL] module = __import__ ( [string] ) [EOL] my_class = getattr ( module . Normalize , class_name ) [EOL] return my_class ( env ) [EOL] [EOL] [comment] [EOL] def CNN_class_import ( class_name , params ) : [EOL] module = __import__ ( [string] ) [EOL] my_class = getattr ( module , class_name ) [EOL] return my_class ( * params ) [EOL] [EOL] class Train ( ) : [EOL] [EOL] def __init__ ( self , config ) : [EOL] [EOL] self . _config = config [EOL] [EOL] def get_available_gpus ( ) : [EOL] local_device_protos = device_lib . list_local_devices ( ) [EOL] return [ x . name for x in local_device_protos if x . device_type == [string] ] [EOL] [EOL] print ( [string] , tf . test . is_gpu_available ( ) ) [EOL] [EOL] [comment] [EOL] gpus = tf . config . experimental . list_physical_devices ( [string] ) [EOL] tf . config . threading . set_inter_op_parallelism_threads ( [number] ) [EOL] tf . config . threading . set_intra_op_parallelism_threads ( [number] ) [EOL] [EOL] if gpus : [EOL] [EOL] try : [EOL] [EOL] [comment] [EOL] for gpu in gpus : [EOL] tf . config . experimental . set_memory_growth ( gpu , True ) [EOL] [EOL] except RuntimeError as e : [EOL] print ( e ) [EOL] [EOL] env_names = [ ] [EOL] for _ in range ( self . _config [ [string] ] ) : [EOL] env_names . append ( self . _config [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _model_save_path = [string] [EOL] self . _video_save_path = [string] [EOL] self . record = True [EOL] [EOL] [comment] [EOL] self . _envs = [ ] [EOL] collector = Collector ( ) [EOL] collector . set_dimensions ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . _plot = AsynchronousPlot ( collector , live = False ) [EOL] [EOL] [comment] [EOL] counter = [number] [EOL] for env_name in env_names : [EOL] env = gym . make ( env_name ) [EOL] [EOL] if env_name == [string] : [EOL] env = JoypadSpace ( env , COMPLEX_MOVEMENT ) [EOL] [EOL] [comment] [EOL] env = Stats ( env , collector ) [EOL] if self . _config [ [string] ] != [string] : [EOL] env = env_wrapper_import ( self . _config [ [string] ] , env ) [EOL] [EOL] [EOL] env = Monitor ( env , env . observation_space . shape , savePath = self . _video_save_path , record = self . record ) [EOL] [EOL] env = preprocess . GrayScaleImage ( env , height = [number] , width = [number] , grayscale = self . _config [ [string] ] ) [EOL] env = preprocess . FrameStack ( env , [number] ) [EOL] [EOL] self . _envs . append ( env ) [EOL] [EOL] self . NUM_STATE = self . _envs [ [number] ] . observation_space . shape [EOL] self . NUM_ACTIONS = self . _envs [ [number] ] . env . action_space . n [EOL] self . ACTION_SPACE = self . _envs [ [number] ] . env . action_space [EOL] [EOL] if not os . path . exists ( self . _video_save_path ) : [EOL] os . makedirs ( self . _video_save_path ) [EOL] [EOL] if not os . path . exists ( self . _model_save_path ) : [EOL] os . makedirs ( self . _model_save_path ) [EOL] [EOL] if not os . path . exists ( [string] ) : [EOL] os . makedirs ( [string] ) [EOL] [EOL] def start ( self ) : [EOL] workers = [ ] [EOL] network_params = ( self . NUM_STATE , self . _config [ [string] ] , self . NUM_ACTIONS , self . ACTION_SPACE ) [EOL] [EOL] [comment] [EOL] if self . _config [ [string] ] == [string] : [EOL] self . _global_model = AC_Model_Large ( self . NUM_STATE , self . NUM_ACTIONS , self . _config , is_training = True ) [EOL] self . _global_model ( tf . convert_to_tensor ( np . random . random ( ( [number] , * self . NUM_STATE ) ) , dtype = [string] ) ) [EOL] self . _step_model = AC_Model_Large ( self . NUM_STATE , self . NUM_ACTIONS , self . _config , is_training = True ) [EOL] self . _step_model ( tf . convert_to_tensor ( np . random . random ( ( [number] , * self . NUM_STATE ) ) , dtype = [string] ) ) [EOL] else : [EOL] self . _global_model = CNN_class_import ( self . _config [ [string] ] , ( self . NUM_STATE , self . NUM_ACTIONS , self . _config , True ) ) [EOL] self . _global_model ( tf . convert_to_tensor ( np . random . random ( ( [number] , * self . NUM_STATE ) ) , dtype = [string] ) ) [EOL] self . _step_model = CNN_class_import ( self . _config [ [string] ] , ( self . NUM_STATE , self . NUM_ACTIONS , self . _config , True ) ) [EOL] self . _step_model ( tf . convert_to_tensor ( np . random . random ( ( [number] , * self . NUM_STATE ) ) , dtype = [string] ) ) [EOL] [EOL] [comment] [EOL] if not os . path . exists ( self . _model_save_path ) : [EOL] os . makedirs ( self . _model_save_path ) [EOL] else : [EOL] try : [EOL] if ( os . path . exists ( self . _model_save_path + [string] ) ) : [EOL] [EOL] self . _global_model . load_model_weights ( ) [EOL] self . _step_model . load_model_weights ( ) [EOL] for env in self . _envs : [EOL] workers . append ( Worker ( self . _step_model , env , batch_size = self . _config [ [string] ] , render = False ) ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] else : [EOL] [EOL] for env in self . _envs : [EOL] workers . append ( Worker ( self . _step_model , env , batch_size = self . _config [ [string] ] , render = False ) ) [EOL] [EOL] print ( [string] ) [EOL] except : [EOL] print ( [string] ) [EOL] raise [EOL] [EOL] coordinator = Coordinator ( self . _global_model , self . _step_model , workers , self . _plot , self . _model_save_path , self . _config ) [EOL] [EOL] [comment] [EOL] try : [EOL] if coordinator . run ( ) : [EOL] try : [EOL] self . _global_model . save_model_weights ( ) [EOL] print ( [string] ) [EOL] return True [EOL] except : [EOL] print ( [string] ) [EOL] raise [EOL] [EOL] except : [EOL] print ( [string] ) [EOL] raise [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 $Wrappers.preprocess.FrameStack$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 $Wrappers.preprocess.FrameStack$ 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Wrappers.preprocess.FrameStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Tuple[unknown,typing.Any,unknown,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Coordinator.Coordinator.Coordinator$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Coordinator.Coordinator.Coordinator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import numpy as np [EOL] [EOL] import tensorflow as tf [EOL] [EOL] class AC_Model_Large ( tf . keras . Model ) : [EOL] def __init__ ( self , input_s , num_actions , config , is_training = True ) : [EOL] super ( AC_Model_Large , self ) . __init__ ( ) [EOL] self . value_s = None [EOL] self . action_s = None [EOL] self . num_actions = num_actions [EOL] self . training = is_training [EOL] [EOL] [comment] [EOL] self . entropy_coef = config [ [string] ] [EOL] self . value_function_coeff = config [ [string] ] [EOL] self . max_grad_norm = config [ [string] ] [EOL] self . learning_rate = config [ [string] ] [EOL] self . epsilon = config [ [string] ] [EOL] [EOL] [comment] [EOL] self . conv1 = tf . keras . layers . Conv2D ( filters = [number] , kernel_size = [ [number] , [number] ] , strides = ( [number] , [number] ) , padding = [string] , activation = [string] , name = [string] , trainable = is_training , dtype = [string] ) [EOL] [EOL] self . maxPool1 = tf . keras . layers . MaxPooling2D ( pool_size = ( [number] , [number] ) , name = [string] ) [EOL] [EOL] [comment] [EOL] self . conv2 = tf . keras . layers . Conv2D ( filters = [number] , kernel_size = [ [number] , [number] ] , strides = ( [number] , [number] ) , padding = [string] , activation = [string] , name = [string] , trainable = is_training , dtype = [string] ) [EOL] [EOL] self . maxPool2 = tf . keras . layers . MaxPooling2D ( pool_size = ( [number] , [number] ) , name = [string] , trainable = is_training ) [EOL] [EOL] [comment] [EOL] self . conv3 = tf . keras . layers . Conv2D ( filters = [number] , kernel_size = [ [number] , [number] ] , strides = ( [number] , [number] ) , padding = [string] , activation = [string] , name = [string] , trainable = is_training , dtype = [string] ) [EOL] [EOL] [comment] [EOL] self . conv4 = tf . keras . layers . Conv2D ( filters = [number] , kernel_size = [ [number] , [number] ] , strides = ( [number] , [number] ) , padding = [string] , activation = [string] , name = [string] , trainable = is_training , dtype = [string] ) [EOL] [EOL] self . maxPool3 = tf . keras . layers . MaxPooling2D ( pool_size = ( [number] , [number] ) , name = [string] , trainable = is_training ) [EOL] self . flattened = tf . keras . layers . Flatten ( name = [string] , trainable = is_training ) [EOL] self . hiddenLayer1 = tf . keras . layers . Dense ( [number] , activation = [string] , kernel_initializer = tf . keras . initializers . Orthogonal ( np . sqrt ( [number] ) ) , name = [string] , trainable = is_training , dtype = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] self . _value = tf . keras . layers . Dense ( [number] , kernel_initializer = tf . keras . initializers . orthogonal ( np . sqrt ( [number] ) ) , activation = [string] , name = [string] , use_bias = True , trainable = is_training ) [EOL] [EOL] self . _policy = tf . keras . layers . Dense ( self . num_actions , activation = [string] , kernel_initializer = tf . keras . initializers . orthogonal ( [number] ) , use_bias = True , name = [string] , trainable = is_training ) [EOL] [EOL] [EOL] def call ( self , input_image , keep_p = [number] ) : [EOL] [EOL] [comment] [EOL] conv1_out = self . conv1 ( input_image ) [EOL] maxpool1_out = self . maxPool1 ( conv1_out ) [EOL] [comment] [EOL] conv2_out = self . conv2 ( maxpool1_out ) [EOL] maxpool2_out = self . maxPool2 ( conv2_out ) [EOL] [comment] [EOL] conv3_out = self . conv3 ( maxpool2_out ) [EOL] maxpool3_out = self . maxPool3 ( conv3_out ) [EOL] [EOL] conv4_out = self . conv4 ( maxpool3_out ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] flattened_out = self . flattened ( conv4_out ) [EOL] [comment] [EOL] hidden_out1 = self . hiddenLayer1 ( flattened_out ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] value = self . _value ( hidden_out1 ) [EOL] logits = self . _policy ( hidden_out1 ) [EOL] action_dist = tf . nn . softmax ( logits ) [EOL] [EOL] return logits , action_dist , value [EOL] [EOL] [comment] [EOL] def step ( self , observation , keep_p = [number] ) : [EOL] logits , softmax , value = self . call ( observation , keep_p = keep_p ) [EOL] return logits . numpy ( ) , softmax . numpy ( ) , tf . squeeze ( value ) . numpy ( ) [EOL] [EOL] [comment] [EOL] def value_function ( self , observation , keep_p ) : [EOL] _ , _ , value = self . call ( observation , keep_p ) [EOL] return tf . squeeze ( value ) . numpy ( ) [EOL] [EOL] def save_model_weights ( self ) : [EOL] try : [EOL] model_save_path = [string] [EOL] self . save_weights ( model_save_path , save_format = [string] ) [EOL] except : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def load_model_weights ( self ) : [EOL] model_save_path = [string] [EOL] self . load_weights ( filepath = model_save_path ) [EOL] [EOL] [comment] [EOL] def logits_entropy ( self , logits ) : [EOL] a0 = logits - tf . reduce_max ( logits , [number] , keepdims = True ) [EOL] ea0 = tf . exp ( a0 ) [EOL] z0 = tf . reduce_sum ( ea0 , [number] , keepdims = True ) [EOL] p0 = ea0 / z0 [EOL] return tf . reduce_sum ( p0 * ( tf . math . log ( z0 ) - a0 ) , [number] ) [EOL] [EOL] [comment] [EOL] def softmax_entropy ( self , p0 ) : [EOL] return - tf . reduce_sum ( p0 * tf . math . log ( p0 + [number] ) , axis = [number] ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] from typing import Union , Any , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import numpy as np [EOL] import os [EOL] import cv2 [EOL] from collections import deque [EOL] [EOL] import gym [EOL] from gym . core import ObservationWrapper [EOL] from gym . spaces . box import Box [EOL] import tensorflow as tf [EOL] [EOL] [comment] [EOL] [EOL] class GrayScaleImage ( ObservationWrapper ) : [EOL] [EOL] def __init__ ( self , env , height = [number] , width = [number] , grayscale = True ) : [EOL] super ( GrayScaleImage , self ) . __init__ ( env ) [EOL] [EOL] self . img_size = ( height , width ) [EOL] self . grayscale = grayscale [EOL] n_channels = [number] if self . grayscale else [number] [EOL] self . observation_space = Box ( [number] , [number] , [ height , width , n_channels ] , dtype = [string] ) [EOL] [EOL] [comment] [EOL] def _displayImage ( self , img ) : [EOL] cv2 . imshow ( [string] , img ) [EOL] cv2 . waitKey ( [number] ) [EOL] cv2 . destroyAllWindows ( ) [EOL] [EOL] def observation ( self , img ) : [EOL] [comment] [EOL] if self . grayscale : [EOL] img = cv2 . cvtColor ( img , cv2 . COLOR_BGR2GRAY ) [EOL] [EOL] img = cv2 . resize ( img , self . img_size , interpolation = cv2 . INTER_AREA ) [EOL] [EOL] if self . grayscale : [EOL] img = img / [number] [EOL] else : [EOL] img = cv2 . normalize ( img , None , alpha = [number] , beta = [number] , norm_type = cv2 . NORM_MINMAX , dtype = cv2 . CV_64F ) [EOL] [EOL] if self . grayscale : [EOL] img = img [ : , : , np . newaxis ] [EOL] [EOL] return [ img ] [EOL] [EOL] [comment] [EOL] class FrameSkip ( gym . Wrapper ) : [EOL] [EOL] def __init__ ( self , env , skipped_frames ) : [EOL] super ( FrameSkip , self ) . __init__ ( env ) [EOL] self . n = skipped_frames [EOL] [EOL] def reset ( self ) : [EOL] return self . env . reset ( ) [EOL] [EOL] def step ( self , action ) : [EOL] done = False [EOL] total_reward = [number] [EOL] for _ in range ( self . n ) : [EOL] o , r , done , info = self . env . step ( action ) [EOL] total_reward += r [EOL] if done : break [EOL] return o , total_reward , done , info [EOL] [EOL] [comment] [EOL] class FrameStack ( ObservationWrapper ) : [EOL] def __init__ ( self , env , k ) : [EOL] [docstring] [EOL] super ( FrameStack , self ) . __init__ ( env ) [EOL] self . k = k [EOL] self . frames = deque ( [ ] , maxlen = k ) [EOL] ( height , width , n_channels ) = env . observation_space . shape [EOL] self . observation_space = Box ( [number] , [number] , ( height , width * k , n_channels ) , dtype = [string] ) [EOL] [EOL] [EOL] def reset ( self ) : [EOL] [docstring] [EOL] ob = self . env . reset ( ) [EOL] for _ in range ( self . k ) : self . frames . append ( ob ) [EOL] return self . observation ( ) [EOL] [EOL] [EOL] def step ( self , action ) : [EOL] ob , reward , done , info = self . env . step ( action ) [EOL] self . frames . append ( ob ) [EOL] return self . observation ( ) , reward , done , info [EOL] [EOL] def observation ( self ) : [EOL] assert len ( self . frames ) == self . k [EOL] return np . concatenate ( self . frames , axis = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Callable , Any [EOL] import typing [EOL] import numpy as np [EOL] from os . path import isfile , join [EOL] import cv2 [EOL] import time [EOL] import datetime [EOL] import glob [EOL] [EOL] [comment] [EOL] import gym [EOL] from gym . core import ObservationWrapper [EOL] from gym . spaces . box import Box [EOL] [EOL] [EOL] [EOL] class Monitor ( ObservationWrapper ) : [EOL] def __init__ ( self , env , env_shape , record = False , savePath = [string] , random_samples = False , save_images_to_disk = False ) : [EOL] super ( Monitor , self ) . __init__ ( env ) [EOL] ( HEIGHT , WIDTH , CHANNELS ) = env_shape [EOL] self . _height = HEIGHT [EOL] self . _width = WIDTH [EOL] self . _channels = CHANNELS [EOL] self . _record = record [EOL] self . _savePath = savePath [EOL] self . _is_running = False [EOL] self . _session_video = None [EOL] self . _timestamp = None [EOL] [EOL] def step ( self , action ) : [EOL] observation , reward , done , info = self . env . step ( action ) [EOL] [EOL] if self . _record : [EOL] return self . observation ( observation ) , reward , done , info [EOL] else : [EOL] return observation , reward , done , info [EOL] [EOL] def reset ( self , ** kwargs ) : [EOL] if self . _session_video : [EOL] self . _session_video . release ( ) [EOL] [EOL] [comment] [EOL] current_milli_time = lambda : int ( round ( time . time ( ) * [number] ) ) [EOL] [EOL] self . _session_video = cv2 . VideoWriter ( self . _savePath + [string] + str ( current_milli_time ( ) ) + [string] , apiPreference = [number] , fourcc = cv2 . VideoWriter_fourcc ( * [string] ) , fps = [number] , frameSize = ( self . _width , self . _height ) ) [EOL] [EOL] observation = self . env . reset ( ** kwargs ) [EOL] self . _is_running = False [EOL] [EOL] return self . observation ( observation ) [EOL] [EOL] def observation ( self , observation ) : [EOL] if not self . _is_running : [EOL] self . _is_running = True [EOL] [EOL] try : [EOL] self . _session_video . write ( observation ) [EOL] except : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] return observation [EOL] [EOL] def _displayImage ( self , img ) : [EOL] cv2 . imshow ( [string] , img ) [EOL] cv2 . waitKey ( [number] ) [EOL] cv2 . destroyAllWindows ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , List [EOL] import typing [EOL] import gym [EOL] from gym . core import Wrapper [EOL] import numpy as np [EOL] [EOL] [comment] [EOL] class Normalize ( Wrapper ) : [EOL] def __init__ ( self , env ) : [EOL] super ( Normalize , self ) . __init__ ( env ) [EOL] [EOL] def reset ( self , ** kwargs ) : [EOL] observation = self . env . reset ( ** kwargs ) [EOL] return self . observation ( observation ) [EOL] [EOL] def step ( self , action ) : [EOL] observation , reward , done , info = self . env . step ( action ) [EOL] [EOL] return self . observation ( observation ) , self . reward ( reward ) , done , info [EOL] [EOL] [comment] [EOL] def reward ( self , reward ) : [EOL] return reward [EOL] [EOL] def observation ( self , observation ) : [EOL] return observation [EOL] [EOL] [comment] [EOL] class MsPacmanWrapper ( Wrapper ) : [EOL] [EOL] def __init__ ( self , env ) : [EOL] super ( MsPacmanWrapper , self ) . __init__ ( env ) [EOL] self . num_lives = [number] [EOL] self . _reversed = False [EOL] self . _action_desc = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } [EOL] self . _actions = [ [number] , [number] , [number] , [number] , [number] ] [EOL] self . _last_action = None [EOL] self . action_space = gym . spaces . Discrete ( len ( self . _actions ) ) [EOL] [EOL] def reversed ( self ) : [EOL] return self . _reversed [EOL] [EOL] def reset ( self , ** kwargs ) : [EOL] observation = self . env . reset ( ** kwargs ) [EOL] return self . observation ( observation ) [EOL] [EOL] def step ( self , action ) : [EOL] observation , reward , done , info = self . env . step ( action ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] step = [number] [EOL] reverse = [number] [EOL] life_loss = [number] [EOL] death = [number] [EOL] [EOL] [comment] [EOL] if self . _reversed != None : [EOL] a = action [EOL] if self . _last_action == [number] : [EOL] if a == [number] : [EOL] self . _reversed == True [EOL] else : [EOL] self . _reversed = False [EOL] elif self . _last_action == [number] : [EOL] if a == [number] : [EOL] self . _reversed == True [EOL] else : [EOL] self . _reversed = False [EOL] elif self . _last_action == [number] : [EOL] if a == [number] : [EOL] self . _reversed == True [EOL] else : [EOL] self . _reversed = False [EOL] elif self . _last_action == [number] : [EOL] if a == [number] : [EOL] self . _reversed == True [EOL] else : [EOL] self . _reversed = False [EOL] else : [EOL] self . _reversed = False [EOL] self . _last_action = a [EOL] [EOL] [comment] [EOL] rewards = [number] [EOL] rewards += step [EOL] [EOL] [comment] [EOL] rewards += ( reward // [number] ) * [number] [EOL] reward = ( reward % [number] ) [EOL] [EOL] [comment] [EOL] rewards += ( reward // [number] ) * [number] [EOL] reward = ( reward % [number] ) [EOL] [EOL] [comment] [EOL] rewards += ( reward // [number] ) * [number] [EOL] reward = ( reward % [number] ) [EOL] [EOL] [comment] [EOL] rewards += ( reward // [number] ) [EOL] reward = reward % [number] [EOL] [EOL] [comment] [EOL] if self . _reversed : [EOL] rewards += reverse [EOL] [EOL] [comment] [EOL] if info [ [string] ] < self . num_lives : [EOL] self . num_lives = info [ [string] ] [EOL] rewards += life_loss [EOL] [EOL] [comment] [EOL] if (done) : [EOL] rewards += death [EOL] [EOL] [comment] [EOL] rewards = np . clip ( rewards , - [number] , [number] ) [EOL] [EOL] return self . observation ( observation ) , self . reward ( rewards ) , done , info [EOL] [EOL] [comment] [EOL] def reward ( self , reward ) : [EOL] [EOL] return reward [EOL] [EOL] def observation ( self , observation ) : [EOL] return observation	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] [EOL] from numpy import arange , array , ones [EOL] import scipy [EOL] from scipy . optimize import curve_fit [EOL] from scipy import stats [EOL] from heapq import * [EOL] [EOL] [EOL] [comment] [EOL] line_types = [ [string] , [string] ] [EOL] line_type = line_types [ [number] ] [EOL] dimensions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] dimension = dimensions [ [number] ] [EOL] [EOL] [comment] [EOL] heap = [ ] [EOL] runtime , x , y = np . loadtxt ( dimension + [string] , delimiter = [string] , unpack = True ) [EOL] for i in range ( len ( runtime ) ) : [EOL] data = abs ( y [ i ] ) [EOL] time = runtime [ i ] [EOL] item = ( time , data ) [EOL] heappush ( heap , item ) [EOL] [EOL] sorted_x = [ ] [EOL] sorted_y = [ ] [EOL] counter = [number] [EOL] [EOL] while heap : [EOL] ( x_i , y_i ) = heappop ( heap ) [EOL] sorted_x . append ( counter ) [EOL] sorted_y . append ( y_i ) [EOL] counter += [number] [EOL] [EOL] sorted_x = np . array ( sorted_x , dtype = int ) [EOL] [EOL] if line_type == [string] : [EOL] [EOL] [comment] [EOL] slope , intercept , r_value , p_value , std_err = stats . linregress ( sorted_x , sorted_y ) [EOL] line = slope * sorted_x + intercept [EOL] plt . plot ( sorted_x , sorted_y , label = [string] + str ( slope ) ) [EOL] [EOL] [comment] [EOL] [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( dimension ) [EOL] plt . title ( [string] ) [EOL] plt . legend ( ) [EOL] plt . show ( ) [EOL] [EOL] elif line_type == [string] : [EOL] [comment] [EOL] [ [ offset , scale ] , _ ] = scipy . optimize . curve_fit ( lambda t , a , b : a + b * np . log ( t ) , x , y ) [EOL] [EOL] line = scale * np . log ( x ) + offset [EOL] [EOL] plt . plot ( sorted_x , sorted_y , label = [string] + str ( scale ) + [string] + [string] + str ( offset ) ) [EOL] [EOL] plt . plot ( sorted_x , sorted_y , [string] , sorted_x , line ) [EOL] plt . plot ( sorted_x , sorted_y , [string] ) [EOL] [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( dimension ) [EOL] plt . title ( [string] ) [EOL] plt . legend ( ) [EOL] plt . show ( ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0