	0
from typing import List , Optional [EOL] import typing [EOL] import builtins [EOL] from typing import List , Optional [EOL] import random [EOL] [EOL] [EOL] def get_random_key ( keys ) : [EOL] if not keys : [EOL] return None [EOL] [EOL] return random . choice ( keys ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] from rectifier import settings [EOL] from healthcheck import HealthCheck [EOL] from redis . exceptions import ConnectionError , TimeoutError [EOL] [EOL] [EOL] class HealthChecker : [EOL] [docstring] [EOL] def __init__ ( self , redis_storage ) : [EOL] self . _redis_store = redis_storage [EOL] self . _health_check = HealthCheck ( failed_status = settings . HEALTH_CHECKER_FAILED_STATUS ) [EOL] [EOL] self . _health_check . add_section ( [string] , os . environ . get ( [string] , None ) ) [EOL] self . _health_check . add_section ( [string] , { [string] : os . environ . get ( [string] , None ) } ) [EOL] self . _health_check . add_check ( self . _redis_available ) [EOL] [EOL] def _redis_available ( self ) : [EOL] try : [EOL] info = self . _redis_store . redis . info ( ) [EOL] except ConnectionError : [EOL] return False , [string] [EOL] except TimeoutError : [EOL] return False , [string] [EOL] return True , info [EOL] [EOL] def run ( self ) : [EOL] return self . _health_check . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Optional , Any [EOL] import typing [EOL] import rectifier [EOL] from typing import Optional [EOL] [EOL] import structlog [EOL] [EOL] from rectifier import settings [EOL] from rectifier . config import ConfigParser , AppMode [EOL] from rectifier . consumer_updates_coordinator import ConsumerUpdatesCoordinator [EOL] from rectifier . infrastructure_provider import ( InfrastructureProvider , InfrastructureProviderError , ) [EOL] from rectifier . message_brokers import Broker [EOL] from rectifier . message_brokers . rabbitmq import BrokerError [EOL] from rectifier . storage import Storage [EOL] [EOL] LOGGER = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] class Rectifier : [EOL] [docstring] [EOL] [EOL] broker = ... [EOL] consumer_updates_coordinator = ... [EOL] infrastructure_provider = ... [EOL] [EOL] def __init__ ( self , storage , broker , infrastructure_provider , ) : [EOL] self . storage = storage [EOL] self . broker = broker [EOL] self . infrastructure_provider = infrastructure_provider [EOL] [EOL] self . subscription = self . storage . subscribe ( settings . REDIS_CONFIG_KEY ) [EOL] [EOL] self . update_configuration ( ) [EOL] [EOL] def update_configuration ( self ) : [EOL] [docstring] [EOL] config_reader = ConfigParser ( storage = self . storage ) [EOL] [EOL] if not config_reader . config : [EOL] self . consumer_updates_coordinator = None [EOL] return [EOL] [EOL] self . consumer_updates_coordinator = ConsumerUpdatesCoordinator ( config = config_reader . config . coordinator_config , storage = self . storage ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] message = self . subscription . get_message ( ) [EOL] if message : [EOL] LOGGER . info ( [string] ) [EOL] self . update_configuration ( ) [EOL] [EOL] self . scale ( ) [EOL] [EOL] def scale ( self ) : [EOL] [docstring] [EOL] if not self . consumer_updates_coordinator : [EOL] return [EOL] [EOL] for ( app , app_config ) in self . consumer_updates_coordinator . config . apps . items ( ) : [EOL] if app_config . mode == AppMode . NOOP : [EOL] continue [EOL] [EOL] queues_config = app_config . queues [EOL] [EOL] try : [EOL] broker_uri = self . infrastructure_provider . broker_uri ( app ) [EOL] except InfrastructureProviderError : [EOL] return [EOL] [EOL] if not broker_uri : [EOL] LOGGER . warning ( [string] , app = app ) [EOL] continue [EOL] [EOL] try : [EOL] stats = self . broker . stats ( broker_uri ) [EOL] queues = self . broker . queues ( queues_config . keys ( ) , stats ) [EOL] except BrokerError : [EOL] return [EOL] [EOL] updates = dict ( ) [EOL] for queue in queues : [EOL] ( new_consumer_count , consumer_formation , ) = self . consumer_updates_coordinator . compute_consumers_count ( app , app_config . mode , queue ) [EOL] [EOL] if new_consumer_count is None : [EOL] continue [EOL] [EOL] updates [ consumer_formation ] = new_consumer_count [EOL] [EOL] if not updates : [EOL] continue [EOL] [EOL] try : [EOL] self . infrastructure_provider . scale ( app , updates ) [EOL] except InfrastructureProviderError : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rectifier.message_brokers.Broker$ 0 0 0 $typing.Optional[rectifier.consumer_updates_coordinator.ConsumerUpdatesCoordinator]$ 0 0 0 $rectifier.infrastructure_provider.InfrastructureProvider$ 0 0 0 0 0 $None$ 0 0 0 $rectifier.storage.storage.Storage$ 0 $rectifier.message_brokers.broker.Broker$ 0 $rectifier.infrastructure_provider.infrastructure_provider.InfrastructureProvider$ 0 0 0 0 0 0 $rectifier.storage.storage.Storage$ 0 $rectifier.storage.storage.Storage$ 0 0 0 $rectifier.message_brokers.broker.Broker$ 0 $rectifier.message_brokers.broker.Broker$ 0 0 0 $rectifier.infrastructure_provider.infrastructure_provider.InfrastructureProvider$ 0 $rectifier.infrastructure_provider.infrastructure_provider.InfrastructureProvider$ 0 0 0 0 0 0 0 0 $rectifier.storage.storage.Storage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $rectifier.config.config_parser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rectifier.config.config_parser.ConfigParser$ 0 0 0 0 0 0 $typing.Optional[rectifier.consumer_updates_coordinator.consumer_updates_coordinator.ConsumerUpdatesCoordinator]$ 0 0 0 0 0 0 0 0 $typing.Optional[rectifier.consumer_updates_coordinator.consumer_updates_coordinator.ConsumerUpdatesCoordinator]$ 0 0 0 0 0 $rectifier.config.config_parser.ConfigParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rectifier.queue.queue.Queue]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.List[rectifier.queue.queue.Queue]$ 0 0 0 0 0 $typing.List[rectifier.queue.queue.Queue]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[rectifier.queue.queue.Queue]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import redis [EOL] import typing [EOL] import rectifier [EOL] import builtins [EOL] from typing import Optional , Any [EOL] [EOL] import redis [EOL] from redis . client import PubSub [EOL] [EOL] from rectifier . storage . storage import Storage , StorageSubscription [EOL] from rectifier import settings [EOL] [EOL] [EOL] class RedisSubscription ( StorageSubscription ) : [EOL] def __init__ ( self , pubsub ) : [EOL] self . pubsub = pubsub [EOL] [EOL] def get_message ( self ) : [EOL] return self . pubsub . get_message ( ) [EOL] [EOL] [EOL] class RedisStorage ( Storage ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . redis = redis . StrictRedis . from_url ( settings . REDIS_URL ) [EOL] [EOL] def set ( self , key , value ) : [EOL] return self . redis . set ( key , value ) [EOL] [EOL] def get ( self , key ) : [EOL] return self . redis . get ( key ) [EOL] [EOL] def subscribe ( self , channel ) : [EOL] pubsub = self . redis . pubsub ( ) [EOL] pubsub . subscribe ( channel ) [EOL] return RedisSubscription ( pubsub ) [EOL] [EOL] def publish ( self , channel , message = None ) : [EOL] return self . redis . publish ( channel , message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $rectifier.storage.storage.StorageSubscription$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Any]$ 0 0
from typing import Optional , Any [EOL] import typing [EOL] import builtins [EOL] from abc import ABC , abstractmethod [EOL] from typing import Optional , Any [EOL] [EOL] [EOL] class StorageSubscription ( ABC ) : [EOL] @ abstractmethod def get_message ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Storage ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def get ( self , key ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def set ( self , key , value ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def publish ( self , channel , message = None ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def subscribe ( self , channel ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $StorageSubscription$ 0 0 0 $builtins.str$ 0 0 0 0 0
from . redis_storage import RedisStorage , RedisSubscription [EOL] from . storage import Storage , StorageSubscription [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . consumer_updates_coordinator import ConsumerUpdatesCoordinator [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import List , Literal , Any , Dict , Type , Tuple , Union [EOL] import requests [EOL] import typing [EOL] import rectifier [EOL] import typing_extensions [EOL] import json [EOL] import builtins [EOL] import json [EOL] from typing import Dict , List [EOL] [EOL] import jsonschema as jsonschema [EOL] import requests [EOL] import structlog [EOL] import pika [EOL] [EOL] import schemas [EOL] from rectifier import settings [EOL] from rectifier . queue import Queue [EOL] from . broker import Broker [EOL] [EOL] LOGGER = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] class BrokerError ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class RabbitMQ ( Broker ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def stats ( uri ) : [EOL] [docstring] [EOL] [EOL] url_params = pika . URLParameters ( uri ) [EOL] [EOL] host = url_params . host [EOL] if url_params . port and url_params . port != url_params . DEFAULT_PORT : [EOL] host = [string] % ( host , url_params . port ) [EOL] user = url_params . credentials . username [EOL] password = url_params . credentials . password [EOL] vhost = url_params . virtual_host [EOL] [EOL] protocol = [string] if settings . RABBIT_MQ_SECURE else [string] [EOL] url = [string] % ( protocol , host , vhost ) [EOL] [EOL] auth = requests . auth . HTTPBasicAuth ( user , password ) [EOL] [EOL] errors = ( requests . exceptions . RequestException , requests . exceptions . HTTPError , EOFError , MemoryError , OSError , UnicodeError , IOError , EnvironmentError , TypeError , ValueError , OverflowError , json . JSONDecodeError , ) [EOL] [EOL] LOGGER . debug ( [string] , url = url ) [EOL] [EOL] try : [EOL] response = requests . get ( url , auth = auth ) [EOL] response . raise_for_status ( ) [EOL] except errors as err : [EOL] message = [string] [EOL] LOGGER . error ( message , url = url , err = err ) [EOL] raise BrokerError ( message ) from err [EOL] [EOL] try : [EOL] data = response . json ( ) [EOL] except errors as err : [EOL] message = [string] [EOL] LOGGER . error ( message , url = url , err = err , response = response . content ) [EOL] raise BrokerError ( message ) from err [EOL] [EOL] try : [EOL] jsonschema . validate ( data , schemas . RabbitMQ . SCHEMA ) [EOL] except jsonschema . ValidationError as err : [EOL] message = [string] [EOL] LOGGER . error ( message , url = url , err = err , data = data ) [EOL] raise BrokerError ( message ) from err [EOL] [EOL] return data [EOL] [EOL] @ classmethod def queues ( cls , interest_queues , stats ) : [EOL] multiple_queues_config = cls . _multiple_queue_configs ( interest_queues ) [EOL] single_queue_configs = cls . _single_queue_configs ( interest_queues ) [EOL] [EOL] queues = [ ] [EOL] for queue_name in single_queue_configs : [EOL] queue = cls . _handle_single_queue_config ( stats , queue_name ) [EOL] if queue : [EOL] queues . append ( queue ) [EOL] [EOL] for queue_names in multiple_queues_config : [EOL] queue = cls . _handle_multiple_queues_config ( stats , queue_names ) [EOL] if queue : [EOL] queues . append ( queue ) [EOL] [EOL] return queues [EOL] [EOL] @ classmethod def _handle_single_queue_config ( cls , stats , queue_name ) : [EOL] queue_list = cls . _filter_stats ( stats , [ queue_name ] ) [EOL] [EOL] if len ( queue_list ) != [number] : [EOL] message = [string] [EOL] LOGGER . error ( message , response = stats , queue_name = queue_name ) [EOL] return [EOL] [EOL] queue = queue_list [ [number] ] [EOL] return Queue ( queue_name = queue_name , consumers_count = queue . get ( [string] ) , messages = queue . get ( [string] ) , ) [EOL] [EOL] @ classmethod def _handle_multiple_queues_config ( cls , stats , raw_queue_names ) : [EOL] queue_names = list ( map ( str . strip , raw_queue_names . split ( [string] ) ) ) [EOL] queue_list = cls . _filter_stats ( stats , queue_names ) [EOL] [EOL] if len ( queue_list ) != len ( queue_names ) : [EOL] message = [string] [EOL] LOGGER . error ( message , response = stats , queue_names = queue_names ) [EOL] return [EOL] [EOL] expected_consumers_count = queue_list [ [number] ] . get ( [string] ) [EOL] if not all ( queue . get ( [string] ) == expected_consumers_count for queue in queue_list [ [number] : ] ) : [EOL] message = [string] [EOL] LOGGER . error ( message , response = stats , queue_names = queue_list ) [EOL] return [EOL] [EOL] return Queue ( queue_name = [string] . join ( queue_names ) , consumers_count = queue_list [ [number] ] . get ( [string] ) , messages = sum ( q . get ( [string] ) for q in queue_list ) , ) [EOL] [EOL] @ staticmethod def _single_queue_configs ( interest_queues ) : [EOL] return [ interest_queue for interest_queue in interest_queues if [string] not in interest_queue ] [EOL] [EOL] @ staticmethod def _multiple_queue_configs ( interest_queues ) : [EOL] return [ interest_queue for interest_queue in interest_queues if [string] in interest_queue ] [EOL] [EOL] @ staticmethod def _filter_stats ( stats , queue_names ) : [EOL] return list ( filter ( lambda queue_stats : queue_stats [ [string] ] in queue_names , stats ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $builtins.str$ 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 0 0 $requests.auth.HTTPBasicAuth$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[requests.exceptions.RequestException],typing.Type[requests.exceptions.HTTPError],typing.Type[builtins.EOFError],typing.Type[builtins.MemoryError],typing.Type[builtins.OSError],typing.Type[builtins.UnicodeError],typing.Type[builtins.OSError],typing.Type[builtins.OSError],typing.Type[builtins.TypeError],typing.Type[builtins.ValueError],typing.Type[builtins.OverflowError],typing.Type[json.decoder.JSONDecodeError]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $requests.auth.HTTPBasicAuth$ 0 $requests.auth.HTTPBasicAuth$ 0 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Tuple[typing.Type[requests.exceptions.RequestException],typing.Type[requests.exceptions.HTTPError],typing.Type[builtins.EOFError],typing.Type[builtins.MemoryError],typing.Type[builtins.OSError],typing.Type[builtins.UnicodeError],typing.Type[builtins.OSError],typing.Type[builtins.OSError],typing.Type[builtins.TypeError],typing.Type[builtins.ValueError],typing.Type[builtins.OverflowError],typing.Type[json.decoder.JSONDecodeError]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Tuple[typing.Type[requests.exceptions.RequestException],typing.Type[requests.exceptions.HTTPError],typing.Type[builtins.EOFError],typing.Type[builtins.MemoryError],typing.Type[builtins.OSError],typing.Type[builtins.UnicodeError],typing.Type[builtins.OSError],typing.Type[builtins.OSError],typing.Type[builtins.TypeError],typing.Type[builtins.ValueError],typing.Type[builtins.OverflowError],typing.Type[json.decoder.JSONDecodeError]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $requests.models.Response$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[rectifier.queue.Queue]$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.Dict$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Dict$ 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import rectifier [EOL] import builtins [EOL] from abc import ABC , abstractmethod [EOL] from typing import List , Dict [EOL] [EOL] from rectifier . queue import Queue [EOL] [EOL] [EOL] class Broker ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod @ abstractmethod def stats ( uri ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod @ abstractmethod def queues ( interest_queues , stats ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rectifier.queue.Queue]$ 0 $typing.List[builtins.str]$ 0 $typing.Dict$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . rabbitmq import RabbitMQ [EOL] from . broker import Broker [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . infrastructure_provider import InfrastructureProvider , InfrastructureProviderError [EOL] from . heroku import Heroku [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any [EOL] import heroku3 [EOL] import typing [EOL] import builtins [EOL] from typing import Dict [EOL] [EOL] import structlog [EOL] import heroku3 [EOL] [EOL] from heroku3 . models . app import App as HerokuApp [EOL] from requests import HTTPError [EOL] [EOL] from rectifier . infrastructure_provider import ( InfrastructureProvider , InfrastructureProviderError , ) [EOL] [EOL] from rectifier import settings [EOL] from rectifier . get_random_key import get_random_key [EOL] [EOL] LOGGER = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] class Heroku ( InfrastructureProvider ) : [EOL] [docstring] [EOL] [EOL] def scale ( self , app_name , scale_requests ) : [EOL] [docstring] [EOL] [EOL] LOGGER . info ( f" [string] { app_name } [string] { scale_requests }" ) [EOL] [EOL] if settings . DRY_RUN : [EOL] LOGGER . debug ( [string] ) [EOL] return [EOL] [EOL] try : [EOL] app = self . _connection ( app_name ) [EOL] app . batch_scale_formation_processes ( scale_requests ) [EOL] except HTTPError as e : [EOL] message = [string] [EOL] LOGGER . error ( message , error = e ) [EOL] raise InfrastructureProviderError ( message ) [EOL] [EOL] def broker_uri ( self , app_name ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] app = self . _connection ( app_name ) [EOL] return app . config ( ) [ settings . BROKER_URL_KEY ] [EOL] except HTTPError as e : [EOL] message = [string] [EOL] LOGGER . error ( message , error = e ) [EOL] raise InfrastructureProviderError ( message ) [EOL] [EOL] @ staticmethod def _connection ( app_name ) : [EOL] [docstring] [EOL] key = get_random_key ( settings . HEROKU_API_KEYS ) [EOL] if not key : [EOL] message = [string] [EOL] LOGGER . error ( [string] ) [EOL] raise InfrastructureProviderError ( message ) [EOL] [EOL] conn = heroku3 . from_key ( get_random_key ( settings . HEROKU_API_KEYS ) ) [EOL] apps = conn . apps ( ) [EOL] [EOL] if app_name not in apps : [EOL] message = [string] [EOL] LOGGER . error ( message , app = app_name , apps = apps ) [EOL] raise InfrastructureProviderError ( message ) [EOL] [EOL] return apps [ app_name ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $heroku3.models.app.App$ 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] from abc import ABC , abstractmethod [EOL] from typing import Dict [EOL] [EOL] [EOL] class InfrastructureProviderError ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InfrastructureProvider ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def scale ( self , app_name , scale_requests ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def broker_uri ( self , app_name ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from dataclasses import dataclass [EOL] from enum import Enum [EOL] from typing import List , Dict [EOL] [EOL] [EOL] @ dataclass class QueueConfig : [EOL] [docstring] [EOL] [EOL] intervals = ... [EOL] workers = ... [EOL] cooldown = ... [EOL] queue_name = ... [EOL] consumers_formation_name = ... [EOL] [EOL] [EOL] class AppMode ( Enum ) : [EOL] SCALE = [string] [EOL] NOOP = [string] [EOL] KILL = [string] [EOL] [EOL] [EOL] @ dataclass class AppConfig : [EOL] [docstring] [EOL] [EOL] queues = ... [EOL] mode = ... [EOL] [EOL] [EOL] @ dataclass class CoordinatorConfig : [EOL] [docstring] [EOL] [EOL] apps = ... [EOL] [EOL] [EOL] @ dataclass class Config : [EOL] [docstring] [EOL] [EOL] coordinator_config = ... [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,QueueConfig]$ 0 0 0 $AppMode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,AppConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $CoordinatorConfig$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . config import AppConfig , CoordinatorConfig , QueueConfig , Config , AppMode [EOL] from . config_parser import ConfigParser , ConfigReadError [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Any [EOL] import typing [EOL] import rectifier [EOL] import json [EOL] from json import JSONDecodeError [EOL] from typing import Dict [EOL] [EOL] import jsonschema [EOL] import structlog [EOL] [EOL] import schemas [EOL] from rectifier . config import Config , AppConfig , QueueConfig , CoordinatorConfig , AppMode [EOL] from rectifier . storage . storage import Storage [EOL] from rectifier import settings [EOL] [EOL] LOGGER = structlog . get_logger ( __name__ ) [EOL] [EOL] [EOL] class ConfigReadError ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class ConfigParser : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , storage ) : [EOL] [docstring] [EOL] [EOL] storage_config = storage . get ( settings . REDIS_CONFIG_KEY ) [EOL] config_dict = None [EOL] [EOL] if storage_config is None : [EOL] LOGGER . info ( [string] ) [EOL] else : [EOL] try : [EOL] config_dict = json . loads ( storage_config ) [EOL] except ( JSONDecodeError , TypeError ) : [EOL] LOGGER . info ( [string] , config = storage_config ) [EOL] [EOL] self . raw_config = config_dict [EOL] self . config = ConfigParser . from_dict ( config_dict ) if config_dict else None [EOL] LOGGER . info ( [string] , config = self . config ) [EOL] [EOL] @ classmethod def from_dict ( cls , data ) : [EOL] [docstring] [EOL] cls . validate ( data ) [EOL] [EOL] apps = dict ( ) [EOL] for ( app , config ) in data . items ( ) : [EOL] queues = dict ( ) [EOL] [EOL] mode = AppMode ( config . get ( [string] , AppMode . SCALE . value ) ) [EOL] for ( queue_name , queue_properties ) in cls . _queue_configs ( config ) : [EOL] queues [ queue_name ] = QueueConfig ( queue_name = queue_name , ** queue_properties ) [EOL] [EOL] apps [ app ] = AppConfig ( queues = queues , mode = mode ) [EOL] [EOL] return Config ( coordinator_config = CoordinatorConfig ( apps = apps ) ) [EOL] [EOL] @ classmethod def validate ( cls , data ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] jsonschema . validate ( data , schemas . Config . SCHEMA ) [EOL] except jsonschema . ValidationError as err : [EOL] message = [string] [EOL] LOGGER . error ( message , config = data , err = err ) [EOL] raise ConfigReadError ( message ) from err [EOL] [EOL] for ( app , config ) in data . items ( ) : [EOL] app_mode = config . get ( [string] , AppMode . SCALE . value ) [EOL] try : [EOL] AppMode ( app_mode ) [EOL] except ValueError as err : [EOL] message = f' [string] { app_mode } [string] { [ mode . value for mode in AppMode ] }' [EOL] raise ConfigReadError ( message ) from err [EOL] [EOL] for ( queue_name , queue_properties ) in cls . _queue_configs ( config ) : [EOL] intervals = queue_properties [ [string] ] [EOL] workers = queue_properties [ [string] ] [EOL] cooldown = queue_properties [ [string] ] [EOL] [EOL] if len ( intervals ) != len ( workers ) : [EOL] message = [string] [EOL] LOGGER . error ( message , queue_name = queue_name ) [EOL] raise ConfigReadError ( message ) [EOL] [EOL] if intervals [ [number] ] != [number] : [EOL] message = [string] [EOL] LOGGER . error ( message , intervals = intervals , queue_name = queue_name ) [EOL] raise ConfigReadError ( message ) [EOL] [EOL] if any ( [ interval < [number] for interval in intervals ] ) : [EOL] message = ( [string] ) [EOL] LOGGER . error ( message , intervals = intervals , queue_name = queue_name ) [EOL] raise ConfigReadError ( message ) [EOL] [EOL] if any ( [ worker < [number] for worker in workers ] ) : [EOL] message = ( [string] ) [EOL] LOGGER . error ( message , workers = workers , queue_name = queue_name ) [EOL] raise ConfigReadError ( message ) [EOL] [EOL] if cooldown < [number] : [EOL] message = [string] [EOL] LOGGER . error ( message , cooldown = cooldown , queue_name = queue_name ) [EOL] raise ConfigReadError ( message ) [EOL] [EOL] if sorted ( intervals ) != intervals : [EOL] message = [string] [EOL] LOGGER . error ( message , intervals = intervals , queue_name = queue_name ) [EOL] raise ConfigReadError ( message ) [EOL] [EOL] @ staticmethod def _queue_configs ( app_config ) : [EOL] return ( ( k , v ) for ( k , v ) in app_config . items ( ) if k != [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rectifier.config.Config$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $rectifier.config.config.AppMode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $rectifier.config.config.AppMode$ 0 $rectifier.config.config.AppMode$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0
from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass class Queue : [EOL] queue_name = ... [EOL] consumers_count = ... [EOL] messages = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
from typing import List [EOL] import typing [EOL] from . queue import Queue [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import rectifier [EOL] import tests [EOL] import unittest [EOL] import builtins [EOL] import pytest [EOL] import pickle [EOL] [EOL] from collections import defaultdict [EOL] from typing import Dict [EOL] from unittest . mock import MagicMock [EOL] [EOL] from freezegun import freeze_time [EOL] [EOL] from rectifier import settings [EOL] from rectifier . config import AppMode [EOL] from rectifier . infrastructure_provider import InfrastructureProvider [EOL] from rectifier . message_brokers import RabbitMQ [EOL] from rectifier . rectifier import Rectifier [EOL] from tests . redis_mock import RedisStorageMock [EOL] [EOL] from . env import env [comment] [EOL] [EOL] [EOL] class InfrastructureProviderMock ( InfrastructureProvider ) : [EOL] def __init__ ( self , env ) : [EOL] self . consumers = defaultdict ( lambda : defaultdict ( int ) ) [EOL] self . called_count = [number] [EOL] self . env = env [EOL] [EOL] def scale ( self , app_name , updates ) : [EOL] for queue_name , consumers_count in updates . items ( ) : [EOL] self . consumers [ app_name ] [ queue_name ] = consumers_count [EOL] [EOL] self . called_count += [number] [EOL] [EOL] def broker_uri ( self , app_name ) : [EOL] return self . env . rabbit_mq_uri ( app_name ) [EOL] [EOL] [EOL] def test_monitor ( env ) : [EOL] storage = RedisStorageMock ( ) [EOL] infrastructure_provider = InfrastructureProviderMock ( env ) [EOL] [EOL] storage . set ( settings . REDIS_CONFIG_KEY , [string] [string] , ) [EOL] rectifier = Rectifier ( broker = RabbitMQ ( ) , storage = storage , infrastructure_provider = infrastructure_provider , ) [EOL] [EOL] with freeze_time ( [string] ) as frozen_time : [EOL] env . rabbitmq . set_queue ( [string] , [string] ) [EOL] env . rabbitmq . set_queue ( [string] , [string] ) [EOL] rectifier . run ( ) [EOL] [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] [comment] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] frozen_time . move_to ( [string] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] [comment] [EOL] frozen_time . move_to ( [string] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] [comment] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] frozen_time . move_to ( [string] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] [comment] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] frozen_time . move_to ( [string] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] [comment] [EOL] [comment] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] [comment] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] [comment] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] frozen_time . move_to ( [string] ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] frozen_time . move_to ( [string] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] frozen_time . move_to ( [string] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( AppMode . SCALE . value , [number] , [number] ) , ( AppMode . KILL . value , [number] , [number] ) , ( AppMode . NOOP . value , [number] , [number] ) , ] , ) def test_monitor_paused ( env , mode , expected_called_count , expected_workers ) : [EOL] storage = RedisStorageMock ( ) [EOL] infrastructure_provider = InfrastructureProviderMock ( env ) [EOL] [EOL] config = f' [string] { mode } [string] ' [EOL] storage . set ( settings . REDIS_CONFIG_KEY , bytes ( config , [string] ) ) [EOL] [EOL] rectifier = Rectifier ( broker = RabbitMQ ( ) , storage = storage , infrastructure_provider = infrastructure_provider , ) [EOL] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] rectifier . run ( ) [EOL] [EOL] assert infrastructure_provider . called_count == expected_called_count [EOL] assert ( infrastructure_provider . consumers [ [string] ] [ [string] ] == expected_workers ) [EOL] [EOL] [EOL] def test_kill_only_calls_when_needed ( env ) : [EOL] storage = RedisStorageMock ( ) [EOL] infrastructure_provider = InfrastructureProviderMock ( env ) [EOL] [EOL] config = f' [string] ' [EOL] storage . set ( settings . REDIS_CONFIG_KEY , bytes ( config , [string] ) ) [EOL] [EOL] rectifier = Rectifier ( broker = RabbitMQ ( ) , storage = storage , infrastructure_provider = infrastructure_provider , ) [EOL] [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] [EOL] def test_monitor_with_no_config ( env ) : [EOL] storage = RedisStorageMock ( ) [EOL] infrastructure_provider = InfrastructureProviderMock ( env ) [EOL] [EOL] storage . set ( settings . REDIS_CONFIG_KEY , None ) [EOL] rectifier = Rectifier ( broker = RabbitMQ ( ) , storage = storage , infrastructure_provider = infrastructure_provider , ) [EOL] [EOL] assert not storage . get ( settings . REDIS_CONFIG_KEY ) [EOL] assert not storage . get ( settings . REDIS_UPDATE_TIMES ) [EOL] rectifier . run ( ) [EOL] [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert not storage . get ( settings . REDIS_CONFIG_KEY ) [EOL] assert not storage . get ( settings . REDIS_UPDATE_TIMES ) [EOL] [EOL] [EOL] def test_monitor_with_no_broker_uri ( env ) : [EOL] storage = RedisStorageMock ( ) [EOL] infrastructure_provider = MagicMock ( ) [EOL] infrastructure_provider . scale = MagicMock ( ) [EOL] infrastructure_provider . broker_uri = MagicMock ( return_value = None ) [EOL] [EOL] storage . set ( settings . REDIS_CONFIG_KEY , [string] , ) [EOL] rectifier = Rectifier ( broker = RabbitMQ ( ) , storage = storage , infrastructure_provider = infrastructure_provider , ) [EOL] [EOL] rectifier . run ( ) [EOL] [EOL] assert not infrastructure_provider . scale . called [EOL] [EOL] [EOL] def test_update_time_storage ( env ) : [EOL] storage = RedisStorageMock ( ) [EOL] infrastructure_provider = InfrastructureProviderMock ( env ) [EOL] [EOL] rectifier = Rectifier ( broker = RabbitMQ ( ) , storage = storage , infrastructure_provider = infrastructure_provider , ) [EOL] [EOL] storage . set ( settings . REDIS_CONFIG_KEY , [string] , ) [EOL] [EOL] with freeze_time ( [string] ) as frozen_time : [EOL] [comment] [EOL] [comment] [EOL] env . rabbitmq . set_queue ( [string] , [string] ) [EOL] rectifier . run ( ) [EOL] [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] update_times = pickle . loads ( storage . get ( settings . REDIS_UPDATE_TIMES ) ) [EOL] assert update_times [ [string] ] [ [string] ] == frozen_time . time_to_freeze [EOL] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] frozen_time . move_to ( [string] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] update_times = pickle . loads ( storage . get ( settings . REDIS_UPDATE_TIMES ) ) [EOL] assert update_times [ [string] ] [ [string] ] == frozen_time . time_to_freeze [EOL] [EOL] old_time = frozen_time . time_to_freeze [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] frozen_time . move_to ( [string] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] update_times = pickle . loads ( storage . get ( settings . REDIS_UPDATE_TIMES ) ) [EOL] assert update_times [ [string] ] [ [string] ] == old_time [EOL] [EOL] [EOL] def test_monitor_common_config ( env ) : [EOL] storage = RedisStorageMock ( ) [EOL] infrastructure_provider = InfrastructureProviderMock ( env ) [EOL] [EOL] storage . set ( settings . REDIS_CONFIG_KEY , [string] , ) [EOL] [EOL] rectifier = Rectifier ( broker = RabbitMQ ( ) , storage = storage , infrastructure_provider = infrastructure_provider , ) [EOL] [EOL] with freeze_time ( [string] ) as frozen_time : [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] rectifier . run ( ) [EOL] [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] rectifier . run ( ) [EOL] [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] frozen_time . move_to ( [string] ) [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL] [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] env . rabbitmq . set_queue ( [string] , [string] , [number] , [number] ) [EOL] rectifier . run ( ) [EOL] assert infrastructure_provider . called_count == [number] [EOL] assert infrastructure_provider . consumers [ [string] ] [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import rectifier [EOL] import builtins [EOL] from typing import Any , Optional [EOL] [EOL] from rectifier . storage import Storage , StorageSubscription [EOL] [EOL] [EOL] class RedisStorageMockSubscription ( StorageSubscription ) : [EOL] def get_message ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class RedisStorageMock ( Storage ) : [EOL] def __init__ ( self ) : [EOL] self . data = dict ( config = [string] [string] ) [EOL] [EOL] def get ( self , key ) : [EOL] return self . data . get ( key ) [EOL] [EOL] def set ( self , key , value ) : [EOL] self . data [ key ] = value [EOL] [EOL] def publish ( self , channel , message = None ) : [EOL] pass [EOL] [EOL] def subscribe ( self , channel ) : [EOL] return RedisStorageMockSubscription ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 0 0 0 $rectifier.storage.StorageSubscription$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import rectifier [EOL] import tests [EOL] import pytest [EOL] [EOL] from rectifier import settings [EOL] from rectifier . config import Config , CoordinatorConfig , QueueConfig , AppConfig , AppMode [EOL] [EOL] from . rabbitmq_mock import RabbitMQAPIMock [EOL] [EOL] [EOL] class TestableEnv : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . rabbitmq = RabbitMQAPIMock ( ) [EOL] [EOL] apps = dict ( rectifier = AppConfig ( mode = AppMode . SCALE , queues = dict ( queue = QueueConfig ( intervals = [ [number] , [number] , [number] , [number] ] , workers = [ [number] , [number] , [number] , [number] ] , cooldown = [number] , queue_name = [string] , consumers_formation_name = [string] , ) ) , ) ) [EOL] [EOL] coordinator_config = CoordinatorConfig ( apps = apps ) [EOL] self . config = Config ( coordinator_config = coordinator_config ) [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] [EOL] self . rabbitmq . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] [EOL] self . rabbitmq . stop ( ) [EOL] [EOL] def rabbit_mq_uri ( self , app ) : [EOL] host = [string] % ( self . rabbitmq . host , self . rabbitmq . port ) [EOL] return [string] % ( [string] , [string] , host , app ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def env ( ) : [EOL] [docstring] [EOL] [EOL] env = TestableEnv ( ) [EOL] env . start ( ) [EOL] settings . RABBIT_MQ_SECURE = False [EOL] yield env [EOL] env . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.rabbitmq_mock.RabbitMQAPIMock$ 0 0 0 0 0 0 $typing.Dict[builtins.str,rectifier.config.config.AppConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rectifier.config.config.CoordinatorConfig$ 0 0 0 $typing.Dict[builtins.str,rectifier.config.config.AppConfig]$ 0 $typing.Dict[builtins.str,rectifier.config.config.AppConfig]$ 0 0 0 0 $rectifier.config.config.Config$ 0 0 0 $rectifier.config.config.CoordinatorConfig$ 0 $rectifier.config.config.CoordinatorConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import _importlib_modulespec [EOL] import pytest [EOL] import uuid [EOL] import sys [EOL] import importlib [EOL] [EOL] [EOL] @ pytest . fixture ( ) def empty_settings ( ) : [EOL] settings = importlib . import_module ( [string] ) [EOL] yield settings [EOL] del sys . modules [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def heroku_api_key ( monkeypatch ) : [EOL] key = str ( uuid . uuid4 ( ) ) [EOL] monkeypatch . setenv ( [string] , key ) [EOL] [EOL] settings = importlib . import_module ( [string] ) [EOL] yield key , settings [EOL] del sys . modules [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def heroku_api_keys ( monkeypatch ) : [EOL] keys = [ str ( uuid . uuid4 ( ) ) for _ in range ( [number] , [number] ) ] [EOL] monkeypatch . setenv ( [string] , [string] . join ( keys ) ) [EOL] [EOL] settings = importlib . import_module ( [string] ) [EOL] yield keys , settings [EOL] del sys . modules [ [string] ] [EOL] [EOL] [EOL] def test_empty_config ( empty_settings ) : [EOL] assert empty_settings . HEROKU_API_KEYS == [ ] [EOL] assert empty_settings . HEROKU_API_KEY is None [EOL] [EOL] [EOL] def test_api_key_set ( heroku_api_key ) : [EOL] ( heroku_api_key , settings ) = heroku_api_key [EOL] assert settings . HEROKU_API_KEY == heroku_api_key [EOL] assert settings . HEROKU_API_KEYS == [ heroku_api_key ] [EOL] [EOL] [EOL] def test_api_keys_set ( heroku_api_keys ) : [EOL] ( heroku_api_keys , settings ) = heroku_api_keys [EOL] assert settings . HEROKU_API_KEYS == heroku_api_keys [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import threading [EOL] import typing [EOL] import flask [EOL] import builtins [EOL] import threading [EOL] from collections import defaultdict [EOL] from typing import Dict [EOL] [EOL] import flask [EOL] from werkzeug . serving import make_server [EOL] [EOL] [EOL] class RabbitMQAPIMock : [EOL] [docstring] [EOL] [EOL] _queues = ... [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] self . _queues = defaultdict ( lambda : defaultdict ( str ) ) [EOL] [EOL] self . _thread = threading . Thread ( target = self . _run ) [EOL] [EOL] self . _app = flask . Flask ( __name__ ) [EOL] self . _app . add_url_rule ( [string] , [string] , view_func = self . _get_queues ) [EOL] self . _server = make_server ( [string] , [number] , self . _app ) [EOL] [EOL] self . host = self . _server . host [EOL] self . port = self . _server . port [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] self . _thread . start ( ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] [EOL] self . _server . shutdown ( ) [EOL] self . _thread . join ( timeout = [number] ) [EOL] [EOL] def _run ( self ) : [EOL] [docstring] [EOL] [EOL] self . _server . serve_forever ( ) [EOL] [EOL] def _get_queues ( self , app_name ) : [EOL] [docstring] [EOL] [EOL] queues = self . _queues [ app_name ] [EOL] return flask . jsonify ( [ { [string] : queue_name , [string] : queue [ [string] ] , [string] : queue [ [string] ] , } for queue_name , queue in queues . items ( ) ] ) [EOL] [EOL] def set_queue ( self , app , name , consumers = [number] , messages = [number] ) : [EOL] [docstring] [EOL] self . _queues [ app ] [ name ] = { [string] : messages , [string] : consumers } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0
from typing import List [EOL] import typing [EOL] import rectifier [EOL] import pytest [EOL] [EOL] from rectifier . message_brokers import RabbitMQ [EOL] from rectifier . queue . queue import Queue [EOL] [EOL] from . env import env [comment] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ ( [string] , [string] , [number] , [number] ) ] , [ [string] ] , [ Queue ( queue_name = [string] , consumers_count = [number] , messages = [number] ) ] , ) , ( [ ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) ] , [ [string] , [string] ] , [ Queue ( queue_name = [string] , consumers_count = [number] , messages = [number] ) , Queue ( queue_name = [string] , consumers_count = [number] , messages = [number] ) , ] , ) , ( [ ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) ] , [ [string] ] , [ Queue ( queue_name = [string] , consumers_count = [number] , messages = [number] ) ] , ) , ( [ ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) ] , [ [string] ] , [ Queue ( queue_name = [string] , consumers_count = [number] , messages = [number] ) ] , ) , ( [ ( [string] , [string] , [number] , [number] ) , ( [string] , [string] , [number] , [number] ) ] , [ [string] ] , [ ] , ) , ] , ) def test_get_current_load ( config , interest_queues , output , env ) : [EOL] for queue in config : [EOL] env . rabbitmq . set_queue ( * queue ) [EOL] [EOL] interest_queues = RabbitMQ . queues ( interest_queues , RabbitMQ . stats ( env . rabbit_mq_uri ( app = [string] ) ) ) [EOL] for queue in output : [EOL] assert queue in interest_queues [EOL] [EOL] [EOL] def test_get_current_load_missing_queue ( env ) : [EOL] [docstring] [EOL] [EOL] interest_queues = RabbitMQ . queues ( [ [string] ] , RabbitMQ . stats ( env . rabbit_mq_uri ( app = [string] ) ) ) [EOL] [EOL] assert len ( interest_queues ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional [EOL] import typing [EOL] from collections import Counter [EOL] [EOL] from rectifier . get_random_key import get_random_key [EOL] [EOL] [EOL] def test_rotating_keys ( ) : [EOL] keys = [ get_random_key ( [ [string] , [string] , [string] ] ) for _ in range ( [number] , [number] ) ] [EOL] most_common_element_occurrences = Counter ( keys ) . most_common ( [number] ) [ [number] ] [ [number] ] [EOL] assert most_common_element_occurrences != [number] [EOL] [EOL] [EOL] def test_rotating_keys_no_elements ( ) : [EOL] assert get_random_key ( [ ] ) is None [EOL] assert get_random_key ( None ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Union , List , Dict [EOL] import typing [EOL] import rectifier [EOL] import tests [EOL] import pytest [EOL] [EOL] from rectifier . config import ( Config , ConfigParser , ConfigReadError , CoordinatorConfig , QueueConfig , ) [EOL] from rectifier . config . config import AppConfig , AppMode [EOL] from tests . redis_mock import RedisStorageMock [EOL] [EOL] [EOL] def test_config_reader_dict_parsing ( ) : [EOL] config = { [string] : { [string] : [string] , [string] : { [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [number] , [string] : [string] , } , [string] : { [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [number] , [string] : [string] , } , } , [string] : { [string] : { [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [number] , [string] : [string] , } , [string] : { [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [number] , [string] : [string] , } , } , } [EOL] expected_result = Config ( coordinator_config = CoordinatorConfig ( apps = dict ( rectifier = AppConfig ( mode = AppMode . NOOP , queues = dict ( q1 = QueueConfig ( intervals = [ [number] , [number] , [number] , [number] ] , workers = [ [number] , [number] , [number] , [number] ] , cooldown = [number] , queue_name = [string] , consumers_formation_name = [string] , ) , q2 = QueueConfig ( intervals = [ [number] , [number] , [number] , [number] ] , workers = [ [number] , [number] , [number] , [number] ] , cooldown = [number] , queue_name = [string] , consumers_formation_name = [string] , ) , ) , ) , rectifier2 = AppConfig ( mode = AppMode . SCALE , queues = { [string] : QueueConfig ( intervals = [ [number] , [number] , [number] , [number] ] , workers = [ [number] , [number] , [number] , [number] ] , cooldown = [number] , queue_name = [string] , consumers_formation_name = [string] , ) , [string] : QueueConfig ( intervals = [ [number] , [number] , [number] , [number] ] , workers = [ [number] , [number] , [number] , [number] ] , cooldown = [number] , queue_name = [string] , consumers_formation_name = [string] , ) , } , ) , ) ) ) [EOL] [EOL] assert ConfigParser . from_dict ( config ) == expected_result [EOL] [EOL] [EOL] def test_config_reader ( ) : [EOL] storage = RedisStorageMock ( ) [EOL] [EOL] config_reader = ConfigParser ( storage = storage ) [EOL] expected_result = Config ( coordinator_config = CoordinatorConfig ( apps = dict ( rectifier = AppConfig ( mode = AppMode . SCALE , queues = dict ( q1 = QueueConfig ( intervals = [ [number] , [number] , [number] , [number] ] , workers = [ [number] , [number] , [number] , [number] ] , cooldown = [number] , queue_name = [string] , consumers_formation_name = [string] , ) ) , ) , rectifier2 = AppConfig ( mode = AppMode . SCALE , queues = dict ( q21 = QueueConfig ( intervals = [ [number] , [number] , [number] , [number] ] , workers = [ [number] , [number] , [number] , [number] ] , cooldown = [number] , queue_name = [string] , consumers_formation_name = [string] , ) ) , ) , ) ) ) [EOL] [EOL] assert config_reader . config == expected_result [EOL] [EOL] storage . set ( [string] , None ) [EOL] config_reader = ConfigParser ( storage = storage ) [EOL] assert config_reader . config is None [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( { [string] : { [string] : { [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [number] , [string] : [string] , } } } ) , ( { [string] : { [string] : { [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [number] , [string] : [string] , } } } ) , ( { [string] : { [string] : { [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ - [number] , [number] , [number] , [number] ] , [string] : [number] , [string] : [string] , } } } ) , ( { [string] : { [string] : { [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : - [number] , [string] : [string] , } } } ) , ( { [string] : { [string] : { [string] : [ [number] , [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] , [number] ] , [string] : [number] , [string] : [string] , } } } ) , ( { [string] : { [string] : { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [number] , [string] : False , } } } ) , ( { [string] : { [string] : { [string] : False } } } , ) , ] , ) def test_invalid_queue_configurations ( config ) : [EOL] with pytest . raises ( ConfigReadError ) : [EOL] ConfigParser . validate ( config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . config import Config [EOL] from . rabbitmq import RabbitMQ [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from typing import Type , List , Dict , Union [EOL] import schemas [EOL] import typing [EOL] class Config : [EOL] QUEUE = { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] } } , [string] : { [string] : [string] , [string] : { [string] : [string] } } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : [ [string] , [string] , [string] , [string] ] , [string] : False , } [EOL] [EOL] APP = { [string] : [string] , [string] : { [string] : QUEUE , [string] : { [string] : [string] , [string] : [ [string] , [string] , [string] ] } , } , } [EOL] [EOL] SCHEMA = { [string] : [string] , [string] : { [string] : APP } , [string] : False , } [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Dict , Union [EOL] import schemas [EOL] import typing [EOL] class RabbitMQ : [EOL] QUEUE = { [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : [ [string] , [string] , [string] ] , } [EOL] [EOL] SCHEMA = { [string] : [string] , [string] : QUEUE } [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0