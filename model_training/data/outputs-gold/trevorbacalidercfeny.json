from typing import Iterator , Type , List , Any , Sequence , Tuple [EOL] import typing [EOL] import builtins [EOL] import collections [EOL] import copy [EOL] import typing [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] [EOL] def coruscate ( talea , cut , fit , dilation , unit , rests = True ) : [EOL] [docstring] [EOL] talea = baca . sequence ( talea ) [EOL] talea = talea . helianthate ( [number] , [number] ) [EOL] talea = talea . flatten ( ) [EOL] assert all ( talea ) [EOL] cut = baca . sequence ( cut ) [EOL] cut = cut . helianthate ( [number] , [number] ) [EOL] cut = cut . flatten ( ) [EOL] dilation = baca . sequence ( dilation ) [EOL] dilation = dilation . helianthate ( [number] , [number] ) [EOL] dilation = dilation . flatten ( ) [EOL] fit_copy = copy . copy ( fit ) [EOL] fit = baca . increase_elements ( fit , dilation ) [EOL] j = [number] [EOL] signatures = [ ] [EOL] for i , element in enumerate ( fit ) : [EOL] new = [ ] [EOL] while abjad . mathx . weight ( new ) < element : [EOL] if cut [ j % len ( cut ) ] == [number] : [EOL] new . append ( talea [ j % len ( talea ) ] ) [EOL] elif cut [ j % len ( cut ) ] == [number] : [EOL] new . append ( - talea [ j % len ( talea ) ] ) [EOL] else : [EOL] raise ValueError [EOL] j += [number] [EOL] signatures . append ( new ) [EOL] [EOL] def helper ( argument ) : [EOL] return list ( abjad . sequence ( argument ) . sum_by_sign ( sign = [ - [number] ] ) ) [EOL] [EOL] signatures = [ helper ( signature ) for signature in signatures ] [EOL] signatures = partition_nested_into_canonic_parts ( signatures ) [EOL] if not rests : [EOL] part_counts = [ len ( _ ) for _ in signatures ] [EOL] signatures = baca . sequence ( signatures ) . flatten ( ) [EOL] signatures = [ abs ( _ ) for _ in signatures ] [EOL] signatures = baca . sequence ( signatures ) . partition_by_counts ( part_counts ) [EOL] pairs = zip ( signatures , fit_copy ) [EOL] method = abjad . makers . tuplet_from_ratio_and_pair [EOL] result = [ method ( pair [ [number] ] , ( pair [ [number] ] , unit ) ) for pair in pairs ] [EOL] for i , element in enumerate ( result ) : [EOL] durations = [ abjad . get . duration ( element ) ] [EOL] abjad . beam ( element , durations = durations ) [EOL] return result [EOL] [EOL] [EOL] def get_shared_numeric_sign ( argument ) : [EOL] [docstring] [EOL] if not isinstance ( argument , collections . abc . Iterable ) : [EOL] raise TypeError ( argument ) [EOL] if len ( argument ) == [number] : [EOL] return [number] [EOL] elif all ( [number] < x for x in argument ) : [EOL] return [number] [EOL] elif all ( x < [number] for x in argument ) : [EOL] return - [number] [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def intaglio ( list_ , specification , weight = [number] ) : [EOL] [docstring] [EOL] assert all ( [ isinstance ( _ , int ) and _ > [number] for _ in list_ ] ) [EOL] assert all ( [ isinstance ( _ , int ) and _ != [number] for _ in specification ] ) [EOL] assert [number] < len ( list_ ) [EOL] assert [number] < len ( specification ) [EOL] result = [ ] [EOL] result = baca . sequence ( specification ) . repeat_to_weight ( sum ( list_ ) ) [EOL] result = result . split ( list_ , cyclic = False , overhang = True ) [EOL] for i , sublist in enumerate ( result ) : [EOL] if abjad . mathx . weight ( sublist ) <= weight : [EOL] result = list ( result ) [EOL] result [ i ] = baca . sequence ( [ abjad . mathx . weight ( sublist ) ] ) [EOL] result = baca . sequence ( result ) [EOL] return result [EOL] [EOL] [EOL] def join_subsequences_by_sign_of_elements ( sequence ) : [EOL] [docstring] [EOL] if not isinstance ( sequence , collections . abc . Sequence ) : [EOL] raise Exception ( f" [string] { sequence !r} [string] " ) [EOL] if not all ( isinstance ( x , collections . abc . Sequence ) for x in sequence ) : [EOL] raise Exception ( f" [string] { sequence !r} [string] " ) [EOL] if any ( get_shared_numeric_sign ( x ) is None for x in sequence ) : [EOL] raise ValueError [EOL] sequence_type = type ( sequence ) [EOL] result = [ ] [EOL] for subsequence in sequence : [EOL] try : [EOL] previous_subsequence = result [ - [number] ] [EOL] previous_subsequence_type = type ( previous_subsequence ) [EOL] previous_sublist = list ( previous_subsequence ) [EOL] if get_shared_numeric_sign ( previous_subsequence ) == get_shared_numeric_sign ( subsequence ) : [EOL] previous_sublist . extend ( subsequence ) [EOL] previous_subsequence = previous_subsequence_type ( previous_sublist ) [EOL] result [ - [number] ] = previous_subsequence [EOL] else : [EOL] result . append ( subsequence [ : ] ) [EOL] except IndexError : [EOL] result . append ( subsequence [ : ] ) [EOL] result = sequence_type ( result ) [EOL] return result [EOL] [EOL] [EOL] def lengths_to_joined_positive_counts ( sequence , ) : [EOL] [docstring] [EOL] result = map_elements_to_numbered_sublists ( sequence ) [EOL] result = join_subsequences_by_sign_of_elements ( result ) [EOL] result = [ x for x in result if get_shared_numeric_sign ( x ) == [number] ] [EOL] return result [EOL] [EOL] [EOL] def make_measures ( argument , meters ) : [EOL] [docstring] [EOL] durations = [ abjad . Duration ( * meter ) for meter in meters ] [EOL] total = sum ( durations , abjad . Duration ( [number] ) ) [EOL] for voice in abjad . iterate ( argument ) . components ( abjad . Voice ) : [EOL] assert abjad . get . duration ( voice ) == total [EOL] meter_index = [number] [EOL] measure = abjad . Container ( ) [EOL] for component in voice [ : ] : [EOL] measure . append ( component ) [EOL] if durations [ meter_index ] <= abjad . get . duration ( measure ) : [EOL] duration = abjad . get . duration ( measure ) [EOL] time_signature = abjad . TimeSignature ( duration ) [EOL] leaf = abjad . get . leaf ( measure , [number] ) [EOL] abjad . attach ( time_signature , leaf ) [EOL] voice [ meter_index : [number] * meter_index + len ( measure ) - [number] ] = [ measure ] [EOL] meter_index += [number] [EOL] if meter_index == len ( durations ) : [EOL] break [EOL] else : [EOL] measure = abjad . Container ( ) [EOL] [EOL] [EOL] def map_elements_to_numbered_sublists ( sequence ) : [EOL] [docstring] [EOL] if not isinstance ( sequence , list ) : [EOL] raise TypeError [EOL] if not all ( isinstance ( x , int ) for x in sequence ) : [EOL] raise ValueError [EOL] result = [ ] [EOL] current = [number] [EOL] for length in sequence : [EOL] abs_length = abs ( length ) [EOL] part = range ( current , current + abs_length ) [EOL] part = [ abjad . mathx . sign ( length ) * x for x in part ] [EOL] result . append ( part ) [EOL] current += abs_length [EOL] return result [EOL] [EOL] [EOL] def partition_nested_into_canonic_parts ( argument ) : [EOL] [docstring] [EOL] if isinstance ( argument , int ) : [EOL] return abjad . mathx . partition_integer_into_canonic_parts ( argument ) [EOL] elif isinstance ( argument , list ) : [EOL] result = [ ] [EOL] for subexpr in argument : [EOL] new = partition_nested_into_canonic_parts ( subexpr ) [EOL] if isinstance ( subexpr , int ) : [EOL] result . extend ( new ) [EOL] elif isinstance ( subexpr , list ) : [EOL] result . append ( new ) [EOL] return result [EOL] else : [EOL] raise ValueError [EOL] [EOL] [EOL] def replace_measure_contents_with_rests ( leaf , positions ) : [EOL] [docstring] [EOL] for i , m in enumerate ( leaf ) : [EOL] if ( i + [number] ) in positions : [EOL] duration = abjad . get . duration ( m ) [EOL] maker = abjad . RestMaker ( ) [EOL] rests = maker ( duration ) [EOL] time_signature = abjad . TimeSignature ( m . time_signature ) [EOL] abjad . attach ( time_signature , rests [ [number] ] ) [EOL] new_measure = abjad . Container ( rests ) [EOL] leaf [ i ] = new_measure [EOL] [EOL] [EOL] def replace_nested_elements_with_unary_subruns ( list_ ) : [EOL] [docstring] [EOL] result = [ ] [EOL] for element in list_ : [EOL] if isinstance ( element , list ) : [EOL] new_sublist = [ ] [EOL] for number in element : [EOL] if [number] < number : [EOL] new_sublist . extend ( number * [ [number] ] ) [EOL] else : [EOL] new_sublist . append ( number ) [EOL] result . append ( new_sublist ) [EOL] elif isinstance ( element , int ) : [EOL] if [number] < element : [EOL] result . extend ( [ [number] ] * element ) [EOL] else : [EOL] result . append ( element ) [EOL] else : [EOL] raise ValueError [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import distutils . version [EOL] import platform [EOL] [EOL] from . etc import ( append_articulations , clear_dynamics , copy_music_list , get_lowest_pitch , hpartition_notes_only , hpartition_rest_terminated , make_breaks_voice , make_measures_voice , octavate_leaves , recombine_voices , redden_sections , ripple_voices , set_articulations , set_pitch , set_pitch_iterator , stellate , ) [EOL] from . etc . cfg import PERSISTENCEDIR [EOL] from . tools import ( coruscate , get_shared_numeric_sign , intaglio , join_subsequences_by_sign_of_elements , lengths_to_joined_positive_counts , make_measures , map_elements_to_numbered_sublists , partition_nested_into_canonic_parts , replace_measure_contents_with_rests , replace_nested_elements_with_unary_subruns , ) [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] if not ( distutils . version . LooseVersion ( [string] ) < distutils . version . LooseVersion ( platform . python_version ( ) ) ) : [EOL] raise ImportError ( [string] ) [EOL] del distutils [EOL] del platform [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import abjad [EOL] [EOL] metadata = abjad . OrderedDict ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [number] ) , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pathlib [EOL] import pathlib [EOL] [EOL] LIDERCFENYDIR = pathlib . Path ( [string] ) [EOL] VOICESDIR = LIDERCFENYDIR / [string] [EOL] PERSISTENCEDIR = pathlib . Path ( [string] ) [EOL]	0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pickle [EOL] [EOL] import abjad [EOL] [EOL] from lidercfeny . etc . cfg import PERSISTENCEDIR [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] eighths = pickle . load ( pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] staves = pickle . load ( pointer ) [EOL] [EOL] violinPitchStaff = staves [ [string] ] [EOL] violinPitchVoice = staves [ [string] ] [EOL] [EOL] bowStaff = staves [ [string] ] [EOL] bowVoice = staves [ [string] ] [EOL] bowVoice . invocation = [string] [EOL] for leaf in bowVoice . leaves : [EOL] leaf . history [ [string] ] = leaf . __class__ . __name__ [EOL] [EOL] bowReferenceVoice = bowVoice . copy ( ) [EOL] bowReferenceVoice . invocation = [string] [EOL] bowStaff . append ( bowReferenceVoice ) [EOL] for leaf in bowReferenceVoice . leaves : [EOL] leaf . beam . counts = None [EOL] leaf . beam . unspan ( ) [EOL] if not leaf . kind ( [string] ) : [EOL] abjad . Skip ( leaf ) [EOL] [EOL] abjad . label ( violinPitchVoice ) . with_indices ( ) [EOL] abjad . label ( bowVoice ) . with_indices ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from . bowtreatments import BowTreatment , iterate_over_structure [EOL] [EOL] [EOL] def apply_bow ( voice , start , stop , treatment ) : [EOL] [EOL] notes = BowTreatment ( ) [EOL] rests = BowTreatment ( ) [EOL] [EOL] if treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] rests [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] rests [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] , ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] , ] [EOL] rests [ [string] ] = [ [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] , ] [EOL] rests [ [string] ] = [ [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] notes [ [string] ] = [ [string] , [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] , [string] , [string] ] [EOL] notes [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] = [ [string] ] [EOL] [EOL] else : [EOL] raise ValueError ( [string] % treatment ) [EOL] [EOL] iterate_over_structure ( voice , start , stop , notes , rests ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import time [EOL] [EOL] import abjad [EOL] [EOL] from . . cfg import VOICESDIR [EOL] from . . pitch . trills import apply_trills [EOL] from . import palette [EOL] from . expose import bowReferenceVoice as reference [EOL] from . expose import bowVoice as bow [EOL] from . expose import violinPitchVoice as pitches [EOL] [EOL] print ( [string] ) [EOL] [EOL] x1 = time . time ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vh ( [number] , [string] ) [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vgliss ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] abjad . hairpin ( [string] , bow . leaves [ [number] : [number] + [number] ] ) [EOL] abjad . hairpin ( [string] , bow . leaves [ [number] : [number] + [number] ] ) [EOL] abjad . hairpin ( [string] , bow . leaves [ [number] : [number] + [number] ] ) [EOL] abjad . hairpin ( [string] , bow . leaves [ [number] : [number] + [number] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vtwine ( [number] , [number] , [string] ) [EOL] [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhnxpins ( [number] , [number] , [string] ) [EOL] bow . leaves [ [number] ] . glissando = True [EOL] bow . leaves [ [number] ] . dynamics . spanner . capture ( [number] ) [EOL] abjad . Note ( bow . leaves [ [number] ] ) [EOL] bow . leaves [ [number] ] . pitch = [number] [EOL] bow . leaves [ [number] ] . notehead . transparent = True [EOL] bow . leaves [ [number] ] . dots . transparent = True [EOL] bow . leaves [ [number] ] . stem . transparent = True [EOL] bow . leaves [ [number] ] . beam . _refuse = True [EOL] [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vmeas ( [number] , [number] , [string] ) [EOL] [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhnxpins ( [number] , [number] , [string] ) [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vhnxpins ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vblossom ( [number] , [number] ) [EOL] palette . vh ( [number] , [number] , [string] ) [EOL] [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhnxpins ( [number] , [number] , [string] ) [EOL] [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] pitches . leaves [ [number] ] . beam . spanner . durations = [ ( [number] , [number] ) ] [EOL] [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] bow . leaves [ [number] ] . glissando = False [EOL] bow . leaves [ [number] ] . stem . tremolo = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] pitches . leaves [ [number] ] . pitch = ( [string] , [number] ) [EOL] pitches . leaves [ [number] ] . glissando = True [EOL] pitches . leaves [ [number] ] . pitch = ( [string] , [number] ) [EOL] pitches . leaves [ [number] ] . glissando = True [EOL] pitches . leaves [ [number] ] . pitch = ( [string] , [number] ) [EOL] pitches . leaves [ [number] ] . glissando = True [EOL] pitches . leaves [ [number] ] = abjad . Note ( pitches . leaves [ [number] ] ) [EOL] pitches . leaves [ [number] ] . pitch = ( [string] , [number] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] bow . leaves [ [number] ] . dynamics . self_alignment_X = - [number] [EOL] bow . leaves [ [number] ] . dynamics . self_alignment_X = - [number] [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] apply_trills ( pitches , [number] , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhnxpins ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vtwine ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] bow . leaves [ [number] ] . glissando = False [EOL] bow . leaves [ [number] ] . dynamics . spanner . surrender ( [number] ) [EOL] [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vtwine ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vgliss ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] abjad . hairpin ( [string] , bow . leaves [ [number] : [number] + [number] ] ) [EOL] abjad . hairpin ( [string] , bow . leaves [ [number] : [number] + [number] ] ) [EOL] abjad . hairpin ( [string] , bow . leaves [ [number] : [number] + [number] ] ) [EOL] abjad . hairpin ( [string] , bow . leaves [ [number] : [number] + [number] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vblossom ( [number] , [number] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vmeas ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] bow . leaves [ [number] ] . dynamics . spanner . surrender ( [number] ) [EOL] bow . leaves [ [number] ] . dynamics . self_alignment_X = - [number] [EOL] bow . leaves [ [number] ] . dynamics . self_alignment_X = - [number] [EOL] [EOL] [comment] [EOL] for measure in pitches [ [number] - [number] : [number] - [number] + [number] ] : [EOL] measure . leaves [ [number] ] . beam . spanner . durations = [ measure . duration . pair ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vtwine ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] apply_trills ( pitches , [number] , [number] , ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] [EOL] bow . leaves [ [number] ] . glissando = False [EOL] bow . leaves [ [number] ] . dynamics . spanner . surrender ( [number] ) [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] palette . vreg ( [number] , [number] , [string] ) [EOL] palette . vtwine ( [number] , [number] , [string] ) [EOL] palette . vbow ( [number] , [number] , [string] ) [EOL] palette . vhrtpins ( [number] , [number] , [string] ) [EOL] apply_trills ( pitches , [number] , [number] , ( [number] , [number] ) ) [EOL] [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] bow . leaves [ [number] ] . dynamics . self_alignment_X = - [number] [EOL] bow . leaves [ [number] ] . glissando = False [EOL] bow . leaves [ [number] ] . dynamics . unspan ( ) [EOL] bow . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def _replace_measure ( measure , replacement_reference ) : [EOL] for x in range ( len ( measure ) ) : [EOL] measure . pop ( ) [EOL] measure . append ( replacement_reference ) [EOL] [EOL] [EOL] replacement = pitches [ [number] - [number] ] . leaves [ [number] ] . copy ( ) [EOL] replacement . duration = ( [number] , [number] ) [EOL] replacement . beam . unspan ( ) [EOL] _replace_measure ( pitches [ [number] - [number] ] , replacement ) [EOL] [EOL] replacement = pitches [ [number] - [number] ] . leaves [ [number] ] . copy ( ) [EOL] replacement . duration = ( [number] , [number] ) [EOL] replacement . beam . unspan ( ) [EOL] _replace_measure ( pitches [ [number] - [number] ] , replacement ) [EOL] [EOL] [comment] [EOL] [EOL] for leaf in bow . leaves : [EOL] if isinstance ( leaf , abjad . Rest ) : [EOL] abjad . override ( leaf ) . rest . transparent = True [EOL] if leaf . written_duration . dots : [EOL] abjad . override ( leaf ) . dots . transparent = True [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] x2 = time . time ( ) [EOL] print ( [string] % round ( x2 - x1 , [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL] open ( VOICESDIR / [string] , [string] ) . write ( pitches . format ) [EOL] open ( VOICESDIR / [string] , [string] ) . write ( bow . format ) [EOL] open ( VOICESDIR / [string] , [string] ) . write ( reference . format ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Literal , List , Any [EOL] import typing [EOL] import typing_extensions [EOL] import abjad [EOL] [EOL] import lidercfeny [EOL] [EOL] from . . dynamics . dynamics import hairpin_to_measures [EOL] from . . dynamics . newd import historical_notes_only_pins , historical_rest_terminated_pins [EOL] from . . pitch . glissandi import applyGlissandi [EOL] from . . pitch . ornament import apply_articulations [EOL] from . . pitch . register import applyRegistration [EOL] from . . pitch . shine import apply_blossoms , apply_shine [EOL] from . . pitch . twine import apply_twine [EOL] from . bow import apply_bow [EOL] from . expose import bowVoice as bow [EOL] from . expose import violinPitchVoice as pitches [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def apply_artificial_harmonic ( voice , * arguments ) : [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] leaves = list ( leaves ) [EOL] if len ( arguments ) == [number] : [EOL] start , diatonicInterval = arguments [EOL] stop = start [EOL] elif len ( arguments ) == [number] : [EOL] start , stop , diatonicInterval = arguments [EOL] else : [EOL] raise ValueError [EOL] for leaf in leaves [ start : stop + [number] ] : [EOL] if isinstance ( leaf , abjad . Note ) : [EOL] leaf . add_artificial_harmonic ( diatonicInterval ) [EOL] [EOL] [EOL] def vreg ( start , stop , registration ) : [EOL] applyRegistration ( pitches , start , stop , registration ) [EOL] [EOL] [EOL] def vtwine ( * arguments ) : [EOL] apply_twine ( pitches , * arguments ) [EOL] [EOL] [EOL] def vshine ( * arguments , ** keywords ) : [EOL] apply_shine ( pitches , * arguments , ** keywords ) [EOL] [EOL] [EOL] def vblossom ( start , stop ) : [EOL] apply_blossoms ( pitches , start , stop ) [EOL] [EOL] [EOL] def vprall ( start , stop ) : [EOL] min = ( [number] , [number] ) [EOL] mask = [ [number] , [number] , [number] , [number] , [number] ] [EOL] apply_articulations ( pitches , start , stop , ( [string] , ) , min = min , mask = mask , rests = False , overwrite = False , ) [EOL] [EOL] [EOL] def vh ( * arguments ) : [EOL] apply_artificial_harmonic ( pitches , * arguments ) [EOL] [EOL] [EOL] def vmark ( * arguments ) : [EOL] lidercfeny . etc . transforms . set_articulations ( pitches , arguments [ - [number] ] , * arguments [ : - [number] ] ) [EOL] [EOL] [EOL] def vlayer ( * arguments ) : [EOL] lidercfeny . etc . transforms . append_articulations ( pitches , arguments [ - [number] ] , * arguments [ : - [number] ] ) [EOL] [EOL] [EOL] def vgliss ( * arguments , ** keywords ) : [EOL] applyGlissandi ( pitches , * arguments , ** keywords ) [EOL] [EOL] [EOL] def vbow ( start , stop , treatment ) : [EOL] apply_bow ( bow , start , stop , treatment ) [EOL] [EOL] [EOL] def vmeas ( start , stop , hpstr ) : [EOL] hairpin_to_measures ( bow , start , stop , hpstr ) [EOL] [EOL] [EOL] def vhnxpins ( start , stop , material ) : [EOL] historical_notes_only_pins ( bow , start , stop , material ) [EOL] [EOL] [EOL] def vhrtpins ( start , stop , material ) : [EOL] historical_rest_terminated_pins ( bow , start , stop , material ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] [EOL] [EOL] def H ( leaf ) : [EOL] return baca . sequence ( leaf ) . helianthate ( [number] , - [number] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] positionToPitchNumber = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] POSITION = { [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : H ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] , [string] , [string] ] ] ) , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] + [ [string] , [string] ] * [number] + H ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , } [EOL] [EOL] [EOL] def _materialIndexToPosition ( material , i ) : [EOL] return POSITION [ material ] [ i % len ( POSITION [ material ] ) ] [EOL] [EOL] [EOL] def treatOneLeaf ( cur , treatments , i ) : [EOL] [EOL] if hasattr ( cur , [string] ) : [EOL] cur . notehead . clear ( ) [EOL] cur . tremolo . clear ( ) [EOL] cur . glissando . clear ( ) [EOL] [EOL] for treatment in treatments : [EOL] if treatment == [string] : [EOL] if not cur . kind ( [string] ) : [EOL] cur = abjad . Note ( cur ) [EOL] cur . pitch = [number] [EOL] elif treatment == [string] : [EOL] if not cur . kind ( [string] ) : [EOL] cur = abjad . Rest ( cur ) [EOL] elif treatment == [string] : [EOL] if not cur . kind ( [string] ) : [EOL] cur = abjad . Skip ( cur ) [EOL] elif treatment == [string] : [EOL] cur . dots . transparent = True [EOL] cur . stem . transparent = True [EOL] if hasattr ( cur , [string] ) : [EOL] cur . notehead . transparent = True [EOL] cur . notehead . no_ledgers = True [EOL] [comment] [EOL] if cur . kind ( [string] ) : [EOL] cur . beam . _refuse = True [EOL] elif treatment == [string] : [EOL] cur . notehead . style = treatment [EOL] elif treatment == [string] : [EOL] cur . notehead . transparent = True [EOL] cur . notehead . no_ledgers = True [EOL] elif treatment == [string] : [EOL] cur . notehead . style = [string] [EOL] elif treatment == [string] : [EOL] cur . stem . tremolo = [number] [EOL] elif treatment == [string] : [EOL] cur . glissando = True [EOL] elif treatment in positionToPitchNumber . keys ( ) : [EOL] cur . pitch = positionToPitchNumber [ treatment ] [EOL] elif treatment in POSITION . keys ( ) : [EOL] position = _materialIndexToPosition ( treatment , i ) [EOL] cur . pitch = positionToPitchNumber [ position ] [EOL] else : [EOL] raise ValueError ( [string] % treatment ) [EOL] [EOL] [EOL] def BowTreatment ( ) : [EOL] return { [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , } [EOL] [EOL] [EOL] def iterate_over_structure ( voice , start , stop , notes = BowTreatment , rests = BowTreatment ) : [EOL] leaves = voice . leaves [ start : stop + [number] ] [EOL] for i , cur in enumerate ( leaves ) : [EOL] if [number] < i : [EOL] prev = cur . prev [EOL] else : [EOL] prev = None [EOL] if i < len ( leaves ) - [number] : [EOL] next = cur . next [EOL] else : [EOL] next = None [EOL] positions = [ ] [EOL] if len ( leaves ) == [number] : [EOL] positions . append ( [string] ) [EOL] if i == [number] : [EOL] positions . append ( [string] ) [EOL] if i == len ( leaves ) - [number] : [EOL] positions . append ( [string] ) [EOL] if ( prev [EOL] and next [EOL] and prev . history [ [string] ] != cur . history [ [string] ] != next . history [ [string] ] ) : [EOL] positions . append ( [string] ) [EOL] if not prev or ( prev and prev . history [ [string] ] != cur . history [ [string] ] ) : [EOL] positions . append ( [string] ) [EOL] if not next or ( next and cur . history [ [string] ] != next . history [ [string] ] ) : [EOL] positions . append ( [string] ) [EOL] if ( prev [EOL] and next [EOL] and prev . history [ [string] ] != cur . history [ [string] ] != next . history [ [string] ] ) : [EOL] positions . append ( [string] ) [EOL] positions . append ( [string] ) [EOL] if cur . history [ [string] ] == [string] : [EOL] for position in positions : [EOL] if notes [ position ] : [EOL] [comment] [EOL] treatOneLeaf ( cur , notes [ position ] , i ) [EOL] break [EOL] else : [EOL] for position in positions : [EOL] if rests [ position ] : [EOL] [comment] [EOL] treatOneLeaf ( cur , rests [ position ] , i ) [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] import quicktions [EOL] [EOL] import lidercfeny [EOL] [EOL] from . sections import sections [EOL] [EOL] [EOL] def present ( eighths , staves , startMeasure = [number] ) : [EOL] pairs = [ ( _ , [number] ) if _ == int ( _ ) else ( int ( _ * [number] ) , [number] ) for _ in eighths ] [EOL] durations = [ quicktions . Fraction ( * p ) for p in pairs ] [EOL] directives = [ [string] % ( p [ [number] ] , p [ [number] ] ) for p in pairs ] [EOL] measuresPerLine = baca . sequence ( eighths ) . group_by_weights ( [ [number] ] , fill = [string] , cyclic = True , overhang = False ) [EOL] measuresPerLine = [ len ( x ) for x in measuresPerLine ] [EOL] measuresWithBreaks = [ m - [number] for m in abjad . mathx . cumulative_sums ( measuresPerLine ) ] [EOL] measuresWithSpacing = [ [number] ] + [ m + [number] for m in measuresWithBreaks ] [ : - [number] ] [EOL] pageHeight = [number] [EOL] systemsPerPage = [number] [EOL] systemHeight = pageHeight / systemsPerPage [EOL] [comment] [EOL] curSystem = [number] [EOL] breaks = [ ] [EOL] for i , duration in enumerate ( durations ) : [EOL] try : [EOL] new = abjad . Skip ( duration ) [EOL] except ValueError : [EOL] new = abjad . Skip ( ( [number] , [number] ) ) [EOL] new . multiplier = duration [EOL] if i in measuresWithSpacing : [EOL] new . formatter . before . append ( [string] ) [EOL] new . formatter . before . append ( [string] ) [EOL] systemOffset = systemHeight * ( curSystem % systemsPerPage ) [EOL] staffOffsets = [string] [EOL] text = [string] % systemOffset [EOL] new . formatter . before . append ( text ) [EOL] text = [string] % staffOffsets [EOL] new . formatter . before . append ( text ) [EOL] if i in measuresWithBreaks : [EOL] if curSystem % systemsPerPage == systemsPerPage - [number] : [EOL] new . formatter . right . append ( [string] ) [EOL] else : [EOL] new . formatter . right . append ( [string] ) [EOL] curSystem += [number] [EOL] breaks . append ( new ) [EOL] breaks [ - [number] ] . formatter . right . append ( [string] ) [EOL] breaksVoice = abjad . Voice ( breaks ) [EOL] breaksVoice . name = [string] [EOL] [EOL] for st in staves : [EOL] voices = abjad . iterate ( st ) . components ( abjad . Voice ) [EOL] for v in voices : [EOL] before = [string] [EOL] v . leaves [ [number] ] . formatter . before . append ( before ) [EOL] [EOL] measures_voice = lidercfeny . transforms . make_measures_voice ( pairs ) [EOL] for i , measure in enumerate ( measures_voice ) : [EOL] measure [ [number] ] . formatter . left . append ( directives [ i ] ) [EOL] mm = abjad . select ( measures_voice ) . components ( abjad . Skip ) [EOL] [EOL] override = [string] % startMeasure [EOL] abjad . get . leaf ( st , [number] ) . formatter . before . append ( override ) [EOL] [EOL] barText = [string] [EOL] spanBarText = [string] [EOL] for ( i , start , stop , description ) in sections : [EOL] if startMeasure <= start : [EOL] sectionText = [string] [EOL] sectionText += [string] % ( i , description ) [EOL] try : [EOL] mm [ start - startMeasure ] . formatter . before . extend ( [ barText , spanBarText ] ) [EOL] abjad . get . leaf ( mm [ start - startMeasure ] , [number] ) . formatter . right . append ( sectionText ) [EOL] except Exception : [EOL] pass [EOL] [EOL] flute = abjad . Staff ( [ staves [ [number] ] , staves [ [number] ] ] ) [EOL] flute . invocation = [string] [EOL] flute . brackets = [string] [EOL] violin = abjad . Staff ( [ staves [ [number] ] , staves [ [number] ] ] ) [EOL] violin . invocation = [string] [EOL] violin . brackets = [string] [EOL] piano = abjad . Staff ( [ staves [ [number] ] , staves [ [number] ] ] ) [EOL] piano . invocation = [string] [EOL] piano . brackets = [string] [EOL] [EOL] sc = abjad . Score ( [ flute , violin , piano ] ) [EOL] sc [ [string] ] . insert ( [number] , breaksVoice ) [EOL] sc [ [string] ] . brackets = [string] [EOL] [EOL] ly = abjad . LilyPondFile ( [ sc ] ) [EOL] layout = [string] [EOL] ly . includes . append ( layout ) [EOL] [EOL] return ly [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . wrap import redden_sections [EOL] [EOL] __all__ = [ [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import math [EOL] [EOL] import abjad [EOL] [EOL] from . split_pitches import split_pitches [EOL] [EOL] LIDERCFENYDIR = [string] [EOL] [EOL] [EOL] def make_fixed_layout_voice ( duration , systems , alignments , offsets ) : [EOL] [docstring] [EOL] alignment = [string] . join ( [ str ( _ ) for _ in alignments ] ) [EOL] alignment = [string] % alignment [EOL] voice = abjad . Voice ( [ ] , name = [string] ) [EOL] for system in range ( systems ) : [EOL] new = abjad . Skip ( duration ) [EOL] offset = offsets [ system % len ( offsets ) ] [EOL] offset = [string] % offset [EOL] text = [string] [EOL] new . before . append ( text ) [EOL] new . before . append ( [string] ) [EOL] text = [string] % ( offset , alignment ) [EOL] new . before . append ( text ) [EOL] if system % len ( offsets ) == len ( offsets ) - [number] : [EOL] new . right . append ( [string] ) [EOL] else : [EOL] new . right . append ( [string] ) [EOL] voice . music . append ( new ) [EOL] return voice [EOL] [EOL] [EOL] def plot ( pitches ) : [EOL] chords_per_system = [number] [EOL] systems = int ( math . ceil ( len ( pitches ) / chords_per_system ) ) [EOL] offsets = [ [number] + x for x in ( [number] , [number] , [number] , [number] , [number] ) ] [EOL] layoutVoice = make_fixed_layout_voice ( ( chords_per_system , [number] ) , systems , ( [number] , - [number] ) , offsets ) [EOL] treble , bass = split_pitches ( pitches ) [EOL] trebleVoice = abjad . Voice ( treble , name = [string] ) [EOL] trebleVoice . instances ( [string] ) [ [number] ] . before . append ( [string] ) [EOL] trebleStaff = abjad . Staff ( [ layoutVoice , trebleVoice ] , name = [string] ) [EOL] bassVoice = abjad . Voice ( bass , name = [string] ) [EOL] bassVoice . instances ( [string] ) [ [number] ] . before . append ( [string] ) [EOL] last = bassVoice . instances ( [string] ) [ - [number] ] [EOL] last . after . append ( [string] ) [EOL] last . after . append ( [string] ) [EOL] bassStaff = abjad . Staff ( [ bassVoice ] , name = [string] ) [EOL] gs = abjad . GrandStaff ( [ trebleStaff , bassStaff ] , name = [string] ) [EOL] sc = abjad . Score ( [ gs ] , name = [string] ) [EOL] ly = abjad . LilyPondFile ( [ sc ] , includes = [ LIDERCFENYDIR + [string] ] ) [EOL] return ly [EOL] [EOL] [EOL] def lines ( pitches ) : [EOL] chords_per_system = [number] [EOL] systems = int ( math . ceil ( len ( pitches ) / chords_per_system ) ) [EOL] offsets = [ [number] + [number] * x for x in range ( [number] ) ] [EOL] layoutVoice = make_fixed_layout_voice ( ( chords_per_system , [number] ) , systems , ( [number] , - [number] ) , offsets ) [EOL] treble , bass = split_pitches ( pitches ) [EOL] trebleVoice = abjad . Voice ( treble , name = [string] ) [EOL] trebleVoice . instances ( [string] ) [ [number] ] . before . append ( [string] ) [EOL] trebleStaff = abjad . Staff ( [ layoutVoice , trebleVoice ] , name = [string] ) [EOL] bassVoice = abjad . Voice ( bass , name = [string] ) [EOL] bassVoice . instances ( [string] ) [ [number] ] . before . append ( [string] ) [EOL] last = bassVoice . instances ( [string] ) [ - [number] ] [EOL] last . after . append ( [string] ) [EOL] last . after . append ( [string] ) [EOL] bassStaff = abjad . Staff ( [ bassVoice ] , name = [string] ) [EOL] gs = abjad . StaffGroup ( [ trebleStaff , bassStaff ] , lilypond_type = [string] , name = [string] , ) [EOL] score = abjad . Score ( [ gs ] , name = [string] ) [EOL] ly = abjad . LilyPondFile ( [ score ] , includes = [ LIDERCFENYDIR + [string] ] ) [EOL] return ly [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import lidercfeny [EOL] [EOL] from . . cfg import VOICESDIR [EOL] [EOL] lineBreaks = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] lineBreaks [ [string] ] = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] lineBreaks [ [string] ] = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] [EOL] [EOL] alignmentOffsets = [ [number] , - [number] , - [number] , - [number] , - [number] , - [number] ] [EOL] breaks = lidercfeny . etc . transforms . make_breaks_voice ( lineBreaks [ [string] ] , [ - [number] , [number] ] , alignmentOffsets , [number] ) [EOL] [EOL] system = [number] [EOL] for skip in breaks : [EOL] page = int ( system / [number] ) + [number] [EOL] system_on_page = system % [number] + [number] [EOL] skip . comments . before . append ( [string] % ( page , system_on_page ) ) [EOL] system += [number] [EOL] [EOL] [comment] [EOL] open ( VOICESDIR / [string] , [string] ) . write ( breaks . format ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import abjad [EOL] [EOL] [EOL] def split_pitches ( pitches , split = - [number] ) : [EOL] [docstring] [EOL] for sublist in pitches : [EOL] components = { [string] : [ ] , [string] : [ ] } [EOL] for n in sublist : [EOL] if n >= split : [EOL] components [ [string] ] . append ( n ) [EOL] else : [EOL] components [ [string] ] . append ( n ) [EOL] for register in ( [string] , [string] ) : [EOL] if len ( components [ register ] ) == [number] : [EOL] components [ register ] = abjad . Skip ( ( [number] , [number] ) ) [EOL] elif len ( components [ register ] ) == [number] : [EOL] components [ register ] = abjad . Note ( components [ register ] , ( [number] , [number] ) ) [EOL] else : [EOL] components [ register ] = abjad . Chord ( components [ register ] , ( [number] , [number] ) ) [EOL] return components [ [string] ] , components [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import abjad [EOL] [EOL] import lidercfeny [EOL] from lidercfeny . etc . layout . sections import sections [EOL] [EOL] [EOL] def redden_sections ( measuresVoice , sectionTuples , start_measure = [number] ) : [EOL] [docstring] [EOL] skips = abjad . iterate ( measuresVoice ) . components ( abjad . Skip ) [EOL] skips = list ( skips ) [EOL] for i , start , stop , description in sectionTuples : [EOL] if start_measure <= start : [EOL] [comment] [EOL] string = [string] [EOL] string = string . format ( i , description ) [EOL] markup = abjad . Markup ( string , direction = abjad . Up , literal = True ) [EOL] skip_index = start - start_measure [EOL] skip = skips [ skip_index ] [EOL] abjad . override ( skip ) . score . bar_line . color = [string] [EOL] abjad . override ( skip ) . score . span_bar . color = [string] [EOL] abjad . attach ( markup , skip ) [EOL] [EOL] [EOL] def trim_voices ( argument , nMeasures ) : [EOL] [docstring] [EOL] [EOL] customVoiceContexts = [ [string] , [string] , [string] , [string] , ] [EOL] voices = abjad . iterate ( argument ) . components ( abjad . Voice ) [EOL] voices = list ( voices ) + customVoiceContexts [EOL] for v in voices : [EOL] v . music = v . music [ : nMeasures ] [EOL] [EOL] [EOL] def makeFluteGroup ( * staves ) : [EOL] return abjad . Container ( list ( staves ) , id = [string] , name = [string] ) [EOL] [EOL] [EOL] def makeViolinGroup ( * staves ) : [EOL] return abjad . Container ( list ( staves ) , id = [string] , name = [string] ) [EOL] [EOL] [EOL] def makeScore ( eighths , staves , breaks , nMeasures = None , startMeasure = [number] ) : [EOL] eighths = eighths [ : nMeasures ] [EOL] trim_voices ( staves , nMeasures ) [EOL] pairs = [ ( _ , [number] ) if _ == int ( _ ) else ( int ( _ * [number] ) , [number] ) for _ in eighths ] [EOL] measures_voice = lidercfeny . etc . transforms . make_measures_voice ( pairs ) [EOL] redden_sections ( measures_voice , sections ) [EOL] alignmentOffsets = [ [number] , - [number] , - [number] , - [number] , - [number] , - [number] ] [EOL] breaksVoice = lidercfeny . etc . transforms . make_breaks_voice ( breaks , [ - [number] , [number] ] , alignmentOffsets , [number] ) [EOL] breaksVoice . addFinalBar ( ) [EOL] breaksVoice . setInitialTempo ( [string] ) [EOL] for voice in abjad . iterate ( staves ) . components ( abjad . Voice ) : [EOL] voice . accidentals = [string] [EOL] flute = makeFluteGroup ( staves [ [number] ] , staves [ [number] ] ) [EOL] violin = makeViolinGroup ( staves [ [number] ] , staves [ [number] ] ) [EOL] piano = abjad . PianoStaff ( [ staves [ [number] ] , staves [ [number] ] ] , name = [string] ) [EOL] sc = abjad . Score ( [ flute , violin , piano ] , name = [string] ) [EOL] sc . insertMeasuresVoice ( measures_voice ) [EOL] sc . insertBreaksVoice ( breaksVoice ) [EOL] sc . setCurrentBarNumber ( startMeasure ) [EOL] ly = abjad . LilyPondFile ( [ sc ] , name = [string] ) [EOL] ly . setLayoutFile ( [string] ) [EOL] return ly [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import typing [EOL] sections = [ ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [string] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] import quicktions [EOL] [EOL] [EOL] def visualize ( eighths , staves ) : [EOL] pairs = [ ( _ , [number] ) if _ == int ( _ ) else ( int ( _ * [number] ) , [number] ) for _ in eighths ] [EOL] durations = [ quicktions . Fraction ( * p ) for p in pairs ] [EOL] directives = [ [string] % ( p [ [number] ] , p [ [number] ] ) for p in pairs ] [EOL] measuresPerLine = baca . sequence ( eighths ) . group_by_weights ( [ [number] ] , fill = [string] , cyclic = True , overhang = False ) [EOL] measuresPerLine = [ len ( x ) for x in measuresPerLine ] [EOL] measuresWithBreaks = [ m - [number] for m in abjad . mathx . cumulative_sums ( measuresPerLine ) ] [EOL] measuresWithSpacing = [ [number] ] + [ m + [number] for m in measuresWithBreaks ] [ : - [number] ] [EOL] pageHeight = [number] [EOL] systemsPerPage = [number] [EOL] systemHeight = pageHeight / systemsPerPage [EOL] [comment] [EOL] curSystem = [number] [EOL] breaks = [ ] [EOL] for i , duration in enumerate ( durations ) : [EOL] new = abjad . Skip ( duration ) [EOL] if i in measuresWithSpacing : [EOL] new . before . append ( [string] ) [EOL] new . before . append ( [string] ) [EOL] systemOffset = systemHeight * ( curSystem % systemsPerPage ) [EOL] [comment] [EOL] [comment] [EOL] staffOffsets = [string] [EOL] text = [string] % systemOffset [EOL] new . before . append ( text ) [EOL] text = [string] % staffOffsets [EOL] new . before . append ( text ) [EOL] if i in measuresWithBreaks : [EOL] if curSystem % systemsPerPage == systemsPerPage - [number] : [EOL] new . right . append ( [string] ) [EOL] else : [EOL] new . right . append ( [string] ) [EOL] curSystem += [number] [EOL] breaks . append ( new ) [EOL] breaks [ - [number] ] . right . append ( [string] ) [EOL] breaksVoice = abjad . Voice ( breaks , name = [string] ) [EOL] [EOL] mm = [ abjad . Container ( [ abjad . Skip ( * p ) ] ) for p in pairs ] [EOL] for i , m in enumerate ( mm ) : [EOL] m . music [ [number] ] . left . append ( directives [ i ] ) [EOL] measures_voice = abjad . Voice ( mm , name = [string] ) [EOL] mm = abjad . select ( measures_voice ) . components ( abjad . Skip ) [EOL] [EOL] [docstring] [EOL] [EOL] flute = abjad . GrandStaff ( [ staves [ [number] ] , staves [ [number] ] ] , name = [string] ) [EOL] violin = abjad . GrandStaff ( [ staves [ [number] ] , staves [ [number] ] ] , name = [string] ) [EOL] piano = abjad . PianoStaff ( [ staves [ [number] ] , staves [ [number] ] ] , name = [string] ) [EOL] [EOL] flute . during . extend ( [ [string] , [string] , ] ) [EOL] violin . during . extend ( [ [string] , [string] , ] ) [EOL] piano . during . extend ( [ [string] , [string] , ] ) [EOL] [EOL] sc = abjad . Score ( [ flute , violin , piano ] , name = [string] ) [EOL] sc . instances ( [string] ) [ [number] ] . music . insert ( [number] , measures_voice ) [EOL] sc . instances ( [string] ) [ [number] ] . music . insert ( [number] , breaksVoice ) [EOL] [EOL] ly = abjad . LilyPondFile ( [ sc ] , name = [string] ) [EOL] ly . includes . append ( [string] ) [EOL] [EOL] return ly [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import abjad [EOL] [EOL] [EOL] def clear_dynamics ( argument ) : [EOL] [docstring] [EOL] for leaf in abjad . iterate ( argument ) . leaves ( ) : [EOL] leaf . dynamics = None [EOL] leaf . dynamics . unspan ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] [EOL] import lidercfeny [EOL] [EOL] [EOL] def recombine_voices ( target , s , insert , t , loci ) : [EOL] [docstring] [EOL] targetVoices = abjad . select ( target ) . components ( abjad . Voice ) [EOL] insertVoices = abjad . select ( insert ) . components ( abjad . Voice ) [EOL] if len ( targetVoices ) != len ( insertVoices ) : [EOL] message = [string] [EOL] raise ValueError ( message ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def P ( n , s ) : [EOL] return baca . sequence ( range ( n ) ) . partition ( s , cyclic = True , overhang = True , action = [string] ) [EOL] [EOL] def makeIndexPairs ( n , s ) : [EOL] result = [ len ( part ) for part in P ( n , s ) ] [EOL] result = abjad . mathx . cumulative_sums_zero ( result ) [EOL] return baca . sequence ( result ) . nwise ( n = [number] ) [EOL] [EOL] targetIndexPairs = makeIndexPairs ( len ( targetVoices [ [number] ] ) , s ) [EOL] insertIndexPairs = makeIndexPairs ( len ( insertVoices [ [number] ] ) , t ) [EOL] if len ( insertIndexPairs ) < len ( loci ) : [EOL] print ( [string] % len ( insertIndexPairs ) ) [EOL] print ( [string] % len ( loci ) ) [EOL] print ( ) [EOL] for targetVoice , insertVoice in zip ( targetVoices , insertVoices ) : [EOL] for j , locus in enumerate ( reversed ( sorted ( loci ) ) ) : [EOL] first , last = insertIndexPairs [ len ( loci ) - [number] - j ] [EOL] insert = lidercfeny . etc . transforms . copy_music_list ( insertVoice , first , last - [number] ) [EOL] first , last = targetIndexPairs [ locus ] [EOL] targetVoice [ first : last ] = insert [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import abjad [EOL] [EOL] [EOL] def copy_music_list ( ll , i = None , j = None ) : [EOL] [docstring] [EOL] if i is None and j is None : [EOL] source = ll [ : ] [EOL] else : [EOL] source = ll [ i : j + [number] ] [EOL] if source == [ ] : [EOL] print ( [string] % ( i , j ) ) [EOL] print ( [string] % len ( ll ) ) [EOL] print ( ) [EOL] result = abjad . Container ( source ) [EOL] result = result . copy ( ) [EOL] result = result [ : ] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import abjad [EOL] [EOL] [EOL] def set_pitch ( note , specification = [number] ) : [EOL] [docstring] [EOL] if not isinstance ( note , abjad . Note ) : [EOL] return [EOL] if specification == [string] : [EOL] pitches = note . core [EOL] transposition = [number] [EOL] elif isinstance ( specification , int ) : [EOL] pitches = [ pitch % [number] for pitch in note . core ] [EOL] transposition = specification [EOL] elif isinstance ( specification , list ) : [EOL] [comment] [EOL] if specification [ [number] ] == [string] : [EOL] new = [ ] [EOL] for pitch in note . core : [EOL] for start , stop , t in specification [ [number] : ] : [EOL] if pitch in range ( start , stop + [number] ) : [EOL] new . append ( pitch % [number] + t ) [EOL] if len ( new ) == [number] : [EOL] [comment] [EOL] note . pitch = new [ [number] ] [EOL] else : [EOL] note . caster . toChord ( ) [EOL] note . pitches = new [EOL] return [EOL] [comment] [EOL] elif specification [ [number] ] == [string] : [EOL] pitches = [ pitch % [number] for pitch in note . core ] [EOL] for start , stop , t in specification [ [number] : ] : [EOL] [comment] [EOL] if pitches [ [number] ] in range ( start , stop + [number] ) : [EOL] transposition = t [EOL] break [EOL] else : [EOL] raise ValueError [EOL] else : [EOL] raise ValueError [EOL] if len ( pitches ) == [number] : [EOL] note . pitch = pitches [ [number] ] + transposition [EOL] else : [EOL] note . caster . toChord ( ) [EOL] note . pitches = [ pitch + transposition for pitch in pitches ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import abjad [EOL] [EOL] import lidercfeny [EOL] [EOL] [EOL] def set_pitch_iterator ( voice , start , stop , spec = [number] ) : [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] leaves = list ( leaves ) [EOL] for leaf in leaves [ start : stop + [number] ] : [EOL] lidercfeny . etc . transforms . set_pitch ( leaf , spec ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import abjad [EOL] [EOL] import lidercfeny [EOL] [EOL] [EOL] def ripple_voices ( music , specification ) : [EOL] [docstring] [EOL] specification = dict ( specification ) [EOL] voices = abjad . select ( music ) . components ( abjad . Voice ) [EOL] for voice in voices : [EOL] for i in reversed ( range ( len ( voice ) ) ) : [EOL] if i in specification : [EOL] length , count = specification [ i ] [EOL] source = voice . copy ( i , i + length - [number] ) [EOL] leaves = abjad . select ( source ) . leaves ( ) [EOL] left , right = leaves [ [number] ] , leaves [ - [number] ] [EOL] [comment] [EOL] [comment] [EOL] left . spanners . fracture ( direction = [string] ) [EOL] right . spanners . fracture ( direction = [string] ) [EOL] new = [ ] [EOL] for j in range ( count ) : [EOL] new . extend ( lidercfeny . etc . transforms . copy_music_list ( source ) ) [EOL] voice [ i : i + [number] ] = new [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import abjad [EOL] [EOL] [EOL] def get_lowest_pitch ( argument ) : [EOL] [docstring] [EOL] if isinstance ( argument , abjad . Note ) : [EOL] return argument . pitch . number [EOL] elif isinstance ( argument , abjad . Chord ) : [EOL] return argument . pitches [ [number] ] . number [EOL] else : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import abjad [EOL] [EOL] [EOL] def append_articulations ( voice , articulations , * arguments , ** keywords ) : [EOL] [docstring] [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] leaves = list ( leaves ) [EOL] if len ( arguments ) == [number] : [EOL] start = [number] [EOL] stop = len ( leaves ) [EOL] elif len ( arguments ) == [number] : [EOL] start = stop = arguments [EOL] elif len ( arguments ) == [number] : [EOL] start , stop = arguments [EOL] else : [EOL] raise ValueError [EOL] [comment] [EOL] if [string] in keywords : [EOL] exclude = keywords [ [string] ] [EOL] else : [EOL] exclude = True [EOL] for leaf in leaves : [EOL] if isinstance ( leaf , ( abjad . Note , abjad . Chord ) ) or not exclude : [EOL] if isinstance ( articulations , str ) : [EOL] leaf . articulations . append ( articulations ) [EOL] elif isinstance ( articulations , list ) : [EOL] for articulation in articulations : [EOL] leaf . articulations . extend ( articulation ) [EOL] else : [EOL] raise ValueError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . append_articulations import append_articulations [EOL] from . clear_dynamics import clear_dynamics [EOL] from . copy_music_list import copy_music_list [EOL] from . get_lowest_pitch import get_lowest_pitch [EOL] from . hpartition_notes_only import hpartition_notes_only [EOL] from . hpartition_rest_terminated import hpartition_rest_terminated [EOL] from . make_breaks_voice import make_breaks_voice [EOL] from . make_measures_voice import make_measures_voice [EOL] from . octavate_leaves import octavate_leaves [EOL] from . recombine_voices import recombine_voices [EOL] from . ripple_voices import ripple_voices [EOL] from . set_articulations import set_articulations [EOL] from . set_pitch import set_pitch [EOL] from . set_pitch_iterator import set_pitch_iterator [EOL] from . stellate import stellate [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import abjad [EOL] [EOL] [EOL] def make_breaks_voice ( durationPairs , yOffsets , alignmentOffsets , start = [number] ) : [EOL] [docstring] [EOL] [EOL] if not isinstance ( yOffsets , list ) : [EOL] yOffsets = [ yOffsets ] [EOL] alignmentOffsets = [string] . join ( [ str ( x ) for x in alignmentOffsets ] ) [EOL] breaks = [ ] [EOL] for p in durationPairs : [EOL] try : [EOL] skip = abjad . Skip ( p ) [EOL] except ( ValueError , abjad . AssignabilityError ) : [EOL] skip = abjad . Skip ( ( [number] , [number] ) , multiplier = p ) [EOL] breaks . append ( skip ) [EOL] for i , b in enumerate ( breaks ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] voice = abjad . Voice ( breaks ) [EOL] voice . name = [string] [EOL] return voice [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Tuple , List , Any [EOL] import typing [EOL] import copy [EOL] import math [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] import lidercfeny [EOL] [EOL] [EOL] def stellate ( denominators , prolation , mask , unit , beams , span = [string] , rests = True , ) : [EOL] [docstring] [EOL] if mask == [ [ [number] ] ] : [EOL] message = [string] [EOL] raise ValueError ( message ) [EOL] debug = False [EOL] denominators_copy = copy . copy ( denominators ) [EOL] prolation = baca . sequence ( prolation ) . helianthate ( [number] , [number] ) [EOL] prolation = prolation . flatten ( ) [EOL] numerators = baca . increase_elements ( denominators , prolation ) [EOL] mask = baca . sequence ( mask ) [EOL] mask = mask . helianthate ( [number] , [number] ) [EOL] mask = mask . flatten ( ) [EOL] mask = mask . repeat_to_weight ( abjad . mathx . weight ( numerators ) ) [EOL] mask = lidercfeny . replace_nested_elements_with_unary_subruns ( mask ) [EOL] signatures = mask . split ( numerators , cyclic = False , overhang = True ) [EOL] for i , signature in enumerate ( signatures ) : [EOL] if signature == [ [number] ] : [EOL] signatures [ i ] = [ - [number] ] [EOL] signatures = lidercfeny . partition_nested_into_canonic_parts ( signatures ) [EOL] if not rests : [EOL] part_counts = [ len ( _ ) for _ in signatures ] [EOL] signatures = signatures . flatten ( ) [EOL] signatures = [ abs ( _ ) for _ in signatures ] [EOL] signatures = signatures . partition ( part_counts ) [EOL] pairs = zip ( signatures , denominators_copy ) [EOL] method = abjad . makers . tuplet_from_ratio_and_pair [EOL] tuplets = [ method ( pair [ [number] ] , ( pair [ [number] ] , unit ) ) for pair in pairs ] [EOL] if span == [string] : [EOL] span = int ( math . log ( unit , [number] ) ) - [number] [EOL] if isinstance ( span , int ) and span < [number] : [EOL] span = None [EOL] dummy_container = abjad . Container ( tuplets ) [EOL] tuplets = tuplets . partition ( beams , cyclic = True , overhang = True ) [EOL] for i , sublist in enumerate ( tuplets ) : [EOL] if debug : [EOL] sublist [ [number] ] [ [number] ] . formatter . right . append ( [string] % i ) [EOL] durations = [ abjad . get . duration ( tuplet ) for tuplet in sublist ] [EOL] spanner = abjad . Beam ( durations = durations , span_beam_count = span ) [EOL] abjad . attach ( spanner , sublist ) [EOL] i += [number] [EOL] dummy_container [ : ] = [ ] [EOL] tuplets = tuplets . flatten ( ) [EOL] return tuplets [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import quicktions [EOL] [EOL] [EOL] def hpartition_rest_terminated ( leaves , cut = ( [number] , ) , gap = ( [number] , ) ) : [EOL] [docstring] [EOL] cut = quicktions . Fraction ( * cut ) [EOL] gap = quicktions . Fraction ( * gap ) [EOL] result = [ [ ] ] [EOL] for leaf in leaves : [EOL] lastChunk = result [ - [number] ] [EOL] if leaf . history [ [string] ] == [string] : [EOL] if len ( lastChunk ) == [number] : [EOL] lastChunk . append ( leaf ) [EOL] else : [EOL] lastLeaf = lastChunk [ - [number] ] [EOL] if lastLeaf . history [ [string] ] == [string] : [EOL] lastChunk . append ( leaf ) [EOL] else : [EOL] result . append ( [ leaf ] ) [EOL] elif leaf . history [ [string] ] == [string] : [EOL] if [number] < len ( lastChunk ) : [EOL] lastLeaf = lastChunk [ - [number] ] [EOL] if lastLeaf . history [ [string] ] == [string] : [EOL] lastChunk . append ( leaf ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import abjad [EOL] [EOL] [EOL] def make_measures_voice ( durationPairs ) : [EOL] [docstring] [EOL] measures = [ ] [EOL] for pair in durationPairs : [EOL] skip = abjad . Skip ( ( [number] , [number] ) , multiplier = pair ) [EOL] time_signature = abjad . TimeSignature ( pair ) [EOL] abjad . attach ( time_signature , skip ) [EOL] measure = abjad . Container ( [ skip ] ) [EOL] measures . append ( measure ) [EOL] voice = abjad . Voice ( measures ) [EOL] voice . name = [string] [EOL] return voice [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import abjad [EOL] [EOL] [EOL] def octavate_leaf ( note , base = ( - [number] , [number] ) ) : [EOL] [docstring] [EOL] if not isinstance ( note , abjad . Note ) : [EOL] return [EOL] assert hasattr ( note , [string] ) [EOL] assert isinstance ( note . core , list ) [EOL] lower , upper = base [EOL] pitch = abjad . spget ( note ) [EOL] if upper < pitch <= upper + [number] : [EOL] abjad . OttavaSpanner ( note , [number] ) [EOL] elif upper + [number] < pitch : [EOL] abjad . OttavaSpanner ( note , [number] ) [EOL] elif lower - [number] <= pitch < lower : [EOL] abjad . OttavaSpanner ( note , - [number] ) [EOL] elif pitch < lower - [number] : [EOL] abjad . OttavaSpanner ( note , - [number] ) [EOL] [EOL] [EOL] def octavate_leaves ( voice , start , stop , base ) : [EOL] [docstring] [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] leaves = list ( leaves ) [EOL] for leaf in leaves [ start : stop + [number] ] : [EOL] octavate_leaf ( leaf , base ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import pickle [EOL] [EOL] import abjad [EOL] [EOL] from lidercfeny . etc . cfg import PERSISTENCEDIR [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] eighths = pickle . load ( pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] staves = pickle . load ( pointer ) [EOL] [EOL] [comment] [EOL] [EOL] flutePitchStaff = staves [ [string] ] [EOL] flutePitchVoice = flutePitchStaff [ [string] ] [EOL] [EOL] breathStaff = staves [ [string] ] [EOL] breathVoice = staves [ [string] ] [EOL] for leaf in breathVoice . leaves : [EOL] leaf . history [ [string] ] = leaf . __class__ . __name__ [EOL] [EOL] attackVoice = breathVoice . copy ( ) [EOL] attackVoice . invocation = [string] [EOL] for leaf in attackVoice . leaves : [EOL] leaf . duration . rewrite ( ( [number] , [number] ) ) [EOL] leaf . beam . clear ( ) [EOL] leaf . beam . counts = None [EOL] leaf . beam . unspan ( ) [EOL] if leaf . kind ( [string] ) : [EOL] leaf . pitch = [number] [EOL] else : [EOL] abjad . Skip ( leaf ) [EOL] [EOL] nucleusVoice = breathVoice . copy ( ) [EOL] nucleusVoice . invocation = [string] [EOL] for leaf in nucleusVoice . leaves : [EOL] leaf . beam . counts = None [EOL] leaf . beam . unspan ( ) [EOL] if leaf . kind ( [string] ) : [EOL] leaf . pitch = [number] [EOL] else : [EOL] abjad . Skip ( leaf ) [EOL] [EOL] releaseVoice = breathVoice . copy ( ) [EOL] releaseVoice . invocation = [string] [EOL] for leaf in releaseVoice . leaves : [EOL] leaf . duration . rewrite ( ( [number] , [number] ) ) [EOL] leaf . beam . clear ( ) [EOL] leaf . beam . clear ( ) [EOL] leaf . beam . counts = None [EOL] leaf . beam . unspan ( ) [EOL] if leaf . kind ( [string] ) : [EOL] leaf . pitch = [number] [EOL] else : [EOL] abjad . Skip ( leaf ) [EOL] [EOL] referenceVoice = breathVoice . copy ( ) [EOL] referenceVoice . invocation = [string] [EOL] for leaf in referenceVoice . leaves : [EOL] if leaf . kind ( [string] ) : [EOL] leaf . pitch = - [number] [EOL] [EOL] breathVoices = { [string] : attackVoice , [string] : nucleusVoice , [string] : releaseVoice , } [EOL] [EOL] breathStaff . pop ( ) [EOL] breathStaff . extend ( [ attackVoice , nucleusVoice , releaseVoice , referenceVoice ] ) [EOL] [EOL] abjad . label ( flutePitchVoice ) . with_indices ( ) [EOL] [comment] [EOL] [comment] [EOL] abjad . label ( referenceVoice ) . with_indices ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] [EOL] [EOL] def H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , - [number] ) [EOL] [EOL] [EOL] ATTACKS = { [string] : [ [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : H ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : [ [string] , [string] , [string] ] * [number] , [string] : H ( [ [ [string] , [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] ) , } [EOL] [EOL] [EOL] def _materialIndexToAttack ( material , i ) : [EOL] return ATTACKS [ material ] [ i % len ( ATTACKS [ material ] ) ] [EOL] [EOL] [EOL] NUCLEUS = { [string] : [ [string] ] * [number] , [string] : [ [string] ] * [number] + [ [string] , [string] ] + [ [string] ] * [number] + [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : H ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : H ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] ) , } [EOL] [EOL] [EOL] def _materialIndexToNucleus ( material , i ) : [EOL] return NUCLEUS [ material ] [ i % len ( NUCLEUS [ material ] ) ] [EOL] [EOL] [EOL] RELEASE = { [string] : [ [string] ] * [number] , [string] : [ [string] ] * [number] , [string] : [ [string] ] * [number] , [string] : H ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , } [EOL] [EOL] [EOL] def _materialIndexToRelease ( material , i ) : [EOL] return [string] + RELEASE [ material ] [ i % len ( RELEASE [ material ] ) ] [EOL] [EOL] [EOL] BreathPitchNumbers = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] BreathShapes = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def treatOneLeaf ( cur , treatments , i ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if hasattr ( cur , [string] ) : [EOL] cur . notehead . clear ( ) [EOL] cur . tremolo . clear ( ) [EOL] cur . glissando . clear ( ) [EOL] [EOL] for treatment in treatments : [EOL] if treatment == [string] : [EOL] if not cur . kind ( [string] ) : [EOL] cur = abjad . Note ( cur ) [EOL] cur . pitch = [number] [EOL] elif treatment == [string] : [EOL] if not cur . kind ( [string] ) : [EOL] cur = abjad . Rest ( cur ) [EOL] elif treatment == [string] : [EOL] if not cur . kind ( [string] ) : [EOL] cur = abjad . Skip ( cur ) [EOL] elif treatment == [string] : [EOL] cur . dots . transparent = True [EOL] cur . stem . transparent = True [EOL] if hasattr ( cur , [string] ) : [EOL] cur . notehead . transparent = True [EOL] cur . notehead . no_ledgers = True [EOL] if cur . kind ( [string] ) : [EOL] cur . beam . _refuse = True [EOL] elif treatment == [string] : [EOL] cur . notehead . style = treatment [EOL] elif treatment == [string] : [EOL] cur . glissando = True [EOL] elif treatment in BreathPitchNumbers . keys ( ) : [EOL] cur . pitch = BreathPitchNumbers [ treatment ] [EOL] if treatment in BreathShapes : [EOL] if hasattr ( cur , [string] ) : [EOL] cur . notehead . shape = BreathShapes [ treatment ] [EOL] elif treatment in ATTACKS . keys ( ) : [EOL] attack = _materialIndexToAttack ( treatment , i ) [EOL] cur . pitch = BreathPitchNumbers [ attack ] [EOL] if hasattr ( cur , [string] ) : [EOL] cur . notehead . shape = BreathShapes [ attack ] [EOL] elif treatment in NUCLEUS . keys ( ) : [EOL] nucleus = _materialIndexToNucleus ( treatment , i ) [EOL] cur . pitch = BreathPitchNumbers [ nucleus ] [EOL] if nucleus in BreathShapes : [EOL] if hasattr ( cur , [string] ) : [EOL] cur . notehead . shape = BreathShapes [ nucleus ] [EOL] elif treatment in RELEASE . keys ( ) : [EOL] release = _materialIndexToRelease ( treatment , i ) [EOL] cur . pitch = BreathPitchNumbers [ release ] [EOL] if hasattr ( cur , [string] ) : [EOL] cur . notehead . shape = BreathShapes [ release ] [EOL] else : [EOL] raise ValueError ( [string] % treatment ) [EOL] [EOL] [EOL] def BreathTreatment ( ) : [EOL] return { [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None , [string] : None } , [string] : { [string] : None , [string] : None , [string] : None } , } [EOL] [EOL] [EOL] def iterate_over_structure ( voices , start , stop , notes = BreathTreatment , rests = BreathTreatment ) : [EOL] [docstring] [EOL] [EOL] for i in range ( start , stop + [number] ) : [EOL] for stage in ( [string] , [string] , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] leaves = voices [ stage ] . leaves [EOL] cur = leaves [ i ] [EOL] if [number] < i : [EOL] prev = cur . prev [EOL] else : [EOL] prev = None [EOL] if i < len ( leaves ) - [number] : [EOL] next = cur . next [EOL] else : [EOL] next = None [EOL] positions = [ ] [EOL] if len ( leaves ) == [number] : [EOL] positions . append ( [string] ) [EOL] if i == start : [EOL] positions . append ( [string] ) [EOL] if i == stop : [EOL] positions . append ( [string] ) [EOL] if ( prev [EOL] and next [EOL] and prev . history [ [string] ] != cur . history [ [string] ] != next . history [ [string] ] ) : [EOL] positions . append ( [string] ) [EOL] if not prev or ( prev and prev . history [ [string] ] != cur . history [ [string] ] ) : [EOL] positions . append ( [string] ) [EOL] if not next or ( next and cur . history [ [string] ] != next . history [ [string] ] ) : [EOL] positions . append ( [string] ) [EOL] if ( prev [EOL] and next [EOL] and prev . history [ [string] ] != cur . history [ [string] ] != next . history [ [string] ] ) : [EOL] positions . append ( [string] ) [EOL] positions . append ( [string] ) [EOL] if cur . history [ [string] ] == [string] : [EOL] for position in positions : [EOL] if notes [ position ] [ stage ] : [EOL] [comment] [EOL] treatOneLeaf ( cur , notes [ position ] [ stage ] , i ) [EOL] break [EOL] else : [EOL] for position in positions : [EOL] if rests [ position ] [ stage ] : [EOL] [comment] [EOL] treatOneLeaf ( cur , rests [ position ] [ stage ] , i ) [EOL] break [EOL] [EOL] [EOL] def apply_breath ( voices , start , stop , treatment ) : [EOL] [EOL] notes = BreathTreatment ( ) [EOL] rests = BreathTreatment ( ) [EOL] [EOL] if treatment == [string] : [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] , [string] , ] [EOL] notes [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] , [string] , ] [EOL] notes [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] ] [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] , [string] , ] [EOL] notes [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] , [string] , ] [EOL] notes [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] , [string] , [string] , ] [EOL] notes [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] , [string] , [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] elif treatment == [string] : [EOL] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] ] [EOL] notes [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] rests [ [string] ] [ [string] ] = [ [string] ] [EOL] [EOL] else : [EOL] raise ValueError ( [string] % treatment ) [EOL] [EOL] iterate_over_structure ( voices , start , stop , notes , rests ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import time [EOL] [EOL] import abjad [EOL] [EOL] from . . cfg import VOICESDIR [EOL] from . . pitch . graces import apply_graces [EOL] from . import palette [EOL] from . expose import attackVoice as attack [EOL] from . expose import flutePitchVoice as pitches [EOL] from . expose import nucleusVoice as nucleus [EOL] from . expose import referenceVoice as reference [EOL] from . expose import releaseVoice as release [EOL] [EOL] print ( [string] ) [EOL] [EOL] x1 = time . time ( ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . ftenuti ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fseg ( [number] , [number] , [string] , ( [number] , ) , ( [number] , [number] ) ) [EOL] palette . fseg ( [number] , [number] , [string] , ( [number] , ) , ( [number] , [number] ) ) [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fseg ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . frepitch ( [number] , [number] , - [number] ) [EOL] palette . ftwine ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fmeas ( [number] , [number] , [string] ) [EOL] palette . fturn ( [number] , [number] ) [EOL] palette . fprall ( [number] , [number] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fcover ( [number] , [number] ) [EOL] palette . fcover ( [number] , [number] ) [EOL] palette . fcover ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fchange ( [number] , [string] ) [EOL] palette . fdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fcover ( [number] , [number] ) [EOL] palette . fdyn ( [number] , [number] , [string] ) [EOL] palette . fcover ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . ftwine ( [number] , [number] , [string] ) [EOL] palette . ftwine ( [number] , [number] , [string] ) [EOL] palette . ftwine ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . ftenuti ( [number] , [number] , [string] ) [EOL] palette . fcover ( [number] , [number] ) [EOL] [EOL] for leaf in reference . leaves [ [number] : [number] + [number] ] : [EOL] if leaf . dynamics . first : [EOL] leaf . dynamics . self_alignment_X = - [number] [EOL] [EOL] reference . leaves [ [number] ] . dynamics . unspan ( ) [EOL] reference . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] reference . leaves [ [number] ] . dynamics . unspan ( ) [EOL] reference . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] reference . leaves [ [number] ] . dynamics . unspan ( ) [EOL] reference . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] reference . leaves [ [number] ] . glissando = False [EOL] reference . leaves [ [number] ] . dynamics . unspan ( ) [EOL] reference . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fseg ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . ftwine ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . ftenuti ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fdyn ( [number] , [string] ) [EOL] palette . fhpin ( [number] , [number] , [string] , [string] , [string] ) [EOL] palette . fhpin ( [number] , [number] , [string] , [string] , [string] ) [EOL] palette . fhpin ( [number] , [number] , [string] , [string] , [string] ) [EOL] palette . fhpin ( [number] , [number] , [string] , [string] , [string] ) [EOL] [EOL] reference . leaves [ [number] ] . dynamics . unspan ( ) [EOL] reference . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . ftwine ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . ftenuti ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . ftenuti ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fseg ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . ftenuti ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . ftenuti ( [number] , [number] , [string] ) [EOL] apply_graces ( pitches , [number] , [number] ) [EOL] palette . fcover ( [number] , [number] ) [EOL] [EOL] reference . leaves [ [number] ] . dynamics . unspan ( ) [EOL] reference . leaves [ [number] ] . dynamics = [string] [EOL] [EOL] [comment] [EOL] [EOL] palette . freg ( [number] , [number] , [string] ) [EOL] palette . ftwine ( [number] , [number] , [string] ) [EOL] palette . fbreath ( [number] , [number] , [string] ) [EOL] palette . fcover ( [number] , [number] ) [EOL] palette . fcover ( [number] ) [EOL] palette . fdyn ( [number] , [number] , [string] ) [EOL] palette . fdyn ( [number] , [number] , [string] ) [EOL] [EOL] x2 = time . time ( ) [EOL] print ( [string] % round ( x2 - x1 , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def raise_dynamic_line_spanners_just_below_beam ( leaf_indices , vertical ) : [EOL] for i in leaf_indices : [EOL] if reference . leaves [ i ] . dynamics . spanned : [EOL] hairpin = reference . leaves [ i ] . dynamics . spanner [EOL] hairpin . leaves [ [number] ] . formatter . before . append ( [string] % vertical ) [EOL] elif nucleus . leaves [ i ] . dynamics . spanned : [EOL] hairpin = nucleus . leaves [ i ] . dynamics . spanner [EOL] hairpin . leaves [ [number] ] . formatter . before . append ( [string] % vertical ) [EOL] elif reference . leaves [ i ] . dynamics : [EOL] reference . leaves [ i ] . formatter . before . append ( [string] % vertical ) [EOL] elif nucleus . leaves [ i ] . dynamics : [EOL] nucleus . leaves [ i ] . formatter . before . append ( [string] % vertical ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL] leaf_indices = ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ) [EOL] raise_dynamic_line_spanners_just_below_beam ( leaf_indices , [number] ) [EOL] [EOL] abjad . override ( reference . leaves [ [number] : [number] + [number] ] ) . dynamic_line_spanner . staff_padding = [number] [EOL] abjad . override ( reference . leaves [ [number] : [number] + [number] ] ) . dynamic_line_spanner . staff_padding = [number] [EOL] [EOL] [comment] [EOL] [EOL] override = [string] [EOL] pitches . leaves [ [number] ] . formatter . before . append ( override ) [EOL] pitches . leaves [ [number] ] . formatter . before . append ( override ) [EOL] [EOL] [comment] [EOL] [EOL] for leaf in pitches . leaves [ [number] : ] : [EOL] if leaf . kind ( [string] ) : [EOL] leaf . pitch = leaf . pitch . diatonicTranspose ( [string] ) [EOL] if leaf . grace . before : [EOL] for x in leaf . grace . before . leaves : [EOL] if x . kind ( [string] ) : [EOL] x . pitch = x . pitch . diatonicTranspose ( [string] ) [EOL] if leaf . grace . after : [EOL] for x in leaf . grace . after . leaves : [EOL] if x . kind ( [string] ) : [EOL] x . pitch = x . pitch . diatonicTranspose ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] for leaf in ( pitches . leaves [ [number] : [number] + [number] ] + pitches [ [number] : [number] + [number] ] + pitches [ [number] : [number] + [number] ] + pitches [ [number] : [number] + [number] ] ) : [EOL] if leaf . kind ( [string] ) : [EOL] leaf . pitch = leaf . pitch . diatonicTranspose ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] pitches . leaves [ [number] ] . pitch = [number] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] pitches . leaves [ [number] ] . pitch = pitches . leaves [ [number] ] . pitch . diatonicTranspose ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def _blank_measure ( measure , replacement_reference ) : [EOL] for i in range ( len ( measure ) ) : [EOL] measure . pop ( ) [EOL] measure . append ( replacement_reference ) [EOL] [EOL] [EOL] _blank_measure ( pitches [ [number] - [number] ] , abjad . Rest ( ( [number] , [number] ) ) ) [EOL] _blank_measure ( attack [ [number] - [number] ] , abjad . Skip ( ( [number] , [number] ) ) ) [EOL] _blank_measure ( nucleus [ [number] - [number] ] , abjad . Skip ( ( [number] , [number] ) ) ) [EOL] _blank_measure ( release [ [number] - [number] ] , abjad . Skip ( ( [number] , [number] ) ) ) [EOL] _blank_measure ( reference [ [number] - [number] ] , abjad . Rest ( ( [number] , [number] ) ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL] open ( VOICESDIR / [string] , [string] ) . write ( pitches . format ) [EOL] open ( VOICESDIR / [string] , [string] ) . write ( attack . format ) [EOL] open ( VOICESDIR / [string] , [string] ) . write ( nucleus . format ) [EOL] open ( VOICESDIR / [string] , [string] ) . write ( release . format ) [EOL] open ( VOICESDIR / [string] , [string] ) . write ( reference . format ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Literal , List , Any [EOL] import typing [EOL] import typing_extensions [EOL] import abjad [EOL] [EOL] import lidercfeny [EOL] [EOL] from . . dynamics . dynamics import ( applyDynamics , applyDynamicsMeasures , applyDynamicsSegments , applyHairpin , apply_swell , apply_tenuti , ) [EOL] from . . pitch . ornament import apply_articulations [EOL] from . . pitch . register import applyRegistration [EOL] from . . pitch . twine import apply_twine [EOL] from . breath import apply_breath [EOL] from . expose import attackVoice as attack [EOL] from . expose import breathVoices [EOL] from . expose import flutePitchVoice as pitches [EOL] from . expose import nucleusVoice as nucleus [EOL] from . expose import referenceVoice as reference [EOL] [EOL] [EOL] def applyCoverSpanner ( voice , * arguments ) : [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] leaves = list ( leaves ) [EOL] if len ( arguments ) == [number] : [EOL] i = arguments [ [number] ] [EOL] leaves [ i ] . formatter . right . append ( [string] ) [EOL] elif len ( arguments ) == [number] : [EOL] start , stop = arguments [EOL] leaves [ start ] . formatter . before . extend ( [ [string] + [string] , [string] , [string] , [string] [string] , [string] [string] , [string] + [string] , [string] + [string] , [string] , [string] , ] ) [EOL] leaves [ start ] . formatter . right . append ( [string] ) [EOL] leaves [ stop ] . formatter . right . append ( [string] ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def freg ( start , stop , registration ) : [EOL] applyRegistration ( pitches , start , stop , registration ) [EOL] [EOL] [EOL] def frepitch ( start , stop , shift ) : [EOL] for leaf in pitches . leaves [ start : stop + [number] ] : [EOL] leaf . pitch = pitches . leaves [ leaf . number + shift ] . pitch . number [EOL] [EOL] [EOL] def ftwine ( * arguments ) : [EOL] apply_twine ( pitches , * arguments ) [EOL] [EOL] [EOL] def fmark ( * arguments ) : [EOL] lidercfeny . etc . transforms . set_articulations ( pitches , arguments [ - [number] ] , * arguments [ : - [number] ] ) [EOL] [EOL] [EOL] def flayer ( * arguments ) : [EOL] lidercfeny . etc . transforms . append_articulations ( pitches , arguments [ - [number] ] , * arguments [ : - [number] ] ) [EOL] [EOL] [EOL] def fturn ( start , stop ) : [EOL] min = ( [number] , [number] ) [EOL] max = None [EOL] mask = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] apply_articulations ( pitches , start , stop , ( [string] , ) , min = min , max = max , mask = mask , rests = False , overwrite = False , ) [EOL] [EOL] [EOL] def fprall ( start , stop ) : [EOL] min = ( [number] , [number] ) [EOL] max = ( [number] , [number] ) [EOL] mask = [ [number] , [number] , [number] ] + [ [number] ] * [number] [EOL] apply_articulations ( pitches , start , stop , ( [string] , ) , min = min , max = max , mask = mask , rests = False , overwrite = False , ) [EOL] [EOL] [EOL] def fbreath ( start , stop , treatment ) : [EOL] apply_breath ( breathVoices , start , stop , treatment ) [EOL] [EOL] [EOL] def fcover ( * arguments ) : [EOL] applyCoverSpanner ( attack , * arguments ) [EOL] [EOL] [EOL] def fdyn ( * arguments ) : [EOL] applyDynamics ( reference , * arguments ) [EOL] [EOL] [EOL] def fhpin ( * arguments , ** keywords ) : [EOL] applyHairpin ( nucleus , * arguments , ** keywords ) [EOL] [EOL] [EOL] def fmeas ( start , stop , material ) : [EOL] applyDynamicsMeasures ( nucleus , start , stop , material ) [EOL] [EOL] [EOL] def fseg ( start , stop , material , cut = ( [number] , ) , gap = ( [number] , ) ) : [EOL] applyDynamicsSegments ( reference , start , stop , material , cut , gap ) [EOL] [EOL] [EOL] def fswell ( start , stop , material , gap = ( [number] , ) ) : [EOL] apply_swell ( nucleus , start , stop , material , gap ) [EOL] [EOL] [EOL] def ftenuti ( start , stop , material ) : [EOL] apply_tenuti ( reference , start , stop , material ) [EOL] [EOL] [EOL] def fchange ( i , instrument ) : [EOL] leaf = pitches . leaves [ i ] [EOL] if instrument == [string] : [EOL] leaf . formatter . before . extend ( [ [string] , [string] , ] ) [EOL] leaf . formatter . right . append ( [string] ) [EOL] elif instrument == [string] : [EOL] leaf . formatter . before . extend ( [ [string] , [string] , [string] , [string] [string] , [string] , [string] , ] ) [EOL] leaf . formatter . right . append ( [string] + [string] ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import abjad [EOL] [EOL] [EOL] def split ( leaf , remote_staff_reference ) : [EOL] if hasattr ( leaf , [string] ) : [EOL] parent = leaf . _parent [EOL] index = parent . index ( leaf ) [EOL] upper = [ x for x in leaf . core if - [number] < x ] [EOL] if upper : [EOL] upper_chord = abjad . Chord ( leaf ) [EOL] for i in range ( len ( upper_chord ) ) : [EOL] upper_chord . pop ( ) [EOL] upper_chord . extend ( upper ) [EOL] lower = [ x for x in leaf . core if x <= - [number] ] [EOL] if lower : [EOL] lower_chord = abjad . Chord ( lower , leaf . duration . pair ) [EOL] lower_chord . staff = remote_staff_reference [EOL] if upper and lower : [EOL] parent [ index ] = abjad . Container ( [ upper_chord , abjad . Voice ( [ lower_chord ] ) ] , simultaneous = True ) [EOL] elif upper : [EOL] parent [ index ] = upper_chord [EOL] else : [EOL] parent [ index ] = lower_chord [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import abjad [EOL] [EOL] import lidercfeny [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def crossPiano ( voice , * arguments ) : [EOL] leaves = voice . leaves [EOL] print ( arguments ) [EOL] if arguments [ [number] ] == [string] : [EOL] ( start , stop , command , bp , includes , excludes , ( staff1 , positions1 ) , ( staff2 , positions2 , ) , ) = arguments [EOL] for i , leaf in enumerate ( leaves [ start : stop + [number] ] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if leaf . kind ( [string] ) : [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] elif ( bp < lidercfeny . etc . transforms . get_lowest_pitch ( leaf ) or start + i in includes ) and start + i not in excludes : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] abjad . override ( leaf , [string] , [string] , [string] ) [EOL] [comment] [EOL] if leaf . beam . first : [EOL] abjad . override ( leaf , [string] , [string] , ( positions1 , positions2 ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] leaf . articulations . append ( [string] ) [EOL] [comment] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] abjad . override ( leaf , [string] , [string] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if leaf . beam . first : [EOL] [comment] [EOL] [comment] [EOL] abjad . override ( leaf , [string] , [string] , ( positions2 , positions2 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] import pickle [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] import lidercfeny [EOL] from lidercfeny . etc . piano . cross import cross_staves_down [EOL] [EOL] from . . cfg import PERSISTENCEDIR , VOICESDIR [EOL] from . . pitch . graces import apply_graces [EOL] from . import palette [EOL] from . expose import crossVoice as cross [EOL] from . expose import p1Voice as rh [EOL] from . expose import p2Staff [EOL] from . expose import p2Voice as lh [EOL] from . expose import staves [EOL] from . split import split [EOL] [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] first_spanner = [number] [EOL] beam_position = - [number] [EOL] beam_below_rh = ( - [number] , - [number] ) [EOL] beam_above_lh = ( [number] , [number] ) [EOL] beamcross = [string] [EOL] stem_calc_direction = [string] [EOL] treble = ( - [number] , [number] ) [EOL] bass = ( - [number] , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . rhcore ( [number] , [number] ) [EOL] palette . rhoctavate ( [number] , [number] , treble ) [EOL] palette . rhmarks ( [number] , [number] , [ [string] , [string] ] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . rhreg ( [number] , [number] , [string] ) [EOL] palette . rhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] palette . rhbeam ( [number] , [number] , [string] , beam_position ) [EOL] palette . rhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . rhmarkdur ( [number] , [number] , [ [string] ] , ( [number] , [number] ) , [ [string] ] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] CAY , CAZ = [number] , [number] [EOL] palette . rhreg ( CAY , CAZ , [string] ) [EOL] palette . rhbeam ( CAY , CAZ , [string] , beam_position ) [EOL] palette . rhtup ( CAY , CAZ , [string] , [number] ) [EOL] palette . rhmarks ( CAY , CAZ , [ [string] ] ) [EOL] palette . rhdynspanner ( CAY , CAZ , [number] ) [EOL] palette . rhpin ( CAY , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , CAZ , [string] ) [EOL] [EOL] CBY , CBZ = [number] , [number] [EOL] palette . rhreg ( CBY , CBZ , [string] ) [EOL] palette . rhbeam ( CBY , CBZ , [string] , beam_position ) [EOL] palette . rhtup ( CBY , CBZ , [string] , [number] ) [EOL] palette . rhmarks ( CBY , CBZ , [ [string] ] ) [EOL] palette . rhmarks ( CBZ , CBZ , [ [string] ] ) [EOL] palette . rhdynspanner ( CBY , CBZ , [number] ) [EOL] leaves = baca . select ( rh [ [number] - [number] ] ) . tleaves ( ) [EOL] abjad . hairpin ( [string] , leaves ) [EOL] [EOL] CCY , CCZ = [number] , [number] [EOL] palette . rhreg ( CCY , CCZ , [string] ) [EOL] palette . rhbeam ( CCY , CCZ , [string] , beam_position ) [EOL] palette . rhtup ( CCY , CCZ , [string] , [number] ) [EOL] palette . rhmarks ( CCY , CCZ , [ [string] ] ) [EOL] palette . rhmarks ( CCY , CCY , [ [string] ] ) [EOL] palette . rhdynspanner ( CCY , CCZ , [number] ) [EOL] leaves = baca . select ( rh [ [number] - [number] ] ) . tleaves ( ) [EOL] abjad . hairpin ( [string] , leaves ) [EOL] [EOL] palette . rhdyn ( [number] , [string] ) [EOL] [EOL] CDY , CDZ = [number] , [number] [EOL] palette . rhreg ( CDY , CDZ , [string] ) [EOL] palette . rhoctspan ( [number] , CDZ , [number] , [number] , [number] ) [EOL] palette . rhbeam ( CDY , CDZ , [string] , beam_position ) [EOL] palette . rhtup ( [number] , CDZ , [string] , [number] ) [EOL] palette . rhmarks ( CDY , CDZ , [ [string] ] ) [EOL] palette . rhdynspanner ( CDY , CDZ , [number] ) [EOL] palette . rhpin ( CDY , CDZ , [string] ) [EOL] [EOL] CEY , CEZ = [number] , [number] [EOL] palette . rhreg ( CEY , CEZ , [string] ) [EOL] palette . rhmarks ( CEY , CEZ , [ [string] ] ) [EOL] palette . rhtup ( CEY , CEZ , [string] , [number] ) [EOL] palette . rhbeam ( CEY , CEZ , [string] , beam_position ) [EOL] palette . rhdynspanner ( CEY , CEZ , [number] ) [EOL] palette . rhdyn ( CEY , [string] ) [EOL] palette . rhdyn ( CEZ , [string] ) [EOL] [EOL] CFY , CFZ = [number] , [number] [EOL] palette . rhreg ( CFY , CFZ , [string] ) [EOL] palette . rhoctspan ( CFY , CFZ , [number] , [number] , [number] ) [EOL] palette . rhbeam ( CFY , CFZ , [string] , beam_position ) [EOL] palette . rhtup ( CFY , CFZ , [string] , [number] ) [EOL] palette . rhmarks ( CFY , CFZ , [ [string] ] ) [EOL] palette . rhdynspanner ( CFY , CFZ , [number] ) [EOL] palette . rhpin ( CFY , [number] , [string] ) [EOL] palette . rhpin ( [number] , CFZ , [string] ) [EOL] [EOL] CGY , CGZ = [number] , [number] [EOL] palette . rhcore ( CGY , CGZ ) [EOL] cross_staves_down ( rh . leaves [ [number] : [number] + [number] ] , p2Staff , [number] , beam_below_rh , beam_above_lh ) [EOL] palette . rhtup ( CGY , CGZ , [string] , [number] ) [EOL] palette . rhmarks ( CGY , CGZ , [ [string] ] ) [EOL] palette . rhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . rhdynspanner ( CGY , CGZ , [number] ) [EOL] palette . rhpin ( CGY , [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdynspanner ( [number] , CGZ , [number] ) [EOL] palette . rhpin ( [number] , CGZ , [string] ) [EOL] [EOL] CHY , CHZ = [number] , [number] [EOL] palette . rhreg ( CHY , CHZ , [string] ) [EOL] palette . rhclone ( [number] , [number] , - [number] ) [EOL] palette . rhmarks ( CHY , CHZ , [ [string] ] ) [EOL] palette . rhstem ( CHY , CHZ , stem_calc_direction ) [EOL] palette . rhtup ( CHY , CHZ , [string] , [number] ) [EOL] rh . leaves [ [number] ] . formatter . before . extend ( [ [string] , [string] , ] ) [EOL] cross_staves_down ( rh . leaves [ [number] : [number] + [number] ] , p2Staff , [number] , beam_below_rh , beam_above_lh ) [EOL] palette . rhdynspanner ( CHY , CHZ , [number] ) [EOL] palette . rhpin ( CHY , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , CHZ , [string] ) [EOL] [EOL] CIY , CIZ = [number] , [number] [EOL] palette . rhreg ( CIY , CIZ , [string] ) [EOL] cross_staves_down ( rh . leaves [ [number] : [number] + [number] ] , p2Staff , [number] , beam_below_rh , beam_above_lh ) [EOL] cross_staves_down ( rh . leaves [ [number] : [number] + [number] ] , p2Staff , [number] , beam_below_rh , beam_above_lh ) [EOL] palette . rhtup ( CIY , CIZ , [string] , [number] ) [EOL] rh . leaves [ [number] ] . formatter . before . extend ( [ [string] , [string] , ] ) [EOL] palette . rhbeam ( CIY , CIZ , [string] , beam_position ) [EOL] palette . rhmarks ( CIY , CIZ , [ [string] ] ) [EOL] palette . rhdynspanner ( CIY , CIZ , [number] ) [EOL] palette . rhpin ( CIY , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhdyn ( CIZ , [string] ) [EOL] [EOL] CJY , CJZ = [number] , [number] [EOL] palette . rhcycle ( CJY , CJZ , [ [number] , [number] ] ) [EOL] palette . rhoctspan ( CJY , CJZ , [number] , [number] , [number] ) [EOL] palette . rhtup ( CJY , CJZ , [string] , [number] ) [EOL] palette . rhbeam ( CJY , CJZ , [string] , beam_position ) [EOL] palette . rhmarkdur ( CJY , CJZ , [ [string] ] , ( [number] , [number] ) , [ [string] ] ) [EOL] palette . rhdynspanner ( CJY , CJZ , [number] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] DAY , DAZ = [number] , [number] [EOL] palette . rhreg ( DAY , DAZ , [string] ) [EOL] palette . rhtup ( DAY , DAZ , [string] , [number] ) [EOL] palette . rhbeam ( DAY , DAZ , [string] , beam_position ) [EOL] palette . rhmarks ( DAY , DAZ , [ [string] , [string] ] ) [EOL] palette . rhdynspanner ( DAY , DAZ , [number] ) [EOL] palette . rhdyn ( DAY , DAZ , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] EAY , EAZ = [number] , [number] [EOL] palette . rhreg ( EAY , EAZ , [string] ) [EOL] palette . rhtup ( EAY , EAZ , [string] , [number] ) [EOL] palette . rhbeam ( EAY , EAZ , [string] , beam_position ) [EOL] palette . rhmarks ( EAY , EAZ , [ [string] ] ) [EOL] palette . rhdynspanner ( EAY , EAZ , [number] ) [EOL] palette . rhdyn ( EAY , EAZ , [string] ) [EOL] rh . leaves [ [number] ] . dynamics . mark = [string] [EOL] apply_graces ( rh , [number] , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] FAY , FAZ = [number] , [number] [EOL] palette . rhcore ( FAY , FAZ ) [EOL] palette . rhtup ( FAY , [number] , [string] , [number] ) [EOL] palette . rhtup ( [number] , FAZ , [string] , [number] ) [EOL] palette . rhmarks ( FAY , FAZ , [ [string] ] ) [EOL] palette . rhdyn ( FAY , FAZ , [string] ) [EOL] palette . rhmarks ( [number] , [number] , [ [string] , [string] ] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] palette . rhmarks ( [number] , [number] , [ [string] , [string] ] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] cross_staves_down ( rh . leaves [ FAY : FAZ + [number] ] , p2Staff , - [number] , beam_below_rh , beam_above_lh ) [EOL] rh . leaves [ [number] ] . formatter . before . append ( [string] ) [EOL] rh . leaves [ [number] ] . formatter . before . append ( [string] ) [EOL] rh . leaves [ [number] ] . formatter . before . append ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] GAY , GAZ = [number] , [number] [EOL] palette . rhreg ( GAY , GAZ , [string] ) [EOL] palette . rhbeam ( GAY , GAZ , [string] , [number] ) [EOL] palette . rhtup ( GAY , GAZ , [string] , [number] ) [EOL] palette . rhmarks ( GAY , GAZ , [ [string] ] ) [EOL] palette . rhdynspanner ( GAY , GAZ , [number] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , GAZ , [string] ) [EOL] rh . leaves [ [number] ] . formatter . before . append ( [string] ) [EOL] rh . leaves [ [number] ] . formatter . before . append ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . rhreg ( [number] , [number] , [string] ) [EOL] palette . rhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] palette . rhmark ( [number] , [ [string] ] ) [EOL] [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] lidercfeny . etc . transforms . set_articulations ( cross , [ [string] ] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] palette . rhcore ( [number] , [number] ) [EOL] palette . rhclef ( [number] , [string] ) [EOL] palette . rhclef ( [number] , [string] ) [EOL] palette . rhclef ( [number] , [string] ) [EOL] palette . rhclef ( [number] , [string] ) [EOL] palette . rhmarks ( [number] , [number] , [ [string] , [string] ] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . rhreg ( [number] , [number] , [string] ) [EOL] palette . rhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] palette . rhbeam ( [number] , [number] , [string] , beam_position ) [EOL] palette . rhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . rhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . rhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . rhreg ( [number] , [number] , [string] ) [EOL] palette . rhbeam ( [number] , [number] , [string] , beam_position ) [EOL] palette . rhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . rhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . rhreg ( [number] , [number] , [string] ) [EOL] palette . rhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] palette . rhbeam ( [number] , [number] , [string] , beam_position ) [EOL] palette . rhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . rhmarkdur ( [number] , [number] , [ [string] ] , ( [number] , [number] ) , [ [string] ] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] palette . rhdyn ( [number] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] apply_graces ( rh , [number] , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . rhreg ( [number] , [number] , [string] ) [EOL] palette . rhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] palette . rhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] palette . rhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] palette . rhbeam ( [number] , [number] , [string] , beam_position ) [EOL] palette . rhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . rhmarkdur ( [number] , [number] , [ [string] ] , ( [number] , [number] ) , [ [string] ] ) [EOL] palette . rhdynspanner ( [number] , [number] , [number] ) [EOL] palette . rhdyn ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] palette . rhpin ( [number] , [number] , [string] ) [EOL] [EOL] rh [ - [number] ] [ [number] ] . formatter . before . append ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] lh_flat = - [number] [EOL] [EOL] [comment] [EOL] [EOL] palette . lhcore ( [number] , [number] ) [EOL] palette . lhoctavate ( [number] , [number] , treble ) [EOL] palette . lhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , lh_flat ) [EOL] palette . lhmarkdur ( [number] , [number] , [ [string] ] , ( [number] , [number] ) , [ [string] ] ) [EOL] [comment] [EOL] palette . lhdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . lhreg ( [number] , [number] , [string] ) [EOL] palette . lhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , lh_flat ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhmarkpitch ( [number] , [number] , [ [string] ] , [number] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] lh . leaves [ [number] ] . clef = [string] [EOL] lh . leaves [ [number] ] . clef = [string] [EOL] palette . lhreg ( [number] , [number] , [string] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , lh_flat ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . lhcore ( [number] , [number] ) [EOL] palette . lhoctavate ( [number] , [number] , treble ) [EOL] lh . leaves [ [number] ] . clef = [string] [EOL] lh . leaves [ [number] ] . beam . unspan ( ) [EOL] lh . leaves [ [number] ] . beam . unspan ( ) [EOL] lh . leaves [ [number] ] . beam . unspan ( ) [EOL] lh . leaves [ [number] ] . clef = [string] [EOL] palette . lhoctavate ( [number] , [number] , treble ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhdyn ( [number] , [number] , [string] ) [EOL] palette . lhdyn ( [number] , [number] , [string] ) [EOL] lh . leaves [ [number] ] . clef = [string] [EOL] [EOL] [comment] [EOL] [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhreg ( [number] , [number] , [string] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , lh_flat ) [EOL] palette . lhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . lhreg ( [number] , [number] , [string] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , - [number] ) [EOL] palette . lhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhdyn ( [number] , [string] ) [EOL] palette . lhdyn ( [number] , [string] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] palette . lhdyn ( [number] , [string] ) [EOL] palette . lhdyn ( [number] , [string] ) [EOL] palette . lhdyn ( [number] , [string] ) [EOL] palette . lhdyn ( [number] , [string] ) [EOL] palette . lhdyn ( [number] , [string] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] abjad . hairpin ( [string] , lh . leaves [ [number] : [number] + [number] ] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] lh . leaves [ [number] ] . dynamics . mark = [string] [EOL] [EOL] [comment] [EOL] [EOL] palette . lhcore ( [number] , [number] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , - [number] ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . lhcore ( [number] , [number] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , - [number] ) [EOL] palette . lhmarkdur ( [number] , [number] , [ [string] ] , ( [number] , [number] ) , [ [string] ] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] palette . lhpin ( [number] , [number] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] apply_graces ( lh , [number] , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . lhcore ( [number] , [number] ) [EOL] palette . lhreg ( [number] , [number] , [string] ) [EOL] palette . lhdyn ( [number] , [number] , [string] ) [EOL] palette . lhtup ( [number] , [number] , [string] , [number] ) [EOL] lh . leaves [ [number] ] . clef = [string] [EOL] lh . leaves [ [number] ] . clef = [string] [EOL] lh . leaves [ [number] ] . clef = [string] [EOL] palette . lhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , lh_flat ) , [EOL] palette . lhbeam ( [number] , [number] , [string] , [number] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , lh_flat ) [EOL] palette . lhtup ( [number] , [number] , [string] , [number] ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhdyn ( [number] , [number] , [string] ) [EOL] lh . leaves [ [number] ] . dynamics = None [EOL] [EOL] for leaf in lh . leaves [ [number] : [number] + [number] ] : [EOL] if leaf . kind ( [string] ) : [EOL] if leaf . pitch . number > [number] : [EOL] leaf . pitch . octave -= [number] [EOL] [EOL] [comment] [EOL] [EOL] palette . lhreg ( [number] , [number] , [string] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , lh_flat ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] palette . lhcore ( [number] , [number] ) [EOL] palette . lhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhclef ( [number] , [string] ) [EOL] palette . lhbeam ( [number] , [number] , [string] , lh_flat ) [EOL] palette . lhmarks ( [number] , [number] , [ [string] ] ) [EOL] palette . lhdynspanner ( [number] , [number] , [number] ) [EOL] palette . lhdyn ( [number] , [number] , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] lh [ - [number] ] . bar_line = [string] [EOL] lh . leaves [ - [number] ] . formatter . before . append ( [string] ) [EOL] lh . leaves [ - [number] ] . formatter . right . append ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] for leaf in lh . leaves : [EOL] if leaf . kind ( [string] ) : [EOL] abjad . Rest ( leaf ) [EOL] [EOL] abjad . Skip ( lh . leaves [ [number] ] ) [EOL] [EOL] for leaf in lh . leaves [ [number] : [number] + [number] ] : [EOL] abjad . Skip ( leaf ) [EOL] [EOL] [comment] [EOL] [EOL] for override in lh . spanners . get ( grob = [string] ) : [EOL] override . die ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] for leaf in ( rh . leaves [ [number] : [number] + [number] ] + rh . leaves [ [number] : [number] + [number] ] + rh . leaves [ [number] : [number] + [number] ] ) : [EOL] split ( leaf , lh . _parent ) [EOL] [EOL] [EOL] for leaf in rh . leaves [ [number] : [number] + [number] ] : [EOL] split ( leaf , lh . _parent ) [EOL] [EOL] [comment] [EOL] [EOL] for staff in staves : [EOL] for voice in staff : [EOL] for i , measure in enumerate ( voice ) : [EOL] measure . comments . before . append ( [string] % ( i + [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for leaf in abjad . iterate ( staves ) . leaves ( ) : [EOL] leaf . formatter . right = [ x for x in leaf . formatter . right if [string] not in x and [string] not in x ] [EOL] [EOL] [comment] [EOL] [EOL] abjad . label ( rh ) . with_leaf_indices ( ) [EOL] abjad . label ( lh ) . with_leaf_indices ( ) [EOL] [EOL] palette . rhoctspan ( [number] , [number] , [number] , [number] , [number] ) [EOL] rh . leaves [ [number] ] . dynamics = [string] [EOL] rh . leaves [ [number] ] . articulations . append ( [string] ) [EOL] rh . leaves [ [number] ] . articulations . append ( [string] ) [EOL] rh . leaves [ [number] ] . pitches = [ [number] , [number] , [number] ] [comment] [EOL] rh . leaves [ [number] ] . articulations . append ( [string] ) [EOL] [EOL] for leaf in lh . leaves [ [number] : [number] + [number] ] : [EOL] abjad . Rest ( leaf ) [EOL] [EOL] for leaf in lh . leaves [ [number] : [number] + [number] ] : [EOL] abjad . Rest ( leaf ) [EOL] [EOL] abjad . Chord ( lh . leaves [ [number] ] ) [EOL] lh . leaves [ [number] ] . pitches = [ x . number for x in rh . leaves [ [number] ] . pitches ] [EOL] abjad . Rest ( rh . leaves [ [number] ] ) [EOL] rh . leaves [ [number] ] . staff = None [EOL] [EOL] rh . leaves [ [number] ] . articulations . append ( [string] ) [EOL] rh . leaves [ [number] ] . articulations . append ( [string] ) [EOL] [EOL] abjad . Rest ( lh . leaves [ [number] ] ) [EOL] lh . leaves [ [number] ] . duration = ( [number] , [number] ) [EOL] leaf = rh . leaves [ [number] ] [EOL] chord = abjad . Chord ( [ x . number for x in leaf . pitches ] , leaf . duration . pair ) [EOL] abjad . attach ( abjad . Articulation ( [string] ) , chord ) [EOL] lh [ [number] - [number] ] . append ( chord ) [EOL] leaf . staff = None [EOL] abjad . Rest ( leaf ) [EOL] [EOL] lh [ [number] - [number] ] . leaves [ [number] ] . duration = ( [number] , [number] ) [EOL] lh [ [number] - [number] ] . append ( abjad . Rest ( ( [number] , [number] ) ) ) [EOL] [EOL] [comment] [EOL] abjad . label ( lh ) . with_leaf_indices ( ) [EOL] [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Note ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] lh [ [number] - [number] ] . leaves [ [number] ] . pitch = - [number] [EOL] lh [ [number] - [number] ] . leaves [ [number] ] . articulations . append ( [string] ) [EOL] [EOL] rh . leaves [ [number] ] . articulations . append ( [string] ) [EOL] [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Note ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] lh [ [number] - [number] ] . leaves [ [number] ] . pitch = - [number] [EOL] lh [ [number] - [number] ] . leaves [ [number] ] . dynamics = [string] [EOL] rh [ [number] - [number] ] . leaves [ [number] ] . staff = None [EOL] abjad . Rest ( rh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] abjad . Rest ( lh [ [number] - [number] ] . leaves [ [number] ] ) [EOL] [EOL] rh [ [number] - [number] ] . pop ( ) [EOL] rh [ [number] - [number] ] . extend ( [ abjad . Chord ( [ [number] , [number] ] , ( [number] , [number] ) ) , abjad . Note ( [number] , ( [number] , [number] ) ) , abjad . Rest ( ( [number] , [number] ) ) ] ) [EOL] rh [ [number] - [number] ] . leaves [ [number] ] . articulations . append ( [string] ) [EOL] rh [ [number] - [number] ] . leaves [ [number] ] . dynamics = [string] [EOL] rh [ [number] - [number] ] . leaves [ [number] ] . articulations . append ( [string] ) [EOL] rh [ [number] - [number] ] . leaves [ [number] ] . dynamics = [string] [EOL] abjad . override ( rh [ [number] - [number] ] ) . dynamic_line_spanner . staff_padding = [number] [EOL] lh [ [number] - [number] ] . pop ( ) [EOL] lh [ [number] - [number] ] . extend ( [ abjad . Chord ( [ - [number] , - [number] ] , ( [number] , [number] ) ) , abjad . Chord ( [ - [number] , - [number] ] , ( [number] , [number] ) ) , abjad . Rest ( ( [number] , [number] ) ) , ] ) [EOL] lh [ [number] - [number] ] . leaves [ [number] ] . articulations . append ( [string] ) [EOL] lh [ [number] - [number] ] . leaves [ [number] ] . articulations . append ( [string] ) [EOL] lh [ [number] - [number] ] . leaves [ [number] ] . clef = [string] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] pickle . dump ( staves , pointer ) [EOL] [EOL] open ( VOICESDIR / [string] , [string] ) . write ( staves [ [number] ] [ [number] ] . format ) [EOL] open ( VOICESDIR / [string] , [string] ) . write ( staves [ [number] ] [ [number] ] . format ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import abjad [EOL] [EOL] [EOL] def cross_staves_down ( local_leaves , remote_staff , breakpitch , local_beam_positions , remote_beam_positions , ) : [EOL] for leaf in abjad . iterate ( local_leaves ) . leaves ( ) : [EOL] if ( isinstance ( leaf , abjad . Note ) and leaf . pitch . number <= breakpitch ) or ( isinstance ( leaf , abjad . Chord ) and leaf . pitches [ [number] ] . number <= breakpitch ) : [EOL] leaf . staff = remote_staff [EOL] abjad . override ( leaf , [string] , [string] , [string] ) [EOL] [comment] [EOL] if leaf . beam . opening : [EOL] abjad . override ( leaf , [string] , [string] , remote_beam_positions ) [EOL] elif isinstance ( leaf , ( abjad . Note , abjad . Chord ) ) : [EOL] abjad . override ( leaf , [string] , [string] , [string] ) [EOL] [comment] [EOL] if leaf . beam . opening : [EOL] abjad . override ( leaf , [string] , [string] , local_beam_positions ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] import quicktions [EOL] [EOL] import lidercfeny [EOL] [EOL] from . . dynamics . dynamics import applyDynamics [EOL] from . . pitch . register import applyRegistration [EOL] from . expose import p1Voice as rh [EOL] from . expose import p2Staff [EOL] from . expose import p2Voice as lh [EOL] from . utils import crossPiano [EOL] [EOL] [EOL] def set_articulations_by_pitch ( voice , start , stop , articulations , min ) : [EOL] [docstring] [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] for leaf in leaves [ start : stop + [number] ] : [EOL] if isinstance ( leaf , ( abjad . Note , abjad . Chord ) ) and min <= abjad . spget ( leaf ) : [EOL] leaf . articulations = articulations [EOL] [EOL] [EOL] def set_articulations_by_duration ( voice , start , stop , long , min , short ) : [EOL] [docstring] [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] leaves = list ( leaves ) [EOL] min = quicktions . Fraction ( * min ) [EOL] for leaf in leaves [ start : stop + [number] ] : [EOL] if isinstance ( leaf , ( abjad . Note , abjad . Chord ) ) : [EOL] if min <= abjad . get . duration ( leaf ) : [EOL] leaf . articulations = long [EOL] else : [EOL] leaf . articulations = short [EOL] [EOL] [EOL] def clone_pitches ( voice , start , stop , offset ) : [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] leaves = list ( leaves ) [EOL] for i , leaf in enumerate ( leaves [ start : stop + [number] ] ) : [EOL] if isinstance ( leaf , abjad . Note ) : [EOL] leaf . pitch = leaves [ start + i + offset ] . pitch . pair [EOL] [EOL] [EOL] def cross_staves_down ( voice , start , stop , bp , target , includes = [ ] , excludes = [ ] , topBeamPositions = None , bottomBeamPositions = None , ) : [EOL] [docstring] [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] leaves = list ( leaves ) [EOL] for j , leaf in enumerate ( leaves [ start : stop + [number] ] ) : [EOL] i = start + j [EOL] if isinstance ( leaf , abjad . Note ) : [EOL] [comment] [EOL] if ( bp <= lidercfeny . etc . transforms . get_lowest_pitch ( leaf ) or i in includes ) and i not in excludes : [EOL] leaf . staff = target [EOL] else : [EOL] abjad . octavate ( leaf , base = ( - [number] , [number] ) ) [EOL] [EOL] [EOL] def cross_staves_up ( leaves , start , stop , bp , target ) : [EOL] [docstring] [EOL] for i , leaf in enumerate ( leaves [ start : stop + [number] ] ) : [EOL] if leaf . note : [EOL] if bp < leaf . pitch . number : [EOL] leaf . staff = target [EOL] else : [EOL] abjad . octavate ( leaf , base = ( - [number] , [number] ) ) [EOL] [EOL] [EOL] def set_pitches_by_pitch_cycle ( voice , start , stop , pcyc ) : [EOL] leaves = abjad . iterate ( voice ) . leaves ( ) [EOL] leaves = list ( leaves ) [EOL] for j , leaf in enumerate ( leaves [ start : stop + [number] ] ) : [EOL] [comment] [EOL] pitch = pcyc [ j % len ( pcyc ) ] [EOL] leaf . pitch = pitch [EOL] [EOL] [EOL] def split_hands ( list_ ) : [EOL] [docstring] [EOL] [comment] [EOL] if max ( list_ ) - min ( list_ ) <= [number] : [EOL] upper = list_ [ : ] [EOL] lower = [ ] [EOL] else : [EOL] mid = ( max ( list_ ) - min ( list_ ) ) / [number] + min ( list_ ) [EOL] upper = [ _ for _ in list_ if mid <= _ ] [EOL] lower = [ _ for _ in list_ if _ < mid ] [EOL] return upper , lower [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def set_pitches_by_split_hands ( leaves , start , stop , crossLeaves ) : [EOL] [docstring] [EOL] for j , leaf in enumerate ( leaves [ start : stop + [number] ] ) : [EOL] i = start + j [EOL] if isinstance ( leaf , abjad . Note ) : [EOL] [comment] [EOL] upper , lower = split_hands ( leaf . core ) [EOL] if lower == [ ] : [EOL] if - [number] < min ( upper ) : [EOL] leaf . core = upper [EOL] [comment] [EOL] [comment] [EOL] if len ( leaf . core ) == [number] : [EOL] leaf . pitch = leaf . core [ [number] ] [EOL] else : [EOL] raise Exception ( [string] ) [EOL] abjad . octavate ( leaf ) [EOL] else : [EOL] [comment] [EOL] leaf . caster . toRest ( ) [EOL] [comment] [EOL] cl = crossLeaves [ i ] [EOL] cl . core = upper [EOL] [comment] [EOL] cl . caster . toNote ( ) [EOL] [comment] [EOL] cl . setPitches ( cl . core ) [EOL] else : [EOL] leaf . core = upper [EOL] [comment] [EOL] [comment] [EOL] if len ( leaf . core ) == [number] : [EOL] leaf . pitch = leaf . core [ [number] ] [EOL] else : [EOL] raise Exception ( [string] ) [EOL] abjad . octavate ( leaf ) [EOL] [comment] [EOL] print ( i , lower ) [EOL] cl = crossLeaves [ i ] [EOL] cl . core = lower [EOL] print ( cl , cl . core , [string] ) [EOL] [comment] [EOL] cl . caster . toNote ( ) [EOL] [comment] [EOL] [comment] [EOL] if len ( cl . core ) == [number] : [EOL] cl . pitch = cl . core [ [number] ] [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def rhcore ( start , stop ) : [EOL] lidercfeny . etc . transforms . set_pitch_iterator ( rh , start , stop , [string] ) [EOL] [EOL] [EOL] def lhcore ( start , stop ) : [EOL] lidercfeny . etc . transforms . set_pitch_iterator ( lh , start , stop , [string] ) [EOL] [EOL] [EOL] def rhreg ( start , stop , registration ) : [EOL] applyRegistration ( rh , start , stop , registration ) [EOL] [EOL] [EOL] def lhreg ( start , stop , registration ) : [EOL] applyRegistration ( lh , start , stop , registration ) [EOL] [EOL] [EOL] def rhclone ( start , stop , offset ) : [EOL] clone_pitches ( rh , start , stop , offset ) [EOL] [EOL] [EOL] def lhclone ( start , stop , offset ) : [EOL] clone_pitches ( lh , start , stop , offset ) [EOL] [EOL] [EOL] def rhcycle ( start , stop , pcyc ) : [EOL] set_pitches_by_pitch_cycle ( rh , start , stop , pcyc ) [EOL] [EOL] [EOL] def lhcycle ( start , stop , pcyc ) : [EOL] set_pitches_by_pitch_cycle ( lh , start , stop , pcyc ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def rhmarks ( start , stop , articulations ) : [EOL] lidercfeny . etc . transforms . set_articulations ( rh , articulations , start , stop ) [EOL] [EOL] [EOL] def lhmarks ( start , stop , articulations ) : [EOL] lidercfeny . etc . transforms . set_articulations ( lh , articulations , start , stop ) [EOL] [EOL] [EOL] def rhmark ( start , articulations ) : [EOL] lidercfeny . etc . transforms . set_articulations ( rh , articulations , start , start ) [EOL] [EOL] [EOL] def lhmark ( start , articulations ) : [EOL] lidercfeny . etc . transforms . set_articulations ( lh , articulations , start , start ) [EOL] [EOL] [EOL] def rhmarkpitch ( start , stop , articulations , min ) : [EOL] set_articulations_by_pitch ( rh , start , stop , articulations , min ) [EOL] [EOL] [EOL] def lhmarkpitch ( start , stop , articulations , min ) : [EOL] set_articulations_by_pitch ( lh , start , stop , articulations , min ) [EOL] [EOL] [EOL] def rhmarkdur ( start , stop , long , min , short ) : [EOL] set_articulations_by_duration ( rh , start , stop , long , min , short ) [EOL] [EOL] [EOL] def lhmarkdur ( start , stop , long , min , short ) : [EOL] set_articulations_by_duration ( lh , start , stop , long , min , short ) [EOL] [EOL] [EOL] def rhdyn ( * arguments , ** keywords ) : [EOL] applyDynamics ( rh , * arguments , ** keywords ) [EOL] [EOL] [EOL] def lhdyn ( * arguments , ** keywords ) : [EOL] applyDynamics ( lh , * arguments , ** keywords ) [EOL] [EOL] [EOL] def rhpin ( start , stop , hpstr ) : [EOL] leaves = rh . leaves [ start : stop + [number] ] [EOL] leaves = baca . select ( leaves ) . tleaves ( ) [EOL] lidercfeny . etc . transforms . clear_dynamics ( leaves ) [EOL] abjad . hairpin ( hpstr , leaves ) [EOL] [EOL] [EOL] def lhpin ( start , stop , hpstr ) : [EOL] leaves = lh . leaves [ start : stop + [number] ] [EOL] leaves = baca . select ( leaves ) . tleaves ( ) [EOL] lidercfeny . etc . transforms . clear_dynamics ( leaves ) [EOL] abjad . hairpin ( hpstr , leaves ) [EOL] [EOL] [EOL] def rhdynspanner ( start , stop , staffPadding = False , direction = False ) : [EOL] if staffPadding : [EOL] abjad . override ( rh . leaves [ start : stop + [number] ] , [string] , [string] , staffPadding , ) [EOL] if direction : [EOL] abjad . override ( rh . leaves [ start : stop + [number] ] , [string] , [string] , direction , ) [EOL] [EOL] [EOL] def lhdynspanner ( start , stop , staffPadding = None , direction = None ) : [EOL] if staffPadding : [EOL] abjad . override ( lh . leaves [ start : stop + [number] ] , [string] , [string] , staffPadding , ) [EOL] if direction : [EOL] abjad . override ( lh . leaves [ start : stop + [number] ] , [string] , [string] , direction , ) [EOL] [EOL] [EOL] def rhoctspan ( start , stop , away , home , padding ) : [EOL] abjad . OttavaSpanner ( rh . leaves [ start : stop + [number] ] , away , home ) [EOL] abjad . override ( rh . leaves [ start : stop + [number] ] , [string] , [string] , [string] , padding , ) [EOL] [EOL] [EOL] def lhoctspan ( start , stop , away , home , padding ) : [EOL] abjad . OttavaSpanner ( lh . leaves [ start : stop + [number] ] , away , home ) [EOL] abjad . override ( lh . leaves [ start : stop + [number] ] , [string] , [string] , [string] , padding , ) [EOL] [EOL] [EOL] def rhoctavate ( start , stop , base ) : [EOL] lidercfeny . etc . transforms . octavate_leaves ( rh , start , stop , base ) [EOL] [EOL] [EOL] def lhoctavate ( start , stop , base ) : [EOL] lidercfeny . etc . transforms . octavate_leaves ( lh , start , stop , base ) [EOL] [EOL] [EOL] def rhbeam ( start , stop , direction , position ) : [EOL] leaves = rh . leaves [ start : stop + [number] ] [EOL] abjad . override ( leaves , [string] , [string] , direction ) [EOL] abjad . override ( leaves , [string] , [string] , ( position , position ) ) [EOL] [EOL] [EOL] def lhbeam ( start , stop , direction , position ) : [EOL] leaves = lh . leaves [ start : stop + [number] ] [EOL] abjad . override ( leaves , [string] , [string] , direction ) [EOL] abjad . override ( leaves , [string] , [string] , ( position , position ) ) [EOL] [EOL] [EOL] def rhtup ( start , stop , direction , padding ) : [EOL] leaves = rh . leaves [ start : stop + [number] ] [EOL] abjad . override ( leaves , [string] , [string] , direction ) [EOL] abjad . override ( leaves , [string] , [string] , padding ) [EOL] [EOL] [EOL] def lhtup ( start , stop , direction , padding ) : [EOL] leaves = lh . leaves [ start : stop + [number] ] [EOL] abjad . override ( leaves , [string] , [string] , direction ) [EOL] abjad . override ( leaves , [string] , [string] , padding ) [EOL] [EOL] [EOL] def rhcross ( * arguments ) : [EOL] crossPiano ( rh , * arguments ) [EOL] [EOL] [EOL] def lhcross ( * arguments ) : [EOL] crossPiano ( lh , * arguments ) [EOL] [EOL] [EOL] def rhCROSS ( start , stop , bp ) : [EOL] cross_staves_down ( rh , start , stop , bp , p2Staff ) [EOL] [EOL] [EOL] def rhstem ( start , stop , direction ) : [EOL] leaves = rh . leaves [ start : stop + [number] ] [EOL] abjad . override ( leaves , [string] , [string] , direction ) [EOL] [EOL] [EOL] def lhstem ( start , stop , direction ) : [EOL] leaves = lh . leaves [ start : stop + [number] ] [EOL] abjad . override ( leaves , [string] , [string] , direction ) [EOL] [EOL] [EOL] def rhclef ( i , clef ) : [EOL] rh . leaves [ i ] . clef = clef [EOL] [EOL] [EOL] def lhclef ( i , clef ) : [EOL] lh . leaves [ i ] . clef = clef [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pickle [EOL] [EOL] import abjad [EOL] [EOL] from lidercfeny . etc . cfg import PERSISTENCEDIR [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] eighths = pickle . load ( pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] staves = pickle . load ( pointer ) [EOL] [EOL] p1Staff = staves [ [number] ] [EOL] p1Voice = p1Staff [ [string] ] [EOL] p1Leaves = abjad . select ( p1Staff ) . leaves ( ) [EOL] p1Staff . name = [string] [EOL] p1Voice . name = [string] [EOL] [EOL] p2Staff = staves [ [number] ] [EOL] p2Voice = p2Staff [ [string] ] [EOL] p2Leaves = abjad . select ( p2Staff ) . leaves ( ) [EOL] p2Staff . name = [string] [EOL] p2Voice . name = [string] [EOL] [EOL] crossVoice = p1Voice . copy ( ) [EOL] crossVoice . name = [string] [EOL] p2Staff . insert ( [number] , crossVoice ) [EOL] p2Staff . brackets = [string] [EOL] [EOL] [comment] [EOL] for leaf in crossVoice . leaves : [EOL] abjad . Skip ( leaf ) [EOL] leaf . beam . counts = None [EOL] leaf . beam . unspan ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] crossLeaves = abjad . select ( crossVoice ) . leaves ( ) [EOL] [EOL] abjad . label ( p1Staff . leaves ) . with_indices ( ) [EOL] abjad . label ( p2Staff [ [number] ] . leaves ) . with_indices ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] [EOL] import lidercfeny [EOL] [EOL] from . resevoir import get_hairpin [EOL] [EOL] [EOL] def historical_notes_only_pins ( voice , start , stop , material ) : [EOL] leaves = voice . leaves [ start : stop + [number] ] [EOL] lidercfeny . etc . transforms . clear_dynamics ( leaves ) [EOL] parts = lidercfeny . etc . transforms . hpartition_notes_only ( leaves ) [EOL] for i , part in enumerate ( parts ) : [EOL] hairpin = get_hairpin ( material , i ) [EOL] if [number] < len ( part ) : [EOL] abjad . hairpin ( hairpin , part ) [EOL] else : [EOL] part [ [number] ] . dynamics = hairpin . split ( ) [ [number] ] [EOL] [EOL] [EOL] def historical_rest_terminated_pins ( voice , start , stop , material ) : [EOL] leaves = voice . leaves [ start : stop + [number] ] [EOL] lidercfeny . etc . transforms . clear_dynamics ( leaves ) [EOL] parts = lidercfeny . etc . transforms . hpartition_rest_terminated ( leaves ) [EOL] for i , part in enumerate ( parts ) : [EOL] hairpin = get_hairpin ( material , i ) [EOL] if [number] < len ( part ) : [EOL] abjad . hairpin ( hairpin , part ) [EOL] else : [EOL] part [ [number] ] . dynamics = hairpin . split ( ) [ [number] ] [EOL] [EOL] [EOL] def hairpin_to_measures ( voice , start , stop , hpstr , trim = False ) : [EOL] measures = voice [ : ] [EOL] for i , measure in enumerate ( measures [ start - [number] : stop ] ) : [EOL] lidercfeny . etc . transforms . clear_dynamics ( measure ) [EOL] if trim : [EOL] leaves = baca . select ( measure ) . tleaves ( ) [EOL] else : [EOL] leaves = baca . select ( measure ) . leaves ( ) [EOL] abjad . hairpin ( [string] , leaves ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import baca [EOL] [EOL] [EOL] def _G ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , [number] ) . flatten ( ) [EOL] [EOL] [EOL] def _Gt ( list_ ) : [EOL] unflattened = baca . sequence ( list_ ) . helianthate ( [number] , [number] ) [EOL] result = [ ] [EOL] for sublist in unflattened : [EOL] result . extend ( sublist ) [EOL] return result [EOL] [EOL] [EOL] _MARKS = { [string] : _G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : _G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : _G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : _G ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : _G ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : _G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : _G ( [ [ [string] ] ] ) , [string] : _G ( [ [ [string] ] ] ) , [string] : _G ( [ [ [string] ] ] ) , [string] : _G ( [ [ [string] ] ] ) , [string] : _G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : _G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , } [EOL] [EOL] [EOL] _HAIRPINS = { [string] : [ [string] , [string] ] , [string] : _Gt ( [ [ [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : _Gt ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , ] ) , [string] : _Gt ( [ [ [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , } [EOL] [EOL] [EOL] def get_mark ( material , i ) : [EOL] try : [EOL] return _MARKS [ material ] [ i % len ( _MARKS [ material ] ) ] [EOL] except KeyError : [EOL] return material [EOL] [EOL] [EOL] def get_hairpin ( material , i ) : [EOL] try : [EOL] return _HAIRPINS [ material ] [ i % len ( _HAIRPINS [ material ] ) ] [EOL] except KeyError : [EOL] return material [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Dict , List , Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] import quicktions [EOL] [EOL] import lidercfeny [EOL] [EOL] [EOL] def partition_leaves ( leaves , type = [string] , cut = ( [number] , ) , gap = ( [number] , ) ) : [EOL] [docstring] [EOL] [EOL] cut = quicktions . Fraction ( * cut ) [EOL] gap = quicktions . Fraction ( * gap ) [EOL] result = [ [ ] ] [EOL] [EOL] if type == [string] : [EOL] for leaf in leaves : [EOL] lastChunk = result [ - [number] ] [EOL] if len ( lastChunk ) == [number] : [EOL] lastChunk . append ( leaf ) [EOL] else : [EOL] lastLeaf = lastChunk [ - [number] ] [EOL] if isinstance ( lastLeaf , abjad . Note ) == isinstance ( leaf , abjad . Note ) : [EOL] lastChunk . append ( leaf ) [EOL] else : [EOL] result . append ( [ leaf ] ) [EOL] [EOL] elif type == [string] : [EOL] for leaf in leaves : [EOL] lastChunk = result [ - [number] ] [EOL] if isinstance ( leaf , abjad . Note ) : [EOL] lastChunk . append ( leaf ) [EOL] else : [EOL] if [number] < len ( lastChunk ) : [EOL] result . append ( [ ] ) [EOL] if result [ - [number] ] == [ ] : [EOL] result . pop ( ) [EOL] [EOL] elif type == [string] : [EOL] firstResult = partition_leaves ( leaves , type = [string] ) [EOL] if not isinstance ( firstResult [ [number] ] [ [number] ] , abjad . Note ) : [EOL] firstResult . pop ( [number] ) [EOL] result = [ firstResult . pop ( [number] ) ] [EOL] for chunk in firstResult : [EOL] lastChunk = result [ - [number] ] [EOL] if isinstance ( chunk [ [number] ] , abjad . Note ) : [EOL] [comment] [EOL] if len ( lastChunk ) == [number] : [EOL] lastChunk . extend ( chunk ) [EOL] [comment] [EOL] elif isinstance ( lastChunk [ - [number] ] , abjad . Note ) : [EOL] result . append ( chunk ) [EOL] [comment] [EOL] else : [EOL] lastChunk . extend ( chunk ) [EOL] else : [EOL] [comment] [EOL] if abjad . get . duration ( chunk ) <= cut : [EOL] lastChunk . extend ( chunk ) [EOL] else : [EOL] result . append ( [ ] ) [EOL] if result [ - [number] ] == [ ] : [EOL] result . pop ( ) [EOL] [EOL] elif type == [string] : [EOL] firstResult = partition_leaves ( leaves , type = [string] ) [EOL] if not isinstance ( firstResult [ [number] ] [ [number] ] , abjad . Note ) : [EOL] firstResult . pop ( [number] ) [EOL] result = [ [ [ ] ] ] [EOL] for chunk in firstResult : [EOL] lastPair = result [ - [number] ] [EOL] lastChunk = lastPair [ - [number] ] [EOL] if isinstance ( chunk [ [number] ] , abjad . Note ) : [EOL] lastChunk . extend ( chunk ) [EOL] else : [EOL] [comment] [EOL] if abjad . get . duration ( chunk ) <= cut : [EOL] lastChunk . extend ( chunk ) [EOL] [comment] [EOL] elif cut < abjad . get . duration ( chunk ) <= gap : [EOL] if len ( lastPair ) == [number] : [EOL] lastPair . append ( [ ] ) [EOL] elif len ( lastPair ) == [number] : [EOL] result . append ( [ [ ] ] ) [EOL] else : [EOL] raise Exception [EOL] [comment] [EOL] elif gap < abjad . get . duration ( chunk ) : [EOL] result . append ( [ [ ] ] ) [EOL] else : [EOL] raise Exception [EOL] lastChunk = result [ - [number] ] [ - [number] ] [EOL] for m in reversed ( lastChunk ) : [EOL] if not isinstance ( m , abjad . Note ) : [EOL] lastChunk . pop ( - [number] ) [EOL] else : [EOL] break [EOL] for i , sublist in enumerate ( result ) : [EOL] result [ i ] = tuple ( sublist ) [EOL] [EOL] elif type == [string] : [EOL] for leaf in leaves : [EOL] lastChunk = result [ - [number] ] [EOL] if isinstance ( leaf , abjad . Rest ) : [EOL] lastChunk . append ( leaf ) [EOL] else : [EOL] if [number] < len ( lastChunk ) : [EOL] result . append ( [ ] ) [EOL] if result [ - [number] ] == [ ] : [EOL] result . pop ( ) [EOL] [EOL] elif type == [string] : [EOL] for leaf in leaves : [EOL] lastChunk = result [ - [number] ] [EOL] if isinstance ( leaf , abjad . Note ) : [EOL] if len ( lastChunk ) == [number] : [EOL] lastChunk . append ( leaf ) [EOL] else : [EOL] lastLeaf = lastChunk [ - [number] ] [EOL] if isinstance ( lastLeaf , abjad . Note ) : [EOL] lastChunk . append ( leaf ) [EOL] else : [EOL] result . append ( [ leaf ] ) [EOL] elif isinstance ( leaf , abjad . Rest ) : [EOL] if [number] < len ( lastChunk ) : [EOL] lastLeaf = lastChunk [ - [number] ] [EOL] if isinstance ( lastLeaf , abjad . Note ) : [EOL] lastChunk . append ( leaf ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] elif type == [string] : [EOL] firstResult = partition_leaves ( leaves , type = [string] ) [EOL] if not isinstance ( firstResult [ [number] ] [ [number] ] , abjad . Note ) : [EOL] firstResult . pop ( [number] ) [EOL] result = [ [ firstResult . pop ( [number] ) ] ] [EOL] bridged = False [EOL] bridgeNext = False [EOL] for chunk in firstResult : [EOL] if not isinstance ( chunk [ [number] ] , abjad . Note ) : [EOL] result [ - [number] ] [ - [number] ] . append ( chunk [ [number] ] ) [EOL] [comment] [EOL] if abjad . get . duration ( chunk ) <= gap : [EOL] if not bridged : [EOL] bridgeNext = True [EOL] else : [EOL] if bridgeNext : [EOL] result [ - [number] ] . append ( chunk ) [EOL] bridged = True [EOL] bridgeNext = False [EOL] else : [EOL] result . append ( [ chunk ] ) [EOL] bridged = False [EOL] bridgeNext = False [EOL] for i , sublist in enumerate ( result ) : [EOL] result [ i ] = tuple ( sublist ) [EOL] [EOL] elif type == [string] : [EOL] firstResult = partition_leaves ( leaves , type = [string] ) [EOL] if not isinstance ( firstResult [ [number] ] [ [number] ] , abjad . Note ) : [EOL] firstResult . pop ( [number] ) [EOL] result = [ [ firstResult . pop ( [number] ) ] ] [EOL] bridged = False [EOL] bridgeNext = False [EOL] for chunk in firstResult : [EOL] if not isinstance ( chunk [ [number] ] , abjad . Note ) : [EOL] if abjad . get . duration ( chunk ) <= gap : [EOL] if not bridged : [EOL] bridgeNext = True [EOL] else : [EOL] if bridgeNext : [EOL] result [ - [number] ] . append ( chunk ) [EOL] bridged = True [EOL] bridgeNext = False [EOL] else : [EOL] result . append ( [ chunk ] ) [EOL] bridged = False [EOL] bridgeNext = False [EOL] for i , sublist in enumerate ( result ) : [EOL] result [ i ] = tuple ( sublist ) [EOL] [EOL] else : [EOL] raise ValueError [EOL] [EOL] return result [EOL] [EOL] [EOL] def segment_leaves ( leaves , cut = ( [number] , ) , gap = ( [number] , ) ) : [EOL] [docstring] [EOL] [EOL] def trim_empty_lists ( leaf ) : [EOL] for note_head in reversed ( leaf ) : [EOL] if note_head == [ ] : [EOL] leaf . pop ( - [number] ) [EOL] else : [EOL] break [EOL] [EOL] def trim_rests ( leaves ) : [EOL] for leaf in reversed ( leaves ) : [EOL] if isinstance ( leaf , abjad . Rest ) : [EOL] leaves . pop ( - [number] ) [EOL] else : [EOL] break [EOL] [EOL] cut = quicktions . Fraction ( * cut ) [EOL] gap = quicktions . Fraction ( * gap ) [EOL] parts = partition_leaves ( leaves ) [EOL] if not isinstance ( parts [ [number] ] [ [number] ] , abjad . Note ) : [EOL] parts . pop ( [number] ) [EOL] segments = [ [ [ ] ] ] [EOL] for part in parts : [EOL] segment = segments [ - [number] ] [EOL] stage = segment [ - [number] ] [EOL] if isinstance ( part [ [number] ] , abjad . Note ) : [EOL] stage . extend ( part ) [EOL] else : [EOL] if abjad . get . duration ( part ) <= cut : [EOL] stage . extend ( part ) [EOL] elif cut < abjad . get . duration ( part ) < gap : [EOL] segment . append ( [ ] ) [EOL] elif gap <= abjad . get . duration ( part ) : [EOL] segments . append ( [ [ ] ] ) [EOL] else : [EOL] raise Exception [EOL] trim_empty_lists ( segments [ - [number] ] ) [EOL] trim_empty_lists ( segments ) [EOL] trim_rests ( segments [ - [number] ] [ - [number] ] ) [EOL] for i , sublist in enumerate ( segments ) : [EOL] segments [ i ] = tuple ( sublist ) [EOL] return segments [EOL] [EOL] [EOL] def G ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , [number] ) [EOL] [EOL] [EOL] def Gt ( list_ ) : [EOL] unflattened = baca . sequence ( list_ ) . helianthate ( [number] , [number] ) [EOL] result = [ ] [EOL] for sublist in unflattened : [EOL] result . extend ( sublist ) [EOL] return result [EOL] [EOL] [EOL] source = { [string] : G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] ] ] ) , [string] : G ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : G ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : G ( [ [ [string] ] ] ) , [string] : G ( [ [ [string] ] ] ) , [string] : G ( [ [ [string] ] ] ) , [string] : G ( [ [ [string] ] ] ) , [string] : G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , [string] : G ( [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) , } [EOL] [EOL] [EOL] def applyLeafDynamic ( leaf , material , i ) : [EOL] if material in source . keys ( ) : [EOL] dynamic = source [ material ] [ i % len ( source [ material ] ) ] [EOL] else : [EOL] dynamic = material [EOL] leaf . dynamics = dynamic [EOL] [EOL] [EOL] def applyDynamics ( voice , * arguments , ** keywords ) : [EOL] leaves = voice . leaves [EOL] min = quicktions . Fraction ( * keywords . get ( [string] , ( [number] , [number] ) ) ) [EOL] if len ( arguments ) == [number] : [EOL] i , material = arguments [EOL] leaf = leaves [ i ] [EOL] if min <= leaf . duration . prolated : [EOL] applyLeafDynamic ( leaf , material , i ) [EOL] elif len ( arguments ) == [number] : [EOL] start , stop , material = arguments [EOL] chunk = leaves [ start : stop + [number] ] [EOL] for j , leaf in enumerate ( chunk ) : [EOL] if leaf . kind ( ( [string] , [string] ) ) and min <= leaf . duration . prolated : [EOL] i = j + start [EOL] applyLeafDynamic ( leaf , material , i ) [EOL] [EOL] [EOL] hairpinMaterials = { [string] : ( [string] , [string] , [string] ) , [string] : ( [string] , [string] , [string] ) , [string] : ( [string] , [string] , [string] ) , } [EOL] [EOL] [EOL] swellComponents = { [string] : ( [string] , [string] , [string] , [string] , [string] ) , [string] : ( [string] , [string] , [string] , [string] , [string] ) , [string] : ( [string] , [string] , [string] , [string] , [string] ) , } [EOL] [EOL] [EOL] def applyPredefinedHairpin ( leaves , material ) : [EOL] assert isinstance ( leaves , ( tuple , list ) ) [EOL] lidercfeny . etc . transforms . clear_dynamics ( leaves ) [EOL] if material in hairpinMaterials . keys ( ) : [EOL] startMark , pin , stopMark = hairpinMaterials [ material ] [EOL] hairpin = [string] . join ( [ startMark , pin , stopMark ] ) [EOL] if isinstance ( leaves , tuple ) : [EOL] abjad . hairpin ( hairpin , leaves [ [number] ] ) [EOL] elif isinstance ( leaves , list ) : [EOL] abjad . hairpin ( hairpin , leaves ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] elif material in swellComponents . keys ( ) : [EOL] startMark , stage1 , peakMark , stage2 , stopMark = swellComponents [ material ] [EOL] first = [string] . join ( [ startMark , stage1 , peakMark ] ) [EOL] second = [string] . join ( [ stage2 , stopMark ] ) [EOL] [comment] [EOL] if len ( leaves ) == [number] : [EOL] theRun = leaves [ [number] ] [EOL] abjad . hairpin ( first , theRun [ [number] : - [number] ] ) [EOL] abjad . hairpin ( second , theRun [ - [number] : ] ) [EOL] [comment] [EOL] elif len ( leaves ) == [number] : [EOL] openRun , closeRun = leaves [EOL] abjad . hairpin ( first , openRun ) [EOL] abjad . hairpin ( second , closeRun ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] raise ValueError ( ) [EOL] [EOL] [EOL] def applyHairpin ( voice , * arguments , ** keywords ) : [EOL] leaves = voice . leaves [EOL] if len ( arguments ) == [number] : [EOL] start , stop , material = arguments [EOL] cut = keywords . get ( [string] , ( [number] , ) ) [EOL] gap = keywords . get ( [string] , ( [number] , ) ) [EOL] type = keywords . get ( [string] , [string] ) [EOL] sourceLeaves = leaves [ start : stop + [number] ] [EOL] for leaf in sourceLeaves : [EOL] leaf . dynamics = None [EOL] chunks = partition_leaves ( sourceLeaves , type = type , cut = cut , gap = gap ) [EOL] for chunk in chunks : [EOL] applyPredefinedHairpin ( chunk , material ) [EOL] elif len ( arguments ) == [number] : [EOL] start , stop , startMark , pin , stopMark = arguments [EOL] chunk = leaves [ start : stop + [number] ] [EOL] hairpin = [string] . join ( [ startMark , pin , stopMark ] ) [EOL] abjad . hairpin ( hairpin , chunk ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] DYNAMICS = { [string] : [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , [string] : [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , [string] : [ ( [string] , [string] , [string] , [string] , [string] ) ] , [string] : [ ( [string] , [string] , [string] , [string] , [string] ) ] , [string] : [ ( [string] , [string] , [string] ) ] , [string] : [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , [string] : [ ( [string] , ) ] , [string] : [ ( [string] , [string] , [string] ) ] , [string] : [ ( [string] , [string] , [string] ) ] , [string] : [ ( [string] , [string] , [string] ) ] , [string] : [ ( [string] , ) ] , [string] : [ ( [string] , ) ] , [string] : [ ( [string] , [string] , [string] ) ] , [string] : Gt ( [ [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ] , ] ) , } [EOL] [EOL] [EOL] def _get_dynamics_segment ( material , i ) : [EOL] return DYNAMICS [ material ] [ i % len ( DYNAMICS [ material ] ) ] [EOL] [EOL] [EOL] def _accepts_hairpin ( leaves ) : [EOL] prolated_duration = sum ( [ _ . duration . prolated for _ in leaves ] ) [EOL] return quicktions . Fraction ( [number] , [number] ) <= prolated_duration and [number] < len ( leaves ) [EOL] [EOL] [EOL] def applyDynamicsSegments ( voice , start , stop , material , cut , gap ) : [EOL] leaves = voice . leaves [EOL] source = leaves [ start : stop + [number] ] [EOL] lidercfeny . etc . transforms . clear_dynamics ( source ) [EOL] segments = segment_leaves ( source , cut , gap ) [EOL] i = - [number] [EOL] for segment in segments : [EOL] for stage in segment : [EOL] i += [number] [EOL] apply_dynamics_leaves ( stage , material , [number] ) [EOL] [EOL] [EOL] def historical_notes_only ( voice , start , stop , material ) : [EOL] leaves = voice . leaves [ start : stop + [number] ] [EOL] lidercfeny . etc . transforms . clear_dynamics ( leaves ) [EOL] parts = lidercfeny . etc . transforms . hpartition_notes_only ( leaves ) [EOL] for i , part in enumerate ( parts ) : [EOL] apply_dynamics_leaves ( part , material , i ) [EOL] [EOL] [EOL] def historical_rest_terminated ( voice , start , stop , material ) : [EOL] leaves = voice . leaves [ start : stop + [number] ] [EOL] lidercfeny . etc . transforms . clear_dynamics ( leaves ) [EOL] parts = lidercfeny . etc . transforms . hpartition_rest_terminated ( leaves ) [EOL] for i , part in enumerate ( parts ) : [EOL] apply_dynamics_leaves ( part , material , i ) [EOL] [EOL] [EOL] [comment] [EOL] def apply_tenuti ( voice , start , stop , material ) : [EOL] runs = partition_leaves ( voice . leaves [ start : stop + [number] ] , type = [string] ) [EOL] keyed = material in DYNAMICS . keys ( ) [EOL] i = start [EOL] for run in runs : [EOL] lidercfeny . etc . transforms . clear_dynamics ( run ) [EOL] if keyed : [EOL] hairpin = [string] . join ( _get_dynamics_segment ( material , i ) ) [EOL] else : [EOL] hairpin = material [EOL] if _accepts_hairpin ( run ) : [EOL] abjad . hairpin ( hairpin , run ) [EOL] else : [EOL] dynamic = hairpin . split ( ) [ [number] ] [EOL] run [ [number] ] . dynamics = dynamic [EOL] i += len ( run ) [EOL] [EOL] [EOL] def applyDynamicsMeasures ( voice , start , stop , material ) : [EOL] measures = voice [ : ] [EOL] for i , measure in enumerate ( measures [ start - [number] : stop ] ) : [EOL] j = start + i [EOL] lidercfeny . etc . transforms . clear_dynamics ( measure . leaves ) [EOL] notes = abjad . select ( measure ) . leaves ( pitched = True ) [EOL] if [number] < len ( notes ) : [EOL] apply_dynamics_leaves ( notes , material , j ) [EOL] [EOL] [EOL] def hairpin_to_measures ( voice , start , stop , hpstr , trim = False ) : [EOL] measures = voice [ : ] [EOL] for i , measure in enumerate ( measures [ start - [number] : stop ] ) : [EOL] lidercfeny . etc . transforms . clear_dynamics ( measure ) [EOL] if trim : [EOL] leaves = baca . select ( measure ) . tleaves ( ) [EOL] else : [EOL] leaves = baca . select ( measure ) . leaves ( ) [EOL] abjad . hairping ( hpstr , leaves ) [EOL] [EOL] [EOL] def apply_dynamics_leaves ( run , material , i ) : [EOL] assert material in DYNAMICS . keys ( ) [EOL] dynamics = _get_dynamics_segment ( material , i ) [EOL] if len ( dynamics ) == [number] : [EOL] startMark = dynamics [ [number] ] [EOL] run [ [number] ] . dynamics = startMark [EOL] elif len ( dynamics ) == [number] : [EOL] startMark , hairpin , stopMark = dynamics [EOL] hairpin = [string] . join ( [ startMark , hairpin , stopMark ] ) [EOL] if hasattr ( run [ - [number] ] , [string] ) and run [ - [number] ] . glissando : [EOL] extended_run = run + [ run [ - [number] ] . next ] [EOL] if _accepts_hairpin ( run ) : [EOL] abjad . hairpin ( hairpin , extended_run ) [EOL] else : [EOL] run [ [number] ] . dynamics = startMark [EOL] else : [EOL] if _accepts_hairpin ( run ) : [EOL] abjad . hairpin ( hairpin , run ) [EOL] else : [EOL] run [ [number] ] . dynamics = startMark [EOL] else : [EOL] raise ValueError ( [string] % dynamics ) [EOL] [EOL] [EOL] [comment] [EOL] def apply_swell ( voice , start , stop , swell , gap = ( [number] , ) ) : [EOL] leaves = voice . leaves [EOL] assert len ( swell . split ( ) ) == [number] [EOL] startMark , stage1 , peakMark , stage2 , stopMark = swell . split ( ) [EOL] first = [string] . join ( [ startMark , stage1 , peakMark ] ) [EOL] second = [string] . join ( [ stage2 , stopMark ] ) [EOL] source = leaves [ start : stop + [number] ] [EOL] lidercfeny . etc . transforms . clear_dynamics ( source ) [EOL] segments = partition_leaves ( source , type = [string] , gap = gap ) [EOL] for segment in segments : [EOL] [comment] [EOL] if len ( segment ) == [number] : [EOL] part = segment [ [number] ] [EOL] abjad . hairpin ( first , part [ [number] : - [number] ] ) [EOL] abjad . hairpin ( second , part [ - [number] : ] ) [EOL] [comment] [EOL] elif len ( segment ) == [number] : [EOL] part1 , part2 = segment [EOL] abjad . hairpin ( first , part1 ) [EOL] abjad . hairpin ( second , part2 ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import typing [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] from . import chords [EOL] [EOL] [EOL] def P ( list_ , counts ) : [EOL] assert isinstance ( counts , list ) [EOL] return baca . sequence ( list_ ) . partition ( counts , cyclic = False , overhang = False ) [EOL] [EOL] [EOL] def rl ( list_ ) : [EOL] return baca . sequence ( list_ ) . rotate ( n = - [number] ) [EOL] [EOL] [EOL] def Q ( list_ ) : [EOL] return baca . sequence ( rl ( [ rl ( _ ) for _ in list_ ] ) ) . flatten ( ) [EOL] [EOL] [EOL] def T1R ( list_ ) : [EOL] result = list_ [ : ] [EOL] result = rl ( result ) [EOL] result = [ ( pc + [number] ) % [number] for pc in result ] [EOL] return result [EOL] [EOL] [EOL] def T ( list_ ) : [EOL] result = [ list_ [ : [number] ] , list_ [ [number] : ] ] [EOL] result [ [number] ] . reverse ( ) [EOL] result [ [number] ] . reverse ( ) [EOL] return result [EOL] [EOL] [EOL] def L ( list_ ) : [EOL] result = [ list_ [ [number] : ] , list_ [ : [number] ] ] [EOL] return result [EOL] [EOL] [EOL] start = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] row = start [EOL] rows = [ row ] [EOL] while True : [EOL] row = Q ( P ( row , [ [number] , [number] ] ) ) [EOL] rows . append ( row [ : ] ) [EOL] row = T1R ( row ) [EOL] if row == start : [EOL] break [EOL] else : [EOL] rows . append ( row [ : ] ) [EOL] [EOL] row = Q ( P ( row , [ [number] , [number] ] ) ) [EOL] rows . append ( row [ : ] ) [EOL] row = T1R ( row ) [EOL] if row == start : [EOL] break [EOL] else : [EOL] rows . append ( row [ : ] ) [EOL] [EOL] [EOL] def ics ( list_ ) : [EOL] differences = abjad . mathx . difference_series ( list_ ) [EOL] [EOL] def helper ( difference ) : [EOL] if [number] < difference : [EOL] return [number] - difference [EOL] else : [EOL] return difference [EOL] [EOL] result = [ helper ( abs ( _ ) ) for _ in differences ] [EOL] return result [EOL] [EOL] [EOL] def H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( - [number] , - [number] ) [EOL] [EOL] [EOL] pcs = H ( [ [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] ] ) [EOL] [EOL] assert len ( pcs ) == [number] [EOL] [EOL] pairs = baca . sequence ( pcs ) . nwise ( ) [EOL] dups = [ pair for pair in pairs if pair [ [number] ] == pair [ [number] ] ] [EOL] [EOL] assert dups == [ ] [EOL] [EOL] pitches = [ ] [EOL] [EOL] len_chords = len ( chords . chords ) [EOL] for i , pc in enumerate ( pcs ) : [EOL] aggregate_index = i / [number] % len_chords [EOL] assert isinstance ( aggregate_index , int ) [EOL] aggregate = chords . chords [ aggregate_index ] [EOL] pitch_set = abjad . PitchSet ( aggregate ) [EOL] pitches_ = pitch_set . register ( [ pc ] ) [EOL] assert len ( pitches_ ) == [number] [EOL] pitches . extend ( pitches ) [EOL] [EOL] assert len ( pitches ) == [number] [EOL] [EOL] assert pitches [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , - [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] pitches = [ pitch + [number] for pitch in pitches ] [EOL] [EOL] counts = [ [number] + _ for _ in range ( [number] , len ( pcs ) , [number] ) ] [EOL] blocks = baca . sequence ( [ [number] , [number] ] ) . repeat_to_length ( len ( counts ) ) [EOL] indicators = [ ( x , [ y ] ) for ( x , y ) in zip ( counts , blocks ) ] [EOL] [EOL] assert len ( counts ) == len ( blocks ) == len ( indicators ) == [number] [EOL] [EOL] assert indicators == [ ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ( [number] , [ [number] ] ) , ] [EOL] [EOL] assert len ( pitches ) == [number] [EOL] [EOL] notes = [ abjad . Note ( pitch , ( [number] , [number] ) ) for pitch in pitches ] [EOL] baca . insert_and_transpose ( notes , indicators ) [EOL] notes = baca . sequence ( notes ) . flatten ( ) [EOL] [EOL] pitches = [ ] [EOL] for note in notes : [EOL] assert note . written_pitch is not None [EOL] pitches . append ( note . written_pitch . number ) [EOL] [EOL] assert len ( pitches ) == [number] [EOL] [EOL] assert pitches [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] pitch_set = abjad . PitchSet ( chords . chords [ [number] ] ) [EOL] for i , pitch in enumerate ( pitches ) : [EOL] if pitch < [number] : [EOL] pitches [ i ] = pitch_set . register ( [ pitch ] ) [ [number] ] [EOL] elif [number] < pitch . number : [EOL] pitches [ i ] = pitch - [number] [EOL] else : [EOL] raise ValueError [EOL] [EOL] assert len ( pitches ) == [number] [EOL] [EOL] assert pitches [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , - [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.Tuple[builtins.int,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,typing.List[typing.Any]]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Tuple[builtins.int,typing.List[typing.Any]]]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import baca [EOL] [EOL] [EOL] def T ( pset , n ) : [EOL] return [ ( p + n ) % [number] for p in pset ] [EOL] [EOL] [EOL] def Invert ( pset ) : [EOL] return [ ( [number] - p ) % [number] for p in pset ] [EOL] [EOL] [EOL] def M ( pset , n , k = [number] ) : [EOL] result = pset [EOL] for j in range ( k ) : [EOL] result = [ ( p * n ) % [number] for p in result ] [EOL] return result [EOL] [EOL] [EOL] def ics ( pset ) : [EOL] result = [ ] [EOL] for i in baca . differences ( pset ) : [EOL] if abs ( i ) <= [number] : [EOL] result . append ( abs ( i ) ) [EOL] else : [EOL] result . append ( [number] - abs ( i ) ) [EOL] return result [EOL] [EOL] [EOL] def H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( - [number] , - [number] ) [EOL] [EOL] [EOL] def P ( list_ ) : [EOL] return baca . sequence ( list_ ) . partition ( [ [number] ] , cyclic = False , overhang = False ) [EOL] [EOL] [EOL] ordering = [ ] [EOL] for row in P ( H ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) ) : [EOL] ordering . append ( row ) [EOL] ordering . append ( T ( row , [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import baca [EOL] [EOL] [EOL] def H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , [number] ) . flatten ( ) [EOL] [EOL] [EOL] GLISSANDI = { [string] : H ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , [string] : H ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] ] ] ) , [string] : H ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , } [EOL] [EOL] [EOL] def _materialIndexToGlissandi ( material , i ) : [EOL] return GLISSANDI [ material ] [ i % len ( GLISSANDI [ material ] ) ] [EOL] [EOL] [EOL] def lookupGlissando ( leaf , material , i , offset = [number] ) : [EOL] glissandi = _materialIndexToGlissandi ( material , i + offset ) [EOL] if glissandi == [number] : [EOL] leaf . glissando = True [EOL] [EOL] [EOL] def applyGlissandi ( voice , * arguments , ** keywords ) : [EOL] leaves = voice . leaves [EOL] if len ( arguments ) == [number] : [EOL] i = arguments [EOL] leaves [ i ] . glissando = True [EOL] elif len ( arguments ) == [number] : [EOL] start , stop = arguments [EOL] for leaf in leaves [ start : stop ] : [EOL] leaf . glissando = True [EOL] elif len ( arguments ) == [number] : [EOL] start , stop , material = arguments [EOL] source = leaves [ start : stop + [number] ] [EOL] for j , leaf in enumerate ( source ) : [EOL] i = start + j [EOL] try : [EOL] next = leaves [ i + [number] ] [EOL] except Exception : [EOL] next = None [EOL] if leaf . kind ( [string] ) and next and next . kind ( [string] ) : [EOL] lookupGlissando ( leaf , material , i , ** keywords ) [EOL] else : [EOL] raise ValueError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] import quicktions [EOL] [EOL] [EOL] def H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , - [number] ) [EOL] [EOL] [EOL] def clear_articulations ( leaves , start = [number] , stop = None ) : [EOL] [docstring] [EOL] if isinstance ( stop , int ) : [EOL] stop += [number] [EOL] for list_ in abjad . iterate ( leaves [ start : stop ] ) . leaves ( ) : [EOL] list_ . articulations = [ ] [EOL] [EOL] [EOL] def apply_articulations ( voice , start , stop , articulations , min = ( [number] , ) , max = None , mask = [ [number] ] , rests = False , overwrite = True , ) : [EOL] [docstring] [EOL] source = voice . leaves [ start : stop + [number] ] [EOL] if overwrite : [EOL] clear_articulations ( source ) [EOL] min = quicktions . Fraction ( * min ) [EOL] if max : [EOL] max = quicktions . Fraction ( * max ) [EOL] for i , leaf in enumerate ( source ) : [EOL] if leaf . kind ( ( [string] , [string] ) ) or rests : [EOL] duration = abjad . get . duration ( leaf ) [EOL] if min <= duration and ( not max or duration < max ) : [EOL] if mask [ i % len ( mask ) ] : [EOL] articulation = articulations [ i % len ( articulations ) ] [EOL] leaf . articulations . append ( articulation ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import baca [EOL] import quicktions [EOL] [EOL] import lidercfeny [EOL] [EOL] from . twine import twine_leaf [EOL] [EOL] [EOL] def _H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , - [number] ) [EOL] [EOL] [EOL] _SHINE = { [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] ] * [number] , [string] : [ [string] , [string] , [string] , [string] ] * [number] , [string] : [ [string] , [string] , [string] , [string] ] * [number] , [string] : [ [string] , [string] , [string] , [string] ] * [number] , [string] : [ [string] , [string] , [string] , [string] ] * [number] , [string] : [ [string] , [string] , [string] , [string] ] * [number] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] ] * [number] , } [EOL] [EOL] [EOL] def _materialIndexToShine ( material , i ) : [EOL] return _SHINE [ material ] [ i % len ( _SHINE [ material ] ) ] [EOL] [EOL] [EOL] _abbreviationToDiatonicInterval = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def _shine_leaf ( leaf , material , i , offset = [number] ) : [EOL] shine = _materialIndexToShine ( material , i + offset ) [EOL] if shine != [string] : [EOL] diatonicInterval = _abbreviationToDiatonicInterval [ shine ] [EOL] leaf . add_artificial_harmonic ( diatonicInterval ) [EOL] [EOL] [EOL] def apply_shine ( voice , * arguments , ** keywords ) : [EOL] leaves = voice . leaves [EOL] if len ( arguments ) == [number] : [EOL] start , material = arguments [EOL] stop = start [EOL] elif len ( arguments ) == [number] : [EOL] start , stop , material = arguments [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] if [string] in keywords : [EOL] offset = keywords [ [string] ] [EOL] else : [EOL] offset = [number] [EOL] for j , leaf in enumerate ( leaves [ start : stop + [number] ] ) : [EOL] i = j + start [EOL] prev = leaves [ i - [number] ] [EOL] next = leaves [ i + [number] ] [EOL] if leaf . kind ( [string] ) and ( ( next . kind ( [string] ) [EOL] and lidercfeny . etc . transforms . get_lowest_pitch ( leaf ) == lidercfeny . etc . transforms . get_lowest_pitch ( next ) ) or ( prev . kind ( [string] ) [EOL] and lidercfeny . etc . transforms . get_lowest_pitch ( leaf ) == lidercfeny . etc . transforms . get_lowest_pitch ( prev ) ) ) : [EOL] _shine_leaf ( leaf , material , i , offset ) [EOL] [EOL] [EOL] def apply_blossoms ( voice , start , stop ) : [EOL] leaves = voice . leaves [EOL] shine = [number] [EOL] shineMaterial = [ [string] , [string] , [string] ] [EOL] for i , cur in enumerate ( leaves ) : [EOL] prev = cur . prev [EOL] next = cur . next [EOL] if ( cur . kind ( [string] ) [EOL] and cur . beam . first [EOL] and next [EOL] and next . duration . prolated <= cur . duration . prolated [EOL] and quicktions . Fraction ( [number] , [number] ) <= cur . duration . prolated [EOL] and next . duration . prolated < quicktions . Fraction ( [number] , [number] ) ) : [EOL] cur . add_artificial_harmonic ( [string] ) [EOL] elif cur . kind ( [string] ) and ( ( next [EOL] and next . kind ( [string] ) [EOL] and lidercfeny . etc . transforms . get_lowest_pitch ( next ) == lidercfeny . etc . transforms . get_lowest_pitch ( cur ) ) or ( prev [EOL] and prev . kind ( [string] ) [EOL] and lidercfeny . etc . transforms . get_lowet_pitch ( prev ) == lidercfeny . etc . transforms . get_lowest_pitch ( cur ) ) ) : [EOL] if cur . pitch . accidental is None : [EOL] _shine_leaf ( cur , shineMaterial [ shine % len ( shineMaterial ) ] , i ) [EOL] else : [EOL] twine_leaf ( cur , [string] , i ) [EOL] if ( prev [EOL] and prev . kind ( [string] ) [EOL] and lidercfeny . etc . transforms . get_lowest_pitch ( prev ) == lidercfeny . etc . transforms . get_lowet_pitch ( cur ) [EOL] and ( not next or ( next and next . kind ( [string] ) ) or ( next [EOL] and next . kind ( [string] ) [EOL] and lidercfeny . etc . transforms . get_lowest_pitch ( next ) != lidercfeny . etc . transforms . get_lowest_pitch ( cur ) ) ) ) : [EOL] shine += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] [EOL] range_ = abjad . PitchRange ( [string] ) [EOL] constellation_circuit = baca . ConstellationCircuit ( baca . ConstellationCircuit . CC1 , range_ , ) [EOL] [EOL] chords = [ constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , constellation_circuit [ [number] - [number] ] [ [number] - [number] ] , ] [EOL] [EOL] expansions = ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL] chords [ [number] - [number] ] = constellation_circuit [ [number] - [number] ] [ [number] - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , List , Any [EOL] import typing [EOL] import abjad [EOL] [EOL] REGISTRATION = { [string] : [ ( ( - [number] , [number] ) , - [number] ) ] , [string] : [ ( ( - [number] , [number] ) , - [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , - [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , - [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , - [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , - [number] ) , [number] ) , ( ( [number] , [number] ) , [number] ) ] , [string] : [ ( ( - [number] , [number] ) , [number] ) ] , } [EOL] [EOL] [EOL] def applyRegistration ( voice , start , stop , registration ) : [EOL] leaves = voice . leaves [EOL] for leaf in leaves [ start : stop + [number] ] : [EOL] if leaf . kind ( [string] ) : [EOL] if isinstance ( registration , int ) : [EOL] mapping = [ ( ( - [number] , [number] ) , registration ) ] [EOL] elif isinstance ( registration , str ) : [EOL] mapping = REGISTRATION [ registration ] [EOL] else : [EOL] raise ValueError [EOL] pp = [ ] [EOL] for pitch_number in leaf . core : [EOL] pp . append ( abjad . send_pitch_number_to_octave ( pitch_number , mapping ) ) [EOL] if len ( pp ) == [number] : [EOL] leaf . pitch = pp [ [number] ] [EOL] else : [EOL] abjad . Chord ( leaf ) [EOL] leaf . pitches = pp [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Tuple[typing.Tuple[builtins.int,builtins.int],builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] [EOL] [EOL] def _H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , - [number] ) [EOL] [EOL] [EOL] _graces = _H ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [EOL] [EOL] _signs = _H ( [ [ - [number] , - [number] , [number] ] , [ - [number] , [number] , [number] , [number] ] ] ) [EOL] [EOL] [EOL] for i , grace in enumerate ( _graces ) : [EOL] _graces [ i ] = grace * _signs [ i % len ( _signs ) ] [EOL] [EOL] [EOL] def _get_grace_interval ( i ) : [EOL] return _graces [ i % len ( _graces ) ] [EOL] [EOL] [EOL] def apply_graces ( voice , start , stop ) : [EOL] for i , leaf in enumerate ( voice . leaves [ start : stop + [number] ] ) : [EOL] j = start + i [EOL] if leaf . kind ( [string] ) : [EOL] interval = _get_grace_interval ( j ) [EOL] if interval : [EOL] measure = leaf . _parentage . _first ( [string] ) [EOL] if not leaf == measure . leaves [ [number] ] : [EOL] if not hasattr ( leaf , [string] ) : [EOL] grace = abjad . AfterGraceContainer ( [ abjad . Note ( leaf . pitch . number , ( [number] , [number] ) ) ] ) [EOL] if [number] < interval : [EOL] pitch = grace [ [number] ] . pitch . staffSpaceTranspose ( [number] , interval ) [EOL] else : [EOL] pitch = grace [ [number] ] . pitch . staffSpaceTranspose ( - [number] , interval ) [EOL] grace [ [number] ] . pitch = pitch [EOL] grace [ [number] ] . formatter . before . append ( [string] ) [EOL] leaf . grace . before = grace [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] [EOL] [EOL] def _H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , - [number] ) [EOL] [EOL] [EOL] def _Ht ( list_ ) : [EOL] unflattened = baca . sequence ( list_ ) . helianthate ( [number] , - [number] ) [EOL] result = [ ] [EOL] for sublist in unflattened : [EOL] result . extend ( sublist ) [EOL] return result [EOL] [EOL] [EOL] _TWINE = { [string] : [ ( [number] , [number] ) , ( - [number] , - [number] ) ] * [number] , [string] : [ ( [number] , [number] ) , ( [number] , [number] ) ] * [number] , [string] : [ ( [number] , [number] ) , ( [number] , [number] ) ] * [number] , [string] : [ ( - [number] , - [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] * [number] , [string] : [ ( - [number] , - [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] * [number] , [string] : [ [number] , [number] , [number] ] * [number] , [string] : [ [number] , - [number] , [number] , [number] , - [number] , [number] ] * [number] , [string] : _Ht ( [ [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , - [number] ) ] , [ ( - [number] , - [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] , [ ( - [number] , - [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] , ] ) , [string] : _H ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) , [string] : _H ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , - [number] , - [number] ] , [ [number] , - [number] , - [number] , - [number] ] ] ) , } [EOL] [EOL] [EOL] def _materialIndexToTwining ( material , i ) : [EOL] return _TWINE [ material ] [ i % len ( _TWINE [ material ] ) ] [EOL] [EOL] [EOL] def twine_leaf ( leaf , material , i ) : [EOL] twine = _materialIndexToTwining ( material , i ) [EOL] if [string] not in leaf . history : [EOL] leaf . history [ [string] ] = leaf . pitch . number [EOL] leaf . pitch = abjad . NamedPitch ( leaf . history [ [string] ] ) . staffSpaceTranspose ( * twine ) [EOL] [EOL] [EOL] def apply_twine ( voice , * arguments ) : [EOL] leaves = voice . leaves [EOL] if len ( arguments ) == [number] : [EOL] start , material = arguments [EOL] stop = start [EOL] elif len ( arguments ) == [number] : [EOL] start , stop , material = arguments [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] for j , leaf in enumerate ( leaves [ start : stop + [number] ] ) : [EOL] i = j + start [EOL] if leaf . kind ( [string] ) : [EOL] if ( leaf . next and getattr ( leaf . next , [string] , False ) ) or getattr ( leaf , [string] , False ) : [EOL] twine_leaf ( leaf , material , i ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import pickle [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] from . . cfg import PERSISTENCEDIR [EOL] [EOL] MEASURES = [number] [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] eighths = pickle . load ( pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] staves = pickle . load ( pointer ) [EOL] [EOL] eighths = eighths [ : MEASURES ] [EOL] for v in abjad . iterate ( staves ) . components ( abjad . Voice ) : [EOL] v [ : ] = v [ : MEASURES ] [EOL] [EOL] prolongations = [ ] [EOL] FLUTEDIR = [string] [EOL] lines = open ( FLUTEDIR + [string] , [string] ) . readlines ( ) [EOL] for line in lines : [EOL] strings = line . split ( ) [EOL] if len ( strings ) == [number] : [EOL] start , stop = ( eval ( strings [ [number] ] ) , eval ( strings [ [number] ] ) ) [EOL] for i in range ( start , stop + [number] ) : [EOL] prolongations . append ( i ) [EOL] elif strings [ [number] ] == [string] : [EOL] for ( start , stop ) in baca . sequence ( [ eval ( x ) for x in line [ [number] : ] ] ) . nwise ( ) : [EOL] for i in range ( start + [number] , stop ) : [EOL] prolongations . append ( i ) [EOL] [EOL] fluteStaff = staves [ [number] ] [EOL] [EOL] for i , leaf in enumerate ( abjad . select ( fluteStaff ) . leaves ( ) ) : [EOL] if leaf . kind ( [string] ) and i in prolongations : [EOL] leaf . prolongation = True [EOL] leaf . formatter . right . append ( [string] ) [EOL] [EOL] prolongations = [ ] [EOL] VIOLINDIR = [string] [EOL] lines = open ( VIOLINDIR + [string] , [string] ) . readlines ( ) [EOL] for line in lines : [EOL] strings = line . split ( ) [EOL] if len ( strings ) == [number] : [EOL] start , stop = ( eval ( strings [ [number] ] ) , eval ( strings [ [number] ] ) ) [EOL] for i in range ( start , stop + [number] ) : [EOL] prolongations . append ( i ) [EOL] elif strings [ [number] ] == [string] : [EOL] for ( start , stop ) in baca . sequence ( [ eval ( x ) for x in line [ [number] : ] ] ) . nwise ( ) : [EOL] for i in range ( start + [number] , stop ) : [EOL] prolongations . append ( i ) [EOL] [EOL] violinStaff = staves [ [number] ] [EOL] [EOL] for i , leaf in enumerate ( abjad . select ( violinStaff ) . leaves ( ) ) : [EOL] if leaf . kind ( [string] ) and i in prolongations : [EOL] leaf . prolongation = True [EOL] leaf . formatter . right . append ( [string] ) [EOL] [EOL] piano1Staff = staves [ [number] ] [EOL] piano2Staff = staves [ [number] ] [EOL] [EOL] p1arity = baca . sequence ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] p1arity = p1arity . helianthate ( [number] , [number] ) [EOL] [EOL] p2arity = baca . sequence ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] p2arity = p2arity . helianthate ( [number] , [number] ) [EOL] [EOL] p1range = [ [number] , [number] ] [EOL] p1range += range ( [number] , [number] + [number] ) [EOL] p1range += range ( [number] , [number] + [number] ) [EOL] p1range += range ( [number] , [number] + [number] ) [EOL] p1range += range ( [number] , [number] + [number] ) [EOL] p1range += range ( [number] , [number] + [number] ) [EOL] p1range += [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] p1prolongations = list ( range ( [number] , [number] + [number] ) ) [EOL] p1prolongations += range ( [number] , [number] + [number] ) [EOL] p1prolongations += range ( [number] , [number] + [number] ) [EOL] p1prolongations += range ( [number] , [number] + [number] ) [EOL] [EOL] ct = [number] [EOL] for i , leaf in enumerate ( abjad . select ( piano1Staff ) . leaves ( ) ) : [EOL] if leaf . kind ( [string] ) and i in p1range : [EOL] arity = p1arity [ ct % len ( p1arity ) ] [EOL] leaf . arity = arity [EOL] markup = [string] % arity [EOL] leaf . formatter . right . append ( markup ) [EOL] ct += [number] [EOL] if leaf . kind ( [string] ) and i in p1prolongations : [EOL] leaf . prolongation = True [EOL] leaf . formatter . right . append ( [string] ) [EOL] [EOL] p2range = list ( range ( [number] , [number] + [number] ) ) [EOL] p2range += [ [number] , [number] ] [EOL] p2range += [ [number] ] [EOL] p2range += [ [number] ] [EOL] p2range += [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] p2prolongations = list ( range ( [number] , [number] + [number] ) ) [EOL] p2prolongations += range ( [number] , [number] + [number] ) [EOL] p2prolongations += range ( [number] , [number] + [number] ) [EOL] p2prolongations += range ( [number] , [number] + [number] ) [EOL] p2prolongations += range ( [number] , [number] + [number] ) [EOL] p2prolongations += range ( [number] , [number] + [number] ) [EOL] [EOL] ct = [number] [EOL] for i , leaf in enumerate ( abjad . select ( piano2Staff ) . leaves ( ) ) : [EOL] if leaf . kind ( [string] ) and i in p2range : [EOL] arity = p2arity [ ct % len ( p2arity ) ] [EOL] leaf . arity = arity [EOL] markup = [string] % arity [EOL] leaf . formatter . right . append ( markup ) [EOL] ct += [number] [EOL] if leaf . kind ( [string] ) and i in p2prolongations : [EOL] leaf . prolongation = True [EOL] leaf . formatter . right . append ( [string] ) [EOL] [EOL] abjad . label ( staves [ [number] ] ) . with_leaf_indices ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] pickle . dump ( staves , pointer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] import quicktions [EOL] [EOL] [EOL] def _H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , - [number] ) [EOL] [EOL] [EOL] _trill_intervals = _H ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [EOL] [EOL] def apply_trills ( voice , start , stop , minimum = ( [number] , [number] ) ) : [EOL] for i , leaf in enumerate ( voice . leaves [ start : stop + [number] ] ) : [EOL] if leaf . kind ( [string] ) and quicktions . Fraction ( * minimum ) < leaf . duration : [EOL] j = start + i [EOL] interval = _trill_intervals [ j % len ( _trill_intervals ) ] [EOL] trill = abjad . Trill ( [ leaf , leaf . next ] ) [EOL] trill . pitch = leaf . pitch . number + interval [EOL] if leaf . next . kind ( [string] ) and leaf . next . pitch . accidental is not None : [EOL] right_padding = [number] [EOL] else : [EOL] right_padding = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] leaf . formatter . before . extend ( [ [string] [string] % right_padding ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Tuple , List , Any [EOL] import typing [EOL] import pickle [EOL] import typing [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] import lidercfeny [EOL] [EOL] from . . cfg import PERSISTENCEDIR [EOL] from . import weave [EOL] [EOL] print ( [string] ) [EOL] [EOL] staves = [ ] [EOL] [EOL] [EOL] def add ( staves , tuplets , name ) : [EOL] voice = abjad . Voice ( tuplets ) [EOL] voice . name = name + [string] [EOL] staff = abjad . Staff ( [ voice ] ) [EOL] staff . name = name + [string] [EOL] staff . invocation . lhs = [string] [EOL] staves . append ( staff ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] rhythm_eighths = pickle . load ( pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] rhythmb_eighths = pickle . load ( pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] rhythm = pickle . load ( pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] rhythmb = pickle . load ( pointer ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] target_lengths = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] insert_lengths = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] loci = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] a_sections = baca . sequence ( rhythm_eighths ) . partition ( target_lengths ) [EOL] b_sections = baca . sequence ( rhythmb_eighths ) . partition ( insert_lengths ) [EOL] read_once_loci = ( loci , None ) [EOL] periodic_b_sections = ( b_sections , len ( b_sections ) ) [EOL] eighths = baca . sequence ( a_sections ) . replace_at ( read_once_loci , periodic_b_sections ) [EOL] eighths = baca . sequence ( eighths ) . flatten ( ) [EOL] [EOL] lidercfeny . etc . transforms . recombine_voices ( rhythm , target_lengths , rhythmb , insert_lengths , loci ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] specification = [ ] [EOL] specification . extend ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] specification . extend ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] length = [number] [EOL] specification_ = [ ( start , length , count - [number] ) for start , count in specification ] [EOL] [comment] [EOL] eighths = baca . sequence ( eighths ) . repeat_runs_to_count ( specification_ ) [EOL] eighths = baca . sequence ( eighths ) . flatten ( ) [EOL] lidercfeny . etc . transforms . ripple_voices ( rhythm , specification_ ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( ) [EOL] for part in weave . weft [ [string] ] : [EOL] print ( part ) [EOL] result = [ ] [EOL] for n , ( start , length ) in zip ( weave . weft [ part ] , weave . weft [ [string] ] ) : [EOL] i = start - [number] [EOL] j = i + length - [number] [EOL] print ( f" [string] { i + [number] } [string] { j + [number] } [string] { n } [string] " ) [EOL] [comment] [EOL] new = abjad . mutate . copy ( rhythm [ n - [number] ] [ [number] ] [ i : j + [number] ] ) [EOL] result . extend ( new [ : ] ) [EOL] print ( f"{ part } [string] { len ( result ) } [string] " ) [EOL] add ( staves , result , weave . weft [ [string] ] [ part ] ) [EOL] [EOL] [EOL] def pull ( staves , name ) : [EOL] for staff in staves : [EOL] if hasattr ( staff , [string] ) and staff . name == name : [EOL] return staff [EOL] [EOL] [EOL] names = ( [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] staves = [ pull ( staves , name + [string] ) for name in names ] [EOL] [EOL] print ( [string] ) [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] pickle . dump ( eighths , pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] pickle . dump ( staves , pointer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Tuple , List , Any [EOL] import typing [EOL] import baca [EOL] [EOL] first = baca . sequence ( [ [ [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] first = first . helianthate ( [number] , [number] ) [EOL] first *= [number] [EOL] weight = sum ( first ) [EOL] [EOL] assert weight == [number] [EOL] assert first [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] specification = baca . sequence ( [ [ [number] , - [number] ] , [ [number] , [number] , - [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] specification = specification . helianthate ( [number] , [number] ) [EOL] first = first . increase_cyclically_by_addenda ( specification ) [EOL] first = first . repeat_to_weight ( weight ) [EOL] [EOL] assert first [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] second = baca . sequence ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] second = second . helianthate ( [number] , [number] ) [EOL] second . extend ( second [ : [number] ] ) [EOL] weight = sum ( second ) [EOL] [EOL] assert weight == [number] [EOL] assert second [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] specification = baca . sequence ( [ [ [number] , [number] ] , [ - [number] , - [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] specification = specification . helianthate ( [number] , [number] ) [EOL] second = second . increase_sequence_cyclically_by_addenda ( specification ) [EOL] second = second . repeat_to_weight ( weight ) [EOL] [EOL] assert second [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] eighths = first + second [EOL] assert len ( eighths ) == [number] [EOL] assert eighths [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] addenda = [ [number] , [number] , [number] , [number] , [number] ] [EOL] indices = [ [number] , [number] , [number] , [number] , [number] ] [EOL] eighths = baca . increase_elements ( eighths , addenda , indices = indices ) [EOL] assert len ( eighths ) == [number] [EOL] assert sum ( eighths ) == [number] [EOL] assert eighths [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] eighths = eighths . remove_weighted_subrun_at ( [number] , [number] ) [EOL] assert len ( eighths ) == [number] [EOL] assert sum ( eighths ) == [number] [EOL] [EOL] eighths = eighths . split ( [ [number] ] , cyclic = False , overhang = False ) [EOL] assert len ( eighths ) == [number] [EOL] assert eighths [ : [number] ] == [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] ] [EOL] [EOL] numbers_1 = baca . sequence ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] numbers_1 = numbers_1 . helianthate ( [number] , [number] ) [EOL] numbers_1 = numbers_1 . split ( [ [number] ] , cyclic = False , overhang = False ) [EOL] assert len ( numbers_1 ) == [number] [EOL] assert numbers_1 [ : [number] ] == [ [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ] [EOL] [EOL] [EOL] indices_ = ( [ [number] , [number] , [number] , [number] , [number] , [number] ] , None ) [EOL] material = ( numbers_1 , None ) [EOL] eighths = eighths . overwrite_elements_at ( indices_ , material ) [EOL] eighths [ [number] ] [ : [number] ] = numbers_1 [ - [number] ] [EOL] assert len ( eighths ) == [number] [EOL] assert eighths [ : [number] ] == [ [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] ] [EOL] [EOL] sections = [ len ( section ) for section in eighths ] [EOL] eighths = baca . sequence ( eighths ) . flatten ( ) [EOL] assert eighths [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] eighths = [ int ( _ ) if int ( _ ) == _ else _ for _ in eighths ] [EOL] assert len ( eighths ) == [number] [EOL] assert eighths [ : [number] ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] sixteenths = [ int ( [number] * eighth ) for eighth in eighths ] [EOL] thirties = [ int ( [number] * eighth ) for eighth in eighths ] [EOL] sixties = [ int ( [number] * eighth ) for eighth in eighths ] [EOL] [EOL] meters = [ ( int ( eighth * [number] ) , [number] ) if int ( eighth * [number] ) % [number] == [number] else ( int ( eighth ) , [number] ) for eighth in eighths ] [EOL] [EOL] assert eighths == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,None]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,None]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import pickle [EOL] [EOL] import abjad [EOL] [EOL] from lidercfeny . etc . cfg import PERSISTENCEDIR [EOL] [EOL] print ( [string] ) [EOL] [EOL] MEASURES = [number] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] eighths = pickle . load ( pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] staves = pickle . load ( pointer ) [EOL] [EOL] eighths = eighths [ : MEASURES ] [EOL] for v in abjad . iterate ( staves ) . by_voice ( ) : [EOL] v [ : ] = v [ : MEASURES ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] total = [number] [EOL] source = staves [ [string] ] [EOL] target = staves [ [string] ] [EOL] for i , ( pitches , breath ) in enumerate ( zip ( staves [ [number] ] [ [number] ] , staves [ [number] ] [ [number] ] ) ) : [EOL] vector = [ leaf . kind ( [string] ) for leaf in abjad . select ( breath ) . leaves ( ) ] [EOL] [comment] [EOL] if len ( vector ) == len ( set ( vector ) ) : [EOL] total += [number] [EOL] [comment] [EOL] target [ i : i + [number] ] = [ source [ i ] . copy ( ) ] [EOL] print ( [string] % total ) [EOL] print ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] pfl = staves [ [string] ] [EOL] pfl [ [number] - [number] ] = abjad . makers . tuplet_from_ratio_and_pair ( ( - [number] , [number] ) , ( [number] , [number] ) ) [EOL] pfl [ [number] - [number] ] = abjad . makers . tuplet_from_ratio_and_pair ( ( [number] , - [number] ) , ( [number] , [number] ) ) [EOL] pfl [ [number] - [number] ] = abjad . makers . tuplet_from_ratio_and_pair ( ( - [number] , - [number] , [number] ) , ( [number] , [number] ) ) [EOL] pfl [ [number] - [number] ] [ [number] ] = abjad . makers . tuplet_from_ratio_and_pair ( ( - [number] , ) , ( [number] , [number] ) ) [EOL] pfl [ [number] - [number] ] [ [number] ] [ [number] ] = abjad . Rest ( ( [number] , [number] ) ) [EOL] pfl [ [number] - [number] ] [ [number] ] [ [number] ] = abjad . Rest ( ( [number] , [number] ) ) [EOL] print ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] total = [number] [EOL] source = staves [ [string] ] [EOL] target = staves [ [string] ] [EOL] for i , ( pitches , bow ) in enumerate ( zip ( staves [ [number] ] [ [number] ] , staves [ [number] ] [ [number] ] ) ) : [EOL] vector = [ leaf . kind ( [string] ) for leaf in abjad . select ( bow ) . leaves ( ) ] [EOL] if len ( vector ) == len ( set ( vector ) ) : [EOL] total += [number] [EOL] [comment] [EOL] target [ i : i + [number] ] = [ source [ i ] . copy ( ) ] [EOL] print ( [string] % total ) [EOL] print ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] print ( ) [EOL] [EOL] total = [number] [EOL] source = staves [ [string] ] [EOL] target = staves [ [string] ] [EOL] for i , ( piano1 , piano2 ) in enumerate ( zip ( staves [ [number] ] [ [number] ] , staves [ [number] ] [ [number] ] ) ) : [EOL] [comment] [EOL] leaves = abjad . iterate ( piano1 ) . leaves ( ) [EOL] vector1 = [ abjad . get . duration ( _ ) for _ in leaves ] [EOL] [comment] [EOL] leaves = abjad . iterate ( piano2 ) . leaves ( ) [EOL] vector2 = [ abjad . get . duration ( _ ) for _ in leaves ] [EOL] vr1 = [ leaf . kind ( [string] ) for leaf in abjad . select ( piano1 ) . leaves ( ) ] [EOL] vr1 = [ len ( vr1 ) == len ( set ( vr1 ) ) ] [EOL] vr2 = [ leaf . kind ( [string] ) for leaf in abjad . select ( piano2 ) . leaves ( ) ] [EOL] vr2 = [ len ( vr2 ) == len ( set ( vr2 ) ) ] [EOL] if vector1 == vector2 or vr1 == [ True ] or vr2 == [ True ] : [EOL] [comment] [EOL] meter = piano1 . duration . pair [EOL] [comment] [EOL] while meter [ [number] ] not in ( [number] , [number] ) : [EOL] meter = ( meter [ [number] ] * [number] , meter [ [number] ] * [number] ) [EOL] parts = abjad . mathx . partition_integer_into_canonic_parts ( meter [ [number] ] ) [EOL] skips = [ abjad . Container ( [ abjad . Skip ( ( n , meter [ [number] ] ) ) for n in parts ] ) ] [EOL] blank = abjad . Container ( skips ) [EOL] [comment] [EOL] if vr1 == vr2 == [ True ] : [EOL] pass [EOL] elif vr1 == [ True ] and vr2 != [ True ] : [EOL] leaves = abjad . select ( piano2 ) . leaves ( ) [EOL] for j , leaf in enumerate ( leaves ) : [EOL] if j == [number] : [EOL] leaf . cross = [string] [EOL] elif j == len ( leaves ) - [number] : [EOL] leaf . cross = [string] [EOL] else : [EOL] leaf . cross = True [EOL] [comment] [EOL] target [ i : i + [number] ] = [ source [ i ] . copy ( ) ] [EOL] source [ i : i + [number] ] = [ blank ] [EOL] elif vr1 != [ True ] and vr2 == [ True ] : [EOL] leaves = abjad . select ( piano1 ) . leaves ( ) [EOL] for j , leaf in enumerate ( leaves ) : [EOL] if j == [number] : [EOL] leaf . cross = [string] [EOL] elif j == len ( leaves ) - [number] : [EOL] leaf . cross = [string] [EOL] else : [EOL] leaf . cross = True [EOL] source [ i : i + [number] ] = [ blank ] [EOL] else : [EOL] leaves = abjad . select ( piano1 ) . leaves ( ) [EOL] for j , leaf in enumerate ( leaves ) : [EOL] if j == [number] : [EOL] leaf . cross = [string] [EOL] elif j == len ( leaves ) - [number] : [EOL] leaf . cross = [string] [EOL] else : [EOL] leaf . cross = True [EOL] source [ i : i + [number] ] = [ blank ] [EOL] total += [number] [EOL] print ( [string] % total ) [EOL] print ( ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] pickle . dump ( staves , pointer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.bool]$ 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import pickle [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] import lidercfeny [EOL] [EOL] from . . cfg import PERSISTENCEDIR [EOL] [EOL] print ( [string] ) [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] staves = pickle . load ( pointer ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] measures = [number] [EOL] [EOL] [EOL] def H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , [number] ) [EOL] [EOL] [EOL] reflections = [ [ ( [string] , [string] ) ] , [ ( [string] , [string] ) ] , [ ( [string] , [string] ) ] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , [ ( [string] , [string] ) ] , [ ( [string] , [string] ) ] , [ ( [string] , [string] ) , ( [string] , [string] ) ] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , ] [EOL] [EOL] window = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] count = [number] [EOL] [EOL] mask = H ( [ [ [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] mask = baca . sequence ( mask ) . repeat_to_length ( measures * len ( reflections ) ) [EOL] [EOL] [comment] [EOL] window_period = len ( window ) [EOL] window_true_indices = baca . sequence ( window ) . true_indices ( ) [EOL] mask = mask . negate_elements ( absolute = True , indices = window_true_indices , period = window_period ) [EOL] [EOL] mask = mask . split ( measures , cyclic = True , overhang = True ) [EOL] mask = mask . flatten ( ) [EOL] mask = mask . split ( [ count ] , cyclic = True , overhang = True ) [EOL] mask = mask . flatten ( ) [EOL] [EOL] window = baca . sequence ( window ) . repeat_to_length ( count ) [EOL] [comment] [EOL] window_period = len ( window ) [EOL] [comment] [EOL] window_true_indices = [ ] [EOL] for i , item in enumerate ( window ) : [EOL] if item is True : [EOL] window_true_indices . append ( i ) [EOL] mask = mask . negate_elements ( absolute = True , indices = window_true_indices , period = window_period ) [EOL] [EOL] mask = mask . split ( measures , cyclic = True , overhang = True ) [EOL] mask = [ lidercfeny . lengths_to_joined_positive_counts ( row ) for row in mask ] [EOL] mask = mask . rotate ( n = - int ( len ( reflections ) / [number] ) ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] for reflection , mask in zip ( reflections , mask ) : [EOL] [comment] [EOL] for sourceName , targetName in reflection : [EOL] for measure_list in mask : [EOL] source = staves [ sourceName + [string] ] [EOL] target = staves [ targetName + [string] ] [EOL] i = measure_list [ [number] ] - [number] [EOL] j = i + len ( measure_list ) - [number] [EOL] [comment] [EOL] new = abjad . mutate . copy ( source [ i : j + [number] ] ) [EOL] [comment] [EOL] target [ i : j + [number] ] = new [ : ] [EOL] [EOL] print ( [string] ) [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] pickle . dump ( staves , pointer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.List[typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.List[typing.Tuple[builtins.str,builtins.str]]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
import builtins [EOL] from typing import Tuple , List , Any [EOL] import typing [EOL] import abjad [EOL] import pickle [EOL] import typing [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] import lidercfeny [EOL] [EOL] INCLUDEFILLED = True [EOL] [EOL] if INCLUDEFILLED : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] measure_count = len ( lidercfeny . etc . rhythm . measures . eighths ) [EOL] [comment] [EOL] eighths = lidercfeny . etc . rhythm . measures . eighths [ : measure_count ] [EOL] sixteenths = lidercfeny . etc . rhythm . measures . sixteenths [ : measure_count ] [EOL] thirties = lidercfeny . etc . rhythm . measures . thirties [ : measure_count ] [EOL] sixties = lidercfeny . etc . rhythm . measures . sixties [ : measure_count ] [EOL] [EOL] prolation = ( [ [ [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] , ) [EOL] [EOL] masks = ( [ [ [number] , - [number] , [number] , - [number] ] , [ [number] , - [number] ] , [ [number] , - [number] , [number] , - [number] ] ] , [ [ [number] , [number] , [number] , - [number] ] , [ [number] , - [number] ] , [ [number] , [number] , [number] , - [number] ] ] , [ [ [number] , [number] , [number] , - [number] ] , [ [number] , - [number] ] , [ [number] , [number] , [number] , - [number] ] ] , ) [EOL] [EOL] staves = [ ] [EOL] [EOL] [EOL] def add ( staves , tuplets , tag = [string] ) : [EOL] [comment] [EOL] staff = abjad . RhythmicStaff ( [ abjad . Voice ( tuplets ) ] ) [EOL] [comment] [EOL] [comment] [EOL] staves . append ( staff ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] signal = baca . sequence ( [ [ [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] signal = signal . helianthate ( [number] , [number] ) [EOL] j1 = lidercfeny . intaglio ( sixteenths , signal , weight = [number] ) [EOL] j1 = lidercfeny . partition_nested_into_canonic_parts ( j1 ) [EOL] assert len ( j1 ) == [number] [EOL] assert j1 [ - [number] : ] == [ [ [number] ] , [ [number] ] , [ [number] ] , [ [number] ] , [ [number] ] , [ [number] ] , [ [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] ] ] [EOL] [EOL] denominators_1a = baca . sequence ( j1 ) . flatten ( ) [EOL] denominators_1b = [ [number] * _ for _ in denominators_1a ] [EOL] denominators_1c = [ [number] * _ for _ in denominators_1a ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] beams_1 = abjad . Sequence ( j1 ) . partition_by_weights ( [ [number] , [number] , [number] ] ) [EOL] beams_1 = abjad . Sequence ( [ len ( _ ) for _ in beams_1 ] ) [EOL] [EOL] [comment] [EOL] signal = baca . sequence ( [ [ [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] signal = signal . helianthate ( [number] , [number] ) [EOL] period_s = len ( signal ) [EOL] signal = signal . true_indices ( ) [EOL] [comment] [EOL] j1_part_lengths = [ len ( _ ) for _ in j1 ] [EOL] ratios_1 = baca . sequence ( j1 ) . flatten ( ) [EOL] ratios_1 = ratios_1 . negate_elements ( indices = signal , period = period_s ) [EOL] ratios_1 = ratios_1 . partition ( j1_part_lengths ) [EOL] assert len ( ratios_1 ) == [number] [EOL] assert ratios_1 [ - [number] : ] == [ [ [number] ] , [ [number] ] , [ [number] ] , [ - [number] ] , [ [number] ] , [ [number] ] , [ [number] ] , [ - [number] , [number] ] , [ [number] , - [number] ] , [ [number] ] , ] [EOL] tuplets = [ abjad . makers . tuplet_from_ratio_and_pair ( ratio , ( abjad . mathx . weight ( ratio ) , [number] ) ) for ratio in ratios_1 ] [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] lengths = [ len ( _ ) for _ in ratios_1 ] [EOL] ratios_1 = baca . sequence ( ratios_1 ) . flatten ( ) [EOL] ratios_1 = baca . sequence ( [ abs ( _ ) for _ in ratios_1 ] ) [EOL] ratios_1 = ratios_1 . partition ( lengths ) [EOL] tuplets = [ abjad . makers . tuplet_from_ratio_and_pair ( ratio , ( abjad . mathx . weight ( ratio ) , [number] ) ) for ratio in ratios_1 ] [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] mask = [ [ [number] , [number] , - [number] ] , [ [number] , - [number] ] , [ [number] , [number] , - [number] , [number] ] ] [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_1a , prolation [ [number] ] , mask , [number] , beams_1 ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_1a , prolation [ [number] ] , mask , [number] , beams_1 , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_1b , prolation [ [number] ] , masks [ [number] ] , [number] , beams_1 ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_1b , prolation [ [number] ] , masks [ [number] ] , [number] , beams_1 , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] talea = [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] cut = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] dilation = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_1b , dilation , [number] ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_1b , dilation , [number] , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] mask = [ [ [number] , [number] , - [number] ] , [ [number] , - [number] ] , [ [number] , [number] , - [number] , [number] ] ] [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_1c , [ [ [number] ] ] , mask , [number] , beams_1 ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_1c , [ [ [number] ] ] , mask , [number] , beams_1 , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_1c , prolation [ [number] ] , masks [ [number] ] , [number] , beams_1 ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_1c , prolation [ [number] ] , masks [ [number] ] , [number] , beams_1 , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] signal = baca . sequence ( [ [ [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] signal = signal . helianthate ( [number] , [number] ) [EOL] j2 = lidercfeny . intaglio ( sixteenths , signal , weight = [number] ) [EOL] j2 = lidercfeny . partition_nested_into_canonic_parts ( j2 ) [EOL] [EOL] denominators_2a = baca . sequence ( j2 ) . flatten ( ) [EOL] denominators_2b = [ [number] * _ for _ in denominators_2a ] [EOL] denominators_2c = [ [number] * _ for _ in denominators_2a ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] beams_2 = abjad . Sequence ( j2 ) . partition_by_weights ( [ [number] , [number] , [number] ] ) [EOL] beams_2 = abjad . Sequence ( [ len ( _ ) for _ in beams_2 ] ) [EOL] [EOL] [comment] [EOL] signal = baca . sequence ( [ [ [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] signal = signal . helianthate ( [number] , [number] ) [EOL] period_s = len ( signal ) [EOL] signal = signal . true_indices ( ) [EOL] [comment] [EOL] j2_part_lengths = [ len ( _ ) for _ in j2 ] [EOL] ratios_2 = baca . sequence ( j2 ) . flatten ( ) [EOL] ratios_2 = ratios_2 . negate_elements ( indices = signal , period = period_s ) [EOL] ratios_2 = ratios_2 . partition_by_lengths ( j2_part_lengths ) [EOL] tuplets = [ abjad . makers . tuplet_from_ratio_and_pair ( ratio , ( abjad . mathx . weight ( ratio ) , [number] ) ) for ratio in ratios_2 ] [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] lengths = [ len ( _ ) for _ in ratios_2 ] [EOL] ratios_2 = baca . sequence ( ratios_2 ) . flatten ( ) [EOL] ratios_2 = [ abs ( _ ) for _ in ratios_2 ] [EOL] ratios_2 = ratios_2 . partition_by_lengths ( lengths ) [EOL] tuplets = [ abjad . makers . tuplet_from_ratio_and_pair ( ratio , ( abjad . mathx . weight ( ratio ) , [number] ) ) for ratio in ratios_2 ] [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] mask = [ [ [number] , - [number] , [number] ] , [ [number] , - [number] ] , [ - [number] , [number] , - [number] , [number] ] ] [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_2a , [ [ [number] ] ] , mask , [number] , beams_2 ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_2a , [ [ [number] ] ] , mask , [number] , beams_2 , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] talea = [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] cut = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] dilation = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_2a , dilation , [number] ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_2a , dilation , [number] , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] talea = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] cut = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] dilation = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_2b , dilation , [number] ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_2b , dilation , [number] , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] talea = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] cut = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] dilation = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_2c , dilation , [number] ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_2c , dilation , [number] , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] signal = baca . sequence ( [ [ [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] signal = signal . helianthate ( [number] , [number] ) [EOL] j3 = lidercfeny . intaglio ( sixteenths , signal , weight = [number] ) [EOL] j3 = lidercfeny . partition_nested_into_canonic_parts ( j3 ) [EOL] [EOL] denominators_3a = baca . sequence ( j3 ) . flatten ( ) [EOL] denominators_3b = [ [number] * _ for _ in denominators_3a ] [EOL] denominators_3c = [ [number] * _ for _ in denominators_3a ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] beams_3 = abjad . Sequence ( j3 ) . partition_by_weights ( [ [number] , [number] , [number] ] ) [EOL] beams_3 = abjad . Sequence ( [ len ( _ ) for _ in beams_3 ] ) [EOL] [EOL] [comment] [EOL] signal = baca . sequence ( [ [ [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] signal = signal . helianthate ( [number] , [number] ) [EOL] period_s = len ( signal ) [EOL] signal = signal . true_indices ( ) [EOL] [comment] [EOL] j3_part_lengths = [ len ( _ ) for _ in j3 ] [EOL] ratios_3 = baca . sequence ( j3 ) . flatten ( ) [EOL] ratios_3 = ratios_3 . negate_elements ( indices = signal , period = period_s ) [EOL] ratios_3 = ratios_3 . partition_by_lengths ( j3_part_lengths ) [EOL] tuplets = [ abjad . makers . tuplet_from_ratio_and_pair ( ratio , ( abjad . mathx . weight ( ratio ) , [number] ) ) for ratio in ratios_3 ] [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] lengths = [ len ( _ ) for _ in ratios_3 ] [EOL] ratios_3 = baca . sequence ( ratios_3 ) . flatten ( ) [EOL] ratios_3 = [ abs ( _ ) for _ in ratios_3 ] [EOL] ratios_3 = ratios_3 . partition_by_lengths ( lengths ) [EOL] tuplets = [ abjad . makers . tuplet_from_ratio_and_pair ( ratio , ( abjad . mathx . weight ( ratio ) , [number] ) ) for ratio in ratios_3 ] [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] mask = [ [ [number] , [number] , - [number] ] , [ [number] , - [number] ] , [ [number] , [number] , - [number] , [number] ] ] [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_3a , prolation [ [number] ] , mask , [number] , beams_1 ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_3a , prolation [ [number] ] , mask , [number] , beams_1 , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] mask = [ [ [number] , [number] , [number] ] , [ [number] , - [number] ] , [ [number] , [number] , - [number] , [number] ] ] [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_3b , [ [ [number] ] ] , mask , [number] , beams_1 ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_3b , [ [ [number] ] ] , mask , [number] , beams_1 , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_3b , prolation [ [number] ] , masks [ [number] ] , [number] , beams_1 ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_3b , prolation [ [number] ] , masks [ [number] ] , [number] , beams_1 , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_3c , prolation [ [number] ] , masks [ [number] ] , [number] , beams_3 ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . etc . transforms . stellate ( denominators_3c , prolation [ [number] ] , masks [ [number] ] , [number] , beams_3 , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] talea = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] cut = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] dilation = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_3c , dilation , [number] ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] [comment] [EOL] if INCLUDEFILLED : [EOL] tuplets = lidercfeny . coruscate ( talea , cut , denominators_3c , dilation , [number] , rests = False ) [EOL] add ( staves , tuplets , [string] ) [EOL] [EOL] lidercfeny . make_measures ( staves , lidercfeny . etc . rhythm . measures . meters ) [EOL] [EOL] print ( [string] ) [EOL] with open ( lidercfeny . PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] pickle . dump ( eighths , pointer ) [EOL] with open ( lidercfeny . PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] pickle . dump ( staves , pointer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[abjad.Staff]$ 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import pickle [EOL] [EOL] import abjad [EOL] [EOL] import lidercfeny [EOL] [EOL] from . . cfg import PERSISTENCEDIR [EOL] [EOL] MEASURES = [number] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def fill_with_middle_c ( measures , positions ) : [EOL] [docstring] [EOL] for i , measure in enumerate ( measures ) : [EOL] if ( i + [number] ) in positions : [EOL] numerator , denominator = abjad . get . duration ( measure ) . pair [EOL] parts = abjad . mathx . partition_integer_into_canonic_parts ( numerator ) [EOL] notes = [ abjad . Note ( [number] , ( _ , denominator ) ) for _ in parts ] [EOL] time_signature = abjad . TimeSignature ( measure . meter . pair ) [EOL] abjad . attach ( time_signature , notes [ [number] ] ) [EOL] measures [ i ] = abjad . Container ( notes ) [EOL] [EOL] [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] eighths = pickle . load ( pointer ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] staves = pickle . load ( pointer ) [EOL] [EOL] eighths = eighths [ : MEASURES ] [EOL] for v in abjad . iterate ( staves ) . components ( abjad . Voice ) : [EOL] v [ : ] = v [ : MEASURES ] [EOL] [EOL] fluteVoice = staves [ [number] ] [ [number] ] [EOL] breathVoice = staves [ [number] ] [ [number] ] [EOL] violinVoice = staves [ [number] ] [ [number] ] [EOL] bowVoice = staves [ [number] ] [ [number] ] [EOL] piano1Voice = staves [ [number] ] [ [number] ] [EOL] piano2Voice = staves [ [number] ] [ [number] ] [EOL] [EOL] lidercfeny . replace_measure_contents_with_rests ( fluteVoice , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] , ) [EOL] lidercfeny . replace_measure_contents_with_rests ( breathVoice , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] , ) [EOL] lidercfeny . replace_measure_contents_with_rests ( violinVoice , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] , ) [EOL] lidercfeny . replace_measure_contents_with_rests ( bowVoice , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] , ) [EOL] lidercfeny . replace_measure_contents_with_rests ( piano1Voice , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] , ) [EOL] lidercfeny . replace_measure_contents_with_rests ( piano2Voice , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] , ) [EOL] [EOL] fill_with_middle_c ( violinVoice , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] fill_with_middle_c ( bowVoice , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , [number] ] ) [EOL] bowVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , [number] ] ) [EOL] bowVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , [number] ] ) [EOL] bowVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , - [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] fluteVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , - [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] breathVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , - [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano1Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ - [number] , [number] , - [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano1Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ - [number] , [number] , - [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] fluteVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ - [number] , [number] , - [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] breathVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ - [number] , [number] , - [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano1Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] violinVoice [ [number] - [number] ] [ - [number] ] = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ - [number] ] ) [EOL] [EOL] bowVoice [ [number] - [number] ] [ - [number] ] = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ - [number] ] ) [EOL] [EOL] fill_with_middle_c ( piano1Voice , [ [number] , [number] ] ) [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano2Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] fill_with_middle_c ( fluteVoice , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , [number] ] ) [EOL] fluteVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] fluteVoice [ [number] - [number] ] [ [number] ] [ [number] ] = abjad . Rest ( ( [number] , [number] ) ) [EOL] fluteVoice [ [number] - [number] ] [ [number] ] [ - [number] ] = abjad . Rest ( ( [number] , [number] ) ) [EOL] [EOL] fill_with_middle_c ( breathVoice , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] breathVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano2Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] breathVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano2Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] breathVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano2Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] breathVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano2Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [number] * [ [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano2Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] violinVoice [ [number] - [number] ] [ [number] ] [ [number] : [number] ] = [ abjad . Rest ( ( [number] , [number] ) ) ] [EOL] lastNote = violinVoice [ [number] - [number] ] [ [number] ] [ [number] ] [EOL] [EOL] violinVoice [ [number] - [number] ] [ [number] ] [ [number] : [number] ] = [ abjad . Rest ( ( [number] , [number] ) ) ] [EOL] firstNote = violinVoice [ [number] - [number] ] [ [number] ] [ [number] ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano1Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ - [number] , [number] ] ) [EOL] bowVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] breathVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] bowVoice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ [number] , [number] ] ) [EOL] abjad . beam ( new [ : ] ) [EOL] piano2Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] new = abjad . makers . tuplet_from_duration_and_ratio ( ( [number] , [number] ) , [ - [number] , - [number] , [number] ] ) [EOL] piano2Voice [ [number] - [number] ] [ : ] = [ new ] [EOL] [EOL] fluteVoice [ [number] - [number] ] [ [number] ] [ [number] ] = abjad . Rest ( ( [number] , [number] ) ) [EOL] fluteVoice [ [number] - [number] ] [ [number] ] [ [number] ] = abjad . Rest ( ( [number] , [number] ) ) [EOL] fluteVoice [ [number] - [number] ] [ [number] ] [ [number] ] = abjad . Rest ( ( [number] , [number] ) ) [EOL] [EOL] violinVoice [ [number] - [number] ] [ [number] ] [ - [number] ] = abjad . Rest ( ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] with open ( PERSISTENCEDIR / [string] , [string] ) as pointer : [EOL] pickle . dump ( staves , pointer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import abjad [EOL] import baca [EOL] [EOL] eighths = baca . sequence ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] eighths = eighths . helianthate ( [number] , [number] ) [EOL] assert len ( eighths ) == [number] [EOL] assert eighths [ - [number] : ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] eighths = eighths . split_by_weights ( [ [number] ] , cyclic = True , overhang = True ) [EOL] [EOL] eighths = baca . sequence ( eighths ) . flatten ( ) [EOL] assert len ( eighths ) == [number] [EOL] assert eighths [ - [number] : ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] eighths = [ int ( x ) if int ( x ) == x else x for x in eighths ] [EOL] assert eighths [ - [number] : ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] meters = [ ( _ , [number] ) if _ == int ( _ ) else ( int ( _ * [number] ) , [number] ) for _ in eighths ] [EOL] durations = [ abjad . Duration ( * p ) for p in meters ] [EOL] directives = [ [string] % ( p [ [number] ] , p [ [number] ] ) for p in meters ] [EOL] sixteenths = [ int ( [number] * eighth ) for eighth in eighths ] [EOL] thirties = [ int ( [number] * eighth ) for eighth in eighths ] [EOL] [EOL] assert thirties [ - [number] : ] == [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , List , Any , Dict , Tuple [EOL] import typing [EOL] import builtins [EOL] import typing [EOL] [EOL] import abjad [EOL] import baca [EOL] [EOL] PRINTPARTS = False [EOL] [EOL] [EOL] def H ( list_ ) : [EOL] return baca . sequence ( list_ ) . helianthate ( [number] , [number] ) [EOL] [EOL] [EOL] parts = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] names = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] starts = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] end = [number] [EOL] lengths = abjad . mathx . difference_series ( starts + [ end ] ) [EOL] length = len ( lengths ) [EOL] cuts = zip ( starts , lengths ) [EOL] [EOL] first = H ( [ [ [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] second = H ( [ [ [number] ] , [ [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [comment] [EOL] third = H ( [ [ [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] third [ [number] - [number] ] = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] v1 = first . repeat_to_length ( length , start = [number] ) [EOL] v2 = first . repeat_to_length ( length , start = length ) [EOL] [EOL] f1 = second . repeat_to_length ( length , start = [number] ) [EOL] f2 = second . repeat_to_length ( length , start = length ) [EOL] [EOL] p1 = third . repeat_to_length ( length , start = [number] ) [EOL] p2 = third . repeat_to_length ( length , start = length ) [EOL] [EOL] [comment] [EOL] for part in [ v1 , f1 , p1 , p2 ] : [EOL] for i , x in enumerate ( part ) : [EOL] part [ i ] = [number] * x - [number] [EOL] [EOL] [comment] [EOL] for part in [ v2 , f2 ] : [EOL] for i , x in enumerate ( part ) : [EOL] part [ i ] = [number] * x [EOL] [EOL] weft = { } [EOL] weft [ [string] ] = names [EOL] weft [ [string] ] = parts [EOL] weft [ [string] ] = cuts [EOL] for part in parts : [EOL] weft [ part ] = eval ( part ) [EOL] [EOL] ff = [ [string] ] [EOL] ff . extend ( starts ) [EOL] warp = zip ( ff , v1 , v2 , f1 , f2 , p1 , p2 ) [EOL] [EOL] if PRINTPARTS : [EOL] print ( ) [EOL] print ( [string] ) [EOL] for part in parts : [EOL] print ( [string] % part ) [EOL] print ( ) [EOL] for row in warp : [EOL] for element in row : [EOL] print ( [string] % element ) [EOL] print ( ) [EOL] print ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.int,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.int,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[typing.Any,...]]$ 0 0 0 $typing.List$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[typing.Any,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0