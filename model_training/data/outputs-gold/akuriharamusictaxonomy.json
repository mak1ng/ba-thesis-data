from typing import Dict , Union , Optional [EOL] import typing [EOL] import os [EOL] [EOL] import tornado [EOL] import tornado . options [EOL] from tornado . options import define [EOL] [EOL] define ( [string] , help = [string] , type = int ) [EOL] tornado . options . parse_command_line ( ) [EOL] [EOL] settings = { [string] : True , [string] : True , [string] : [string] , [string] : False , [string] : os . path . join ( os . path . dirname ( __file__ ) , [string] ) , [string] : os . path . join ( os . path . dirname ( __file__ ) , [string] ) , } [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] SPOTIFY_CLIENT_ID = os . environ . get ( [string] ) [EOL] SPOTIFY_CLIENT_SECRET = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] DATABASE_URL = os . environ . get ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] import json [EOL] [EOL] from musictaxonomy . auth import service as auth_service [EOL] from tornado . web import RequestHandler [EOL] [EOL] [EOL] class BaseAPIHandler ( RequestHandler ) : [EOL] def set_default_headers ( self ) : [EOL] self . set_header ( [string] , [string] ) [EOL] self . set_header ( [string] , [string] ) [EOL] self . set_header ( [string] , [string] ) [EOL] [EOL] def write_error ( self , status_code , ** kwargs ) : [EOL] self . set_header ( [string] , [string] ) [EOL] response_body = { [string] : { [string] : status_code , [string] : self . _reason } } [EOL] [EOL] return self . finish ( json . dumps ( response_body ) ) [EOL] [EOL] def get_access_token ( self ) : [EOL] [docstring] [EOL] access_token = self . get_secure_cookie ( [string] ) [EOL] access_token = access_token . decode ( [string] ) if access_token else None [EOL] [EOL] return access_token [EOL] [EOL] [EOL] class IndexHandler ( BaseAPIHandler ) : [EOL] async def get ( self ) : [EOL] [docstring] [EOL] access_token = self . get_access_token ( ) [EOL] is_access_token_valid = await auth_service . is_access_token_valid ( access_token ) [EOL] [EOL] [comment] [EOL] if not is_access_token_valid : [EOL] return self . redirect ( [string] , permanent = False ) [EOL] [EOL] self . render ( [string] ) [EOL] [EOL] [EOL] class StatusHandler ( BaseAPIHandler ) : [EOL] def get ( self ) : [EOL] [docstring] [EOL] response = { [string] : [string] , [string] : [number] } [EOL] [EOL] return self . write ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0
	0
from typing import Any [EOL] import typing [EOL] from sqlalchemy import create_engine [EOL] from sqlalchemy . ext . declarative import declarative_base [EOL] from sqlalchemy . orm import sessionmaker [EOL] [EOL] from settings import DATABASE_URL [EOL] [EOL] engine = create_engine ( DATABASE_URL , echo = True ) [EOL] [EOL] [comment] [EOL] Base = declarative_base ( ) [EOL] [EOL] [comment] [EOL] Session = sessionmaker ( ) [EOL] Session . configure ( bind = engine ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0
	0
from typing import Coroutine , Dict , List , Type , Any [EOL] import musictaxonomy [EOL] import builtins [EOL] import typing [EOL] from typing import Any , Dict , List [EOL] [EOL] from musictaxonomy . spotify import client as spotify_client [EOL] from musictaxonomy . spotify . models import SpotifyArtist , SpotifyUser [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] SpotifyArtistDocument = Dict [ str , Any ] [EOL] [EOL] [EOL] async def get_spotify_user ( access_token ) : [EOL] user_profile_response = await spotify_client . get_current_user_profile ( access_token ) [EOL] spotify_user = SpotifyUser ( id = user_profile_response [ [string] ] , display_name = user_profile_response [ [string] ] , ) [EOL] [EOL] return spotify_user [EOL] [EOL] [EOL] async def get_all_top_artists_for_user ( access_token ) : [EOL] futures = [ spotify_client . get_top_artists_in_time_range ( access_token , time_range ) for time_range in ( [string] , [string] , [string] ) ] [EOL] responses = [ await future for future in futures ] [EOL] [EOL] return [ spotify_artist for response in responses for spotify_artist in _parse_spotify_artists_from_top_artists_response ( response ) ] [EOL] [EOL] [EOL] def _parse_spotify_artists_from_top_artists_response ( response , ) : [EOL] artist_documents = response [ [string] ] [EOL] return [ _parse_spotify_artist_from_artist_document ( document ) for document in artist_documents ] [EOL] [EOL] [EOL] def _parse_spotify_artist_from_artist_document ( artist_document , ) : [EOL] return SpotifyArtist ( id = artist_document [ [string] ] , name = artist_document [ [string] ] , genres = artist_document [ [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.spotify.models.SpotifyUser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[musictaxonomy.spotify.models.SpotifyArtist]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[musictaxonomy.spotify.models.SpotifyArtist]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.spotify.models.SpotifyArtist$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import builtins [EOL] import typing [EOL] import json [EOL] import urllib . parse [EOL] from typing import Dict [EOL] [EOL] from musictaxonomy . spotify import constants as spotify_constants [EOL] from settings import SPOTIFY_CLIENT_ID , SPOTIFY_CLIENT_SECRET [EOL] from tornado . httpclient import AsyncHTTPClient [EOL] [EOL] __all__ = [ [string] , [string] , [string] , ] [EOL] [EOL] [EOL] async def get_access_token ( authorization_code , redirect_base_url ) : [EOL] post_data = { [string] : [string] , [string] : authorization_code , [string] : [string] . format ( redirect_base_url ) , [string] : SPOTIFY_CLIENT_ID , [string] : SPOTIFY_CLIENT_SECRET , } [EOL] body = urllib . parse . urlencode ( post_data ) [EOL] [EOL] response = await AsyncHTTPClient ( ) . fetch ( spotify_constants . SPOTIFY_TOKEN_URL , method = [string] , body = body ) [EOL] [EOL] return json . loads ( response . body ) [EOL] [EOL] [EOL] async def get_current_user_profile ( access_token ) : [EOL] headers = { [string] : [string] . format ( access_token ) } [EOL] url = [string] . format ( base = spotify_constants . SPOTIFY_API_BASE_URL ) [EOL] [EOL] response = await AsyncHTTPClient ( ) . fetch ( url , method = [string] , headers = headers ) [EOL] [EOL] parsed_body = json . loads ( response . body ) [EOL] [EOL] return parsed_body [EOL] [EOL] [EOL] async def get_top_artists_in_time_range ( access_token , time_range ) : [EOL] query_parameters = { [string] : time_range , [string] : [number] } [EOL] headers = { [string] : [string] . format ( access_token ) } [EOL] url = [string] . format ( base = spotify_constants . SPOTIFY_API_BASE_URL , query_string = urllib . parse . urlencode ( query_parameters ) , ) [EOL] [EOL] response = await AsyncHTTPClient ( ) . fetch ( url , method = [string] , headers = headers ) [EOL] [EOL] parsed_body = json . loads ( response . body ) [EOL] [EOL] return parsed_body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] class SpotifyUser ( object ) : [EOL] [EOL] __slots__ = [ [string] , [string] ] [EOL] [EOL] def __init__ ( self , id , display_name ) : [EOL] self . id = id [EOL] self . display_name = display_name [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . id ) [EOL] [EOL] [EOL] class SpotifyArtist ( object ) : [EOL] [EOL] __slots__ = [ [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , id , name , genres ) : [EOL] self . id = id [EOL] self . name = name [EOL] self . genres = genres [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
SPOTIFY_AUTHORIZATION_BASE_URL = [string] [EOL] SPOTIFY_AUTHORIZE_URL = SPOTIFY_AUTHORIZATION_BASE_URL + [string] [EOL] SPOTIFY_TOKEN_URL = SPOTIFY_AUTHORIZATION_BASE_URL + [string] [EOL] SPOTIFY_API_BASE_URL = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import musictaxonomy [EOL] import typing [EOL] from musictaxonomy . auth import service as auth_service [EOL] from musictaxonomy . handlers import BaseAPIHandler [EOL] from musictaxonomy . spotify import service as spotify_service [EOL] [EOL] [EOL] class LoginHandler ( BaseAPIHandler ) : [EOL] async def get ( self ) : [EOL] [docstring] [EOL] access_token = self . get_access_token ( ) [EOL] is_access_token_valid = await auth_service . is_access_token_valid ( access_token ) [EOL] [EOL] [comment] [EOL] if is_access_token_valid : [EOL] return self . redirect ( [string] , permanent = False ) [EOL] [EOL] redirect_base_url = [string] . format ( protocol = self . request . protocol , host = self . request . host ) [EOL] spotify_authorize_url = auth_service . generate_spotify_authorize_url ( redirect_base_url ) [EOL] [EOL] return self . redirect ( spotify_authorize_url , permanent = False ) [EOL] [EOL] [EOL] class OauthCallbackHandler ( BaseAPIHandler ) : [EOL] async def get ( self ) : [EOL] [docstring] [EOL] authorization_code = self . get_argument ( [string] ) [EOL] [EOL] [comment] [EOL] redirect_base_url = [string] . format ( protocol = self . request . protocol , host = self . request . host ) [EOL] access_token = await auth_service . get_spotify_access_token ( authorization_code , redirect_base_url ) [EOL] [EOL] [comment] [EOL] self . set_secure_cookie ( [string] , access_token ) [EOL] [EOL] [comment] [EOL] spotify_user = await spotify_service . get_spotify_user ( access_token ) [EOL] await auth_service . create_new_user_if_necessary ( spotify_user ) [EOL] [EOL] [comment] [EOL] return self . redirect ( [string] , permanent = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $musictaxonomy.spotify.models.SpotifyUser$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $musictaxonomy.spotify.models.SpotifyUser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , List , Optional [EOL] import musictaxonomy [EOL] import builtins [EOL] import typing [EOL] import urllib . parse [EOL] from typing import Optional [EOL] [EOL] from musictaxonomy . auth . models import User [EOL] from musictaxonomy . database import Session [EOL] from musictaxonomy . spotify import client as spotify_client [EOL] from musictaxonomy . spotify import constants as spotify_constants [EOL] from musictaxonomy . spotify . models import SpotifyUser [EOL] from settings import SPOTIFY_CLIENT_ID [EOL] from tornado . httpclient import HTTPClientError [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def generate_spotify_authorize_url ( redirect_base_url ) : [EOL] query_parameters = { [string] : SPOTIFY_CLIENT_ID , [string] : [string] , [string] : [string] . format ( redirect_base_url ) , [string] : [string] , } [EOL] spotify_authorize_url = [string] . format ( base = spotify_constants . SPOTIFY_AUTHORIZE_URL , query_string = urllib . parse . urlencode ( query_parameters ) , ) [EOL] [EOL] return spotify_authorize_url [EOL] [EOL] [EOL] async def get_spotify_access_token ( authorization_code , redirect_base_url ) : [EOL] access_token_response = await spotify_client . get_access_token ( authorization_code , redirect_base_url ) [EOL] [EOL] return access_token_response [ [string] ] [EOL] [EOL] [EOL] async def is_access_token_valid ( access_token ) : [EOL] if not access_token : [EOL] return False [EOL] [EOL] try : [EOL] await spotify_client . get_current_user_profile ( access_token ) [EOL] except HTTPClientError : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] async def create_new_user_if_necessary ( spotify_user ) : [EOL] session = Session ( ) [EOL] user = None [EOL] [EOL] if not _does_spotify_user_exist ( session , spotify_user ) : [EOL] user = _create_user_from_spotify_user ( session , spotify_user , should_commit = True ) [EOL] [EOL] return user [EOL] [EOL] [EOL] def _does_spotify_user_exist ( session , spotify_user ) : [EOL] [docstring] [EOL] number_of_users = ( session . query ( User ) . filter_by ( external_id = spotify_user . id , external_source = [string] ) . count ( ) ) [EOL] return number_of_users > [number] [EOL] [EOL] [EOL] def _create_user_from_spotify_user ( session , spotify_user , should_commit = False ) : [EOL] [docstring] [EOL] user = User ( display_name = spotify_user . display_name , external_source = [string] , external_id = spotify_user . id , ) [EOL] session . add ( user ) [EOL] [EOL] if should_commit : [EOL] session . commit ( ) [EOL] [EOL] return user [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[musictaxonomy.auth.models.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.auth.models.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import musictaxonomy [EOL] import typing [EOL] from musictaxonomy . database import Base [EOL] from sqlalchemy import Column , Integer , String [EOL] [EOL] [EOL] class User ( Base ) : [EOL] __tablename__ = [string] [EOL] [EOL] id = Column ( Integer , primary_key = True ) [EOL] display_name = Column ( String ( [number] ) , nullable = False ) [EOL] external_source = Column ( String ( [number] ) , nullable = False ) [EOL] external_id = Column ( Integer , nullable = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Type[musictaxonomy.auth.models.User]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[musictaxonomy.auth.models.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[musictaxonomy.auth.models.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[musictaxonomy.auth.models.User]$ 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from musictaxonomy . auth import models as auth_models [comment] [EOL] from musictaxonomy . database import Base , Session , engine [EOL] from musictaxonomy . graph import models as graph_models [comment] [EOL] [EOL] [EOL] def main ( ) : [EOL] Base . metadata . create_all ( engine ) [EOL] [EOL] session = Session ( ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] session . add ( graph_models . MainGenre ( id = [number] , spotify_name = [string] , display_name = [string] ) ) [EOL] [EOL] session . commit ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import musictaxonomy [EOL] from unittest import TestCase [EOL] [EOL] from musictaxonomy . spotify . models import SpotifyArtist , SpotifyUser [EOL] [EOL] [EOL] class SpotifyArtistTest ( TestCase ) : [EOL] def test_conversion_to_string ( self ) : [EOL] spotify_artist = SpotifyArtist ( id = [string] , name = [string] , genres = [ [string] , [string] , [string] ] , ) [EOL] [EOL] self . assertEqual ( str ( spotify_artist ) , [string] ) [EOL] [EOL] [EOL] class SpotifyUserTest ( TestCase ) : [EOL] def test_conversion_to_string ( self ) : [EOL] spotify_user = SpotifyUser ( id = [string] , display_name = [string] ) [EOL] [EOL] self . assertEqual ( str ( spotify_user ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.spotify.models.SpotifyArtist$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.spotify.models.SpotifyArtist$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.spotify.models.SpotifyUser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.spotify.models.SpotifyUser$ 0 0 0 0 0
	0
	0
	0
import musictaxonomy [EOL] from unittest import TestCase [EOL] [EOL] from musictaxonomy . graph . models import Node , TaxonomyGraph [EOL] [EOL] [EOL] class TaxonomyGraphTest ( TestCase ) : [EOL] def test_add_genre_node_with_duplicate_id ( self ) : [EOL] taxonomy_graph = TaxonomyGraph ( [string] ) [EOL] taxonomy_graph . add_genre_node ( [string] ) [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] taxonomy_graph . add_genre_node ( [string] ) [EOL] [EOL] def test_add_subgenre_node_with_duplicate_id ( self ) : [EOL] taxonomy_graph = TaxonomyGraph ( [string] ) [EOL] taxonomy_graph . add_subgenre_node ( [string] , [string] ) [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] taxonomy_graph . add_subgenre_node ( [string] , [string] ) [EOL] [EOL] def test_add_artist_node_with_duplicate_id ( self ) : [EOL] taxonomy_graph = TaxonomyGraph ( [string] ) [EOL] taxonomy_graph . add_artist_node ( [string] , [string] ) [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] taxonomy_graph . add_artist_node ( [string] , [string] ) [EOL] [EOL] [EOL] class NodeTest ( TestCase ) : [EOL] def test_conversion_to_string ( self ) : [EOL] first_node = Node ( id = [string] ) [EOL] second_node = Node ( id = [string] ) [EOL] first_node . add_neighbor ( second_node ) [EOL] [EOL] self . assertEqual ( str ( first_node ) , [string] ) [EOL] [EOL] def test_render_as_json ( self ) : [EOL] node = Node ( id = [string] ) [EOL] [EOL] self . assertEqual ( node . render_as_json ( ) , { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.TaxonomyGraph$ 0 0 0 0 0 0 $musictaxonomy.graph.models.TaxonomyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.TaxonomyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.TaxonomyGraph$ 0 0 0 0 0 0 $musictaxonomy.graph.models.TaxonomyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.TaxonomyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.TaxonomyGraph$ 0 0 0 0 0 0 $musictaxonomy.graph.models.TaxonomyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.TaxonomyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.Node$ 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.Node$ 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.Node$ 0 0 0 $musictaxonomy.graph.models.Node$ 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $musictaxonomy.graph.models.Node$ 0 0 0 0 0 0 0 0 0 0 0 0
	0