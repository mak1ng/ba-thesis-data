[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] from setuptools import setup , find_packages [EOL] [EOL] [EOL] with open ( [string] ) as readme_file : [EOL] README = readme_file . read ( ) [EOL] [EOL] [EOL] with open ( [string] ) as history_file : [EOL] HISTORY = history_file . read ( ) [EOL] [EOL] [EOL] with open ( os . path . join ( [string] , [string] ) ) as fp : [EOL] REQUIREMENTS = [ x for x in fp if not x . startswith ( [string] ) ] [EOL] [EOL] [EOL] setup ( author = [string] , author_email = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , ] , description = [string] [string] , entry_points = { [string] : [ [string] , ] , } , extras_require = { [string] : [ [string] ] , } , install_requires = REQUIREMENTS , license = [string] , long_description = README + [string] + HISTORY , include_package_data = True , keywords = [string] , name = [string] , packages = find_packages ( [string] ) , package_dir = { [string] : [string] } , setup_requires = [ [string] ] , test_suite = [string] , tests_require = [ [string] ] , url = [string] , version = [string] , zip_safe = False , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import click [EOL] import typing [EOL] [docstring] [EOL] [EOL] from click . testing import CliRunner [EOL] from moto import mock_cloudwatch [EOL] [EOL] from awsme . cli import main [EOL] from awsme import create_cloud_watch [EOL] [EOL] [EOL] @ mock_cloudwatch def test_command_line_interface ( ) : [EOL] [docstring] [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( main ) [EOL] assert result . exit_code == [number] [EOL] assert [string] in result . output [EOL] help_result = runner . invoke ( main , [ [string] ] ) [EOL] assert help_result . exit_code == [number] [EOL] assert [string] in help_result . output [EOL] [EOL] [EOL] @ mock_cloudwatch def test_put_metric ( ) : [EOL] cloud_watch = create_cloud_watch ( [string] , buffered = False , dummy = False , dimensions = { [string] : [string] } , ) [EOL] cloud_watch . log ( [string] , { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import builtins [EOL] from __future__ import print_function [EOL] [EOL] import datetime [EOL] [EOL] from awsme . metric import Metric [EOL] from awsme . buffered_recorder import BufferedRecorder [EOL] from typing import List , Dict , Any [comment] [EOL] [EOL] class StdoutRecorder : [EOL] [EOL] def put_metric_data ( self , metric_data ) : [EOL] print ( metric_data ) [EOL] [EOL] recorder = BufferedRecorder ( recorder = StdoutRecorder ( ) ) [EOL] recorder . put_metric ( Metric ( event_time = datetime . datetime . min , name = [string] , dimensions = { } , ) ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] [EOL] from awsme . metric import Metric [EOL] [EOL] [EOL] def test_sample_metric_formatting ( ) : [EOL] metric = Metric ( event_time = datetime . datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , name = [string] , dimensions = { [string] : [string] , [string] : [string] , } , ) [EOL] data = metric . to_metric_data ( ) [EOL] assert data == [ { [string] : [ { [string] : [string] , [string] : [string] } , ] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [number] } , { [string] : [ { [string] : [string] , [string] : [string] } , ] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [number] } , { [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [number] } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import subprocess [EOL] import unittest [EOL] import datetime [EOL] import logging [EOL] import subprocess [EOL] from unittest import mock [EOL] [EOL] from awsme . immediate_recorder import ImmediateRecorder [EOL] from awsme . metric import Metric [EOL] from awsme . buffered_recorder import ( BufferedRecorder , PAGE_SIZE , MAX_BATCH_SIZE , MAX_BUFFER_SIZE , ) [EOL] [EOL] [EOL] def test_buffered_recorder_buffers_incomplete_page ( ) : [EOL] _ , fake_recorder = make_recorder ( [number] ) [EOL] assert fake_recorder . called == [number] [EOL] [EOL] [EOL] def test_buffered_recorder_flushes_full_page ( ) : [EOL] _ , fake_recorder = make_recorder ( [number] ) [EOL] fake_recorder . put_metric_data . assert_called_once ( ) [EOL] assert len ( fake_recorder . put_metric_data . call_args [ [number] ] [ [number] ] ) == PAGE_SIZE [EOL] [EOL] [EOL] def test_buffered_recorder_rate_control ( caplog ) : [EOL] with caplog . at_level ( logging . WARNING ) : [EOL] _ , fake_recorder = make_recorder ( MAX_BUFFER_SIZE ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert fake_recorder . put_metric_data . call_count == MAX_BATCH_SIZE [EOL] [EOL] [EOL] def test_buffered_recorder_complete_flush_keeps_nothing ( ) : [EOL] recorder , fake_recorder = make_recorder ( MAX_BUFFER_SIZE ) [EOL] recorder . flush ( ) [EOL] assert fake_recorder . put_metric_data . call_count == MAX_BUFFER_SIZE // PAGE_SIZE [EOL] [EOL] def test_buffered_recorder_flush_atexit ( ) : [EOL] completed_process = subprocess . run ( [ [string] , [string] ] , stdout = subprocess . PIPE , check = True ) [EOL] result = completed_process . stdout . decode ( ) [EOL] test_metric = Metric ( event_time = datetime . datetime . min , name = [string] , dimensions = { } , ) [EOL] test_result = [string] . format ( test_metric . to_metric_data ( ) ) [EOL] assert result == test_result [EOL] [EOL] [EOL] def make_recorder ( dimensions_count ) : [EOL] fake_recorder = mock . Mock ( spec = ImmediateRecorder ) [EOL] recorder = BufferedRecorder ( recorder = fake_recorder ) [EOL] recorder . put_metric ( Metric ( datetime . datetime . utcnow ( ) , [string] , { str ( number ) : str ( number ) for number in range ( dimensions_count ) } , ) ) [EOL] return recorder , fake_recorder [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Dict , Tuple , List [EOL] import typing [EOL] import os [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] [EOL] import awsme [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = awsme . __version__ [EOL] [comment] [EOL] release = awsme . __version__ [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] todo_include_todos = False [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0