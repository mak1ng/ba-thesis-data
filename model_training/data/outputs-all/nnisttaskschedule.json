[comment] [EOL] [EOL] from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , license = [string] , author = [string] , author_email = [string] , description = [string] , long_description = [string] [string] [string] , url = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , python_requires = [string] , packages = [ [string] , [string] ] , scripts = [ [string] ] , include_package_data = True , install_requires = [ [string] , [string] ] , extras_require = { [string] : [ [string] , [string] ] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import taskschedule [EOL] import os [EOL] import sys [EOL] [EOL] from taskschedule . main import Main [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] main = Main ( sys . argv [ [number] : ] ) [EOL] main . main ( ) [EOL] except KeyboardInterrupt : [EOL] print ( [string] ) [EOL] try : [EOL] sys . exit ( [number] ) [EOL] except SystemExit : [EOL] os . _exit ( [number] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.main.Main$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.main.Main$ 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.main.Main$ 0 $taskschedule.main.Main$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import taskschedule [EOL] import datetime [EOL] from __future__ import annotations [EOL] [EOL] from typing import TYPE_CHECKING [EOL] [EOL] from taskschedule . main import Main [EOL] from taskschedule . utils import calculate_datetime [EOL] [EOL] if TYPE_CHECKING : [EOL] from datetime import datetime [EOL] [EOL] [EOL] class TestMain : [EOL] def test_main_init_creates_backend_and_schedule ( self , tw ) : [EOL] main = Main ( [ [string] , [string] , [string] ] ) [EOL] [EOL] backend = main . backend [EOL] assert backend . taskrc_location == [string] [EOL] [EOL] schedule = main . schedule [EOL] assert schedule . backend is backend [EOL] [EOL] def test_main_command_args ( self , tw ) : [EOL] main = Main ( [ [string] , [string] , [string] ] ) [EOL] backend = main . backend [EOL] task_command = backend . task_command [EOL] assert [string] in task_command [EOL] assert [string] in task_command [EOL] [EOL] scheduled_after = calculate_datetime ( [string] ) [EOL] scheduled_before = calculate_datetime ( [string] ) [EOL] assert f" [string] { scheduled_after }" in task_command [EOL] assert f" [string] { scheduled_before }" in task_command [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.main.Main$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 $taskschedule.main.Main$ 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 $taskschedule.main.Main$ 0 $taskschedule.schedule.Schedule$ 0 0 $taskschedule.schedule.Schedule$ 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.main.Main$ 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 $taskschedule.main.Main$ 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 0 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0
from typing import List , Optional , Dict , Any [EOL] import taskschedule [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import TYPE_CHECKING [EOL] [EOL] import pytest [EOL] [EOL] from taskschedule . utils import calculate_datetime [EOL] [EOL] if TYPE_CHECKING : [EOL] from taskschedule . schedule import Schedule [EOL] [EOL] [EOL] class TestSchedule : [EOL] def test_get_tasks_returns_correct_tasks ( self , schedule ) : [EOL] tasks = schedule . tasks [EOL] assert len ( tasks ) == [number] [EOL] assert tasks [ [number] ] [ [string] ] == [string] [EOL] assert tasks [ [number] ] [ [string] ] == [string] [EOL] assert tasks [ [number] ] [ [string] ] == [string] [EOL] assert tasks [ [number] ] [ [string] ] == [string] [EOL] assert tasks [ [number] ] [ [string] ] == [string] [EOL] assert tasks [ [number] ] [ [string] ] == [string] [EOL] assert tasks [ [number] ] [ [string] ] == [string] [EOL] [EOL] def test_clear_cache ( self , schedule ) : [EOL] tasks = schedule . tasks [EOL] assert tasks [EOL] schedule . clear_cache ( ) [EOL] with pytest . raises ( KeyError ) : [EOL] schedule . __dict__ [ [string] ] [EOL] [EOL] tasks = schedule . tasks [EOL] assert tasks [EOL] [EOL] def test_get_time_slots_returns_correct_amount_of_days ( self , schedule ) : [EOL] time_slots = schedule . get_time_slots ( ) [EOL] assert len ( time_slots ) == [number] [EOL] [EOL] def test_get_time_slots_has_correct_tasks ( self , schedule ) : [EOL] time_slots = schedule . get_time_slots ( ) [EOL] [EOL] yesterday = calculate_datetime ( [string] ) . date ( ) . isoformat ( ) [EOL] today = calculate_datetime ( [string] ) . date ( ) . isoformat ( ) [EOL] tomorrow = calculate_datetime ( [string] ) . date ( ) . isoformat ( ) [EOL] [EOL] assert time_slots [ yesterday ] [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert time_slots [ today ] [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert time_slots [ today ] [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert time_slots [ today ] [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert time_slots [ tomorrow ] [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] def test_get_max_length ( self , schedule ) : [EOL] length = schedule . get_max_length ( [string] ) [EOL] assert length == [number] [EOL] [EOL] def test_get_column_offsets ( self , schedule ) : [EOL] offsets = schedule . get_column_offsets ( ) [EOL] assert offsets == [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] def test_get_next_task_returns_next_task ( self , schedule ) : [EOL] next_task = schedule . get_next_task ( schedule . tasks [ [number] ] ) [EOL] if next_task : [EOL] assert next_task [ [string] ] == [string] [EOL] else : [EOL] pytest . fail ( [string] ) [EOL] [EOL] def test_get_next_task_for_last_task_returns_none ( self , schedule ) : [EOL] next_task = schedule . get_next_task ( schedule . tasks [ [number] ] ) [EOL] assert not next_task [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 $typing.Any$ 0 $taskschedule.schedule.Schedule$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 $typing.Any$ 0 $taskschedule.schedule.Schedule$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $taskschedule.schedule.Schedule$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 0 0 0 0 $typing.Any$ 0 $taskschedule.schedule.Schedule$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $taskschedule.schedule.Schedule$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $taskschedule.schedule.Schedule$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 $builtins.int$ 0 $taskschedule.schedule.Schedule$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 $typing.List[builtins.int]$ 0 $taskschedule.schedule.Schedule$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 $typing.Optional[taskschedule.scheduled_task.ScheduledTask]$ 0 $taskschedule.schedule.Schedule$ 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 0 0 0 0 0 $typing.Optional[taskschedule.scheduled_task.ScheduledTask]$ 0 0 0 $typing.Optional[taskschedule.scheduled_task.ScheduledTask]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 $typing.Optional[taskschedule.scheduled_task.ScheduledTask]$ 0 $taskschedule.schedule.Schedule$ 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 0 0 0 0 0 0 $typing.Optional[taskschedule.scheduled_task.ScheduledTask]$ 0
import taskschedule [EOL] from taskschedule . config_parser import ConfigParser [EOL] [EOL] [EOL] class TestConfigParser : [EOL] def test_config_parser ( self ) : [EOL] parser = ConfigParser ( ) [EOL] assert parser . config ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.config_parser.ConfigParser$ 0 0 0 0 0 0 $taskschedule.config_parser.ConfigParser$ 0 0 0 0 0
from typing import List , Tuple , Any [EOL] import taskschedule [EOL] import typing [EOL] from taskschedule . screen import Screen [EOL] [EOL] [EOL] class TestScreen : [EOL] def test_screen_scroll_up_at_top_is_blocked ( self , screen ) : [EOL] current_scroll_level = screen . scroll_level [EOL] screen . scroll ( - [number] ) [EOL] assert current_scroll_level == screen . scroll_level [EOL] [EOL] def test_screen_scroll_down_and_up ( self , screen ) : [EOL] current_scroll_level = screen . scroll_level [EOL] screen . scroll ( [number] ) [EOL] assert current_scroll_level + [number] == screen . scroll_level [EOL] [EOL] current_scroll_level = screen . scroll_level [EOL] screen . scroll ( - [number] ) [EOL] assert current_scroll_level - [number] == screen . scroll_level [EOL] [EOL] def test_prerender_footnote ( self , screen ) : [EOL] footnote = screen . prerender_footnote ( ) [EOL] count = len ( screen . schedule . tasks ) [EOL] assert f"{ count } [string] " in footnote [EOL] [EOL] def test_prerender_buffer ( self , screen ) : [EOL] header_buffer = screen . prerender_headers ( ) [EOL] assert [string] in header_buffer [ [number] ] [ [number] ] [EOL] assert header_buffer [ [number] ] [ [number] ] == [number] [EOL] assert [string] in header_buffer [ [number] ] [ [number] ] [EOL] assert header_buffer [ [number] ] [ [number] ] == [number] [EOL] assert [string] in header_buffer [ [number] ] [ [number] ] [EOL] assert header_buffer [ [number] ] [ [number] ] == [number] [EOL] assert [string] in header_buffer [ [number] ] [ [number] ] [EOL] assert header_buffer [ [number] ] [ [number] ] == [number] [EOL] assert [string] in header_buffer [ [number] ] [ [number] ] [EOL] assert header_buffer [ [number] ] [ [number] ] == [number] [EOL] [EOL] def test_predender_divider ( self , screen ) : [EOL] divider_buffer = screen . prerender_divider ( [string] , [number] ) [EOL] assert [string] in divider_buffer [ [number] ] [ [number] ] [EOL] assert [string] in divider_buffer [ [number] ] [ [number] ] [EOL] assert divider_buffer [ [number] ] [ [number] ] == [number] [EOL] assert ( [string] in divider_buffer [ [number] ] [ [number] ] ) [EOL] assert divider_buffer [ [number] ] [ [number] ] == [number] [EOL] [EOL] def test_prerender_empty_line ( self , screen ) : [EOL] empty_line_buffer = screen . prerender_empty_line ( True , [number] , [number] , [string] ) [EOL] assert [string] in empty_line_buffer [ [number] ] [ [number] ] [EOL] assert empty_line_buffer [ [number] ] [ [number] ] == [number] [EOL] assert empty_line_buffer [ [number] ] [ [number] ] == [string] [EOL] assert empty_line_buffer [ [number] ] [ [number] ] == [number] [EOL] [EOL] def test_prerender_task ( self , screen ) : [EOL] task = screen . schedule . tasks [ [number] ] [EOL] task_buffer = screen . prerender_task ( [number] , task , False , [number] , [number] , [string] ) [EOL] assert task_buffer [ [number] ] [ [number] ] == [number] [EOL] assert [string] in task_buffer [ [number] ] [ [number] ] [EOL] [EOL] [comment] [EOL] assert task_buffer [ [number] ] [ [number] ] == [number] [EOL] assert [string] in task_buffer [ [number] ] [ [number] ] [EOL] [EOL] [comment] [EOL] assert task_buffer [ [number] ] [ [number] ] == [number] [EOL] assert [string] in task_buffer [ [number] ] [ [number] ] [EOL] [EOL] [comment] [EOL] assert task_buffer [ [number] ] [ [number] ] == [number] [EOL] assert [string] in task_buffer [ [number] ] [ [number] ] [EOL] [EOL] [comment] [EOL] assert task_buffer [ [number] ] [ [number] ] == [number] [EOL] assert task_buffer [ [number] ] [ [number] ] == [string] [EOL] [EOL] [comment] [EOL] assert task_buffer [ [number] ] [ [number] ] == [number] [EOL] assert [string] in task_buffer [ [number] ] [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.screen.Screen$ 0 0 0 $builtins.str$ 0 $taskschedule.screen.Screen$ 0 0 0 0 0 $builtins.int$ 0 0 0 $taskschedule.screen.Screen$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $taskschedule.screen.Screen$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 $taskschedule.screen.Screen$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.screen.Screen$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 $taskschedule.screen.Screen$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.screen.Screen$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 $taskschedule.screen.Screen$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.screen.Screen$ 0 0 0 $typing.Any$ 0 $taskschedule.screen.Screen$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 $taskschedule.screen.Screen$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0
import taskschedule [EOL] import datetime [EOL] from __future__ import annotations [EOL] [EOL] import os [EOL] import shutil [EOL] from typing import TYPE_CHECKING [EOL] [EOL] import pytest [EOL] [EOL] from taskschedule . schedule import Schedule , ScheduledTask [EOL] from taskschedule . screen import Screen [EOL] from taskschedule . taskwarrior import PatchedTaskWarrior [EOL] from taskschedule . utils import calculate_datetime [EOL] [EOL] if TYPE_CHECKING : [EOL] from datetime import datetime [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def tw ( ) : [EOL] [docstring] [EOL] [EOL] taskrc_path = [string] [EOL] task_dir_path = [string] [EOL] [EOL] [comment] [EOL] with open ( taskrc_path , [string] ) as file : [EOL] file . write ( [string] ) [EOL] file . write ( [string] ) [EOL] file . write ( [string] ) [EOL] file . write ( [string] ) [EOL] file . write ( [string] ) [EOL] file . write ( [string] ) [EOL] file . write ( [string] ) [EOL] file . write ( [string] ) [EOL] [EOL] [comment] [EOL] os . makedirs ( task_dir_path ) [EOL] [EOL] tw = PatchedTaskWarrior ( data_location = task_dir_path , create = True , taskrc_location = taskrc_path ) [EOL] tw . overrides . update ( { [string] : [string] } ) [EOL] tw . overrides . update ( { [string] : [string] } ) [EOL] [EOL] yield tw [EOL] [EOL] try : [EOL] os . remove ( taskrc_path ) [EOL] except FileNotFoundError : [EOL] pass [EOL] [EOL] try : [EOL] shutil . rmtree ( task_dir_path ) [EOL] except FileNotFoundError : [EOL] pass [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def schedule ( tw ) : [EOL] [docstring] [EOL] ScheduledTask ( tw , description = [string] , schedule = [string] , estimate = [string] ) . save ( ) [EOL] ScheduledTask ( tw , description = [string] , schedule = [string] , estimate = [string] ) . save ( ) [EOL] ScheduledTask ( tw , description = [string] , schedule = [string] , estimate = [string] ) . save ( ) [EOL] ScheduledTask ( tw , description = [string] , schedule = [string] , estimate = [string] ) . save ( ) [EOL] ScheduledTask ( tw , description = [string] , schedule = [string] , estimate = [string] , ) . save ( ) [EOL] ScheduledTask ( tw , description = [string] , schedule = [string] , estimate = [string] ) . save ( ) [EOL] ScheduledTask ( tw , description = [string] , schedule = [string] , estimate = [string] ) . save ( ) [EOL] [EOL] scheduled_after = calculate_datetime ( [string] ) [EOL] scheduled_before = calculate_datetime ( [string] ) [EOL] schedule = Schedule ( backend = tw , scheduled_before = scheduled_before , scheduled_after = scheduled_after ) [EOL] [EOL] yield schedule [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def screen ( tw , schedule ) : [EOL] screen = Screen ( schedule , schedule . scheduled_after , schedule . scheduled_before ) [EOL] yield screen [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from datetime import datetime , timedelta [EOL] [EOL] from taskschedule . utils import calculate_datetime [EOL] [EOL] [EOL] def test_calculate_datetime ( ) : [EOL] assert calculate_datetime ( [string] ) . year == [number] [EOL] assert ( calculate_datetime ( [string] ) . day == ( datetime . today ( ) + timedelta ( days = [number] ) ) . day ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import taskschedule [EOL] import datetime [EOL] import typing [EOL] from datetime import datetime , timedelta [EOL] [EOL] import pytest [EOL] [EOL] from taskschedule . scheduled_task import ScheduledTask [EOL] [EOL] [EOL] def test_as_dict ( tw ) : [comment] [EOL] expected_desc = [string] [EOL] task = ScheduledTask ( backend = tw , description = expected_desc ) [EOL] [EOL] assert task . as_dict ( ) [ [string] ] == expected_desc [EOL] [EOL] [EOL] def test_has_scheduled_time ( tw ) : [comment] [EOL] task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] ) ) [EOL] assert task . has_scheduled_time is True [EOL] task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] ) ) [EOL] assert task . has_scheduled_time is True [EOL] task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] assert task . has_scheduled_time is True [EOL] task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , [number] ) , ) [EOL] assert task . has_scheduled_time is True [EOL] [EOL] task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] ) ) [EOL] assert task . has_scheduled_time is False [EOL] [EOL] [EOL] def test_scheduled_start_datetime ( tw ) : [comment] [EOL] task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] ) ) [EOL] tzinfo = task [ [string] ] . tzinfo [EOL] expected = datetime ( [number] , [number] , [number] , [number] , [number] , tzinfo = tzinfo ) [EOL] assert task . scheduled_start_datetime == expected [EOL] [EOL] task = ScheduledTask ( backend = tw , description = [string] ) [EOL] assert task . scheduled_start_datetime is None [EOL] [EOL] [EOL] def test_scheduled_end_datetime ( tw ) : [comment] [EOL] task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] ) , estimate = [string] , ) [EOL] difference = task . scheduled_end_datetime - task [ [string] ] [EOL] [EOL] assert difference == timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] def test_notified ( tw ) : [comment] [EOL] task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] ) ) [EOL] task . save ( ) [EOL] [EOL] assert task . notified is False [EOL] assert task . notified is True [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_should_be_active ( tw ) : [comment] [EOL] [comment] [EOL] ... [EOL] [EOL] [EOL] def test_overdue ( tw ) : [comment] [EOL] future_task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] ) ) [EOL] old_task = ScheduledTask ( backend = tw , description = [string] , scheduled = datetime ( [number] , [number] , [number] , [number] , [number] ) ) [EOL] [EOL] assert future_task . overdue is False [EOL] assert old_task . overdue is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] DEFAULTS = { [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } } [EOL] [EOL] [EOL] class ConfigParser : [EOL] def config ( self ) : [EOL] [docstring] [EOL] cfg = DEFAULTS [EOL] return cfg [EOL]	0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 $builtins.dict$ 0
from typing import List , Any [EOL] import argparse [EOL] import taskschedule [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import argparse [EOL] import os [EOL] import sys [EOL] import time [EOL] from curses import KEY_RESIZE [EOL] from curses import error as curses_error [EOL] from curses import napms [EOL] from datetime import datetime [EOL] [EOL] from tasklib import TaskWarrior [EOL] [EOL] from taskschedule . notifier import Notifier , SoundDoesNotExistError [EOL] from taskschedule . schedule import ( Schedule , TaskDirDoesNotExistError , TaskrcDoesNotExistError , UDADoesNotExistError , ) [EOL] from taskschedule . screen import Screen [EOL] from taskschedule . taskwarrior import PatchedTaskWarrior [EOL] from taskschedule . utils import calculate_datetime [EOL] [EOL] [EOL] class Main : [EOL] def __init__ ( self , argv ) : [EOL] self . home_dir = os . path . expanduser ( [string] ) [EOL] [EOL] self . parse_args ( argv ) [EOL] self . check_files ( ) [EOL] [EOL] task_command_args = [ [string] , [string] ] [EOL] [EOL] task_command_args . append ( f" [string] { self . scheduled_after }" ) [EOL] task_command_args . append ( f" [string] { self . scheduled_before }" ) [EOL] [EOL] if not self . show_completed : [EOL] task_command_args . append ( f" [string] { self . show_completed }" ) [EOL] [EOL] self . backend = PatchedTaskWarrior ( data_location = self . data_location , create = False , taskrc_location = self . taskrc_location , task_command = [string] . join ( task_command_args ) , ) [EOL] [EOL] self . schedule = Schedule ( self . backend , scheduled_after = self . scheduled_after , scheduled_before = self . scheduled_before , ) [EOL] [EOL] def check_files ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] taskwarrior = TaskWarrior ( data_location = self . data_location , create = False , taskrc_location = self . taskrc_location , ) [EOL] [EOL] [comment] [EOL] taskwarrior . overrides . update ( { [string] : [string] } ) [EOL] [EOL] [comment] [EOL] if os . path . isdir ( self . data_location ) is False : [EOL] raise TaskDirDoesNotExistError ( [string] ) [EOL] if os . path . isfile ( self . taskrc_location ) is False : [EOL] raise TaskrcDoesNotExistError ( [string] ) [EOL] [EOL] [comment] [EOL] if taskwarrior . config . get ( [string] ) is None : [EOL] raise UDADoesNotExistError ( ( [string] [string] ) ) [EOL] if taskwarrior . config . get ( [string] ) is None : [EOL] raise UDADoesNotExistError ( ( [string] [string] ) ) [EOL] [EOL] [comment] [EOL] sound_file = self . home_dir + [string] [EOL] if self . show_notifications and os . path . isfile ( sound_file ) is False : [EOL] raise SoundDoesNotExistError ( f" [string] { sound_file }" ) [EOL] [EOL] [comment] [EOL] taskschedule_dir = self . home_dir + [string] [EOL] hooks_directory = self . home_dir + [string] [EOL] if not os . path . isdir ( taskschedule_dir ) : [EOL] os . mkdir ( taskschedule_dir ) [EOL] if not os . path . isdir ( hooks_directory ) : [EOL] os . mkdir ( hooks_directory ) [EOL] [EOL] def parse_args ( self , argv ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , type = int , default = [number] ) [EOL] parser . add_argument ( [string] , help = [string] , type = str , dest = [string] , default = [string] , ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , type = str , dest = [string] , default = [string] , ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , type = str , dest = [string] , default = f"{ self . home_dir } [string] " , ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , type = str , dest = [string] , default = f"{ self . home_dir } [string] " , ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] , default = False , ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] , default = True , ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] , default = False , ) [EOL] parser . add_argument ( [string] , help = [string] , action = [string] , default = True , dest = [string] , ) [EOL] args = parser . parse_args ( argv ) [EOL] [EOL] if args . before and not args . after or not args . before and args . after : [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] self . data_location = args . data_location [EOL] self . taskrc_location = args . taskrc_location [EOL] [EOL] [comment] [EOL] self . scheduled_after = calculate_datetime ( args . after ) [EOL] self . scheduled_before = calculate_datetime ( args . before ) [EOL] [EOL] self . show_completed = args . completed [EOL] self . hide_empty = not args . all [EOL] self . hide_projects = args . project [EOL] self . refresh_rate = args . refresh [EOL] self . show_notifications = args . notifications [EOL] [EOL] def main ( self ) : [EOL] [docstring] [EOL] [EOL] if self . show_notifications : [EOL] self . notifier = Notifier ( self . backend ) [EOL] else : [EOL] self . notifier = None [EOL] [EOL] self . screen = Screen ( self . schedule , scheduled_after = self . scheduled_after , scheduled_before = self . scheduled_before , hide_empty = self . hide_empty , hide_projects = self . hide_projects , ) [EOL] [EOL] try : [EOL] self . run ( ) [EOL] except TaskDirDoesNotExistError as err : [EOL] print ( [string] . format ( err ) ) [EOL] sys . exit ( [number] ) [EOL] except TaskrcDoesNotExistError as err : [EOL] print ( [string] . format ( err ) ) [EOL] sys . exit ( [number] ) [EOL] except KeyboardInterrupt : [EOL] self . screen . close ( ) [EOL] except ValueError as err : [EOL] self . screen . close ( ) [EOL] print ( [string] . format ( err ) ) [EOL] sys . exit ( [number] ) [EOL] except UDADoesNotExistError as err : [EOL] self . screen . close ( ) [EOL] print ( [string] . format ( err ) ) [EOL] sys . exit ( [number] ) [EOL] except SoundDoesNotExistError as err : [EOL] self . screen . close ( ) [EOL] print ( [string] . format ( err ) ) [EOL] sys . exit ( [number] ) [EOL] else : [EOL] try : [EOL] self . screen . close ( ) [EOL] except curses_error as err : [EOL] print ( err . with_traceback ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] [EOL] filename = f"{ self . data_location } [string] " [EOL] cached_stamp = [number] [EOL] [EOL] last_refresh_time = [number] [EOL] while True : [EOL] key = self . screen . stdscr . getch ( ) [EOL] if key == [number] : [comment] [EOL] break [EOL] elif key == [number] or key == [number] : [comment] [EOL] self . screen . scroll ( - [number] ) [EOL] last_refresh_time = time . time ( ) [EOL] elif key == [number] or key == [number] : [comment] [EOL] self . screen . scroll ( [number] ) [EOL] last_refresh_time = time . time ( ) [EOL] elif key == [number] : [comment] [EOL] max_y , max_x = self . screen . get_maxyx ( ) [EOL] self . screen . scroll ( max_y - [number] ) [EOL] last_refresh_time = time . time ( ) [EOL] elif key == [number] : [comment] [EOL] max_y , max_x = self . screen . get_maxyx ( ) [EOL] self . screen . scroll ( - ( max_y - [number] ) ) [EOL] last_refresh_time = time . time ( ) [EOL] elif key == KEY_RESIZE : [EOL] last_refresh_time = time . time ( ) [EOL] self . screen . refresh_buffer ( ) [EOL] self . screen . draw ( ) [EOL] elif time . time ( ) > last_refresh_time + self . refresh_rate : [EOL] if self . notifier : [EOL] self . notifier . send_notifications ( ) [EOL] [EOL] [comment] [EOL] stamp = os . stat ( filename ) . st_mtime [EOL] if stamp != cached_stamp : [EOL] cached_stamp = stamp [EOL] self . schedule . clear_cache ( ) [EOL] self . screen . refresh_buffer ( ) [EOL] self . screen . draw ( ) [EOL] [EOL] last_refresh_time = time . time ( ) [EOL] [EOL] napms ( [number] ) [EOL] [EOL] if self . refresh_rate < [number] : [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $taskschedule.schedule.Schedule$ 0 0 0 0 0 $taskschedule.taskwarrior.PatchedTaskWarrior$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Optional [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import json [EOL] import os [EOL] import tempfile [EOL] import time [EOL] from datetime import datetime as dt [EOL] from typing import Dict , Optional [EOL] [EOL] from isodate import parse_duration [EOL] from tasklib . task import Task , TaskQuerySet [EOL] [EOL] [EOL] class ScheduledTaskQuerySet ( TaskQuerySet ) : [EOL] ... [EOL] [EOL] [EOL] class ScheduledTask ( Task ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ScheduledTask , self ) . __init__ ( * args , ** kwargs ) [EOL] [comment] [EOL] self . glyph = [string] [EOL] [EOL] @ property def has_scheduled_time ( self ) : [EOL] [docstring] [EOL] start = self . scheduled_start_datetime [EOL] if start : [EOL] if ( start . hour == [number] [EOL] and start . minute == [number] [EOL] and start . second == [number] [EOL] and start . microsecond == [number] ) : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] @ property def scheduled_start_datetime ( self ) : [EOL] [docstring] [EOL] try : [EOL] return self [ [string] ] [EOL] except TypeError : [EOL] return None [EOL] [EOL] @ property def scheduled_end_datetime ( self ) : [EOL] [docstring] [EOL] try : [EOL] estimate = self [ [string] ] [EOL] duration = parse_duration ( estimate ) [EOL] return self [ [string] ] + duration [EOL] except TypeError : [EOL] return None [EOL] [EOL] @ property def notified ( self ) : [EOL] filename = tempfile . gettempdir ( ) + [string] [EOL] uuid = self [ [string] ] [EOL] [EOL] [comment] [EOL] [EOL] min_delay = [number] [comment] [EOL] if os . path . exists ( filename ) : [EOL] mode = [string] [EOL] else : [EOL] mode = [string] [EOL] [EOL] with open ( filename , mode ) as f : [EOL] raw_data = f . read ( ) [EOL] [EOL] if not raw_data : [EOL] raw_data = [string] [EOL] [EOL] data = json . loads ( raw_data ) [EOL] [EOL] [comment] [EOL] if uuid not in data : [EOL] data [ uuid ] = time . time ( ) [EOL] f . seek ( [number] ) [EOL] f . truncate ( [number] ) [EOL] f . write ( json . dumps ( data ) ) [EOL] return False [EOL] else : [EOL] if time . time ( ) > float ( data [ uuid ] ) + min_delay : [EOL] data [ uuid ] = time . time ( ) [EOL] f . seek ( [number] ) [EOL] f . truncate ( [number] ) [EOL] f . write ( json . dumps ( data ) ) [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] @ property def should_be_active ( self ) : [EOL] [docstring] [EOL] [EOL] if self . scheduled_start_datetime is None : [EOL] return False [EOL] [EOL] start_ts = dt . timestamp ( self . scheduled_start_datetime ) [EOL] [EOL] now = dt . now ( ) [EOL] now_ts = dt . timestamp ( now ) [EOL] [EOL] if self [ [string] ] is None : [EOL] [comment] [EOL] [comment] [EOL] next_task = None [EOL] if next_task is not None : [EOL] next_task_start_ts = dt . timestamp ( next_task . start ) [EOL] if now_ts > start_ts and next_task_start_ts > now_ts : [EOL] return True [EOL] else : [EOL] end_ts = dt . timestamp ( self [ [string] ] ) [EOL] if now_ts > start_ts and end_ts > now_ts : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] @ property def overdue ( self ) : [EOL] [docstring] [EOL] if not self . scheduled_start_datetime : [EOL] return False [EOL] [EOL] now = dt . now ( ) [EOL] now_ts = dt . timestamp ( now ) [EOL] [EOL] if self [ [string] ] is None : [EOL] start_ts = dt . timestamp ( self . scheduled_start_datetime ) [EOL] if now_ts > start_ts : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] end_ts = dt . timestamp ( self [ [string] ] ) [EOL] if now_ts > end_ts : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def as_dict ( self ) : [EOL] data = self . export_data ( ) [EOL] return json . loads ( data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $builtins.float$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $builtins.float$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
	0
import taskschedule [EOL] import datetime [EOL] import builtins [EOL] from datetime import datetime [EOL] [EOL] from taskschedule . scheduled_task import ScheduledTask [EOL] from taskschedule . taskwarrior import PatchedTaskWarrior [EOL] [EOL] [EOL] def calculate_datetime ( date_str ) : [EOL] [docstring] [EOL] [EOL] tw = PatchedTaskWarrior ( ) [EOL] task = ScheduledTask ( tw , description = [string] ) [EOL] task [ [string] ] = date_str [EOL] return task [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import subprocess [EOL] import typing [EOL] import json [EOL] import os [EOL] import subprocess [EOL] [EOL] [EOL] def run_hooks ( hook_type , data = { [string] : - [number] , [string] : [string] } ) : [EOL] [docstring] [EOL] [EOL] home = os . path . expanduser ( [string] ) [EOL] [EOL] hooks_directory = home + [string] [EOL] onlyfiles = [ f for f in os . listdir ( hooks_directory ) if os . path . isfile ( os . path . join ( hooks_directory , f ) ) ] [EOL] [EOL] for filename in onlyfiles : [EOL] if hook_type == [string] and filename . startswith ( [string] ) : [EOL] input_data = json . dumps ( data , ensure_ascii = False ) . encode ( [string] ) [EOL] result = subprocess . run ( [ home + [string] + filename ] , shell = True , stdout = subprocess . PIPE , stderr = subprocess . PIPE , input = input_data , ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Optional , List , Any , Type , Dict [EOL] import taskschedule [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import curses [EOL] import time [EOL] from datetime import datetime [EOL] from typing import List , Tuple [EOL] [EOL] from taskschedule . config_parser import ConfigParser [EOL] from taskschedule . hooks import run_hooks [EOL] from taskschedule . schedule import Schedule [EOL] from taskschedule . scheduled_task import ScheduledTask [EOL] from taskschedule . utils import calculate_datetime [EOL] [EOL] BufferType = List [ Tuple [ int , int , str , int ] ] [EOL] [EOL] [EOL] class Screen : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , schedule , scheduled_after , scheduled_before , hide_projects = False , hide_empty = False , ) : [EOL] self . config = ConfigParser ( ) . config ( ) [EOL] self . scheduled_before = scheduled_before [EOL] self . scheduled_after = scheduled_after [EOL] [EOL] self . stdscr = curses . initscr ( ) [EOL] self . stdscr . nodelay ( True ) [EOL] self . stdscr . scrollok ( True ) [EOL] self . stdscr . idlok ( True ) [EOL] curses . noecho ( ) [EOL] [EOL] self . pad = curses . newpad ( [number] , [number] ) [EOL] self . scroll_level = [number] [EOL] [EOL] self . hide_projects = hide_projects [EOL] self . hide_empty = hide_empty [EOL] self . buffer = [ ] [EOL] self . prev_buffer = [ ] [EOL] self . init_colors ( ) [EOL] [EOL] self . current_task = None [EOL] [EOL] self . schedule = schedule [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] curses . endwin ( ) [EOL] [EOL] def init_colors ( self ) : [EOL] [docstring] [EOL] curses . curs_set ( [number] ) [EOL] curses . start_color ( ) [EOL] if curses . can_change_color ( ) : [EOL] curses . init_pair ( [number] , [number] , curses . COLOR_BLACK ) [EOL] curses . init_pair ( [number] , [number] , [number] ) [EOL] curses . init_pair ( [number] , [number] , [number] ) [EOL] curses . init_pair ( [number] , curses . COLOR_WHITE , curses . COLOR_BLACK ) [EOL] curses . init_pair ( [number] , curses . COLOR_GREEN , curses . COLOR_BLACK ) [EOL] curses . init_pair ( [number] , [number] , [number] ) [EOL] curses . init_pair ( [number] , [number] , [number] ) [EOL] curses . init_pair ( [number] , curses . COLOR_BLACK , curses . COLOR_GREEN ) [EOL] curses . init_pair ( [number] , curses . COLOR_BLACK , curses . COLOR_BLACK ) [EOL] curses . init_pair ( [number] , curses . COLOR_GREEN , curses . COLOR_BLACK ) [EOL] curses . init_pair ( [number] , curses . COLOR_YELLOW , curses . COLOR_BLACK ) [EOL] curses . init_pair ( [number] , curses . COLOR_YELLOW , [number] ) [EOL] curses . init_pair ( [number] , curses . COLOR_GREEN , [number] ) [EOL] curses . init_pair ( [number] , [number] , [number] ) [EOL] curses . init_pair ( [number] , curses . COLOR_GREEN , curses . COLOR_BLACK ) [EOL] curses . init_pair ( [number] , [number] , curses . COLOR_BLACK ) [EOL] curses . init_pair ( [number] , curses . COLOR_BLUE , curses . COLOR_BLACK ) [EOL] [EOL] [comment] [EOL] self . COLOR_DEFAULT = curses . color_pair ( [number] ) [EOL] self . COLOR_DEFAULT_ALTERNATE = curses . color_pair ( [number] ) [EOL] self . COLOR_HEADER = curses . color_pair ( [number] ) | curses . A_UNDERLINE [EOL] self . COLOR_HOUR = curses . color_pair ( [number] ) [EOL] self . COLOR_HOUR_CURRENT = curses . color_pair ( [number] ) [EOL] self . COLOR_ACTIVE = curses . color_pair ( [number] ) [EOL] self . COLOR_SHOULD_BE_ACTIVE = curses . color_pair ( [number] ) [EOL] self . COLOR_SHOULD_BE_ACTIVE_ALTERNATE = curses . color_pair ( [number] ) [EOL] self . COLOR_OVERDUE = curses . color_pair ( [number] ) [EOL] self . COLOR_OVERDUE_ALTERNATE = curses . color_pair ( [number] ) [EOL] self . COLOR_COMPLETED = curses . color_pair ( [number] ) [EOL] self . COLOR_COMPLETED_ALTERNATE = curses . color_pair ( [number] ) [EOL] self . COLOR_GLYPH = curses . color_pair ( [number] ) [EOL] self . COLOR_DIVIDER = curses . color_pair ( [number] ) [EOL] self . COLOR_DIVIDER_ACTIVE = curses . color_pair ( [number] ) [EOL] self . COLOR_DIVIDER_TEXT = curses . color_pair ( [number] ) [EOL] self . COLOR_BLUE = curses . color_pair ( [number] ) [EOL] else : [EOL] [comment] [EOL] self . COLOR_DEFAULT = curses . color_pair ( [number] ) [EOL] self . COLOR_DEFAULT_ALTERNATE = curses . color_pair ( [number] ) [EOL] self . COLOR_HEADER = curses . color_pair ( [number] ) [EOL] self . COLOR_HOUR = curses . color_pair ( [number] ) [EOL] self . COLOR_HOUR_CURRENT = curses . color_pair ( [number] ) [EOL] self . COLOR_ACTIVE = curses . color_pair ( [number] ) [EOL] self . COLOR_SHOULD_BE_ACTIVE = curses . color_pair ( [number] ) [EOL] self . COLOR_SHOULD_BE_ACTIVE_ALTERNATE = curses . color_pair ( [number] ) [EOL] self . COLOR_OVERDUE = curses . color_pair ( [number] ) [EOL] self . COLOR_OVERDUE_ALTERNATE = curses . color_pair ( [number] ) [EOL] self . COLOR_COMPLETED = curses . color_pair ( [number] ) [EOL] self . COLOR_COMPLETED_ALTERNATE = curses . color_pair ( [number] ) [EOL] self . COLOR_GLYPH = curses . color_pair ( [number] ) [EOL] self . COLOR_DIVIDER = curses . color_pair ( [number] ) [EOL] self . COLOR_DIVIDER_ACTIVE = curses . color_pair ( [number] ) [EOL] self . COLOR_DIVIDER_TEXT = curses . color_pair ( [number] ) [EOL] self . COLOR_BLUE = curses . color_pair ( [number] ) [EOL] [EOL] def get_task_color ( self , task , alternate ) : [EOL] [docstring] [EOL] color = None [EOL] [EOL] if task . completed : [EOL] if alternate : [EOL] color = self . COLOR_COMPLETED_ALTERNATE [EOL] else : [EOL] color = self . COLOR_COMPLETED [EOL] elif task . active : [EOL] color = self . COLOR_ACTIVE [EOL] elif task . should_be_active : [EOL] if alternate : [EOL] color = self . COLOR_SHOULD_BE_ACTIVE_ALTERNATE [EOL] else : [EOL] color = self . COLOR_SHOULD_BE_ACTIVE [EOL] elif task . overdue and not task . completed : [EOL] if alternate : [EOL] color = self . COLOR_OVERDUE_ALTERNATE [EOL] else : [EOL] color = self . COLOR_OVERDUE [EOL] else : [EOL] if alternate : [EOL] color = self . COLOR_DEFAULT_ALTERNATE [EOL] else : [EOL] color = self . COLOR_DEFAULT [EOL] [EOL] return color [EOL] [EOL] def get_maxyx ( self ) : [EOL] [docstring] [EOL] max_y , max_x = self . stdscr . getmaxyx ( ) [EOL] return max_y , max_x [EOL] [EOL] def scroll ( self , lines ) : [EOL] [docstring] [EOL] max_y , max_x = self . get_maxyx ( ) [EOL] self . scroll_level += lines [EOL] if self . scroll_level < [number] : [EOL] self . scroll_level = [number] [EOL] [EOL] self . stdscr . refresh ( ) [EOL] self . pad . refresh ( self . scroll_level + [number] , [number] , [number] , [number] , max_y - [number] , max_x - [number] ) [EOL] [EOL] def prerender_footnote ( self ) : [EOL] [docstring] [EOL] count = len ( self . schedule . tasks ) [EOL] date_format = [string] [EOL] before = self . scheduled_before . strftime ( date_format ) [EOL] after = self . scheduled_after . strftime ( date_format ) [EOL] footnote = f"{ count } [string] { after } [string] { before }" [EOL] [EOL] return footnote [EOL] [EOL] def draw_footnote ( self ) : [EOL] [docstring] [EOL] max_y , max_x = self . get_maxyx ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] footnote = self . prerender_footnote ( ) [EOL] self . stdscr . addstr ( max_y - [number] , [number] , footnote , self . COLOR_DEFAULT ) [EOL] [EOL] def draw ( self , force = False ) : [EOL] [docstring] [EOL] max_y , max_x = self . get_maxyx ( ) [EOL] if not self . buffer : [EOL] self . stdscr . clear ( ) [EOL] self . stdscr . addstr ( [number] , [number] , [string] , self . COLOR_DEFAULT ) [EOL] self . draw_footnote ( ) [EOL] self . stdscr . refresh ( ) [EOL] else : [EOL] if force or self . prev_buffer != self . buffer : [EOL] self . pad . clear ( ) [EOL] if self . prev_buffer > self . buffer : [EOL] self . stdscr . clear ( ) [EOL] self . stdscr . refresh ( ) [EOL] [EOL] for line , offset , string , color in self . buffer : [EOL] if line == [number] : [EOL] self . stdscr . addstr ( line , offset , string , color ) [EOL] else : [EOL] self . pad . addstr ( line , offset , string , color ) [EOL] [EOL] self . draw_footnote ( ) [EOL] self . pad . refresh ( self . scroll_level + [number] , [number] , [number] , [number] , max_y - [number] , max_x - [number] ) [EOL] [EOL] def render_timeboxes ( self , task , color ) : [EOL] [docstring] [EOL] [EOL] timeboxes = [ ] [EOL] real = [number] [EOL] if task [ [string] ] : [EOL] real = task [ [string] ] [EOL] for i in range ( task [ [string] ] ) : [EOL] if i >= task [ [string] ] : [EOL] timeboxes . append ( { [string] : self . config [ [string] ] [ [string] ] , [string] : color , } ) [EOL] else : [EOL] timeboxes . append ( { [string] : self . config [ [string] ] [ [string] ] , [string] : color } ) [EOL] if task [ [string] ] : [EOL] for i in range ( task [ [string] ] - real ) : [EOL] timeboxes . append ( { [string] : self . config [ [string] ] [ [string] ] , [string] : color } ) [EOL] [EOL] return timeboxes [EOL] [EOL] def prerender_headers ( self ) : [EOL] [docstring] [EOL] [EOL] header_buffer = [ ] [EOL] [EOL] [comment] [EOL] max_y , max_x = self . get_maxyx ( ) [EOL] offsets = self . schedule . get_column_offsets ( ) [EOL] max_project_column_length = round ( max_x / [number] ) [EOL] if offsets [ [number] ] - offsets [ [number] ] > max_project_column_length : [EOL] offsets [ [number] ] = offsets [ [number] ] + max_project_column_length [EOL] [EOL] [comment] [EOL] headers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] column_lengths = [ [number] , [number] ] [EOL] column_lengths . append ( self . schedule . get_max_length ( [string] ) ) [EOL] column_lengths . append ( [number] ) [EOL] column_lengths . append ( [number] ) [EOL] column_lengths . append ( max_project_column_length - [number] ) [EOL] column_lengths . append ( self . schedule . get_max_length ( [string] ) ) [EOL] [EOL] for i , header in enumerate ( headers ) : [EOL] try : [EOL] extra_length = column_lengths [ i ] - len ( header ) [EOL] headers [ i ] += [string] * extra_length [EOL] except IndexError : [EOL] pass [EOL] [EOL] header_buffer . append ( ( [number] , offsets [ [number] ] , headers [ [number] ] , self . COLOR_HEADER ) ) [EOL] header_buffer . append ( ( [number] , offsets [ [number] ] , headers [ [number] ] , self . COLOR_HEADER ) ) [EOL] header_buffer . append ( ( [number] , offsets [ [number] ] , headers [ [number] ] , self . COLOR_HEADER ) ) [EOL] header_buffer . append ( ( [number] , offsets [ [number] ] , headers [ [number] ] , self . COLOR_HEADER ) ) [EOL] [EOL] if not self . hide_projects : [EOL] header_buffer . append ( ( [number] , offsets [ [number] ] , headers [ [number] ] , self . COLOR_HEADER ) ) [EOL] [EOL] return header_buffer [EOL] [EOL] def prerender_divider ( self , day , current_line ) : [EOL] max_y , max_x = self . get_maxyx ( ) [EOL] offsets = self . schedule . get_column_offsets ( ) [EOL] divider_pt1 = [string] * ( offsets [ [number] ] - [number] ) [EOL] [EOL] divider_buffer = [ ] [EOL] divider_buffer . append ( ( current_line , [number] , divider_pt1 , self . COLOR_DIVIDER ) ) [EOL] [EOL] date_format = [string] [EOL] formatted_date = calculate_datetime ( day ) . strftime ( date_format ) [EOL] divider_pt2 = [string] + formatted_date + [string] [EOL] if day == datetime . now ( ) . date ( ) . isoformat ( ) : [EOL] divider_buffer . append ( ( current_line , len ( divider_pt1 ) , divider_pt2 , self . COLOR_DIVIDER_ACTIVE ) ) [EOL] else : [EOL] divider_buffer . append ( ( current_line , len ( divider_pt1 ) , divider_pt2 , self . COLOR_DIVIDER_TEXT ) ) [EOL] [EOL] divider_pt3 = [string] * ( max_x - ( len ( divider_pt1 ) + len ( divider_pt2 ) ) ) [EOL] divider_buffer . append ( ( current_line , len ( divider_pt1 ) + len ( divider_pt2 ) , divider_pt3 , self . COLOR_DIVIDER , ) ) [EOL] [EOL] return divider_buffer [EOL] [EOL] def run_hook ( self ) : [EOL] [comment] [EOL] current_task = None [EOL] for task_ in self . schedule . tasks : [EOL] if task_ . should_be_active : [EOL] current_task = task_ [EOL] [EOL] if current_task is not None : [EOL] if self . current_task is None : [EOL] self . current_task = current_task [EOL] if current_task [ [string] ] != [number] : [EOL] run_hooks ( [string] , data = current_task . as_dict ( ) ) [EOL] else : [EOL] if self . current_task [ [string] ] != current_task [ [string] ] : [EOL] self . current_task = current_task [EOL] if current_task [ [string] ] != [number] : [EOL] run_hooks ( [string] , data = current_task . as_dict ( ) ) [EOL] [EOL] def prerender_empty_line ( self , alternate , current_line , hour , day ) : [EOL] max_y , max_x = self . get_maxyx ( ) [EOL] [EOL] _buffer = [ ] [EOL] [EOL] if alternate : [EOL] color = self . COLOR_DEFAULT_ALTERNATE [EOL] else : [EOL] color = self . COLOR_DEFAULT [EOL] [EOL] [comment] [EOL] _buffer . append ( ( current_line , [number] , [string] * ( max_x - [number] ) , color ) ) [EOL] [EOL] [comment] [EOL] current_hour = time . localtime ( ) . tm_hour [EOL] if int ( hour ) == current_hour and day == datetime . now ( ) . date ( ) . isoformat ( ) : [EOL] _buffer . append ( ( current_line , [number] , str ( hour ) , self . COLOR_HOUR_CURRENT ) ) [EOL] else : [EOL] _buffer . append ( ( current_line , [number] , str ( hour ) , self . COLOR_HOUR ) ) [EOL] [EOL] return _buffer [EOL] [EOL] def prerender_task ( self , task_num , task , alternate , hour , current_line , day , ) : [EOL] [docstring] [EOL] max_y , max_x = self . get_maxyx ( ) [EOL] offsets = self . schedule . get_column_offsets ( ) [EOL] [EOL] _buffer = [ ] [EOL] [EOL] color = self . get_task_color ( task , alternate ) [EOL] [EOL] [comment] [EOL] if task_num == [number] : [EOL] hour_ = str ( hour ) [EOL] else : [EOL] hour_ = [string] [EOL] [EOL] [comment] [EOL] current_hour = time . localtime ( ) . tm_hour [EOL] if hour_ != [string] : [EOL] if int ( hour ) == current_hour and day == datetime . now ( ) . date ( ) . isoformat ( ) : [EOL] _buffer . append ( ( current_line , [number] , hour_ , self . COLOR_HOUR_CURRENT ) ) [EOL] else : [EOL] _buffer . append ( ( current_line , [number] , hour_ , self . COLOR_HOUR ) ) [EOL] [EOL] [comment] [EOL] _buffer . append ( ( current_line , [number] , [string] * ( max_x - [number] ) , color ) ) [EOL] [EOL] [comment] [EOL] _buffer . append ( ( current_line , [number] , task . glyph , self . COLOR_GLYPH ) ) [EOL] [EOL] [comment] [EOL] if task [ [string] ] != [number] : [EOL] _buffer . append ( ( current_line , [number] , str ( task [ [string] ] ) , color ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] start_dt = task . scheduled_start_datetime [EOL] if start_dt : [EOL] if not task . has_scheduled_time : [EOL] if task . scheduled_end_datetime : [EOL] end_time = [string] . format ( task . scheduled_end_datetime . strftime ( [string] ) ) [EOL] formatted_time = [string] . format ( end_time ) [EOL] else : [EOL] formatted_time = [string] [EOL] else : [EOL] start_time = [string] . format ( start_dt . strftime ( [string] ) ) [EOL] if task . scheduled_end_datetime is None : [EOL] formatted_time = start_time [EOL] else : [EOL] end_time = [string] . format ( task . scheduled_end_datetime . strftime ( [string] ) ) [EOL] formatted_time = [string] . format ( start_time , end_time ) [EOL] else : [EOL] formatted_time = [string] [EOL] [EOL] _buffer . append ( ( current_line , offsets [ [number] ] , formatted_time , color ) ) [EOL] [EOL] [comment] [EOL] timeboxes = self . render_timeboxes ( task , color ) [EOL] for i , timebox in enumerate ( timeboxes ) : [EOL] _buffer . append ( ( current_line , offsets [ [number] ] + i , timebox . get ( [string] ) , timebox . get ( [string] ) , ) ) [EOL] [EOL] [comment] [EOL] offset = [number] [EOL] if not self . hide_projects : [EOL] if task [ [string] ] is None : [EOL] project = [string] [EOL] else : [EOL] max_length = offsets [ [number] ] - offsets [ [number] ] - [number] [EOL] project = task [ [string] ] [ [number] : max_length ] [EOL] [EOL] _buffer . append ( ( current_line , offsets [ [number] ] , project , color ) ) [EOL] offset = offsets [ [number] ] [EOL] else : [EOL] offset = offsets [ [number] ] [EOL] [EOL] [comment] [EOL] description = task [ [string] ] [ [number] : max_x - offset ] [EOL] _buffer . append ( ( current_line , offset , description , color ) ) [EOL] [EOL] return _buffer [EOL] [EOL] def refresh_buffer ( self ) : [EOL] [docstring] [EOL] max_y , max_x = self . get_maxyx ( ) [EOL] self . prev_buffer = self . buffer [EOL] self . buffer = [ ] [EOL] [EOL] tasks = self . schedule . tasks [EOL] [EOL] if not self . schedule . tasks : [EOL] return [EOL] [EOL] [comment] [EOL] self . run_hook ( ) [EOL] [EOL] [comment] [EOL] header_buffer = self . prerender_headers ( ) [EOL] for header in header_buffer : [EOL] self . buffer . append ( header ) [EOL] [EOL] [comment] [EOL] alternate = True [EOL] current_line = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] time_slots = self . schedule . get_time_slots ( ) [EOL] for day in time_slots : [EOL] [EOL] [comment] [EOL] day_has_tasks = False [EOL] for hour in time_slots [ day ] : [EOL] tasks = time_slots [ day ] [ hour ] [EOL] if tasks : [EOL] day_has_tasks = True [EOL] [EOL] if day_has_tasks or not self . hide_empty : [EOL] divider_buffer = self . prerender_divider ( day , current_line ) [EOL] for divider_part in divider_buffer : [EOL] self . buffer . append ( divider_part ) [EOL] [EOL] current_line += [number] [EOL] alternate = False [EOL] [EOL] for hour in time_slots [ day ] : [EOL] tasks = time_slots [ day ] [ hour ] [EOL] if not tasks and not self . hide_empty : [EOL] empty_line_buffer = self . prerender_empty_line ( alternate , current_line , hour , day ) [EOL] for part in empty_line_buffer : [EOL] self . buffer . append ( part ) [EOL] [EOL] current_line += [number] [EOL] alternate = not alternate [EOL] [EOL] task = ... [EOL] for task_num , task in enumerate ( tasks ) : [EOL] task_buffer = self . prerender_task ( task_num , task , alternate , hour , current_line , day ) [EOL] for part in task_buffer : [EOL] self . buffer . append ( part ) [EOL] [EOL] current_line += [number] [EOL] alternate = not alternate [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0
from typing import Optional , Any [EOL] import taskschedule [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import subprocess [EOL] [EOL] from taskschedule . scheduled_task import ScheduledTask [EOL] [EOL] [EOL] class SoundDoesNotExistError ( Exception ) : [EOL] ... [EOL] [EOL] [EOL] class Notifier : [EOL] def __init__ ( self , backend ) : [EOL] self . backend = backend [EOL] [EOL] def notify ( self , task ) : [EOL] [docstring] [EOL] [EOL] home = os . path . expanduser ( [string] ) [EOL] [EOL] scheduled_time = task . scheduled_start_datetime [EOL] if not scheduled_time : [EOL] return [EOL] [EOL] scheduled_time_formatted = scheduled_time . strftime ( [string] ) [EOL] [EOL] task_id = task [ [string] ] [EOL] summary = f"{ scheduled_time_formatted } [string] { task_id }" [EOL] body = [string] . format ( task [ [string] ] ) [EOL] urgency = [string] [EOL] uuid = task [ [string] ] [EOL] [EOL] if [string] in str ( os . getenv ( [string] ) ) : [EOL] urgency = [string] [EOL] subprocess . run ( [ [string] , [string] , summary , [string] , body , [string] , [string] , [string] , f" [string] { uuid } [string] " , [string] , [string] , [string] , f" [string] { uuid } [string] " , [string] , [string] , [string] , [string] , [string] , f" [string] { uuid }" , [string] , [string] , [string] , urgency , [string] , [string] , [string] , [string] , ] ) [EOL] else : [EOL] subprocess . run ( [ [string] , [string] , urgency , summary , body ] ) [EOL] [EOL] sound_file = home + [string] [EOL] if os . path . isfile ( sound_file ) is True : [EOL] subprocess . Popen ( [ [string] , sound_file ] , stdout = subprocess . DEVNULL , stderr = subprocess . STDOUT , ) [EOL] else : [EOL] raise SoundDoesNotExistError ( f" [string] { sound_file }" ) [EOL] [EOL] def send_notifications ( self ) : [EOL] [docstring] [EOL] [EOL] tasks = self . backend . tasks . filter ( [string] ) [EOL] [EOL] for task in tasks : [EOL] if not task . notified : [EOL] self . notify ( task ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import taskschedule [EOL] import typing [EOL] import json [EOL] [EOL] from tasklib import TaskWarrior [EOL] from tasklib . backends import TaskWarriorException [EOL] [EOL] from taskschedule . scheduled_task import ScheduledTask , ScheduledTaskQuerySet [EOL] [EOL] [EOL] class PatchedTaskWarrior ( TaskWarrior ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( PatchedTaskWarrior , self ) . __init__ ( * args , ** kwargs ) [EOL] self . tasks = ScheduledTaskQuerySet ( self ) [EOL] [EOL] def filter_tasks ( self , filter_obj ) : [EOL] self . enforce_recurrence ( ) [EOL] args = [ [string] ] + filter_obj . get_filter_params ( ) [EOL] tasks = [ ] [EOL] for line in self . execute_command ( args ) : [EOL] if line : [EOL] data = line . strip ( [string] ) [EOL] try : [EOL] filtered_task = ScheduledTask ( self ) [EOL] filtered_task . _load_data ( json . loads ( data ) ) [EOL] tasks . append ( filtered_task ) [EOL] except ValueError : [EOL] raise TaskWarriorException ( [string] % data ) [EOL] return tasks [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTaskQuerySet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $taskschedule.scheduled_task.ScheduledTask$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0