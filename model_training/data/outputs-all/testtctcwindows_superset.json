[comment] [EOL] [EOL] from superset import app [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , DefaultDict , Any [EOL] import typing [EOL] from collections import defaultdict [EOL] [EOL] from superset import sm [EOL] [EOL] [EOL] def cleanup_permissions ( ) : [EOL] [comment] [EOL] pvms = sm . get_session . query ( sm . permissionview_model ) . all ( ) [EOL] print ( [string] . format ( len ( pvms ) ) ) [EOL] pvms_dict = defaultdict ( list ) [EOL] for pvm in pvms : [EOL] pvms_dict [ ( pvm . permission , pvm . view_menu ) ] . append ( pvm ) [EOL] duplicates = [ v for v in pvms_dict . values ( ) if len ( v ) > [number] ] [EOL] len ( duplicates ) [EOL] [EOL] for pvm_list in duplicates : [EOL] first_prm = pvm_list [ [number] ] [EOL] roles = set ( first_prm . role ) [EOL] for pvm in pvm_list [ [number] : ] : [EOL] roles = roles . union ( pvm . role ) [EOL] sm . get_session . delete ( pvm ) [EOL] first_prm . roles = list ( roles ) [EOL] sm . get_session . commit ( ) [EOL] [EOL] pvms = sm . get_session . query ( sm . permissionview_model ) . all ( ) [EOL] print ( [string] . format ( len ( pvms ) ) ) [EOL] [EOL] [comment] [EOL] pvms = sm . get_session . query ( sm . permissionview_model ) . all ( ) [EOL] for pvm in pvms : [EOL] if not ( pvm . view_menu and pvm . permission ) : [EOL] sm . get_session . delete ( pvm ) [EOL] sm . get_session . commit ( ) [EOL] [EOL] pvms = sm . get_session . query ( sm . permissionview_model ) . all ( ) [EOL] print ( [string] . format ( len ( pvms ) ) ) [EOL] [EOL] [comment] [EOL] roles = sm . get_session . query ( sm . role_model ) . all ( ) [EOL] for role in roles : [EOL] role . permissions = [ p for p in role . permissions if p ] [EOL] sm . get_session . commit ( ) [EOL] [EOL] [comment] [EOL] pvms = sm . get_session . query ( sm . permissionview_model ) . all ( ) [EOL] for pvm in pvms : [EOL] pvm . role = [ r for r in pvm . role if r ] [EOL] sm . get_session . commit ( ) [EOL] [EOL] [EOL] cleanup_permissions ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import datetime [EOL] import typing [EOL] from contextlib import closing [EOL] from datetime import datetime [EOL] import logging [EOL] from time import sleep [EOL] import uuid [EOL] [EOL] from celery . exceptions import SoftTimeLimitExceeded [EOL] from contextlib2 import contextmanager [EOL] from flask_babel import lazy_gettext as _ [EOL] import simplejson as json [EOL] import sqlalchemy [EOL] from sqlalchemy . orm import sessionmaker [EOL] from sqlalchemy . pool import NullPool [EOL] [EOL] from superset import app , dataframe , db , results_backend , security_manager [EOL] from superset . models . sql_lab import Query [EOL] from superset . sql_parse import ParsedQuery [EOL] from superset . tasks . celery_app import app as celery_app [EOL] from superset . utils . core import ( json_iso_dttm_ser , QueryStatus , sources , zlib_compress , ) [EOL] from superset . utils . dates import now_as_float [EOL] from superset . utils . decorators import stats_timing [EOL] [EOL] config = app . config [EOL] stats_logger = config . get ( [string] ) [EOL] SQLLAB_TIMEOUT = config . get ( [string] , [number] ) [EOL] log_query = config . get ( [string] ) [EOL] [EOL] [EOL] class SqlLabException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SqlLabSecurityException ( SqlLabException ) : [EOL] pass [EOL] [EOL] [EOL] class SqlLabTimeoutException ( SqlLabException ) : [EOL] pass [EOL] [EOL] [EOL] def handle_query_error ( msg , query , session , payload = None ) : [EOL] [docstring] [EOL] payload = payload or { } [EOL] troubleshooting_link = config [ [string] ] [EOL] query . error_message = msg [EOL] query . status = QueryStatus . FAILED [EOL] query . tmp_table_name = None [EOL] session . commit ( ) [EOL] payload . update ( { [string] : query . status , [string] : msg , } ) [EOL] if troubleshooting_link : [EOL] payload [ [string] ] = troubleshooting_link [EOL] return payload [EOL] [EOL] [EOL] def get_query ( query_id , session , retry_count = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] query = None [EOL] attempt = [number] [EOL] while not query and attempt < retry_count : [EOL] try : [EOL] query = session . query ( Query ) . filter_by ( id = query_id ) . one ( ) [EOL] except Exception : [EOL] attempt += [number] [EOL] logging . error ( [string] . format ( query_id ) ) [EOL] stats_logger . incr ( [string] + str ( attempt ) ) [EOL] logging . error ( [string] ) [EOL] sleep ( [number] ) [EOL] if not query : [EOL] stats_logger . incr ( [string] ) [EOL] raise SqlLabException ( [string] ) [EOL] return query [EOL] [EOL] [EOL] [comment] [EOL] @ contextmanager def session_scope ( nullpool ) : [EOL] [docstring] [EOL] if nullpool : [EOL] engine = sqlalchemy . create_engine ( app . config . get ( [string] ) , poolclass = NullPool ) [EOL] session_class = sessionmaker ( ) [EOL] session_class . configure ( bind = engine ) [EOL] session = session_class ( ) [EOL] else : [EOL] session = db . session ( ) [EOL] session . commit ( ) [comment] [EOL] [EOL] try : [EOL] yield session [EOL] session . commit ( ) [EOL] except Exception as e : [EOL] session . rollback ( ) [EOL] logging . exception ( e ) [EOL] raise [EOL] finally : [EOL] session . close ( ) [EOL] [EOL] [EOL] @ celery_app . task ( name = [string] , bind = True , soft_time_limit = SQLLAB_TIMEOUT ) def get_sql_results ( ctask , query_id , rendered_query , return_results = True , store_results = False , user_name = None , start_time = None ) : [EOL] [docstring] [EOL] [comment] [EOL] with session_scope ( not ctask . request . called_directly ) as session : [EOL] [EOL] try : [EOL] return execute_sql_statements ( ctask , query_id , rendered_query , return_results , store_results , user_name , session = session , start_time = start_time ) [EOL] except Exception as e : [EOL] logging . exception ( e ) [EOL] stats_logger . incr ( [string] ) [EOL] query = get_query ( query_id , session ) [EOL] return handle_query_error ( str ( e ) , query , session ) [EOL] [EOL] [EOL] def execute_sql_statement ( sql_statement , query , user_name , session , cursor ) : [EOL] [docstring] [EOL] [comment] [EOL] database = query . database [EOL] db_engine_spec = database . db_engine_spec [EOL] parsed_query = ParsedQuery ( sql_statement ) [EOL] sql = parsed_query . stripped ( ) [EOL] SQL_MAX_ROWS = app . config . get ( [string] ) [EOL] [EOL] if not parsed_query . is_readonly ( ) and not database . allow_dml : [EOL] raise SqlLabSecurityException ( _ ( [string] ) ) [EOL] if query . select_as_cta : [EOL] if not parsed_query . is_select ( ) : [EOL] raise SqlLabException ( _ ( [string] [string] ) ) [EOL] if not query . tmp_table_name : [EOL] start_dttm = datetime . fromtimestamp ( query . start_time ) [EOL] query . tmp_table_name = [string] . format ( query . user_id , start_dttm . strftime ( [string] ) ) [EOL] sql = parsed_query . as_create_table ( query . tmp_table_name ) [EOL] query . select_as_cta_used = True [EOL] if parsed_query . is_select ( ) : [EOL] if SQL_MAX_ROWS and ( not query . limit or query . limit > SQL_MAX_ROWS ) : [EOL] query . limit = SQL_MAX_ROWS [EOL] if query . limit : [EOL] sql = database . apply_limit_to_sql ( sql , query . limit ) [EOL] [EOL] [comment] [EOL] SQL_QUERY_MUTATOR = config . get ( [string] ) [EOL] if SQL_QUERY_MUTATOR : [EOL] sql = SQL_QUERY_MUTATOR ( sql , user_name , security_manager , database ) [EOL] [EOL] try : [EOL] if log_query : [EOL] log_query ( query . database . sqlalchemy_uri , query . executed_sql , query . schema , user_name , __name__ , security_manager , ) [EOL] query . executed_sql = sql [EOL] with stats_timing ( [string] , stats_logger ) : [EOL] logging . info ( [string] . format ( sql ) ) [EOL] db_engine_spec . execute ( cursor , sql , async_ = True ) [EOL] logging . info ( [string] ) [EOL] db_engine_spec . handle_cursor ( cursor , query , session ) [EOL] [EOL] with stats_timing ( [string] , stats_logger ) : [EOL] logging . debug ( [string] . format ( query . to_dict ( ) ) ) [EOL] data = db_engine_spec . fetch_data ( cursor , query . limit ) [EOL] [EOL] except SoftTimeLimitExceeded as e : [EOL] logging . exception ( e ) [EOL] raise SqlLabTimeoutException ( [string] [string] . format ( SQLLAB_TIMEOUT ) ) [EOL] except Exception as e : [EOL] logging . exception ( e ) [EOL] raise SqlLabException ( db_engine_spec . extract_error_message ( e ) ) [EOL] [EOL] logging . debug ( [string] ) [EOL] cursor_description = cursor . description [EOL] return dataframe . SupersetDataFrame ( data , cursor_description , db_engine_spec ) [EOL] [EOL] [comment] [EOL] def execute_sql_statements ( ctask , query_id , rendered_query , return_results = True , store_results = False , user_name = None , session = None , start_time = None , ) : [EOL] [comment] [EOL] [docstring] [EOL] if store_results and start_time : [EOL] [comment] [EOL] stats_logger . timing ( [string] , now_as_float ( ) - start_time ) [EOL] [EOL] query = get_query ( query_id , session ) [EOL] payload = dict ( query_id = query_id ) [EOL] database = query . database [EOL] db_engine_spec = database . db_engine_spec [EOL] db_engine_spec . patch ( ) [EOL] [EOL] if store_results and not results_backend : [EOL] raise SqlLabException ( [string] ) [EOL] [EOL] [comment] [EOL] parsed_query = ParsedQuery ( rendered_query ) [EOL] statements = parsed_query . get_statements ( ) [EOL] logging . info ( f' [string] { len ( statements ) } [string] ' ) [EOL] [EOL] logging . info ( [string] ) [EOL] query . status = QueryStatus . RUNNING [EOL] query . start_running_time = now_as_float ( ) [EOL] [EOL] engine = database . get_sqla_engine ( schema = query . schema , nullpool = True , user_name = user_name , source = sources . get ( [string] , None ) , ) [EOL] [comment] [EOL] [comment] [EOL] with closing ( engine . raw_connection ( ) ) as conn : [EOL] [comment] [EOL] [comment] [EOL] if [string] in database . sqlalchemy_uri : [EOL] import pyignite [EOL] client = pyignite . Client ( ) [EOL] uri = database . url_object [EOL] host = uri . query [ [string] ] [EOL] port = int ( uri . query [ [string] ] ) [EOL] client . connect ( host , port ) [EOL] statement_count = len ( statements ) [EOL] for i , statement in enumerate ( statements ) : [EOL] [comment] [EOL] msg = f' [string] { i + [number] } [string] { statement_count }' [EOL] logging . info ( msg ) [EOL] query . set_extra_json_key ( [string] , msg ) [EOL] session . commit ( ) [EOL] try : [EOL] cdf = [ i for i in client . sql ( statement ) ] [EOL] msg = f' [string] { i + [number] } [string] { statement_count }' [EOL] except Exception as e : [EOL] msg = str ( e ) [EOL] if statement_count > [number] : [EOL] msg = f' [string] { i + [number] } [string] { statement_count } [string] ' + msg [EOL] payload = handle_query_error ( msg , query , session , payload ) [EOL] return payload [EOL] else : [EOL] with closing ( conn . cursor ( ) ) as cursor : [EOL] statement_count = len ( statements ) [EOL] for i , statement in enumerate ( statements ) : [EOL] [comment] [EOL] msg = f' [string] { i + [number] } [string] { statement_count }' [EOL] logging . info ( msg ) [EOL] query . set_extra_json_key ( [string] , msg ) [EOL] session . commit ( ) [EOL] try : [EOL] cdf = execute_sql_statement ( statement , query , user_name , session , cursor ) [EOL] msg = f' [string] { i + [number] } [string] { statement_count }' [EOL] except Exception as e : [EOL] msg = str ( e ) [EOL] if statement_count > [number] : [EOL] msg = f' [string] { i + [number] } [string] { statement_count } [string] ' + msg [EOL] payload = handle_query_error ( msg , query , session , payload ) [EOL] return payload [EOL] [EOL] [comment] [EOL] query . rows = cdf . size [EOL] query . progress = [number] [EOL] query . set_extra_json_key ( [string] , None ) [EOL] query . status = QueryStatus . SUCCESS [EOL] if query . select_as_cta : [EOL] query . select_sql = database . select_star ( query . tmp_table_name , limit = query . limit , schema = database . force_ctas_schema , show_cols = False , latest_partition = False ) [EOL] query . end_time = now_as_float ( ) [EOL] [EOL] payload . update ( { [string] : query . status , [string] : cdf . data if cdf . data else [ ] , [string] : cdf . columns if cdf . columns else [ ] , [string] : query . to_dict ( ) , } ) [EOL] [EOL] if store_results : [EOL] key = str ( uuid . uuid4 ( ) ) [EOL] logging . info ( f' [string] { key }' ) [EOL] with stats_timing ( [string] , stats_logger ) : [EOL] json_payload = json . dumps ( payload , default = json_iso_dttm_ser , ignore_nan = True ) [EOL] cache_timeout = database . cache_timeout [EOL] if cache_timeout is None : [EOL] cache_timeout = config . get ( [string] , [number] ) [EOL] [comment] [EOL] results_backend . set ( key , zlib_compress ( json_payload ) , cache_timeout ) [EOL] query . results_key = key [EOL] session . commit ( ) [EOL] [EOL] if return_results : [EOL] return payload [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [EOL] def update_time_range ( form_data ) : [EOL] [docstring] [EOL] [comment] [EOL] if [string] in form_data or [string] in form_data : [EOL] form_data [ [string] ] = [string] . format ( form_data . pop ( [string] , [string] ) or [string] , form_data . pop ( [string] , [string] ) or [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple , Literal , Pattern , Optional , List , Union , Any , Match , Type , Dict [EOL] import sqlalchemy [EOL] import superset [EOL] import builtins [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] from collections import namedtuple [EOL] import hashlib [EOL] import inspect [EOL] import logging [EOL] import os [EOL] import re [EOL] import textwrap [EOL] import time [EOL] from typing import List , Tuple [EOL] from urllib import parse [EOL] [EOL] from flask import g [EOL] from flask_babel import lazy_gettext as _ [EOL] import pandas [EOL] import sqlalchemy as sqla [EOL] from sqlalchemy import Column , select , types [EOL] from sqlalchemy . engine import create_engine [EOL] from sqlalchemy . engine . base import Engine [EOL] from sqlalchemy . engine . reflection import Inspector [EOL] from sqlalchemy . engine . result import RowProxy [EOL] from sqlalchemy . engine . url import make_url [EOL] from sqlalchemy . sql import quoted_name , text [EOL] from sqlalchemy . sql . expression import ColumnClause [EOL] from sqlalchemy . sql . expression import TextAsFrom [EOL] from sqlalchemy . types import String , UnicodeText [EOL] import sqlparse [EOL] from werkzeug . utils import secure_filename [EOL] [EOL] from superset import app , conf , db , sql_parse [EOL] from superset . exceptions import SupersetTemplateException [EOL] from superset . models . sql_types . presto_sql_types import type_map as presto_type_map [EOL] from superset . utils import core as utils [EOL] [EOL] QueryStatus = utils . QueryStatus [EOL] config = app . config [EOL] [EOL] tracking_url_trans = conf . get ( [string] ) [EOL] hive_poll_interval = conf . get ( [string] ) [EOL] [EOL] Grain = namedtuple ( [string] , [string] )[comment] [EOL] [EOL] [comment] [EOL] builtin_time_grains = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def _create_time_grains_tuple ( time_grains , time_grain_functions , blacklist ) : [EOL] ret_list = [ ] [EOL] blacklist = blacklist if blacklist else [ ] [EOL] for duration , func in time_grain_functions . items ( ) : [EOL] if duration not in blacklist : [EOL] name = time_grains . get ( duration ) [EOL] ret_list . append ( Grain ( name , _ ( name ) , func , duration ) ) [EOL] return tuple ( ret_list ) [EOL] [EOL] [EOL] class LimitMethod ( object ) : [EOL] [comment] [EOL] [docstring] [EOL] FETCH_MANY = [string] [EOL] WRAP_SQL = [string] [EOL] FORCE_LIMIT = [string] [EOL] [EOL] [EOL] class BaseEngineSpec ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] engine = [string] [comment] [EOL] time_grain_functions = { } [EOL] time_groupby_inline = False [EOL] limit_method = LimitMethod . FORCE_LIMIT [EOL] time_secondary_columns = False [EOL] inner_joins = True [EOL] allows_subquery = True [EOL] supports_column_aliases = True [EOL] force_column_alias_quotes = False [EOL] arraysize = [number] [EOL] max_column_name_length = [number] [EOL] [EOL] @ classmethod def get_time_expr ( cls , expr , pdf , time_grain , grain ) : [EOL] [comment] [EOL] if pdf == [string] : [EOL] expr = cls . epoch_to_dttm ( ) . format ( col = expr ) [EOL] elif pdf == [string] : [EOL] expr = cls . epoch_ms_to_dttm ( ) . format ( col = expr ) [EOL] [EOL] if grain : [EOL] expr = grain . function . format ( col = expr ) [EOL] return expr [EOL] [EOL] @ classmethod def get_time_grains ( cls ) : [EOL] blacklist = config . get ( [string] , [ ] ) [EOL] grains = builtin_time_grains . copy ( ) [EOL] grains . update ( config . get ( [string] , { } ) ) [EOL] grain_functions = cls . time_grain_functions . copy ( ) [EOL] grain_addon_functions = config . get ( [string] , { } ) [EOL] grain_functions . update ( grain_addon_functions . get ( cls . engine , { } ) ) [EOL] return _create_time_grains_tuple ( grains , grain_functions , blacklist ) [EOL] [EOL] @ classmethod def make_select_compatible ( cls , groupby_exprs , select_exprs ) : [EOL] [comment] [EOL] [comment] [EOL] return select_exprs [EOL] [EOL] @ classmethod def fetch_data ( cls , cursor , limit ) : [EOL] if cls . arraysize : [EOL] cursor . arraysize = cls . arraysize [EOL] if cls . limit_method == LimitMethod . FETCH_MANY : [EOL] return cursor . fetchmany ( limit ) [EOL] return cursor . fetchall ( ) [EOL] [EOL] @ classmethod def alter_new_orm_column ( cls , orm_col ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ classmethod def epoch_to_dttm ( cls ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ classmethod def epoch_ms_to_dttm ( cls ) : [EOL] return cls . epoch_to_dttm ( ) . replace ( [string] , [string] ) [EOL] [EOL] @ classmethod def get_datatype ( cls , type_code ) : [EOL] if isinstance ( type_code , str ) and len ( type_code ) : [EOL] return type_code . upper ( ) [EOL] [EOL] @ classmethod def extra_table_metadata ( cls , database , table_name , schema_name ) : [EOL] [docstring] [EOL] return { } [EOL] [EOL] @ classmethod def apply_limit_to_sql ( cls , sql , limit , database ) : [EOL] [docstring] [EOL] if cls . limit_method == LimitMethod . WRAP_SQL : [EOL] sql = sql . strip ( [string] ) [EOL] qry = ( select ( [string] ) . select_from ( TextAsFrom ( text ( sql ) , [ [string] ] ) . alias ( [string] ) , ) . limit ( limit ) ) [EOL] return database . compile_sqla_query ( qry ) [EOL] elif LimitMethod . FORCE_LIMIT : [EOL] parsed_query = sql_parse . ParsedQuery ( sql ) [EOL] sql = parsed_query . get_query_with_new_limit ( limit ) [EOL] return sql [EOL] [EOL] @ classmethod def get_limit_from_sql ( cls , sql ) : [EOL] parsed_query = sql_parse . ParsedQuery ( sql ) [EOL] return parsed_query . limit [EOL] [EOL] @ classmethod def get_query_with_new_limit ( cls , sql , limit ) : [EOL] parsed_query = sql_parse . ParsedQuery ( sql ) [EOL] return parsed_query . get_query_with_new_limit ( limit ) [EOL] [EOL] @ staticmethod def csv_to_df ( ** kwargs ) : [EOL] kwargs [ [string] ] = config [ [string] ] + kwargs [ [string] ] [EOL] kwargs [ [string] ] = [string] [EOL] kwargs [ [string] ] = True [EOL] chunks = pandas . read_csv ( ** kwargs ) [EOL] df = pandas . DataFrame ( ) [EOL] df = pandas . concat ( chunk for chunk in chunks ) [EOL] return df [EOL] [EOL] @ staticmethod def df_to_db ( df , table , ** kwargs ) : [EOL] df . to_sql ( ** kwargs ) [EOL] table . user_id = g . user . id [EOL] table . schema = kwargs [ [string] ] [EOL] table . fetch_metadata ( ) [EOL] db . session . add ( table ) [EOL] db . session . commit ( ) [EOL] [EOL] @ staticmethod def create_table_from_csv ( form , table ) : [EOL] def _allowed_file ( filename ) : [EOL] [comment] [EOL] extension = os . path . splitext ( filename ) [ [number] ] [EOL] return extension and extension [ [number] : ] in config [ [string] ] [EOL] [EOL] filename = secure_filename ( form . csv_file . data . filename ) [EOL] if not _allowed_file ( filename ) : [EOL] raise Exception ( [string] ) [EOL] kwargs = { [string] : filename , [string] : form . sep . data , [string] : form . header . data if form . header . data else [number] , [string] : form . index_col . data , [string] : form . mangle_dupe_cols . data , [string] : form . skipinitialspace . data , [string] : form . skiprows . data , [string] : form . nrows . data , [string] : form . skip_blank_lines . data , [string] : form . parse_dates . data , [string] : form . infer_datetime_format . data , [string] : [number] , } [EOL] df = BaseEngineSpec . csv_to_df ( ** kwargs ) [EOL] [EOL] df_to_db_kwargs = { [string] : table , [string] : df , [string] : form . name . data , [string] : create_engine ( form . con . data . sqlalchemy_uri_decrypted , echo = False ) , [string] : form . schema . data , [string] : form . if_exists . data , [string] : form . index . data , [string] : form . index_label . data , [string] : [number] , } [EOL] [EOL] BaseEngineSpec . df_to_db ( ** df_to_db_kwargs ) [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] @ classmethod def fetch_result_sets ( cls , db , datasource_type ) : [EOL] [docstring] [EOL] schemas = db . all_schema_names ( cache = db . schema_cache_enabled , cache_timeout = db . schema_cache_timeout , force = True ) [EOL] all_result_sets = [ ] [EOL] for schema in schemas : [EOL] if datasource_type == [string] : [EOL] all_datasource_names = db . all_table_names_in_schema ( schema = schema , force = True , cache = db . table_cache_enabled , cache_timeout = db . table_cache_timeout ) [EOL] elif datasource_type == [string] : [EOL] all_datasource_names = db . all_view_names_in_schema ( schema = schema , force = True , cache = db . table_cache_enabled , cache_timeout = db . table_cache_timeout ) [EOL] else : [EOL] raise Exception ( f' [string] { datasource_type }' ) [EOL] all_result_sets += [ [string] . format ( schema , t ) for t in all_datasource_names ] [EOL] return all_result_sets [EOL] [EOL] @ classmethod def handle_cursor ( cls , cursor , query , session ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ classmethod def extract_error_message ( cls , e ) : [EOL] [docstring] [EOL] return utils . error_msg_from_exception ( e ) [EOL] [EOL] @ classmethod def adjust_database_uri ( cls , uri , selected_schema ) : [EOL] [docstring] [EOL] return uri [EOL] [EOL] @ classmethod def patch ( cls ) : [EOL] pass [EOL] [EOL] @ classmethod def get_schema_names ( cls , inspector ) : [EOL] return sorted ( inspector . get_schema_names ( ) ) [EOL] [EOL] @ classmethod def get_table_names ( cls , inspector , schema ) : [EOL] return sorted ( inspector . get_table_names ( schema ) ) [EOL] [EOL] @ classmethod def get_view_names ( cls , inspector , schema ) : [EOL] return sorted ( inspector . get_view_names ( schema ) ) [EOL] [EOL] @ classmethod def get_columns ( cls , inspector , table_name , schema ) : [EOL] return inspector . get_columns ( table_name , schema ) [EOL] [EOL] @ classmethod def where_latest_partition ( cls , table_name , schema , database , qry , columns = None ) : [EOL] return False [EOL] [EOL] @ classmethod def _get_fields ( cls , cols ) : [EOL] return [ sqla . column ( c . get ( [string] ) ) for c in cols ] [EOL] [EOL] @ classmethod def select_star ( cls , my_db , table_name , engine , schema = None , limit = [number] , show_cols = False , indent = True , latest_partition = True , cols = None ) : [EOL] fields = [string] [EOL] cols = cols or [ ] [EOL] if ( show_cols or latest_partition ) and not cols : [EOL] cols = my_db . get_columns ( table_name , schema ) [EOL] [EOL] if show_cols : [EOL] fields = cls . _get_fields ( cols ) [EOL] quote = engine . dialect . identifier_preparer . quote [EOL] if schema : [EOL] full_table_name = quote ( schema ) + [string] + quote ( table_name ) [EOL] else : [EOL] full_table_name = quote ( table_name ) [EOL] [EOL] qry = select ( fields ) . select_from ( text ( full_table_name ) ) [EOL] [EOL] if limit : [EOL] qry = qry . limit ( limit ) [EOL] if latest_partition : [EOL] partition_query = cls . where_latest_partition ( table_name , schema , my_db , qry , columns = cols ) [EOL] if partition_query != False : [comment] [EOL] qry = partition_query [EOL] sql = my_db . compile_sqla_query ( qry ) [EOL] if indent : [EOL] sql = sqlparse . format ( sql , reindent = True ) [EOL] return sql [EOL] [EOL] @ classmethod def modify_url_for_impersonation ( cls , url , impersonate_user , username ) : [EOL] [docstring] [EOL] if impersonate_user is not None and username is not None : [EOL] url . username = username [EOL] [EOL] @ classmethod def get_configuration_for_impersonation ( cls , uri , impersonate_user , username ) : [EOL] [docstring] [EOL] return { } [EOL] [EOL] @ classmethod def execute ( cls , cursor , query , ** kwargs ) : [EOL] [comment] [EOL] if cls . arraysize : [EOL] cursor . arraysize = cls . arraysize [EOL] cursor . execute ( query ) [EOL] [EOL] @ classmethod def make_label_compatible ( cls , label ) : [EOL] [docstring] [EOL] label_mutated = cls . mutate_label ( label ) [EOL] if cls . max_column_name_length and len ( label_mutated ) > cls . max_column_name_length : [EOL] label_mutated = cls . truncate_label ( label ) [EOL] if cls . force_column_alias_quotes : [EOL] label_mutated = quoted_name ( label_mutated , True ) [EOL] return label_mutated [EOL] [EOL] @ classmethod def get_sqla_column_type ( cls , type_ ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ staticmethod def mutate_label ( label ) : [EOL] [docstring] [EOL] return label [EOL] [EOL] @ classmethod def truncate_label ( cls , label ) : [EOL] [docstring] [EOL] label = hashlib . md5 ( label . encode ( [string] ) ) . hexdigest ( ) [EOL] [comment] [EOL] if cls . max_column_name_length and len ( label ) > cls . max_column_name_length : [EOL] label = label [ : cls . max_column_name_length ] [EOL] return label [EOL] [EOL] @ staticmethod def get_timestamp_column ( expression , column_name ) : [EOL] [docstring] [EOL] return expression or column_name [EOL] [EOL] [EOL] class PostgresBaseEngineSpec ( BaseEngineSpec ) : [EOL] [docstring] [EOL] [EOL] engine = [string] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def fetch_data ( cls , cursor , limit ) : [EOL] if not cursor . description : [EOL] return [ ] [EOL] if cls . limit_method == LimitMethod . FETCH_MANY : [EOL] return cursor . fetchmany ( limit ) [EOL] return cursor . fetchall ( ) [EOL] [EOL] @ classmethod def epoch_to_dttm ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] [EOL] class PostgresEngineSpec ( PostgresBaseEngineSpec ) : [EOL] engine = [string] [EOL] max_column_name_length = [number] [EOL] [EOL] @ classmethod def get_table_names ( cls , inspector , schema ) : [EOL] [docstring] [EOL] tables = inspector . get_table_names ( schema ) [EOL] tables . extend ( inspector . get_foreign_table_names ( schema ) ) [EOL] return sorted ( tables ) [EOL] [EOL] @ staticmethod def get_timestamp_column ( expression , column_name ) : [EOL] [docstring] [EOL] if expression : [EOL] return expression [EOL] elif column_name . lower ( ) != column_name : [EOL] return f' [string] { column_name } [string] ' [EOL] return column_name [EOL] [EOL] [EOL] class SnowflakeEngineSpec ( PostgresBaseEngineSpec ) : [EOL] engine = [string] [EOL] force_column_alias_quotes = True [EOL] max_column_name_length = [number] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def adjust_database_uri ( cls , uri , selected_schema = None ) : [EOL] database = uri . database [EOL] if [string] in uri . database : [EOL] database = uri . database . split ( [string] ) [ [number] ] [EOL] if selected_schema : [EOL] selected_schema = parse . quote ( selected_schema , safe = [string] ) [EOL] uri . database = database + [string] + selected_schema [EOL] return uri [EOL] [EOL] [EOL] class VerticaEngineSpec ( PostgresBaseEngineSpec ) : [EOL] engine = [string] [EOL] [EOL] [EOL] class RedshiftEngineSpec ( PostgresBaseEngineSpec ) : [EOL] engine = [string] [EOL] max_column_name_length = [number] [EOL] [EOL] @ staticmethod def mutate_label ( label ) : [EOL] [docstring] [EOL] return label . lower ( ) [EOL] [EOL] [EOL] class OracleEngineSpec ( PostgresBaseEngineSpec ) : [EOL] engine = [string] [EOL] limit_method = LimitMethod . WRAP_SQL [EOL] force_column_alias_quotes = True [EOL] max_column_name_length = [number] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] return ( [string] ) . format ( dttm . isoformat ( ) ) [EOL] [EOL] [EOL] class Db2EngineSpec ( BaseEngineSpec ) : [EOL] engine = [string] [EOL] limit_method = LimitMethod . WRAP_SQL [EOL] force_column_alias_quotes = True [EOL] max_column_name_length = [number] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] [string] , [string] : [string] [string] [string] , [string] : [string] [string] [string] [string] , [string] : [string] [string] [string] [string] [string] , [string] : [string] , [string] : [string] , [string] : [string] [string] [string] , [string] : [string] [string] , } [EOL] [EOL] @ classmethod def epoch_to_dttm ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] [EOL] class SqliteEngineSpec ( BaseEngineSpec ) : [EOL] engine = [string] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def epoch_to_dttm ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def fetch_result_sets ( cls , db , datasource_type ) : [EOL] schemas = db . all_schema_names ( cache = db . schema_cache_enabled , cache_timeout = db . schema_cache_timeout , force = True ) [EOL] all_result_sets = [ ] [EOL] schema = schemas [ [number] ] [EOL] if datasource_type == [string] : [EOL] all_datasource_names = db . all_table_names_in_schema ( schema = schema , force = True , cache = db . table_cache_enabled , cache_timeout = db . table_cache_timeout ) [EOL] elif datasource_type == [string] : [EOL] all_datasource_names = db . all_view_names_in_schema ( schema = schema , force = True , cache = db . table_cache_enabled , cache_timeout = db . table_cache_timeout ) [EOL] else : [EOL] raise Exception ( f' [string] { datasource_type }' ) [EOL] [EOL] all_result_sets += [ [string] . format ( schema , t ) for t in all_datasource_names ] [EOL] return all_result_sets [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] iso = dttm . isoformat ( ) . replace ( [string] , [string] ) [EOL] if [string] not in iso : [EOL] iso += [string] [EOL] return [string] . format ( iso ) [EOL] [EOL] @ classmethod def get_table_names ( cls , inspector , schema ) : [EOL] [docstring] [EOL] return sorted ( inspector . get_table_names ( ) ) [EOL] [EOL] [EOL] class MySQLEngineSpec ( BaseEngineSpec ) : [EOL] engine = [string] [EOL] max_column_name_length = [number] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] [string] [string] , [string] : [string] [string] , [string] : [string] [string] , [string] : [string] , [string] : [string] [string] , [string] : [string] [string] , [string] : [string] [string] , [string] : [string] [string] , [string] : [string] [string] , } [EOL] [EOL] type_code_map = { } [comment] [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] if target_type . upper ( ) in ( [string] , [string] ) : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] @ classmethod def adjust_database_uri ( cls , uri , selected_schema = None ) : [EOL] if selected_schema : [EOL] uri . database = parse . quote ( selected_schema , safe = [string] ) [EOL] return uri [EOL] [EOL] @ classmethod def get_datatype ( cls , type_code ) : [EOL] if not cls . type_code_map : [EOL] [comment] [EOL] import MySQLdb [EOL] ft = MySQLdb . constants . FIELD_TYPE [EOL] cls . type_code_map = { getattr ( ft , k ) : k for k in dir ( ft ) if not k . startswith ( [string] ) } [EOL] datatype = type_code [EOL] if isinstance ( type_code , int ) : [EOL] datatype = cls . type_code_map . get ( type_code ) [EOL] if datatype and isinstance ( datatype , str ) and len ( datatype ) : [EOL] return datatype [EOL] [EOL] @ classmethod def epoch_to_dttm ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def extract_error_message ( cls , e ) : [EOL] [docstring] [EOL] message = str ( e ) [EOL] try : [EOL] if isinstance ( e . args , tuple ) and len ( e . args ) > [number] : [EOL] message = e . args [ [number] ] [EOL] except Exception : [EOL] pass [EOL] return message [EOL] [EOL] [EOL] class PrestoEngineSpec ( BaseEngineSpec ) : [EOL] engine = [string] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def get_view_names ( cls , inspector , schema ) : [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] @ classmethod def _create_column_info ( cls , column , name , data_type ) : [EOL] [docstring] [EOL] return { [string] : name , [string] : data_type , [string] : getattr ( column , [string] , True ) , [string] : None , } [EOL] [EOL] @ classmethod def _get_full_name ( cls , names ) : [EOL] [docstring] [EOL] return [string] . join ( column [ [number] ] for column in names if column [ [number] ] ) [EOL] [EOL] @ classmethod def _has_nested_data_types ( cls , component_type ) : [EOL] [docstring] [EOL] comma_regex = [string] [EOL] white_space_regex = [string] [EOL] return re . search ( comma_regex , component_type ) is not None or re . search ( white_space_regex , component_type ) is not None [EOL] [EOL] @ classmethod def _split_data_type ( cls , data_type , delimiter ) : [EOL] [docstring] [EOL] return re . split ( [string] . format ( delimiter ) , data_type ) [EOL] [EOL] @ classmethod def _parse_structural_column ( cls , column , result ) : [EOL] [docstring] [EOL] full_data_type = [string] . format ( column . Column , column . Type ) [EOL] [comment] [EOL] [comment] [EOL] data_types = cls . _split_data_type ( full_data_type , [string] ) [EOL] stack = [ ] [EOL] for data_type in data_types : [EOL] [comment] [EOL] [comment] [EOL] inner_types = cls . _split_data_type ( data_type , [string] ) [EOL] for inner_type in inner_types : [EOL] [comment] [EOL] if not inner_type and len ( stack ) > [number] : [EOL] stack . pop ( ) [EOL] elif cls . _has_nested_data_types ( inner_type ) : [EOL] [comment] [EOL] single_fields = cls . _split_data_type ( inner_type , [string] ) [EOL] for single_field in single_fields : [EOL] [comment] [EOL] [comment] [EOL] if not single_field : [EOL] continue [EOL] [comment] [EOL] field_info = cls . _split_data_type ( single_field , [string] ) [EOL] [comment] [EOL] [comment] [EOL] if field_info [ [number] ] == [string] or field_info [ [number] ] == [string] : [EOL] stack . append ( ( field_info [ [number] ] , field_info [ [number] ] ) ) [EOL] full_parent_path = cls . _get_full_name ( stack ) [EOL] result . append ( cls . _create_column_info ( column , full_parent_path , presto_type_map [ field_info [ [number] ] ] ( ) ) ) [EOL] else : [comment] [EOL] full_parent_path = cls . _get_full_name ( stack ) [EOL] column_name = [string] . format ( full_parent_path , field_info [ [number] ] ) [EOL] result . append ( cls . _create_column_info ( column , column_name , presto_type_map [ field_info [ [number] ] ] ( ) ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not ( inner_type . endswith ( [string] ) or inner_type . endswith ( [string] ) ) : [EOL] stack . pop ( ) [EOL] [comment] [EOL] elif [string] == inner_type or [string] == inner_type : [EOL] [comment] [EOL] stack . append ( ( [string] , inner_type ) ) [EOL] [comment] [EOL] elif len ( stack ) > [number] : [EOL] [comment] [EOL] [comment] [EOL] stack . pop ( ) [EOL] [EOL] @ classmethod def _show_columns ( cls , inspector , table_name , schema ) : [EOL] [docstring] [EOL] quote = inspector . engine . dialect . identifier_preparer . quote_identifier [EOL] full_table = quote ( table_name ) [EOL] if schema : [EOL] full_table = [string] . format ( quote ( schema ) , full_table ) [EOL] columns = inspector . bind . execute ( [string] . format ( full_table ) ) [EOL] return columns [EOL] [EOL] @ classmethod def get_columns ( cls , inspector , table_name , schema ) : [EOL] [docstring] [EOL] columns = cls . _show_columns ( inspector , table_name , schema ) [EOL] result = [ ] [EOL] for column in columns : [EOL] try : [EOL] [comment] [EOL] if [string] in column . Type or [string] in column . Type : [EOL] cls . _parse_structural_column ( column , result ) [EOL] continue [EOL] else : [comment] [EOL] column_type = presto_type_map [ column . Type ] ( ) [EOL] except KeyError : [EOL] logging . info ( [string] . format ( column . Type , column . Column ) ) [EOL] column_type = types . NullType [EOL] result . append ( cls . _create_column_info ( column , column . Column , column_type ) ) [EOL] return result [EOL] [EOL] @ classmethod def _is_column_name_quoted ( cls , column_name ) : [EOL] [docstring] [EOL] return column_name . startswith ( [string] ) and column_name . endswith ( [string] ) [EOL] [EOL] @ classmethod def _get_fields ( cls , cols ) : [EOL] [docstring] [EOL] column_clauses = [ ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dot_pattern = [string] [EOL] dot_regex = re . compile ( dot_pattern , re . VERBOSE ) [EOL] for col in cols : [EOL] [comment] [EOL] col_names = re . split ( dot_regex , col [ [string] ] ) [EOL] [comment] [EOL] for index , col_name in enumerate ( col_names ) : [EOL] if not cls . _is_column_name_quoted ( col_name ) : [EOL] col_names [ index ] = [string] . format ( col_name ) [EOL] quoted_col_name = [string] . join ( col_name if cls . _is_column_name_quoted ( col_name ) else f' [string] { col_name } [string] ' for col_name in col_names ) [EOL] [comment] [EOL] column_clause = sqla . literal_column ( quoted_col_name ) . label ( col [ [string] ] ) [EOL] column_clauses . append ( column_clause ) [EOL] return column_clauses [EOL] [EOL] @ classmethod def _filter_presto_cols ( cls , cols ) : [EOL] [docstring] [EOL] filtered_cols = [ ] [EOL] curr_array_col_name = [string] [EOL] for col in cols : [EOL] [comment] [EOL] if curr_array_col_name and col [ [string] ] . startswith ( curr_array_col_name ) : [EOL] continue [EOL] [comment] [EOL] [comment] [EOL] elif str ( col [ [string] ] ) == [string] : [EOL] curr_array_col_name = col [ [string] ] [EOL] filtered_cols . append ( col ) [EOL] else : [EOL] curr_array_col_name = [string] [EOL] filtered_cols . append ( col ) [EOL] return filtered_cols [EOL] [EOL] @ classmethod def select_star ( cls , my_db , table_name , engine , schema = None , limit = [number] , show_cols = False , indent = True , latest_partition = True , cols = [ ] ) : [EOL] [docstring] [EOL] presto_cols = cols [EOL] if show_cols : [EOL] presto_cols = cls . _filter_presto_cols ( cols ) [EOL] return super ( PrestoEngineSpec , cls ) . select_star ( my_db , table_name , engine , schema , limit , show_cols , indent , latest_partition , presto_cols , ) [EOL] [EOL] @ classmethod def adjust_database_uri ( cls , uri , selected_schema = None ) : [EOL] database = uri . database [EOL] if selected_schema and database : [EOL] selected_schema = parse . quote ( selected_schema , safe = [string] ) [EOL] if [string] in database : [EOL] database = database . split ( [string] ) [ [number] ] + [string] + selected_schema [EOL] else : [EOL] database += [string] + selected_schema [EOL] uri . database = database [EOL] return uri [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] tt = target_type . upper ( ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . isoformat ( ) [ : [number] ] ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . isoformat ( ) ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . isoformat ( ) ) [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] @ classmethod def epoch_to_dttm ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def fetch_result_sets ( cls , db , datasource_type ) : [EOL] [docstring] [EOL] result_set_df = db . get_df ( [string] . format ( datasource_type . upper ( ) , ) , None ) [EOL] result_sets = [ ] [EOL] for unused , row in result_set_df . iterrows ( ) : [EOL] result_sets . append ( [string] . format ( row [ [string] ] , row [ [string] ] ) ) [EOL] return result_sets [EOL] [EOL] @ classmethod def extra_table_metadata ( cls , database , table_name , schema_name ) : [EOL] indexes = database . get_indexes ( table_name , schema_name ) [EOL] if not indexes : [EOL] return { } [EOL] cols = indexes [ [number] ] . get ( [string] , [ ] ) [EOL] full_table_name = table_name [EOL] if schema_name and [string] not in table_name : [EOL] full_table_name = [string] . format ( schema_name , table_name ) [EOL] pql = cls . _partition_query ( full_table_name ) [EOL] col_name , latest_part = cls . latest_partition ( table_name , schema_name , database , show_first = True ) [EOL] return { [string] : { [string] : cols , [string] : { col_name : latest_part } , [string] : pql , } , } [EOL] [EOL] @ classmethod def handle_cursor ( cls , cursor , query , session ) : [EOL] [docstring] [EOL] logging . info ( [string] ) [EOL] polled = cursor . poll ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] while polled : [EOL] [comment] [EOL] stats = polled . get ( [string] , { } ) [EOL] [EOL] query = session . query ( type ( query ) ) . filter_by ( id = query . id ) . one ( ) [EOL] if query . status in [ QueryStatus . STOPPED , QueryStatus . TIMED_OUT ] : [EOL] cursor . cancel ( ) [EOL] break [EOL] [EOL] if stats : [EOL] state = stats . get ( [string] ) [EOL] [EOL] [comment] [EOL] if state == [string] : [EOL] break [EOL] [EOL] completed_splits = float ( stats . get ( [string] ) ) [EOL] total_splits = float ( stats . get ( [string] ) ) [EOL] if total_splits and completed_splits : [EOL] progress = [number] * ( completed_splits / total_splits ) [EOL] logging . info ( [string] [string] . format ( completed_splits , total_splits ) ) [EOL] if progress > query . progress : [EOL] query . progress = progress [EOL] session . commit ( ) [EOL] time . sleep ( [number] ) [EOL] logging . info ( [string] ) [EOL] polled = cursor . poll ( ) [EOL] [EOL] @ classmethod def extract_error_message ( cls , e ) : [EOL] if ( hasattr ( e , [string] ) and type ( e . orig ) . __name__ == [string] and isinstance ( e . orig [ [number] ] , dict ) ) : [EOL] error_dict = e . orig [ [number] ] [EOL] return [string] . format ( error_dict . get ( [string] ) , error_dict . get ( [string] ) , error_dict . get ( [string] ) , ) [EOL] if ( type ( e ) . __name__ == [string] and hasattr ( e , [string] ) and len ( e . args ) > [number] ) : [EOL] error_dict = e . args [ [number] ] [EOL] return error_dict . get ( [string] ) [EOL] return utils . error_msg_from_exception ( e ) [EOL] [EOL] @ classmethod def _partition_query ( cls , table_name , limit = [number] , order_by = None , filters = None ) : [EOL] [docstring] [EOL] limit_clause = [string] . format ( limit ) if limit else [string] [EOL] order_by_clause = [string] [EOL] if order_by : [EOL] l = [ ] [comment] [EOL] for field , desc in order_by : [EOL] l . append ( field + [string] if desc else [string] ) [EOL] order_by_clause = [string] + [string] . join ( l ) [EOL] [EOL] where_clause = [string] [EOL] if filters : [EOL] l = [ ] [comment] [EOL] for field , value in filters . items ( ) : [EOL] l . append ( f"{ field } [string] { value } [string] " ) [EOL] where_clause = [string] + [string] . join ( l ) [EOL] [EOL] sql = textwrap . dedent ( f""" [string] { table_name } [string] { where_clause } [string] { order_by_clause } [string] { limit_clause } [string] """ ) [EOL] return sql [EOL] [EOL] @ classmethod def where_latest_partition ( cls , table_name , schema , database , qry , columns = None ) : [EOL] try : [EOL] col_name , value = cls . latest_partition ( table_name , schema , database , show_first = True ) [EOL] except Exception : [EOL] [comment] [EOL] return False [EOL] if value is not None : [EOL] for c in columns : [EOL] if c . get ( [string] ) == col_name : [EOL] return qry . where ( Column ( col_name ) == value ) [EOL] return False [EOL] [EOL] @ classmethod def _latest_partition_from_df ( cls , df ) : [EOL] if not df . empty : [EOL] return df . to_records ( index = False ) [ [number] ] [ [number] ] [EOL] [EOL] @ classmethod def latest_partition ( cls , table_name , schema , database , show_first = False ) : [EOL] [docstring] [EOL] indexes = database . get_indexes ( table_name , schema ) [EOL] if len ( indexes [ [number] ] [ [string] ] ) < [number] : [EOL] raise SupersetTemplateException ( [string] ) [EOL] elif not show_first and len ( indexes [ [number] ] [ [string] ] ) > [number] : [EOL] raise SupersetTemplateException ( [string] [string] [string] ) [EOL] part_field = indexes [ [number] ] [ [string] ] [ [number] ] [EOL] sql = cls . _partition_query ( table_name , [number] , [ ( part_field , True ) ] ) [EOL] df = database . get_df ( sql , schema ) [EOL] return part_field , cls . _latest_partition_from_df ( df ) [EOL] [EOL] @ classmethod def latest_sub_partition ( cls , table_name , schema , database , ** kwargs ) : [EOL] [docstring] [EOL] indexes = database . get_indexes ( table_name , schema ) [EOL] part_fields = indexes [ [number] ] [ [string] ] [EOL] for k in kwargs . keys ( ) : [EOL] if k not in k in part_fields : [EOL] msg = [string] [EOL] raise SupersetTemplateException ( msg ) [EOL] if len ( kwargs . keys ( ) ) != len ( part_fields ) - [number] : [EOL] msg = ( [string] [string] ) . format ( len ( part_fields ) - [number] , len ( part_fields ) ) [EOL] raise SupersetTemplateException ( msg ) [EOL] [EOL] for field in part_fields : [EOL] if field not in kwargs . keys ( ) : [EOL] field_to_return = field [EOL] [EOL] sql = cls . _partition_query ( table_name , [number] , [ ( field_to_return , True ) ] , kwargs ) [EOL] df = database . get_df ( sql , schema ) [EOL] if df . empty : [EOL] return [string] [EOL] return df . to_dict ( ) [ field_to_return ] [ [number] ] [EOL] [EOL] [EOL] class HiveEngineSpec ( PrestoEngineSpec ) : [EOL] [EOL] [docstring] [EOL] [EOL] engine = [string] [EOL] max_column_name_length = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] jobs_stats_r = re . compile ( [string] ) [EOL] [comment] [EOL] launching_job_r = re . compile ( [string] [string] ) [EOL] [comment] [EOL] [comment] [EOL] stage_progress_r = re . compile ( [string] [string] [string] ) [EOL] [EOL] @ classmethod def patch ( cls ) : [EOL] from pyhive import hive [comment] [EOL] from superset . db_engines import hive as patched_hive [EOL] from TCLIService import ( constants as patched_constants , ttypes as patched_ttypes , TCLIService as patched_TCLIService ) [EOL] [EOL] hive . TCLIService = patched_TCLIService [EOL] hive . constants = patched_constants [EOL] hive . ttypes = patched_ttypes [EOL] hive . Cursor . fetch_logs = patched_hive . fetch_logs [EOL] [EOL] @ classmethod def fetch_result_sets ( cls , db , datasource_type ) : [EOL] return BaseEngineSpec . fetch_result_sets ( db , datasource_type ) [EOL] [EOL] @ classmethod def fetch_data ( cls , cursor , limit ) : [EOL] import pyhive [EOL] from TCLIService import ttypes [EOL] state = cursor . poll ( ) [EOL] if state . operationState == ttypes . TOperationState . ERROR_STATE : [EOL] raise Exception ( [string] , state . errorMessage ) [EOL] try : [EOL] return super ( HiveEngineSpec , cls ) . fetch_data ( cursor , limit ) [EOL] except pyhive . exc . ProgrammingError : [EOL] return [ ] [EOL] [EOL] @ staticmethod def create_table_from_csv ( form , table ) : [EOL] [docstring] [EOL] def convert_to_hive_type ( col_type ) : [EOL] [docstring] [EOL] tableschema_to_hive_types = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] return tableschema_to_hive_types . get ( col_type , [string] ) [EOL] [EOL] bucket_path = config [ [string] ] [EOL] [EOL] if not bucket_path : [EOL] logging . info ( [string] ) [EOL] raise Exception ( [string] ) [EOL] [EOL] table_name = form . name . data [EOL] schema_name = form . schema . data [EOL] [EOL] if config . get ( [string] ) : [EOL] if [string] in table_name or schema_name : [EOL] raise Exception ( [string] [string] . format ( config . get ( [string] ) ) ) [EOL] full_table_name = [string] . format ( config . get ( [string] ) , table_name ) [EOL] else : [EOL] if [string] in table_name and schema_name : [EOL] raise Exception ( [string] [string] ) [EOL] [EOL] full_table_name = [string] . format ( schema_name , table_name ) if schema_name else table_name [EOL] [EOL] filename = form . csv_file . data . filename [EOL] [EOL] upload_prefix = config [ [string] ] [EOL] upload_path = config [ [string] ] + secure_filename ( filename ) [EOL] [EOL] [comment] [EOL] from tableschema import Table [comment] [EOL] hive_table_schema = Table ( upload_path ) . infer ( ) [EOL] column_name_and_type = [ ] [EOL] for column_info in hive_table_schema [ [string] ] : [EOL] column_name_and_type . append ( [string] . format ( column_info [ [string] ] , convert_to_hive_type ( column_info [ [string] ] ) ) ) [EOL] schema_definition = [string] . join ( column_name_and_type ) [EOL] [EOL] [comment] [EOL] import boto3 [comment] [EOL] [EOL] s3 = boto3 . client ( [string] ) [EOL] location = os . path . join ( [string] , bucket_path , upload_prefix , table_name ) [EOL] s3 . upload_file ( upload_path , bucket_path , os . path . join ( upload_prefix , table_name , filename ) ) [EOL] sql = f""" [string] { full_table_name } [string] { schema_definition } [string] { location } [string] """ [EOL] logging . info ( form . con . data ) [EOL] engine = create_engine ( form . con . data . sqlalchemy_uri_decrypted ) [EOL] engine . execute ( sql ) [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] tt = target_type . upper ( ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . isoformat ( ) [ : [number] ] ) [EOL] elif tt == [string] : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] @ classmethod def adjust_database_uri ( cls , uri , selected_schema = None ) : [EOL] if selected_schema : [EOL] uri . database = parse . quote ( selected_schema , safe = [string] ) [EOL] return uri [EOL] [EOL] @ classmethod def extract_error_message ( cls , e ) : [EOL] msg = str ( e ) [EOL] match = re . search ( [string] , msg ) [EOL] if match : [EOL] msg = match . group ( [number] ) [EOL] return msg [EOL] [EOL] @ classmethod def progress ( cls , log_lines ) : [EOL] total_jobs = [number] [comment] [EOL] current_job = [number] [EOL] stages = { } [EOL] for line in log_lines : [EOL] match = cls . jobs_stats_r . match ( line ) [EOL] if match : [EOL] total_jobs = int ( match . groupdict ( ) [ [string] ] ) or [number] [EOL] match = cls . launching_job_r . match ( line ) [EOL] if match : [EOL] current_job = int ( match . groupdict ( ) [ [string] ] ) [EOL] total_jobs = int ( match . groupdict ( ) [ [string] ] ) or [number] [EOL] stages = { } [EOL] match = cls . stage_progress_r . match ( line ) [EOL] if match : [EOL] stage_number = int ( match . groupdict ( ) [ [string] ] ) [EOL] map_progress = int ( match . groupdict ( ) [ [string] ] ) [EOL] reduce_progress = int ( match . groupdict ( ) [ [string] ] ) [EOL] stages [ stage_number ] = ( map_progress + reduce_progress ) / [number] [EOL] logging . info ( [string] [string] [string] . format ( stages , current_job , total_jobs ) ) [EOL] [EOL] stage_progress = sum ( stages . values ( ) ) / len ( stages . values ( ) ) if stages else [number] [EOL] [EOL] progress = ( [number] * ( current_job - [number] ) / total_jobs + stage_progress / total_jobs ) [EOL] return int ( progress ) [EOL] [EOL] @ classmethod def get_tracking_url ( cls , log_lines ) : [EOL] lkp = [string] [EOL] for line in log_lines : [EOL] if lkp in line : [EOL] return line . split ( lkp ) [ [number] ] [EOL] [EOL] @ classmethod def handle_cursor ( cls , cursor , query , session ) : [EOL] [docstring] [EOL] from pyhive import hive [comment] [EOL] unfinished_states = ( hive . ttypes . TOperationState . INITIALIZED_STATE , hive . ttypes . TOperationState . RUNNING_STATE , ) [EOL] polled = cursor . poll ( ) [EOL] last_log_line = [number] [EOL] tracking_url = None [EOL] job_id = None [EOL] while polled . operationState in unfinished_states : [EOL] query = session . query ( type ( query ) ) . filter_by ( id = query . id ) . one ( ) [EOL] if query . status == QueryStatus . STOPPED : [EOL] cursor . cancel ( ) [EOL] break [EOL] [EOL] log = cursor . fetch_logs ( ) or [string] [EOL] if log : [EOL] log_lines = log . splitlines ( ) [EOL] progress = cls . progress ( log_lines ) [EOL] logging . info ( [string] . format ( progress ) ) [EOL] needs_commit = False [EOL] if progress > query . progress : [EOL] query . progress = progress [EOL] needs_commit = True [EOL] if not tracking_url : [EOL] tracking_url = cls . get_tracking_url ( log_lines ) [EOL] if tracking_url : [EOL] job_id = tracking_url . split ( [string] ) [ - [number] ] [EOL] logging . info ( [string] . format ( tracking_url ) ) [EOL] tracking_url = tracking_url_trans ( tracking_url ) [EOL] logging . info ( [string] . format ( tracking_url ) ) [EOL] query . tracking_url = tracking_url [EOL] logging . info ( [string] . format ( job_id ) ) [EOL] needs_commit = True [EOL] if job_id and len ( log_lines ) > last_log_line : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for l in log_lines [ last_log_line : ] : [EOL] logging . info ( [string] . format ( job_id , l ) ) [EOL] last_log_line = len ( log_lines ) [EOL] if needs_commit : [EOL] session . commit ( ) [EOL] time . sleep ( hive_poll_interval ) [EOL] polled = cursor . poll ( ) [EOL] [EOL] @ classmethod def get_columns ( cls , inspector , table_name , schema ) : [EOL] return inspector . get_columns ( table_name , schema ) [EOL] [EOL] @ classmethod def where_latest_partition ( cls , table_name , schema , database , qry , columns = None ) : [EOL] try : [EOL] col_name , value = cls . latest_partition ( table_name , schema , database , show_first = True ) [EOL] except Exception : [EOL] [comment] [EOL] return False [EOL] if value is not None : [EOL] for c in columns : [EOL] if c . get ( [string] ) == col_name : [EOL] return qry . where ( Column ( col_name ) == value ) [EOL] return False [EOL] [EOL] @ classmethod def _get_fields ( cls , cols ) : [EOL] return BaseEngineSpec . _get_fields ( cols ) [EOL] [EOL] @ classmethod def latest_sub_partition ( cls , table_name , schema , database , ** kwargs ) : [EOL] [comment] [EOL] pass [EOL] [EOL] @ classmethod def _latest_partition_from_df ( cls , df ) : [EOL] [docstring] [EOL] if not df . empty : [EOL] return df . ix [ : , [number] ] . max ( ) . split ( [string] ) [ [number] ] [EOL] [EOL] @ classmethod def _partition_query ( cls , table_name , limit = [number] , order_by = None , filters = None ) : [EOL] return f' [string] { table_name }' [EOL] [EOL] @ classmethod def select_star ( cls , my_db , table_name , engine , schema = None , limit = [number] , show_cols = False , indent = True , latest_partition = True , cols = [ ] ) : [EOL] return BaseEngineSpec . select_star ( my_db , table_name , engine , schema , limit , show_cols , indent , latest_partition , cols ) [EOL] [EOL] @ classmethod def modify_url_for_impersonation ( cls , url , impersonate_user , username ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] @ classmethod def get_configuration_for_impersonation ( cls , uri , impersonate_user , username ) : [EOL] [docstring] [EOL] configuration = { } [EOL] url = make_url ( uri ) [EOL] backend_name = url . get_backend_name ( ) [EOL] [EOL] [comment] [EOL] if ( backend_name == [string] and [string] in url . query . keys ( ) and impersonate_user is True and username is not None ) : [EOL] configuration [ [string] ] = username [EOL] return configuration [EOL] [EOL] @ staticmethod def execute ( cursor , query , async_ = False ) : [EOL] kwargs = { [string] : async_ } [EOL] cursor . execute ( query , ** kwargs ) [EOL] [EOL] [EOL] class MssqlEngineSpec ( BaseEngineSpec ) : [EOL] engine = [string] [EOL] epoch_to_dttm = [string] [EOL] limit_method = LimitMethod . WRAP_SQL [EOL] max_column_name_length = [number] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] return [string] . format ( dttm . isoformat ( ) ) [EOL] [EOL] @ classmethod def fetch_data ( cls , cursor , limit ) : [EOL] data = super ( MssqlEngineSpec , cls ) . fetch_data ( cursor , limit ) [EOL] if len ( data ) != [number] and type ( data [ [number] ] ) . __name__ == [string] : [EOL] data = [ [ elem for elem in r ] for r in data ] [EOL] return data [EOL] [EOL] column_types = [ ( String ( ) , re . compile ( [string] , re . IGNORECASE ) ) , ( UnicodeText ( ) , re . compile ( [string] , re . IGNORECASE ) ) , ] [EOL] [EOL] @ classmethod def get_sqla_column_type ( cls , type_ ) : [EOL] [comment] [EOL] for sqla_type , regex in cls . column_types : [EOL] if regex . match ( type_ ) : [EOL] return sqla_type [EOL] return None [EOL] [EOL] [EOL] class AthenaEngineSpec ( BaseEngineSpec ) : [EOL] engine = [string] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] tt = target_type . upper ( ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . isoformat ( ) [ : [number] ] ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . isoformat ( ) ) [EOL] return ( [string] . format ( dttm . strftime ( [string] ) ) ) [EOL] [EOL] @ classmethod def epoch_to_dttm ( cls ) : [EOL] return [string] [EOL] [EOL] @ staticmethod def mutate_label ( label ) : [EOL] [docstring] [EOL] return label . lower ( ) [EOL] [EOL] [EOL] class PinotEngineSpec ( BaseEngineSpec ) : [EOL] engine = [string] [EOL] allows_subquery = False [EOL] inner_joins = False [EOL] supports_column_aliases = False [EOL] [EOL] _time_grain_to_datetimeconvert = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [comment] [EOL] time_grain_functions = { k : None for k in _time_grain_to_datetimeconvert . keys ( ) } [EOL] [EOL] @ classmethod def get_time_expr ( cls , expr , pdf , time_grain , grain ) : [EOL] is_epoch = pdf in ( [string] , [string] ) [EOL] if not is_epoch : [EOL] raise NotImplementedError ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] seconds_or_ms = [string] if pdf == [string] else [string] [EOL] tf = f' [string] { seconds_or_ms } [string] ' [EOL] granularity = cls . _time_grain_to_datetimeconvert . get ( time_grain ) [EOL] if not granularity : [EOL] raise NotImplementedError ( [string] + str ( time_grain ) ) [EOL] [comment] [EOL] return f' [string] { expr } [string] { tf } [string] { tf } [string] { granularity } [string] ' [EOL] [EOL] @ classmethod def make_select_compatible ( cls , groupby_exprs , select_exprs ) : [EOL] [comment] [EOL] select_sans_groupby = [ ] [EOL] [comment] [EOL] for s in select_exprs : [EOL] for gr in groupby_exprs : [EOL] if s is gr : [EOL] break [EOL] else : [EOL] select_sans_groupby . append ( s ) [EOL] return select_sans_groupby [EOL] [EOL] [EOL] class ClickHouseEngineSpec ( BaseEngineSpec ) : [EOL] [docstring] [EOL] [EOL] engine = [string] [EOL] [EOL] time_secondary_columns = True [EOL] time_groupby_inline = True [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] tt = target_type . upper ( ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] [EOL] class BQEngineSpec ( BaseEngineSpec ) : [EOL] [docstring] [EOL] engine = [string] [EOL] max_column_name_length = [number] [EOL] [EOL] [docstring] [EOL] arraysize = [number] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] tt = target_type . upper ( ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] @ classmethod def fetch_data ( cls , cursor , limit ) : [EOL] data = super ( BQEngineSpec , cls ) . fetch_data ( cursor , limit ) [EOL] if len ( data ) != [number] and type ( data [ [number] ] ) . __name__ == [string] : [EOL] data = [ r . values ( ) for r in data ] [EOL] return data [EOL] [EOL] @ staticmethod def mutate_label ( label ) : [EOL] [docstring] [EOL] label_hashed = [string] + hashlib . md5 ( label . encode ( [string] ) ) . hexdigest ( ) [EOL] [EOL] [comment] [EOL] label_mutated = [string] + label if re . match ( [string] , label ) else label [EOL] [EOL] [comment] [EOL] label_mutated = re . sub ( [string] , [string] , label_mutated ) [EOL] if label_mutated != label : [EOL] [comment] [EOL] label_mutated += label_hashed [EOL] [EOL] return label_mutated [EOL] [EOL] @ classmethod def truncate_label ( cls , label ) : [EOL] [docstring] [EOL] return [string] + hashlib . md5 ( label . encode ( [string] ) ) . hexdigest ( ) [EOL] [EOL] @ classmethod def extra_table_metadata ( cls , database , table_name , schema_name ) : [EOL] indexes = database . get_indexes ( table_name , schema_name ) [EOL] if not indexes : [EOL] return { } [EOL] partitions_columns = [ index . get ( [string] , [ ] ) for index in indexes if index . get ( [string] ) == [string] ] [EOL] cluster_columns = [ index . get ( [string] , [ ] ) for index in indexes if index . get ( [string] ) == [string] ] [EOL] return { [string] : { [string] : partitions_columns , } , [string] : { [string] : cluster_columns , } , } [EOL] [EOL] @ classmethod def _get_fields ( cls , cols ) : [EOL] [docstring] [EOL] return [ sqla . literal_column ( c . get ( [string] ) ) . label ( c . get ( [string] ) . replace ( [string] , [string] ) ) for c in cols ] [EOL] [EOL] [EOL] class ImpalaEngineSpec ( BaseEngineSpec ) : [EOL] [docstring] [EOL] [EOL] engine = [string] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def epoch_to_dttm ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] tt = target_type . upper ( ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] @ classmethod def get_schema_names ( cls , inspector ) : [EOL] schemas = [ row [ [number] ] for row in inspector . engine . execute ( [string] ) if not row [ [number] ] . startswith ( [string] ) ] [EOL] return schemas [EOL] [EOL] [EOL] class DruidEngineSpec ( BaseEngineSpec ) : [EOL] [docstring] [EOL] engine = [string] [EOL] inner_joins = False [EOL] allows_subquery = False [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def alter_new_orm_column ( cls , orm_col ) : [EOL] if orm_col . column_name == [string] : [EOL] orm_col . is_dttm = True [EOL] [EOL] [EOL] class GSheetsEngineSpec ( SqliteEngineSpec ) : [EOL] [docstring] [EOL] engine = [string] [EOL] inner_joins = False [EOL] allows_subquery = False [EOL] [EOL] [EOL] class KylinEngineSpec ( BaseEngineSpec ) : [EOL] [docstring] [EOL] [EOL] engine = [string] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] @ classmethod def convert_dttm ( cls , target_type , dttm ) : [EOL] tt = target_type . upper ( ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . isoformat ( ) [ : [number] ] ) [EOL] if tt == [string] : [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] return [string] . format ( dttm . strftime ( [string] ) ) [EOL] [EOL] [EOL] class TeradataEngineSpec ( BaseEngineSpec ) : [EOL] [docstring] [EOL] engine = [string] [EOL] limit_method = LimitMethod . WRAP_SQL [EOL] max_column_name_length = [number] [comment] [EOL] [EOL] time_grain_functions = { None : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] [EOL] [comment] [EOL] engines = { o . engine : o for o in globals ( ) . values ( ) if inspect . isclass ( o ) and issubclass ( o , BaseEngineSpec ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] from typing import List , Any [EOL] import typing [EOL] def fetch_logs ( self , max_rows = [number] , orientation = None ) : [EOL] [docstring] [EOL] from pyhive import hive [EOL] from TCLIService import ttypes [EOL] from thrift import Thrift [EOL] orientation = orientation or ttypes . TFetchOrientation . FETCH_NEXT [EOL] try : [EOL] req = ttypes . TGetLogReq ( operationHandle = self . _operationHandle ) [EOL] logs = self . _connection . client . GetLog ( req ) . log [EOL] return logs [EOL] [comment] [EOL] except ( ttypes . TApplicationException , Thrift . TApplicationException ) : [EOL] if self . _state == self . _STATE_NONE : [EOL] raise hive . ProgrammingError ( [string] ) [EOL] logs = [ ] [EOL] while True : [EOL] req = ttypes . TFetchResultsReq ( operationHandle = self . _operationHandle , orientation = ttypes . TFetchOrientation . FETCH_NEXT , maxRows = self . arraysize , fetchType = [number] , ) [EOL] response = self . _connection . client . FetchResults ( req ) [EOL] hive . _check_status ( response ) [EOL] assert not response . results . rows , [string] [EOL] assert len ( response . results . columns ) == [number] , response . results . columns [EOL] new_logs = hive . _unwrap_column ( response . results . columns [ [number] ] ) [EOL] logs += new_logs [EOL] if not new_logs : [EOL] break [EOL] return [string] . join ( logs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = [string] [EOL] [EOL] from alembic import op [EOL] import logging [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] op . add_column ( [string] , sa . Column ( [string] , sa . String ( length = [number] ) , nullable = True ) ) [EOL] op . add_column ( [string] , sa . Column ( [string] , sa . String ( length = [number] ) , nullable = True ) ) [EOL] [EOL] try : [EOL] op . create_unique_constraint ( None , [string] , [ [string] ] ) [EOL] op . create_unique_constraint ( None , [string] , [ [string] ] ) [EOL] except Exception as e : [EOL] logging . info ( [string] ) [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] try : [EOL] op . drop_column ( [string] , [string] ) [EOL] op . drop_column ( [string] , [string] ) [EOL] except Exception as e : [EOL] logging . exception ( e ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from superset import app [EOL] from superset . utils . core import get_celery_app [EOL] [EOL] [comment] [EOL] config = app . config [EOL] app = get_celery_app ( config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Dict , Any [EOL] import jinja2 [EOL] import typing [EOL] from __future__ import absolute_import [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import unicode_literals [EOL] [EOL] from flask import request , Response [EOL] from flask_appbuilder import expose [EOL] from flask_appbuilder . security . decorators import has_access_api [EOL] from jinja2 . sandbox import SandboxedEnvironment [EOL] import simplejson as json [EOL] from sqlalchemy import and_ , func [EOL] from werkzeug . routing import BaseConverter [EOL] [EOL] from superset import app , appbuilder , db , utils [EOL] from superset . jinja_context import current_user_id , current_username [EOL] from superset . models . core import Dashboard , Slice [EOL] from superset . models . sql_lab import SavedQuery [EOL] from superset . models . tags import ObjectTypes , Tag , TaggedObject , TagTypes [EOL] from . base import BaseSupersetView , json_success [EOL] [EOL] [EOL] class ObjectTypeConverter ( BaseConverter ) : [EOL] [EOL] [docstring] [EOL] [EOL] def to_python ( self , object_type ) : [EOL] return ObjectTypes [ object_type ] [EOL] [EOL] def to_url ( self , object_type ) : [EOL] return object_type . name [EOL] [EOL] [EOL] def process_template ( content ) : [EOL] env = SandboxedEnvironment ( ) [EOL] template = env . from_string ( content ) [EOL] context = { [string] : current_user_id , [string] : current_username , } [EOL] return template . render ( context ) [EOL] [EOL] [EOL] class TagView ( BaseSupersetView ) : [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] ] ) def suggestions ( self ) : [EOL] query = ( db . session . query ( TaggedObject ) . join ( Tag ) . with_entities ( TaggedObject . tag_id , Tag . name ) . group_by ( TaggedObject . tag_id , Tag . name ) . order_by ( func . count ( ) . desc ( ) ) . all ( ) ) [EOL] tags = [ { [string] : id , [string] : name } for id , name in query ] [EOL] return json_success ( json . dumps ( tags ) ) [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] ] ) def get ( self , object_type , object_id ) : [EOL] [docstring] [EOL] if object_id == [number] : [EOL] return json_success ( json . dumps ( [ ] ) ) [EOL] [EOL] query = db . session . query ( TaggedObject ) . filter ( and_ ( TaggedObject . object_type == object_type , TaggedObject . object_id == object_id ) ) [EOL] tags = [ { [string] : obj . tag . id , [string] : obj . tag . name } for obj in query ] [EOL] return json_success ( json . dumps ( tags ) ) [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] ] ) def post ( self , object_type , object_id ) : [EOL] [docstring] [EOL] if object_id == [number] : [EOL] return Response ( status = [number] ) [EOL] [EOL] tagged_objects = [ ] [EOL] for name in request . get_json ( force = True ) : [EOL] if [string] in name : [EOL] type_name = name . split ( [string] , [number] ) [ [number] ] [EOL] type_ = TagTypes [ type_name ] [EOL] else : [EOL] type_ = TagTypes . custom [EOL] [EOL] tag = db . session . query ( Tag ) . filter_by ( name = name , type = type_ ) . first ( ) [EOL] if not tag : [EOL] tag = Tag ( name = name , type = type_ ) [EOL] [EOL] tagged_objects . append ( TaggedObject ( object_id = object_id , object_type = object_type , tag = tag , ) , ) [EOL] [EOL] db . session . add_all ( tagged_objects ) [EOL] db . session . commit ( ) [EOL] [EOL] return Response ( status = [number] ) [comment] [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] ] ) def delete ( self , object_type , object_id ) : [EOL] [docstring] [EOL] tag_names = request . get_json ( force = True ) [EOL] if not tag_names : [EOL] return Response ( status = [number] ) [EOL] [EOL] db . session . query ( TaggedObject ) . filter ( and_ ( TaggedObject . object_type == object_type , TaggedObject . object_id == object_id ) , TaggedObject . tag . has ( Tag . name . in_ ( tag_names ) ) , ) . delete ( synchronize_session = False ) [EOL] db . session . commit ( ) [EOL] [EOL] return Response ( status = [number] ) [comment] [EOL] [EOL] @ has_access_api @ expose ( [string] , methods = [ [string] , [string] ] ) def tagged_objects ( self ) : [EOL] tags = [ process_template ( tag ) for tag in request . args . get ( [string] , [string] ) . split ( [string] ) if tag ] [EOL] if not tags : [EOL] return json_success ( json . dumps ( [ ] ) ) [EOL] [EOL] [comment] [EOL] types = [ type_ for type_ in request . args . get ( [string] , [string] ) . split ( [string] ) if type_ ] [EOL] [EOL] results = [ ] [EOL] [EOL] [comment] [EOL] if not types or [string] in types : [EOL] dashboards = ( db . session . query ( Dashboard ) . join ( TaggedObject , and_ ( TaggedObject . object_id == Dashboard . id , TaggedObject . object_type == ObjectTypes . dashboard , ) , ) . join ( Tag , TaggedObject . tag_id == Tag . id ) . filter ( Tag . name . in_ ( tags ) ) ) [EOL] results . extend ( { [string] : obj . id , [string] : ObjectTypes . dashboard . name , [string] : obj . dashboard_title , [string] : obj . url , [string] : obj . changed_on , [string] : obj . created_by_fk , [string] : obj . creator ( ) , } for obj in dashboards ) [EOL] [EOL] [comment] [EOL] if not types or [string] in types : [EOL] charts = ( db . session . query ( Slice ) . join ( TaggedObject , and_ ( TaggedObject . object_id == Slice . id , TaggedObject . object_type == ObjectTypes . chart , ) , ) . join ( Tag , TaggedObject . tag_id == Tag . id ) . filter ( Tag . name . in_ ( tags ) ) ) [EOL] results . extend ( { [string] : obj . id , [string] : ObjectTypes . chart . name , [string] : obj . slice_name , [string] : obj . url , [string] : obj . changed_on , [string] : obj . created_by_fk , [string] : obj . creator ( ) , } for obj in charts ) [EOL] [EOL] [comment] [EOL] if not types or [string] in types : [EOL] saved_queries = ( db . session . query ( SavedQuery ) . join ( TaggedObject , and_ ( TaggedObject . object_id == SavedQuery . id , TaggedObject . object_type == ObjectTypes . query , ) , ) . join ( Tag , TaggedObject . tag_id == Tag . id ) . filter ( Tag . name . in_ ( tags ) ) ) [EOL] results . extend ( { [string] : obj . id , [string] : ObjectTypes . query . name , [string] : obj . label , [string] : obj . url ( ) , [string] : obj . changed_on , [string] : obj . created_by_fk , [string] : obj . creator ( ) , } for obj in saved_queries ) [EOL] [EOL] return json_success ( json . dumps ( results , default = utils . core . json_int_dttm_ser ) ) [EOL] [EOL] [EOL] app . url_map . converters [ [string] ] = ObjectTypeConverter [EOL] appbuilder . add_view_no_menu ( TagView ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Type [EOL] import typing [EOL] import superset [EOL] from superset import appbuilder [EOL] [EOL] from flask_appbuilder . models . sqla . interface import SQLAInterface [EOL] import superset . models . core as models [EOL] from . base import ( SupersetModelView , YamlExportMixin , ) [EOL] [EOL] class DashpositionView ( SupersetModelView , YamlExportMixin ) : [comment] [EOL] datamodel = SQLAInterface ( models . Dashboard ) [EOL] list_columns = [ [string] , [string] , [string] ] [EOL] show_columns = edit_columns = add_columns = list_columns [EOL] [EOL] appbuilder . add_view_no_menu ( DashpositionView ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[superset.views.addition.DashpositionView]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] [EOL] import pandas as pd [EOL] import polyline [EOL] from sqlalchemy import String , Text [EOL] [EOL] from superset import db [EOL] from superset . utils . core import get_or_create_main_db [EOL] from . helpers import TBL , get_example_data [EOL] [EOL] [EOL] def load_bart_lines ( ) : [EOL] tbl_name = [string] [EOL] content = get_example_data ( [string] ) [EOL] df = pd . read_json ( content , encoding = [string] ) [EOL] df [ [string] ] = df . path . map ( json . dumps ) [EOL] df [ [string] ] = df . path . map ( polyline . encode ) [EOL] del df [ [string] ] [EOL] [EOL] df . to_sql ( tbl_name , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : Text , [string] : Text , } , index = False ) [EOL] print ( [string] . format ( tbl_name ) ) [EOL] tbl = db . session . query ( TBL ) . filter_by ( table_name = tbl_name ) . first ( ) [EOL] if not tbl : [EOL] tbl = TBL ( table_name = tbl_name ) [EOL] tbl . description = [string] [EOL] tbl . database = get_or_create_main_db ( ) [EOL] db . session . merge ( tbl ) [EOL] db . session . commit ( ) [EOL] tbl . fetch_metadata ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Dict , Union , Any [EOL] import typing [EOL] import datetime [EOL] [EOL] import pandas as pd [EOL] from sqlalchemy import BigInteger , Date , String [EOL] [EOL] from superset import db [EOL] from superset . connectors . sqla . models import SqlMetric [EOL] from superset . utils import core as utils [EOL] from . helpers import ( get_example_data , get_slice_json , merge_slice , misc_dash_slices , Slice , TBL , ) [EOL] [EOL] [EOL] def load_country_map_data ( ) : [EOL] [docstring] [EOL] csv_bytes = get_example_data ( [string] , is_gzip = False , make_bytes = True ) [EOL] data = pd . read_csv ( csv_bytes , encoding = [string] ) [EOL] data [ [string] ] = datetime . datetime . now ( ) . date ( ) [EOL] data . to_sql ( [string] , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : String ( [number] ) , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : BigInteger , [string] : Date ( ) , } , index = False ) [EOL] print ( [string] ) [EOL] print ( [string] * [number] ) [EOL] print ( [string] ) [EOL] obj = db . session . query ( TBL ) . filter_by ( table_name = [string] ) . first ( ) [EOL] if not obj : [EOL] obj = TBL ( table_name = [string] ) [EOL] obj . main_dttm_col = [string] [EOL] obj . database = utils . get_or_create_main_db ( ) [EOL] if not any ( col . metric_name == [string] for col in obj . metrics ) : [EOL] obj . metrics . append ( SqlMetric ( metric_name = [string] , expression = [string] , ) ) [EOL] db . session . merge ( obj ) [EOL] db . session . commit ( ) [EOL] obj . fetch_metadata ( ) [EOL] tbl = obj [EOL] [EOL] slice_data = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [number] , } [EOL] [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] misc_dash_slices . add ( slc . slice_name ) [EOL] merge_slice ( slc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] [EOL] import pandas as pd [EOL] from sqlalchemy import String , Text [EOL] [EOL] from superset import db [EOL] from superset . utils import core as utils [EOL] from . helpers import TBL , get_example_data [EOL] [EOL] [EOL] def load_paris_iris_geojson ( ) : [EOL] tbl_name = [string] [EOL] [EOL] data = get_example_data ( [string] ) [EOL] df = pd . read_json ( data ) [EOL] df [ [string] ] = df . features . map ( json . dumps ) [EOL] [EOL] df . to_sql ( tbl_name , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : Text , [string] : Text , } , index = False ) [EOL] print ( [string] . format ( tbl_name ) ) [EOL] tbl = db . session . query ( TBL ) . filter_by ( table_name = tbl_name ) . first ( ) [EOL] if not tbl : [EOL] tbl = TBL ( table_name = tbl_name ) [EOL] tbl . description = [string] [EOL] tbl . database = utils . get_or_create_main_db ( ) [EOL] db . session . merge ( tbl ) [EOL] db . session . commit ( ) [EOL] tbl . fetch_metadata ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import datetime [EOL] import json [EOL] import random [EOL] [EOL] import pandas as pd [EOL] from sqlalchemy import Date , Float , String [EOL] [EOL] from superset import db [EOL] from superset . utils import core as utils [EOL] from . helpers import ( config , Dash , get_example_data , get_slice_json , merge_slice , Slice , TBL , update_slice_ids , ) [EOL] [EOL] [EOL] def load_unicode_test_data ( ) : [EOL] [docstring] [EOL] data = get_example_data ( [string] , is_gzip = False , make_bytes = True ) [EOL] df = pd . read_csv ( data , encoding = [string] ) [EOL] [comment] [EOL] df [ [string] ] = datetime . datetime . now ( ) . date ( ) [EOL] df [ [string] ] = [ random . randint ( [number] , [number] ) for _ in range ( len ( df ) ) ] [EOL] df . to_sql ( [string] , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : Date ( ) , [string] : Float ( ) , } , index = False ) [EOL] print ( [string] ) [EOL] print ( [string] * [number] ) [EOL] [EOL] print ( [string] ) [EOL] obj = db . session . query ( TBL ) . filter_by ( table_name = [string] ) . first ( ) [EOL] if not obj : [EOL] obj = TBL ( table_name = [string] ) [EOL] obj . main_dttm_col = [string] [EOL] obj . database = utils . get_or_create_main_db ( ) [EOL] db . session . merge ( obj ) [EOL] db . session . commit ( ) [EOL] obj . fetch_metadata ( ) [EOL] tbl = obj [EOL] [EOL] slice_data = { [string] : [string] , [string] : [ ] , [string] : [string] , [string] : config . get ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL] [EOL] print ( [string] ) [EOL] dash = ( db . session . query ( Dash ) . filter_by ( dashboard_title = [string] ) . first ( ) ) [EOL] [EOL] if not dash : [EOL] dash = Dash ( ) [EOL] js = [string] [EOL] dash . dashboard_title = [string] [EOL] pos = json . loads ( js ) [EOL] update_slice_ids ( pos , [ slc ] ) [EOL] dash . position_json = json . dumps ( pos , indent = [number] ) [EOL] dash . slug = [string] [EOL] dash . slices = [ slc ] [EOL] db . session . merge ( dash ) [EOL] db . session . commit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import pandas as pd [EOL] from sqlalchemy import DateTime [EOL] [EOL] from superset import db [EOL] from superset . utils import core as utils [EOL] from . helpers import ( config , get_example_data , get_slice_json , merge_slice , Slice , TBL , ) [EOL] [EOL] [EOL] def load_random_time_series_data ( ) : [EOL] [docstring] [EOL] data = get_example_data ( [string] ) [EOL] pdf = pd . read_json ( data ) [EOL] pdf . ds = pd . to_datetime ( pdf . ds , unit = [string] ) [EOL] pdf . to_sql ( [string] , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : DateTime , } , index = False ) [EOL] print ( [string] ) [EOL] print ( [string] * [number] ) [EOL] [EOL] print ( [string] ) [EOL] obj = db . session . query ( TBL ) . filter_by ( table_name = [string] ) . first ( ) [EOL] if not obj : [EOL] obj = TBL ( table_name = [string] ) [EOL] obj . main_dttm_col = [string] [EOL] obj . database = utils . get_or_create_main_db ( ) [EOL] db . session . merge ( obj ) [EOL] db . session . commit ( ) [EOL] obj . fetch_metadata ( ) [EOL] tbl = obj [EOL] [EOL] slice_data = { [string] : [string] , [string] : config . get ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Set , Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import json [EOL] import os [EOL] import textwrap [EOL] [EOL] import pandas as pd [EOL] from sqlalchemy import DateTime , String [EOL] [EOL] from superset import db [EOL] from superset . connectors . sqla . models import SqlMetric [EOL] from superset . utils import core as utils [EOL] from . helpers import ( config , Dash , DATA_FOLDER , get_example_data , get_slice_json , merge_slice , misc_dash_slices , Slice , TBL , update_slice_ids , ) [EOL] [EOL] [EOL] def load_tabbed_dashboard ( ) : [EOL] [docstring] [EOL] [EOL] print ( [string] ) [EOL] slug = [string] [EOL] dash = db . session . query ( Dash ) . filter_by ( slug = slug ) . first ( ) [EOL] [EOL] if not dash : [EOL] dash = Dash ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] tabbed_dash_slices = set ( ) [EOL] tabbed_dash_slices . add ( [string] ) [EOL] tabbed_dash_slices . add ( [string] ) [EOL] tabbed_dash_slices . add ( [string] ) [EOL] tabbed_dash_slices . add ( [string] ) [EOL] [EOL] js = textwrap . dedent ( [string] ) [EOL] pos = json . loads ( js ) [EOL] slices = [ db . session . query ( Slice ) . filter_by ( slice_name = name ) . first ( ) for name in tabbed_dash_slices ] [EOL] [EOL] slices = sorted ( slices , key = lambda x : x . id ) [EOL] update_slice_ids ( pos , slices ) [EOL] dash . position_json = json . dumps ( pos , indent = [number] ) [EOL] dash . slices = slices [EOL] dash . dashboard_title = [string] [EOL] dash . slug = slug [EOL] [EOL] db . session . merge ( dash ) [EOL] db . session . commit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Dict , Union , Any [EOL] import typing [EOL] import json [EOL] [EOL] from superset import db [EOL] from . helpers import ( Dash , get_slice_json , merge_slice , Slice , TBL , update_slice_ids , ) [EOL] [EOL] COLOR_RED = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] POSITION_JSON = [string] [EOL] [EOL] [EOL] def load_deck_dash ( ) : [EOL] print ( [string] ) [EOL] slices = [ ] [EOL] tbl = db . session . query ( TBL ) . filter_by ( table_name = [string] ) . first ( ) [EOL] slice_data = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : COLOR_RED , [string] : [string] , [string] : [ ] , [string] : None , [string] : [ ] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : { [string] : [string] , [string] : [string] } , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : None , [string] : { [string] : - [number] , [string] : [number] , [string] : - [number] , [string] : [number] , [string] : [number] , } , [string] : [string] , [string] : [string] , } [EOL] [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL] slices . append ( slc ) [EOL] [EOL] slice_data = { [string] : [string] , [string] : [ ] , [string] : [number] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : [number] , [string] : [string] , [string] : [string] , [string] : { [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [string] , [string] : [number] } , [string] : [string] , [string] : None , [string] : [ ] , } [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL] slices . append ( slc ) [EOL] [EOL] slice_data = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [ ] , [string] : [number] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : [number] , [string] : True , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : - [number] , [string] : - [number] , } , [string] : [string] , [string] : { [string] : [string] , [string] : [number] } , [string] : [string] , [string] : None , [string] : [ ] , } [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL] slices . append ( slc ) [EOL] [EOL] slice_data = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [ ] , [string] : [number] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : [number] , [string] : True , [string] : [string] , [string] : { [string] : - [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : [string] , [string] : { [string] : [string] , [string] : [number] } , [string] : [string] , [string] : None , [string] : [ ] , } [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL] slices . append ( slc ) [EOL] [EOL] polygon_tbl = db . session . query ( TBL ) . filter_by ( table_name = [string] ) . first ( ) [EOL] slice_data = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : { [string] : - [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : - [number] , } , [string] : False , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : True , [string] : False , [string] : True , [string] : [number] , [string] : [ [string] , [string] , ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , } [EOL] [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = polygon_tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL] slices . append ( slc ) [EOL] [EOL] slice_data = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : None , [string] : None , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [number] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : - [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : - [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , } [EOL] [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = db . session . query ( TBL ) . filter_by ( table_name = [string] ) . first ( ) . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL] slices . append ( slc ) [EOL] [EOL] slice_data = { [string] : [string] , [string] : [number] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : { [string] : - [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : - [number] , } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : [number] , [string] : False , [string] : [ [string] , ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , } [EOL] [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = db . session . query ( TBL ) . filter_by ( table_name = [string] ) . first ( ) . id , params = get_slice_json ( slice_data ) , ) [EOL] merge_slice ( slc ) [EOL] slices . append ( slc ) [EOL] slug = [string] [EOL] [EOL] print ( [string] ) [EOL] title = [string] [EOL] dash = db . session . query ( Dash ) . filter_by ( slug = slug ) . first ( ) [EOL] [EOL] if not dash : [EOL] dash = Dash ( ) [EOL] js = POSITION_JSON [EOL] pos = json . loads ( js ) [EOL] update_slice_ids ( pos , slices ) [EOL] dash . position_json = json . dumps ( pos , indent = [number] ) [EOL] dash . dashboard_title = title [EOL] dash . slug = slug [EOL] dash . slices = slices [EOL] db . session . merge ( dash ) [EOL] db . session . commit ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] load_deck_dash ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Dict , Union , Any [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import random [EOL] [EOL] import geohash [EOL] import pandas as pd [EOL] from sqlalchemy import DateTime , Float , String [EOL] [EOL] from superset import db [EOL] from superset . utils import core as utils [EOL] from . helpers import ( get_example_data , get_slice_json , merge_slice , misc_dash_slices , Slice , TBL , ) [EOL] [EOL] [EOL] def load_long_lat_data ( ) : [EOL] [docstring] [EOL] data = get_example_data ( [string] , make_bytes = True ) [EOL] pdf = pd . read_csv ( data , encoding = [string] ) [EOL] start = datetime . datetime . now ( ) . replace ( hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] pdf [ [string] ] = [ start + datetime . timedelta ( hours = i * [number] / ( len ( pdf ) - [number] ) ) for i in range ( len ( pdf ) ) ] [EOL] pdf [ [string] ] = [ random . randint ( [number] , [number] ) for _ in range ( len ( pdf ) ) ] [EOL] pdf [ [string] ] = [ random . uniform ( [number] , [number] ) for _ in range ( len ( pdf ) ) ] [EOL] pdf [ [string] ] = pdf [ [ [string] , [string] ] ] . apply ( lambda x : geohash . encode ( * x ) , axis = [number] ) [EOL] pdf [ [string] ] = pdf [ [string] ] . map ( str ) . str . cat ( pdf [ [string] ] . map ( str ) , sep = [string] ) [EOL] pdf . to_sql ( [string] , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : Float ( ) , [string] : Float ( ) , [string] : Float ( ) , [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : Float ( ) , [string] : String ( [number] ) , [string] : DateTime ( ) , [string] : Float ( ) , [string] : Float ( ) , [string] : String ( [number] ) , [string] : String ( [number] ) , } , index = False ) [EOL] print ( [string] ) [EOL] print ( [string] * [number] ) [EOL] [EOL] print ( [string] ) [EOL] obj = db . session . query ( TBL ) . filter_by ( table_name = [string] ) . first ( ) [EOL] if not obj : [EOL] obj = TBL ( table_name = [string] ) [EOL] obj . main_dttm_col = [string] [EOL] obj . database = utils . get_or_create_main_db ( ) [EOL] db . session . merge ( obj ) [EOL] db . session . commit ( ) [EOL] obj . fetch_metadata ( ) [EOL] tbl = obj [EOL] [EOL] slice_data = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : [number] , } [EOL] [EOL] print ( [string] ) [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = get_slice_json ( slice_data ) , ) [EOL] misc_dash_slices . add ( slc . slice_name ) [EOL] merge_slice ( slc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import textwrap [EOL] [EOL] import pandas as pd [EOL] from sqlalchemy import Float , String [EOL] [EOL] from superset import db [EOL] from superset . connectors . sqla . models import SqlMetric [EOL] from superset . utils import core as utils [EOL] from . helpers import ( DATA_FOLDER , get_example_data , merge_slice , misc_dash_slices , Slice , TBL , ) [EOL] [EOL] [EOL] def load_energy ( ) : [EOL] [comment] [EOL] [docstring] [EOL] tbl_name = [string] [EOL] data = get_example_data ( [string] ) [EOL] pdf = pd . read_json ( data ) [EOL] pdf . to_sql ( tbl_name , db . engine , if_exists = [string] , chunksize = [number] , dtype = { [string] : String ( [number] ) , [string] : String ( [number] ) , [string] : Float ( ) , } , index = False ) [EOL] [EOL] print ( [string] ) [EOL] tbl = db . qusession . ery ( TBL ) . filter_by ( table_name = tbl_name ) . first ( ) [EOL] if not tbl : [EOL] tbl = TBL ( table_name = tbl_name ) [EOL] tbl . description = [string] [EOL] tbl . database = utils . get_or_create_main_db ( ) [EOL] [EOL] if not any ( col . metric_name == [string] for col in tbl . metrics ) : [EOL] tbl . metrics . append ( SqlMetric ( metric_name = [string] , expression = [string] , ) ) [EOL] [EOL] db . session . merge ( tbl ) [EOL] db . session . commit ( ) [EOL] tbl . fetch_metadata ( ) [EOL] [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = textwrap . dedent ( [string] ) , ) [EOL] misc_dash_slices . add ( slc . slice_name ) [EOL] merge_slice ( slc ) [EOL] [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = textwrap . dedent ( [string] ) , ) [EOL] misc_dash_slices . add ( slc . slice_name ) [EOL] merge_slice ( slc ) [EOL] [EOL] slc = Slice ( slice_name = [string] , viz_type = [string] , datasource_type = [string] , datasource_id = tbl . id , params = textwrap . dedent ( [string] ) , ) [EOL] misc_dash_slices . add ( slc . slice_name ) [EOL] merge_slice ( slc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import builtins [EOL] from flask import request [EOL] [EOL] from superset import tables_cache [EOL] [EOL] [EOL] def view_cache_key ( * unused_args , ** unused_kwargs ) : [EOL] [comment] [EOL] args_hash = hash ( frozenset ( request . args . items ( ) ) ) [EOL] return [string] . format ( request . path , args_hash ) [EOL] [EOL] [EOL] def memoized_func ( key = view_cache_key , attribute_in_key = None ) : [EOL] [comment] [EOL] [docstring] [EOL] def wrap ( f ) : [EOL] if tables_cache : [EOL] def wrapped_f ( self , * args , ** kwargs ) : [EOL] if not kwargs . get ( [string] , True ) : [EOL] return f ( self , * args , ** kwargs ) [EOL] [EOL] if attribute_in_key : [EOL] cache_key = key ( * args , ** kwargs ) . format ( getattr ( self , attribute_in_key ) ) [EOL] else : [EOL] cache_key = key ( * args , ** kwargs ) [EOL] o = tables_cache . get ( cache_key ) [EOL] if not kwargs . get ( [string] ) and o is not None : [EOL] return o [EOL] o = f ( self , * args , ** kwargs ) [EOL] tables_cache . set ( cache_key , o , timeout = kwargs . get ( [string] ) ) [EOL] return o [EOL] else : [EOL] [comment] [EOL] def wrapped_f ( self , * args , ** kwargs ) : [EOL] return f ( self , * args , ** kwargs ) [EOL] return wrapped_f [EOL] return wrap [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Dict , Any [EOL] import typing [EOL] from datetime import datetime , timedelta [EOL] from functools import wraps [EOL] import logging [EOL] [EOL] from contextlib2 import contextmanager [EOL] from flask import request [EOL] [EOL] from superset import app , cache [EOL] from superset . utils . dates import now_as_float [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] FAR_FUTURE = [number] * [number] * [number] * [number] [comment] [EOL] [EOL] [comment] [EOL] @ contextmanager def stats_timing ( stats_key , stats_logger ) : [EOL] [comment] [EOL] [docstring] [EOL] start_ts = now_as_float ( ) [EOL] try : [EOL] yield start_ts [EOL] except Exception as e : [EOL] raise e [EOL] finally : [EOL] stats_logger . timing ( stats_key , now_as_float ( ) - start_ts ) [EOL] [EOL] [comment] [EOL] def etag_cache ( max_age , check_perms = bool ) : [EOL] [docstring] [EOL] def decorator ( f ) : [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] [comment] [EOL] check_perms ( * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if request . method == [string] : [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] response = None [EOL] if cache : [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] key_args = list ( args ) [EOL] key_kwargs = kwargs . copy ( ) [EOL] key_kwargs . update ( request . args ) [EOL] cache_key = wrapper . make_cache_key ( f , * key_args , ** key_kwargs ) [EOL] response = cache . get ( cache_key ) [EOL] except Exception : [comment] [EOL] if app . debug : [EOL] raise [EOL] logging . exception ( [string] ) [EOL] [EOL] [comment] [EOL] if response is None : [EOL] response = f ( * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] response . cache_control . public = True [EOL] response . last_modified = datetime . utcnow ( ) [EOL] expiration = max_age if max_age != [number] else FAR_FUTURE [EOL] response . expires = response . last_modified + timedelta ( seconds = expiration ) [EOL] response . add_etag ( ) [EOL] [EOL] [comment] [EOL] if cache : [EOL] try : [EOL] cache . set ( cache_key , response , timeout = max_age ) [EOL] except Exception : [comment] [EOL] if app . debug : [EOL] raise [EOL] logging . exception ( [string] ) [EOL] [EOL] return response . make_conditional ( request ) [EOL] [EOL] if cache : [EOL] wrapper . uncached = f [EOL] wrapper . cache_timeout = max_age [EOL] wrapper . make_cache_key = cache . _memoize_make_cache_key ( make_name = None , timeout = max_age ) [EOL] [EOL] return wrapper [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] from superset . connectors . sqla . models import TableColumn [EOL] from superset . db_engine_specs import DruidEngineSpec [EOL] from . base_tests import SupersetTestCase [EOL] [EOL] [EOL] class DatabaseModelTestCase ( SupersetTestCase ) : [EOL] [EOL] def test_is_time_druid_time_col ( self ) : [EOL] [docstring] [EOL] col = TableColumn ( column_name = [string] , type = [string] ) [EOL] self . assertEquals ( col . is_dttm , None ) [EOL] DruidEngineSpec . alter_new_orm_column ( col ) [EOL] self . assertEquals ( col . is_dttm , True ) [EOL] [EOL] col = TableColumn ( column_name = [string] , type = [string] ) [EOL] self . assertEquals ( col . is_time , False ) [EOL] [EOL] def test_is_time_by_type ( self ) : [EOL] col = TableColumn ( column_name = [string] , type = [string] ) [EOL] self . assertEquals ( col . is_time , True ) [EOL] [EOL] col = TableColumn ( column_name = [string] , type = [string] ) [EOL] self . assertEquals ( col . is_time , True ) [EOL] [EOL] col = TableColumn ( column_name = [string] , type = [string] ) [EOL] self . assertEquals ( col . is_time , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Tuple , Literal , Any , List , Type , Set , Dict [EOL] import unittest [EOL] import typing [EOL] import superset [EOL] import typing_extensions [EOL] import inspect [EOL] from unittest import mock [EOL] [EOL] from sqlalchemy import column , select , table [EOL] from sqlalchemy . dialects . mssql import pymssql [EOL] from sqlalchemy . engine . result import RowProxy [EOL] from sqlalchemy . types import String , UnicodeText [EOL] [EOL] from superset import db_engine_specs [EOL] from superset . db_engine_specs import ( BaseEngineSpec , BQEngineSpec , HiveEngineSpec , MssqlEngineSpec , MySQLEngineSpec , OracleEngineSpec , PrestoEngineSpec , ) [EOL] from superset . models . core import Database [EOL] from . base_tests import SupersetTestCase [EOL] [EOL] [EOL] class DbEngineSpecsTestCase ( SupersetTestCase ) : [EOL] def test_0_progress ( self ) : [EOL] log = [string] . split ( [string] ) [comment] [EOL] self . assertEquals ( [number] , HiveEngineSpec . progress ( log ) ) [EOL] [EOL] def test_number_of_jobs_progress ( self ) : [EOL] log = [string] . split ( [string] ) [EOL] self . assertEquals ( [number] , HiveEngineSpec . progress ( log ) ) [EOL] [EOL] def test_job_1_launched_progress ( self ) : [EOL] log = [string] . split ( [string] ) [EOL] self . assertEquals ( [number] , HiveEngineSpec . progress ( log ) ) [EOL] [EOL] def test_job_1_launched_stage_1_0_progress ( self ) : [EOL] log = [string] . split ( [string] ) [comment] [EOL] self . assertEquals ( [number] , HiveEngineSpec . progress ( log ) ) [EOL] [EOL] def test_job_1_launched_stage_1_map_40_progress ( self ) : [EOL] log = [string] . split ( [string] ) [comment] [EOL] self . assertEquals ( [number] , HiveEngineSpec . progress ( log ) ) [EOL] [EOL] def test_job_1_launched_stage_1_map_80_reduce_40_progress ( self ) : [EOL] log = [string] . split ( [string] ) [comment] [EOL] self . assertEquals ( [number] , HiveEngineSpec . progress ( log ) ) [EOL] [EOL] def test_job_1_launched_stage_2_stages_progress ( self ) : [EOL] log = [string] . split ( [string] ) [comment] [EOL] self . assertEquals ( [number] , HiveEngineSpec . progress ( log ) ) [EOL] [EOL] def test_job_2_launched_stage_2_stages_progress ( self ) : [EOL] log = [string] . split ( [string] ) [comment] [EOL] self . assertEquals ( [number] , HiveEngineSpec . progress ( log ) ) [EOL] [EOL] def test_hive_error_msg ( self ) : [EOL] msg = ( [string] [string] [string] [string] ) [EOL] self . assertEquals ( ( [string] [string] [string] ) , HiveEngineSpec . extract_error_message ( Exception ( msg ) ) ) [EOL] [EOL] e = Exception ( [string] ) [EOL] self . assertEquals ( str ( e ) , HiveEngineSpec . extract_error_message ( e ) ) [EOL] [EOL] msg = ( [string] [string] [string] ) [EOL] self . assertEquals ( ( [string] ) , HiveEngineSpec . extract_error_message ( Exception ( msg ) ) ) [EOL] [EOL] def get_generic_database ( self ) : [EOL] return Database ( sqlalchemy_uri = [string] ) [EOL] [EOL] def sql_limit_regex ( self , sql , expected_sql , engine_spec_class = MySQLEngineSpec , limit = [number] ) : [EOL] main = self . get_generic_database ( ) [EOL] limited = engine_spec_class . apply_limit_to_sql ( sql , limit , main ) [EOL] self . assertEquals ( expected_sql , limited ) [EOL] [EOL] def test_extract_limit_from_query ( self , engine_spec_class = MySQLEngineSpec ) : [EOL] q0 = [string] [EOL] q1 = [string] [EOL] q2 = [string] [EOL] q3 = [string] [EOL] q4 = [string] [EOL] q5 = [string] [EOL] q6 = [string] [EOL] q7 = [string] [EOL] q8 = [string] [EOL] q9 = [string] [EOL] q10 = [string] [EOL] q11 = [string] [EOL] [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q0 ) , None ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q1 ) , [number] ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q2 ) , [number] ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q3 ) , None ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q4 ) , [number] ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q5 ) , [number] ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q6 ) , [number] ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q7 ) , None ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q8 ) , None ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q9 ) , None ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q10 ) , None ) [EOL] self . assertEqual ( engine_spec_class . get_limit_from_sql ( q11 ) , None ) [EOL] [EOL] def test_wrapped_query ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , MssqlEngineSpec , ) [EOL] [EOL] def test_wrapped_semi ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , MssqlEngineSpec , ) [EOL] [EOL] def test_wrapped_semi_tabs ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , MssqlEngineSpec , ) [EOL] [EOL] def test_simple_limit_query ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , ) [EOL] [EOL] def test_modify_limit_query ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , ) [EOL] [EOL] def test_limit_query_with_limit_subquery ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , ) [EOL] [EOL] def test_limit_with_expr ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , ) [EOL] [EOL] def test_limit_expr_and_semicolon ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , ) [EOL] [EOL] def test_get_datatype ( self ) : [EOL] self . assertEquals ( [string] , PrestoEngineSpec . get_datatype ( [string] ) ) [EOL] self . assertEquals ( [string] , MySQLEngineSpec . get_datatype ( [number] ) ) [EOL] self . assertEquals ( [string] , MySQLEngineSpec . get_datatype ( [number] ) ) [EOL] self . assertEquals ( [string] , BaseEngineSpec . get_datatype ( [string] ) ) [EOL] [EOL] def test_limit_with_implicit_offset ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , ) [EOL] [EOL] def test_limit_with_explicit_offset ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , ) [EOL] [EOL] def test_limit_with_non_token_limit ( self ) : [EOL] self . sql_limit_regex ( [string] , [string] , ) [EOL] [EOL] def test_time_grain_blacklist ( self ) : [EOL] blacklist = [ [string] ] [EOL] time_grains = { [string] : [string] , [string] : [string] , } [EOL] time_grain_functions = { [string] : [string] , [string] : [string] , } [EOL] time_grains = db_engine_specs . _create_time_grains_tuple ( time_grains , time_grain_functions , blacklist ) [EOL] self . assertEqual ( [number] , len ( time_grains ) ) [EOL] self . assertEqual ( [string] , time_grains [ [number] ] . duration ) [EOL] [EOL] def test_engine_time_grain_validity ( self ) : [EOL] time_grains = set ( db_engine_specs . builtin_time_grains . keys ( ) ) [EOL] [comment] [EOL] for cls_name , cls in inspect . getmembers ( db_engine_specs ) : [EOL] if inspect . isclass ( cls ) and issubclass ( cls , BaseEngineSpec ) \ [EOL] and cls is not BaseEngineSpec : [EOL] [comment] [EOL] self . assertGreater ( len ( cls . time_grain_functions ) , [number] ) [EOL] [comment] [EOL] defined_time_grains = { grain . duration for grain in cls . get_time_grains ( ) } [EOL] intersection = time_grains . intersection ( defined_time_grains ) [EOL] self . assertSetEqual ( defined_time_grains , intersection , cls_name ) [EOL] [EOL] def test_presto_get_view_names_return_empty_list ( self ) : [EOL] self . assertEquals ( [ ] , PrestoEngineSpec . get_view_names ( mock . ANY , mock . ANY ) ) [EOL] [EOL] def verify_presto_column ( self , column , expected_results ) : [EOL] inspector = mock . Mock ( ) [EOL] inspector . engine . dialect . identifier_preparer . quote_identifier = mock . Mock ( ) [EOL] keymap = { [string] : ( None , None , [number] ) , [string] : ( None , None , [number] ) , [string] : ( None , None , [number] ) } [EOL] row = RowProxy ( mock . Mock ( ) , column , [ None , None , None , None ] , keymap ) [EOL] inspector . bind . execute = mock . Mock ( return_value = [ row ] ) [EOL] results = PrestoEngineSpec . get_columns ( inspector , [string] , [string] ) [EOL] self . assertEqual ( len ( expected_results ) , len ( results ) ) [EOL] for expected_result , result in zip ( expected_results , results ) : [EOL] self . assertEqual ( expected_result [ [number] ] , result [ [string] ] ) [EOL] self . assertEqual ( expected_result [ [number] ] , str ( result [ [string] ] ) ) [EOL] [EOL] def test_presto_get_column ( self ) : [EOL] presto_column = ( [string] , [string] , [string] ) [EOL] expected_results = [ ( [string] , [string] ) ] [EOL] self . verify_presto_column ( presto_column , expected_results ) [EOL] [EOL] def test_presto_get_simple_row_column ( self ) : [EOL] presto_column = ( [string] , [string] , [string] ) [EOL] expected_results = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] self . verify_presto_column ( presto_column , expected_results ) [EOL] [EOL] def test_presto_get_simple_row_column_with_tricky_name ( self ) : [EOL] presto_column = ( [string] , [string] , [string] ) [EOL] expected_results = [ ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] self . verify_presto_column ( presto_column , expected_results ) [EOL] [EOL] def test_presto_get_simple_array_column ( self ) : [EOL] presto_column = ( [string] , [string] , [string] ) [EOL] expected_results = [ ( [string] , [string] ) ] [EOL] self . verify_presto_column ( presto_column , expected_results ) [EOL] [EOL] def test_presto_get_row_within_array_within_row_column ( self ) : [EOL] presto_column = ( [string] , [string] , [string] ) [EOL] expected_results = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] self . verify_presto_column ( presto_column , expected_results ) [EOL] [EOL] def test_presto_get_array_within_row_within_array_column ( self ) : [EOL] presto_column = ( [string] , [string] , [string] ) [EOL] expected_results = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] self . verify_presto_column ( presto_column , expected_results ) [EOL] [EOL] def test_presto_get_fields ( self ) : [EOL] cols = [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] [EOL] actual_results = PrestoEngineSpec . _get_fields ( cols ) [EOL] expected_results = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] for actual_result , expected_result in zip ( actual_results , expected_results ) : [EOL] self . assertEqual ( actual_result . element . name , expected_result [ [string] ] ) [EOL] self . assertEqual ( actual_result . name , expected_result [ [string] ] ) [EOL] [EOL] def test_presto_filter_presto_cols ( self ) : [EOL] cols = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] actual_results = PrestoEngineSpec . _filter_presto_cols ( cols ) [EOL] expected_results = [ cols [ [number] ] ] [EOL] self . assertEqual ( actual_results , expected_results ) [EOL] [EOL] def test_hive_get_view_names_return_empty_list ( self ) : [EOL] self . assertEquals ( [ ] , HiveEngineSpec . get_view_names ( mock . ANY , mock . ANY ) ) [EOL] [EOL] def test_bigquery_sqla_column_label ( self ) : [EOL] label = BQEngineSpec . make_label_compatible ( column ( [string] ) . name ) [EOL] label_expected = [string] [EOL] self . assertEqual ( label , label_expected ) [EOL] [EOL] label = BQEngineSpec . make_label_compatible ( column ( [string] ) . name ) [EOL] label_expected = [string] [EOL] self . assertEqual ( label , label_expected ) [EOL] [EOL] label = BQEngineSpec . make_label_compatible ( column ( [string] ) . name ) [EOL] label_expected = [string] [EOL] self . assertEqual ( label , label_expected ) [EOL] [EOL] label = BQEngineSpec . make_label_compatible ( column ( [string] ) . name ) [EOL] label_expected = [string] [EOL] self . assertEqual ( label , label_expected ) [EOL] [EOL] def test_oracle_sqla_column_name_length_exceeded ( self ) : [EOL] col = column ( [string] ) [EOL] label = OracleEngineSpec . make_label_compatible ( col . name ) [EOL] self . assertEqual ( label . quote , True ) [EOL] label_expected = [string] [EOL] self . assertEqual ( label , label_expected ) [EOL] [EOL] def test_mssql_column_types ( self ) : [EOL] def assert_type ( type_string , type_expected ) : [EOL] type_assigned = MssqlEngineSpec . get_sqla_column_type ( type_string ) [EOL] if type_expected is None : [EOL] self . assertIsNone ( type_assigned ) [EOL] else : [EOL] self . assertIsInstance ( type_assigned , type_expected ) [EOL] [EOL] assert_type ( [string] , None ) [EOL] assert_type ( [string] , String ) [EOL] assert_type ( [string] , String ) [EOL] assert_type ( [string] , String ) [EOL] assert_type ( [string] , String ) [EOL] assert_type ( [string] , UnicodeText ) [EOL] assert_type ( [string] , UnicodeText ) [EOL] assert_type ( [string] , UnicodeText ) [EOL] [EOL] def test_mssql_where_clause_n_prefix ( self ) : [EOL] dialect = pymssql . dialect ( ) [EOL] spec = MssqlEngineSpec [EOL] str_col = column ( [string] , type_ = spec . get_sqla_column_type ( [string] ) ) [EOL] unicode_col = column ( [string] , type_ = spec . get_sqla_column_type ( [string] ) ) [EOL] tbl = table ( [string] ) [EOL] sel = select ( [ str_col , unicode_col ] ) . select_from ( tbl ) . where ( str_col == [string] ) . where ( unicode_col == [string] ) [EOL] [EOL] query = str ( sel . compile ( dialect = dialect , compile_kwargs = { [string] : True } ) ) [EOL] query_expected = [string] [comment] [EOL] self . assertEqual ( query , query_expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.set$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.set$ 0 0 0 0 0 0 $typing.set$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[None,None,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[None,None,builtins.int]]$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Type[superset.db_engine_specs.MssqlEngineSpec]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Type[superset.db_engine_specs.MssqlEngineSpec]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Type[superset.db_engine_specs.MssqlEngineSpec]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Dict , Union , Any [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] from unittest . mock import MagicMock [EOL] [EOL] from superset import db [EOL] from superset . models . core import Log [EOL] from superset . models . tags import ( get_tag , ObjectTypes , TaggedObject , TagTypes , ) [EOL] from superset . tasks . cache import ( DashboardTagsStrategy , DummyStrategy , get_form_data , TopNDashboardsStrategy , ) [EOL] from . base_tests import SupersetTestCase [EOL] [EOL] [EOL] TEST_URL = [string] [EOL] [EOL] [EOL] class CacheWarmUpTests ( SupersetTestCase ) : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( CacheWarmUpTests , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def test_get_form_data_chart_only ( self ) : [EOL] chart_id = [number] [EOL] result = get_form_data ( chart_id , None ) [EOL] expected = { [string] : chart_id } [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_get_form_data_no_dashboard_metadata ( self ) : [EOL] chart_id = [number] [EOL] dashboard = MagicMock ( ) [EOL] dashboard . json_metadata = None [EOL] result = get_form_data ( chart_id , dashboard ) [EOL] expected = { [string] : chart_id } [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_get_form_data_immune_slice ( self ) : [EOL] chart_id = [number] [EOL] filter_box_id = [number] [EOL] dashboard = MagicMock ( ) [EOL] dashboard . json_metadata = json . dumps ( { [string] : [ chart_id ] , [string] : json . dumps ( { str ( filter_box_id ) : { [string] : [ [string] , [string] ] } , } ) , } ) [EOL] result = get_form_data ( chart_id , dashboard ) [EOL] expected = { [string] : chart_id } [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_get_form_data_no_default_filters ( self ) : [EOL] chart_id = [number] [EOL] dashboard = MagicMock ( ) [EOL] dashboard . json_metadata = json . dumps ( { } ) [EOL] result = get_form_data ( chart_id , dashboard ) [EOL] expected = { [string] : chart_id } [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_get_form_data_immune_fields ( self ) : [EOL] chart_id = [number] [EOL] filter_box_id = [number] [EOL] dashboard = MagicMock ( ) [EOL] dashboard . json_metadata = json . dumps ( { [string] : json . dumps ( { str ( filter_box_id ) : { [string] : [ [string] , [string] ] , [string] : [string] , } , } ) , [string] : { chart_id : [ [string] ] } , } ) [EOL] result = get_form_data ( chart_id , dashboard ) [EOL] expected = { [string] : chart_id , [string] : [ { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , } , ] , } [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_get_form_data_no_extra_filters ( self ) : [EOL] chart_id = [number] [EOL] filter_box_id = [number] [EOL] dashboard = MagicMock ( ) [EOL] dashboard . json_metadata = json . dumps ( { [string] : json . dumps ( { str ( filter_box_id ) : { [string] : [string] , } , } ) , [string] : { chart_id : [ [string] ] } , } ) [EOL] result = get_form_data ( chart_id , dashboard ) [EOL] expected = { [string] : chart_id } [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_get_form_data ( self ) : [EOL] chart_id = [number] [EOL] filter_box_id = [number] [EOL] dashboard = MagicMock ( ) [EOL] dashboard . json_metadata = json . dumps ( { [string] : json . dumps ( { str ( filter_box_id ) : { [string] : [ [string] , [string] ] , [string] : [string] , } , } ) , } ) [EOL] result = get_form_data ( chart_id , dashboard ) [EOL] expected = { [string] : chart_id , [string] : [ { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , } , { [string] : [string] , [string] : [string] , [string] : [string] , } , ] , } [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_dummy_strategy ( self ) : [EOL] strategy = DummyStrategy ( ) [EOL] result = sorted ( strategy . get_urls ( ) ) [EOL] expected = [ f'{ TEST_URL } [string] ' , f'{ TEST_URL } [string] ' , f'{ TEST_URL } [string] ' , f'{ TEST_URL } [string] ' , f'{ TEST_URL } [string] ' , f'{ TEST_URL } [string] ' , f'{ TEST_URL } [string] ' , ] [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_top_n_dashboards_strategy ( self ) : [EOL] [comment] [EOL] db . session . query ( Log ) . delete ( ) [EOL] self . login ( username = [string] ) [EOL] for _ in range ( [number] ) : [EOL] self . client . get ( [string] ) [EOL] [EOL] strategy = TopNDashboardsStrategy ( [number] ) [EOL] result = sorted ( strategy . get_urls ( ) ) [EOL] expected = [ f'{ TEST_URL } [string] ' , ] [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_dashboard_tags ( self ) : [EOL] strategy = DashboardTagsStrategy ( [ [string] ] ) [EOL] [EOL] result = sorted ( strategy . get_urls ( ) ) [EOL] expected = [ ] [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] [comment] [EOL] tag1 = get_tag ( [string] , db . session , TagTypes . custom ) [EOL] object_id = [number] [EOL] tagged_object = TaggedObject ( tag_id = tag1 . id , object_id = object_id , object_type = ObjectTypes . dashboard , ) [EOL] db . session . add ( tagged_object ) [EOL] db . session . commit ( ) [EOL] [EOL] result = sorted ( strategy . get_urls ( ) ) [EOL] expected = [ f'{ TEST_URL } [string] ' , ] [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] strategy = DashboardTagsStrategy ( [ [string] ] ) [EOL] [EOL] result = sorted ( strategy . get_urls ( ) ) [EOL] expected = [ ] [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] [comment] [EOL] tag2 = get_tag ( [string] , db . session , TagTypes . custom ) [EOL] object_id = [number] [EOL] tagged_object = TaggedObject ( tag_id = tag2 . id , object_id = object_id , object_type = ObjectTypes . chart , ) [EOL] db . session . add ( tagged_object ) [EOL] db . session . commit ( ) [EOL] [EOL] result = sorted ( strategy . get_urls ( ) ) [EOL] expected = [ f'{ TEST_URL } [string] ' , ] [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] strategy = DashboardTagsStrategy ( [ [string] , [string] ] ) [EOL] [EOL] result = sorted ( strategy . get_urls ( ) ) [EOL] expected = [ f'{ TEST_URL } [string] ' , f'{ TEST_URL } [string] ' , ] [EOL] self . assertEqual ( result , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $unittest.mock.MagicMock$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $unittest.mock.MagicMock$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $unittest.mock.MagicMock$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $unittest.mock.MagicMock$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]],builtins.int]]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $unittest.mock.MagicMock$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $unittest.mock.MagicMock$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]],builtins.int]]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.str]$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Row ( object ) : [EOL] def __init__ ( self , values ) : [EOL] self . values = values [EOL] [EOL] def __name__ ( self ) : [EOL] return [string] [EOL] [EOL] def __iter__ ( self ) : [EOL] return ( item for item in self . values ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0