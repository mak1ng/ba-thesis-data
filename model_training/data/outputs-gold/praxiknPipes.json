import npipes [EOL] import npipes . producers . commandline [EOL] [EOL] message_str = [string] [EOL] pr = npipes . producers . commandline . ProducerCommandline ( [ [string] , message_str ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for m in pr . messages ( ) : [EOL] print ( m ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $npipes.producers.commandline.ProducerCommandline$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.producers.commandline.ProducerCommandline$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import unittest [EOL] import time [EOL] [comment] [EOL] from npipes . message . header import Message [EOL] from npipes . message . ezqconverter import convertFromEZQ , convertToEZQ [EOL] [EOL] class EZQConverterTestCase ( unittest . TestCase ) : [EOL] [EOL] def test_convertHeaderOnly ( self ) : [EOL] with open ( [string] ) as msgfile : [EOL] msgstr = msgfile . read ( ) [EOL] with convertFromEZQ ( Message , msgstr ) as msg : [EOL] print ( msg . _toMinDict ( ) ) [EOL] [EOL] [EOL] def test_convertFullMessage ( self ) : [EOL] with open ( [string] ) as msgfile : [EOL] msgstr = msgfile . read ( ) [EOL] with convertFromEZQ ( Message , msgstr ) as msg : [EOL] print ( msg . _toMinDict ( ) ) [EOL] [EOL] [EOL] def test_convertBigMessage ( self ) : [EOL] with open ( [string] ) as msgfile : [EOL] msgstr = msgfile . read ( ) [EOL] with convertFromEZQ ( Message , msgstr ) as msg : [EOL] print ( msg . _toMinDict ( ) ) [EOL] [EOL] def test_convertToEZQFullMsg ( self ) : [EOL] with open ( [string] ) as msgfile : [EOL] msgstr = msgfile . read ( ) [EOL] with convertFromEZQ ( Message , msgstr ) as msg : [EOL] print ( convertToEZQ ( msg ) ) [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Dict , Union [EOL] import npipes [EOL] import typing [EOL] import unittest [EOL] [EOL] from npipes . message . header import * [EOL] [comment] [EOL] from npipes . assethandlers . s3utils import S3Path [EOL] [EOL] class SerializeTestCase ( unittest . TestCase ) : [EOL] [EOL] def test_toMinDict1 ( self ) : [EOL] step1 = Step ( [string] , command = Command ( [ [string] , [string] ] ) ) [EOL] expected = { [string] : [string] , [string] : { [string] : [ [string] , [string] ] } } [EOL] self . assertEqual ( step1 . _toMinDict ( ) , expected ) [EOL] self . assertEqual ( step1 , Step . _fromDict ( step1 . _toMinDict ( ) ) ) [EOL] [EOL] def test_toMinDict2 ( self ) : [EOL] step2 = Step ( [string] , trigger = TriggerFilesystem ( [string] ) ) [EOL] expected = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } } [EOL] self . assertEqual ( step2 . _toMinDict ( ) , expected ) [EOL] self . assertEqual ( step2 , Step . _fromDict ( step2 . _toMinDict ( ) ) ) [EOL] [EOL] def test_toMinDict3 ( self ) : [EOL] s3 = S3Asset ( S3Path ( [string] ) , AssetSettings ( [string] ) ) [EOL] expected = { [string] : [string] , [string] : [string] , [string] : { [string] : [string] } } [EOL] self . assertEqual ( s3 . _toMinDict ( ) , expected ) [EOL] self . assertEqual ( s3 , Asset . _fromDict ( s3 . _toMinDict ( ) ) ) [EOL] [EOL] def test_toMinDict4 ( self ) : [EOL] ur = UriAsset ( [string] , AssetSettings ( [string] , localTarget = [string] ) ) [EOL] expected = { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] } } [EOL] self . assertEqual ( ur . _toMinDict ( ) , expected ) [EOL] self . assertEqual ( ur , Asset . _fromDict ( ur . _toMinDict ( ) ) ) [EOL] [EOL] def test_with ( self ) : [EOL] s = Step ( id = [string] , trigger = TriggerSqs ( QueueName ( [string] ) , overflowPath = [string] ) , command = Command ( [ [string] , [string] ] , outputChannel = OutputChannelStdout ( ) ) , description = [string] ) [EOL] [EOL] newpath = [string] [EOL] newdesc = [string] [EOL] newargs = [ [string] , [string] , [string] ] [EOL] [EOL] t = s . _with ( [ ( [string] , OutputChannelFile ( FilePath ( newpath ) ) ) , ( [string] , newdesc ) , ( [string] , newargs ) ] ) [EOL] self . assertNotEqual ( s , t ) [EOL] self . assertEqual ( t . command . outputChannel . filepath , newpath ) [EOL] self . assertEqual ( t . description , newdesc ) [EOL] self . assertEqual ( t . command . arglist , newargs ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],builtins.str]]$ 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.S3Asset$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.S3Asset$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 $npipes.message.header.S3Asset$ 0 0 0 0 0 $npipes.message.header.S3Asset$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.UriAsset$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.UriAsset$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 $npipes.message.header.UriAsset$ 0 0 0 0 0 $npipes.message.header.UriAsset$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $npipes.message.header.Step$ 0 $npipes.message.header.Step$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $npipes.message.header.Step$ 0 $npipes.message.header.Step$ 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $npipes.message.header.Step$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any [EOL] import builtins [EOL] import message [EOL] import typing [EOL] from base64 import b64decode , b64encode [EOL] from distutils . util import strtobool [EOL] import os [EOL] [EOL] from dataclasses import dataclass , field [EOL] from typing import Dict [EOL] [EOL] from . serialize import * [EOL] from . message . header import Command [EOL] [EOL] [EOL] [EOL] def strToB64Str ( s ) : [EOL] return b64encode ( s . encode ( ) ) . decode ( ) [EOL] [EOL] [EOL] def b64StrToStr ( s ) : [EOL] return b64decode ( s . encode ( ) ) . decode ( ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Configuration ( Serializable ) : [EOL] [docstring] [EOL] command = field ( default_factory = Command ) [EOL] lockCommand = True [EOL] commandValidator = [string] [EOL] producer = [string] [EOL] producerArgs = field ( default_factory = dict ) [EOL] pid = field ( default_factory = os . getpid ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def _toDict ( self ) : [EOL] return { [string] : b64encode ( json . dumps ( self . command . _toDict ( ) ) . encode ( ) ) . decode ( ) , [string] : str ( self . lockCommand ) , [string] : self . commandValidator , [string] : self . producer , [string] : strToB64Str ( json . dumps ( self . producerArgs ) ) } [EOL] [comment] [EOL] [EOL] def _fromDict ( d ) : [EOL] cmd = d . get ( [string] , { } ) [EOL] if isinstance ( cmd , str ) : [EOL] ccmd = json . loads ( b64StrToStr ( cmd ) ) [EOL] elif isinstance ( cmd , dict ) : [EOL] ccmd = cmd [EOL] else : [EOL] raise TypeError ( f" [string] { type ( cmd ) }" ) [EOL] return Configuration ( command = Command . _fromDict ( ccmd ) , lockCommand = bool ( strtobool ( d . get ( [string] , [string] ) ) ) , commandValidator = d . get ( [string] , [string] ) , producer = d . get ( [string] , [string] ) , producerArgs = ( json . loads ( b64StrToStr ( d . get ( [string] , strToB64Str ( [string] ) ) ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $message.header.Command$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Callable , Any , Iterator , TypeVar , Sequence , Optional [EOL] import builtins [EOL] import npipes [EOL] import typing [EOL] from typing import Any , Callable , TypeVar , Union , Generic , Optional , Sequence , Iterator [EOL] from contextlib import contextmanager [EOL] [EOL] L = TypeVar ( [string] ) [comment] [EOL] R = TypeVar ( [string] ) [comment] [EOL] C = TypeVar ( [string] ) [comment] [EOL] [EOL] class Outcome ( Generic [ L , R ] ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . err = ... [EOL] self . val = ... [EOL] [EOL] def then ( self , f ) : [EOL] [docstring] [EOL] if isinstance ( self , Success ) : [EOL] return f ( self . val ) [EOL] else : [comment] [EOL] return self [EOL] [EOL] def __rshift__ ( self , f ) : [EOL] [docstring] [EOL] return self . then ( f ) [EOL] [EOL] [EOL] class Failure ( Outcome [ L , R ] ) : [EOL] [docstring] [EOL] def __init__ ( self , reason ) : [EOL] [docstring] [EOL] self . err = reason [EOL] [EOL] @ property def reason ( self ) : [EOL] [docstring] [EOL] return self . err [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( type ( self . reason ) , self . reason ) [EOL] [EOL] [EOL] class Success ( Outcome [ L , R ] ) : [EOL] [docstring] [EOL] def __init__ ( self , v ) : [EOL] [docstring] [EOL] self . val = v [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return self . val [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( type ( self . value ) , self . value ) [EOL] [EOL] [EOL] def onFailure ( oc ) : [EOL] [docstring] [EOL] if isinstance ( oc , Failure ) : [EOL] yield oc . reason [EOL] [EOL] [EOL] def onSuccess ( oc ) : [EOL] [docstring] [EOL] if isinstance ( oc , Success ) : [EOL] yield oc . value [EOL] [EOL] [EOL] def failed ( oc ) : [EOL] [docstring] [EOL] if isinstance ( oc , Failure ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def succeeded ( oc ) : [EOL] [docstring] [EOL] if isinstance ( oc , Success ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def filterMapFailed ( f , ocs ) : [EOL] [docstring] [EOL] for oc in ocs : [EOL] for reason in onFailure ( oc ) : [EOL] yield f ( reason ) [EOL] [EOL] [EOL] def filterMapSucceeded ( f , ocs ) : [EOL] [docstring] [EOL] for oc in ocs : [EOL] for value in onSuccess ( oc ) : [EOL] yield f ( value ) [EOL] [EOL] [EOL] def pureOutcome ( v , sentinels = [ None ] , fstring = [string] ) : [EOL] [docstring] [EOL] if v in sentinels : [EOL] return Failure ( ( v , fstring ) ) [EOL] else : [EOL] return Success ( v ) [EOL] [EOL] [EOL] def liftOutcome ( f , sentinels = [ None ] , fstring = None , catch = False ) : [EOL] [docstring] [EOL] if fstring is None : [comment] [EOL] myfstring = f . __name__ [EOL] else : [EOL] myfstring = fstring [EOL] if catch : [EOL] return ( lambda x : _exceptionWrapped ( f , x , sentinels , myfstring ) ) [EOL] else : [EOL] return ( lambda x : pureOutcome ( f ( x ) , sentinels , myfstring ) ) [EOL] [EOL] [EOL] def _exceptionWrapped ( f , x , sentinels , fstring ) : [EOL] [docstring] [EOL] try : [EOL] return pureOutcome ( f ( x ) , sentinels , fstring ) [EOL] except Exception as e : [EOL] return Failure ( ( e , fstring ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $L$ 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Union , Generator , List , Dict , Sequence , Optional [EOL] import configuration [EOL] import typing [EOL] import npipes [EOL] import message [EOL] import pathlib [EOL] import outcome [EOL] import subprocess [EOL] import builtins [EOL] import producers [EOL] from typing import Tuple , NamedTuple , List , Dict , Union , Type , Any , Optional , Sequence [EOL] import subprocess [EOL] import string [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] from . outcome import Success , Failure , onFailure , onSuccess , filterMapFailed [EOL] [EOL] from . message . header import ( Asset , Trigger , OutputChannel , OutputChannelStdout , OutputChannelFile , Encoding , EncodingPlainText , EncodingGzB64 , Command , Step , Header , Body , BodyInString , BodyInAsset , Message , peekStep , popStep , peekTrigger ) [EOL] [EOL] from . assethandlers . assets import localizeAssets , decideLocalTarget , randomName [EOL] from . configuration import Configuration [EOL] from . serialize import toJson [EOL] from . producers . producer import Producer [EOL] from . outcome import Outcome , Success , Failure [EOL] from . utils . iteratorextras import consume [EOL] from . utils . typeshed import pathlike [EOL] from . utils . autodeleter import AutoDeleter [EOL] from . utils . compressionutils import fromGzB64 [EOL] from . utils . track import track [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def scrapeOutput ( command , cmdstdout ) : [EOL] oc = command . outputChannel [EOL] if isinstance ( oc , OutputChannelStdout ) : [EOL] result = Success ( cmdstdout ) [EOL] elif isinstance ( oc , OutputChannelFile ) : [EOL] p = Path ( oc . filepath ) [EOL] if p . is_file ( ) : [EOL] result = Success ( p . read_text ( ) ) [EOL] else : [EOL] result = Failure ( track ( f" [string] { p } [string] " ) ) [EOL] else : [EOL] result = Failure ( track ( [string] ) ) [EOL] return result [EOL] [EOL] [EOL] def runProcess ( command , input , timeout ) : [EOL] [docstring] [EOL] try : [EOL] cp = subprocess . run ( command . arglist , input = input , timeout = timeout , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] except subprocess . TimeoutExpired as teerr : [EOL] return Failure ( track ( [string] ) ) [EOL] except Exception as err : [EOL] return Failure ( track ( f" [string] { err }" ) ) [EOL] [EOL] if cp . returncode is not [number] : [EOL] return Failure ( track ( f" [string] { cp . returncode } [string] " f" [string] { cp . stdout . decode ( ) } [string] " f" [string] { cp . stderr . decode }" ) ) [EOL] else : [EOL] return Success ( cp . stdout . decode ( ) ) [EOL] [EOL] [EOL] def runCommand ( command , body ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] timeout = None if command . timeout is [number] else command . timeout [EOL] [EOL] input = body . encode ( [string] ) if command . inputChannelStdin else None [EOL] [EOL] return ( runProcess ( command , input , timeout ) >> ( lambda output : scrapeOutput ( command , output ) ) ) [EOL] [EOL] [EOL] def toUniqueFile ( data ) : [EOL] filename = randomName ( ) [EOL] Path ( filename ) . write_text ( data ) [EOL] return filename [EOL] [EOL] [comment] [EOL] [comment] [EOL] def expandCommand ( command , assets , body , bodyfile , headerfile , outputfile , pid ) : [EOL] [docstring] [EOL] targetsForIds = { [string] : bodyfile , [string] : body , [string] : headerfile , [string] : outputfile , [string] : pid } [EOL] [comment] [EOL] targetsForIds . update ( dict ( zip ( map ( lambda a : a . settings . id , assets ) , map ( decideLocalTarget , assets ) ) ) ) [EOL] [EOL] newargs = list ( map ( lambda s : string . Template ( s ) . safe_substitute ( targetsForIds ) , command . arglist ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if any ( map ( lambda arg : [string] in arg , newargs ) ) : [EOL] ebc = { [string] : repr ( body ) } [EOL] newargs = list ( map ( lambda s : string . Template ( s ) . safe_substitute ( ebc ) , newargs ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( command . outputChannel , OutputChannelFile ) : [EOL] fp = ( string . Template ( command . outputChannel . filepath ) . safe_substitute ( { [string] : bodyfile } ) ) [EOL] command = command . _with ( [ ( [string] , fp ) ] ) [EOL] [EOL] return command . _with ( [ ( [string] , newargs ) ] ) [EOL] [EOL] [EOL] def triggerNextStep ( result ) : [EOL] [comment] [EOL] return peekTrigger ( result ) . sendMessage ( result ) [EOL] [EOL] [EOL] def makeMessage ( result , newHeader ) : [EOL] return Success ( Message ( header = newHeader , body = BodyInString ( result ) ) ) [EOL] [EOL] [EOL] def extractBodyInString ( body ) : [EOL] if isinstance ( body . encoding , EncodingPlainText ) : [EOL] return body . string [EOL] else : [comment] [EOL] return fromGzB64 ( body . string . encode ( ) ) [EOL] [EOL] [EOL] def extractBodyInAsset ( body , assets ) : [EOL] for asset in assets : [EOL] if body . assetId == asset . settings . id : [EOL] with open ( decideLocalTarget ( asset ) ) as f : [EOL] return f . read ( ) [EOL] return [string] [EOL] [EOL] [EOL] def extractBody ( body , assets ) : [EOL] [docstring] [EOL] if isinstance ( body , BodyInString ) : [EOL] return extractBodyInString ( body ) [EOL] elif isinstance ( body , BodyInAsset ) : [EOL] return extractBodyInAsset ( body , assets ) [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] def chooseCommand ( config , command ) : [EOL] [docstring] [EOL] if config . lockCommand : [EOL] return config . command [EOL] else : [EOL] return command [EOL] [EOL] [EOL] def handleMessage ( config , msg ) : [EOL] [docstring] [EOL] step , newHeader = popStep ( msg . header ) [EOL] [EOL] lao = localizeAssets ( step . assets ) [EOL] if isinstance ( lao , Failure ) : [EOL] result = lao [EOL] else : [EOL] with AutoDeleter ( ) as deleter : [EOL] body = extractBody ( msg . body , step . assets ) [EOL] bodyfile = deleter . add ( toUniqueFile ( body ) ) [EOL] headerfile = deleter . add ( toUniqueFile ( toJson ( msg . header ) ) ) [EOL] outputfile = deleter . add ( randomName ( ) ) [EOL] consume ( map ( deleter . add , lao . value ) ) [EOL] [EOL] result = ( ( Success ( chooseCommand ( config , step . command ) ) >> ( lambda cmd : Success ( expandCommand ( cmd , step . assets , body , bodyfile , headerfile , outputfile , config . pid ) ) ) >> ( lambda expcmd : runCommand ( expcmd , body ) ) ) >> ( lambda res : makeMessage ( res , newHeader ) ) >> ( lambda message : triggerNextStep ( message ) ) ) [EOL] return result [EOL] [EOL] [EOL] def runMessageProducer ( config , producer ) : [EOL] [docstring] [EOL] stream = producer . messages ( ) [EOL] for msg in stream : [comment] [EOL] result = handleMessage ( config , msg ) [EOL] [EOL] stream . send ( result ) [EOL] [EOL] for reason in onFailure ( result ) : [EOL] logging . fatal ( reason ) [EOL] [EOL] [comment] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $message.header.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,message.header.Message]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $message.header.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import argparse [EOL] import _importlib_modulespec [EOL] import typing [EOL] import pathlib [EOL] import json [EOL] import logging [EOL] import os [EOL] [EOL] from argparse import ArgumentParser [EOL] from importlib import import_module [EOL] from pathlib import Path [EOL] [EOL] from . configuration import Configuration [EOL] from . processor import runMessageProducer [EOL] from . producers . producer import Producer [EOL] [EOL] [EOL] def getArgs ( ) : [EOL] parser = ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] , default = [string] , type = Path ) [EOL] return parser . parse_known_args ( ) [EOL] [EOL] [EOL] def getFileConfig ( fname ) : [EOL] configFile = Path ( fname ) [EOL] if configFile . is_file ( ) : [EOL] return json . loads ( configFile . read_text ( ) ) [EOL] else : [EOL] return { } [EOL] [EOL] [EOL] def getEnv ( ) : [EOL] keys = [ [string] , [string] , [string] , [string] , [string] ] [EOL] return { k : os . environ [ k ] for k in keys if k in os . environ } [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] def liftConfig ( config , configHash ) : [EOL] [docstring] [EOL] configDict = config . _toDict ( ) [EOL] for k , v in configDict . items ( ) : [EOL] os . environ [ k ] = v [EOL] [comment] [EOL] for k , v in configHash . items ( ) : [EOL] if k not in configDict . keys ( ) : [EOL] os . environ [ k ] = v [EOL] [EOL] [EOL] def main ( ) : [EOL] [comment] [EOL] logging . basicConfig ( level = logging . DEBUG , format = [string] ) [EOL] [EOL] args , extraArgs = getArgs ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] configHash = getFileConfig ( args . config ) [EOL] configHash . update ( getEnv ( ) ) [EOL] config = Configuration . _fromDict ( configHash ) [EOL] [EOL] liftConfig ( config , configHash ) [EOL] [EOL] producerModule = import_module ( config . producer ) [EOL] producer = producerModule . createProducer ( extraArgs , config . producerArgs ) [EOL] [EOL] runMessageProducer ( config , producer ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] import builtins [EOL] import outcome [EOL] import message [EOL] from . . message . header import Message [EOL] from . . outcome import Outcome , Success , Failure [EOL] [EOL] [EOL] def sendMessageGet ( uri , message ) : [EOL] pass [EOL] [EOL] [EOL] def sendMessagePost ( uri , message ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,None]$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import builtins [EOL] import outcome [EOL] import message [EOL] import typing [EOL] from . . message . header import Message [EOL] from . . outcome import Outcome , Success , Failure [EOL] from . . message . ezqconverter import toEzqOrJsonLines [EOL] [EOL] import boto3 [EOL] [EOL] [EOL] def sendMessage ( name , message ) : [EOL] [docstring] [EOL] client = boto3 . client ( [string] ) [EOL] resp = client . invoke ( FunctionName = name , InvocationType = [string] , Payload = toEzqOrJsonLines ( message ) . encode ( [string] ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if resp [ [string] ] == [number] : [EOL] return Success ( None ) [EOL] else : [EOL] return Failure ( f" [string] { name } [string] { resp [ [string] ] }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import builtins [EOL] import outcome [EOL] import typing [EOL] import message [EOL] from . . message . header import Message [EOL] from . . outcome import Outcome , Success , Failure [EOL] from . . message . ezqconverter import toEzqOrJsonLines [EOL] [EOL] import boto3 [EOL] [EOL] def sendMessage ( topic , message ) : [EOL] [docstring] [EOL] sns = boto3 . client ( [string] ) [EOL] resp = sns . publish ( TopicArn = topic , Message = toEzqOrJsonLines ( message ) ) [EOL] [comment] [EOL] [comment] [EOL] return Success ( None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import message [EOL] import npipes [EOL] import outcome [EOL] import builtins [EOL] from . . message . header import Message [EOL] from . . outcome import Outcome , Success , Failure [EOL] from . . message . header import Encoding , EncodingPlainText , EncodingGzB64 , S3Asset , AssetSettings , Decompression , BodyInString , BodyInAsset [EOL] from . . assethandlers . assets import randomName [EOL] from . . assethandlers . s3utils import uploadData [EOL] from . . assethandlers . s3path import S3Path [EOL] from . . message . ezqconverter import toEzqOrJsonLines [EOL] [EOL] from typing import Generator , List [EOL] import boto3 [EOL] import hashlib [EOL] import gzip [EOL] from base64 import b64encode [EOL] [EOL] [EOL] def sendMessage ( queuename , overflowPath , message ) : [EOL] [docstring] [EOL] try : [EOL] sqs = boto3 . resource ( [string] ) [EOL] queue = sqs . get_queue_by_name ( QueueName = queuename ) [EOL] messageAutoflowed = overflow ( message , overflowPath ) [EOL] messageBody = toEzqOrJsonLines ( overflow ( message , overflowPath ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] md5 = hashlib . md5 ( messageBody . encode ( [string] ) ) . hexdigest ( ) [EOL] response = queue . send_message ( MessageBody = messageBody ) [EOL] if response . get ( [string] ) == md5 : [EOL] return Success ( None ) [EOL] else : [EOL] return Failure ( [string] ) [EOL] except Exception as err : [EOL] return Failure ( [string] . format ( err ) ) [EOL] [EOL] def overflow ( message , overflowPath ) : [EOL] [comment] [EOL] body = Message . body [EOL] if isinstance ( body , BodyInString ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] overAmount = len ( message . toJsonLines ( ) . encode ( ) ) - [number] [EOL] if overAmount > [number] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] bodyBytes = body . string . encode ( ) [EOL] gzBodyBytes = gzip . compress ( bodyBytes , compresslevel = [number] ) [EOL] b64BodyBytes = b64encode ( gzBodyBytes ) [EOL] [comment] [EOL] if len ( b64BodyBytes ) < ( overAmount - [number] ) : [comment] [EOL] [comment] [EOL] newBody = BodyInString ( b64BodyBytes . decode ( ) , encoding = EncodingGzB64 ( ) ) [EOL] return message . _with ( [ ( [string] , newBody ) ] ) [EOL] else : [EOL] [comment] [EOL] fname = randomName ( ) [EOL] s3Path = S3Path ( overflowPath ) . add ( fname ) [EOL] uploadData ( gzBodyBytes , s3Path ) [EOL] asset = S3Asset ( s3Path , AssetSettings ( id = [string] , decompression = Decompression ( True ) ) ) [EOL] [EOL] oldsteps = message . header . steps [EOL] oldstep = oldsteps [ [number] ] [EOL] newstep = oldstep . _with ( [ ( [string] , oldstep . assets + [ asset ] ) ] ) [EOL] newsteps = [ newstep ] + oldsteps [ [number] : ] [EOL] [EOL] return message . _with ( [ ( [string] , newsteps ) , ( [string] , BodyInAsset ( assetId = [string] ) ) ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] return message [EOL] else : [EOL] return message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $message.header.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] import outcome [EOL] import message [EOL] from pathlib import Path [EOL] [EOL] from . . message . header import Message [EOL] from . . outcome import Outcome , Success , Failure [EOL] from . . assethandlers . assets import randomName [EOL] from . . message . ezqconverter import toEzqOrJsonLines [EOL] [EOL] [EOL] def sendMessage ( dir , message ) : [EOL] [docstring] [EOL] try : [EOL] messageStr = toEzqOrJsonLines ( message ) [EOL] Path ( dir ) . joinpath ( randomName ( ) ) . write_text ( messageStr ) [EOL] return Success ( None ) [EOL] except Exception as e : [EOL] return Failure ( [string] . format ( e ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] import concurrent . futures [EOL] [EOL] def identity ( x ) : [EOL] return x [EOL] [EOL] [EOL] def concurrentMap ( f , xs ) : [EOL] with concurrent . futures . ThreadPoolExecutor ( ) as executor : [EOL] return executor . map ( f , xs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from itertools import * [EOL] import collections [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def consume ( iterator , n = None ) : [EOL] [docstring] [EOL] [comment] [EOL] if n is None : [EOL] [comment] [EOL] collections . deque ( iterator , maxlen = [number] ) [EOL] else : [EOL] [comment] [EOL] next ( islice ( iterator , n , n ) , None ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] def each ( f , iterator , n = None ) : [EOL] [docstring] [EOL] consume ( map ( f , iterator ) , n ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Union [EOL] from pathlib import Path [EOL] [EOL] pathlike = Union [ str , Path ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
from npipes . utils . iteratorextras import * [EOL] from npipes . utils . fp import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from gzip import compress , decompress [EOL] from base64 import b64encode , b64decode [EOL] [EOL] [EOL] def toGzB64 ( s ) : [EOL] [docstring] [EOL] return b64encode ( compress ( s . encode ( [string] ) ) ) [EOL] [EOL] def fromGzB64 ( b ) : [EOL] [docstring] [EOL] return decompress ( b64decode ( b ) ) . decode ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import types [EOL] import typing [EOL] import inspect [EOL] [EOL] def track ( s ) : [EOL] [docstring] [EOL] frame = inspect . currentframe ( ) [EOL] if frame : [EOL] prev = frame . f_back [EOL] if prev : [EOL] return f" [string] { prev . f_code . co_filename } [string] { prev . f_lineno } [string] { s }" [EOL] return s [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Iterator [EOL] import npipes [EOL] import typing [EOL] from contextlib import contextmanager , ExitStack [EOL] from pathlib import Path [EOL] from typing import Iterator [EOL] [EOL] from npipes . utils . typeshed import pathlike [EOL] [EOL] @ contextmanager def autoDeleteFile ( path ) : [EOL] [docstring] [EOL] try : [EOL] yield path [EOL] finally : [EOL] if Path ( path ) . is_file ( ) : [EOL] Path ( path ) . unlink ( ) [EOL] [EOL] [EOL] class AutoDeleter ( ExitStack ) : [EOL] [docstring] [EOL] def add ( self , path ) : [EOL] [docstring] [EOL] return self . enter_context ( autoDeleteFile ( path ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[npipes.utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.utils.typeshed.pathlike$ 0 0 0 $npipes.utils.typeshed.pathlike$ 0 0 0 0 0 0 0 0 0 0 0 0 $npipes.utils.typeshed.pathlike$ 0 0 0
	0
	0
[comment] [EOL] [EOL] from typing import List , Dict , Any , Generator [EOL] import message [EOL] import typing [EOL] import outcome [EOL] import producer [EOL] import builtins [EOL] from typing import Generator , List , Dict , Any [EOL] from dataclasses import dataclass [EOL] [EOL] from . . message . header import Message [EOL] from . . outcome import Outcome , Success , Failure [EOL] from . producer import Producer [EOL] [EOL] [EOL] def createProducer ( cliArgs , producerArgs ) : [EOL] return ProducerTcpSocket ( ** producerArgs ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class ProducerTcpSocket ( Producer ) : [EOL] socket = ... [EOL] [EOL] def messages ( self ) : [EOL] [docstring] [EOL] pass [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $producer.Producer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Generator[message.header.Message,outcome.Outcome[typing.Any,typing.Any],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Dict , Any , Generator [EOL] import builtins [EOL] import outcome [EOL] import message [EOL] import typing [EOL] from base64 import b64decode [EOL] import json [EOL] from os import environ [EOL] [EOL] from typing import Generator , List , Dict , Any [EOL] from . . outcome import Outcome , Success , Failure [EOL] from . . message . header import Message [EOL] [EOL] [EOL] [comment] [EOL] def envLower ( key ) : [EOL] bv = environ . get ( key , [string] ) [comment] [EOL] return json . loads ( b64decode ( bv . encode ( ) ) . decode ( ) ) [EOL] [EOL] [EOL] class Producer : [EOL] def messages ( self ) : [EOL] [docstring] [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def createProducer ( cliArgs , producerArgs ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[message.header.Message,outcome.Outcome[typing.Any,typing.Any],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Producer$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Dict , Any , Generator [EOL] import message [EOL] import npipes [EOL] import typing [EOL] import outcome [EOL] import producer [EOL] import builtins [EOL] from typing import Generator , List , Dict , Any [EOL] from dataclasses import dataclass [EOL] [EOL] import boto3 [EOL] [EOL] from . . message . header import Message [EOL] from . . outcome import Outcome , Success , Failure [EOL] from . producer import Producer [EOL] [EOL] def createProducer ( cliArgs , producerArgs ) : [EOL] return ProducerSqs ( ** producerArgs ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class ProducerSqs ( Producer ) : [EOL] queueName = ... [EOL] maxNumberOfMessages = [number] [EOL] [EOL] def messages ( self ) : [EOL] [docstring] [EOL] sqs = boto3 . resource ( [string] ) [EOL] queue = sqs . get_queue_by_name ( QueueName = self . queueName ) [EOL] fake_message = Message ( ) [EOL] [EOL] sqsMsgs = [ ] [EOL] while True : [EOL] sqsMsgs = queue . receive_messages ( AttributeNames = [ [string] ] , MaxNumberOfMessages = self . maxNumberOfMessages , WaitTimeSeconds = [number] ) [EOL] for sqsMsg in sqsMsgs : [comment] [EOL] with Message . fromStr ( sqsMsg . body ) as msg : [EOL] result = yield msg [EOL] if isinstance ( result , Success ) : [EOL] sqsMsg . delete ( ) [EOL] elif isinstance ( result , Failure ) : [EOL] sqsMsg . change_visibility ( VisibilityTimeout = [number] ) [EOL] [EOL] yield fake_message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Generator[message.header.Message,outcome.Outcome[typing.Any,typing.Any],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Dict , Any , Generator [EOL] import typing [EOL] import npipes [EOL] import message [EOL] import outcome [EOL] import producer [EOL] import argparse [EOL] import builtins [EOL] import argparse [EOL] import sys [EOL] from typing import Generator , List , Dict , Any [EOL] [EOL] from dataclasses import dataclass [EOL] [EOL] from . . message . header import Message [EOL] from . . outcome import Outcome , Success , Failure [EOL] from . producer import Producer [EOL] [EOL] [EOL] def createProducer ( cliArgs , producerArgs ) : [EOL] return ProducerCommandline ( cliArgs ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class ProducerCommandline ( Producer ) : [EOL] argv = ... [EOL] [EOL] def messages ( self ) : [EOL] [docstring] [EOL] fake_message = Message ( ) [comment] [EOL] [EOL] with Message . fromStr ( self . _getCliMessage ( self . argv ) ) as msg : [EOL] yield msg [EOL] [EOL] [comment] [EOL] yield fake_message [EOL] [EOL] [EOL] def _getCliMessage ( self , argv ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] mxGroup = parser . add_mutually_exclusive_group ( ) [EOL] mxGroup . add_argument ( [string] , action = [string] ) [EOL] mxGroup . add_argument ( [string] , action = [string] ) [EOL] args = parser . parse_args ( argv ) [EOL] [EOL] if args . file : [EOL] msg = self . _readFile ( args . file ) [EOL] elif args . message : [EOL] msg = args . message [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] msg = [string] [EOL] for line in sys . stdin : [EOL] msg += line [EOL] [EOL] print ( msg ) [EOL] return msg [EOL] [EOL] [EOL] def _readFile ( self , filename ) : [EOL] with open ( filename ) as f : [EOL] return f . read ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 0 0 0 0 0 0 0 0 0 $argparse._MutuallyExclusiveGroup$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $builtins.str$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any , Sequence [EOL] import utils [EOL] import message [EOL] import pathlib [EOL] import typing [EOL] import outcome [EOL] import builtins [EOL] from typing import Tuple , NamedTuple , List , Dict , Union , Type , Any , Optional , Sequence [EOL] import secrets [EOL] import zipfile [EOL] import gzip [EOL] import shutil [EOL] import string [EOL] import logging [EOL] from pathlib import Path [EOL] import distutils . dir_util [EOL] [EOL] [EOL] from . . message . header import ( Uri , Topic , QueueName , FilePath , Asset , S3Asset , UriAsset , AssetSettings , Decompression ) [EOL] [EOL] from . . outcome import Outcome , Success , Failure , onFailure , filterMapSucceeded [EOL] from . . utils . fp import concurrentMap [EOL] from . . utils . iteratorextras import consume [EOL] from . s3path import S3Path [EOL] from . . utils . track import track [EOL] from . . utils . typeshed import pathlike [EOL] [EOL] [EOL] def localizeAssets ( assets ) : [EOL] [docstring] [EOL] [comment] [EOL] outcomes = concurrentMap ( localizeAsset , assets ) [EOL] if any ( map ( lambda oc : isinstance ( oc , Failure ) , outcomes ) ) : [EOL] logFailures ( outcomes , assets ) [EOL] [comment] [EOL] consume ( filterMapSucceeded ( lambda p : Path ( p ) . unlink ( ) , outcomes ) ) [EOL] return Failure ( track ( [string] ) ) [EOL] else : [EOL] return Success ( list ( map ( lambda oc : oc . value , outcomes ) ) ) [EOL] [EOL] [EOL] def logFailures ( outcomes , assets ) : [EOL] for oc , nm in zip ( outcomes , map ( str , assets ) ) : [EOL] for reason in onFailure ( oc ) : [EOL] logging . fatal ( [string] . format ( nm , reason ) ) [EOL] [EOL] [EOL] def localizeAsset ( asset ) : [EOL] [docstring] [EOL] tempname = genUniqueAssetName ( asset ) [EOL] [EOL] return ( localizeAssetTyped ( asset , tempname ) >> ( lambda name : decompressIfRequired ( name , asset ) ) >> ( lambda name : renameToLocalTarget ( name , asset ) ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def localizeAssetTyped ( asset , target ) : [EOL] if isinstance ( asset , S3Asset ) : [EOL] return localizeS3Asset ( asset , target ) [EOL] elif isinstance ( asset , UriAsset ) : [EOL] return localizeUriAsset ( asset , target ) [EOL] else : [EOL] return Failure ( track ( f" [string] { type ( asset ) }" ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] from . import s3utils [EOL] def localizeS3Asset ( asset , target ) : [EOL] [docstring] [EOL] return s3utils . downloadFile ( asset . path , target ) [EOL] except ImportError : [EOL] pass [comment] [EOL] [EOL] [EOL] try : [EOL] import requests [EOL] def localizeUriAsset ( asset , target ) : [EOL] [docstring] [EOL] [comment] [EOL] return Success ( target ) [EOL] except ModuleNotFoundError : [EOL] pass [EOL] [EOL] [EOL] def genUniqueAssetName ( asset ) : [EOL] [docstring] [EOL] return [string] . format ( randomName ( ) , getAssetRawExt ( asset ) ) [EOL] [EOL] [EOL] def randomName ( ) : [EOL] [docstring] [EOL] return secrets . token_hex ( [number] ) [EOL] [EOL] [EOL] def decompressIfRequired ( fname , asset ) : [EOL] [docstring] [EOL] if asset . settings . decompression . decompress : [EOL] return decompress ( fname ) [EOL] else : [EOL] return Success ( fname ) [EOL] [EOL] [EOL] def decompress ( path ) : [EOL] [docstring] [EOL] pth = Path ( path ) [EOL] suff = pth . suffix [EOL] if suff == [string] : [EOL] return decompressZip ( path ) [EOL] elif suff == [string] : [EOL] return decompressGzip ( path ) [EOL] else : [EOL] return Failure ( track ( f" [string] { suff }" ) ) [EOL] [EOL] [EOL] def decompressZip ( file ) : [EOL] [docstring] [EOL] tmpdir = randomName ( ) [EOL] try : [EOL] with zipfile . ZipFile ( file ) as z : [EOL] z . extractall ( path = tmpdir ) [EOL] Path ( file ) . unlink ( ) [comment] [EOL] return Success ( tmpdir ) [EOL] except Exception as err : [EOL] if Path ( tmpdir ) . exists ( ) : [comment] [EOL] distutils . dir_util . remove_tree ( tmpdir ) [EOL] Path ( file ) . unlink ( ) [EOL] return Failure ( track ( f" [string] { err }" ) ) [EOL] [EOL] [EOL] def decompressGzip ( file ) : [EOL] [docstring] [EOL] try : [EOL] target = Path ( file ) . stem [EOL] if Path ( file ) . suffix == [string] : [EOL] target += [string] [EOL] with gzip . open ( file , [string] ) as src : [EOL] with open ( target , [string] ) as dst : [EOL] shutil . copyfileobj ( src , dst ) [EOL] return Success ( target ) [EOL] except Exception as err : [EOL] return Failure ( track ( f" [string] { err }" ) ) [EOL] [EOL] [EOL] def renameToLocalTarget ( fname , asset ) : [EOL] [docstring] [EOL] target = decideLocalTarget ( asset ) [EOL] targetPath = Path ( target ) [EOL] try : [EOL] targetPath . parent . mkdir ( parents = True , exist_ok = True ) [EOL] if targetPath . name is not [string] : [EOL] Path ( fname ) . rename ( targetPath ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if Path ( fname ) . is_dir ( ) : [EOL] distutils . dir_util . copy_tree ( str ( fname ) , target ) [EOL] distutils . dir_util . remove_tree ( str ( fname ) ) [EOL] else : [EOL] return Failure ( track ( f" [string] { targetPath }" ) ) [EOL] return Success ( target ) [EOL] except Exception as err : [EOL] return Failure ( track ( f" [string] { target } [string] { err }" ) ) [EOL] [EOL] [EOL] def getAssetRawExt ( asset ) : [EOL] [docstring] [EOL] leaf = decideLocalTargetTyped ( asset ) [EOL] ext = [string] . join ( leaf . split ( [string] ) [ [number] : ] ) [EOL] return ext [EOL] [EOL] [EOL] def decideLocalTarget ( asset ) : [EOL] if asset . settings . localTarget : [EOL] return asset . settings . localTarget [EOL] else : [EOL] return decideLocalTargetTyped ( asset ) [EOL] [EOL] [EOL] def decideLocalTargetTyped ( asset ) : [EOL] if isinstance ( asset , S3Asset ) : [EOL] return decideLocalTargetS3Asset ( asset ) [EOL] elif isinstance ( asset , UriAsset ) : [EOL] return decideLocalTargetUriAsset ( asset ) [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] def decideLocalTargetS3Asset ( asset ) : [EOL] [docstring] [EOL] return S3Path ( asset . path ) . key [EOL] [EOL] [EOL] def decideLocalTargetUriAsset ( asset ) : [EOL] [docstring] [EOL] return asset . uri . split ( [string] ) [ - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,typing.Sequence[utils.typeshed.pathlike]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $outcome.Outcome[builtins.str,utils.typeshed.pathlike]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0