from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import sys [EOL] from typing import List [EOL] [EOL] [EOL] def to_int ( array ) : [EOL] return int ( [string] . join ( str ( d ) for d in array ) ) [EOL] [EOL] [EOL] def nine_out ( index , array ) : [EOL] return [ x if i < index else ( x - [number] if i == index else [number] ) for i , x in enumerate ( array ) ] [EOL] [EOL] [EOL] def tidy ( array ) : [EOL] for i in range ( [number] , len ( array ) - [number] ) : [EOL] [comment] [EOL] if array [ i ] <= array [ i + [number] ] : [EOL] continue [EOL] else : [EOL] return tidy ( nine_out ( i , array ) ) [EOL] [EOL] return to_int ( array ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def parse ( filename ) : [EOL] with open ( filename ) as f : [EOL] lines = f . readlines ( ) [EOL] [EOL] num_cases = int ( lines [ [number] ] ) [EOL] [EOL] for i in range ( num_cases ) : [EOL] case = lines [ i + [number] ] [EOL] array = [ int ( n ) for n in case . strip ( ) ] [EOL] [EOL] result = tidy ( array ) [EOL] print ( f" [string] { i + [number] } [string] " , result ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parse ( sys . argv [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] from dataclasses import dataclass [EOL] import sys [EOL] from typing import Union [EOL] [EOL] [EOL] @ dataclass class Node : [EOL] array = ... [EOL] cost = ... [EOL] k = ... [EOL] [EOL] def is_final ( self ) : [EOL] return len ( self . array ) < self . k or all ( [ int ( a ) for a in self . array ] ) [EOL] [EOL] @ property def true_cost ( self ) : [EOL] if len ( self . array ) < self . k : [EOL] return float ( [string] ) [EOL] [EOL] return self . cost [EOL] [EOL] [EOL] def flip_first ( array , k ) : [EOL] return [string] . join ( [ str ( int ( not int ( num ) ) ) for num in array [ : k ] ] ) + array [ k : ] [EOL] [EOL] [EOL] def reduced ( array ) : [EOL] for i in range ( len ( array ) ) : [EOL] if array [ i ] != [string] : [EOL] return array [ i : ] [EOL] [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def visit ( node ) : [EOL] if node . is_final ( ) : [EOL] return node [EOL] [EOL] if node . array [ [number] ] == [string] : [EOL] return Node ( array = reduced ( node . array ) , cost = node . cost , k = node . k ) [EOL] else : [EOL] return Node ( flip_first ( node . array , node . k ) , cost = node . cost + [number] , k = node . k ) [EOL] [EOL] [EOL] [comment] [EOL] def get_cost ( array , k , cost ) : [EOL] stack = [ Node ( array = array , k = k , cost = cost ) ] [EOL] best_node = Node ( array = array , k = k , cost = float ( [string] ) ) [EOL] while stack : [EOL] node = visit ( stack . pop ( ) ) [EOL] if node . is_final ( ) : [EOL] if node . true_cost < best_node . true_cost : [EOL] best_node = node [EOL] [EOL] continue [EOL] [EOL] [comment] [EOL] if node . true_cost > best_node . true_cost : [EOL] continue [EOL] else : [EOL] stack . append ( node ) [EOL] [EOL] return best_node . true_cost [EOL] [EOL] [EOL] def parse ( filename ) : [EOL] with open ( filename ) as f : [EOL] lines = f . readlines ( ) [EOL] [EOL] num_cases = int ( lines [ [number] ] ) [EOL] [EOL] for i in range ( num_cases ) : [EOL] case = lines [ i + [number] ] [EOL] inputs , k = case . split ( [string] ) [EOL] array = [string] . join ( [ [string] if a == [string] else [string] for a in inputs ] ) [EOL] c = get_cost ( array , int ( k ) , cost = [number] ) [EOL] cost = c if c != float ( [string] ) else [string] [EOL] print ( f" [string] { i + [number] } [string] " , cost ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parse ( sys . argv [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[builtins.int,builtins.float]$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from functools import lru_cache [EOL] import heapq [EOL] import math [EOL] import sys [EOL] from typing import Tuple [EOL] [EOL] [EOL] @ lru_cache ( maxsize = None ) def choose_stall ( N ) : [EOL] i = ( N - [number] ) / [number] [EOL] return ( int ( math . ceil ( i ) ) , int ( i ) ) [EOL] [EOL] [EOL] def solve ( N , k ) : [EOL] multiset = [ - N ] [EOL] while k > [number] : [EOL] max_chunk = - heapq . heappop ( multiset ) [EOL] chunks = choose_stall ( max_chunk ) [EOL] k -= [number] [EOL] for chunk in chunks : [EOL] heapq . heappush ( multiset , - chunk ) [EOL] [EOL] return chunks [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def parse ( filename ) : [EOL] with open ( filename ) as f : [EOL] lines = f . readlines ( ) [EOL] [EOL] num_cases = int ( lines [ [number] ] ) [EOL] [EOL] for i in range ( num_cases ) : [EOL] case = lines [ i + [number] ] [EOL] N , k = [ int ( n ) for n in case . strip ( ) . split ( ) ] [EOL] [EOL] result = solve ( N , k ) [EOL] print ( f" [string] { i + [number] } [string] " , result [ [number] ] , result [ [number] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parse ( sys . argv [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Tuple [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] [EOL] def find_adjacent ( row , col , matrix ) : [EOL] R = len ( matrix ) [EOL] C = len ( matrix [ [number] ] ) [EOL] left = ( row - [number] , col ) if row - [number] >= [number] else None [EOL] right = ( row + [number] , col ) if row + [number] < R else None [EOL] up = ( row , col - [number] ) if col - [number] >= [number] else None [EOL] down = ( row , col + [number] ) if col + [number] < C else None [EOL] [EOL] neighbors = [ left , right , up , down ] [EOL] [EOL] [comment] [EOL] return [ e for e in [ matrix [ n [ [number] ] ] [ n [ [number] ] ] for n in neighbors if n ] if e != [string] ] [EOL] [EOL] [EOL] def check ( row , col , matrix , letter ) : [EOL] R = len ( matrix ) [EOL] C = len ( matrix [ [number] ] ) [EOL] top_left = ( row - [number] , col - [number] ) [EOL] left = ( row - [number] , col ) [EOL] bottom_left = ( row + [number] , col - [number] ) [EOL] [EOL] top_right = ( row - [number] , col + [number] ) [EOL] right = ( row + [number] , col ) [EOL] bottom_right = ( row + [number] , col + [number] ) [EOL] [EOL] up = ( row , col - [number] ) [EOL] down = ( row , col + [number] ) [EOL] [EOL] neighbors = [ n for n in [ top_left , left , bottom_left , top_right , right , bottom_right , up , down ] if [number] <= n [ [number] ] < R and [number] <= n [ [number] ] < C and matrix [ n [ [number] ] ] [ n [ [number] ] ] != [string] ] [EOL] [EOL] for i in range ( len ( neighbors ) - [number] ) : [EOL] for j in range ( i + [number] , len ( neighbors ) ) : [EOL] first = neighbors [ i ] [EOL] second = neighbors [ j ] [EOL] if ( matrix [ first [ [number] ] ] [ first [ [number] ] ] == matrix [ second [ [number] ] ] [ second [ [number] ] ] [EOL] and first [ [number] ] != second [ [number] ] [EOL] and first [ [number] ] != second [ [number] ] ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] def simulate ( matrix ) : [EOL] R = len ( matrix ) [EOL] C = len ( matrix [ [number] ] ) [EOL] [EOL] for rowIndex in range ( R ) : [EOL] row = matrix [ rowIndex ] [EOL] for colIndex in range ( C ) : [EOL] cell = row [ colIndex ] [EOL] [EOL] if cell == [string] : [EOL] neighbors = find_adjacent ( rowIndex , colIndex , matrix ) [EOL] for n in neighbors : [EOL] if check ( rowIndex , colIndex , matrix , n ) : [EOL] matrix [ rowIndex ] [ colIndex ] [EOL] [EOL] [EOL] def to_matrix ( m ) : [EOL] return [ [ letter for letter in row ] for row in m . strip ( ) . split ( ) ] [EOL] [EOL] [EOL] matrix = to_matrix ( [string] ) [EOL] [EOL] simulate ( matrix ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0
from typing import Literal , Generator , Union [EOL] import typing [EOL] import edit_distance [EOL] import builtins [EOL] import typing_extensions [EOL] [docstring] [EOL] from contextlib import contextmanager [EOL] from dataclasses import dataclass [EOL] from functools import lru_cache [EOL] import time [EOL] from typing import Generator [EOL] [EOL] [EOL] @ dataclass class Timer : [EOL] duration = ... [EOL] [EOL] [EOL] @ contextmanager def timed ( ) : [EOL] timer = Timer ( duration = [number] ) [EOL] start = time . time ( ) [EOL] try : [EOL] yield timer [EOL] finally : [EOL] end = time . time ( ) [EOL] timer . duration = end - start [EOL] [EOL] [EOL] def solution_recursive ( str1 , str2 ) : [EOL] if not str1 : [EOL] return len ( str2 ) [EOL] [EOL] if not str2 : [EOL] return len ( str1 ) [EOL] [EOL] cost = [number] if str1 [ [number] ] == str2 [ [number] ] else [number] [EOL] return min ( solution_recursive ( str1 [ [number] : ] , str2 ) + [number] , solution_recursive ( str1 , str2 [ [number] : ] ) + [number] , solution_recursive ( str1 [ [number] : ] , str2 [ [number] : ] ) + cost , ) [EOL] [EOL] [EOL] @ lru_cache ( maxsize = None ) def solution_memoized_recursive ( str1 , str2 ) : [EOL] [comment] [EOL] if not str1 : [EOL] return len ( str2 ) [EOL] [EOL] if not str2 : [EOL] return len ( str1 ) [EOL] [EOL] cost = [number] if str1 [ [number] ] == str2 [ [number] ] else [number] [EOL] return min ( solution_memoized_recursive ( str1 [ [number] : ] , str2 ) + [number] , solution_memoized_recursive ( str1 , str2 [ [number] : ] ) + [number] , solution_memoized_recursive ( str1 [ [number] : ] , str2 [ [number] : ] ) + cost , ) [EOL] [EOL] [EOL] def solution_recursive_no_slice ( str1 , len1 , str2 , len2 ) : [EOL] [docstring] [EOL] if not len1 : [EOL] return len2 [EOL] [EOL] if not len2 : [EOL] return len1 [EOL] [EOL] cost = [number] if str1 [ len1 - [number] ] == str2 [ len2 - [number] ] else [number] [EOL] return min ( solution_recursive_no_slice ( str1 , len1 - [number] , str2 , len2 ) + [number] , solution_recursive_no_slice ( str1 , len1 , str2 , len2 - [number] ) + [number] , solution_recursive_no_slice ( str1 , len1 - [number] , str2 , len2 - [number] ) + cost , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] with timed ( ) as timer : [EOL] print ( solution_recursive ( [string] * [number] , [string] * [number] ) ) [EOL] [EOL] print ( [string] , timer ) [EOL] [EOL] with timed ( ) as timer : [EOL] print ( solution_recursive_no_slice ( [string] * [number] , [number] , [string] * [number] , [number] ) ) [EOL] [EOL] print ( [string] , timer ) [EOL] [EOL] with timed ( ) as timer : [EOL] print ( solution_memoized_recursive ( [string] * [number] , [string] * [number] ) ) [EOL] [EOL] print ( [string] , timer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0