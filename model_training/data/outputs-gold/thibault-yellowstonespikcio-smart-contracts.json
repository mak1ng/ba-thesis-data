from typing import Any [EOL] import typing [EOL] [docstring] [EOL] _RATE_1 = [number] [comment] [EOL] _RATE_2 = [number] [comment] [EOL] last_rate = None [comment] [EOL] other_var = [number] [EOL] [EOL] [EOL] def _get_previous_rate ( ) : [comment] [EOL] return last_rate or [number] [EOL] [EOL] [EOL] def compute_rate ( amount ) : [comment] [EOL] [comment] [EOL] global last_rate [EOL] last_rate = _RATE_1 if amount < [number] else _RATE_2 [EOL] return last_rate [EOL] [EOL] [EOL] def reset_last_rate ( ) : [comment] [EOL] global last_rate [EOL] last_rate = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Any [EOL] import argparse [EOL] import typing [EOL] import sys [EOL] import logging [EOL] from os import path [EOL] from argparse import ArgumentParser [EOL] [EOL] from mypy . build import parse , Options [EOL] from mypy . errors import CompileError [EOL] from mypy . nodes import FuncDef , AssignmentStmt , NameExpr , Expression , FloatExpr , IntExpr , StrExpr [EOL] [EOL] [EOL] def _extract_storage_vars ( compiled ) : [EOL] [docstring] [EOL] assignments = [ ( lvalue , def_ . rvalue ) for def_ in compiled . defs if isinstance ( def_ , AssignmentStmt ) for lvalue in def_ . lvalues if isinstance ( lvalue , NameExpr ) if not lvalue . name . startswith ( [string] ) ] [EOL] [EOL] return [ ( lvalue . name , rvalue . value if hasattr ( rvalue , [string] ) else [EOL] rvalue . name if hasattr ( rvalue , [string] ) else [EOL] str ( rvalue ) ) for ( lvalue , rvalue ) in assignments ] [EOL] [EOL] [EOL] def _extract_endpoints ( compiled ) : [EOL] return [ def_ for def_ in compiled . defs if isinstance ( def_ , FuncDef ) if not def_ . name ( ) . startswith ( [string] ) ] [EOL] [EOL] [EOL] def _parse_contract_from_source_insecure ( source_code , filename ) : [EOL] [EOL] logging . debug ( [string] ) [EOL] compiled = parse ( source = source_code , fnam = filename , options = Options ( ) , module = [string] , errors = None ) [EOL] logging . debug ( [string] ) [EOL] [EOL] variable_constants = _extract_storage_vars ( compiled ) [EOL] endpoints = _extract_endpoints ( compiled ) [EOL] return { [string] : True , [string] : [ str ( def_ ) for def_ in variable_constants ] , [string] : { def_ . name ( ) : def_ . type for def_ in endpoints } } [EOL] [EOL] [EOL] def parse_contract_from_source ( source_code , filename = [string] ) : [EOL] try : [EOL] return _parse_contract_from_source_insecure ( source_code , filename ) [EOL] except ( CompileError , ValueError ) as e : [EOL] logging . error ( e ) [EOL] return { [string] : False , [string] : str ( e ) } [EOL] [EOL] [EOL] def parse_contract_from_file ( source_path ) : [EOL] with open ( source_path ) as fd : [EOL] code = fd . read ( ) [EOL] return parse_contract_from_source ( code , path . basename ( source_path ) ) [EOL] [EOL] [EOL] def _parse_args ( ) : [EOL] [docstring] [EOL] parser = ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] args , _ = parser . parse_known_args ( ) [EOL] return args . file [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] logging . basicConfig ( stream = sys . stdout , level = logging . DEBUG , format = [string] ) [EOL] [EOL] args_file = _parse_args ( ) [EOL] parse_result = parse_contract_from_file ( args_file ) [EOL] print ( parse_result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0