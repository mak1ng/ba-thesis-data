from setuptools import setup [EOL] [EOL] setup ( name = [string] , packages = [ [string] ] , version = [string] , include_package_data = True , install_requires = [ [string] , [string] ] , author = [string] , author_email = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] import sys [EOL] sys . path . insert ( [number] , os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) ) [EOL] [EOL] import transaction [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [docstring] [EOL] [EOL] from unittest . mock import ANY , MagicMock , patch [EOL] [EOL] from cloudant . client import CouchDB [EOL] import pytest [EOL] [EOL] from context import transaction [EOL] from transaction . config import cfg [EOL] [EOL] mocked_couch = MagicMock ( spec = CouchDB ) [EOL] [EOL] @ pytest . fixture def transaction_db ( ) : [EOL] cfg [ [string] ] = [string] [EOL] cfg [ [string] ] = [string] [EOL] fixture = transaction . storage . database [EOL] fixture . __client = mocked_couch [EOL] return fixture [EOL] [EOL] @ patch ( [string] ) def test_database_whenconnect_thenconnectcalled ( patch_couch , transaction_db ) : [EOL] transaction_db . connect ( ) [EOL] [EOL] assert patch_couch . call_args == ( { [string] : [string] , [string] : [string] , [string] : ANY , [string] : True } , ) [EOL] [EOL] def test_database_whendisconnect_thendisconnectcalled ( transaction_db ) : [EOL] transaction_db . disconnect ( ) [EOL] [EOL] assert mocked_couch . disconnect . called [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0
import pytest [EOL] [EOL] from context import transaction [EOL] [EOL] @ pytest . fixture def health_controller ( ) : [EOL] return transaction . controllers . health . HealthController ( ) [EOL] [EOL] def test_health_whenok_then200 ( health_controller ) : [EOL] ( __ , resultInt ) = health_controller . ok ( ) [EOL] assert resultInt == [number] [EOL] [EOL] def test_health_whenhealth_then200 ( health_controller ) : [EOL] ( resultJson , resultInt ) = health_controller . health ( ) [EOL] assert resultInt == [number] [EOL] exp_string = [string] [EOL] assert exp_string == resultJson [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] CONFIG_FILE = os . environ . get ( [string] , [string] ) [EOL] [EOL] try : [EOL] with open ( CONFIG_FILE , [string] ) as json_data_file : [EOL] cfg = json . load ( json_data_file ) [EOL] except FileNotFoundError : [EOL] print ( [string] . format ( CONFIG_FILE ) ) [EOL] cfg = { } [EOL] [EOL] for key in [ [string] , [string] , [string] ] : [EOL] if key not in cfg : [EOL] cfg [ key ] = None [EOL] cfg [ key ] = os . environ . get ( key , cfg [ key ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0
import flask [EOL] [docstring] [EOL] [EOL] from flask import Flask [EOL] [EOL] from transaction . controllers . health import HealthController [EOL] from transaction . controllers . transaction import TransactionController [EOL] import config [EOL] [EOL] app = Flask ( __name__ ) [EOL] [EOL] HealthController . register ( app , route_base = [string] ) [EOL] TransactionController . register ( app , route_base = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0
	0
[docstring] [EOL] [EOL] from flask_classful import FlaskView , route [EOL] [EOL] class TransactionController ( FlaskView ) : [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] @ route ( [string] , methods = [ [string] ] ) def post ( self ) : [EOL] return ( [string] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] [EOL] from flask_classful import FlaskView , route [EOL] from typing import Tuple [EOL] [EOL] from transaction . storage import database [EOL] [EOL] class HealthController ( FlaskView ) : [EOL] [docstring] [EOL] [EOL] @ route ( [string] , methods = [ [string] ] ) def ok ( self ) : [EOL] return ( [string] , [number] ) [EOL] [EOL] @ route ( [string] , methods = [ [string] ] ) def health ( self ) : [EOL] result = { [string] : True } [EOL] return ( json . dumps ( result , indent = [number] ) , [number] ) [EOL] [EOL] @ route ( [string] , methods = [ [string] ] ) def db_health ( self ) : [EOL] if not database . connect ( ) : [EOL] return ( json . dumps ( { [string] : False } ) , [number] ) [EOL] ( result , info ) = database . health ( ) [EOL] database . disconnect ( ) [EOL] if not result : [EOL] return ( json . dumps ( { [string] : False } ) , [number] ) [EOL] return ( json . dumps ( info , indent = [number] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from cloudant . client import CouchDB [EOL] from typing import Tuple [EOL] [EOL] from transaction . config import cfg [EOL] [EOL] __client = ... [EOL] [EOL] def connect ( ) : [EOL] global __client [EOL] try : [EOL] __client = CouchDB ( user = cfg [ [string] ] , auth_token = cfg [ [string] ] , url = cfg [ [string] ] , connect = True ) [EOL] except : [EOL] return False [EOL] return True [EOL] [EOL] def health ( ) : [EOL] result = __client . session ( ) [EOL] if [string] not in result : [EOL] return ( False , { } ) [EOL] return ( True , result ) [EOL] [EOL] def disconnect ( ) : [EOL] __client . disconnect ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cloudant.client.CouchDB$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $cloudant.client.CouchDB$ 0 0 0 0 $cloudant.client.CouchDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bool,builtins.dict]$ 0 0 0 0 0 0 $cloudant.client.CouchDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $cloudant.client.CouchDB$ 0 0 0 0 0