[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Iterable , List , Dict , Counter [EOL] import collections [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import subprocess [EOL] [docstring] [EOL] [EOL] import os [EOL] import shutil [EOL] import subprocess [EOL] import sys [EOL] from collections import Counter [EOL] from glob import iglob [EOL] from pathlib import Path [EOL] [EOL] import click [EOL] from click import secho , style [EOL] from kedro . cli import main as kedro_main [EOL] from kedro . cli . utils import ( KedroCliError , call , forward_command , python_call , export_nodes , ) [EOL] from kedro . utils import load_obj [EOL] from kedro . runner import SequentialRunner [EOL] from typing import Iterable , List [EOL] [EOL] CONTEXT_SETTINGS = dict ( help_option_names = [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] PROJ_PATH = Path ( __file__ ) . resolve ( ) . parent [EOL] sys . path . insert ( [number] , str ( PROJ_PATH / [string] ) ) [EOL] os . environ [ [string] ] = ( str ( PROJ_PATH / [string] ) + os . pathsep + os . environ . get ( [string] , [string] ) ) [EOL] os . environ [ [string] ] = str ( PROJ_PATH / [string] ) [EOL] [EOL] [EOL] NO_PYTEST_MESSAGE = [string] [EOL] [EOL] NO_NBSTRIPOUT_MESSAGE = [string] [EOL] [EOL] TAG_ARG_HELP = [string] [EOL] [EOL] ENV_ARG_HELP = [string] [EOL] [EOL] NODE_ARG_HELP = [string] [EOL] [EOL] FROM_NODES_HELP = [string] [EOL] [EOL] TO_NODES_HELP = [string] [EOL] [EOL] PARALLEL_ARG_HELP = [string] [EOL] [EOL] RUNNER_ARG_HELP = [string] [EOL] [EOL] CONVERT_ALL_HELP = [string] [EOL] [EOL] OVERWRITE_HELP = [string] [EOL] [EOL] [EOL] @ click . group ( context_settings = CONTEXT_SETTINGS , name = __file__ ) def cli ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ cli . command ( ) @ click . option ( [string] , type = str , default = [string] , help = FROM_NODES_HELP ) @ click . option ( [string] , type = str , default = [string] , help = TO_NODES_HELP ) @ click . option ( [string] , [string] , [string] , type = str , default = None , multiple = True , help = NODE_ARG_HELP , ) @ click . option ( [string] , [string] , type = str , default = None , multiple = False , help = RUNNER_ARG_HELP ) @ click . option ( [string] , [string] , is_flag = True , multiple = False , help = PARALLEL_ARG_HELP ) @ click . option ( [string] , [string] , type = str , default = None , multiple = False , help = ENV_ARG_HELP ) @ click . option ( [string] , [string] , type = str , default = None , multiple = True , help = TAG_ARG_HELP ) def run ( tag , env , parallel , runner , node_names , to_nodes , from_nodes ) : [EOL] [docstring] [EOL] from futbolean . run import main [EOL] from_nodes = [ n for n in from_nodes . split ( [string] ) if n ] [EOL] to_nodes = [ n for n in to_nodes . split ( [string] ) if n ] [EOL] [EOL] if parallel and runner : [EOL] raise KedroCliError ( [string] [string] ) [EOL] if parallel : [EOL] runner = [string] [EOL] runner_class = load_obj ( runner , [string] ) if runner else SequentialRunner [EOL] [EOL] main ( tags = tag , env = env , runner = runner_class ( ) , node_names = node_names , from_nodes = from_nodes , to_nodes = to_nodes , ) [EOL] [EOL] [EOL] @ forward_command ( cli , forward_help = True ) def test ( args ) : [EOL] [docstring] [EOL] try : [EOL] import pytest [comment] [EOL] except ImportError : [EOL] raise KedroCliError ( NO_PYTEST_MESSAGE ) [EOL] else : [EOL] python_call ( [string] , args ) [EOL] [EOL] [EOL] @ cli . command ( ) def install ( ) : [EOL] [docstring] [EOL] [EOL] if ( Path . cwd ( ) / [string] / [string] ) . is_file ( ) : [EOL] call ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] python_call ( [string] , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] @ forward_command ( cli , forward_help = True ) def ipython ( args ) : [EOL] [docstring] [EOL] if [string] not in args and [string] not in args : [EOL] ipython_message ( ) [EOL] call ( [ [string] ] + list ( args ) ) [EOL] [EOL] [EOL] @ cli . command ( ) def package ( ) : [EOL] [docstring] [EOL] call ( [ sys . executable , [string] , [string] , [string] , [string] ] , cwd = [string] ) [EOL] call ( [ sys . executable , [string] , [string] , [string] , [string] ] , cwd = [string] ) [EOL] [EOL] [EOL] @ cli . command ( [string] ) def build_docs ( ) : [EOL] [docstring] [EOL] python_call ( [string] , [ [string] , [string] ] ) [EOL] python_call ( [string] , [ [string] , [string] , [string] ] ) [EOL] python_call ( [string] , [ [string] , [string] , [string] ] ) [EOL] if Path ( [string] ) . exists ( ) : [EOL] shutil . rmtree ( [string] ) [EOL] call ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] call ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] @ cli . command ( [string] ) def build_reqs ( ) : [EOL] [docstring] [EOL] requirements_path = Path . cwd ( ) / [string] / [string] [EOL] if not requirements_path . is_file ( ) : [EOL] secho ( [string] ) [EOL] contents = ( Path . cwd ( ) / [string] / [string] ) . read_text ( ) [EOL] requirements_path . write_text ( contents ) [EOL] python_call ( [string] , [ [string] , str ( requirements_path ) ] ) [EOL] secho ( ( [string] [string] [string] ) ) [EOL] [EOL] [EOL] @ cli . command ( [string] ) def activate_nbstripout ( ) : [EOL] [docstring] [EOL] secho ( ( [string] [string] ) , fg = [string] , ) [EOL] [EOL] try : [EOL] import nbstripout [comment] [EOL] except ImportError : [EOL] raise KedroCliError ( NO_NBSTRIPOUT_MESSAGE ) [EOL] [EOL] try : [EOL] res = subprocess . run ( [ [string] , [string] , [string] ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE , ) [EOL] if res . returncode : [EOL] raise KedroCliError ( [string] ) [EOL] except FileNotFoundError : [EOL] raise KedroCliError ( [string] ) [EOL] [EOL] call ( [ [string] , [string] ] ) [EOL] [EOL] [EOL] def _build_jupyter_command ( base , ip , all_kernels , args ) : [EOL] cmd = [ base , [string] + ip ] [EOL] [EOL] if not all_kernels : [EOL] cmd . append ( [string] ) [EOL] [EOL] return cmd + list ( args ) [EOL] [EOL] [EOL] @ cli . group ( ) def jupyter ( ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ forward_command ( jupyter , [string] , forward_help = True ) @ click . option ( [string] , type = str , default = [string] ) @ click . option ( [string] , is_flag = True , default = False ) def jupyter_notebook ( ip , all_kernels , args ) : [EOL] [docstring] [EOL] if [string] not in args and [string] not in args : [EOL] ipython_message ( all_kernels ) [EOL] [EOL] call ( _build_jupyter_command ( [string] , ip = ip , all_kernels = all_kernels , args = args ) ) [EOL] [EOL] [EOL] @ forward_command ( jupyter , [string] , forward_help = True ) @ click . option ( [string] , type = str , default = [string] ) @ click . option ( [string] , is_flag = True , default = False ) def jupyter_lab ( ip , all_kernels , args ) : [EOL] [docstring] [EOL] if [string] not in args and [string] not in args : [EOL] ipython_message ( all_kernels ) [EOL] [EOL] call ( _build_jupyter_command ( [string] , ip = ip , all_kernels = all_kernels , args = args ) ) [EOL] [EOL] [EOL] @ jupyter . command ( [string] ) @ click . option ( [string] , [string] , is_flag = True , help = CONVERT_ALL_HELP ) @ click . option ( [string] , [string] , is_flag = True , help = OVERWRITE_HELP ) @ click . argument ( [string] , type = click . Path ( exists = True , dir_okay = False , resolve_path = True ) , required = False , nargs = - [number] , ) def convert_notebook ( all_flag , overwrite_flag , filepath ) : [EOL] [docstring] [EOL] from futbolean . run import ProjectContext [EOL] if not filepath and not all_flag : [EOL] secho ( [string] [string] ) [EOL] return [EOL] [EOL] kedro_project_path = ProjectContext ( Path . cwd ( ) ) . project_path [EOL] kedro_package_name = [string] [EOL] [EOL] if all_flag : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pattern = kedro_project_path / [string] / [string] [EOL] notebooks = sorted ( Path ( p ) for p in iglob ( str ( pattern ) , recursive = True ) ) [EOL] else : [EOL] notebooks = [ Path ( f ) for f in filepath ] [EOL] [EOL] counter = Counter ( n . stem for n in notebooks ) [EOL] non_unique_names = [ name for name , counts in counter . items ( ) if counts > [number] ] [EOL] if non_unique_names : [EOL] raise KedroCliError ( [string] [string] . format ( [string] . join ( non_unique_names ) ) ) [EOL] [EOL] for notebook in notebooks : [EOL] secho ( [string] . format ( str ( notebook ) ) ) [EOL] output_path = ( kedro_project_path / [string] / kedro_package_name / [string] / [string] . format ( notebook . stem ) ) [EOL] [EOL] if output_path . is_file ( ) : [EOL] overwrite = overwrite_flag or click . confirm ( [string] . format ( str ( output_path ) ) , default = False , ) [EOL] if overwrite : [EOL] export_nodes ( notebook , output_path ) [EOL] else : [EOL] export_nodes ( notebook , output_path ) [EOL] [EOL] secho ( [string] ) [EOL] [EOL] [EOL] def ipython_message ( all_kernels = True ) : [EOL] [docstring] [EOL] ipy_vars = [ [string] , [string] ] [EOL] secho ( [string] * [number] , fg = [string] ) [EOL] secho ( [string] ) [EOL] secho ( [string] . join ( ipy_vars ) , fg = [string] ) [EOL] secho ( [string] . format ( style ( [string] , fg = [string] ) ) ) [EOL] secho ( [string] ) [EOL] [EOL] if not all_kernels : [EOL] secho ( [string] , fg = [string] ) [EOL] secho ( [string] , fg = [string] ) [EOL] [EOL] secho ( [string] * [number] , fg = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] os . chdir ( str ( PROJ_PATH ) ) [EOL] kedro_main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0
from typing import Any [EOL] import pathlib [EOL] import typing [EOL] import logging . config [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] from IPython . core . magic import register_line_magic [EOL] [EOL] from kedro . context import load_context [EOL] [EOL] [EOL] @ register_line_magic def reload_kedro ( project_path , line = None ) : [EOL] [docstring] [EOL] global startup_error [EOL] global context [EOL] try : [EOL] import kedro . config . default_logger [EOL] from kedro . context import load_context [EOL] [EOL] context = load_context ( project_path ) [EOL] [EOL] logging . info ( [string] . format ( context . project_name ) ) [EOL] [EOL] logging . info ( [string] ) [EOL] except ImportError : [EOL] logging . error ( [string] [string] ) [EOL] raise [EOL] except Exception as err : [EOL] startup_error = err [EOL] logging . error ( [string] , str ( err ) ) [EOL] raise err [EOL] [EOL] [EOL] [comment] [EOL] startup_error = None [EOL] project_path = Path ( __file__ ) . parents [ [number] ] . resolve ( ) [EOL] reload_kedro ( project_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] entry_point = [string] [EOL] [EOL] [comment] [EOL] with open ( [string] , [string] , encoding = [string] ) as f : [EOL] requires = [ x . strip ( ) for x in f if x . strip ( ) ] [EOL] [EOL] setup ( name = [string] , version = [string] , packages = find_packages ( exclude = [ [string] ] ) , entry_points = { [string] : [ entry_point ] } , install_requires = requires , extras_require = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Iterable [EOL] import kedro [EOL] import builtins [EOL] import typing [EOL] import data_science [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] from typing import Iterable [EOL] [EOL] from kedro . context import KedroContext [EOL] from kedro . runner import AbstractRunner [EOL] from kedro . pipeline import Pipeline [EOL] [EOL] from futbolean . pipeline import create_pipeline [EOL] [EOL] [EOL] class ProjectContext ( KedroContext ) : [EOL] [docstring] [EOL] [EOL] project_name = [string] [EOL] project_version = [string] [EOL] [EOL] @ property def pipeline ( self ) : [EOL] return create_pipeline ( ) [EOL] [EOL] [EOL] def main ( tags = None , env = None , runner = None , node_names = None , from_nodes = None , to_nodes = None , ) : [EOL] [docstring] [EOL] context = ProjectContext ( Path . cwd ( ) , env ) [EOL] [EOL] return context . run ( tags , runner , node_names , from_nodes , to_nodes ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $kedro.pipeline.Pipeline$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import os [EOL] [EOL] [EOL] BASE_DIR = os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] RAW_DATA_DIR = os . path . join ( BASE_DIR , [string] ) [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from kedro . pipeline import Pipeline , node [EOL] [EOL] [EOL] def create_pipeline ( ** _kwargs ) : [EOL] [docstring] [EOL] [EOL] pipeline = Pipeline ( [ node ( lambda * x : x , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] , ) ] ) [EOL] [EOL] return pipeline [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . json_remote_data_set import JSONRemoteDataSet [EOL]	0 0 0 0 0 0
from typing import Callable , Union , Any , List , Dict [EOL] import builtins [EOL] import typing [EOL] import pandas [EOL] import _importlib_modulespec [EOL] [docstring] [EOL] [EOL] from typing import Any , List , Dict , Callable , Union [EOL] import importlib [EOL] [EOL] import pandas as pd [EOL] from kedro . io . core import AbstractDataSet [EOL] [EOL] [EOL] MODULE_SEPARATOR = [string] [EOL] [EOL] [EOL] class JSONRemoteDataSet ( AbstractDataSet ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data_source , load_kwargs = { } , ** _kwargs ) : [EOL] self . _load_kwargs = load_kwargs [EOL] [EOL] if callable ( data_source ) : [EOL] self . data_source = data_source [EOL] else : [EOL] path_parts = data_source . split ( MODULE_SEPARATOR ) [EOL] function_name = path_parts [ - [number] ] [EOL] module_path = MODULE_SEPARATOR . join ( path_parts [ : - [number] ] ) [EOL] module = importlib . import_module ( module_path ) [EOL] [EOL] self . data_source = getattr ( module , function_name ) [EOL] [EOL] def _load ( self ) : [EOL] return self . data_source ( ** self . _load_kwargs ) [EOL] [EOL] def _save ( self , data ) : [EOL] pass [EOL] [EOL] def _describe ( self ) : [EOL] return self . _load_kwargs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import builtins [EOL] import requests [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import Dict , Any , List , Union [EOL] import time [EOL] [EOL] import requests [EOL] [EOL] [EOL] LOCAL_AFL_DATA_SERVICE = [string] [EOL] [EOL] [EOL] class DataRequestError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] def _handle_response_data ( response ) : [EOL] parsed_response = response . json ( ) [EOL] [EOL] error = parsed_response . get ( [string] ) [EOL] [EOL] if error is not None and any ( error ) : [EOL] raise DataRequestError ( error ) [EOL] [EOL] return parsed_response [EOL] [EOL] [EOL] def _make_request ( url , params = { } , headers = { } , retry = True ) : [EOL] response = requests . get ( url , params = params , headers = headers ) [EOL] [EOL] if response . status_code != [number] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if retry : [EOL] time . sleep ( [number] ) [EOL] _make_request ( url , params = params , headers = headers , retry = False ) [EOL] [EOL] raise RuntimeError ( [string] f"{ response . status_code } [string] { response . headers } [string] { response . text }" ) [EOL] [EOL] return response [EOL] [EOL] [EOL] def fetch_data ( path , params = { } ) : [EOL] [docstring] [EOL] [EOL] service_host = LOCAL_AFL_DATA_SERVICE [EOL] headers = { } [EOL] [EOL] service_url = service_host + path [EOL] response = _make_request ( service_url , params = params , headers = headers ) [EOL] [EOL] return _handle_response_data ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . import epl_player_data [EOL]	0 0 0 0 0
	0
[comment] [EOL] [EOL] [EOL] [docstring] [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] from futbolean . run import ProjectContext [EOL] [EOL] [EOL] @ pytest . fixture def project_context ( ) : [EOL] return ProjectContext ( str ( Path . cwd ( ) ) ) [EOL] [EOL] [EOL] class TestProjectContext : [EOL] @ staticmethod def test_project_name ( project_context ) : [EOL] assert project_context . project_name == [string] [EOL] [EOL] @ staticmethod def test_project_version ( project_context ) : [EOL] assert project_context . project_version == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import unittest [EOL] import typing [EOL] from unittest import TestCase [EOL] from unittest . mock import MagicMock , patch [EOL] [EOL] from futbolean . io . json_remote_data_set import JSONRemoteDataSet [EOL] [EOL] [EOL] class TestJSONRemoteDataSet ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . start_season = [string] [EOL] self . end_season = [string] [EOL] self . data_source = MagicMock ( ) [EOL] self . data_set = JSONRemoteDataSet ( data_source = self . data_source , load_kwargs = { [string] : self . start_season , [string] : self . end_season , } , ) [EOL] [EOL] def test_load ( self ) : [EOL] self . data_set . load ( ) [EOL] [EOL] self . data_source . assert_called_with ( start_season = [string] , end_season = [string] ) [EOL] [EOL] with self . subTest ( [string] ) : [EOL] data_source_path = ( [string] ) [EOL] [EOL] with patch ( data_source_path ) : [EOL] data_set = JSONRemoteDataSet ( load_kwargs = { [string] : [string] , [string] : [string] , } , data_source = data_source_path , ) [EOL] [EOL] data_set . load ( ) [EOL] [EOL] data_set . data_source . assert_called_with ( start_season = [string] , end_season = [string] ) [EOL] [EOL] def test_save ( self ) : [EOL] self . data_set . save ( { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import os [EOL] from unittest import TestCase [EOL] from unittest . mock import patch , mock_open [EOL] import json [EOL] [EOL] from futbolean . data_import . epl_player_data import ( save_player_urls , save_player_match_data , ) [EOL] from futbolean . settings import BASE_DIR , RAW_DATA_DIR [EOL] [EOL] [EOL] START_SEASON = [string] [EOL] END_SEASON = [string] [EOL] EPL_PLAYER_DATA_MODULE_PATH = [string] [EOL] EPL_PLAYER_DATA_PATH = os . path . join ( BASE_DIR , [string] ) [EOL] [EOL] [EOL] class TestEplPlayerData ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . url_filepath = os . path . join ( EPL_PLAYER_DATA_PATH , [string] ) [EOL] self . fake_player_urls = json . load ( open ( self . url_filepath , [string] ) ) [EOL] [EOL] player_data_filepath = os . path . join ( EPL_PLAYER_DATA_PATH , [string] ) [EOL] self . fake_player_match_data = json . load ( open ( player_data_filepath , [string] ) ) [EOL] [EOL] @ patch ( f"{ EPL_PLAYER_DATA_MODULE_PATH } [string] " ) @ patch ( [string] , mock_open ( ) ) @ patch ( [string] ) def test_save_player_urls ( self , _mock_json_dump , mock_fetch_data ) : [EOL] mock_fetch_data . return_value = { [string] : self . fake_player_urls , [string] : [string] , } [EOL] [EOL] save_player_urls ( start_season = START_SEASON , end_season = END_SEASON , verbose = [number] ) [EOL] [EOL] mock_fetch_data . assert_called_with ( START_SEASON , END_SEASON , verbose = [number] ) [EOL] [EOL] data_filepath = os . path . join ( RAW_DATA_DIR , f" [string] { START_SEASON } [string] { END_SEASON } [string] " ) [EOL] open . assert_called_with ( data_filepath , [string] ) [EOL] dump_args , _dump_kwargs = json . dump . call_args [EOL] self . assertIn ( self . fake_player_urls , dump_args ) [EOL] [EOL] @ patch ( f"{ EPL_PLAYER_DATA_MODULE_PATH } [string] " ) @ patch ( [string] , mock_open ( ) ) @ patch ( [string] ) @ patch ( [string] ) def test_save_player_match_data ( self , _mock_json_dump , mock_json_load , mock_fetch_data ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mock_json_load . side_effect = [ self . fake_player_urls , [ ] ] [EOL] mock_fetch_data . return_value = ( { [string] : self . fake_player_match_data , [string] : [string] } , None , ) [EOL] [EOL] skipped_url_filepath = os . path . join ( EPL_PLAYER_DATA_PATH , [string] ) [EOL] save_player_match_data ( player_url_filepath = self . url_filepath , skipped_url_filepath = skipped_url_filepath , verbose = [number] , ) [EOL] [EOL] mock_fetch_data . assert_called_with ( self . fake_player_urls , verbose = [number] ) [EOL] [EOL] data_filepath = os . path . join ( RAW_DATA_DIR , f" [string] { START_SEASON } [string] { END_SEASON } [string] " ) [EOL] open . assert_called_with ( data_filepath , [string] , encoding = [string] ) [EOL] dump_args , _dump_kwargs = json . dump . call_args [EOL] self . assertIn ( self . fake_player_match_data , dump_args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0