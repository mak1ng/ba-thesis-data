from typing import Any [EOL] import typing [EOL] import logging [EOL] import asyncio [EOL] import asyncio [EOL] import logging [EOL] [EOL] import click [EOL] [EOL] from app import app , clients [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ click . group ( ) def cli ( ) : [EOL] pass [EOL] [EOL] [EOL] @ cli . add_command @ click . command ( ) def runserver ( ) : [EOL] app . runserver ( ) [EOL] [EOL] [EOL] @ cli . add_command @ click . command ( ) def runclient ( ) : [EOL] async def fetch ( ) : [EOL] fetcher = clients . Fetcher ( [string] ) [EOL] try : [EOL] headers , text = await fetcher . fetch ( [string] ) [EOL] log . info ( [string] , headers ) [EOL] log . info ( [string] , text ) [EOL] log . info ( [string] , type ( text ) ) [EOL] finally : [EOL] await fetcher . close ( ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( fetch ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] cli ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] import re [EOL] [EOL] from aiohttp import web [EOL] [EOL] from app import settings , views [EOL] from app . clients import Fetcher [EOL] [EOL] [EOL] def runserver ( ) : [EOL] web . run_app ( make_app ( ) , host = settings . APP_HOST , port = settings . APP_PORT ) [EOL] [EOL] [EOL] def make_app ( ) : [EOL] app = web . Application ( ) [EOL] [EOL] app . add_routes ( [ web . get ( [string] , views . habra_proxy_handler ) , ] ) [EOL] [EOL] app . on_startup . append ( on_startup ) [EOL] app . on_cleanup . append ( on_cleanup ) [EOL] return app [EOL] [EOL] [EOL] async def on_startup ( app ) : [EOL] app [ [string] ] = Fetcher ( [string] ) [EOL] [comment] [EOL] app [ [string] ] = re . compile ( [string] ) [EOL] [EOL] [EOL] async def on_cleanup ( app ) : [EOL] await app [ [string] ] . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import multidict [EOL] import asyncio [EOL] import logging [EOL] import builtins [EOL] import asyncio [EOL] import logging [EOL] import ssl [EOL] from typing import Tuple [EOL] [EOL] import aiohttp [EOL] import multidict [EOL] from furl import furl [EOL] [EOL] from app import settings [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Fetcher : [EOL] def __init__ ( self , base_url ) : [EOL] self . base_url = base_url [EOL] self . semaphore = asyncio . Semaphore ( settings . MAX_CONNECTIONS_BY_FETCHER ) [EOL] self . session = aiohttp . ClientSession ( connector = aiohttp . TCPConnector ( verify_ssl = True ) ) [EOL] self . request_params = { [string] : ssl . create_default_context ( purpose = ssl . Purpose . CLIENT_AUTH ) , [string] : settings . CONNECTION_TIMOUT , } [EOL] log . info ( [string] , base_url , self . request_params ) [EOL] [EOL] async def fetch ( self , path ) : [EOL] url = furl ( self . base_url ) . add ( path = path ) . url [EOL] [EOL] log . info ( [string] , url ) [EOL] async with self . semaphore : [EOL] async with self . session . get ( url , ** self . request_params ) as response : [comment] [EOL] return response . status , response . headers , await response . read ( ) [EOL] [EOL] async def close ( self ) : [EOL] await self . session . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $asyncio.locks.Semaphore$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,multidict.CIMultiDictProxy,builtins.bytes]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Any , Iterable [EOL] import typing [EOL] import re [EOL] import builtins [EOL] import re [EOL] from typing import Iterable [EOL] [EOL] from bs4 import BeautifulSoup , element [EOL] [EOL] [EOL] def add_symbols ( text , symbol , searcher , ignore_tags = frozenset ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , ignore_tag_types = ( element . Doctype , element . Comment , element . Declaration ) , ) : [EOL] soup = BeautifulSoup ( text , [string] ) [EOL] [EOL] for tag in soup . findAll ( text = True ) : [EOL] if tag . parent . name in ignore_tags or type ( tag ) in ignore_tag_types : [EOL] continue [EOL] [EOL] edited_text = searcher . sub ( lambda matched : matched . group ( [number] ) + symbol , tag . string ) [EOL] tag . replace_with ( edited_text ) [EOL] return soup . prettify ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import typing [EOL] import os [EOL] [EOL] MAX_CONNECTIONS_BY_FETCHER = [number] [EOL] CONNECTION_TIMOUT = [number] [EOL] [EOL] BASE_PROXY_HEADERS = { [string] , [string] , [string] } [EOL] [EOL] APP_HOST = os . environ . get ( [string] , [string] ) [EOL] APP_PORT = int ( os . environ . get ( [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from aiohttp import web [EOL] [EOL] from app import settings [EOL] from app . helpers import add_symbols [EOL] [EOL] [EOL] async def habra_proxy_handler ( request ) : [EOL] path = request . match_info [ [string] ] [EOL] [EOL] habra_status_code , habra_headers , habra_body = await request . app [ [string] ] . fetch ( path ) [EOL] response_headers = { header : habra_headers [ header ] for header in settings . BASE_PROXY_HEADERS if header in habra_headers } [EOL] [EOL] if not is_html_response ( habra_headers ) : [EOL] return web . Response ( body = habra_body , status = habra_status_code , headers = response_headers ) [EOL] [EOL] habra_text = habra_body . decode ( [string] ) [EOL] habra_text = habra_text . replace ( [string] , f' [string] { settings . APP_HOST } [string] { settings . APP_PORT } [string] ' , ) [EOL] habra_text = add_symbols ( habra_text , symbol = [string] , searcher = request . app [ [string] ] ) [EOL] return web . Response ( text = habra_text , status = habra_status_code , headers = response_headers ) [EOL] [EOL] [EOL] def is_html_response ( headers ) : [EOL] return [string] in headers . get ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] from dataclasses import dataclass [EOL] from typing import Dict [EOL] from unittest import mock [EOL] [EOL] [EOL] @ dataclass class MockedFetcher : [EOL] mocked_fetch = ... [EOL] [EOL] def add_return_values ( self , status_code , headers , body ) : [EOL] async def coro ( ) : [EOL] return status_code , headers , body [EOL] self . mocked_fetch . return_value = coro ( ) [EOL] [EOL] def check_call_with ( self , path ) : [EOL] self . mocked_fetch . assert_called_with ( path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $typing.Dict$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import tests [EOL] import typing [EOL] import aiohttp [EOL] import builtins [EOL] import re [EOL] [EOL] import pytest [EOL] from aiohttp import test_utils [EOL] [EOL] from app . helpers import add_symbols [EOL] from tests . helpers import MockedFetcher [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , ] ) async def test_called_with_path ( client , mocked_habra_fetch , path ) : [EOL] mocked_habra_fetch . add_return_values ( status_code = [number] , headers = { [string] : [string] } , body = [string] , ) [EOL] response = await client . get ( path ) [EOL] assert response . status == [number] [EOL] mocked_habra_fetch . check_call_with ( path . replace ( [string] , [string] , [number] ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) async def test_correct_texts ( client , mocked_habra_fetch , habra_body , expected_text ) : [EOL] mocked_habra_fetch . add_return_values ( status_code = [number] , headers = { [string] : [string] } , body = habra_body , ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == [number] [EOL] [EOL] response_text = await response . text ( ) [EOL] assert response_text . replace ( [string] , [string] ) == expected_text [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] , [number] , ] ) async def test_correct_response_code ( client , mocked_habra_fetch , habra_status_code , ) : [EOL] mocked_habra_fetch . add_return_values ( status_code = habra_status_code , headers = { [string] : [string] } , body = [string] , ) [EOL] response = await client . get ( [string] ) [EOL] assert response . status == habra_status_code [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [string] , re . compile ( [string] ) ) , ( [string] , [string] , [string] , re . compile ( [string] ) ) , ] ) async def test_words_add_symbols ( text , add_symbol , expected_text , searcher ) : [EOL] assert add_symbols ( text , add_symbol , searcher = searcher ) == expected_text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Generator [EOL] import tests [EOL] import typing [EOL] import aiohttp [EOL] from typing import Generator [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] from aiohttp . web_app import Application [EOL] [EOL] from app . app import make_app [EOL] from tests . helpers import MockedFetcher [EOL] [EOL] [EOL] @ pytest . fixture async def app ( ) : [EOL] return make_app ( ) [EOL] [EOL] [EOL] @ pytest . fixture def client ( loop , aiohttp_client , app ) : [EOL] return loop . run_until_complete ( aiohttp_client ( app ) ) [EOL] [EOL] [EOL] @ pytest . fixture def mocked_habra_fetch ( app ) : [EOL] with mock . patch . object ( app [ [string] ] , [string] ) as mocked_fetch : [EOL] yield MockedFetcher ( mocked_fetch ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web_app.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[tests.helpers.MockedFetcher,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0