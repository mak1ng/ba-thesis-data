from typing import Any , List [EOL] import typing [EOL] import os [EOL] [EOL] here = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] [EOL] here_include_paths = [ [string] , [string] , [string] ] [EOL] [EOL] include_paths = [ ] [EOL] include_paths += [ [string] + os . path . join ( here , hip ) for hip in here_include_paths ] [EOL] [EOL] def FlagsForFile ( filename , ** kwargs ) : [EOL] return { [string] : [ [string] , [string] , [string] , [string] , [string] ] + include_paths } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0
import os [EOL] import setuptools [EOL] [EOL] version = os . environ . get ( [string] , [string] ) [EOL] [EOL] setuptools . setup ( name = [string] , version = version , description = [string] , author = [string] , url = [string] , packages = setuptools . find_packages ( ) , ) [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type , List [EOL] import pymbolic [EOL] import typing [EOL] import multiprocessing [EOL] import tvb_hpc [EOL] import enum [comment] [EOL] import os . path [EOL] import numpy as np [EOL] import logging [EOL] import time [EOL] import pymbolic as pm [EOL] import loopy as lp [EOL] from pymbolic import parse [EOL] from pymbolic . mapper . stringifier import SimplifyingSortingStringifyMapper [EOL] from pymbolic . mapper import IdentityMapper [EOL] from sympy . parsing . sympy_parser import parse_expr [EOL] [EOL] [EOL] here = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] include_dir = os . path . normpath ( os . path . join ( here , [string] , [string] ) ) [EOL] [EOL] [EOL] default_target = lp . target . pyopencl . PyOpenCLTarget [EOL] [EOL] [EOL] def can_bcast ( n , m ) : [EOL] return ( n == [number] ) or ( m == [number] ) or ( n == m ) [EOL] [EOL] [EOL] def getLogger ( name ) : [EOL] return logging . getLogger ( name ) [EOL] [EOL] [EOL] class NoSuchExecutable ( RuntimeError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def which ( exe ) : [EOL] [docstring] [EOL] if os . path . exists ( exe ) : [EOL] return exe [EOL] for path in os . environ [ [string] ] . split ( os . path . pathsep ) : [EOL] maybe_path = os . path . join ( path , exe ) [EOL] if os . path . exists ( maybe_path ) : [EOL] return maybe_path [EOL] raise NoSuchExecutable ( exe ) [EOL] [EOL] [EOL] def simplify ( expr ) : [EOL] [docstring] [EOL] [comment] [EOL] parts = SimplifyingSortingStringifyMapper ( ) ( expr ) [EOL] simplified = parse_expr ( parts ) . simplify ( ) [EOL] return parse ( repr ( simplified ) ) [EOL] [EOL] [EOL] def vars ( svars ) : [EOL] [docstring] [EOL] return np . array ( [ pm . var ( var ) for var in svars . split ( ) ] ) [EOL] [EOL] [EOL] def exprs ( sexprs ) : [EOL] [docstring] [EOL] exprs = [ ] [EOL] for expr in sexprs : [EOL] if isinstance ( expr , ( int , float ) ) : [EOL] exprs . append ( expr ) [EOL] else : [EOL] try : [EOL] exprs . append ( pm . parse ( expr ) ) [EOL] except Exception as exc : [EOL] raise Exception ( repr ( expr ) ) [EOL] return np . array ( exprs ) [EOL] [EOL] [EOL] class timer : [EOL] logger = getLogger ( [string] ) [EOL] [EOL] def __init__ ( self , msg = [string] ) : [EOL] self . msg = msg [EOL] [EOL] def __enter__ ( self , * args ) : [EOL] self . tic = time . time ( ) [EOL] return self [EOL] [EOL] def __exit__ ( self , * args ) : [EOL] toc = time . time ( ) [EOL] self . elapsed = toc - self . tic [EOL] msg = [string] [EOL] self . logger . info ( msg , self . msg , self . elapsed ) [EOL] [EOL] [EOL] class VarSubst ( IdentityMapper ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , verbose = False , ** substs ) : [EOL] self . verbose = verbose [EOL] self . substs = substs [EOL] [EOL] def map_variable ( self , var , * args , ** kwargs ) : [EOL] if self . verbose : [EOL] print ( var . name ) [EOL] return self . substs . get ( var . name , var ) [EOL] [EOL] [EOL] def subst_vars ( expr , ** var_name_to_exprs ) : [EOL] expr = pm . parse ( str ( expr ) ) [EOL] return VarSubst ( ** var_name_to_exprs ) ( expr ) [EOL] [EOL] [EOL] def scaling ( ary ) : [EOL] [docstring] [EOL] lin , _ = np . histogram ( ary . flat [ : ] , [number] ) [EOL] log , _ = np . histogram ( np . log ( ary . flat [ : ] + [number] ) , [number] ) [EOL] if np . std ( lin / lin . max ( ) ) > np . std ( log / log . max ( ) ) : [EOL] return [string] [EOL] return [string] [EOL] [EOL] [EOL] def loadtxt_many ( fnames ) : [EOL] [docstring] [EOL] if isinstance ( fnames , str ) : [EOL] import glob [EOL] fnames = glob . glob ( fnames ) [EOL] import multiprocessing [EOL] import numpy [EOL] pool = multiprocessing . Pool ( ) [EOL] arrays = pool . map ( numpy . loadtxt , fnames ) [EOL] pool . close ( ) [EOL] return arrays [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tvb_hpc.utils.timer]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymbolic.var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymbolic.var$ 0 0 0 0 0 0 0 0 0 0 0 $pymbolic.var$ 0 0 0 $pymbolic.var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import loopy [EOL] import typing [EOL] import loopy as lp [EOL] import pymbolic as pm [EOL] import numpy as np [EOL] from . utils import getLogger [EOL] [EOL] LOG = getLogger ( [string] ) [EOL] [EOL] [EOL] class Workspace : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , kernel , ** scalars ) : [EOL] self . kernel = kernel [EOL] self . scalars = scalars [EOL] self . data = { } [EOL] for arg in self . kernel . args : [EOL] if isinstance ( arg , lp . GlobalArg ) : [EOL] shape = tuple ( self . _shape ( arg . shape ) ) [EOL] self . data [ arg . name ] = self . _alloc ( shape , arg . dtype ) [EOL] elif isinstance ( arg , lp . ValueArg ) : [EOL] npdt = getattr ( np , arg . dtype . numpy_dtype . name ) [EOL] self . data [ arg . name ] = npdt ( scalars [ arg . name ] ) [EOL] [EOL] def _alloc ( self , shape , dtype ) : [EOL] return np . zeros ( shape , dtype ) [EOL] [EOL] def _shape ( self , shape ) : [EOL] for dim in shape : [EOL] if isinstance ( dim , pm . primitives . Variable ) : [EOL] name = dim . name [EOL] dim = self . scalars [ name ] [EOL] self . data [ name ] = dim [EOL] yield dim [EOL] [EOL] [EOL] class CLWorkspace ( Workspace ) : [EOL] [EOL] def __init__ ( self , cq , * args , ** kwargs ) : [EOL] self . cq = cq [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def _alloc ( self , shape , dtype ) : [EOL] from pyopencl . array import zeros [EOL] return zeros ( self . cq , shape , dtype ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import string [EOL] import tvb_hpc [EOL] from string import Template [EOL] from tvb_hpc . model import G2DO [EOL] [EOL] [EOL] [EOL] oscilator = G2DO ( ) [EOL] print ( oscilator . const ) [EOL] variables = Template ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tvb_hpc.model.G2DO$ 0 0 0 0 0 0 0 $tvb_hpc.model.G2DO$ 0 0 0 0 $string.Template$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , List , Tuple [EOL] import loopy [EOL] import typing [EOL] import tvb_hpc [EOL] import numpy as np [EOL] import loopy as lp [EOL] import pymbolic as pm [EOL] from tvb_hpc import model , coupling , network , utils , scheme [EOL] [EOL] LOG = utils . getLogger ( [string] ) [EOL] [EOL] [EOL] def network_time_step ( model , coupling , scheme , target = None , ) : [EOL] target = target or utils . default_target ( ) [EOL] [comment] [EOL] kernels = [ model . kernel ( target ) , network . Network ( model , coupling ) . kernel ( target ) , lp . fix_parameters ( scheme . kernel ( target ) , nsvar = len ( model . state_sym ) ) , ] [EOL] data_flow = [ ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) ] [EOL] knl = lp . fuse_kernels ( kernels , data_flow = data_flow ) [EOL] [comment] [EOL] knl = lp . to_batched ( knl , [string] , [ ] , [string] , sequential = True ) [EOL] new_i_time = pm . parse ( [string] ) [EOL] knl = lp . fix_parameters ( knl , i_time = new_i_time ) [EOL] knl . args . append ( lp . ValueArg ( [string] , np . uintc ) ) [EOL] knl = lp . add_dtypes ( knl , { [string] : np . uintc } ) [EOL] return knl [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , List , Tuple [EOL] import model [EOL] import typing [EOL] import coupling [EOL] import numpy [EOL] import builtins [EOL] import tvb_hpc [EOL] [docstring] [EOL] [EOL] import numpy as np [EOL] from scipy import sparse [EOL] import loopy as lp [EOL] import pymbolic as pm [EOL] from . base import BaseKernel [EOL] from . model import BaseModel [EOL] from . coupling import BaseCoupling [EOL] from . utils import getLogger , subst_vars [EOL] [EOL] [EOL] LOG = getLogger ( __name__ ) [EOL] [EOL] [EOL] class Connectivity : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def __init__ ( self , nnode , nz , nnz , col , row , wnz , lnz ) : [EOL] self . nnode = nnode [EOL] self . nz = nz [EOL] self . nnz = nnz [EOL] self . col = col [EOL] self . row = row [EOL] self . wnz = wnz [EOL] self . lnz = lnz [EOL] [EOL] @ classmethod def from_dense ( cls , weights , lengths ) : [EOL] nnode = weights . shape [ [number] ] [EOL] nz = ~ ( weights == [number] ) [EOL] nnz = nz . sum ( ) [EOL] wnz = weights [ nz ] [EOL] lnz = lengths [ nz ] [EOL] sw = sparse . csr_matrix ( weights ) [EOL] col = sw . indices . astype ( np . uintc ) [EOL] row = sw . indptr . astype ( np . uintc ) [EOL] obj = cls ( nnode , nz , nnz , col , row , wnz , lnz ) [EOL] obj . weights = weights [EOL] obj . lengths = lengths [EOL] return obj [EOL] [EOL] @ classmethod def from_npz ( cls , fname , weights_key = [string] , lengths_key = [string] ) : [EOL] npz = np . load ( fname ) [EOL] weights = npz [ weights_key ] [EOL] lengths = npz [ lengths_key ] [EOL] return cls . from_dense ( weights , lengths ) [EOL] [EOL] @ classmethod def hcp0 ( cls ) : [EOL] return cls . from_npz ( [string] ) [EOL] [EOL] [EOL] class Network ( BaseKernel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , model , cfun ) : [EOL] self . model = model [EOL] self . cfun = cfun [EOL] [EOL] def _insn_cfun ( self , k , pre , post ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] pre_expr = subst_vars ( expr = pre , pre_syn = pm . parse ( [string] ) , post_syn = pm . parse ( [string] ) , ) [EOL] [comment] [EOL] sum = subst_vars ( expr = pm . parse ( [string] ) , pre_expr = pre_expr , ) [EOL] [comment] [EOL] mean = sum / pm . var ( [string] ) [EOL] [comment] [EOL] post_expr = subst_vars ( post , sum = sum , mean = mean ) [EOL] [comment] [EOL] post_expr = subst_vars ( post_expr , k = k , ** self . cfun . param ) [EOL] return [string] % ( k , post_expr ) [EOL] [EOL] def kernel_isns ( self ) : [EOL] [docstring] [EOL] yield [string] [EOL] yield [string] [EOL] for k , ( _ , pre , post , _ ) in enumerate ( self . cfun . io ) : [EOL] yield self . _insn_cfun ( k , pre , post ) [EOL] [EOL] def kernel_domains ( self ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] def kernel_dtypes ( self ) : [EOL] dtypes = { [string] : np . uintc , [string] : np . float32 , } [EOL] for name , val in self . cfun . param . items ( ) : [EOL] from pymbolic . primitives import Variable [EOL] if isinstance ( val , Variable ) : [EOL] dtypes [ name ] = np . float32 [EOL] return dtypes [EOL] [EOL] def kernel_data ( self ) : [EOL] data = super ( ) . kernel_data ( ) [EOL] [comment] [EOL] shape = pm . var ( [string] ) , pm . var ( [string] ) , len ( self . model . obsrv_sym ) [EOL] data [ data . index ( [string] ) ] = lp . GlobalArg ( [string] , shape = shape ) [EOL] [comment] [EOL] nnz_shape = pm . var ( [string] ) , [EOL] for key in [string] . split ( ) : [EOL] data [ data . index ( key ) ] = lp . GlobalArg ( key , shape = nnz_shape ) [EOL] return data [EOL] [EOL] [EOL] class RegionMappingMix : [EOL] domains = [string] [EOL] dtypes = { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] class RMapToAvg ( RegionMappingMix , BaseKernel ) : [EOL] [comment] [EOL] extra_data_shape = { [string] : [string] } [EOL] instructions = [string] [EOL] [EOL] [EOL] class RMapFromAvg ( RegionMappingMix , BaseKernel ) : [EOL] extra_data_shape = { [string] : [string] } [EOL] instructions = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $tvb_hpc.network.Connectivity$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $tvb_hpc.network.Connectivity$ 0 0 0 0 0 $tvb_hpc.network.Connectivity$ 0 0 0 0 0 0 $tvb_hpc.network.Connectivity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tvb_hpc.model.BaseModel$ 0 $tvb_hpc.coupling.BaseCoupling$ 0 0 0 0 0 $tvb_hpc.model.BaseModel$ 0 $tvb_hpc.model.BaseModel$ 0 0 0 $tvb_hpc.coupling.BaseCoupling$ 0 $tvb_hpc.coupling.BaseCoupling$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,builtins.int]$ 0 $typing.Tuple[typing.Any,typing.Any,builtins.int]$ 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,builtins.int]$ 0 $typing.Tuple[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] import warnings [EOL] import logging [EOL] import loopy as lp [EOL] import loopy . target . numba as base_numba [EOL] [EOL] [EOL] LOG = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class NumbaTarget ( base_numba . NumbaTarget ) : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . no_jit = kwargs . pop ( [string] , False ) [EOL] with warnings . catch_warnings ( ) : [EOL] warnings . simplefilter ( [string] ) [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def get_kernel_executor_cache_key ( self , * args , ** kwargs ) : [EOL] return [string] [EOL] [EOL] def get_kernel_executor ( self , knl , * args , ** kwargs ) : [EOL] code , _ = lp . generate_code ( knl ) [EOL] if self . no_jit : [EOL] code = [string] . join ( [ line for line in code . split ( [string] ) if line != [string] ] ) [EOL] for i , line in enumerate ( code . split ( [string] ) ) : [EOL] print ( i + [number] , line ) [EOL] LOG . debug ( code ) [EOL] ns = { } [EOL] exec ( code , ns ) [EOL] return ns [ knl . name ] [EOL] [EOL] [EOL] class NumbaCudaTarget ( base_numba . NumbaCudaTarget ) : [EOL] [EOL] def get_kernel_executor_cache_key ( self , * args , ** kwargs ) : [EOL] return [string] [EOL] [EOL] def get_kernel_executor ( self , knl , * args , ** kwargs ) : [EOL] code , _ = lp . generate_code ( knl ) [EOL] LOG . debug ( code ) [EOL] ns = { } [EOL] exec ( code , ns ) [EOL] return self . _wrap_dims ( ns [ knl . name ] ) [EOL] [EOL] def _wrap_dims ( self , nbc_knl ) : [EOL] def _ ( griddim , blockdim , * args , ** kwargs ) : [EOL] return nbc_knl [ griddim , blockdim ] ( * args , ** kwargs ) [EOL] return _ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] from typing import Dict , Any , List , Type , Tuple [EOL] import loopy [EOL] import typing [EOL] import builtins [EOL] import numpy [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List , Dict [EOL] from numpy import dtype [EOL] import pymbolic as pm [EOL] import loopy as lp [EOL] from loopy import ( TargetBase , LoopKernel , make_kernel , add_and_infer_dtypes , make_reduction_inames_unique , generate_code ) [EOL] [EOL] [EOL] [comment] [EOL] Isns = List [ str ] [EOL] [EOL] [EOL] class BaseKernel : [EOL] [EOL] def code ( self , * args , ** kwargs ) : [EOL] knl = self . kernel ( * args , ** kwargs ) [EOL] code , _ = generate_code ( knl ) [EOL] return code [EOL] [EOL] def kernel ( self , target , typed = True ) : [EOL] [docstring] [EOL] domains = self . kernel_domains ( ) [EOL] body = [string] . join ( self . kernel_isns ( ) ) [EOL] data = self . kernel_data ( ) [EOL] knl = make_kernel ( domains , body , data , target = target ) [EOL] knl = make_reduction_inames_unique ( knl ) [EOL] knl . name = self . __class__ . __name__ [EOL] if typed : [EOL] dtypes = self . kernel_dtypes ( ) [EOL] knl = add_and_infer_dtypes ( knl , dtypes ) [EOL] return knl [EOL] [EOL] def kernel_domains ( self ) : [EOL] [docstring] [EOL] return self . domains [EOL] [EOL] def kernel_data ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] csk = [string] . join ( self . kernel_dtypes ( ) . keys ( ) ) [EOL] data = [ key for key in csk . split ( [string] ) ] [EOL] if hasattr ( self , [string] ) : [EOL] for name , shape in self . extra_data_shape . items ( ) : [EOL] shape = tuple ( pm . parse ( _ ) for _ in shape . split ( [string] ) ) [EOL] arg = lp . GlobalArg ( name , shape = shape ) [EOL] data [ data . index ( name ) ] = arg [EOL] return data [EOL] [EOL] def kernel_dtypes ( self ) : [EOL] [docstring] [EOL] return self . dtypes [EOL] [EOL] def kernel_isns ( self ) : [EOL] [docstring] [EOL] return [ _ [ [number] : ] for _ in self . instructions . split ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict [EOL] import typing [EOL] from . base import BaseKernel [EOL] [EOL] [EOL] class Covar : [EOL] template = [string] [EOL] [EOL] [EOL] class BatchCov ( BaseKernel ) : [EOL] domains = [string] [EOL] dtypes = { [string] : [string] , [string] : [string] } [EOL] instructions = [string] [EOL] [EOL] [EOL] class OnlineCov ( BaseKernel ) : [EOL] domains = [string] [EOL] dtypes = { [string] : [string] , [string] : [string] } [EOL] instructions = [string] [EOL] [EOL] [EOL] class CovToCorr : [EOL] template = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Union , Dict , Any , List [EOL] import pymbolic [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Union [EOL] import numpy as np [EOL] import pymbolic as pm [EOL] from . base import BaseKernel [EOL] [EOL] [EOL] def euler ( x , f , dt = None ) : [EOL] [docstring] [EOL] dt = dt or pm . var ( [string] ) [EOL] return x + dt * f [EOL] [EOL] [EOL] def euler_maruyama ( x , f , g , dt = None , dWt = None ) : [EOL] [docstring] [EOL] dt = dt or pm . var ( [string] ) [EOL] dWt = dWt or pm . var ( [string] ) [EOL] return x + dt * f + dWt * dt ** [number] * g [EOL] [EOL] [EOL] def euler_maruyama_logp ( x , f , g , xn = None , dt = None , step = euler ) : [EOL] [docstring] [EOL] dt = dt or pm . var ( [string] ) [EOL] mu = step ( x , f , dt ) [EOL] sd = dt ** [number] * g [EOL] xn = xn or np . array ( [ pm . var ( v . name + [string] ) for v in x ] ) [EOL] return - ( xn - mu ) ** [number] / ( [number] * sd ** [number] ) [EOL] [EOL] [EOL] class TimeStepScheme ( BaseKernel ) : [EOL] pass [EOL] [EOL] [EOL] class EulerStep ( TimeStepScheme ) : [EOL] [EOL] [comment] [EOL] [EOL] def __init__ ( self , dt ) : [EOL] self . dt = dt [EOL] [EOL] def kernel_dtypes ( self ) : [EOL] dtypes = { [string] : np . uintc , [string] : np . float32 , } [EOL] if isinstance ( self . dt , pm . var ) : [EOL] dtypes [ [string] ] = np . float32 [EOL] return dtypes [EOL] [EOL] def kernel_data ( self ) : [EOL] data = [string] . split ( ) [EOL] if isinstance ( self . dt , pm . var ) : [EOL] data . insert ( [number] , self . dt . name ) [EOL] return data [EOL] [EOL] def kernel_domains ( self ) : [EOL] domains = [string] [EOL] constraints = [string] [EOL] return f" [string] { domains } [string] { constraints } [string] " [EOL] [EOL] def kernel_isns ( self ) : [EOL] lhs = [string] [EOL] rhs = f' [string] { self . dt } [string] ' [EOL] return [ f'{ lhs } [string] { rhs }' ] [EOL] [EOL] [EOL] class EulerMaryuyamaStep ( EulerStep ) : [EOL] [EOL] def kernel_isns ( self ) : [EOL] lhs = [string] [EOL] rhs = [string] [string] [EOL] return [ [string] . format ( dt = self . dt ) , ( lhs + rhs ) . format ( dt = self . dt ) ] [EOL] [EOL] def kernel_data ( self ) : [EOL] data = super ( ) . kernel_data ( ) [EOL] data += [ [string] , [string] ] [EOL] return data [EOL] [EOL] def kernel_dtypes ( self ) : [EOL] dtypes = super ( ) . kernel_dtypes ( ) [EOL] dtypes [ [string] ] = np . float32 [EOL] return dtypes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , Type , List [EOL] import typing [EOL] import cgen [EOL] import logging [EOL] import loopy [EOL] import ctypes [EOL] import builtins [EOL] import tvb_hpc [EOL] [docstring] [EOL] [EOL] import os [EOL] import os . path [EOL] import logging [EOL] import ctypes [EOL] import tempfile [EOL] import weakref [EOL] import subprocess [EOL] from typing import List [EOL] import numpy as np [EOL] import loopy as lp [EOL] from loopy . target . c import CTarget , generate_header , CASTBuilder [EOL] import cgen [EOL] from tvb_hpc . utils import which [EOL] [EOL] [EOL] LOG = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Spec : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , float = [string] , width = [number] , align = None , openmp = False , layout = None , debug = False ) : [EOL] self . float = float [EOL] self . width = width [EOL] self . align = align [EOL] self . openmp = openmp [EOL] [comment] [EOL] self . layout = layout [EOL] self . debug = debug [EOL] [EOL] [comment] [EOL] @ property def dtype ( self ) : [EOL] return self . float [EOL] [EOL] @ property def np_dtype ( self ) : [EOL] return { [string] : np . float32 } [ self . dtype ] [EOL] [EOL] @ property def ct_dtype ( self ) : [EOL] import ctypes as ct [EOL] return { [string] : ct . c_float } [ self . dtype ] [EOL] [EOL] [comment] [EOL] @ property def dict ( self ) : [EOL] return { [string] : self . float , [string] : self . width , [string] : self . align , [string] : self . openmp } [EOL] [EOL] [EOL] class Compiler : [EOL] [docstring] [EOL] [EOL] source_suffix = [string] [EOL] default_exe = [string] [EOL] default_compile_flags = [string] . split ( ) [EOL] default_link_flags = [string] . split ( ) [EOL] [EOL] def __init__ ( self , cc = None , cflags = None , ldflags = None ) : [EOL] self . exe = which ( cc ) if cc else self . default_exe [EOL] self . cflags = cflags or self . default_compile_flags [ : ] [EOL] self . ldflags = ldflags or self . default_link_flags [ : ] [EOL] self . tempdir = tempfile . TemporaryDirectory ( ) [EOL] [EOL] def _tempname ( self , name ) : [EOL] [docstring] [EOL] return os . path . join ( self . tempdir . name , name ) [EOL] [EOL] def _call ( self , args , ** kwargs ) : [EOL] [docstring] [EOL] cwd = self . tempdir . name [EOL] args_ = [ self . exe ] + args [EOL] LOG . debug ( args_ ) [EOL] subprocess . check_call ( args_ , cwd = cwd , ** kwargs ) [EOL] [EOL] def build ( self , code ) : [EOL] [docstring] [EOL] LOG . debug ( code ) [EOL] c_fname = self . _tempname ( [string] + self . source_suffix ) [EOL] obj_fname = self . _tempname ( [string] ) [EOL] dll_fname = self . _tempname ( [string] ) [EOL] with open ( c_fname , [string] ) as fd : [EOL] fd . write ( code ) [EOL] self . _call ( self . compile_args ( c_fname ) ) [EOL] self . _call ( self . link_args ( obj_fname , dll_fname ) ) [EOL] return ctypes . CDLL ( dll_fname ) [EOL] [EOL] def compile_args ( self , c_fname ) : [EOL] [docstring] [EOL] return self . cflags + [ [string] , c_fname ] [EOL] [EOL] def link_args ( self , obj_fname , dll_fname ) : [EOL] [docstring] [EOL] return self . ldflags + [ [string] , obj_fname , [string] , dll_fname ] [EOL] [EOL] [EOL] class CppCompiler ( Compiler ) : [EOL] [docstring] [EOL] source_suffix = [string] [EOL] default_exe = [string] [EOL] default_compile_flags = [string] . split ( ) [EOL] [EOL] [EOL] class CompiledKernel : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , knl , comp = None ) : [EOL] assert isinstance ( knl . target , CTarget ) [EOL] self . knl = knl [EOL] self . code , _ = lp . generate_code ( knl ) [EOL] self . comp = comp or Compiler ( ) [EOL] self . dll = self . comp . build ( self . code ) [EOL] self . func_decl , = generate_header ( knl ) [EOL] self . _arg_info = [ ] [EOL] [comment] [EOL] self . _visit_func_decl ( self . func_decl ) [EOL] self . name = self . knl . name [EOL] restype = self . func_decl . subdecl . typename [EOL] if restype == [string] : [EOL] self . restype = None [EOL] else : [EOL] raise ValueError ( [string] % ( restype , ) ) [EOL] self . _fn = getattr ( self . dll , self . name ) [EOL] self . _fn . restype = self . restype [EOL] self . _fn . argtypes = [ ctype for name , ctype in self . _arg_info ] [EOL] self . _prepared_call_cache = weakref . WeakKeyDictionary ( ) [EOL] [EOL] def __call__ ( self , ** kwargs ) : [EOL] [docstring] [EOL] args_ = [ ] [EOL] for knl_arg , arg_t in zip ( self . knl . args , self . _fn . argtypes ) : [EOL] arg = kwargs [ knl_arg . name ] [EOL] if hasattr ( arg , [string] ) : [EOL] if arg . size == [number] : [EOL] [comment] [EOL] arg_ = arg_t ( [number] ) [EOL] else : [EOL] arg_ = arg . ctypes . data_as ( arg_t ) [EOL] else : [EOL] arg_ = arg_t ( arg ) [EOL] args_ . append ( arg_ ) [EOL] self . _fn ( * args_ ) [EOL] [EOL] def _append_arg ( self , name , dtype , pointer = False ) : [EOL] [docstring] [EOL] self . _arg_info . append ( ( name , self . _dtype_to_ctype ( dtype , pointer = pointer ) ) ) [EOL] [EOL] def _visit_const ( self , node ) : [EOL] [docstring] [EOL] if isinstance ( node . subdecl , cgen . RestrictPointer ) : [EOL] self . _visit_pointer ( node . subdecl ) [EOL] else : [EOL] pod = node . subdecl [comment] [EOL] self . _append_arg ( pod . name , pod . dtype ) [EOL] [EOL] def _visit_pointer ( self , node ) : [EOL] [docstring] [EOL] pod = node . subdecl [comment] [EOL] self . _append_arg ( pod . name , pod . dtype , pointer = True ) [EOL] [EOL] def _visit_func_decl ( self , func_decl ) : [EOL] [docstring] [EOL] for i , arg in enumerate ( func_decl . arg_decls ) : [EOL] if isinstance ( arg , cgen . Const ) : [EOL] self . _visit_const ( arg ) [EOL] elif isinstance ( arg , cgen . RestrictPointer ) : [EOL] self . _visit_pointer ( arg ) [EOL] else : [EOL] raise ValueError ( [string] % ( arg , ) ) [EOL] [EOL] def _dtype_to_ctype ( self , dtype , pointer = False ) : [EOL] [docstring] [EOL] target = self . knl . target [comment] [EOL] registry = target . get_dtype_registry ( ) . wrapped_registry [EOL] typename = registry . dtype_to_ctype ( dtype ) [EOL] typename = { [string] : [string] } . get ( typename , typename ) [EOL] basetype = getattr ( ctypes , [string] + typename ) [EOL] if pointer : [EOL] return ctypes . POINTER ( basetype ) [EOL] return basetype [EOL] [EOL] [EOL] class OpenMPCASTBuilder ( CASTBuilder ) : [EOL] [EOL] def emit_sequential_loop ( self , codegen_state , iname , iname_dtype , lbound , ubound , inner ) : [EOL] from cgen import Pragma , Block [EOL] loop = super ( ) . emit_sequential_loop ( codegen_state , iname , iname_dtype , lbound , ubound , inner ) [EOL] [EOL] pragma = self . target . iname_pragma_map . get ( iname ) [EOL] if pragma : [EOL] return Block ( contents = [ Pragma ( pragma ) , loop , ] ) [EOL] return loop [EOL] [EOL] [EOL] class OpenMPCTarget ( CTarget ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . iname_pragma_map = { } [EOL] [EOL] def get_device_ast_builder ( self ) : [EOL] return OpenMPCASTBuilder ( self ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cgen.Const$ 0 0 0 0 0 0 0 0 $cgen.Const$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $cgen.Const$ 0 0 0 0 0 0 0 0 0 $cgen.Const$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cgen.RestrictPointer$ 0 0 0 0 0 0 0 $cgen.RestrictPointer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cgen.FunctionDeclaration$ 0 0 0 0 0 0 0 0 0 0 0 0 $cgen.FunctionDeclaration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] import os [EOL] import logging [EOL] [EOL] _loopy_logger = logging . getLogger ( [string] ) [EOL] _loopy_logger . setLevel ( logging . WARNING ) [EOL] [EOL] logging . basicConfig ( level = getattr ( logging , os . environ . get ( [string] , [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] import builtins [EOL] from typing import Any , List [EOL] import typing [EOL] import compiler [EOL] import tvb_hpc [EOL] [docstring] [EOL] [EOL] import numpy as np [EOL] import ctypes [EOL] from . compiler import CppCompiler , Spec [EOL] from . utils import include_dir [EOL] [EOL] rng_template = [string] [EOL] [EOL] [EOL] class RNG : [EOL] [EOL] def __init__ ( self , comp = None ) : [EOL] self . comp = comp or CppCompiler ( ) [comment] [EOL] [EOL] [comment] [EOL] def generate_c ( self , spec = None ) : [EOL] spec = spec or Spec ( ) [EOL] self . comp . cflags += [ [string] + include_dir ] [EOL] loop_pragma = [string] [EOL] if spec . openmp : [EOL] loop_pragma = [string] [EOL] decls = [ ] [EOL] [comment] [EOL] return rng_template % { [string] : loop_pragma , [string] : [string] . join ( decls ) , } [EOL] [EOL] def build ( self , spec ) : [EOL] self . dll = self . comp . build ( self . generate_c ( spec ) ) [EOL] self . fn = self . dll . tvb_rng [EOL] self . fn . restype = None [EOL] self . fn . argtypes = [ ctypes . c_longlong , ctypes . c_uint , ctypes . POINTER ( ctypes . c_float ) ] [EOL] [EOL] def fill ( self , array , seed = [number] ) : [EOL] assert array . dtype == np . float32 [EOL] self . fn ( self . fn . argtypes [ [number] ] ( seed ) , self . fn . argtypes [ [number] ] ( array . size ) , array . ctypes . data_as ( self . fn . argtypes [ [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tvb_hpc.compiler.Spec$ 0 0 0 0 0 $tvb_hpc.compiler.Spec$ 0 $tvb_hpc.compiler.Spec$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $tvb_hpc.compiler.Spec$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import tvb_hpc [EOL] import itertools [EOL] import numpy as np [EOL] import pymbolic as pm [EOL] from tvb_hpc import model , coupling , network , utils , scheme , transforms [EOL] [EOL] LOG = utils . getLogger ( [string] ) [EOL] [EOL] [EOL] def make_knl ( ) : [EOL] [comment] [EOL] osc = model . Kuramoto ( ) [EOL] osc . dt = [number] [EOL] osc . const [ [string] ] = [number] * [number] * np . pi / [number] [EOL] cfun = coupling . Kuramoto ( osc ) [EOL] cfun . param [ [string] ] = pm . parse ( [string] ) [EOL] scm = scheme . EulerStep ( osc . dt ) [EOL] [comment] [EOL] knl = transforms . network_time_step ( osc , cfun , scm ) [EOL] return knl , osc [EOL] [EOL] [EOL] def make_data ( ) : [EOL] c = network . Connectivity . hcp0 ( ) [EOL] return c . nnode , c . lengths , c . nnz , c . row , c . col , c . wnz , c . nz , c . weights [EOL] [EOL] [EOL] def run_one ( args ) : [EOL] j , speed , coupling , nnode , lengths , nz , nnz , row , col , wnz = args [EOL] knl , osc = make_knl ( ) [EOL] lnz = ( lengths [ nz ] / speed / osc . dt ) . astype ( np . uintc ) [EOL] state , input , param , drift , diffs , _ = osc . prep_arrays ( nnode ) [EOL] obsrv = np . zeros ( ( lnz . max ( ) + [number] + [number] , nnode , [number] ) , np . float32 ) [EOL] trace = np . zeros ( ( [number] , nnode ) , np . float32 ) [EOL] for i in range ( trace . shape [ [number] ] ) : [EOL] knl ( nstep = [number] , nnode = nnode , ntime = obsrv . shape [ [number] ] , state = state , input = input , param = param , drift = drift , diffs = diffs , obsrv = obsrv , nnz = nnz , delays = lnz , row = row , col = col , weights = wnz , a = coupling , i_step_0 = i * [number] ) [EOL] trace [ i ] = obsrv [ i * [number] : ( i + [number] ) * [number] , : , [number] ] . sum ( axis = [number] ) [EOL] return trace [EOL] [EOL] [EOL] def run ( ) : [EOL] from . . numba import NumbaTarget [EOL] utils . default_target = NumbaTarget [EOL] nnode , lengths , nnz , row , col , wnz , nz , weights = make_data ( ) [EOL] [comment] [EOL] nc , ns = [number] , [number] [EOL] couplings = np . logspace ( [number] , [number] , nc ) [EOL] speeds = np . logspace ( [number] , [number] , ns ) [EOL] trace = np . zeros ( ( nc * ns , [number] ) + ( nnode , ) , np . float32 ) [EOL] LOG . info ( [string] , trace . nbytes / [number] ** [number] ) [EOL] for j , ( speed , coupl ) in enumerate ( itertools . product ( speeds , couplings ) ) : [EOL] run_one ( ( j , speed , coupl , nnode , lengths , nz , nnz , row , col , wnz ) ) [EOL] [EOL] [comment] [EOL] n_work_items = nc * ns [EOL] r , c = np . triu_indices ( nnode , [number] ) [EOL] win_size = [number] [comment] [EOL] tavg = np . transpose ( trace , ( [number] , [number] , [number] ) ) [EOL] win_tavg = tavg . reshape ( ( - [number] , win_size ) + tavg . shape [ [number] : ] ) [EOL] err = np . zeros ( ( len ( win_tavg ) , n_work_items ) ) [EOL] for i , tavg_ in enumerate ( win_tavg ) : [EOL] for j in range ( n_work_items ) : [EOL] fc = np . corrcoef ( tavg_ [ : , : , j ] . T ) [EOL] err [ i , j ] = ( ( fc [ r , c ] - weights [ r , c ] ) ** [number] ) . sum ( ) [EOL] [comment] [EOL] err_ = err [ - [number] ] . reshape ( ( speeds . size , couplings . size ) ) [EOL] [comment] [EOL] derr_speed = np . diff ( err_ . mean ( axis = [number] ) ) . sum ( ) [EOL] derr_coupl = np . diff ( err_ . mean ( axis = [number] ) ) . sum ( ) [EOL] LOG . info ( [string] , derr_speed , derr_coupl ) [EOL] assert derr_speed > [number] [EOL] assert derr_coupl < - [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] import _ast [EOL] import ast [EOL] [EOL] from ctree . c . nodes import * [EOL] from ctree . transformations import PyBasicConversions [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def gen_index_arithmetic ( index , dims ) : [EOL] s = [ ] [EOL] for i in range ( len ( dims ) ) : [EOL] tree = SymbolRef ( index [ i ] ) [EOL] for j in range ( i + [number] , len ( dims ) ) : [EOL] tree = BinaryOp ( left = tree , right = SymbolRef ( dims [ j ] ) , op = Op . Mul ( ) ) [EOL] s . append ( tree ) [EOL] tree = s [ [number] ] [EOL] for i in range ( [number] , len ( s ) ) : [EOL] tree = BinaryOp ( left = tree , right = s [ i ] , op = Op . Add ( ) ) [EOL] return tree [EOL] [EOL] class PyBasicConversionsExtended ( PyBasicConversions ) : [EOL] def visit_BinOp ( self , node ) : [EOL] lhs = self . visit ( node . left ) [EOL] rhs = self . visit ( node . right ) [EOL] if type ( node . op ) == ast . Pow : [EOL] return FunctionCall ( func = SymbolRef ( [string] ) , args = [ lhs , rhs ] ) [EOL] else : [EOL] op = self . PY_OP_TO_CTREE_OP . get ( type ( node . op ) , type ( node . op ) ) ( ) [EOL] return BinaryOp ( lhs , op , rhs ) [EOL] [EOL] [EOL] def dfuns_to_c ( dfuns ) : [EOL] c_dfuns = [ ] [EOL] for dfun in dfuns : [EOL] dfun_ast = ast . parse ( G2DO . drift [ [number] ] ) . body [ [number] ] [EOL] c_dfuns . append ( PyBasicConversionsExtended ( ) . visit ( dfun_ast ) . codegen ( ) ) [EOL] return c_dfuns [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] [EOL] from models import G2DO [EOL] from mako . template import Template [EOL] [EOL] template = Template ( filename = [string] ) [EOL] [EOL] print ( template . render ( svar = G2DO . state , const = G2DO . const , cvar = G2DO . input , dfuns = dfuns_to_c ( G2DO . drift ) ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any , Tuple [EOL] import typing [EOL] import ast [EOL] import pprint [EOL] [EOL] def pformat_ast ( node , include_attrs = False , ** kws ) : [EOL] return pprint . pformat ( ast2tree ( node , include_attrs ) , ** kws ) [EOL] [EOL] def ast2tree ( node , include_attrs = True ) : [EOL] def _transform ( node ) : [EOL] if isinstance ( node , ast . AST ) : [EOL] fields = ( ( a , _transform ( b ) ) for a , b in ast . iter_fields ( node ) ) [EOL] if include_attrs : [EOL] attrs = ( ( a , _transform ( getattr ( node , a ) ) ) for a in node . _attributes if hasattr ( node , a ) ) [EOL] return ( node . __class__ . __name__ , dict ( fields ) , dict ( attrs ) ) [EOL] [EOL] return ( node . __class__ . __name__ , dict ( fields ) ) [EOL] elif isinstance ( node , list ) : [EOL] return [ _transform ( x ) for x in node ] [EOL] elif isinstance ( node , str ) : [EOL] return repr ( node ) [EOL] return node [EOL] if not isinstance ( node , ast . AST ) : [EOL] raise TypeError ( [string] % node . __class__ . __name__ ) [EOL] return _transform ( node ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] import numpy [EOL] from __future__ import division , print_function [EOL] import math as m [EOL] import numpy as _lpy_np [EOL] import numba . cuda as _lpy_ncu [EOL] import numba as _lpy_numba [EOL] from tvb_hpc import utils , network , model [EOL] from typing import List [EOL] [EOL] [comment] [EOL] [EOL] [EOL] LOG = utils . getLogger ( [string] ) [EOL] [EOL] [EOL] def make_data ( ) : [EOL] c = network . Connectivity . hcp0 ( ) [EOL] return c . nnode , c . lengths , c . nnz , c . row , c . col , c . wnz , c . nz , c . weights [EOL] [EOL] def prep_arrays ( nsims , nnode ) : [EOL] [docstring] [EOL] dtype = _lpy_np . float32 [EOL] arrs = [ ] [EOL] for key in [string] . split ( ) : [EOL] shape = nsims * nnode * [number] [EOL] arrs . append ( _lpy_np . zeros ( shape , dtype ) ) [EOL] for i , ( lo , hi ) in enumerate ( [ ( [number] , [number] * _lpy_np . pi ) ] ) : [EOL] state = _lpy_np . ones ( nsims * nnode )[comment] [EOL] [comment] [EOL] arrs . append ( state ) [EOL] param = _lpy_np . ones ( ( nnode * [number] ) , dtype ) [EOL] arrs . append ( param ) [EOL] return arrs [EOL] [EOL] def run_all ( args ) : [EOL] j , speed , coupling , nnode , lengths , nz , nnz , row , col , wnz = args [EOL] dt = [number] [EOL] lnz = [ ] [EOL] for i in range ( len ( speed ) ) : [EOL] lnz . append ( ( lengths [ nz ] / speed [ i ] / dt ) . astype ( _lpy_np . uintc ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] flat_lnz = _lpy_np . reshape ( lnz , ( nnz * len ( speed ) ) ) [EOL] input , drift , diffs , state , param = prep_arrays ( len ( coupling ) * len ( speed ) , nnode ) [EOL] obsrv = _lpy_np . zeros ( ( len ( coupling ) * len ( speed ) * ( max ( flat_lnz ) + [number] + [number] ) * nnode * [number] ) , _lpy_np . float32 ) [EOL] trace = _lpy_np . zeros ( ( len ( coupling ) * len ( speed ) , [number] , nnode ) , _lpy_np . float32 ) [EOL] threadsperblock = len ( coupling ) [EOL] blockspergrid = len ( speed ) [EOL] for i in range ( [number] ) : [EOL] Kuramoto_and_Network_and_EulerStep_inner [ blockspergrid , threadsperblock ] ( [number] , nnode , ( max ( flat_lnz ) + [number] + [number] ) , state , input , param , drift , diffs , obsrv , nnz , flat_lnz , row , col , wnz , coupling , i * [number] ) [EOL] o = obsrv [EOL] o = _lpy_np . reshape ( o , ( len ( coupling ) * len ( speed ) , ( max ( flat_lnz ) + [number] + [number] ) , nnode , [number] ) ) [EOL] trace [ : , i , : ] = o [ : , i * [number] : ( i + [number] ) * [number] , : , [number] ] . sum ( axis = [number] ) [EOL] return trace [EOL] [EOL] [EOL] def run ( ) : [EOL] _lpy_ncu . select_device ( [number] ) [EOL] LOG . info ( _lpy_ncu . gpus ) [EOL] [comment] [EOL] nnode , lengths , nnz , row , col , wnz , nz , weights = make_data ( ) [EOL] [comment] [EOL] nc , ns = [number] , [number] [EOL] couplings = _lpy_np . logspace ( [number] , [number] , nc ) [EOL] speeds = _lpy_np . logspace ( [number] , [number] , ns ) [EOL] [comment] [EOL] start = time . time ( ) [EOL] trace = run_all ( ( [number] , speeds , couplings , nnode , lengths , nz , nnz , row , col , wnz ) ) [EOL] end = time . time ( ) [EOL] print ( [string] ) [EOL] print ( end - start ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] n_work_items = nc * ns [EOL] r , c = _lpy_np . triu_indices ( nnode , [number] ) [EOL] win_size = [number] [comment] [EOL] tavg = _lpy_np . transpose ( trace , ( [number] , [number] , [number] ) ) [EOL] win_tavg = tavg . reshape ( ( - [number] , win_size ) + tavg . shape [ [number] : ] ) [EOL] err = _lpy_np . zeros ( ( len ( win_tavg ) , n_work_items ) ) [EOL] for i , tavg_ in enumerate ( win_tavg ) : [EOL] for j in range ( n_work_items ) : [EOL] fc = _lpy_np . corrcoef ( tavg_ [ : , : , j ] . T ) [EOL] err [ i , j ] = ( ( fc [ r , c ] - weights [ r , c ] ) ** [number] ) . sum ( ) [EOL] [comment] [EOL] err_ = err [ - [number] ] . reshape ( ( speeds . size , couplings . size ) ) [EOL] [comment] [EOL] derr_speed = _lpy_np . diff ( err_ . mean ( axis = [number] ) ) . sum ( ) [EOL] derr_coupl = _lpy_np . diff ( err_ . mean ( axis = [number] ) ) . sum ( ) [EOL] LOG . info ( [string] , derr_speed , derr_coupl ) [EOL] print ( derr_speed ) [EOL] assert derr_speed > [number] [EOL] assert derr_coupl < - [number] [EOL] print ( [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[numpy.ndarray]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type , Tuple [EOL] import phase_plane_interactive [EOL] import typing [EOL] class G2DO : [EOL] [docstring] [EOL] state = [string] , [string] [EOL] limit = ( - [number] , [number] ) , ( - [number] , [number] ) [EOL] input = [string] [EOL] param = [string] [EOL] const = { [string] : [number] , [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] drift = ( [string] , [string] ) [EOL] diffs = [number] , [number] [EOL] obsrv = [string] , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0
from typing import Any , Tuple [EOL] import phase_plane_interactive [EOL] import typing [EOL] import numpy as np [EOL] import matplotlib . pyplot as plt [EOL] from scipy . integrate import odeint [EOL] from matplotlib . widgets import Button [EOL] [EOL] TRAJ_STEPS = [number] [EOL] [EOL] [EOL] class Oscillator : [EOL] [EOL] def __init__ ( self , eta = [number] , gamma = [number] , epsilon = [number] ) : [EOL] self . limit = ( - [number] , [number] ) , ( - [number] , [number] ) [EOL] self . eta = eta [EOL] self . gamma = gamma [EOL] self . epsilon = epsilon [EOL] [EOL] def dfun ( self , state_variables , * args , ** kwargs ) : [EOL] psi1 , psi2 = state_variables [EOL] [EOL] [EOL] dpsi1 = self . eta * ( psi2 - self . gamma * psi1 - psi1 ** [number] ) [EOL] dpsi2 = self . eta * ( - self . epsilon * psi1 ) [EOL] [EOL] return [ dpsi1 , dpsi2 ] [EOL] [EOL] class PhasePlaneInteractive : [EOL] def __init__ ( self , model ) : [EOL] self . model = model [EOL] [EOL] def plot_trajectory ( self , x0 ) : [EOL] tspan = np . linspace ( [number] , [number] , TRAJ_STEPS ) [EOL] ys = odeint ( self . model . dfun , x0 , tspan ) [EOL] self . ax . plot ( ys [ : , [number] ] , ys [ : , [number] ] , [string] ) [comment] [EOL] self . ax . plot ( [ ys [ [number] , [number] ] ] , [ ys [ [number] , [number] ] ] , [string] ) [comment] [EOL] self . ax . plot ( [ ys [ - [number] , [number] ] ] , [ ys [ - [number] , [number] ] ] , [string] ) [comment] [EOL] [EOL] def onclick ( self , event ) : [EOL] self . plot_trajectory ( [ event . xdata , event . ydata ] ) [EOL] plt . draw ( ) [EOL] [EOL] def __call__ ( self ) : [EOL] y1 = np . linspace ( - [number] , [number] , [number] ) [EOL] y2 = np . linspace ( - [number] , [number] , [number] ) [EOL] [EOL] Y1 , Y2 = np . meshgrid ( y1 , y2 ) [EOL] [EOL] [EOL] u , v = np . zeros ( Y1 . shape ) , np . zeros ( Y2 . shape ) [EOL] [EOL] NI , NJ = Y1 . shape [EOL] [EOL] for i in range ( NI ) : [EOL] for j in range ( NJ ) : [EOL] x = Y1 [ i , j ] [EOL] y = Y2 [ i , j ] [EOL] yprime = self . model . dfun ( [ x , y ] ) [EOL] u [ i , j ] = yprime [ [number] ] [EOL] v [ i , j ] = yprime [ [number] ] [EOL] [EOL] fig , self . ax = plt . subplots ( ) [EOL] plt . subplots_adjust ( bottom = [number] ) [EOL] [EOL] [EOL] def clear ( event ) : [EOL] self . ax . clear ( ) [EOL] Q = self . ax . quiver ( Y1 , Y2 , u , v , color = [string] ) [EOL] self . ax . set_xlabel ( [string] ) [EOL] self . ax . set_ylabel ( [string] ) [EOL] self . ax . set_xlim ( - [number] , [number] ) [EOL] self . ax . set_ylim ( - [number] , [number] ) [EOL] plt . draw ( ) [EOL] [EOL] [EOL] clear ( [ [number] , [number] ] ) [EOL] cid = fig . canvas . mpl_connect ( [string] , self . onclick ) [EOL] [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . xlim ( [ - [number] , [number] ] ) [EOL] plt . ylim ( [ - [number] , [number] ] ) [EOL] [EOL] [EOL] axclear = plt . axes ( [ [number] , [number] , [number] , [number] ] ) [EOL] bclear = Button ( axclear , [string] ) [EOL] bclear . on_clicked ( clear ) [EOL] [EOL] plt . show ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] model = Oscillator ( ) [EOL] ppi = PhasePlaneInteractive ( model ) [EOL] ppi ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $phase_plane_interactive.ppi.Oscillator$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $phase_plane_interactive.ppi.Oscillator$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $phase_plane_interactive.ppi.Oscillator$ 0 0 0 0 0 $phase_plane_interactive.ppi.PhasePlaneInteractive$ 0 0 0 $phase_plane_interactive.ppi.Oscillator$ 0 0 $phase_plane_interactive.ppi.PhasePlaneInteractive$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] import loopy as lp [EOL] [EOL] target = lp . CudaTarget ( ) [EOL] [EOL] kernel = lp . make_kernel ( [string] , [string] , assumptions = [string] ) [EOL] [EOL] kernel = lp . add_dtypes ( kernel , dict ( tavg = np . float32 , state = np . float32 , weights = np . float32 , lengths = np . float32 ) ) [EOL] kernel = kernel . copy ( target = lp . CudaTarget ( ) ) [EOL] code = lp . generate_code_v2 ( kernel ) [EOL] print ( kernel ) [EOL] print ( code . host_code ( ) ) [EOL] print ( code . device_code ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import typing [EOL] import numpy as np [EOL] import loopy as lp [EOL] from tvb_hpc . numbacudatarget import NumbaCudaTarget [EOL] target = NumbaCudaTarget ( ) [EOL] [EOL] coupling_raw = [string] [EOL] model_raw = [string] [EOL] node = [number] [EOL] [comment] [EOL] couplingknl = lp . make_kernel ( [string] , coupling_raw , target = target ) [EOL] couplingknl = lp . add_dtypes ( couplingknl , { [string] : np . float32 , [string] : np . float32 , [string] : np . float32 , [string] : np . float32 , [string] : np . float32 } ) [EOL] couplingknl = lp . split_iname ( couplingknl , [string] , [number] , outer_tag = [string] ) [EOL] [comment] [EOL] modelknl = lp . make_kernel ( [string] , model_raw , target = target ) [EOL] modelknl = lp . add_dtypes ( modelknl , { [string] : np . float32 , [string] : np . float32 , [string] : np . float32 } ) [EOL] [comment] [EOL] knls = couplingknl , modelknl [EOL] data_flow = [ ( [string] , [number] , [number] ) ] [EOL] knl = lp . fuse_kernels ( knls , data_flow = data_flow ) [EOL] print ( knl ) [EOL] print ( [string] ) [EOL] knl = lp . split_iname ( knl , [string] , [number] , outer_tag = [string] ) [EOL] print ( lp . generate_code_v2 ( knl ) . all_code ( ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int]]$ 0 $typing.List[typing.Tuple[builtins.str,builtins.int,builtins.int]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
	0
	0
[docstring] [EOL] [EOL] from lems . base . base import LEMSBase [EOL] [EOL] class Include ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , filename ) : [EOL] [docstring] [EOL] [EOL] self . file = filename [EOL] [docstring] [EOL] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] % self . file [EOL] [EOL] class Dimension ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , description = [string] , ** params ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . m = params [ [string] ] if [string] in params else [number] [EOL] [docstring] [EOL] [EOL] self . l = params [ [string] ] if [string] in params else [number] [EOL] [docstring] [EOL] [EOL] self . t = params [ [string] ] if [string] in params else [number] [EOL] [docstring] [EOL] [EOL] self . i = params [ [string] ] if [string] in params else [number] [EOL] [docstring] [EOL] [EOL] self . k = params [ [string] ] if [string] in params else [number] [EOL] [docstring] [EOL] [EOL] self . n = params [ [string] ] if [string] in params else [number] [EOL] [docstring] [EOL] [EOL] self . j = params [ [string] ] if [string] in params else [number] [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + ( [string] . format ( self . m ) if self . m != [number] else [string] ) + ( [string] . format ( self . l ) if self . l != [number] else [string] ) + ( [string] . format ( self . t ) if self . t != [number] else [string] ) + ( [string] . format ( self . i ) if self . i != [number] else [string] ) + ( [string] . format ( self . k ) if self . k != [number] else [string] ) + ( [string] . format ( self . n ) if self . n != [number] else [string] ) + ( [string] . format ( self . j ) if self . j != [number] else [string] ) + [string] [EOL] [EOL] class Unit ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , symbol , dimension , power = [number] , scale = [number] , offset = [number] , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . symbol = symbol [EOL] [docstring] [EOL] [EOL] self . dimension = dimension [EOL] [docstring] [EOL] [EOL] self . power = power [EOL] [docstring] [EOL] [EOL] self . scale = scale [EOL] [docstring] [EOL] [EOL] self . offset = offset [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return [string] + ( [string] . format ( self . symbol ) if self . symbol else [string] ) + ( [string] . format ( self . dimension ) if self . dimension else [string] ) + ( [string] . format ( self . power ) if self . power else [string] ) + ( [string] . format ( self . scale ) if self . scale else [string] ) + ( [string] . format ( self . offset ) if self . offset else [string] ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import typing [EOL] [docstring] [EOL] [EOL] from lems . base . base import LEMSBase [EOL] from lems . base . map import Map [EOL] from lems . base . errors import ModelError [EOL] [EOL] class With ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , instance , as_ , list = None , index = None ) : [EOL] [docstring] [EOL] [EOL] self . instance = instance [EOL] [docstring] [EOL] [EOL] self . as_ = as_ [EOL] [docstring] [EOL] [EOL] self . list = list [EOL] [docstring] [EOL] [EOL] self . index = index [EOL] [docstring] [EOL] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] + ( [string] . format ( self . instance ) if self . instance else [string] ) + ( [string] . format ( self . list ) if self . list else [string] ) + ( [string] . format ( self . index ) if self . index else [string] ) + [string] . format ( self . instance , self . as_ ) [EOL] [EOL] [EOL] class Tunnel ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , end_a , end_b , component_a , component_b ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . end_a = end_a [EOL] [docstring] [EOL] [EOL] self . end_b = end_b [EOL] [docstring] [EOL] [EOL] self . component_a = component_a [EOL] [docstring] [EOL] [EOL] self . component_b = component_b [EOL] [docstring] [EOL] [EOL] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + [string] . format ( self . end_a ) + [string] . format ( self . end_b ) + [string] . format ( self . component_a ) + [string] . format ( self . component_b ) + [string] [EOL] [EOL] class EventConnection ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , from_ , to , source_port , target_port , receiver , receiver_container ) : [EOL] [docstring] [EOL] [EOL] self . from_ = from_ [EOL] [docstring] [EOL] [EOL] self . to = to [EOL] [docstring] [EOL] [EOL] self . source_port = source_port [EOL] [docstring] [EOL] [EOL] self . target_port = target_port [EOL] [docstring] [EOL] [EOL] self . receiver = receiver [EOL] [docstring] [EOL] [EOL] self . receiver_container = receiver_container [EOL] [docstring] [EOL] [EOL] def __eq__ ( self , o ) : [EOL] return ( self . from_ == o . from_ and self . to == o . to and self . source_port == o . source_port and self . target_port == o . target_port ) [EOL] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] + ( [string] . format ( self . from_ ) if self . from_ else [string] ) + ( [string] . format ( self . to ) if self . to else [string] ) + ( [string] . format ( self . source_port ) if self . source_port else [string] ) + ( [string] . format ( self . target_port ) if self . target_port else [string] ) + ( [string] . format ( self . receiver ) if self . receiver else [string] ) + ( [string] . format ( self . receiver_container ) if self . receiver_container else [string] ) + [string] [EOL] [EOL] class ChildInstance ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , component , referenced_component = None ) : [EOL] [docstring] [EOL] [EOL] self . component = component [EOL] [docstring] [EOL] [EOL] self . referenced_component = referenced_component [EOL] [docstring] [EOL] [EOL] def __eq__ ( self , o ) : [EOL] return self . component == o . component [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . component ) [EOL] [EOL] class Assign ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , property , value ) : [EOL] [docstring] [EOL] [EOL] self . property_ = property [EOL] [docstring] [EOL] [EOL] self . value = value [EOL] [docstring] [EOL] [EOL] def __eq__ ( self , o ) : [EOL] return self . property_ == o . property_ and self . value == o . value [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . property_ , self . value ) [EOL] [EOL] [EOL] class MultiInstantiate ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , component = None , number = None , component_type = None ) : [EOL] [docstring] [EOL] if component and component_type : [EOL] raise AttributeError ( [string] [string] [string] ) [EOL] [EOL] self . component = component [EOL] [docstring] [EOL] [EOL] self . component_type = component_type [EOL] [docstring] [EOL] [EOL] self . number = number [EOL] [docstring] [EOL] [EOL] self . assignments = [ ] [EOL] [docstring] [EOL] [EOL] def __eq__ ( self , o ) : [EOL] if self . component : [EOL] flag = self . component == o . component and self . number == o . number [EOL] else : [EOL] flag = self . component_type == o . component_type and self . number == o . number [EOL] return flag [EOL] [EOL] def add_assign ( self , assign ) : [EOL] [docstring] [EOL] self . assignments . append ( assign ) [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , Assign ) : [EOL] self . add_assign ( child ) [EOL] else : [EOL] raise ModelError ( [string] ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] argstr = [string] [EOL] if self . component : [EOL] argstr += [string] . format ( self . component ) [EOL] if self . component_type : [EOL] argstr += [string] . format ( self . component_type ) [EOL] if self . number : [EOL] argstr += [string] . format ( self . number ) [EOL] if self . assignments : [EOL] chxmlstr = [string] [EOL] for assign in self . assignments : [EOL] chxmlstr += assign . toxml ( ) [EOL] return [string] . format ( argstr , chxmlstr ) [EOL] else : [EOL] return [string] . format ( argstr ) [EOL] [EOL] class ForEach ( LEMSBase ) : [EOL] [docstring] [EOL] def __init__ ( self , instances , as_ ) : [EOL] [EOL] self . instances = instances [EOL] [EOL] self . as_ = as_ [EOL] [EOL] self . event_connections = list ( ) [EOL] [docstring] [EOL] [EOL] self . for_eachs = list ( ) [EOL] [docstring] [EOL] [EOL] [EOL] def add_for_each ( self , fe ) : [EOL] [docstring] [EOL] [EOL] self . for_eachs . append ( fe ) [EOL] [EOL] [EOL] def add_event_connection ( self , ec ) : [EOL] [docstring] [EOL] [EOL] self . event_connections . append ( ec ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] chxmlstr = [string] [EOL] [EOL] for event_connection in self . event_connections : [EOL] chxmlstr += event_connection . toxml ( ) [EOL] [EOL] for for_each in self . for_eachs : [EOL] chxmlstr += for_each . toxml ( ) [EOL] [EOL] [EOL] return [string] . format ( self . instances , self . as_ , chxmlstr ) [EOL] [EOL] [EOL] class Structure ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] self . withs = Map ( ) [EOL] [docstring] [EOL] [EOL] self . tunnels = Map ( ) [EOL] [docstring] [EOL] [EOL] self . event_connections = list ( ) [EOL] [docstring] [EOL] [EOL] self . child_instances = list ( ) [EOL] [docstring] [EOL] [EOL] self . multi_instantiates = list ( ) [EOL] [docstring] [EOL] [EOL] self . for_eachs = list ( ) [EOL] [docstring] [EOL] [EOL] def has_content ( self ) : [EOL] if len ( self . withs ) == [number] and len ( self . event_connections ) == [number] and len ( self . child_instances ) == [number] and len ( self . multi_instantiates ) == [number] and len ( self . for_eachs ) == [number] : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] def add_with ( self , with_ ) : [EOL] [docstring] [EOL] [EOL] self . withs [ with_ . as_ ] = with_ [EOL] [EOL] def add_tunnel ( self , tunnel ) : [EOL] [docstring] [EOL] [EOL] self . tunnels [ tunnel . name ] = tunnel [EOL] [EOL] def add_event_connection ( self , ec ) : [EOL] [docstring] [EOL] [EOL] self . event_connections . append ( ec ) [EOL] [EOL] def add_child_instance ( self , ci ) : [EOL] [docstring] [EOL] [EOL] self . child_instances . append ( ci ) [EOL] [EOL] def add_multi_instantiate ( self , mi ) : [EOL] [docstring] [EOL] [EOL] self . multi_instantiates . append ( mi ) [EOL] [EOL] def add_for_each ( self , fe ) : [EOL] [docstring] [EOL] [EOL] self . for_eachs . append ( fe ) [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , With ) : [EOL] self . add_with ( child ) [EOL] elif isinstance ( child , EventConnection ) : [EOL] self . add_event_connection ( child ) [EOL] elif isinstance ( child , ChildInstance ) : [EOL] self . add_child_instance ( child ) [EOL] elif isinstance ( child , MultiInstantiate ) : [EOL] self . add_multi_instantiate ( child ) [EOL] elif isinstance ( child , ForEach ) : [EOL] self . add_for_each ( child ) [EOL] else : [EOL] raise ModelError ( [string] ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] chxmlstr = [string] [EOL] [EOL] for with_ in self . withs : [EOL] chxmlstr += with_ . toxml ( ) [EOL] [EOL] for event_connection in self . event_connections : [EOL] chxmlstr += event_connection . toxml ( ) [EOL] [EOL] for child_instance in self . child_instances : [EOL] chxmlstr += child_instance . toxml ( ) [EOL] [EOL] for multi_instantiate in self . multi_instantiates : [EOL] chxmlstr += multi_instantiate . toxml ( ) [EOL] [EOL] for for_each in self . for_eachs : [EOL] chxmlstr += for_each . toxml ( ) [EOL] [EOL] if chxmlstr : [EOL] xmlstr = [string] + chxmlstr + [string] [EOL] else : [EOL] xmlstr = [string] [EOL] [EOL] return xmlstr [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[property]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0
import builtins [EOL] from typing import Any , Type [EOL] import typing [EOL] import dsl [EOL] [docstring] [EOL] [EOL] import os [EOL] from os . path import dirname [EOL] import sys [EOL] [EOL] from lems . base . base import LEMSBase [EOL] from lems . base . map import Map [EOL] from lems . parser . LEMS import LEMSFileParser [EOL] from lems . base . util import merge_maps , merge_lists [EOL] from lems . model . component import Constant , ComponentType , Component , FatComponent [EOL] [EOL] from lems . base . errors import ModelError [EOL] from lems . base . errors import SimBuildError [EOL] [EOL] from lems . model . fundamental import Dimension , Unit , Include [EOL] [comment] [EOL] from lems . model . simulation import Run , Record , EventRecord , DataDisplay , DataWriter , EventWriter [EOL] from lems . model . structure import With , EventConnection , ChildInstance , MultiInstantiate [EOL] [EOL] import xml . dom . minidom as minidom [EOL] [EOL] import logging [EOL] [EOL] class Model ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] logging . basicConfig ( level = logging . INFO ) [EOL] [EOL] target_lems_version = [string] [EOL] branch = [string] [EOL] schema_location = [string] . format ( branch , target_lems_version ) [EOL] [comment] [EOL] [EOL] debug = False [EOL] [EOL] def __init__ ( self , include_includes = True , fail_on_missing_includes = True ) : [EOL] [docstring] [EOL] [EOL] self . targets = list ( ) [EOL] [docstring] [EOL] [EOL] self . includes = Map ( ) [EOL] [docstring] [EOL] [EOL] self . dimensions = Map ( ) [EOL] [docstring] [EOL] [EOL] self . units = Map ( ) [EOL] [docstring] [EOL] [EOL] self . component_types = Map ( ) [EOL] [docstring] [EOL] [EOL] self . components = Map ( ) [EOL] [docstring] [EOL] [EOL] self . fat_components = Map ( ) [EOL] [docstring] [EOL] [EOL] self . constants = Map ( ) [EOL] [docstring] [EOL] [EOL] self . include_directories = [ ] [EOL] [docstring] [EOL] [EOL] self . included_files = [ ] [EOL] [docstring] [EOL] [EOL] self . description = None [EOL] [docstring] [EOL] [EOL] self . include_includes = include_includes [EOL] [docstring] [EOL] [EOL] self . fail_on_missing_includes = fail_on_missing_includes [EOL] [docstring] [EOL] [EOL] def add_target ( self , target ) : [EOL] [docstring] [EOL] [EOL] self . targets . append ( target ) [EOL] [EOL] def add_include ( self , include ) : [EOL] [docstring] [EOL] [EOL] self . includes [ include . file ] = include [EOL] [EOL] def add_dimension ( self , dimension ) : [EOL] [docstring] [EOL] [EOL] self . dimensions [ dimension . name ] = dimension [EOL] [EOL] def add_unit ( self , unit ) : [EOL] [docstring] [EOL] [EOL] self . units [ unit . symbol ] = unit [EOL] [EOL] def add_component_type ( self , component_type ) : [EOL] [docstring] [EOL] name = component_type . name [EOL] [EOL] [comment] [EOL] if [string] in name : [EOL] name = name . replace ( [string] , [string] ) [EOL] component_type . name = name [EOL] [EOL] self . component_types [ name ] = component_type [EOL] [EOL] def add_component ( self , component ) : [EOL] [docstring] [EOL] [EOL] self . components [ component . id ] = component [EOL] [EOL] def add_fat_component ( self , fat_component ) : [EOL] [docstring] [EOL] [EOL] self . fat_components [ fat_component . id ] = fat_component [EOL] [EOL] def add_constant ( self , constant ) : [EOL] [docstring] [EOL] [EOL] self . constants [ constant . name ] = constant [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , Include ) : [EOL] self . add_include ( child ) [EOL] elif isinstance ( child , Dimension ) : [EOL] self . add_dimension ( child ) [EOL] elif isinstance ( child , Unit ) : [EOL] self . add_unit ( child ) [EOL] elif isinstance ( child , ComponentType ) : [EOL] self . add_component_type ( child ) [EOL] elif isinstance ( child , Component ) : [EOL] self . add_component ( child ) [EOL] elif isinstance ( child , FatComponent ) : [EOL] self . add_fat_component ( child ) [EOL] elif isinstance ( child , Constant ) : [EOL] self . add_constant ( child ) [EOL] else : [EOL] raise ModelError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def import_from_file ( self , filepath ) : [EOL] [docstring] [EOL] [EOL] inc_dirs = self . include_directories [ : ] [EOL] inc_dirs . append ( dirname ( filepath ) ) [EOL] [EOL] parser = LEMSFileParser ( self , inc_dirs , self . include_includes ) [EOL] with open ( filepath ) as f : [EOL] parser . parse ( f . read ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def resolve ( self ) : [EOL] [docstring] [EOL] model = self . copy ( ) [EOL] [EOL] for ct in model . component_types : [EOL] model . resolve_component_type ( ct ) [EOL] [EOL] for c in model . components : [EOL] if c . id not in model . fat_components : [EOL] model . add ( model . fatten_component ( c ) ) [EOL] [EOL] for c in ct . constants : [EOL] c2 = c . copy ( ) [EOL] c2 . numeric_value = model . get_numeric_value ( c2 . value , c2 . dimension ) [EOL] model . add ( c2 ) [EOL] [EOL] return model [EOL] [EOL] def resolve_component_type ( self , component_type ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if component_type . extends : [EOL] try : [EOL] base_ct = self . component_types [ component_type . extends ] [EOL] except : [EOL] raise ModelError ( [string] , component_type . name , component_type . extends ) [EOL] [EOL] self . resolve_component_type ( base_ct ) [EOL] self . merge_component_types ( component_type , base_ct ) [EOL] component_type . types = set . union ( component_type . types , base_ct . types ) [EOL] component_type . extends = None [EOL] [EOL] def merge_component_types ( self , ct , base_ct ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] for parameter in base_ct . parameters : [EOL] if parameter . name in ct . parameters : [EOL] p = ct . parameters [ parameter . name ] [EOL] basep = base_ct . parameters [ parameter . name ] [EOL] if p . fixed : [EOL] p . value = p . fixed_value [EOL] p . dimension = basep . dimension [EOL] else : [EOL] ct . parameters [ parameter . name ] = base_ct . parameters [ parameter . name ] [EOL] [EOL] merge_maps ( ct . properties , base_ct . properties ) [EOL] [EOL] merge_maps ( ct . derived_parameters , base_ct . derived_parameters ) [EOL] merge_maps ( ct . index_parameters , base_ct . index_parameters ) [EOL] merge_maps ( ct . constants , base_ct . constants ) [EOL] merge_maps ( ct . exposures , base_ct . exposures ) [EOL] merge_maps ( ct . requirements , base_ct . requirements ) [EOL] merge_maps ( ct . component_requirements , base_ct . component_requirements ) [EOL] merge_maps ( ct . instance_requirements , base_ct . instance_requirements ) [EOL] merge_maps ( ct . children , base_ct . children ) [EOL] merge_maps ( ct . texts , base_ct . texts ) [EOL] merge_maps ( ct . links , base_ct . links ) [EOL] merge_maps ( ct . paths , base_ct . paths ) [EOL] merge_maps ( ct . event_ports , base_ct . event_ports ) [EOL] merge_maps ( ct . component_references , base_ct . component_references ) [EOL] merge_maps ( ct . attachments , base_ct . attachments ) [EOL] [EOL] merge_maps ( ct . dynamics . state_variables , base_ct . dynamics . state_variables ) [EOL] merge_maps ( ct . dynamics . derived_variables , base_ct . dynamics . derived_variables ) [EOL] merge_maps ( ct . dynamics . conditional_derived_variables , base_ct . dynamics . conditional_derived_variables ) [EOL] merge_maps ( ct . dynamics . time_derivatives , base_ct . dynamics . time_derivatives ) [EOL] [EOL] [comment] [EOL] [EOL] merge_maps ( ct . dynamics . kinetic_schemes , base_ct . dynamics . kinetic_schemes ) [EOL] [EOL] merge_lists ( ct . structure . event_connections , base_ct . structure . event_connections ) [EOL] merge_lists ( ct . structure . child_instances , base_ct . structure . child_instances ) [EOL] merge_lists ( ct . structure . multi_instantiates , base_ct . structure . multi_instantiates ) [EOL] [EOL] merge_maps ( ct . simulation . runs , base_ct . simulation . runs ) [EOL] merge_maps ( ct . simulation . records , base_ct . simulation . records ) [EOL] merge_maps ( ct . simulation . event_records , base_ct . simulation . event_records ) [EOL] merge_maps ( ct . simulation . data_displays , base_ct . simulation . data_displays ) [EOL] merge_maps ( ct . simulation . data_writers , base_ct . simulation . data_writers ) [EOL] merge_maps ( ct . simulation . event_writers , base_ct . simulation . event_writers ) [EOL] [EOL] def fatten_component ( self , c ) : [EOL] [docstring] [EOL] if self . debug : print ( [string] % c . id ) [EOL] try : [EOL] ct = self . component_types [ c . type ] [EOL] except : [EOL] raise ModelError ( [string] , c . type , c . id , self . component_types . keys ( ) ) [EOL] [EOL] fc = FatComponent ( c . id , c . type ) [EOL] if c . parent_id : fc . set_parent_id ( c . parent_id ) [EOL] [EOL] [comment] [EOL] for parameter in ct . parameters : [EOL] if self . debug : print ( [string] % parameter ) [EOL] if parameter . name in c . parameters : [EOL] p = parameter . copy ( ) [EOL] p . value = c . parameters [ parameter . name ] [EOL] p . numeric_value = self . get_numeric_value ( p . value , p . dimension ) [EOL] fc . add_parameter ( p ) [EOL] elif parameter . fixed : [EOL] p = parameter . copy ( ) [EOL] p . numeric_value = self . get_numeric_value ( p . value , p . dimension ) [EOL] fc . add_parameter ( p ) [EOL] else : [EOL] raise ModelError ( [string] , parameter . name , c . id ) [EOL] [EOL] [comment] [EOL] for property in ct . properties : [EOL] property2 = property . copy ( ) [EOL] fc . add ( property2 ) [EOL] [EOL] [comment] [EOL] for derived_parameter in ct . derived_parameters : [EOL] derived_parameter2 = derived_parameter . copy ( ) [EOL] fc . add ( derived_parameter2 ) [EOL] [EOL] [comment] [EOL] for index_parameter in ct . index_parameters : [EOL] raise ModelError ( [string] ) [EOL] index_parameter2 = index_parameter . copy ( ) [EOL] fc . add ( index_parameter2 ) [EOL] [EOL] [comment] [EOL] for constant in ct . constants : [EOL] constant2 = constant . copy ( ) [EOL] constant2 . numeric_value = self . get_numeric_value ( constant2 . value , constant2 . dimension ) [EOL] fc . add ( constant2 ) [EOL] [EOL] [comment] [EOL] for text in ct . texts : [EOL] t = text . copy ( ) [EOL] t . value = c . parameters [ text . name ] if text . name in c . parameters else [string] [EOL] fc . add ( t ) [EOL] [EOL] [comment] [EOL] for link in ct . links : [EOL] if link . name in c . parameters : [EOL] l = link . copy ( ) [EOL] l . value = c . parameters [ link . name ] [EOL] fc . add ( l ) [EOL] else : [EOL] raise ModelError ( [string] , link . name , c . id ) [EOL] [EOL] [comment] [EOL] for path in ct . paths : [EOL] if path . name in c . parameters : [EOL] p = path . copy ( ) [EOL] p . value = c . parameters [ path . name ] [EOL] fc . add ( p ) [EOL] else : [EOL] raise ModelError ( [string] , path . name , c . id ) [EOL] [EOL] if len ( ct . component_requirements ) > [number] : [EOL] raise ModelError ( [string] ) [EOL] if len ( ct . instance_requirements ) > [number] : [EOL] raise ModelError ( [string] ) [EOL] [EOL] [comment] [EOL] for cref in ct . component_references : [EOL] if cref . local : [EOL] raise ModelError ( [string] ) [EOL] if cref . name in c . parameters : [EOL] cref2 = cref . copy ( ) [EOL] cid = c . parameters [ cref . name ] [EOL] [EOL] if cid not in self . fat_components : [EOL] self . add ( self . fatten_component ( self . components [ cid ] ) ) [EOL] [EOL] cref2 . referenced_component = self . fat_components [ cid ] [EOL] fc . add ( cref2 ) [EOL] else : [EOL] raise ModelError ( [string] , cref . name , c . id ) [EOL] [EOL] merge_maps ( fc . exposures , ct . exposures ) [EOL] merge_maps ( fc . requirements , ct . requirements ) [EOL] merge_maps ( fc . component_requirements , ct . component_requirements ) [EOL] merge_maps ( fc . instance_requirements , ct . instance_requirements ) [EOL] merge_maps ( fc . children , ct . children ) [EOL] merge_maps ( fc . texts , ct . texts ) [EOL] merge_maps ( fc . links , ct . links ) [EOL] merge_maps ( fc . paths , ct . paths ) [EOL] merge_maps ( fc . event_ports , ct . event_ports ) [EOL] merge_maps ( fc . attachments , ct . attachments ) [EOL] [EOL] fc . dynamics = ct . dynamics . copy ( ) [EOL] if len ( fc . dynamics . regimes ) != [number] : [EOL] fc . dynamics . clear ( ) [EOL] [EOL] self . resolve_structure ( fc , ct ) [EOL] self . resolve_simulation ( fc , ct ) [EOL] [EOL] fc . types = ct . types [EOL] [EOL] [comment] [EOL] for child in c . children : [EOL] fc . add ( self . fatten_component ( child ) ) [EOL] [EOL] return fc [EOL] [EOL] [EOL] def get_parent_component ( self , fc ) : [EOL] [docstring] [EOL] if self . debug : print ( [string] % ( fc . id , fc . parent_id ) ) [EOL] parent_comp = None [EOL] for comp in self . components . values ( ) : [EOL] if self . debug : print ( [string] + comp . id ) [EOL] for child in comp . children : [EOL] if parent_comp == None : [EOL] if child . id == fc . id and comp . id == fc . parent_id : [EOL] if self . debug : print ( [string] + comp . id ) [EOL] parent_comp = comp [EOL] else : [EOL] for child2 in child . children : [EOL] if self . debug : print ( [string] % ( child . id , child2 . id ) ) [EOL] if parent_comp == None and child2 . id == fc . id and child . id == fc . parent_id : [EOL] if self . debug : print ( [string] + child . id ) [EOL] parent_comp = child [EOL] break [EOL] else : [EOL] if self . debug : print ( [string] ) [EOL] return parent_comp [EOL] [EOL] [EOL] [EOL] def resolve_structure ( self , fc , ct ) : [EOL] [docstring] [EOL] if self . debug : print ( [string] % ( fc , ct ) ) [EOL] for w in ct . structure . withs : [EOL] try : [EOL] if w . instance == [string] or w . instance == [string] : [EOL] w2 = With ( w . instance , w . as_ ) [EOL] else : [EOL] w2 = With ( fc . paths [ w . instance ] . value , w . as_ ) [EOL] except : [EOL] raise ModelError ( [string] [string] , w . as_ , fc . id ) [EOL] fc . structure . add ( w2 ) [EOL] [EOL] if len ( ct . structure . tunnels ) > [number] : [EOL] raise ModelError ( [string] ) ; [EOL] [EOL] for fe in ct . structure . for_eachs : [EOL] fc . structure . add_for_each ( fe ) [EOL] [EOL] for ev in ct . structure . event_connections : [EOL] try : [EOL] [EOL] from_inst = fc . structure . withs [ ev . from_ ] . instance [EOL] to_inst = fc . structure . withs [ ev . to ] . instance [EOL] [EOL] if self . debug : print ( [string] + from_inst + [string] + to_inst + [string] + str ( fc . paths ) ) [EOL] [EOL] if len ( fc . texts ) > [number] or len ( fc . paths ) > [number] : [EOL] [EOL] source_port = fc . texts [ ev . source_port ] . value if ev . source_port and len ( ev . source_port ) > [number] and ev . source_port in fc . texts else None [EOL] target_port = fc . texts [ ev . target_port ] . value if ev . target_port and len ( ev . target_port ) > [number] and ev . target_port in fc . texts else None [EOL] [EOL] if self . debug : print ( [string] % source_port ) [EOL] if self . debug : print ( [string] % target_port ) [EOL] [EOL] receiver = None [EOL] [EOL] [comment] [EOL] if [string] in ev . receiver : [EOL] receiver_id = None [EOL] parent_attr = ev . receiver [ [number] : ] [EOL] if self . debug : print ( [string] % ( parent_attr , fc , id ( fc ) ) ) [EOL] [EOL] for comp in self . components . values ( ) : [EOL] if self . debug : print ( [string] % ( comp . id , id ( comp ) ) ) [EOL] for child in comp . children : [EOL] if self . debug : print ( [string] % ( child . id , id ( child ) ) ) [EOL] for child2 in child . children : [EOL] if child2 . id == fc . id and child2 . type == fc . type and child . id == fc . parent_id : [EOL] if self . debug : print ( [string] % ( child . id , id ( child ) , child2 ) ) [EOL] receiver_id = child . parameters [ parent_attr ] [EOL] if self . debug : print ( [string] + receiver_id ) [EOL] break [EOL] [EOL] if receiver_id is not None : [EOL] for comp in self . fat_components : [EOL] if comp . id == receiver_id : [EOL] receiver = comp [EOL] if self . debug : print ( [string] % receiver ) [EOL] [EOL] if self . debug : print ( [string] % receiver ) [EOL] if not receiver : [EOL] receiver = fc . component_references [ ev . receiver ] . referenced_component if ev . receiver else None [EOL] receiver_container = fc . texts [ ev . receiver_container ] . value if ( fc . texts and ev . receiver_container ) else [string] [EOL] [EOL] if self . debug : print ( [string] % receiver ) [EOL] if len ( receiver_container ) == [number] : [EOL] [comment] [EOL] receiver_container = [string] [EOL] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [EOL] if self . debug : [EOL] print ( [string] ) [EOL] print ( ev . toxml ( ) ) [EOL] print ( ev . source_port ) [EOL] print ( fc ) [EOL] source_port = ev . source_port [EOL] target_port = ev . target_port [EOL] receiver = None [EOL] receiver_container = None [EOL] [EOL] ev2 = EventConnection ( from_inst , to_inst , source_port , target_port , receiver , receiver_container ) [EOL] if self . debug : [EOL] print ( [string] + ev2 . toxml ( ) ) [EOL] print ( receiver ) [EOL] print ( receiver_container ) [EOL] except : [EOL] logging . exception ( [string] ) [EOL] raise ModelError ( [string] , fc ) [EOL] fc . structure . add ( ev2 ) [EOL] [EOL] for ch in ct . structure . child_instances : [EOL] try : [EOL] if self . debug : print ( ch . toxml ( ) ) [EOL] if [string] in ch . component : [EOL] parent = self . get_parent_component ( fc ) [EOL] if self . debug : print ( [string] % parent ) [EOL] comp_ref = ch . component [ [number] : ] [EOL] if self . debug : print ( [string] % comp_ref ) [EOL] comp_id = parent . parameters [ comp_ref ] [EOL] comp = self . fat_components [ comp_id ] [EOL] ch2 = ChildInstance ( ch . component , comp ) [EOL] else : [EOL] ref_comp = fc . component_references [ ch . component ] . referenced_component [EOL] ch2 = ChildInstance ( ch . component , ref_comp ) [EOL] except Exception as e : [EOL] if self . debug : print ( e ) [EOL] raise ModelError ( [string] [string] , ch . component , fc . id ) [EOL] fc . structure . add ( ch2 ) [EOL] [EOL] for mi in ct . structure . multi_instantiates : [EOL] try : [EOL] if mi . component : [EOL] mi2 = MultiInstantiate ( component = fc . component_references [ mi . component ] . referenced_component , number = int ( fc . parameters [ mi . number ] . numeric_value ) ) [EOL] else : [EOL] mi2 = MultiInstantiate ( component_type = fc . component_references [ mi . component_type ] . referenced_component , number = int ( fc . parameters [ mi . number ] . numeric_value ) ) [EOL] except : [EOL] raise ModelError ( [string] [string] , mi . component , fc ) [EOL] fc . structure . add ( mi2 ) [EOL] [EOL] def resolve_simulation ( self , fc , ct ) : [EOL] [docstring] [EOL] [EOL] for run in ct . simulation . runs : [EOL] try : [EOL] run2 = Run ( fc . component_references [ run . component ] . referenced_component , run . variable , fc . parameters [ run . increment ] . numeric_value , fc . parameters [ run . total ] . numeric_value ) [EOL] except : [EOL] raise ModelError ( [string] , fc . id ) [EOL] fc . simulation . add ( run2 ) [EOL] [EOL] for record in ct . simulation . records : [EOL] try : [EOL] record2 = Record ( fc . paths [ record . quantity ] . value , fc . parameters [ record . scale ] . numeric_value if record . scale else [number] , fc . texts [ record . color ] . value if record . color else [string] ) [EOL] except : [EOL] raise ModelError ( [string] , fc . id ) [EOL] fc . simulation . add ( record2 ) [EOL] [EOL] for event_record in ct . simulation . event_records : [EOL] try : [EOL] event_record2 = EventRecord ( fc . paths [ event_record . quantity ] . value , fc . texts [ event_record . eventPort ] . value ) [EOL] except : [EOL] raise ModelError ( [string] , fc . id ) [EOL] fc . simulation . add ( event_record2 ) [EOL] [EOL] for dd in ct . simulation . data_displays : [EOL] try : [EOL] dd2 = DataDisplay ( fc . texts [ dd . title ] . value , [string] ) [EOL] if [string] in fc . parameters : [EOL] dd2 . timeScale = fc . parameters [ [string] ] . numeric_value [EOL] except : [EOL] raise ModelError ( [string] , fc . id ) [EOL] fc . simulation . add ( dd2 ) [EOL] [EOL] for dw in ct . simulation . data_writers : [EOL] try : [EOL] path = [string] [EOL] if fc . texts [ dw . path ] and fc . texts [ dw . path ] . value : [EOL] path = fc . texts [ dw . path ] . value [EOL] [EOL] dw2 = DataWriter ( path , fc . texts [ dw . file_name ] . value ) [EOL] except : [EOL] raise ModelError ( [string] , fc . id ) [EOL] fc . simulation . add ( dw2 ) [EOL] [EOL] for ew in ct . simulation . event_writers : [EOL] try : [EOL] path = [string] [EOL] if fc . texts [ ew . path ] and fc . texts [ ew . path ] . value : [EOL] path = fc . texts [ ew . path ] . value [EOL] [EOL] ew2 = EventWriter ( path , fc . texts [ ew . file_name ] . value , fc . texts [ ew . format ] . value ) [EOL] except : [EOL] raise ModelError ( [string] , fc . id ) [EOL] fc . simulation . add ( ew2 ) [EOL] [EOL] [EOL] def get_numeric_value ( self , value_str , dimension = None ) : [EOL] [docstring] [EOL] [EOL] n = None [EOL] i = len ( value_str ) [EOL] while n is None : [EOL] try : [EOL] part = value_str [ [number] : i ] [EOL] nn = float ( part ) [EOL] n = nn [EOL] s = value_str [ i : ] [EOL] except ValueError : [EOL] i = i - [number] [EOL] [EOL] [EOL] number = n [EOL] sym = s [EOL] numeric_value = None [EOL] [EOL] if sym == [string] : [EOL] numeric_value = number [EOL] else : [EOL] if sym in self . units : [EOL] unit = self . units [ sym ] [EOL] if dimension : [EOL] if dimension != unit . dimension and dimension != [string] : [EOL] raise SimBuildError ( [string] [string] , sym , dimension ) [EOL] else : [EOL] dimension = unit . dimension [EOL] [EOL] numeric_value = ( number * ( [number] ** unit . power ) * unit . scale ) + unit . offset [EOL] else : [EOL] raise SimBuildError ( [string] , sym , self . units ) [EOL] [EOL] [comment] [EOL] return numeric_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from lems . base . base import LEMSBase [EOL] from lems . base . errors import ModelError [EOL] from lems . base . map import Map [EOL] [EOL] class Run ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , component , variable , increment , total ) : [EOL] [docstring] [EOL] [EOL] self . component = component [EOL] [docstring] [EOL] [EOL] self . variable = variable [EOL] [docstring] [EOL] [EOL] self . increment = increment [EOL] [docstring] [EOL] [EOL] self . total = total [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . component , self . variable , self . increment , self . total ) [EOL] [EOL] class Record ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , quantity , scale = None , color = None , id = None ) : [EOL] [docstring] [EOL] [EOL] self . id = [string] [EOL] [docstring] [EOL] [EOL] self . quantity = quantity [EOL] [docstring] [EOL] [EOL] self . scale = scale [EOL] [docstring] [EOL] [EOL] self . color = color [EOL] [docstring] [EOL] [EOL] self . id = id [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . quantity , self . scale , self . color , self . id ) [EOL] class EventRecord ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , quantity , eventPort ) : [EOL] [docstring] [EOL] [EOL] self . id = [string] [EOL] [docstring] [EOL] [EOL] self . quantity = quantity [EOL] [docstring] [EOL] [EOL] self . eventPort = eventPort [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . quantity , self . eventPort ) [EOL] [EOL] class DataOutput ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] class DataDisplay ( DataOutput ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , title , data_region ) : [EOL] [docstring] [EOL] [EOL] DataOutput . __init__ ( self ) [EOL] [EOL] self . title = title [EOL] [docstring] [EOL] [EOL] self . data_region = data_region [EOL] [docstring] [EOL] [EOL] self . time_scale = [number] [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . title , self . data_region ) [EOL] [EOL] class DataWriter ( DataOutput ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , file_name ) : [EOL] [docstring] [EOL] [EOL] DataOutput . __init__ ( self ) [EOL] [EOL] self . path = path [EOL] [docstring] [EOL] [EOL] self . file_name = file_name [EOL] [docstring] [EOL] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . path , self . file_name ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . path , self . file_name ) [EOL] [EOL] [EOL] class EventWriter ( DataOutput ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , file_name , format ) : [EOL] [docstring] [EOL] [EOL] DataOutput . __init__ ( self ) [EOL] [EOL] self . path = path [EOL] [docstring] [EOL] [EOL] self . file_name = file_name [EOL] [docstring] [EOL] [EOL] self . format = format [EOL] [docstring] [EOL] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . path , self . file_name , self . format ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . path , self . file_name , self . format ) [EOL] [EOL] [EOL] [EOL] class Simulation ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] self . runs = Map ( ) [EOL] [docstring] [EOL] [EOL] self . records = Map ( ) [EOL] [docstring] [EOL] [EOL] self . event_records = Map ( ) [EOL] [docstring] [EOL] [EOL] self . data_displays = Map ( ) [EOL] [docstring] [EOL] [EOL] self . data_writers = Map ( ) [EOL] [docstring] [EOL] [EOL] self . event_writers = Map ( ) [EOL] [docstring] [EOL] [EOL] def add_run ( self , run ) : [EOL] [docstring] [EOL] [EOL] self . runs [ run . component ] = run [EOL] [EOL] def add_record ( self , record ) : [EOL] [docstring] [EOL] [EOL] self . records [ record . quantity ] = record [EOL] [EOL] def add_event_record ( self , event_record ) : [EOL] [docstring] [EOL] [EOL] self . event_records [ event_record . quantity ] = event_record [EOL] [EOL] def add_data_display ( self , data_display ) : [EOL] [docstring] [EOL] [EOL] self . data_displays [ data_display . title ] = data_display [EOL] [EOL] def add_data_writer ( self , data_writer ) : [EOL] [docstring] [EOL] [EOL] self . data_writers [ data_writer . path ] = data_writer [EOL] [EOL] def add_event_writer ( self , event_writer ) : [EOL] [docstring] [EOL] [EOL] self . event_writers [ event_writer . path ] = event_writer [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , Run ) : [EOL] self . add_run ( child ) [EOL] elif isinstance ( child , Record ) : [EOL] self . add_record ( child ) [EOL] elif isinstance ( child , EventRecord ) : [EOL] self . add_event_record ( child ) [EOL] elif isinstance ( child , DataDisplay ) : [EOL] self . add_data_display ( child ) [EOL] elif isinstance ( child , DataWriter ) : [EOL] self . add_data_writer ( child ) [EOL] elif isinstance ( child , EventWriter ) : [EOL] self . add_event_writer ( child ) [EOL] else : [EOL] raise ModelError ( [string] ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] chxmlstr = [string] [EOL] [EOL] for run in self . runs : [EOL] chxmlstr += run . toxml ( ) [EOL] [EOL] for record in self . records : [EOL] chxmlstr += record . toxml ( ) [EOL] [EOL] for event_record in self . event_records : [EOL] chxmlstr += event_record . toxml ( ) [EOL] [EOL] for data_display in self . data_displays : [EOL] chxmlstr += data_display . toxml ( ) [EOL] [EOL] for data_writer in self . data_writers : [EOL] chxmlstr += data_writer . toxml ( ) [EOL] [EOL] for event_writer in self . event_writers : [EOL] chxmlstr += event_writer . toxml ( ) [EOL] [EOL] if chxmlstr : [EOL] xmlstr = [string] + chxmlstr + [string] [EOL] else : [EOL] xmlstr = [string] [EOL] [EOL] return xmlstr [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from lems . base . base import LEMSBase [EOL] from lems . base . map import Map [EOL] from lems . base . errors import ModelError , ParseError [EOL] [EOL] from lems . model . dynamics import Dynamics [EOL] from lems . model . structure import Structure [EOL] from lems . model . simulation import Simulation [EOL] [EOL] from lems . parser . expr import ExprParser [EOL] [EOL] [EOL] class Parameter ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , dimension , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . dimension = dimension [EOL] [docstring] [EOL] [EOL] self . fixed = False [EOL] [docstring] [EOL] [EOL] self . fixed_value = None [EOL] [docstring] [EOL] [EOL] self . value = None [EOL] [docstring] [EOL] [EOL] self . numeric_value = None [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( [string] if self . fixed else [string] , self . name , self . dimension ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( [string] if self . fixed else [string] , self . name , self . dimension ) + ( [string] . format ( self . description ) if self . description else [string] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] [EOL] class Fixed ( Parameter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , parameter , value , description = [string] ) : [EOL] [docstring] [EOL] [EOL] Parameter . __init__ ( self , parameter , [string] , description ) [EOL] [EOL] self . fixed = True [EOL] self . fixed_value = value [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + [string] . format ( self . fixed_value ) + [string] [EOL] [EOL] [EOL] class Property ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , dimension = None , default_value = None , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . dimension = dimension [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] self . default_value = default_value [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + ( [string] . format ( self . dimension ) if self . dimension else [string] ) + ( [string] . format ( self . default_value ) if self . default_value else [string] ) + [string] [EOL] [EOL] [EOL] class IndexParameter ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + [string] + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class DerivedParameter ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , value , expression = None , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . expression = expression [EOL] [docstring] [EOL] [EOL] self . value = value [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] try : [EOL] ep = ExprParser ( self . expression ) [EOL] self . expression_tree = ep . parse ( ) [EOL] except : [EOL] raise ParseError ( [string] [string] , self . expression , self . name ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + ( [string] . format ( self . dimension ) if self . dimension else [string] ) + ( [string] . format ( self . expression ) if self . expression else [string] ) + [string] [EOL] [EOL] [EOL] class Constant ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , default , domain = None , symbol = None , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . symbol = symbol [EOL] [docstring] [EOL] [EOL] self . default = default [EOL] [docstring] [EOL] [EOL] self . domain = domain [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] self . numeric_value = None [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] + ( [string] . format ( self . name ) if self . name else [string] ) + ( [string] . format ( self . symbol ) if self . symbol else [string] ) + ( [string] . format ( self . value ) if self . value else [string] ) + ( [string] . format ( self . dimension ) if self . dimension else [string] ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class Function ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , value , dimension = None , symbol = None , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . symbol = symbol [EOL] [docstring] [EOL] [EOL] self . value = value [EOL] [docstring] [EOL] [EOL] self . dimension = dimension [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] self . numeric_value = None [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] + ( [string] . format ( self . name ) if self . name else [string] ) + ( [string] . format ( self . symbol ) if self . symbol else [string] ) + ( [string] . format ( self . value ) if self . value else [string] ) + ( [string] . format ( self . dimension ) if self . dimension else [string] ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class Exposure ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , choices , default , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . choices = list ( choices . split ( [string] ) ) [EOL] [docstring] [EOL] [EOL] self . default = list ( default . split ( [string] ) ) [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name , self . choices ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class Requirement ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , dimension , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . dimension = dimension [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name , self . dimension ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class ComponentRequirement ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + [string] + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class InstanceRequirement ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , type , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . type = type [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name , self . dimension ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class Children ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , type_ , multiple = False ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . type = type_ [EOL] [docstring] [EOL] [EOL] self . multiple = multiple [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name , self . type , [string] if self . multiple else [string] ) [EOL] [EOL] [EOL] class Text ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] self . value = None [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . name ) + ( [string] . format ( self . description ) if self . description else [string] ) + ( [string] . format ( self . value ) if self . value else [string] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] [EOL] class Link ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , type_ , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . type = type_ [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] self . value = None [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name , self . type ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class Path ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] self . value = None [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class EventPort ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , direction , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] d = direction . lower ( ) [EOL] if d != [string] and d != [string] : [EOL] raise ModelError ( [string] . format ( direction , name ) ) [EOL] [EOL] self . direction = direction [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name , self . direction ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class ComponentReference ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , type_ , local = None ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . type = type_ [EOL] [docstring] [EOL] [EOL] self . local = local [EOL] [docstring] [EOL] [EOL] self . referenced_component = None [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name , self . type ) + ( [string] . format ( self . local ) if self . local else [string] ) + [string] [EOL] [EOL] [EOL] class Attachments ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , type_ , description = [string] ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . type = type_ [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name , self . type ) + ( [string] . format ( self . description ) if self . description else [string] ) + [string] [EOL] [EOL] [EOL] class Fat ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] self . parameters = Map ( ) [EOL] [docstring] [EOL] [EOL] self . properties = Map ( ) [EOL] [docstring] [EOL] [EOL] self . derived_parameters = Map ( ) [EOL] [docstring] [EOL] [EOL] self . index_parameters = Map ( ) [EOL] [docstring] [EOL] [EOL] self . constants = Map ( ) [EOL] [docstring] [EOL] [EOL] self . functions = Map ( ) [EOL] [EOL] self . exposures = Map ( ) [EOL] [docstring] [EOL] [EOL] self . requirements = Map ( ) [EOL] [docstring] [EOL] [EOL] self . component_requirements = Map ( ) [EOL] [docstring] [EOL] [EOL] self . instance_requirements = Map ( ) [EOL] [docstring] [EOL] [EOL] self . children = Map ( ) [EOL] [docstring] [EOL] [EOL] self . texts = Map ( ) [EOL] [docstring] [EOL] [EOL] self . links = Map ( ) [EOL] [docstring] [EOL] [EOL] self . paths = Map ( ) [EOL] [docstring] [EOL] [EOL] self . event_ports = Map ( ) [EOL] [docstring] [EOL] [EOL] self . component_references = Map ( ) [EOL] [docstring] [EOL] [EOL] self . attachments = Map ( ) [EOL] [docstring] [EOL] [EOL] self . dynamics = Dynamics ( ) [EOL] [docstring] [EOL] [EOL] self . structure = Structure ( ) [EOL] [docstring] [EOL] [EOL] self . simulation = Simulation ( ) [EOL] [docstring] [EOL] [EOL] self . types = set ( ) [EOL] [docstring] [EOL] [EOL] def add_parameter ( self , parameter ) : [EOL] [docstring] [EOL] [EOL] self . parameters [ parameter . name ] = parameter [EOL] [EOL] def add_property ( self , property ) : [EOL] [docstring] [EOL] [EOL] self . properties [ property . name ] = property [EOL] [EOL] def add_derived_parameter ( self , derived_parameter ) : [EOL] [docstring] [EOL] [EOL] self . derived_parameters [ derived_parameter . name ] = derived_parameter [EOL] [EOL] def add_index_parameter ( self , index_parameter ) : [EOL] [docstring] [EOL] [EOL] self . index_parameters [ index_parameter . name ] = index_parameter [EOL] [EOL] def add_constant ( self , constant ) : [EOL] [docstring] [EOL] [EOL] self . constants [ constant . name ] = constant [EOL] [EOL] def add_function ( self , function ) : [EOL] [docstring] [EOL] [EOL] self . functions [ function . name ] = function [EOL] [EOL] def add_exposure ( self , exposure ) : [EOL] [docstring] [EOL] [EOL] self . exposures [ exposure . name ] = exposure [EOL] [EOL] def add_requirement ( self , requirement ) : [EOL] [docstring] [EOL] [EOL] self . requirements [ requirement . name ] = requirement [EOL] [EOL] def add_component_requirement ( self , component_requirement ) : [EOL] [docstring] [EOL] [EOL] self . component_requirements [ component_requirement . name ] = component_requirement [EOL] [EOL] def add_instance_requirement ( self , instance_requirement ) : [EOL] [docstring] [EOL] [EOL] self . instance_requirements [ instance_requirement . name ] = instance_requirement [EOL] [EOL] def add_children ( self , children ) : [EOL] [docstring] [EOL] [EOL] self . children [ children . name ] = children [EOL] [EOL] def add_text ( self , text ) : [EOL] [docstring] [EOL] [EOL] self . texts [ text . name ] = text [EOL] [EOL] def add_link ( self , link ) : [EOL] [docstring] [EOL] [EOL] self . links [ link . name ] = link [EOL] [EOL] def add_path ( self , path ) : [EOL] [docstring] [EOL] [EOL] self . paths [ path . name ] = path [EOL] [EOL] def add_event_port ( self , event_port ) : [EOL] [docstring] [EOL] [EOL] self . event_ports [ event_port . name ] = event_port [EOL] [EOL] def add_component_reference ( self , component_reference ) : [EOL] [docstring] [EOL] [EOL] self . component_references [ component_reference . name ] = component_reference [EOL] [EOL] def add_attachments ( self , attachments ) : [EOL] [docstring] [EOL] [EOL] self . attachments [ attachments . name ] = attachments [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , Parameter ) : [EOL] self . add_parameter ( child ) [EOL] elif isinstance ( child , Property ) : [EOL] self . add_property ( child ) [EOL] elif isinstance ( child , DerivedParameter ) : [EOL] self . add_derived_parameter ( child ) [EOL] elif isinstance ( child , IndexParameter ) : [EOL] self . add_index_parameter ( child ) [EOL] elif isinstance ( child , Constant ) : [EOL] self . add_constant ( child ) [EOL] elif isinstance ( child , Exposure ) : [EOL] self . add_exposure ( child ) [EOL] elif isinstance ( child , Requirement ) : [EOL] self . add_requirement ( child ) [EOL] elif isinstance ( child , ComponentRequirement ) : [EOL] self . add_component_requirement ( child ) [EOL] elif isinstance ( child , InstanceRequirement ) : [EOL] self . add_instance_requirement ( child ) [EOL] elif isinstance ( child , Children ) : [EOL] self . add_children ( child ) [EOL] elif isinstance ( child , Text ) : [EOL] self . add_text ( child ) [EOL] elif isinstance ( child , Link ) : [EOL] self . add_link ( child ) [EOL] elif isinstance ( child , Path ) : [EOL] self . add_path ( child ) [EOL] elif isinstance ( child , EventPort ) : [EOL] self . add_event_port ( child ) [EOL] elif isinstance ( child , ComponentReference ) : [EOL] self . add_component_reference ( child ) [EOL] elif isinstance ( child , Attachments ) : [EOL] self . add_attachments ( child ) [EOL] else : [EOL] raise ModelError ( [string] ) [EOL] [EOL] [EOL] class ComponentType ( Fat ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , description = [string] , extends = None ) : [EOL] [docstring] [EOL] [EOL] Fat . __init__ ( self ) [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . extends = extends [EOL] [docstring] [EOL] [EOL] self . description = description [EOL] [docstring] [EOL] [EOL] self . types . add ( name ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . name ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] xmlstr = [string] . format ( self . name ) + ( [string] . format ( self . extends ) if self . extends else [string] ) + ( [string] . format ( self . description ) if self . description else [string] ) [EOL] [EOL] chxmlstr = [string] [EOL] [EOL] for property in self . properties : [EOL] chxmlstr += property . toxml ( ) [EOL] [EOL] for parameter in self . parameters : [EOL] chxmlstr += parameter . toxml ( ) [EOL] [EOL] for derived_parameter in self . derived_parameters : [EOL] chxmlstr += derived_parameter . toxml ( ) [EOL] [EOL] for index_parameter in self . index_parameters : [EOL] chxmlstr += index_parameter . toxml ( ) [EOL] [EOL] for constant in self . constants : [EOL] chxmlstr += constant . toxml ( ) [EOL] [EOL] childxml = [string] [EOL] childrenxml = [string] [EOL] [EOL] for children in self . children : [EOL] if children . multiple : [EOL] childrenxml += children . toxml ( ) [EOL] else : [EOL] childxml += children . toxml ( ) [EOL] [EOL] chxmlstr += childxml [EOL] chxmlstr += childrenxml [EOL] [EOL] for link in self . links : [EOL] chxmlstr += link . toxml ( ) [EOL] [EOL] for component_reference in self . component_references : [EOL] chxmlstr += component_reference . toxml ( ) [EOL] [EOL] for attachment in self . attachments : [EOL] chxmlstr += attachment . toxml ( ) [EOL] [EOL] for event_port in self . event_ports : [EOL] chxmlstr += event_port . toxml ( ) [EOL] [EOL] for exposure in self . exposures : [EOL] chxmlstr += exposure . toxml ( ) [EOL] [EOL] for requirement in self . requirements : [EOL] chxmlstr += requirement . toxml ( ) [EOL] [EOL] for component_requirement in self . component_requirements : [EOL] chxmlstr += component_requirement . toxml ( ) [EOL] [EOL] for instance_requirement in self . instance_requirements : [EOL] chxmlstr += instance_requirement . toxml ( ) [EOL] [EOL] for path in self . paths : [EOL] chxmlstr += path . toxml ( ) [EOL] [EOL] for text in self . texts : [EOL] chxmlstr += text . toxml ( ) [EOL] [EOL] chxmlstr += self . dynamics . toxml ( ) [EOL] chxmlstr += self . structure . toxml ( ) [EOL] chxmlstr += self . simulation . toxml ( ) [EOL] [EOL] if chxmlstr : [EOL] xmlstr += [string] + chxmlstr + [string] [EOL] else : [EOL] xmlstr += [string] [EOL] [EOL] return xmlstr [EOL] [EOL] [EOL] class Component ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , id_ , type_ , ** params ) : [EOL] [docstring] [EOL] [EOL] self . id = id_ [EOL] [docstring] [EOL] [EOL] self . type = type_ [EOL] [docstring] [EOL] [EOL] self . parameters = dict ( ) [EOL] [docstring] [EOL] for key in params . keys ( ) : [EOL] self . parameters [ key ] = params [ key ] [EOL] [EOL] self . children = list ( ) [EOL] [docstring] [EOL] [EOL] self . parent_id = None [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . id , self . type , self . parameters , self . parent_id ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] def set_parameter ( self , parameter , value ) : [EOL] [docstring] [EOL] [EOL] self . parameters [ parameter ] = value [EOL] [EOL] def add_child ( self , child ) : [EOL] [docstring] [EOL] [EOL] self . children . append ( child ) [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , Component ) : [EOL] self . add_child ( child ) [EOL] else : [EOL] raise ModelError ( [string] ) [EOL] [EOL] def set_parent_id ( self , parent_id ) : [EOL] [docstring] [EOL] [EOL] self . parent_id = parent_id [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] xmlstr = [string] . format ( self . id , self . type ) [EOL] [EOL] for ( k , v ) in self . parameters . items ( ) : [EOL] xmlstr += [string] . format ( k , v ) [EOL] [EOL] if self . children : [EOL] xmlstr += [string] [EOL] for child in self . children : [EOL] xmlstr += child . toxml ( ) [EOL] xmlstr += [string] [EOL] else : [EOL] xmlstr += [string] [EOL] [EOL] return xmlstr [EOL] [EOL] [EOL] class FatComponent ( Fat ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , id_ , type_ ) : [EOL] [docstring] [EOL] [EOL] Fat . __init__ ( self ) [EOL] [EOL] self . id = id_ [EOL] [docstring] [EOL] [EOL] self . type = type_ [EOL] [docstring] [EOL] [EOL] self . child_components = list ( ) [EOL] [docstring] [EOL] [EOL] self . parent_id = None [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . id , self . type , self . parent_id ) + ( [string] . format ( len ( self . child_components ) ) if len ( self . child_components ) > [number] else [string] ) [EOL] [EOL] def add_child_component ( self , child_component ) : [EOL] [docstring] [EOL] [EOL] self . child_components . append ( child_component ) [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , FatComponent ) : [EOL] self . add_child_component ( child ) [EOL] else : [EOL] Fat . add ( self , child ) [EOL] [EOL] def set_parent_id ( self , parent_id ) : [EOL] [docstring] [EOL] [EOL] self . parent_id = parent_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Literal , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] from lems . base . base import LEMSBase [EOL] from lems . base . map import Map [EOL] from lems . base . errors import ModelError , ParseError [EOL] [EOL] from lems . parser . expr import ExprParser [EOL] [EOL] [EOL] class StateVariable ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , default , boundaries = None ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . default = default [EOL] [docstring] [EOL] [EOL] self . boundaries = boundaries [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . name , self . default ) + ( [string] . format ( self . boundaries ) if self . boundaries else [string] ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name , self . dimension ) + ( [string] . format ( self . exposure ) if self . exposure else [string] ) + [string] [EOL] [EOL] [EOL] class DerivedVariable ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , ** params ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . dimension = params [ [string] ] if [string] in params else None [EOL] [docstring] [EOL] [EOL] self . exposure = params [ [string] ] if [string] in params else None [EOL] [docstring] [EOL] [EOL] self . select = params [ [string] ] if [string] in params else None [EOL] [docstring] [EOL] [EOL] self . expression = params [ [string] ] if [string] in params else None [EOL] [docstring] [EOL] [EOL] self . reduce = params [ [string] ] if [string] in params else None [EOL] [docstring] [EOL] [EOL] self . required = params [ [string] ] if [string] in params else None [EOL] [docstring] [EOL] [EOL] self . expression_tree = None [EOL] [docstring] [EOL] [EOL] if self . expression != None : [EOL] try : [EOL] self . expression_tree = ExprParser ( self . expression ) . parse ( ) [EOL] except : [EOL] raise ParseError ( [string] [string] , self . expression , self . name ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . name ) + ( [string] . format ( self . dimension ) if self . dimension else [string] ) + ( [string] . format ( self . exposure ) if self . exposure else [string] ) + ( [string] . format ( self . select ) if self . select else [string] ) + ( [string] . format ( self . value ) if self . value else [string] ) + ( [string] . format ( self . reduce ) if self . reduce else [string] ) + ( [string] . format ( self . required ) if self . required else [string] ) + [string] [EOL] [EOL] [EOL] class Case ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , condition , value ) : [EOL] [docstring] [EOL] [EOL] self . condition = condition [EOL] [docstring] [EOL] [EOL] self . value = value [EOL] [docstring] [EOL] [EOL] self . condition_expression_tree = None [EOL] [docstring] [EOL] [EOL] self . value_expression_tree = None [EOL] [docstring] [EOL] [EOL] try : [EOL] self . value_expression_tree = ExprParser ( self . value ) . parse ( ) [EOL] [EOL] if not self . condition : [EOL] self . condition_expression_tree = None [EOL] else : [EOL] self . condition_expression_tree = ExprParser ( self . condition ) . parse ( ) [EOL] except : [EOL] raise ParseError ( [string] [string] , self . condition , self . value ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . condition , self . value ) + [string] [EOL] [EOL] [EOL] class ConditionalDerivedVariable ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , condition , exposure = None , cases = None ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . condition = condition [EOL] [docstring] [EOL] [EOL] self . exposure = exposure [EOL] [docstring] [EOL] [EOL] self . cases = list ( cases . split ( [string] ) ) [EOL] [docstring] [EOL] [EOL] def add_case ( self , case ) : [EOL] [docstring] [EOL] [EOL] self . cases . append ( case ) [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , Case ) : [EOL] self . add_case ( child ) [EOL] else : [EOL] raise ModelError ( [string] ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] xmlstr = [string] . format ( self . name ) + ( [string] . format ( self . dimension ) if self . dimension else [string] ) + ( [string] . format ( self . exposure ) if self . exposure else [string] ) [EOL] [EOL] chxmlstr = [string] [EOL] [EOL] for case in self . cases : [EOL] chxmlstr += case . toxml ( ) [EOL] [EOL] if chxmlstr : [EOL] xmlstr += [string] + chxmlstr + [string] [EOL] else : [EOL] xmlstr += [string] [EOL] [EOL] return xmlstr [EOL] [EOL] [EOL] class TimeDerivative ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , expression ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . expression = expression [EOL] [docstring] [EOL] [EOL] self . expression_tree = None [EOL] [docstring] [EOL] [EOL] try : [EOL] self . expression_tree = ExprParser ( expression ) . parse ( ) [EOL] except : [EOL] raise ParseError ( [string] [string] , self . expression , self . name ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . variable , self . value ) [EOL] [EOL] [EOL] class Action ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class StateAssignment ( Action ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , variable , value ) : [EOL] [docstring] [EOL] [EOL] Action . __init__ ( self ) [EOL] [EOL] self . variable = variable [EOL] [docstring] [EOL] [EOL] self . value = value [EOL] [docstring] [EOL] [EOL] self . expression_tree = None [EOL] [docstring] [EOL] [EOL] try : [EOL] self . expression_tree = ExprParser ( value ) . parse ( ) [EOL] except : [EOL] raise ParseError ( [string] [string] [string] , self . value , self . variable ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . variable , self . value ) [EOL] [EOL] [EOL] class EventOut ( Action ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , port ) : [EOL] [docstring] [EOL] [EOL] Action . __init__ ( self ) [EOL] [EOL] self . port = port [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . port ) [EOL] [EOL] [EOL] class Transition ( Action ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , regime ) : [EOL] [docstring] [EOL] [EOL] Action . __init__ ( self ) [EOL] [EOL] self . regime = regime [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . regime ) [EOL] [EOL] [EOL] class EventHandler ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] self . actions = list ( ) [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] istr = [string] [EOL] return istr [EOL] [EOL] def add_action ( self , action ) : [EOL] [docstring] [EOL] [EOL] self . actions . append ( action ) [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , Action ) : [EOL] self . add_action ( child ) [EOL] else : [EOL] raise ModelError ( [string] ) [EOL] [EOL] [EOL] class OnStart ( EventHandler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] EventHandler . __init__ ( self ) [EOL] [EOL] def __str__ ( self ) : [EOL] istr = [string] [EOL] for action in self . actions : [EOL] istr += str ( action ) [EOL] istr += [string] [EOL] return str ( istr ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] xmlstr = [string] [EOL] [EOL] chxmlstr = [string] [EOL] [EOL] for action in self . actions : [EOL] chxmlstr += action . toxml ( ) [EOL] [EOL] if chxmlstr : [EOL] xmlstr += [string] + chxmlstr + [string] [EOL] else : [EOL] xmlstr += [string] [EOL] [EOL] return xmlstr [EOL] [EOL] [EOL] class OnCondition ( EventHandler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , test ) : [EOL] [docstring] [EOL] [EOL] EventHandler . __init__ ( self ) [EOL] [EOL] self . test = test [EOL] [docstring] [EOL] [EOL] try : [EOL] self . expression_tree = ExprParser ( test ) . parse ( ) [EOL] except : [EOL] raise ParseError ( [string] , test ) [EOL] [EOL] def __str__ ( self ) : [EOL] istr = [string] [EOL] return istr [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] xmlstr = [string] . format ( self . test ) [EOL] [EOL] chxmlstr = [string] [EOL] [EOL] for action in self . actions : [EOL] chxmlstr += action . toxml ( ) [EOL] [EOL] if chxmlstr : [EOL] xmlstr += [string] + chxmlstr + [string] [EOL] else : [EOL] xmlstr += [string] [EOL] [EOL] return xmlstr [EOL] [EOL] [EOL] class OnEvent ( EventHandler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , port ) : [EOL] [docstring] [EOL] [EOL] EventHandler . __init__ ( self ) [EOL] [EOL] self . port = port [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] istr = [string] % self . port [EOL] return istr [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] xmlstr = [string] . format ( self . port ) [EOL] [EOL] chxmlstr = [string] [EOL] [EOL] for action in self . actions : [EOL] chxmlstr += action . toxml ( ) [EOL] [EOL] if chxmlstr : [EOL] xmlstr += [string] + chxmlstr + [string] [EOL] else : [EOL] xmlstr += [string] [EOL] [EOL] return xmlstr [EOL] [EOL] [EOL] class OnEntry ( EventHandler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] EventHandler . __init__ ( self ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] xmlstr = [string] [EOL] [EOL] chxmlstr = [string] [EOL] [EOL] for action in self . actions : [EOL] chxmlstr += action . toxml ( ) [EOL] [EOL] if chxmlstr : [EOL] xmlstr += [string] + chxmlstr + [string] [EOL] else : [EOL] xmlstr += [string] [EOL] [EOL] return xmlstr [EOL] [EOL] [EOL] class KineticScheme ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , nodes , state_variable , edges , edge_source , edge_target , forward_rate , reverse_rate ) : [EOL] [docstring] [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . nodes = nodes [EOL] [docstring] [EOL] [EOL] self . state_variable = state_variable [EOL] [docstring] [EOL] [EOL] self . edges = edges [EOL] [docstring] [EOL] [EOL] self . edge_source = edge_source [EOL] [docstring] [EOL] [EOL] self . edge_target = edge_target [EOL] [docstring] [EOL] [EOL] self . forward_rate = forward_rate [EOL] [docstring] [EOL] [EOL] self . reverse_rate = reverse_rate [EOL] [docstring] [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] return ( [string] [string] [string] [string] [string] [string] [string] [string] [string] ) . format ( self . name , self . nodes , self . edges , self . state_variable , self . edge_source , self . edge_target , self . forward_rate , self . reverse_rate ) [EOL] [EOL] [EOL] class Behavioral ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] self . parent_behavioral = None [EOL] [docstring] [EOL] [EOL] self . state_variables = Map ( ) [EOL] [docstring] [EOL] [EOL] self . derived_variables = Map ( ) [EOL] [docstring] [EOL] [EOL] self . conditional_derived_variables = Map ( ) [EOL] [docstring] [EOL] [EOL] self . time_derivatives = Map ( ) [EOL] [docstring] [EOL] [EOL] self . event_handlers = list ( ) [EOL] [docstring] [EOL] [EOL] self . kinetic_schemes = Map ( ) [EOL] [docstring] [EOL] [EOL] def has_content ( self ) : [EOL] if len ( self . state_variables ) == [number] and len ( self . derived_variables ) == [number] and len ( self . conditional_derived_variables ) == [number] and len ( self . time_derivatives ) == [number] and len ( self . event_handlers ) == [number] and len ( self . kinetic_schemes ) == [number] : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] def clear ( self ) : [EOL] [docstring] [EOL] [EOL] self . time_derivatives = Map ( ) [EOL] [EOL] def add_state_variable ( self , sv ) : [EOL] [docstring] [EOL] [EOL] self . state_variables [ sv . name ] = sv [EOL] [EOL] def add_derived_variable ( self , dv ) : [EOL] [docstring] [EOL] [EOL] self . derived_variables [ dv . name ] = dv [EOL] [EOL] def add_conditional_derived_variable ( self , cdv ) : [EOL] [docstring] [EOL] [EOL] self . conditional_derived_variables [ cdv . name ] = cdv [EOL] [EOL] def add_time_derivative ( self , td ) : [EOL] [docstring] [EOL] [EOL] self . time_derivatives [ td . name ] = td [EOL] [EOL] def add_event_handler ( self , eh ) : [EOL] [docstring] [EOL] [EOL] self . event_handlers . append ( eh ) [EOL] [EOL] def add_kinetic_scheme ( self , ks ) : [EOL] [docstring] [EOL] [EOL] self . kinetic_schemes [ ks . name ] = ks [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , StateVariable ) : [EOL] self . add_state_variable ( child ) [EOL] elif isinstance ( child , DerivedVariable ) : [EOL] self . add_derived_variable ( child ) [EOL] elif isinstance ( child , ConditionalDerivedVariable ) : [EOL] self . add_conditional_derived_variable ( child ) [EOL] elif isinstance ( child , TimeDerivative ) : [EOL] self . add_time_derivative ( child ) [EOL] elif isinstance ( child , EventHandler ) : [EOL] self . add_event_handler ( child ) [EOL] elif isinstance ( child , KineticScheme ) : [EOL] self . add_kinetic_scheme ( child ) [EOL] else : [EOL] raise ModelError ( [string] ) [EOL] [EOL] def toxml ( self ) : [EOL] [docstring] [EOL] [EOL] chxmlstr = [string] [EOL] [EOL] for state_variable in self . state_variables : [EOL] chxmlstr += state_variable . toxml ( ) [EOL] [EOL] for derived_variable in self . derived_variables : [EOL] chxmlstr += derived_variable . toxml ( ) [EOL] [EOL] for conditional_derived_variable in self . conditional_derived_variables : [EOL] chxmlstr += conditional_derived_variable . toxml ( ) [EOL] [EOL] for time_derivative in self . time_derivatives : [EOL] chxmlstr += time_derivative . toxml ( ) [EOL] [EOL] for event_handler in self . event_handlers : [EOL] chxmlstr += event_handler . toxml ( ) [EOL] [EOL] for kinetic_scheme in self . kinetic_schemes : [EOL] chxmlstr += kinetic_scheme . toxml ( ) [EOL] [EOL] if isinstance ( self , Dynamics ) : [EOL] for regime in self . regimes : [EOL] chxmlstr += regime . toxml ( ) [EOL] [EOL] if isinstance ( self , Dynamics ) : [EOL] xmlprefix = [string] [EOL] xmlsuffix = [string] [EOL] xmlempty = [string] [EOL] else : [EOL] xmlprefix = [string] . format ( self . name ) + ( [string] if self . initial else [string] ) [EOL] xmlsuffix = [string] [EOL] xmlempty = [string] , format ( xmlprefix ) [EOL] [EOL] if chxmlstr : [EOL] xmlstr = [string] . format ( xmlprefix ) + chxmlstr + [string] . format ( xmlsuffix ) [EOL] else : [EOL] xmlstr = xmlempty [EOL] [EOL] return xmlstr [EOL] [EOL] [EOL] class Regime ( Behavioral ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , parent_behavioral , initial = False ) : [EOL] [docstring] [EOL] [EOL] Behavioral . __init__ ( self ) [EOL] [EOL] self . name = name [EOL] [docstring] [EOL] [EOL] self . parent_behavioral = parent_behavioral [EOL] [docstring] [EOL] [EOL] self . initial = initial [EOL] [docstring] [EOL] [EOL] [EOL] class Dynamics ( Behavioral ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] Behavioral . __init__ ( self ) [EOL] [EOL] self . regimes = Map ( ) [EOL] [docstring] [EOL] [EOL] def add_regime ( self , regime ) : [EOL] [docstring] [EOL] [EOL] self . regimes [ regime . name ] = regime [EOL] [EOL] def add ( self , child ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( child , Regime ) : [EOL] self . add_regime ( child ) [EOL] else : [EOL] Behavioral . add ( self , child ) [EOL] [EOL] def has_content ( self ) : [EOL] if len ( self . regimes ) > [number] : [EOL] return True [EOL] else : [EOL] return Behavioral . has_content ( self ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[typing_extensions.Literal,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[typing_extensions.Literal,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $typing.Union[typing_extensions.Literal,typing.Tuple[typing_extensions.Literal,builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing.Tuple[typing_extensions.Literal,builtins.str]]$ 0 $typing.Tuple[typing_extensions.Literal,builtins.str]$ 0 0 0 $typing.Union[typing_extensions.Literal,typing.Tuple[typing_extensions.Literal,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import dsl [EOL] [docstring] [EOL] [EOL] import xml . etree . ElementTree as xe [EOL] [EOL] from lems . base . base import LEMSBase [EOL] [comment] [EOL] from lems . model . component import * [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from lems . model . dynamics import * [EOL] [EOL] [EOL] def get_nons_tag_from_node ( node ) : [EOL] tag = node . tag [EOL] bits = tag . split ( [string] ) [EOL] if len ( bits ) == [number] : [EOL] return tag [EOL] elif [string] in bits [ [number] ] : [EOL] return bits [ [number] ] [EOL] elif [string] in bits [ [number] ] : [EOL] return bits [ [number] ] [EOL] elif [string] in bits [ [number] ] : [EOL] return [string] + bits [ [number] ] [EOL] elif [string] in bits [ [number] ] : [EOL] return [string] + bits [ [number] ] [EOL] elif [string] in bits [ [number] ] : [EOL] return [string] + bits [ [number] ] [EOL] else : [EOL] return [string] % ( bits [ [number] ] , bits [ [number] ] ) [EOL] [EOL] class LEMSXMLNode : [EOL] def __init__ ( self , pyxmlnode ) : [EOL] self . tag = get_nons_tag_from_node ( pyxmlnode ) [EOL] self . ltag = self . tag . lower ( ) [EOL] [EOL] self . attrib = dict ( ) [EOL] self . lattrib = dict ( ) [EOL] [EOL] for k in pyxmlnode . attrib : [EOL] self . attrib [ k ] = pyxmlnode . attrib [ k ] [EOL] self . lattrib [ k . lower ( ) ] = pyxmlnode . attrib [ k ] [EOL] [EOL] self . children = list ( ) [EOL] for pyxmlchild in pyxmlnode : [EOL] self . children . append ( LEMSXMLNode ( pyxmlchild ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . tag , self . attrib ) [EOL] [EOL] class LEMSFileParser ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , model , include_dirs = [ ] , include_includes = True ) : [EOL] [docstring] [EOL] [EOL] self . model = model [EOL] [docstring] [EOL] [EOL] self . include_dirs = include_dirs [EOL] [docstring] [EOL] [EOL] self . tag_parse_table = None [EOL] [docstring] [EOL] [EOL] self . valid_children = None [EOL] [docstring] [EOL] [EOL] self . id_counter = None [EOL] [docstring] [EOL] [EOL] self . include_includes = include_includes [EOL] [docstring] [EOL] [EOL] self . init_parser ( ) [EOL] [EOL] def init_parser ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] self . valid_children = dict ( ) [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] self . valid_children [ [string] ] = [ [string] , [string] ] [EOL] [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] self . valid_children [ [string] ] = [ [string] ] [EOL] [EOL] self . valid_children [ [string] ] = [ [string] ] [EOL] [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] ] [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] ] [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] ] [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] ] [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] ] [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] self . valid_children [ [string] ] = [ [string] , [string] ] [EOL] [EOL] self . valid_children [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] self . tag_parse_table = dict ( ) [EOL] [comment] [EOL] self . tag_parse_table [ [string] ] = self . parse_attachments [EOL] self . tag_parse_table [ [string] ] = self . parse_child [EOL] self . tag_parse_table [ [string] ] = self . parse_child_instance [EOL] self . tag_parse_table [ [string] ] = self . parse_children [EOL] self . tag_parse_table [ [string] ] = self . parse_component [EOL] self . tag_parse_table [ [string] ] = self . parse_component_reference [EOL] self . tag_parse_table [ [string] ] = self . parse_component_requirement [EOL] self . tag_parse_table [ [string] ] = self . parse_component_type [EOL] self . tag_parse_table [ [string] ] = self . parse_constant [EOL] self . tag_parse_table [ [string] ] = self . parse_function [EOL] self . tag_parse_table [ [string] ] = self . parse_data_display [EOL] self . tag_parse_table [ [string] ] = self . parse_data_writer [EOL] self . tag_parse_table [ [string] ] = self . parse_event_writer [EOL] self . tag_parse_table [ [string] ] = self . parse_derived_parameter [EOL] self . tag_parse_table [ [string] ] = self . parse_derived_variable [EOL] self . tag_parse_table [ [string] ] = self . parse_conditional_derived_variable [EOL] self . tag_parse_table [ [string] ] = self . parse_case [EOL] self . tag_parse_table [ [string] ] = self . parse_dimension [EOL] self . tag_parse_table [ [string] ] = self . parse_dynamics [EOL] self . tag_parse_table [ [string] ] = self . parse_event_connection [EOL] self . tag_parse_table [ [string] ] = self . parse_event_out [EOL] self . tag_parse_table [ [string] ] = self . parse_event_port [EOL] self . tag_parse_table [ [string] ] = self . parse_exposure [EOL] self . tag_parse_table [ [string] ] = self . parse_fixed [EOL] self . tag_parse_table [ [string] ] = self . parse_for_each [EOL] self . tag_parse_table [ [string] ] = self . parse_include [EOL] self . tag_parse_table [ [string] ] = self . parse_index_parameter [EOL] self . tag_parse_table [ [string] ] = self . parse_kinetic_scheme [EOL] self . tag_parse_table [ [string] ] = self . parse_link [EOL] self . tag_parse_table [ [string] ] = self . parse_multi_instantiate [EOL] self . tag_parse_table [ [string] ] = self . parse_on_condition [EOL] self . tag_parse_table [ [string] ] = self . parse_on_entry [EOL] self . tag_parse_table [ [string] ] = self . parse_on_event [EOL] self . tag_parse_table [ [string] ] = self . parse_on_start [EOL] self . tag_parse_table [ [string] ] = self . parse_parameter [EOL] self . tag_parse_table [ [string] ] = self . parse_property [EOL] self . tag_parse_table [ [string] ] = self . parse_path [EOL] self . tag_parse_table [ [string] ] = self . parse_record [EOL] self . tag_parse_table [ [string] ] = self . parse_event_record [EOL] self . tag_parse_table [ [string] ] = self . parse_regime [EOL] self . tag_parse_table [ [string] ] = self . parse_requirement [EOL] self . tag_parse_table [ [string] ] = self . parse_instance_requirement [EOL] self . tag_parse_table [ [string] ] = self . parse_run [EOL] [comment] [EOL] self . tag_parse_table [ [string] ] = self . parse_simulation [EOL] self . tag_parse_table [ [string] ] = self . parse_state_assignment [EOL] self . tag_parse_table [ [string] ] = self . parse_state_variable [EOL] self . tag_parse_table [ [string] ] = self . parse_structure [EOL] self . tag_parse_table [ [string] ] = self . parse_target [EOL] self . tag_parse_table [ [string] ] = self . parse_text [EOL] self . tag_parse_table [ [string] ] = self . parse_time_derivative [EOL] self . tag_parse_table [ [string] ] = self . parse_transition [EOL] self . tag_parse_table [ [string] ] = self . parse_tunnel [EOL] self . tag_parse_table [ [string] ] = self . parse_unit [EOL] self . tag_parse_table [ [string] ] = self . parse_with [EOL] [EOL] self . xml_node_stack = [ ] [EOL] [EOL] self . current_component_type = None [EOL] self . current_dynamics = None [EOL] self . current_regime = None [EOL] self . current_event_handler = None [EOL] self . current_structure = None [EOL] self . current_simulation = None [EOL] self . current_component = None [EOL] [EOL] def counter ( ) : [EOL] count = [number] [EOL] while True : [EOL] yield count [EOL] count = count + [number] [EOL] [EOL] self . id_counter = counter ( ) [EOL] [EOL] [EOL] def process_nested_tags ( self , node , tag = [string] ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] if tag == [string] : [EOL] t = node . ltag [EOL] else : [EOL] t = tag . lower ( ) [EOL] [EOL] for child in node . children : [EOL] self . xml_node_stack = [ child ] + self . xml_node_stack [EOL] [EOL] ctagl = child . ltag [EOL] [EOL] if ctagl in self . tag_parse_table and ctagl in self . valid_children [ t ] : [EOL] [comment] [EOL] self . tag_parse_table [ ctagl ] ( child ) [EOL] else : [EOL] [comment] [EOL] self . parse_component_by_typename ( child , child . tag ) [EOL] [EOL] self . xml_node_stack = self . xml_node_stack [ [number] : ] [EOL] [EOL] def parse ( self , xmltext ) : [EOL] [docstring] [EOL] [EOL] xml = LEMSXMLNode ( xe . XML ( xmltext ) ) [EOL] [EOL] if xml . ltag != [string] and xml . ltag != [string] : [EOL] raise ParseError ( [string] . format ( xml . ltag ) ) [EOL] [docstring] [EOL] [EOL] self . process_nested_tags ( xml ) [EOL] [EOL] [EOL] def raise_error ( self , message , * params , ** key_params ) : [EOL] [docstring] [EOL] [EOL] s = [string] [EOL] [EOL] self . xml_node_stack . reverse ( ) [EOL] if len ( self . xml_node_stack ) > [number] : [EOL] node = self . xml_node_stack [ [number] ] [EOL] s += [string] . format ( node . tag ) [EOL] if [string] in node . lattrib : [EOL] s += [string] . format ( node . lattrib [ [string] ] ) [EOL] if [string] in node . lattrib : [EOL] s += [string] . format ( node . lattrib [ [string] ] ) [EOL] s += [string] [EOL] [EOL] for node in self . xml_node_stack [ [number] : ] : [EOL] s += [string] . format ( node . tag ) [EOL] if [string] in node . lattrib : [EOL] s += [string] . format ( node . lattrib [ [string] ] ) [EOL] if [string] in node . lattrib : [EOL] s += [string] . format ( node . lattrib [ [string] ] ) [EOL] s += [string] [EOL] [EOL] s += [string] + message [EOL] [EOL] raise ParseError ( s , * params , ** key_params ) [EOL] [EOL] self . xml_node_stack . reverse ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] def parse_assertion ( self , node ) : [EOL] [docstring] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def parse_attachments ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] type_ = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] description = node . lattrib . get ( [string] , [string] ) [EOL] self . current_component_type . add_attachments ( Attachments ( name , type_ , description ) ) [EOL] [EOL] def parse_child ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] type_ = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] self . current_component_type . add_children ( Children ( name , type_ , False ) ) [EOL] [EOL] def parse_child_instance ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] component = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] self . current_structure . add_child_instance ( ChildInstance ( component ) ) [EOL] [EOL] def parse_children ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] type_ = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] self . current_component_type . add_children ( Children ( name , type_ , True ) ) [EOL] [EOL] def parse_component_by_typename ( self , node , type_ ) : [EOL] [docstring] [EOL] [comment] [EOL] if [string] in node . lattrib : [EOL] id_ = node . lattrib [ [string] ] [EOL] else : [EOL] [comment] [EOL] id_ = node . tag [comment] [EOL] [EOL] if [string] in node . lattrib : [EOL] type_ = node . lattrib [ [string] ] [EOL] else : [EOL] type_ = node . tag [EOL] [EOL] component = Component ( id_ , type_ ) [EOL] [EOL] if self . current_component : [EOL] component . set_parent_id ( self . current_component . id ) [EOL] self . current_component . add_child ( component ) [EOL] [EOL] else : [EOL] self . model . add_component ( component ) [EOL] [EOL] for key in node . attrib : [EOL] if key . lower ( ) not in [ [string] , [string] ] : [EOL] component . set_parameter ( key , node . attrib [ key ] ) [EOL] [EOL] old_component = self . current_component [EOL] self . current_component = component [EOL] self . process_nested_tags ( node , [string] ) [EOL] self . current_component = old_component [EOL] [EOL] def parse_component ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] id_ = node . lattrib [ [string] ] [EOL] else : [EOL] [comment] [EOL] id_ = make_id ( ) [EOL] [EOL] if [string] in node . lattrib : [EOL] type_ = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , id_ ) [EOL] [EOL] component = Component ( id_ , type_ ) [EOL] [EOL] if self . current_component : [EOL] component . set_parent_id ( self . current_component . id ) [EOL] self . current_component . add_child ( component ) [EOL] else : [EOL] self . model . add_component ( component ) [EOL] [EOL] for key in node . attrib : [EOL] if key . lower ( ) not in [ [string] , [string] ] : [EOL] component . set_parameter ( key , node . attrib [ key ] ) [EOL] [EOL] old_component = self . current_component [EOL] self . current_component = component [EOL] self . process_nested_tags ( node ) [EOL] self . current_component = old_component [EOL] [EOL] def parse_component_reference ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] type_ = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] local = node . lattrib [ [string] ] [EOL] else : [EOL] local = None [EOL] [EOL] self . current_component_type . add_component_reference ( ComponentReference ( name , type_ , local ) ) [EOL] [EOL] def parse_component_type ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] name = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] extends = node . lattrib [ [string] ] [EOL] else : [EOL] extends = None [EOL] [EOL] if [string] in node . lattrib : [EOL] description = node . lattrib [ [string] ] [EOL] else : [EOL] description = [string] [EOL] [EOL] component_type = ComponentType ( name , description , extends ) [EOL] self . model . add_component_type ( component_type ) [EOL] [EOL] self . current_component_type = component_type [EOL] self . process_nested_tags ( node ) [EOL] self . current_component_type = None [EOL] [EOL] def parse_constant ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] name = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] domain = node . lattrib . get ( [string] , None ) [EOL] symbol = node . lattrib . get ( [string] , None ) [EOL] [EOL] try : [EOL] default = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] description = node . lattrib . get ( [string] , [string] ) [EOL] [EOL] constant = Constant ( name , default , domain , symbol , description ) [EOL] [EOL] if self . current_component_type : [EOL] self . current_component_type . add_constant ( constant ) [EOL] else : [EOL] self . model . add_constant ( constant ) [EOL] [EOL] def parse_function ( self , node ) : [EOL] [docstring] [EOL] try : [EOL] name = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] try : [EOL] value = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] dimension = None [EOL] symbol = None [EOL] description = None [EOL] [EOL] function = Function ( name , value , dimension , symbol , description ) [EOL] [EOL] if self . current_component_type : [EOL] self . current_component_type . add_function ( function ) [EOL] else : [EOL] self . model . add_function ( function ) [EOL] [EOL] [EOL] def parse_data_display ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] title = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] data_region = node . lattrib [ [string] ] [EOL] else : [EOL] data_region = None [EOL] [EOL] self . current_simulation . add_data_display ( DataDisplay ( title , data_region ) ) [EOL] [EOL] def parse_data_writer ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] path = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] file_path = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , path ) [EOL] [EOL] self . current_simulation . add_data_writer ( DataWriter ( path , file_path ) ) [EOL] [EOL] def parse_event_writer ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] path = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] file_path = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , path ) [EOL] [EOL] if [string] in node . lattrib : [EOL] format = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , path ) [EOL] [EOL] self . current_simulation . add_event_writer ( EventWriter ( path , file_path , format ) ) [EOL] [EOL] def parse_derived_parameter ( self , node ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] expression = node . lattrib [ [string] ] [EOL] else : [EOL] expression = None [EOL] [EOL] if [string] in node . lattrib : [EOL] value = node . lattrib [ [string] ] [EOL] else : [EOL] value = None [EOL] [EOL] if [string] in node . lattrib : [EOL] select = node . lattrib [ [string] ] [EOL] else : [EOL] select = None [EOL] [EOL] self . current_component_type . add_derived_parameter ( DerivedParameter ( name , value , expression , select ) ) [EOL] [EOL] def parse_derived_variable ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] elif [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] params = dict ( ) [EOL] for attr_name in [ [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] if attr_name in node . lattrib : [EOL] params [ attr_name ] = node . lattrib [ attr_name ] [EOL] [EOL] self . current_regime . add_derived_variable ( DerivedVariable ( name , ** params ) ) [EOL] [EOL] [EOL] def parse_conditional_derived_variable ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] elif [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] exposure = node . lattrib [ [string] ] [EOL] else : [EOL] exposure = None [EOL] [EOL] if [string] in node . lattrib : [EOL] condition = node . lattrib [ [string] ] [EOL] else : [EOL] condition = None [EOL] [EOL] if [string] in node . lattrib : [EOL] cases = node . lattrib [ [string] ] [EOL] else : [EOL] cases = None [EOL] [EOL] conditional_derived_variable = ConditionalDerivedVariable ( name , condition , exposure , cases ) [EOL] [EOL] self . current_regime . add_conditional_derived_variable ( conditional_derived_variable ) [EOL] [EOL] self . current_conditional_derived_variable = conditional_derived_variable [EOL] [EOL] self . process_nested_tags ( node ) [EOL] [EOL] [EOL] def parse_case ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] condition = node . lattrib [ [string] ] [EOL] except : [EOL] condition = None [EOL] [EOL] try : [EOL] value = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] self . current_conditional_derived_variable . add_case ( Case ( condition , value ) ) [EOL] [EOL] def parse_dimension ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] name = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] description = node . lattrib . get ( [string] , [string] ) [EOL] [EOL] dim = dict ( ) [EOL] for d in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] dim [ d ] = int ( node . lattrib . get ( d , [number] ) ) [EOL] [EOL] self . model . add_dimension ( Dimension ( name , description , ** dim ) ) [EOL] [EOL] def parse_dynamics ( self , node ) : [EOL] [docstring] [EOL] [EOL] self . current_dynamics = self . current_component_type . dynamics [EOL] self . current_regime = self . current_dynamics [EOL] self . process_nested_tags ( node ) [EOL] self . current_regime = None [EOL] self . current_dynamics = None [EOL] [EOL] def parse_event_connection ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] from_ = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] to = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] source_port = node . lattrib . get ( [string] , [string] ) [EOL] target_port = node . lattrib . get ( [string] , [string] ) [EOL] receiver = node . lattrib . get ( [string] , [string] ) [EOL] receiver_container = node . lattrib . get ( [string] , [string] ) [EOL] [EOL] ec = EventConnection ( from_ , to , source_port , target_port , receiver , receiver_container ) [EOL] self . current_structure . add_event_connection ( ec ) [EOL] [EOL] def parse_event_out ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] port = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] action = EventOut ( port ) [EOL] [EOL] self . current_event_handler . add_action ( action ) [EOL] [EOL] def parse_event_port ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( ( [string] ) ) [EOL] [EOL] if [string] in node . lattrib : [EOL] direction = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] direction = direction . lower ( ) [EOL] if direction != [string] and direction != [string] : [EOL] self . raise_error ( ( [string] [string] ) ) [EOL] [EOL] description = node . lattrib . get ( [string] , [string] ) [EOL] [EOL] self . current_component_type . add_event_port ( EventPort ( name , direction , description ) ) [EOL] [EOL] def parse_exposure ( self , node ) : [EOL] [docstring] [EOL] [EOL] if self . current_component_type == None : [EOL] self . raise_error ( [string] ) [EOL] [EOL] try : [EOL] name = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] try : [EOL] choices = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] try : [EOL] default = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] description = node . lattrib . get ( [string] , [string] ) [EOL] [EOL] self . current_component_type . add_exposure ( Exposure ( name , choices , default , description ) ) [EOL] [EOL] def parse_fixed ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] parameter = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] try : [EOL] value = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] , parameter ) [EOL] [EOL] description = node . lattrib . get ( [string] , [string] ) [EOL] [EOL] self . current_component_type . add_parameter ( Fixed ( parameter , value , description ) ) [EOL] [EOL] def parse_for_each ( self , node ) : [EOL] [docstring] [EOL] [EOL] if self . current_structure == None : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] instances = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] as_ = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] [string] ) [EOL] [EOL] old_structure = self . current_structure [EOL] fe = ForEach ( instances , as_ ) [EOL] self . current_structure . add_for_each ( fe ) [EOL] self . current_structure = fe [EOL] [EOL] self . process_nested_tags ( node ) [EOL] [EOL] self . current_structure = old_structure [EOL] [EOL] def parse_include ( self , node ) : [EOL] [docstring] [EOL] if not self . include_includes : [EOL] if self . model . debug : print ( [string] % node . lattrib [ [string] ] ) [EOL] else : [EOL] [EOL] [comment] [EOL] if [string] not in node . lattrib : [EOL] if [string] in node . lattrib : [EOL] self . model . include_file ( node . lattrib [ [string] ] , self . include_dirs ) [EOL] return [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] self . model . include_file ( node . lattrib [ [string] ] , self . include_dirs ) [EOL] [EOL] def parse_kinetic_scheme ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] nodes = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] if [string] in node . lattrib : [EOL] state_variable = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] if [string] in node . lattrib : [EOL] edges = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] if [string] in node . lattrib : [EOL] edge_source = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] if [string] in node . lattrib : [EOL] edge_target = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] if [string] in node . lattrib : [EOL] forward_rate = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] if [string] in node . lattrib : [EOL] reverse_rate = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] self . current_regime . add_kinetic_scheme ( KineticScheme ( name , nodes , state_variable , edges , edge_source , edge_target , forward_rate , reverse_rate ) ) [EOL] [EOL] def parse_link ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] type_ = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] description = node . lattrib . get ( [string] , [string] ) [EOL] [EOL] self . current_component_type . add_link ( Link ( name , type_ , description ) ) [EOL] [EOL] def parse_multi_instantiate ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] component = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] number = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , component ) [EOL] [EOL] self . current_structure . add_multi_instantiate ( MultiInstantiate ( component , number ) ) [EOL] [EOL] def parse_on_condition ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] test = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] event_handler = OnCondition ( test ) [EOL] [EOL] self . current_regime . add_event_handler ( event_handler ) [EOL] [EOL] self . current_event_handler = event_handler [EOL] self . process_nested_tags ( node ) [EOL] self . current_event_handler = None [EOL] [EOL] def parse_on_entry ( self , node ) : [EOL] [docstring] [EOL] [EOL] event_handler = OnEntry ( ) [EOL] [EOL] self . current_event_handler = event_handler [EOL] self . current_regime . add_event_handler ( event_handler ) [EOL] [EOL] self . process_nested_tags ( node ) [EOL] [EOL] self . current_event_handler = None [EOL] [EOL] def parse_on_event ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] port = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] event_handler = OnEvent ( port ) [EOL] [EOL] self . current_regime . add_event_handler ( event_handler ) [EOL] [EOL] self . current_event_handler = event_handler [EOL] self . process_nested_tags ( node ) [EOL] self . current_event_handler = None [EOL] [EOL] def parse_on_start ( self , node ) : [EOL] [docstring] [EOL] [EOL] event_handler = OnStart ( ) [EOL] [EOL] self . current_regime . add_event_handler ( event_handler ) [EOL] [EOL] self . current_event_handler = event_handler [EOL] self . process_nested_tags ( node ) [EOL] self . current_event_handler = None [EOL] [EOL] def parse_parameter ( self , node ) : [EOL] [docstring] [EOL] [EOL] if self . current_component_type == None : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] try : [EOL] name = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] try : [EOL] dimension = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] parameter = Parameter ( name , dimension ) [EOL] [EOL] self . current_component_type . add_parameter ( parameter ) [EOL] [EOL] def parse_property ( self , node ) : [EOL] [docstring] [EOL] [EOL] if self . current_component_type == None : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] try : [EOL] name = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] try : [EOL] dimension = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] default_value = node . lattrib . get ( [string] , None ) [EOL] [EOL] property = Property ( name , dimension , default_value = default_value ) [EOL] [EOL] self . current_component_type . add_property ( property ) [EOL] [EOL] [EOL] def parse_index_parameter ( self , node ) : [EOL] [docstring] [EOL] [EOL] if self . current_component_type == None : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] try : [EOL] name = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] [EOL] index_parameter = IndexParameter ( name ) [EOL] [EOL] self . current_component_type . add_index_parameter ( index_parameter ) [EOL] [EOL] [EOL] def parse_tunnel ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] name = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] try : [EOL] end_a = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] try : [EOL] end_b = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] try : [EOL] component_a = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] try : [EOL] component_b = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] [EOL] tunnel = Tunnel ( name , end_a , end_b , component_a , component_b ) [EOL] [EOL] self . current_structure . add_tunnel ( tunnel ) [EOL] [EOL] [EOL] def parse_path ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] description = node . lattrib . get ( [string] , [string] ) [EOL] [EOL] self . current_component_type . add_path ( Path ( name , description ) ) [EOL] [EOL] def parse_record ( self , node ) : [EOL] [docstring] [EOL] [EOL] if self . current_simulation == None : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] quantity = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] scale = node . lattrib . get ( [string] , None ) [EOL] color = node . lattrib . get ( [string] , None ) [EOL] id = node . lattrib . get ( [string] , None ) [EOL] [EOL] self . current_simulation . add_record ( Record ( quantity , scale , color , id ) ) [EOL] [EOL] def parse_event_record ( self , node ) : [EOL] [docstring] [EOL] [EOL] if self . current_simulation == None : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] quantity = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] eventPort = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] [EOL] self . current_simulation . add_event_record ( EventRecord ( quantity , eventPort ) ) [EOL] [EOL] def parse_regime ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] name = [string] [EOL] [EOL] if [string] in node . lattrib : [EOL] initial = ( node . lattrib [ [string] ] . strip ( ) . lower ( ) == [string] ) [EOL] else : [EOL] initial = False [EOL] [EOL] regime = Regime ( name , self . current_dynamics , initial ) [EOL] old_regime = self . current_regime [EOL] self . current_dynamics . add_regime ( regime ) [EOL] self . current_regime = regime [EOL] [EOL] self . process_nested_tags ( node ) [EOL] [EOL] self . current_regime = old_regime [EOL] [EOL] def parse_requirement ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] dimension = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] self . current_component_type . add_requirement ( Requirement ( name , dimension ) ) [EOL] [EOL] def parse_component_requirement ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] self . current_component_type . add_component_requirement ( ComponentRequirement ( name ) ) [EOL] [EOL] def parse_instance_requirement ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] type = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] self . current_component_type . add_instance_requirement ( InstanceRequirement ( name , type ) ) [EOL] [EOL] def parse_run ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] component = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] variable = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] increment = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] total = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] + [string] ) [EOL] [EOL] self . current_simulation . add_run ( Run ( component , variable , increment , total ) ) [EOL] [EOL] def parse_show ( self , node ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] def parse_simulation ( self , node ) : [EOL] [docstring] [EOL] [EOL] self . current_simulation = self . current_component_type . simulation [EOL] [EOL] self . process_nested_tags ( node ) [EOL] [EOL] self . current_simulation = None [EOL] [EOL] def parse_state_assignment ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] variable = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] value = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , variable ) [EOL] [EOL] action = StateAssignment ( variable , value ) [EOL] [EOL] self . current_event_handler . add_action ( action ) [EOL] [EOL] [EOL] def parse_state_variable ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] default = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , name ) [EOL] [EOL] if [string] in node . lattrib : [EOL] boundaries = node . lattrib [ [string] ] [EOL] else : [EOL] boundaries = None [EOL] [EOL] self . current_regime . add_state_variable ( StateVariable ( name , default , boundaries ) ) [EOL] [EOL] def parse_structure ( self , node ) : [EOL] [docstring] [EOL] [EOL] self . current_structure = self . current_component_type . structure [EOL] self . process_nested_tags ( node ) [EOL] self . current_structure = None [EOL] [EOL] def parse_target ( self , node ) : [EOL] [docstring] [EOL] [EOL] self . model . add_target ( node . lattrib [ [string] ] ) [EOL] [EOL] def parse_text ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] description = node . lattrib . get ( [string] , [string] ) [EOL] [EOL] self . current_component_type . add_text ( Text ( name , description ) ) [EOL] [EOL] def parse_time_derivative ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] expression = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] , variable ) [EOL] [EOL] self . current_regime . add_time_derivative ( TimeDerivative ( name , expression ) ) [EOL] [EOL] def parse_transition ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] regime = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] action = Transition ( regime ) [EOL] [EOL] self . current_event_handler . add_action ( action ) [EOL] [EOL] def parse_unit ( self , node ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] symbol = node . lattrib [ [string] ] [EOL] dimension = node . lattrib [ [string] ] [EOL] except : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] power = int ( node . lattrib [ [string] ] ) [EOL] else : [EOL] power = [number] [EOL] [EOL] if [string] in node . lattrib : [EOL] name = node . lattrib [ [string] ] [EOL] else : [EOL] name = [string] [EOL] [EOL] if [string] in node . lattrib : [EOL] scale = float ( node . lattrib [ [string] ] ) [EOL] else : [EOL] scale = [number] [EOL] [EOL] if [string] in node . lattrib : [EOL] offset = float ( node . lattrib [ [string] ] ) [EOL] else : [EOL] offset = [number] [EOL] [EOL] self . model . add_unit ( Unit ( name , symbol , dimension , power , scale , offset ) ) [EOL] [EOL] def parse_with ( self , node ) : [EOL] [docstring] [EOL] [EOL] if [string] in node . lattrib : [EOL] instance = node . lattrib [ [string] ] [EOL] list = None [EOL] index = None [EOL] elif [string] in node . lattrib and [string] in node . lattrib : [EOL] instance = None [EOL] list = node . lattrib [ [string] ] [EOL] index = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] ) [EOL] [EOL] if [string] in node . lattrib : [EOL] as_ = node . lattrib [ [string] ] [EOL] else : [EOL] self . raise_error ( [string] [string] ) [EOL] [EOL] self . current_structure . add_with ( With ( instance , as_ , list , index ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dsl.lems.parser.LEMS.LEMSXMLNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dsl.lems.parser.LEMS.LEMSXMLNode$ 0 0 0 0 0 $dsl.lems.parser.LEMS.LEMSXMLNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dsl.lems.parser.LEMS.LEMSXMLNode$ 0 0 0 0 0 0 0 0 0 0 0 0 $dsl.lems.parser.LEMS.LEMSXMLNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $None$ 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $None$ 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0
[docstring] [EOL]	0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import dsl [EOL] [docstring] [EOL] [EOL] from lems . base . base import LEMSBase [EOL] from lems . base . stack import Stack [EOL] [EOL] known_functions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] class ExprNode ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] OP = [number] [EOL] VALUE = [number] [EOL] FUNC1 = [number] [EOL] [EOL] def __init__ ( self , type ) : [EOL] [docstring] [EOL] [EOL] self . type = type [EOL] [docstring] [EOL] [EOL] class ValueNode ( ExprNode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] [docstring] [EOL] [EOL] ExprNode . __init__ ( self , ExprNode . VALUE ) [EOL] self . value = value [EOL] [docstring] [EOL] [EOL] def clean_up ( self ) : [EOL] [docstring] [EOL] try : [EOL] return str ( float ( self . value ) ) [EOL] except ValueError : [EOL] return self . value [EOL] [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return [string] + self . clean_up ( ) + [string] [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] def to_python_expr ( self ) : [EOL] return self . clean_up ( ) [EOL] [EOL] class OpNode ( ExprNode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , op , left , right ) : [EOL] [docstring] [EOL] [EOL] ExprNode . __init__ ( self , ExprNode . OP ) [EOL] [EOL] self . op = op [EOL] [docstring] [EOL] [EOL] self . left = left [EOL] [docstring] [EOL] [EOL] self . right = right [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . op , str ( self . left ) , str ( self . right ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] def to_python_expr ( self ) : [EOL] return [string] . format ( self . left . to_python_expr ( ) , self . op , self . right . to_python_expr ( ) ) [EOL] [EOL] class Func1Node ( ExprNode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , func , param ) : [EOL] [docstring] [EOL] [EOL] ExprNode . __init__ ( self , ExprNode . FUNC1 ) [EOL] [EOL] self . func = func [EOL] [docstring] [EOL] [EOL] self . param = param [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . format ( self . func , str ( self . param ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] def to_python_expr ( self ) : [EOL] return [string] . format ( self . func , self . param . to_python_expr ( ) ) [EOL] [EOL] [EOL] class ExprParser ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] debug = False [EOL] [EOL] op_priority = { [string] : - [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [comment] [EOL] [EOL] depth = [number] [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , parse_string ) : [EOL] [docstring] [EOL] [EOL] self . parse_string = parse_string [EOL] [docstring] [EOL] [EOL] self . token_list = None [EOL] [docstring] [EOL] [EOL] def is_op ( self , str ) : [EOL] [docstring] [EOL] [EOL] return str in self . op_priority [EOL] [EOL] def is_func ( self , str ) : [EOL] [docstring] [EOL] [EOL] return str in known_functions [EOL] [EOL] def is_sym ( self , str ) : [EOL] [docstring] [EOL] [EOL] return str in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def priority ( self , op ) : [EOL] if self . is_op ( op ) : [EOL] return self . op_priority [ op ] [EOL] elif self . is_func ( op ) : [EOL] return self . op_priority [ [string] ] [EOL] else : [EOL] return self . op_priority [ [string] ] [EOL] [EOL] def tokenize ( self ) : [EOL] [docstring] [EOL] [EOL] powerflag = [number] [EOL] self . token_list = [ ] [EOL] ps = self . parse_string . strip ( ) [EOL] [EOL] i = [number] [EOL] last_token = None [EOL] [EOL] while i < len ( ps ) and ps [ i ] . isspace ( ) : [EOL] i += [number] [EOL] [EOL] while i < len ( ps ) : [EOL] token = [string] [EOL] [EOL] if ps [ i ] . isalpha ( ) : [EOL] while i < len ( ps ) and ( ps [ i ] . isalnum ( ) or ps [ i ] == [string] ) : [EOL] token += ps [ i ] [EOL] i += [number] [EOL] elif ps [ i ] . isdigit ( ) : [EOL] while i < len ( ps ) and ( ps [ i ] . isdigit ( ) or ps [ i ] == [string] or ps [ i ] == [string] or ps [ i ] == [string] or ( ps [ i ] == [string] and ( ps [ i - [number] ] == [string] or ps [ i - [number] ] == [string] ) ) or ( ps [ i ] == [string] and ( ps [ i - [number] ] == [string] or ps [ i - [number] ] == [string] ) ) ) : [EOL] token += ps [ i ] [EOL] i += [number] [EOL] elif ps [ i ] == [string] : [EOL] if ps [ i + [number] ] . isdigit ( ) : [EOL] while i < len ( ps ) and ( ps [ i ] . isdigit ( ) or ps [ i ] == [string] ) : [EOL] token += ps [ i ] [EOL] i += [number] [EOL] else : [EOL] while i < len ( ps ) and ( ps [ i ] . isalpha ( ) or ps [ i ] == [string] ) : [EOL] token += ps [ i ] [EOL] i += [number] [EOL] elif ps [ i ] == [string] : [EOL] while i < len ( ps ) and ps [ i ] == [string] :[comment] [EOL] token += ps [ i ] [EOL] i += [number] [EOL] else : [EOL] token += ps [ i ] [EOL] i += [number] [EOL] [EOL] if token == [string] and ( last_token == None or last_token == [string] or self . is_op ( last_token ) ) : [EOL] token = [string] [EOL] [EOL] self . token_list += [ token ] [EOL] last_token = token [EOL] [EOL] while i < len ( ps ) and ps [ i ] . isspace ( ) : [EOL] i += [number] [EOL] [EOL] def make_op_node ( self , op , right ) : [EOL] if self . is_func ( op ) : [EOL] return Func1Node ( op , right ) [EOL] elif op == [string] : [EOL] return OpNode ( [string] , ValueNode ( [string] ) , right ) [EOL] else : [EOL] left = self . val_stack . pop ( ) [EOL] if left == [string] : [EOL] left = self . node_stack . pop ( ) [EOL] else : [EOL] left = ValueNode ( left ) [EOL] [EOL] return OpNode ( op , left , right ) [EOL] [EOL] def cleanup_stacks ( self ) : [EOL] right = self . val_stack . pop ( ) [EOL] if right == [string] : [EOL] right = self . node_stack . pop ( ) [EOL] else : [EOL] right = ValueNode ( right ) [EOL] [EOL] if self . debug : print ( [string] % right ) [EOL] [EOL] while self . op_stack . top ( ) != [string] : [EOL] if self . debug : print ( [string] % ( self . op_stack , self . val_stack , self . node_stack ) ) [EOL] op = self . op_stack . pop ( ) [EOL] [EOL] right = self . make_op_node ( op , right ) [EOL] [EOL] if self . debug : print ( [string] % ( self . op_stack , self . val_stack , self . node_stack ) ) [EOL] if self . debug : print ( [string] % right ) [EOL] [comment] [EOL] [EOL] return right [EOL] [EOL] def parse_token_list_rec ( self , min_precedence ) : [EOL] [docstring] [EOL] [EOL] exit_loop = False [EOL] [EOL] ExprParser . depth = ExprParser . depth + [number] [EOL] if self . debug : print ( [string] % ExprParser . depth ) [EOL] [EOL] precedence = min_precedence [EOL] [EOL] while self . token_list : [EOL] token = self . token_list [ [number] ] [EOL] la = self . token_list [ [number] ] if len ( self . token_list ) > [number] else None [EOL] [EOL] if self . debug : print ( [string] % self . token_list ) [EOL] if self . debug : print ( [string] % ( token , la , self . op_stack , self . val_stack , self . node_stack ) ) [EOL] [EOL] self . token_list = self . token_list [ [number] : ] [EOL] [EOL] close_bracket = False [EOL] [EOL] if token == [string] : [EOL] np = ExprParser ( [string] ) [EOL] np . token_list = self . token_list [EOL] [EOL] nexp = np . parse2 ( ) [EOL] [EOL] self . node_stack . push ( nexp ) [EOL] self . val_stack . push ( [string] ) [EOL] [EOL] self . token_list = np . token_list [EOL] if self . debug : print ( [string] % self . token_list ) [EOL] close_bracket = True [EOL] elif token == [string] : [EOL] break [EOL] elif self . is_func ( token ) : [EOL] self . op_stack . push ( token ) [EOL] elif self . is_op ( token ) : [EOL] stack_top = self . op_stack . top ( ) [EOL] if self . debug : print ( [string] % ( token , self . priority ( token ) , stack_top , self . priority ( stack_top ) ) ) [EOL] if self . priority ( token ) < self . priority ( stack_top ) : [EOL] if self . debug : print ( [string] % ( token , stack_top ) ) [EOL] self . node_stack . push ( self . cleanup_stacks ( ) ) [EOL] self . val_stack . push ( [string] ) [EOL] else : [EOL] if self . debug : print ( [string] % ( token , stack_top ) ) [EOL] [EOL] [EOL] self . op_stack . push ( token ) [EOL] else : [EOL] if self . debug : print ( [string] ) [EOL] if la == [string] : [EOL] raise Exception ( [string] % ( self . parse_string , token , known_functions ) ) [EOL] stack_top = self . op_stack . top ( ) [EOL] if stack_top == [string] : [EOL] if self . debug : print ( [string] ) [EOL] self . node_stack . push ( ValueNode ( token ) ) [EOL] self . val_stack . push ( [string] ) [EOL] else : [EOL] if ( self . is_op ( la ) and self . priority ( stack_top ) < self . priority ( la ) ) : [EOL] if self . debug : print ( [string] ) [EOL] [EOL] self . node_stack . push ( ValueNode ( token ) ) [EOL] self . val_stack . push ( [string] ) [EOL] else : [EOL] if self . debug : print ( [string] % self . node_stack ) [EOL] op = self . op_stack . pop ( ) [EOL] [EOL] right = ValueNode ( token ) [EOL] op_node = self . make_op_node ( op , right ) [EOL] [EOL] self . node_stack . push ( op_node ) [EOL] self . val_stack . push ( [string] ) [EOL] [EOL] if close_bracket : [EOL] stack_top = self . op_stack . top ( ) [EOL] if self . debug : print ( [string] % ( self . op_stack , self . node_stack , la ) ) [EOL] if self . debug : print ( [string] % self . token_list ) [EOL] [EOL] if stack_top == [string] : [EOL] if self . debug : print ( [string] ) [EOL] [docstring] [EOL] else : [EOL] la = self . token_list [ [number] ] if len ( self . token_list ) > [number] else None [EOL] if ( self . is_op ( la ) and self . priority ( stack_top ) < self . priority ( la ) ) : [EOL] if self . debug : print ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] if self . debug : print ( [string] % self . node_stack ) [EOL] if self . debug : print ( [string] % ( self . op_stack , self . val_stack , self . node_stack ) ) [EOL] right = self . node_stack . pop ( ) [EOL] op = self . op_stack . pop ( ) [EOL] op_node = self . make_op_node ( stack_top , right ) [EOL] if self . debug : print ( [string] % ( op_node , right ) ) [EOL] [EOL] self . node_stack . push ( op_node ) [EOL] self . val_stack . push ( [string] ) [EOL] if self . debug : print ( [string] % ( self . op_stack , self . val_stack , self . node_stack ) ) [EOL] [EOL] [EOL] [EOL] if self . debug : print ( [string] % ( token , la , self . op_stack , self . val_stack , self . node_stack ) ) [EOL] if self . debug : print ( [string] ) [EOL] [EOL] if self . debug : print ( [string] % ( self . op_stack , self . val_stack , self . node_stack ) ) [EOL] ret = self . cleanup_stacks ( ) [EOL] [EOL] if self . debug : print ( [string] % ( self . op_stack , self . val_stack , self . node_stack ) ) [EOL] if self . debug : print ( [string] % ( ExprParser . depth , ret ) ) [EOL] ExprParser . depth = ExprParser . depth - [number] [EOL] if self . debug : print ( [string] ) [EOL] return ret [EOL] [EOL] def parse ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . tokenize ( ) [EOL] if self . debug : print ( [string] % self . token_list ) [EOL] [EOL] try : [EOL] parse_tree = self . parse2 ( ) [EOL] except Exception as e : [EOL] raise e [EOL] return parse_tree [EOL] [EOL] def parse2 ( self ) : [EOL] self . op_stack = Stack ( ) [EOL] self . val_stack = Stack ( ) [EOL] self . node_stack = Stack ( ) [EOL] [EOL] self . op_stack . push ( [string] ) [EOL] self . val_stack . push ( [string] ) [EOL] try : [EOL] ret = self . parse_token_list_rec ( self . op_priority [ [string] ] ) [EOL] except Exception as e : [EOL] raise e [EOL] [EOL] return ret [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . token_list ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dsl.lems.parser.expr.ValueNode$ 0 0 0 0 0 0 0 0 0 0 $dsl.lems.parser.expr.ValueNode$ 0 0 0 0 $dsl.lems.parser.expr.ValueNode$ 0 0 0 0 0 0 0 0 0 0 0 0 $dsl.lems.parser.expr.ValueNode$ 0 0 0 $dsl.lems.parser.expr.ValueNode$ 0 0 0 0 0 0 0 0 $dsl.lems.parser.expr.ValueNode$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $dsl.lems.parser.expr.ExprParser$ 0 0 0 0 0 0 $dsl.lems.parser.expr.ExprParser$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $dsl.lems.parser.expr.ExprParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dsl.lems.parser.expr.ExprParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import copy [EOL] [EOL] class LEMSBase ( object ) : [EOL] [docstring] [EOL] [EOL] def copy ( self ) : [EOL] return copy . deepcopy ( self ) [EOL] [EOL] def toxml ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] id_counter = [number] [EOL] [EOL] def make_id ( ) : [EOL] global id_counter [EOL] id_counter = id_counter + [number] [EOL] return [string] . format ( id_counter ) [EOL] [EOL] def merge_maps ( m , base ) : [EOL] [docstring] [EOL] [EOL] for k in base . keys ( ) : [EOL] if k not in m : [EOL] m [ k ] = base [ k ] [EOL] [EOL] def merge_lists ( l , base ) : [EOL] [docstring] [EOL] [EOL] for i in base : [EOL] if i not in l : [EOL] l . append ( i ) [EOL] [EOL] [EOL] def validate_lems ( file_name ) : [EOL] [EOL] from lxml import etree [EOL] try : [EOL] from urllib2 import urlopen [comment] [EOL] except : [EOL] from urllib . request import urlopen [comment] [EOL] [EOL] schema_file = urlopen ( [string] ) [EOL] xmlschema = etree . XMLSchema ( etree . parse ( schema_file ) ) [EOL] print ( [string] . format ( file_name , schema_file . geturl ( ) ) ) [EOL] xmlschema . assertValid ( etree . parse ( file_name ) ) [EOL] print ( [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] class LEMSError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , message , * params , ** key_params ) : [EOL] [docstring] [EOL] [EOL] self . message = None [EOL] [docstring] [EOL] [EOL] if params : [EOL] if key_params : [EOL] self . message = message . format ( * params , ** key_params ) [EOL] else : [EOL] self . message = message . format ( * params ) [EOL] else : [EOL] if key_params : [EOL] self . message = message ( ** key_params ) [EOL] else : [EOL] self . message = message [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] [EOL] return self . message [EOL] [EOL] class StackError ( LEMSError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] class ParseError ( LEMSError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] class ModelError ( LEMSError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] class SimBuildError ( LEMSError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] class SimError ( LEMSError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from lems . base . base import LEMSBase [EOL] from lems . base . errors import StackError [EOL] [EOL] class Stack ( LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] self . stack = [ ] [EOL] [docstring] [EOL] [EOL] def push ( self , val ) : [EOL] [docstring] [EOL] [EOL] self . stack = [ val ] + self . stack [EOL] [EOL] def pop ( self ) : [EOL] [docstring] [EOL] [EOL] if self . stack : [EOL] val = self . stack [ [number] ] [EOL] self . stack = self . stack [ [number] : ] [EOL] return val [EOL] else : [EOL] raise StackError ( [string] ) [EOL] [EOL] def top ( self ) : [EOL] [docstring] [EOL] [EOL] if self . stack : [EOL] return self . stack [ [number] ] [EOL] else : [EOL] raise StackError ( [string] ) [EOL] [EOL] def is_empty ( self ) : [EOL] [docstring] [EOL] [EOL] return self . stack == [ ] [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] [EOL] if len ( self . stack ) == [number] : [EOL] s = [string] [EOL] else : [EOL] s = [string] + str ( self . stack [ [number] ] ) [EOL] for i in range ( [number] , len ( self . stack ) ) : [EOL] s += [string] + str ( self . stack [ i ] ) [EOL] s += [string] [EOL] return s [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from lems . base . base import LEMSBase [EOL] [EOL] from collections import OrderedDict [EOL] [EOL] class Map ( OrderedDict , LEMSBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * params , ** key_params ) : [EOL] [docstring] [EOL] [EOL] OrderedDict . __init__ ( self , * params , ** key_params ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] [EOL] return iter ( self . values ( ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from mako . template import Template [EOL] [EOL] import os [EOL] import sys [EOL] [EOL] sys . path . insert ( [number] , os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , os . path . pardir ) ) [EOL] from lems . model . model import Model [EOL] [EOL] [EOL] def default_lems_folder ( ) : [EOL] here = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] print ( [string] , here , [string] ) [EOL] xmlpath = os . path . join ( here , [string] ) [EOL] return xmlpath [EOL] [EOL] def lems_file ( model_name , folder = None ) : [EOL] folder = folder or default_lems_folder ( ) [EOL] return os . path . join ( folder , model_name . lower ( ) + [string] ) [EOL] [EOL] def default_template ( ) : [EOL] here = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] tmp_filename = os . path . join ( here , [string] ) [EOL] template = Template ( filename = tmp_filename ) [EOL] return template [EOL] [EOL] def load_model ( model_filename , folder = None ) : [EOL] [docstring] [EOL] [EOL] fp_xml = lems_file ( model_filename , folder ) [EOL] [EOL] model = Model ( ) [EOL] model . import_from_file ( fp_xml ) [EOL] [comment] [EOL] [EOL] return model [EOL] [EOL] def render_model ( model_name , template = None , folder = None ) : [EOL] [EOL] model = load_model ( model_name , folder ) [EOL] template = template or default_template ( ) [EOL] [EOL] modellist = model . component_types [ model_name ] [EOL] [EOL] [comment] [EOL] couplinglist = list ( ) [EOL] [EOL] for i , cplists in enumerate ( model . component_types ) : [EOL] if [string] in cplists . name : [EOL] couplinglist . append ( cplists ) [EOL] [EOL] [comment] [EOL] expolist = list ( ) [EOL] for i , expo in enumerate ( modellist . exposures ) : [EOL] for chc in expo . choices : [EOL] expolist . append ( chc ) [EOL] [EOL] [comment] [EOL] noisepresent = False [EOL] for ct in ( model . component_types ) : [EOL] if ct . name == [string] and ct . description == [string] : [EOL] noisepresent = True [EOL] [EOL] [comment] [EOL] model_str = template . render ( modelname = model_name , const = modellist . constants , dynamics = modellist . dynamics , params = modellist . parameters , derparams = modellist . derived_parameters , coupling = couplinglist , noisepresent = noisepresent , expolist = expolist ) [EOL] [EOL] return model_str [EOL] [EOL] def cuda_templating ( model_filename , folder = None ) : [EOL] [EOL] modelfile = os . path . join ( ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) , [string] , model_filename . lower ( ) + [string] ) [EOL] [EOL] [comment] [EOL] model_str = render_model ( model_filename , template = default_template ( ) , folder = folder ) [EOL] [EOL] [comment] [EOL] with open ( modelfile , [string] ) as f : [EOL] f . writelines ( model_str ) [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] model_filename = [string] [EOL] cuda_templating ( model_filename ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0
	0
[comment] [EOL] [EOL] from __future__ import print_function [EOL] import os . path [EOL] import numpy as np [EOL] import pycuda . driver as drv [EOL] from pycuda . compiler import SourceModule [EOL] import pycuda . gpuarray as gpuarray [EOL] import time [EOL] [EOL] here = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] [EOL] class CudaRun : [EOL] [EOL] def make_kernel ( self , source_file , warp_size , block_dim_x , args , lineinfo = False , nh = [string] ) : [EOL] with open ( source_file , [string] ) as fd : [EOL] source = fd . read ( ) [EOL] source = source . replace ( [string] , [string] % ( np . pi , ) ) [EOL] opts = [ [string] , [string] , [string] ] [EOL] if lineinfo : [EOL] opts . append ( [string] ) [EOL] opts . append ( [string] % ( warp_size , ) ) [EOL] opts . append ( [string] % ( block_dim_x , ) ) [EOL] opts . append ( [string] % ( nh , ) ) [EOL] [EOL] idirs = [ here ] [EOL] [comment] [EOL] network_module = SourceModule ( source , options = opts , include_dirs = idirs , no_extern_c = True , keep = False , ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mod_func = [string] . format ( [string] , len ( args . model ) , args . model . capitalize ( ) , [string] ) [EOL] [EOL] step_fn = network_module . get_function ( mod_func ) [EOL] [EOL] return step_fn [comment] [EOL] [EOL] def cf ( self , array ) :[comment] [EOL] [comment] [EOL] return array . astype ( dtype = [string] , order = [string] , copy = True )[comment] [EOL] [EOL] def nbytes ( self , data ) :[comment] [EOL] [comment] [EOL] nbytes = [number] [EOL] for name , array in data . items ( ) : [EOL] nbytes += array . nbytes [EOL] return nbytes[comment] [EOL] [EOL] def make_gpu_data ( self , data ) :[comment] [EOL] [comment] [EOL] gpu_data = { } [EOL] for name , array in data . items ( ) : [EOL] gpu_data [ name ] = gpuarray . to_gpu ( self . cf ( array ) ) [EOL] return gpu_data[comment] [EOL] [EOL] def gpu_info ( self ) : [EOL] cmd = [string] [EOL] returned_value = os . system ( cmd ) [comment] [EOL] print ( [string] , returned_value ) [EOL] [EOL] def run_simulation ( self , weights , lengths , params_matrix , speeds , logger , args , n_nodes , n_work_items , n_params , nstep , n_inner_steps , buf_len , states , dt , min_speed ) : [EOL] [EOL] [comment] [EOL] data = { [string] : weights , [string] : lengths , [string] : params_matrix . T } [EOL] base_shape = n_work_items , [EOL] for name , shape in dict ( tavg = ( n_nodes , ) , state = ( buf_len , states * n_nodes ) , ) . items ( ) : [EOL] data [ name ] = np . zeros ( shape + base_shape , [string] ) [EOL] [EOL] gpu_data = self . make_gpu_data ( data )[comment] [EOL] [comment] [EOL] logger . info ( [string] % ( self . nbytes ( data ) / [number] / [number] , ) )[comment] [EOL] [EOL] [comment] [EOL] step_fn = self . make_kernel ( source_file = args . filename , warp_size = [number] , block_dim_x = args . n_coupling , args = args , lineinfo = args . lineinfo , nh = buf_len , )[comment] [EOL] [EOL] [comment] [EOL] tic = time . time ( ) [EOL] [comment] [EOL] streams = [ drv . Stream ( ) for i in range ( [number] ) ] [EOL] events = [ drv . Event ( ) for i in range ( [number] ) ] [EOL] tavg_unpinned = [ ] [EOL] tavg = drv . pagelocked_zeros ( data [ [string] ] . shape , dtype = np . float32 ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] gridx = args . n_coupling // args . blockszx [EOL] gridy = args . n_speed // args . blockszy [EOL] final_block_dim = args . blockszx , args . blockszy , [number] [EOL] final_grid_dim = gridx , gridy [EOL] [EOL] [comment] [EOL] logger . info ( [string] , final_grid_dim ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( nstep ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] step_fn ( np . uintc ( i * n_inner_steps ) , np . uintc ( n_nodes ) , np . uintc ( buf_len ) , np . uintc ( n_inner_steps ) , np . uintc ( n_params ) , np . float32 ( dt ) , np . float32 ( min_speed ) , gpu_data [ [string] ] , gpu_data [ [string] ] , gpu_data [ [string] ] , gpu_data [ [string] ] , gpu_data [ [string] ] , block = final_block_dim , grid = final_grid_dim ) [EOL] [EOL] [comment] [EOL] tavg_unpinned . append ( tavg . copy ( ) ) [EOL] drv . memcpy_dtoh ( tavg , gpu_data [ [string] ] . ptr ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] tavg = np . array ( tavg_unpinned ) [EOL] return tavg [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import dsl [EOL] import argparse [EOL] import logging [EOL] from tvb . simulator . lab import * [EOL] import numpy as np [EOL] import numpy . random as rgn [EOL] import math [EOL] import time [EOL] import logging [EOL] import itertools [EOL] import argparse [EOL] import os , sys [EOL] [EOL] from numpy import corrcoef [EOL] [EOL] sys . path . insert ( [number] , os . path . join ( os . getcwd ( ) , os . pardir ) ) [EOL] import LEMS2CUDA [EOL] [EOL] rgn . seed ( [number] ) [EOL] [EOL] class TVB_test : [EOL] [EOL] def __init__ ( self ) : [EOL] self . args = self . parse_args ( ) [EOL] self . sim_length = self . args . n_time [comment] [EOL] self . g = np . array ( [ [number] ] ) [EOL] self . s = np . array ( [ [number] ] ) [EOL] self . dt = [number] [EOL] self . period = [number] [EOL] self . omega = [number] * [number] * math . pi / [number] [EOL] ( self . connectivity , self . coupling ) = self . tvb_connectivity ( self . s , self . g , self . dt ) [EOL] self . integrator = integrators . EulerDeterministic ( dt = self . dt ) [EOL] self . weights = self . SC = self . connectivity . weights [EOL] self . lengths = self . connectivity . tract_lengths [EOL] self . n_nodes = self . weights . shape [ [number] ] [EOL] self . tavg_period = [number] [EOL] self . nstep = self . args . n_time [comment] [EOL] self . n_inner_steps = int ( self . tavg_period / self . dt ) [EOL] self . nc = self . args . n_coupling [EOL] self . ns = self . args . n_speed [EOL] self . couplings , self . speeds = self . setup_params ( self . nc , self . ns ) [EOL] self . params = self . expand_params ( self . couplings , self . speeds ) [EOL] self . n_work_items , self . n_params = self . params . shape [EOL] self . min_speed = self . speeds . min ( ) [EOL] self . buf_len_ = ( ( self . lengths / self . min_speed / self . dt ) . astype ( [string] ) . max ( ) + [number] ) [EOL] self . buf_len = [number] ** np . argwhere ( [number] ** np . r_ [ : [number] ] > self . buf_len_ ) [ [number] ] [ [number] ] [comment] [EOL] self . states = [number] [EOL] [EOL] def tvb_connectivity ( self , speed , global_coupling , dt = [number] ) : [EOL] white_matter = connectivity . Connectivity . from_file ( source_file = [string] ) [EOL] white_matter . configure ( ) [EOL] white_matter . speed = np . array ( [ speed ] ) [EOL] white_matter_coupling = coupling . Linear ( a = global_coupling ) [EOL] return white_matter , white_matter_coupling [EOL] [EOL] def parse_args ( self ) : [comment] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , default = [number] , type = int ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , default = [number] , type = int ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , type = int , default = [number] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] , default = [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parser . add_argument ( [string] , default = [number] , type = int ) [EOL] parser . add_argument ( [string] , choices = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , help = [string] , default = [string] ) [EOL] parser . add_argument ( [string] , default = True , action = [string] ) [EOL] [EOL] parser . add_argument ( [string] , default = [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , default = [string] , type = str , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , default = [string] , type = int , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , default = [string] , type = int , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , default = False , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] return args [EOL] [EOL] def expand_params ( self , couplings , speeds ) : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] params = itertools . product ( speeds , couplings ) [EOL] params = np . array ( [ vals for vals in params ] , np . float32 ) [EOL] return params [comment] [EOL] [EOL] def setup_params ( self , nc , ns ) : [comment] [EOL] [comment] [EOL] [comment] [EOL] couplings = np . logspace ( [number] , [number] , nc ) [EOL] speeds = np . logspace ( [number] , [number] , ns ) [EOL] return couplings , speeds [comment] [EOL] [EOL] [comment] [EOL] def check_results ( self , n_nodes , n_work_items , tavg , weights , speeds , couplings , logger , args ) : [EOL] r , c = np . triu_indices ( n_nodes , [number] ) [EOL] win_size = args . n_time [comment] [EOL] win_tavg = tavg . reshape ( ( - [number] , win_size ) + tavg . shape [ [number] : ] ) [EOL] err = np . zeros ( ( len ( win_tavg ) , n_work_items ) ) [EOL] logger . info ( [string] , err . shape ) [EOL] [comment] [EOL] for i , tavg_ in enumerate ( win_tavg ) : [EOL] for j in range ( n_work_items ) : [EOL] fc = np . corrcoef ( tavg_ [ : , : , j ] . T ) [EOL] [comment] [EOL] [comment] [EOL] err [ i , j ] = ( ( fc [ r , c ] - weights [ r , c ] ) ** [number] ) . sum ( ) [EOL] [comment] [EOL] err_ = err [ - [number] ] . reshape ( ( speeds . size , couplings . size ) ) [EOL] [comment] [EOL] derr_speed = np . diff ( err_ . mean ( axis = [number] ) ) . sum ( ) [EOL] derr_coupl = np . diff ( err_ . mean ( axis = [number] ) ) . sum ( ) [EOL] logger . info ( [string] , derr_speed , derr_coupl ) [EOL] [comment] [EOL] assert derr_speed > [number] [EOL] assert derr_coupl < - [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] logger . info ( [string] ) [EOL] [EOL] def start_cuda ( self , logger ) : [EOL] [comment] [EOL] from cuda_run import CudaRun [EOL] cudarun = CudaRun ( ) [EOL] tavg_data = cudarun . run_simulation ( self . weights , self . lengths , self . params , self . speeds , logger , self . args , self . n_nodes , self . n_work_items , self . n_params , self . nstep , self . n_inner_steps , self . buf_len , self . states , self . dt , self . min_speed ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] return tavg_data [EOL] [EOL] def set_CUDAmodel_dir ( self ) : [EOL] [comment] [EOL] self . args . filename = os . path . join ( ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) , os . pardir , [string] , self . args . model . lower ( ) + [string] ) [EOL] [EOL] def set_states ( self ) : [EOL] if [string] in self . args . model . lower ( ) : [EOL] self . states = [number] [EOL] elif [string] in self . args . model . lower ( ) : [EOL] self . states = [number] [EOL] elif [string] in self . args . model . lower ( ) : [EOL] self . states = [number] [EOL] elif [string] in self . args . model . lower ( ) : [EOL] self . states = [number] [EOL] elif [string] in self . args . model . lower ( ) : [EOL] self . states = [number] [EOL] [EOL] def compare_with_ref ( self , logger , tavg0 ) : [EOL] self . args . model = self . args . model + [string] [EOL] self . set_CUDAmodel_dir ( ) [EOL] tavg1 = self . start_cuda ( logger ) [EOL] [EOL] [comment] [EOL] comparison = ( tavg0 . ravel ( ) == tavg1 . ravel ( ) ) [EOL] logger . info ( [string] , comparison . all ( ) ) [EOL] logger . info ( [string] , corrcoef ( tavg0 . ravel ( ) , tavg1 . ravel ( ) ) [ [number] , [number] ] ) [EOL] [EOL] def startsim ( self ) : [EOL] [EOL] tic = time . time ( ) [EOL] logging . basicConfig ( level = logging . DEBUG if self . args . verbose else logging . INFO ) [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] self . set_CUDAmodel_dir ( ) [EOL] [EOL] self . set_states ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] tac = time . time ( ) [EOL] [comment] [EOL] [EOL] tavg0 = self . start_cuda ( logger ) [EOL] toc = time . time ( ) [EOL] [EOL] if ( self . args . validate ) : [EOL] self . compare_with_ref ( logger , tavg0 ) [EOL] [EOL] toc = time . time ( ) [EOL] elapsed = toc - tic [EOL] logger . info ( [string] , elapsed ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] example = TVB_test ( ) [EOL] [EOL] [comment] [EOL] LEMS2CUDA . cuda_templating ( example . args . model , [string] ) [EOL] [EOL] [comment] [EOL] example . startsim ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $logging.Logger$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dsl.dsl_cuda.example.cuda_setup.TVB_test$ 0 0 0 0 0 0 0 0 0 0 0 0 $dsl.dsl_cuda.example.cuda_setup.TVB_test$ 0 0 0 0 0 0 0 0 0 0 0 $dsl.dsl_cuda.example.cuda_setup.TVB_test$ 0 0 0 0 0
	0
	0