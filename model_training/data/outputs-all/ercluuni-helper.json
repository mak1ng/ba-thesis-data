	0
from typing import Type , Any , Dict [EOL] import builtins [EOL] import typing [EOL] import schedule [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] import json [EOL] from pathlib import Path [EOL] [EOL] COLORS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] VALID_COURSES = Path ( __file__ ) . resolve ( ) . parents [ [number] ] . joinpath ( [string] , [string] ) [EOL] [EOL] [EOL] def get_table_content ( ) : [EOL] [docstring] [EOL] content = VALID_COURSES . read_text ( ) [EOL] return json . loads ( content ) [EOL] [EOL] [EOL] class MyCourses : [comment] [EOL] [docstring] [EOL] [EOL] _table = None [EOL] [EOL] def __init__ ( self , name ) : [EOL] if MyCourses . _table is None : [EOL] print ( f" [string] { VALID_COURSES } [string] " , end = [string] ) [EOL] MyCourses . _table = get_table_content ( ) [EOL] print ( [string] ) [EOL] self . _name = None [EOL] [EOL] self . name = name [EOL] properties = MyCourses . _table [ [string] ] [ self . name ] [EOL] self . _acronym = properties [ [string] ] [EOL] self . _color = COLORS [ properties [ [string] ] ] [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . name } [string] { self . acronym } [string] { self . color } [string] " [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ name . setter def name ( self , name ) : [EOL] lower = name . lower ( ) [EOL] if lower not in MyCourses . _table [ [string] ] : [EOL] raise ValueError ( f"{ lower } [string] " ) [EOL] self . _name = lower [EOL] [EOL] @ property def acronym ( self ) : [EOL] [docstring] [EOL] return self . _acronym [EOL] [EOL] @ property def color ( self ) : [EOL] [docstring] [EOL] return self . _color [EOL] [EOL] @ classmethod def get_course_color ( cls , name ) : [EOL] [docstring] [EOL] course = cls ( name ) [EOL] return course . color [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $schedule.courses.MyCourses$ 0 0 0 $builtins.str$ 0 0 0 $schedule.courses.MyCourses$ 0 0 0
from typing import Any , Tuple , List [EOL] import icalendar [EOL] import my_event [EOL] import datetime [EOL] import builtins [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import argparse [comment] [EOL] import typing [EOL] from datetime import datetime , timedelta [EOL] from pathlib import Path [EOL] [EOL] from icalendar import Calendar as VCalendar [EOL] from icalendar import Event as VEvent [EOL] from pytz import timezone as tz [EOL] [EOL] from api_implementation import MyCalendarBatchInsert [EOL] from download_cal import download_from_portal [EOL] from my_event import MyEvent [EOL] [EOL] [EOL] def log ( arg ) : [EOL] [docstring] [EOL] print ( datetime . now ( ) . isoformat ( ) [ : [number] ] + [string] + arg ) [EOL] [EOL] [EOL] def parse_ics_file ( filename ) : [EOL] [docstring] [EOL] with open ( filename , [string] , encoding = [string] ) as file : [EOL] return VCalendar . from_ical ( file . read ( ) ) [EOL] [EOL] [EOL] def parse_ical ( cal , weeks_to_filter ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] vevents = cal . walk ( [string] ) [EOL] my_events = [ MyEvent . from_ical_event ( vevent ) for vevent in vevents ] [EOL] [EOL] if weeks_to_filter != - [number] : [EOL] [EOL] today = datetime . now ( tz ( [string] ) ) . replace ( hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] next_sat = today + timedelta ( ( [number] - today . weekday ( ) ) % [number] ) [EOL] last_dt = next_sat + timedelta ( [number] * weeks_to_filter ) [EOL] [EOL] my_events = [ x for x in my_events if x . start_time < last_dt ] [EOL] [EOL] return my_events [EOL] [EOL] [EOL] def upload_to_google_calendar ( events ) : [EOL] [docstring] [EOL] batch = MyCalendarBatchInsert ( ) [EOL] [EOL] for event in events : [EOL] batch . add ( event . to_gcal_event ( ) ) [EOL] [EOL] return batch . execute ( ) [EOL] [EOL] [EOL] [comment] [EOL] def make_test_content ( ) : [EOL] [docstring] [EOL] cal = VCalendar ( ) [EOL] [comment] [EOL] cal . add ( [string] , [string] ) [EOL] [EOL] now = datetime . now ( ) [EOL] today = ( now . year , now . month , now . day ) [EOL] [EOL] for x in range ( [number] , [number] ) : [EOL] event = VEvent ( ) [EOL] event . add ( [string] , f" [string] { x }" ) [EOL] event . add ( [string] , datetime ( * today , [number] + [number] * x ) ) [EOL] event . add ( [string] , datetime ( * today , [number] + [number] * x ) ) [EOL] [comment] [EOL] [comment] [EOL] event . add ( [string] , f" [string] { x } [string] " , ) [EOL] [EOL] cal . add_component ( event ) [EOL] [EOL] return cal [EOL] [EOL] [EOL] def parse_arguments ( argv ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] group = parser . add_mutually_exclusive_group ( required = True ) [EOL] [EOL] group . add_argument ( [string] , help = [string] , nargs = [string] ) [EOL] [EOL] group . add_argument ( [string] , [string] , dest = [string] , action = [string] , help = [string] , ) [EOL] [EOL] group . add_argument ( [string] , [string] , action = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] , type = str , default = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , dest = [string] , help = [string] , action = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] ) [EOL] [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] , ) [EOL] [EOL] group . add_argument ( [string] , dest = [string] , type = int , default = - [number] , help = [string] [string] , ) [EOL] [EOL] args = parser . parse_args ( argv ) [EOL] return args [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def main ( argv ) : [EOL] [docstring] [EOL] parsed_args = parse_arguments ( argv ) [EOL] log ( [string] ) [EOL] [EOL] if parsed_args . test : [EOL] content = make_test_content ( ) [EOL] [EOL] elif parsed_args . filename : [EOL] if not Path ( parsed_args . filename ) . exists ( ) : [EOL] raise ValueError ( f"{ parsed_args . filename } [string] " ) [EOL] [EOL] print ( f" [string] { parsed_args . filename }" ) [EOL] content = parse_ics_file ( parsed_args . filename ) [EOL] [EOL] elif parsed_args . download : [EOL] if not parsed_args . when : [EOL] today = datetime . now ( tz ( [string] ) ) . replace ( hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] [EOL] next_mon = today + timedelta ( ( [number] - today . weekday ( ) ) % [number] ) [EOL] [EOL] raw_content = download_from_portal ( next_mon ) [EOL] else : [EOL] when = datetime . strptime ( parsed_args . when , [string] ) [EOL] [EOL] raw_content = download_from_portal ( when ) [EOL] [EOL] content = VCalendar . from_ical ( raw_content ) [EOL] [EOL] events = parse_ical ( content , parsed_args . weeks_to_filter ) [EOL] [EOL] print ( f" [string] { len ( events ) } [string] " ) [EOL] [EOL] if parsed_args . colors : [EOL] from api_implementation import update_courses_colors [EOL] [EOL] update_courses_colors ( ) [EOL] [EOL] if parsed_args . verbose : [EOL] for event in events : [EOL] print ( event ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if parsed_args . upload : [EOL] print ( f" [string] " ) [EOL] upload_to_google_calendar ( events ) [EOL] print ( [string] ) [EOL] [EOL] if parsed_args . remove : [EOL] Path ( parsed_args . filename ) . unlink ( ) [EOL] print ( f" [string] { parsed_args . filename }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] from sys import argv as sys_argv [EOL] [EOL] log ( [string] ) [EOL] main ( sys_argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , List , Dict , Callable , Optional [EOL] import pathlib [EOL] import typing [EOL] import googleapiclient [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] import json [EOL] import typing as tp [EOL] from pathlib import Path [EOL] [EOL] [comment] [EOL] [EOL] from google . oauth2 . credentials import Credentials [EOL] [EOL] [comment] [EOL] [comment] [EOL] from google_auth_oauthlib . flow import InstalledAppFlow [EOL] from googleapiclient . discovery import build , Resource [EOL] [EOL] from courses import VALID_COURSES , get_table_content [EOL] [EOL] [EOL] CREDS_FOLDER = Path ( __file__ ) . resolve ( ) . parents [ [number] ] . joinpath ( [string] ) [EOL] CLIENT_SECRETS_FILE = CREDS_FOLDER / [string] [EOL] CREDS_FILENAME = CREDS_FOLDER / [string] [EOL] [EOL] SCOPES = [ [string] , [string] , [string] , ] [EOL] [EOL] UNI_CALENDAR_ID = [string] [EOL] [EOL] [EOL] def get_authenticated_service ( api_name , api_version ) : [EOL] [docstring] [EOL] [EOL] if CREDS_FILENAME . exists ( ) : [EOL] credentials = Credentials . from_authorized_user_file ( str ( CREDS_FILENAME ) ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] else : [EOL] flow = InstalledAppFlow . from_client_secrets_file ( CLIENT_SECRETS_FILE , SCOPES ) [EOL] credentials = flow . run_local_server ( host = [string] , port = [number] , authorization_prompt_message = [string] , success_message = [string] , open_browser = True , ) [EOL] [EOL] creds_data = { [string] : None , [string] : credentials . refresh_token , [string] : credentials . token_uri , [string] : credentials . client_id , [string] : credentials . client_secret , [string] : credentials . scopes , } [EOL] [EOL] with CREDS_FILENAME . open ( [string] ) as outfile : [EOL] json . dump ( creds_data , outfile ) [EOL] [EOL] return build ( api_name , api_version , credentials = credentials ) [EOL] [EOL] [EOL] OptionalCallbackType = tp . Optional [ tp . Callable [ [ str , str , str ] , None ] ] [EOL] [EOL] [EOL] class MyCalendarBatchInsert : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , callback = None ) : [EOL] [EOL] self . _service = get_authenticated_service ( [string] , [string] ) [EOL] self . _batch = self . _service . new_batch_http_request ( callback = callback ) [EOL] [EOL] def add ( self , event , callback = None , request_id = None , ) : [EOL] [docstring] [EOL] [EOL] request = self . _service . events ( ) . insert ( calendarId = UNI_CALENDAR_ID , body = event ) [EOL] self . _batch . add ( request , request_id , callback ) [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] return self . _batch . execute ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] SPREADSHEET_ID = [string] [EOL] RANGE_NAME = [string] [EOL] [EOL] [EOL] def get_last_modified ( ) : [EOL] [docstring] [EOL] service = get_authenticated_service ( [string] , [string] ) [EOL] response = ( service . files ( ) . get ( fileId = SPREADSHEET_ID , fields = [string] ) . execute ( ) ) [EOL] return response [ [string] ] [EOL] [EOL] [EOL] def update_courses_colors ( ) : [EOL] [docstring] [EOL] last_modified = get_last_modified ( ) [EOL] table = get_table_content ( ) [EOL] [EOL] if last_modified > table [ [string] ] : [EOL] print ( [string] ) [EOL] [EOL] service = get_authenticated_service ( [string] , [string] ) [EOL] [EOL] response = ( service . spreadsheets ( ) . values ( ) . get ( spreadsheetId = SPREADSHEET_ID , range = RANGE_NAME , majorDimension = [string] ) . execute ( ) ) [EOL] values = response [ [string] ] [EOL] [EOL] for row in values : [EOL] course = row [ [number] ] . lower ( ) [EOL] try : [EOL] color = row [ [number] ] [EOL] except IndexError : [EOL] color = None [EOL] table [ [string] ] [ course ] [ [string] ] = color [EOL] [EOL] table [ [string] ] = last_modified [EOL] [EOL] with VALID_COURSES . open ( [string] , encoding = [string] ) as outfile : [EOL] json . dump ( table , outfile , ensure_ascii = False ) [EOL] [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] [comment] [EOL] update_courses_colors ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $googleapiclient.discovery.Resource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $OptionalCallbackType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $OptionalCallbackType$ 0 $OptionalCallbackType$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $OptionalCallbackType$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 $OptionalCallbackType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Type , List , Dict [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import schedule [EOL] [docstring] [EOL] [EOL] from datetime import datetime , date [EOL] import re [EOL] [EOL] from icalendar import Event as VEvent [EOL] from pytz import timezone [EOL] [EOL] from courses import MyCourses [EOL] [EOL] [EOL] class MyBaseEvent : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , summary , location , description ) : [EOL] self . summary = summary [EOL] self . location = location [EOL] self . description = description [EOL] [EOL] @ classmethod def from_ical_event ( cls , event ) : [EOL] [docstring] [EOL] [EOL] def to_gcal_event ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] class MyEvent ( MyBaseEvent ) : [EOL] [docstring] [EOL] [EOL] pattern = re . compile ( [string] ) [EOL] [EOL] def __init__ ( self , summary , start_time , end_time , location , description ) : [EOL] super ( ) . __init__ ( summary , location , description ) [EOL] [EOL] if not isinstance ( start_time , datetime ) : [EOL] raise TypeError ( [string] ) [EOL] if not isinstance ( end_time , datetime ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if not start_time . tzinfo : [EOL] start_time = timezone ( [string] ) . localize ( start_time ) [EOL] if not end_time . tzinfo : [EOL] end_time = timezone ( [string] ) . localize ( end_time ) [EOL] [EOL] self . start_time = start_time [EOL] self . end_time = end_time [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( f"{ self . summary } [string] { self . start_time } [string] { self . end_time }" f" [string] { self . location } [string] { self . description } [string] " ) [EOL] [EOL] @ classmethod def from_ical_event ( cls , event ) : [EOL] [docstring] [EOL] if not isinstance ( event , VEvent ) : [EOL] raise TypeError ( ) [EOL] [EOL] summary = str ( event [ [string] ] ) [EOL] description = str ( event [ [string] ] ) [EOL] [EOL] if [string] in event : [EOL] location = str ( event [ [string] ] ) [EOL] else : [EOL] description = description . replace ( summary + [string] , [string] ) . replace ( [string] , [string] ) [EOL] it = cls . pattern . finditer ( description ) [EOL] description = cls . pattern . sub ( [string] , description ) [EOL] [EOL] if not it : [EOL] raise ValueError ( [string] + description ) [EOL] [EOL] matches = [ ] [EOL] for el in it : [EOL] matches . append ( f"{ el . group ( [number] ) } [string] { el . group ( [number] ) } [string] " ) [EOL] [EOL] location = [string] . join ( matches ) [EOL] [EOL] start = event [ [string] ] . dt [EOL] [EOL] [comment] [EOL] if event [ [string] ] is None and start . hour == [number] and start . minute == [number] : [EOL] [comment] [EOL] start = start . replace ( hour = [number] , minute = [number] ) [EOL] end = start . replace ( hour = [number] ) [EOL] summary += [string] [EOL] else : [EOL] end = event [ [string] ] . dt [EOL] [EOL] return cls ( summary , start , end , location , description ) [EOL] [EOL] def to_gcal_event ( self ) : [EOL] event = { [string] : [string] , [string] : self . summary , [string] : self . description , [string] : self . location , [string] : { [string] : self . start_time . isoformat ( ) } , [string] : { [string] : self . end_time . isoformat ( ) } , } [EOL] [EOL] try : [EOL] event [ [string] ] = MyCourses . get_course_color ( self . summary ) [EOL] except ValueError as err : [EOL] print ( err ) [EOL] [EOL] return event [EOL] [EOL] def event_id ( self ) : [EOL] [docstring] [EOL] raw_id = [string] . format ( self . summary . lower ( ) , self . start_time . isocalendar ( ) [ [number] ] , self . start_time . isoformat ( ) , self . end_time . isoformat ( ) , ) [EOL] [EOL] valid_id = re . sub ( [string] , [string] , raw_id ) [EOL] [EOL] return valid_id [EOL] [EOL] [EOL] class MyAllDayEvent ( MyBaseEvent ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , summary , start_date , end_date , location , description ) : [EOL] super ( ) . __init__ ( self , summary , location , description ) [EOL] [EOL] if not isinstance ( start_date , date ) : [EOL] raise TypeError ( [string] ) [EOL] if not isinstance ( end_date , date ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if not start_date . tzinfo : [EOL] start_date = timezone ( [string] ) . localize ( start_date ) [EOL] if not end_date . tzinfo : [EOL] end_date = timezone ( [string] ) . localize ( end_date ) [EOL] [EOL] self . start_date = start_date [EOL] self . end_date = end_date [EOL] [EOL] raise NotImplementedError [EOL] [EOL] def to_gcal_event ( self ) : [EOL] event = { [string] : [string] , [string] : self . summary , [string] : self . description , [string] : self . location , [string] : { [string] : self . start_date . isoformat ( ) } , [string] : { [string] : self . end_date . isoformat ( ) } , } [EOL] [EOL] [comment] [EOL] [EOL] try : [EOL] event [ [string] ] = MyCourses . get_course_color ( self . summary ) [EOL] except ValueError as err : [EOL] print ( err ) [EOL] [EOL] return event [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 $datetime.date.time.datetime.datetime$ 0 0 0 $datetime.date.time.datetime.datetime$ 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date.time.datetime.datetime$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $datetime.date.time.datetime.datetime$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0