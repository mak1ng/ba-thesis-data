from typing import List , Any [EOL] import typing [EOL] import gc [EOL] import pytest [EOL] [EOL] from . index import Tree , Node [EOL] [EOL] [EOL] class TestTree ( ) : [EOL] [EOL] def setup_method ( self ) : [EOL] self . node = Node ( [string] ) [EOL] self . tree = Tree ( ) [EOL] [EOL] def teardown_method ( self ) : [EOL] [docstring] [EOL] self . node . children = [ ] [EOL] self . node = None [EOL] del self . node [EOL] gc . collect ( ) [EOL] [EOL] def test_node_properties ( self ) : [EOL] assert self . node . data == [string] [EOL] assert self . node . children == [ ] [EOL] assert len ( self . node . children ) == [number] [EOL] [EOL] def test_node_add_children ( self ) : [EOL] self . node . add ( [string] ) [EOL] assert len ( self . node . children ) == [number] [EOL] assert self . node . children [ [number] ] . data == [string] [EOL] assert len ( self . node . children [ [number] ] . children ) == [number] [EOL] [EOL] @ pytest . mark . skip def test_node_remove_children ( self ) : [EOL] self . node . add ( [string] ) [EOL] self . node . add ( [string] ) [EOL] self . node . add ( [string] ) [EOL] assert len ( self . node . children ) == [number] [EOL] self . node . remove ( [string] ) [EOL] assert len ( self . node . children ) == [number] [EOL] assert self . node . children [ [number] ] . data == [string] [EOL] [EOL] @ pytest . mark . skip def test_tree_properties ( self ) : [EOL] self . assertIsNone ( self . tree . root ) [EOL] [EOL] @ pytest . mark . skip def test_tree_traverse_breadth ( self ) : [EOL] letters = [ ] [EOL] self . tree . root = self . node [EOL] self . tree . root . add ( [string] ) [EOL] self . tree . root . add ( [string] ) [EOL] self . tree . root . children [ [number] ] . add ( [string] ) [EOL] [EOL] def f ( node ) : letters . append ( node . data ) [EOL] self . tree . traverse_breadth ( f ) [EOL] assert letters == [ [string] , [string] , [string] , [string] ] [EOL] [EOL] @ pytest . mark . skip def test_tree_traverse_depth ( self ) : [EOL] letters = [ ] [EOL] self . tree . root = self . node [EOL] self . tree . root . add ( [string] ) [EOL] self . tree . root . add ( [string] ) [EOL] self . tree . root . children [ [number] ] . add ( [string] ) [EOL] [EOL] def f ( node ) : letters . append ( node . data ) [EOL] self . tree . traverse_depth ( f ) [EOL] assert letters == [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import tree [EOL] [docstring] [EOL] [EOL] [EOL] class Node : [EOL] [EOL] def __init__ ( self , data , children = [ ] ) : [EOL] self . data = data [EOL] self . children = children [EOL] [EOL] def add ( self , data ) : [EOL] [docstring] [EOL] child = Node ( data , [ ] ) [EOL] self . children . append ( child ) [EOL] [EOL] def remove ( self , data ) : [EOL] [docstring] [EOL] self . children = list ( filter ( lambda node : node . data != data , self . children ) ) [EOL] [EOL] [EOL] class Tree : [EOL] [EOL] def __init__ ( self , root = None ) : [EOL] self . root = root [EOL] [EOL] def traverse_breadth ( self , func ) : [EOL] nodes = [ self . root ] [EOL] while nodes : [EOL] node = nodes . pop ( [number] ) [EOL] nodes . extend ( node . children ) [EOL] func ( node ) [EOL] [EOL] def traverse_depth ( self , func ) : [EOL] nodes = [ self . root ] [EOL] while nodes : [EOL] node = nodes . pop ( [number] ) [EOL] nodes [ [number] : [number] ] = node . children [EOL] func ( node ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tree.index.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tree.index.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0
	0
from typing import Iterator , Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from . index import LinkedList , Node [EOL] [EOL] [EOL] class TestLinkedList ( ) : [EOL] [EOL] def setup_method ( self ) : [EOL] self . llst = LinkedList ( ) [EOL] [EOL] def test_node_class ( self ) : [EOL] node_a = Node ( [number] ) [EOL] assert isinstance ( node_a , Node ) is True [EOL] assert node_a . data == [number] [EOL] assert node_a . next is None [EOL] [EOL] node_b = Node ( [string] , node_a ) [EOL] assert isinstance ( node_b , Node ) is True [EOL] assert node_b . data == [string] [EOL] assert node_b . next == node_a [EOL] [EOL] node_c = Node ( [ [string] ] ) [EOL] assert isinstance ( node_c , Node ) is True [EOL] assert node_c . data == [ [string] ] [EOL] assert node_c . next is None [EOL] [EOL] def test_linkedlist_class ( self ) : [EOL] assert isinstance ( self . llst , LinkedList ) is True [EOL] assert self . llst . head is None [EOL] [EOL] def test_size ( self ) : [EOL] assert self . llst . size ( ) == [number] [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . size ( ) == [number] [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . size ( ) == [number] [EOL] assert len ( self . llst ) == [number] [EOL] [EOL] def test_clear ( self ) : [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . size ( ) == [number] [EOL] self . llst . clear ( ) [EOL] assert self . llst . size ( ) == [number] [EOL] [EOL] def test_get_at ( self ) : [EOL] assert self . llst . get_at ( - [number] ) is None [EOL] self . llst . insert_last ( [number] ) [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] assert self . llst . get_at ( [number] ) is None [EOL] [EOL] def test_get_first ( self ) : [EOL] assert self . llst . get_first ( ) is None [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . get_first ( ) . data == [number] [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . get_first ( ) . data == [number] [EOL] [EOL] def test_get_last ( self ) : [EOL] assert self . llst . get_last ( ) is None [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . get_last ( ) . data == [number] [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . get_last ( ) . data == [number] [EOL] [EOL] def test_insert_at ( self ) : [EOL] [comment] [EOL] self . llst . insert_at ( [number] , [string] ) [EOL] assert self . llst . get_at ( [number] ) . data == [string] [EOL] [comment] [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_at ( - [number] , [string] ) [EOL] assert self . llst . get_at ( [number] ) . data == [string] [EOL] assert self . llst . get_at ( [number] ) . data == [string] [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] [comment] [EOL] self . llst . insert_at ( [number] , [number] ) [EOL] assert self . llst . get_at ( [number] ) . data == [string] [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] assert self . llst . get_at ( [number] ) . data == [string] [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] [comment] [EOL] self . llst . insert_at ( [number] , [string] ) [EOL] assert self . llst . get_at ( [number] ) . data == [string] [EOL] assert self . llst . get_last ( ) . data == [string] [EOL] assert self . llst . get_at ( [number] ) is None [EOL] [EOL] def test_insert_first ( self ) : [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . head . data == [number] [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . head . data == [number] [EOL] [EOL] def test_insert_last ( self ) : [EOL] self . llst . insert_last ( [number] ) [EOL] assert self . llst . get_last ( ) . data == [number] [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] assert self . llst . get_last ( ) . data == [number] [EOL] [EOL] def test_remove_at ( self ) : [EOL] [comment] [EOL] try : [EOL] self . llst . remove_at ( [number] ) [EOL] except Exception as e : [EOL] pytest . fail ( e ) [EOL] [comment] [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . remove_at ( [number] ) [EOL] assert self . llst . get_at ( [number] ) is None [EOL] [comment] [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . remove_at ( [number] ) [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] [comment] [EOL] try : [EOL] self . llst . remove_at ( - [number] ) [EOL] except Exception as e : [EOL] pytest . fail ( e ) [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] [comment] [EOL] try : [EOL] self . llst . remove_at ( [number] ) [EOL] except Exception as e : [EOL] pytest . fail ( e ) [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] [EOL] def test_remove_first ( self ) : [EOL] [comment] [EOL] try : [EOL] self . llst . remove_first ( ) [EOL] except Exception as e : [EOL] pytest . fail ( e ) [EOL] [comment] [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . remove_first ( ) [EOL] assert self . llst . get_first ( ) is None [EOL] [comment] [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . get_first ( ) . data == [number] [EOL] self . llst . remove_first ( ) [EOL] assert self . llst . get_first ( ) . data == [number] [EOL] [EOL] def test_remove_last ( self ) : [EOL] [comment] [EOL] try : [EOL] self . llst . remove_last ( ) [EOL] except Exception as e : [EOL] pytest . fail ( e ) [EOL] [comment] [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . remove_last ( ) [EOL] assert self . llst . get_last ( ) is None [EOL] [comment] [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] self . llst . insert_first ( [number] ) [EOL] assert self . llst . get_last ( ) . data == [number] [EOL] self . llst . remove_last ( ) [EOL] assert self . llst . get_last ( ) . data == [number] [EOL] [EOL] def test_every ( self ) : [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] try : [EOL] def f ( node ) : node . data += [number] [EOL] self . llst . every ( f ) [EOL] except Exception as e : [EOL] pytest . fail ( e ) [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] [EOL] def test_iteration ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] for node in self . llst : [EOL] node . data += [number] [EOL] except Exception as e : [EOL] pytest . fail ( e ) [EOL] assert self . llst . get_first ( ) is None [EOL] [comment] [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] self . llst . insert_last ( [number] ) [EOL] [comment] [EOL] g = iter ( self . llst ) [EOL] assert next ( g ) . data == [number] [EOL] assert next ( g ) . data == [number] [EOL] assert next ( g ) . data == [number] [EOL] assert next ( g ) . data == [number] [EOL] [comment] [EOL] try : [EOL] for node in self . llst : [EOL] node . data += [number] [EOL] except Exception as e : [EOL] pytest . fail ( e ) [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL] assert self . llst . get_at ( [number] ) . data == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import qfroms [EOL] [docstring] [EOL] [EOL] [EOL] class Stack : [EOL] [EOL] def __init__ ( self ) : [EOL] self . _data = [ ] [EOL] [EOL] def push ( self , elem ) : [EOL] self . _data . append ( elem ) [EOL] [EOL] def pop ( self ) : [EOL] try : [EOL] return self . _data . pop ( ) [EOL] except : [EOL] return None [EOL] [EOL] def peek ( self ) : [EOL] try : [EOL] return self . _data [ - [number] ] [EOL] except : [EOL] return None [EOL] [EOL] [EOL] class Queue : [EOL] [EOL] def __init__ ( self ) : [EOL] self . _stack_one = Stack ( ) [EOL] self . _stack_two = Stack ( ) [EOL] [EOL] def _reverse ( self ) : [EOL] while self . _stack_one . peek ( ) : [EOL] self . _stack_two . push ( self . _stack_one . pop ( ) ) [EOL] [EOL] def enqueue ( self , elem ) : [EOL] self . _stack_one . push ( elem ) [EOL] [EOL] def dequeue ( self ) : [EOL] self . _reverse ( ) [EOL] return self . _stack_two . pop ( ) [EOL] [EOL] def peek ( self ) : [EOL] self . _reverse ( ) [EOL] return self . _stack_two . peek ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $qfroms.index.Stack$ 0 0 0 0 0 0 0 $qfroms.index.Stack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL]	0 0
from . index import capitalize [EOL] [EOL] [EOL] def test_capitalize ( ) : [EOL] assert capitalize ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL] [EOL] [EOL] def capitalize ( sentence ) : [EOL] return sentence . title ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . index import are_anagrams [EOL] [EOL] [EOL] def test_are_anagrams_true ( ) : [EOL] assert are_anagrams ( [string] , [string] ) is True [EOL] assert are_anagrams ( [string] , [string] ) is True [EOL] assert are_anagrams ( [string] , [string] ) is True [EOL] assert are_anagrams ( [string] , [string] ) is True [EOL] [EOL] [EOL] def test_are_anagrams_false ( ) : [EOL] assert are_anagrams ( [string] , [string] ) is False [EOL] assert are_anagrams ( [string] , [string] ) is False [EOL] assert are_anagrams ( [string] , [string] ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern [EOL] import builtins [EOL] import typing [EOL] import re [EOL] [EOL] [EOL] def are_anagrams ( string_a , string_b ) : [EOL] [docstring] [EOL] pattern = re . compile ( [string] ) [EOL] [comment] [EOL] first = [string] . join ( sorted ( list ( pattern . sub ( [string] , string_a . lower ( ) ) ) ) ) [EOL] second = [string] . join ( sorted ( list ( pattern . sub ( [string] , string_b . lower ( ) ) ) ) ) [EOL] return first == second [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[docstring] [EOL] [EOL] [EOL] class Queue : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . lst = [ ] [EOL] [EOL] def enqueue ( self , elem ) : [EOL] self . lst . insert ( [number] , elem ) [EOL] [EOL] def dequeue ( self ) : [EOL] try : [EOL] return self . lst . pop ( ) [EOL] except : [EOL] return None [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self . lst ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . index import Queue [EOL] [EOL] [EOL] class TestQueue : [EOL] [EOL] def setup_method ( self ) : [EOL] self . q = Queue ( ) [EOL] [EOL] def enqueue_one_to_three ( self ) : [EOL] self . q . enqueue ( [number] ) [EOL] self . q . enqueue ( [number] ) [EOL] self . q . enqueue ( [number] ) [EOL] [EOL] def test_enqueue ( self ) : [EOL] self . enqueue_one_to_three ( ) [EOL] assert self . q . lst == [ [number] , [number] , [number] ] [EOL] self . q . enqueue ( [number] ) [EOL] assert self . q . lst == [ [number] , [number] , [number] , [number] ] [EOL] [EOL] def test_dequeue ( self ) : [EOL] self . enqueue_one_to_three ( ) [EOL] assert self . q . dequeue ( ) == [number] [EOL] assert self . q . dequeue ( ) == [number] [EOL] assert self . q . dequeue ( ) == [number] [EOL] assert self . q . dequeue ( ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . index import reverse_string [EOL] [EOL] [EOL] def test_reverse_string ( ) : [EOL] assert reverse_string ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def reverse_string ( string ) : [EOL] lst = list ( string ) [EOL] lst . reverse ( ) [EOL] return string [ : : - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] from . index import spiral_matrix [EOL] [EOL] [EOL] def test_spiral_matrix ( ) : [EOL] matrix = [ [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] ] [EOL] assert spiral_matrix ( [number] ) == matrix [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def spiral_matrix ( n ) : [EOL] [docstring] [EOL] [comment] [EOL] matrix = [ [ [number] for i in range ( n ) ] for j in range ( n ) ] [EOL] [comment] [EOL] counter = [number] [EOL] start_row = [number] [EOL] start_col = [number] [EOL] end_row = n - [number] [EOL] end_col = n - [number] [EOL] [EOL] while start_row <= end_row and start_col <= end_col : [EOL] [comment] [EOL] for i in range ( start_col , end_col + [number] ) : [EOL] matrix [ start_row ] [ i ] = counter [EOL] counter += [number] [EOL] start_row += [number] [EOL] [EOL] [comment] [EOL] for i in range ( start_row , end_row + [number] ) : [EOL] matrix [ i ] [ end_col ] = counter [EOL] counter += [number] [EOL] end_col -= [number] [EOL] [EOL] [comment] [EOL] for i in reversed ( range ( start_col , end_col + [number] ) ) : [EOL] matrix [ end_row ] [ i ] = counter [EOL] counter += [number] [EOL] end_row -= [number] [EOL] [EOL] [comment] [EOL] for i in reversed ( range ( start_row , end_row + [number] ) ) : [EOL] matrix [ i ] [ start_col ] = counter [EOL] counter += [number] [EOL] start_col += [number] [EOL] [EOL] return matrix [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] class Queue : [EOL] [EOL] def __init__ ( self ) : [EOL] self . data = [ ] [EOL] [EOL] def enqueue ( self , elem ) : [EOL] self . data . insert ( [number] , elem ) [EOL] [EOL] def dequeue ( self ) : [EOL] try : [EOL] return self . data . pop ( ) [EOL] except : [EOL] return None [EOL] [EOL] def peek ( self ) : [EOL] try : [EOL] return self . data [ - [number] ] [EOL] except : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import weave [EOL] [docstring] [EOL] from . queue import Queue [EOL] [EOL] [EOL] def weave ( queue_one , queue_two ) : [EOL] combined = Queue ( ) [EOL] [EOL] while queue_one . peek ( ) or queue_two . peek ( ) : [EOL] if queue_one . peek ( ) : [EOL] combined . enqueue ( queue_one . dequeue ( ) ) [EOL] if queue_two . peek ( ) : [EOL] combined . enqueue ( queue_two . dequeue ( ) ) [EOL] [EOL] return combined [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from . queue import Queue [EOL] from . index import weave [EOL] [EOL] [EOL] class TestWeaveFunction ( ) : [EOL] [EOL] def setup_method ( self ) : [EOL] self . queue_one = Queue ( ) [EOL] self . queue_one . enqueue ( [number] ) [EOL] self . queue_one . enqueue ( [number] ) [EOL] self . queue_one . enqueue ( [number] ) [EOL] [EOL] self . queue_two = Queue ( ) [EOL] self . queue_two . enqueue ( [string] ) [EOL] self . queue_two . enqueue ( [string] ) [EOL] self . queue_two . enqueue ( [string] ) [EOL] [EOL] def test_weave ( self ) : [EOL] result = weave ( self . queue_one , self . queue_two ) [EOL] [EOL] assert result . dequeue ( ) == [number] [EOL] assert result . dequeue ( ) == [string] [EOL] assert result . dequeue ( ) == [number] [EOL] assert result . dequeue ( ) == [string] [EOL] assert result . dequeue ( ) == [number] [EOL] assert result . dequeue ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
	0
	0
from . index import Stack [EOL] [EOL] [EOL] class TestStack : [EOL] [EOL] def setup_method ( self ) : [EOL] self . s = Stack ( ) [EOL] [EOL] def push_one_to_three ( self ) : [EOL] self . s . push ( [number] ) [EOL] self . s . push ( [number] ) [EOL] self . s . push ( [number] ) [EOL] [EOL] def test_push_pop ( self ) : [EOL] self . s . push ( [number] ) [EOL] assert self . s . pop ( ) == [number] [EOL] self . s . push ( [number] ) [EOL] assert self . s . pop ( ) == [number] [EOL] [EOL] def test_order_filo ( self ) : [EOL] self . push_one_to_three ( ) [EOL] assert self . s . pop ( ) == [number] [EOL] assert self . s . pop ( ) == [number] [EOL] assert self . s . pop ( ) == [number] [EOL] [EOL] def test_peek ( self ) : [EOL] self . push_one_to_three ( ) [EOL] assert self . s . peek ( ) == [number] [EOL] assert self . s . pop ( ) == [number] [EOL] assert self . s . peek ( ) == [number] [EOL] assert self . s . pop ( ) == [number] [EOL] assert self . s . peek ( ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class Stack : [EOL] [EOL] def __init__ ( self ) : [EOL] self . data = [ ] [EOL] [EOL] def push ( self , elem ) : [EOL] self . data . append ( elem ) [EOL] [EOL] def pop ( self ) : [EOL] try : [EOL] return self . data . pop ( ) [EOL] except : [EOL] return None [EOL] [EOL] def peek ( self ) : [EOL] try : [EOL] return self . data [ - [number] ] [EOL] except : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . index import pyramid [EOL] [EOL] [EOL] def test_pyramid_success ( capsys ) : [EOL] expected = [string] [EOL] pyramid ( [number] ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert out == expected [EOL] [EOL] [EOL] def test_pyramid_fail ( capsys ) : [EOL] error = [string] [EOL] pyramid ( - [number] ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert out == error [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def pyramid ( n ) : [EOL] if n <= [number] : [EOL] print ( [string] ) [EOL] else : [EOL] for i in range ( [number] , n + [number] ) : [EOL] side = n - i [EOL] centre = i * [number] - [number] [EOL] print ( [string] * side + [string] * centre + [string] * side ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class Node : [EOL] [EOL] def __init__ ( self , data , left = None , right = None ) : [EOL] self . data = data [EOL] self . left = left [EOL] self . right = right [EOL] [EOL] def insert ( self , data ) : [EOL] if data == self . data : [EOL] raise NotImplemented [EOL] elif data < self . data and self . left is None : [EOL] self . left = Node ( data ) [EOL] elif data > self . data and self . right is None : [EOL] self . right = Node ( data ) [EOL] elif data < self . data : [EOL] self . left . insert ( data ) [EOL] elif data > self . data : [EOL] self . right . insert ( data ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] def contains ( self , data ) : [EOL] if data == self . data : [EOL] return self [EOL] elif data < self . data and self . left is not None : [EOL] return self . left . contains ( data ) [EOL] elif data > self . data and self . right is not None : [EOL] return self . right . contains ( data ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import bst [EOL] from . index import Node [EOL] [EOL] [EOL] class TestBinarySearchTree ( ) : [EOL] [EOL] def test_insert ( self ) : [EOL] node = Node ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( [number] ) [EOL] [EOL] assert node . left . data == [number] [EOL] assert node . right . data == [number] [EOL] assert node . right . right . data == [number] [EOL] [EOL] def test_contains_found_node ( self ) : [EOL] node = Node ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( - [number] ) [EOL] node . insert ( [number] ) [EOL] [EOL] three = node . left . left . right [EOL] assert node . contains ( [number] ) == three [EOL] [EOL] def test_contains_return_none ( self ) : [EOL] node = Node ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( [number] ) [EOL] node . insert ( - [number] ) [EOL] node . insert ( [number] ) [EOL] [EOL] assert node . contains ( [number] ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 0 $bst.index.Node$ 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from . linkedlist import LinkedList , Node [EOL] from . index import is_circular [EOL] [EOL] [EOL] class TestIsCircular ( ) : [EOL] [EOL] def test_circular ( self ) : [EOL] d = Node ( [string] ) [EOL] c = Node ( [string] , d ) [EOL] b = Node ( [string] , c ) [EOL] a = Node ( [string] , b ) [EOL] d . next = b [EOL] llst = LinkedList ( a ) [EOL] [EOL] assert llst . get_first ( ) . data == [string] [EOL] assert llst . get_first ( ) . next == b [EOL] assert is_circular ( llst ) is True [EOL] [EOL] def test_non_circular ( self ) : [EOL] d = Node ( [string] ) [EOL] c = Node ( [string] , d ) [EOL] b = Node ( [string] , c ) [EOL] a = Node ( [string] , b ) [EOL] llst = LinkedList ( a ) [EOL] [EOL] assert llst . get_first ( ) . data == [string] [EOL] assert llst . get_first ( ) . next == b [EOL] assert is_circular ( llst ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0
[docstring] [EOL] [EOL] [EOL] def reverse_int ( n ) : [EOL] if n >= [number] : [EOL] return int ( str ( n ) [ : : - [number] ] ) [EOL] return int ( str ( abs ( n ) ) [ : : - [number] ] ) * - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from . index import reverse_int [EOL] [EOL] [EOL] def test_reverse_int ( ) : [EOL] assert reverse_int ( [number] ) == [number] [EOL] assert reverse_int ( [number] ) == [number] [EOL] assert reverse_int ( - [number] ) == - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict [EOL] import builtins [EOL] import typing [EOL] from typing import Dict [EOL] [EOL] [EOL] def max_char ( string ) : [EOL] [docstring] [EOL] if len ( string ) == [number] : [EOL] return [string] [EOL] [EOL] char_map = { } [EOL] [EOL] for char in string : [EOL] if char in char_map : [EOL] char_map [ char ] += [number] [EOL] else : [EOL] char_map [ char ] = [number] [EOL] [EOL] return max ( [ ( val , char ) for char , val in char_map . items ( ) ] ) [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . index import max_char [EOL] [EOL] [EOL] def test_max_char ( ) : [EOL] assert max_char ( [string] ) == [string] [EOL] assert max_char ( [string] ) == [string] [EOL] assert max_char ( [string] ) == [string] [EOL] assert max_char ( [string] ) == [string] [EOL] assert max_char ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import levelwidth [EOL] [docstring] [EOL] [EOL] [EOL] class Node : [EOL] [EOL] def __init__ ( self , data , children = [ ] ) : [EOL] self . data = data [EOL] self . children = children [EOL] [EOL] def add ( self , data ) : [EOL] [docstring] [EOL] child = Node ( data , [ ] ) [EOL] self . children . append ( child ) [EOL] [EOL] [EOL] def get_level_width ( root ) : [EOL] output = [ [number] ] [EOL] nodes = [ root , [string] ] [EOL] [EOL] while len ( nodes ) > [number] : [EOL] node = nodes . pop ( [number] ) [EOL] if node == [string] : [EOL] nodes . append ( [string] ) [EOL] output . append ( [number] ) [EOL] else : [EOL] output [ - [number] ] += [number] [EOL] nodes . extend ( node . children ) [EOL] [EOL] return output [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $levelwidth.index.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $levelwidth.index.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import levelwidth [EOL] from . index import Node , get_level_width [EOL] [EOL] [EOL] def test_get_level_width ( ) : [EOL] root = Node ( [number] ) [EOL] assert get_level_width ( root ) == [ [number] ] [EOL] root . add ( [number] ) [EOL] root . children [ [number] ] . add ( [number] ) [EOL] root . children [ [number] ] . add ( [number] ) [EOL] root . children [ [number] ] . children [ [number] ] . add ( [number] ) [EOL] assert get_level_width ( root ) == [ [number] , [number] , [number] , [number] ] [EOL] root . children [ [number] ] . children [ [number] ] . add ( [number] ) [EOL] root . children [ [number] ] . children [ [number] ] . add ( [number] ) [EOL] assert get_level_width ( root ) == [ [number] , [number] , [number] , [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Pattern [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] [EOL] [EOL] def vowels ( string ) : [EOL] pattern = re . compile ( [string] , re . I ) [EOL] return len ( re . findall ( pattern , string ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . index import vowels [EOL] [EOL] [EOL] def test_vowels ( ) : [EOL] assert vowels ( [string] ) == [number] [EOL] assert vowels ( [string] ) == [number] [EOL] assert vowels ( [string] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def chunk ( array , size ) : [EOL] if len ( array ) < size or len ( array ) == [number] or size <= [number] : [EOL] return array [EOL] [EOL] chunked = [ ] [EOL] index = [number] [EOL] while index < len ( array ) : [EOL] chunked . append ( array [ index : index + size ] ) [EOL] index += size [EOL] return chunked [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . index import chunk [EOL] [EOL] [EOL] def test_chunk ( ) : [EOL] lst = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] ] ] [EOL] assert chunk ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) == lst [EOL] assert chunk ( [ ] , [number] ) == [ ] [EOL] assert chunk ( [ [number] , [number] , [number] ] , [number] ) == [ [number] , [number] , [number] ] [EOL] assert chunk ( [ [number] , [number] , [number] ] , [number] ) == [ [number] , [number] , [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from . linkedlist import LinkedList [EOL] from . index import midpoint [EOL] [EOL] [EOL] class TestMidpoint ( ) : [EOL] [EOL] def setup_method ( self ) : [EOL] self . llst = LinkedList ( ) [EOL] [EOL] def test_empty ( self ) : [EOL] assert midpoint ( self . llst ) is None [EOL] [EOL] def test_odd ( self ) : [EOL] self . llst . insert_last ( [string] ) [EOL] assert len ( self . llst ) == [number] [EOL] assert midpoint ( self . llst ) . data == [string] [EOL] [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] assert len ( self . llst ) == [number] [EOL] assert midpoint ( self . llst ) . data == [string] [EOL] [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] assert len ( self . llst ) == [number] [EOL] assert midpoint ( self . llst ) . data == [string] [EOL] [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] assert len ( self . llst ) == [number] [EOL] assert midpoint ( self . llst ) . data == [string] [EOL] [EOL] def test_even ( self ) : [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] assert len ( self . llst ) == [number] [EOL] assert midpoint ( self . llst ) . data == [string] [EOL] [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] assert len ( self . llst ) == [number] [EOL] assert midpoint ( self . llst ) . data == [string] [EOL] [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] self . llst . insert_last ( [string] ) [EOL] assert len ( self . llst ) == [number] [EOL] assert midpoint ( self . llst ) . data == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] class Node : [EOL] [EOL] def __init__ ( self , data , next = None ) : [EOL] self . data = data [EOL] self . next = next [EOL] [EOL] [EOL] class LinkedList : [EOL] [EOL] def __init__ ( self , head = None ) : [EOL] self . head = head [EOL] [EOL] def clear ( self ) : [EOL] self . head = None [EOL] [EOL] def size ( self ) : [EOL] counter = [number] [EOL] node = self . head [EOL] while node : [EOL] counter += [number] [EOL] node = node . next [EOL] return counter [EOL] [EOL] def get_at ( self , index ) : [EOL] if index < [number] or not self . head : [EOL] return None [EOL] counter = [number] [EOL] node = self . head [EOL] while node : [EOL] if index == counter : [EOL] return node [EOL] counter += [number] [EOL] node = node . next [EOL] return None [EOL] [EOL] def get_first ( self ) : [EOL] return self . get_at ( [number] ) [EOL] [EOL] def get_last ( self ) : [EOL] node = self . head [EOL] while node : [EOL] if node . next is None : [EOL] return node [EOL] node = node . next [EOL] return None [EOL] [EOL] def insert_at ( self , index , data ) : [EOL] if index <= [number] or self . head is None : [EOL] self . head = Node ( data , self . head ) [EOL] return [EOL] [EOL] counter = [number] [EOL] node = self . head [EOL] while node : [EOL] if counter == index - [number] : [EOL] next_node = None [EOL] if node . next : [EOL] next_node = node . next [EOL] node . next = Node ( data , next_node ) [EOL] return [EOL] elif node . next is None : [EOL] [comment] [EOL] node . next = Node ( data ) [EOL] return [EOL] counter += [number] [EOL] node = node . next [EOL] [EOL] def insert_first ( self , data ) : [EOL] self . insert_at ( [number] , data ) [EOL] [EOL] def insert_last ( self , data ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] last = self . get_last ( ) [EOL] if last : [EOL] last . next = Node ( data ) [EOL] else : [EOL] self . head = Node ( data ) [EOL] [EOL] def remove_at ( self , index ) : [EOL] if index < [number] or self . head is None : [EOL] return [EOL] elif index == [number] : [EOL] self . head = self . head . next [EOL] return [EOL] [EOL] counter = [number] [EOL] node = self . head [EOL] while node : [EOL] if counter == index - [number] : [EOL] next_node = None [EOL] if node . next : [EOL] if node . next . next : [EOL] next_node = node . next . next [EOL] [comment] [EOL] node . next = next_node [EOL] return [EOL] counter += [number] [EOL] node = node . next [EOL] [EOL] def remove_first ( self ) : [EOL] self . remove_at ( [number] ) [EOL] [EOL] def remove_last ( self ) : [EOL] node = self . head [EOL] if node is None : [EOL] return [EOL] elif node . next is None : [EOL] self . head = None [EOL] return [EOL] while node : [EOL] if node . next . next is None : [EOL] node . next = None [EOL] return [EOL] node = node . next [EOL] [EOL] def every ( self , fn ) : [EOL] [docstring] [EOL] node = self . head [EOL] while node : [EOL] fn ( node ) [EOL] node = node . next [EOL] [EOL] def __repr__ ( self ) : [EOL] head = self . head . data [EOL] size = self . size ( ) [EOL] return f' [string] { head } [string] { size } [string] ' [EOL] [EOL] def __len__ ( self ) : [EOL] return self . size ( ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] self . node = self . head [EOL] return self [EOL] [EOL] def __next__ ( self ) : [EOL] [docstring] [EOL] if self . node is None : [EOL] raise StopIteration [EOL] current = self . node [EOL] self . node = self . node . next [EOL] return current [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def get_nth_node_from_last ( llst , n ) : [EOL] [docstring] [EOL] if llst . head is None or n < [number] : [EOL] return None [EOL] elif n == [number] : [EOL] return llst . head [EOL] [EOL] slow = fast = llst . head [EOL] [EOL] for _ in range ( n ) : [EOL] fast = fast . next [EOL] [EOL] while n > [number] : [EOL] if fast . next is None : [EOL] return slow [EOL] slow = slow . next [EOL] fast = fast . next [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL] [EOL] [EOL] class Node : [EOL] [EOL] def __init__ ( self , data , left = None , right = None ) : [EOL] self . data = data [EOL] self . left = left [EOL] self . right = right [EOL] [EOL] def insert ( self , data ) : [EOL] if data == self . data : [EOL] raise NotImplemented [EOL] elif data < self . data and self . left is None : [EOL] self . left = Node ( data ) [EOL] elif data > self . data and self . right is None : [EOL] self . right = Node ( data ) [EOL] elif data < self . data : [EOL] self . left . insert ( data ) [EOL] elif data > self . data : [EOL] self . right . insert ( data ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def is_binary_search_tree ( node , min = None , max = None ) : [EOL] [docstring] [EOL] if node is None : [EOL] return False [EOL] if min is not None and node . data <= min : [EOL] return False [EOL] if max is not None and node . data >= max : [EOL] return False [EOL] if node . left is not None : [EOL] return is_binary_search_tree ( node . left , min , node . data ) [EOL] if node . right is not None : [EOL] return is_binary_search_tree ( node . right , node . data , max ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import validate [EOL] from . index import Node , is_binary_search_tree [EOL] [EOL] [EOL] class TestBinarySearchTreeValidator ( ) : [EOL] [EOL] def test_valid ( self ) : [EOL] n = Node ( [number] ) [EOL] n . insert ( [number] ) [EOL] n . insert ( [number] ) [EOL] n . insert ( [number] ) [EOL] n . insert ( [number] ) [EOL] assert is_binary_search_tree ( n ) is True [EOL] [EOL] def test_invalid ( self ) : [EOL] n = Node ( [number] ) [EOL] n . insert ( [number] ) [EOL] n . insert ( [number] ) [EOL] n . insert ( [number] ) [EOL] n . insert ( [number] ) [EOL] n . left . left . right = Node ( [number] ) [EOL] assert is_binary_search_tree ( n ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $validate.index.Node$ 0 0 0 0
	0
from . index import is_palindrome [EOL] [EOL] [EOL] def test_is_palindrome ( ) : [EOL] assert is_palindrome ( [string] ) is False [EOL] assert is_palindrome ( [string] ) is True [EOL] assert is_palindrome ( [string] ) is True [EOL] assert is_palindrome ( [string] ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def is_palindrome ( string ) : [EOL] [comment] [EOL] return all ( [ val == string [ len ( string ) - idx - [number] ] for idx , val in enumerate ( string ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Dict , Any [EOL] import typing [EOL] def memoize ( fn ) : [EOL] cache = { } [EOL] [EOL] def wrapped ( * args , ** kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] key = ( args , frozenset ( kwargs . items ( ) ) ) [EOL] if cache . get ( key ) : [EOL] return cache . get ( key ) [EOL] result = fn ( * args , ** kwargs ) [EOL] cache [ key ] = result [EOL] print ( cache ) [EOL] return result [EOL] return wrapped [EOL] [EOL] [EOL] @ memoize def fib ( n , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] if n < [number] : [EOL] return n [EOL] result = fib ( n - [number] ) + fib ( n - [number] ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . index import fib [EOL] [EOL] [EOL] def test_fib ( ) : [EOL] assert fib ( [number] , foo = [string] ) == [number] [EOL] assert fib ( [number] , foo = [string] , bar = [string] ) == [number] [EOL] assert fib ( [number] ) == [number] [EOL] assert fib ( [number] ) == [number] [EOL] assert fib ( [number] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def fizzbuzz ( n ) : [EOL] if n <= [number] : [EOL] print ( [string] ) [EOL] else : [EOL] for i in range ( [number] , n + [number] ) : [EOL] if i % [number] == [number] and i % [number] == [number] : [EOL] print ( [string] ) [EOL] elif i % [number] == [number] : [EOL] print ( [string] ) [EOL] elif i % [number] == [number] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( i ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . index import fizzbuzz [EOL] [EOL] [EOL] def test_fizzbuzz_success ( capsys ) : [EOL] fizzbuzz ( [number] ) [EOL] out , err = capsys . readouterr ( ) [EOL] s = [string] [comment] [EOL] assert out == s [EOL] [EOL] [EOL] def test_fizzbuzz_fail ( capsys ) : [EOL] error = [string] [EOL] fizzbuzz ( - [number] ) [EOL] out , err = capsys . readouterr ( ) [EOL] assert out == error [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL] [EOL] [EOL] def steps ( n ) : [EOL] if n <= [number] : [EOL] print ( [string] ) [EOL] else : [EOL] for i in range ( [number] , n + [number] ) : [EOL] print ( [string] * i + [string] * ( n - i ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0