from typing import List [EOL] import typing [EOL] import os [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] [comment] [EOL] project_dir = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] with open ( os . path . join ( project_dir , [string] ) ) as f : [EOL] install_requires = [ [string] ] + [ line . rstrip ( [string] ) for line in f if not line . startswith ( [string] ) ] [EOL] [EOL] with open ( os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , [string] ) ) as f : [EOL] version = f . read ( ) . rstrip ( ) [EOL] [EOL] setup ( name = [string] , version = version , description = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( [string] ) , package_data = { [string] : [ [string] ] , [string] : [ [string] ] } , package_dir = { [string] : [string] } , include_package_data = True , zip_safe = False , entry_points = { [string] : [ [string] ] } , license = [string] , install_requires = install_requires , classifiers = [ [string] , [string] , [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from balrogscript . submitter . release import makeCandidatesDir [EOL] [EOL] [EOL] class TestCandidatesDir ( unittest . TestCase ) : [EOL] def test_base ( self ) : [EOL] expected = [string] [EOL] got = makeCandidatesDir ( [string] , [string] , [number] ) [EOL] self . assertEqual ( expected , got ) [EOL] [EOL] def test_fennec ( self ) : [EOL] expected = [string] [EOL] got = makeCandidatesDir ( [string] , [string] , [number] ) [EOL] self . assertEqual ( expected , got ) [EOL] [EOL] def test_remote ( self ) : [EOL] expected = [string] [EOL] got = makeCandidatesDir ( [string] , [string] , [number] , protocol = [string] , server = [string] ) [EOL] self . assertEqual ( expected , got ) [EOL] [EOL] def test_ftp_root ( self ) : [EOL] expected = [string] [EOL] got = makeCandidatesDir ( [string] , [string] , [number] , ftp_root = [string] ) [EOL] self . assertEqual ( expected , got ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0
[comment] [EOL] [EOL] from typing import Union , Any , Dict , List [EOL] import mock [EOL] import typing [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] import mock [EOL] import pytest [EOL] import scriptworker_client . client [EOL] [EOL] import balrogscript . script as bscript [EOL] from balrogscript . submitter . cli import NightlySubmitterV4 , ReleaseCreatorV9 , ReleasePusher , ReleaseScheduler , ReleaseStateUpdater , ReleaseSubmitterV9 [EOL] from balrogscript . task import get_task_server , validate_task_schema [EOL] [EOL] logging . basicConfig ( ) [EOL] [EOL] BASE_DIR = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] [comment] [EOL] def test_create_locale_submitter_nightly_style ( config , nightly_manifest ) : [EOL] auth0_secrets = None [EOL] submitter , release = bscript . create_locale_submitter ( nightly_manifest [ [number] ] , [string] , auth0_secrets , config ) [EOL] assert isinstance ( submitter , NightlySubmitterV4 ) [EOL] [EOL] nightly_manifest [ [number] ] . pop ( [string] , None ) [EOL] submitter , release = bscript . create_locale_submitter ( nightly_manifest [ [number] ] , [string] , auth0_secrets , config ) [EOL] assert isinstance ( submitter , NightlySubmitterV4 ) [EOL] [EOL] [EOL] def test_create_locale_submitter_release_style ( config , release_manifest ) : [EOL] auth0_secrets = None [EOL] [EOL] submitter , release = bscript . create_locale_submitter ( release_manifest [ [number] ] , [string] , auth0_secrets , config ) [EOL] assert isinstance ( submitter , ReleaseSubmitterV9 ) [EOL] [EOL] release_manifest [ [number] ] . pop ( [string] , None ) [EOL] submitter , release = bscript . create_locale_submitter ( release_manifest [ [number] ] , [string] , auth0_secrets , config ) [EOL] assert isinstance ( submitter , ReleaseSubmitterV9 ) [EOL] [EOL] release_manifest [ [number] ] . pop ( [string] , None ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] submitter , release = bscript . create_locale_submitter ( release_manifest [ [number] ] , [string] , auth0_secrets , config ) [EOL] [EOL] [EOL] def test_create_locale_submitter_nightly_metadata ( config , nightly_manifest ) : [EOL] auth0_secrets = None [EOL] submitter , release = bscript . create_locale_submitter ( nightly_manifest [ [number] ] , [string] , auth0_secrets , config ) [EOL] [EOL] exp = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , } ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , } ] , } [EOL] assert exp == release [EOL] [EOL] [EOL] def test_create_locale_submitter_nightly_creates_valid_submitter ( config , nightly_manifest ) : [EOL] auth0_secrets = None [EOL] submitter , release = bscript . create_locale_submitter ( nightly_manifest [ [number] ] , [string] , auth0_secrets , config ) [EOL] lambda : submitter . run ( ** release ) [EOL] [EOL] [EOL] [comment] [EOL] def test_submit_locale ( config , nightly_task , nightly_config , nightly_manifest , mocker ) : [EOL] auth0_secrets = None [EOL] _ , release = bscript . create_locale_submitter ( nightly_manifest [ [number] ] , [string] , auth0_secrets , config ) [EOL] [EOL] def fake_submitter ( ** kwargs ) : [EOL] assert kwargs == release [EOL] [EOL] task = nightly_task [EOL] m = mock . MagicMock ( ) [EOL] m . run = fake_submitter [EOL] mocker . patch . object ( bscript , [string] , return_value = ( m , release ) ) [EOL] bscript . submit_locale ( task , config , auth0_secrets ) [EOL] [EOL] [EOL] [comment] [EOL] def test_create_scheduler ( config ) : [EOL] assert isinstance ( bscript . create_scheduler ( api_root = config [ [string] ] , auth0_secrets = None ) , ReleaseScheduler ) [EOL] [EOL] [EOL] def test_schedule ( config , mocker ) : [EOL] auth0_secrets = None [EOL] [EOL] task = { [string] : { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [number] , [number] ] , [string] : None , [string] : False , [string] : None , } } [EOL] expected = [ [string] , [string] , [number] , [ [number] , [number] ] , False , None , None ] [EOL] real = [ ] [EOL] [EOL] def fake_scheduler ( * args ) : [EOL] [comment] [EOL] real . extend ( args ) [EOL] [EOL] def fake_retry ( c ) : [EOL] return c ( ) [EOL] [EOL] m = mock . MagicMock ( ) [EOL] m . run = fake_scheduler [EOL] mocker . patch . object ( bscript , [string] , return_value = m ) [EOL] [EOL] bscript . schedule ( task , config , auth0_secrets ) [EOL] assert real == expected [EOL] [EOL] [EOL] [comment] [EOL] def test_create_creator ( config ) : [EOL] assert isinstance ( bscript . create_creator ( api_root = config [ [string] ] , auth0_secrets = None ) , ReleaseCreatorV9 ) [EOL] [EOL] [EOL] def test_create_pusher ( config ) : [EOL] assert isinstance ( bscript . create_pusher ( api_root = config [ [string] ] , auth0_secrets = None ) , ReleasePusher ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : False , [string] : [ [number] ] , } } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : { } , [string] : False , [string] : None , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [number] ] } , ) , ( { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : True , [string] : [ [number] ] , } } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : True , [string] : None , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [number] ] } , ) , ( { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : True , [string] : [ [number] ] , [string] : { [string] : { [string] : { } , [string] : { [string] : [string] , [string] : [string] } } } , } } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : True , [string] : { [string] : { } , [string] : { [string] : [string] , [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ [number] ] } , ) , ) , ) def test_submit_toplevel ( task , creator_expected , pusher_expected , nightly_config , mocker ) : [EOL] auth0_secrets = None [EOL] results = [ ] [EOL] [EOL] def fake ( ** kwargs ) : [EOL] results . append ( kwargs ) [EOL] [EOL] m = mock . MagicMock ( ) [EOL] m . run = fake [EOL] [EOL] mocker . patch . object ( bscript , [string] , return_value = m ) [EOL] mocker . patch . object ( bscript , [string] , return_value = m ) [EOL] bscript . submit_toplevel ( task , nightly_config , auth0_secrets ) [EOL] assert results [ [number] ] == creator_expected [EOL] assert results [ [number] ] == pusher_expected [EOL] [EOL] [EOL] [comment] [EOL] def test_validate_task_schema ( config ) : [EOL] test_taskdef = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } ] } } [EOL] validate_task_schema ( config , test_taskdef , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : [ [string] ] , [string] : { [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } ] } } , { [string] : [ [string] ] , [string] : { [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } ] } } , { [string] : [ [string] ] , [string] : [ [string] ] , [string] : { } } , ) , ) def test_verify_task_schema_missing_cert ( config , defn ) : [EOL] with pytest . raises ( SystemExit ) : [EOL] validate_task_schema ( config , defn , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : [ [string] ] , [string] : { [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } ] } , [string] : [ [string] ] , } , { [string] : [ [string] ] , [string] : { [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } ] } , [string] : [ [string] ] , } , { [string] : [ [string] ] , [string] : { [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } ] } , [string] : [ [string] , [string] ] , } , { [string] : [ [string] ] , [string] : { [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } ] } , [string] : [ [string] ] , } , ) , ) def test_get_task_server ( config , defn ) : [EOL] with pytest . raises ( ValueError ) : [EOL] get_task_server ( defn , config ) [EOL] [EOL] [EOL] [comment] [EOL] def test_load_config ( ) : [EOL] config_path = os . path . join ( BASE_DIR , [string] ) [EOL] assert bscript . load_config ( config_path ) [ [string] ] [EOL] with pytest . raises ( SystemExit ) : [EOL] bscript . load_config ( os . path . join ( BASE_DIR , [string] ) ) [EOL] [EOL] [EOL] def test_create_state_updater ( config ) : [EOL] assert isinstance ( bscript . create_state_updater ( api_root = config [ [string] ] ) , ReleaseStateUpdater ) [EOL] [EOL] [EOL] def test_set_readonly ( config , mocker ) : [EOL] task = { [string] : { [string] : [string] , [string] : [string] , [string] : [number] } } [EOL] [EOL] expected = [ [string] , [string] , [number] ] [EOL] real = [ ] [EOL] [EOL] def fake_run ( * args ) : [EOL] real . extend ( args ) [EOL] [EOL] m = mock . MagicMock ( ) [EOL] m . run = fake_run [EOL] mocker . patch . object ( bscript , [string] , return_value = m ) [EOL] [EOL] bscript . set_readonly ( task , config , None ) [EOL] assert real == expected [EOL] [EOL] [EOL] [comment] [EOL] def test_invalid_args ( ) : [EOL] args = [ [string] ] [EOL] with mock . patch . object ( sys , [string] , args ) : [EOL] with pytest . raises ( SystemExit ) as e : [EOL] scriptworker_client . client . init_config ( None ) [EOL] assert e . type == SystemExit [EOL] assert e . value . code == [number] [EOL] [EOL] args = [ [string] , [string] ] [EOL] with mock . patch . object ( sys , [string] , args ) : [EOL] config = scriptworker_client . client . init_config ( None ) [EOL] assert config [ [string] ] == [string] [EOL] [EOL] [EOL] def test_get_default_config ( ) : [EOL] c = bscript . get_default_config ( ) [EOL] assert [string] in c [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] ) ) async def test_async_main_submit_locale ( behavior , nightly_task , nightly_config , mocker ) : [EOL] mocker . patch . object ( bscript , [string] ) [EOL] mocker . patch . object ( bscript , [string] , return_value = behavior ) [EOL] mocker . patch . object ( bscript , [string] ) [EOL] mocker . patch . object ( bscript , [string] ) [EOL] mocker . patch . object ( bscript , [string] ) [EOL] mocker . patch . object ( bscript , [string] ) [EOL] [EOL] await bscript . async_main ( nightly_config , nightly_task ) [EOL] [EOL] [EOL] def test_main ( monkeypatch , mocker ) : [EOL] sync_main_mock = mocker . MagicMock ( ) [EOL] monkeypatch . setattr ( scriptworker_client . client , [string] , sync_main_mock ) [EOL] bscript . main ( ) [EOL] sync_main_mock . asset_called_once_with ( bscript . async_main , default_config = bscript . get_default_config ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import json [EOL] import os [EOL] import shutil [EOL] import tempfile [EOL] [EOL] import pytest [EOL] from immutabledict import immutabledict [EOL] [EOL] [comment] [EOL] NIGHTLY_MANIFEST_PATH = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] NIGHTLY_TASK_PATH = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] RELEASE_MANIFEST_PATH = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] RELEASE_TASK_PATH = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def nightly_manifest ( ) : [EOL] with open ( NIGHTLY_MANIFEST_PATH , [string] ) as fh : [EOL] return json . load ( fh ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def release_manifest ( ) : [EOL] with open ( RELEASE_MANIFEST_PATH , [string] ) as fh : [EOL] return json . load ( fh ) [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def config ( ) : [EOL] tmpdir = tempfile . mkdtemp ( ) [EOL] try : [EOL] yield immutabledict ( { [string] : os . path . join ( tmpdir , [string] ) , [string] : os . path . join ( tmpdir , [string] ) , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : False , [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] ] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] ] , } , } , [string] : False , [string] : True , } ) [EOL] finally : [EOL] shutil . rmtree ( tmpdir ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def nightly_task ( config ) : [EOL] with open ( NIGHTLY_TASK_PATH , [string] ) as fh : [EOL] return json . load ( fh ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def release_task ( config ) : [EOL] with open ( RELEASE_TASK_PATH , [string] ) as fh : [EOL] return json . load ( fh ) [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def nightly_config ( config ) : [EOL] os . makedirs ( os . path . join ( config [ [string] ] , [string] , [string] , [string] ) ) [EOL] shutil . copyfile ( NIGHTLY_MANIFEST_PATH , os . path . join ( config [ [string] ] , [string] , [string] , [string] , [string] ) ) [EOL] yield config [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def release_config ( config ) : [EOL] os . makedirs ( os . path . join ( config [ [string] ] , [string] , [string] , [string] ) ) [EOL] shutil . copyfile ( RELEASE_MANIFEST_PATH , os . path . join ( config [ [string] ] , [string] , [string] , [string] , [string] ) ) [EOL] yield config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from balrogscript . task import get_manifest , get_task_behavior , get_task_server , get_upstream_artifacts [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] ] , None , True ) , ( [ [string] ] , None , True ) , ( [ [string] , [string] ] , None , True ) , ( [ [string] , [string] ] , [string] , False ) , ) , ) def test_get_task_server ( nightly_task , nightly_config , scopes , expected , raises ) : [EOL] task = nightly_task [EOL] task [ [string] ] = scopes [EOL] [EOL] if raises : [EOL] with pytest . raises ( ValueError ) : [EOL] get_task_server ( task , nightly_config ) [EOL] else : [EOL] assert expected == get_task_server ( task , nightly_config ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [ [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } ] ] ) ) def test_get_upstream_artifacts ( nightly_task , nightly_config , expected ) : [EOL] assert get_upstream_artifacts ( nightly_task ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [ [ { [string] : True , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , } ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , } ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] ] ) , ) def test_nightly_get_manifest ( nightly_task , nightly_config , expected_manifest ) : [EOL] upstream_artifacts = get_upstream_artifacts ( nightly_task ) [EOL] [EOL] manifest = get_manifest ( nightly_config , upstream_artifacts ) [EOL] assert manifest == expected_manifest [EOL] [EOL] [EOL] def test_release_get_manifest ( release_task , release_config ) : [EOL] upstream_artifacts = get_upstream_artifacts ( release_task ) [EOL] [EOL] [comment] [EOL] upstream_artifacts [ [number] ] [ [string] ] [ [number] ] += [string] [EOL] with pytest . raises ( SystemExit ) as e : [EOL] get_manifest ( release_config , upstream_artifacts ) [EOL] assert e . type == SystemExit [EOL] assert e . value . code == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] ] } , [string] , False ) , ( { [string] : [ [string] ] } , [string] , False ) , ( { [string] : [ [string] ] } , [string] , False ) , ( { [string] : { [string] : [string] } , [string] : [ ] } , [string] , False ) , ( { [string] : { [string] : [string] } , [string] : [ [string] ] } , None , True ) , ( { [string] : [ [string] , [string] ] } , None , True ) , ( { [string] : [ [string] ] } , None , True ) , ( { [string] : [ ] } , [string] , False ) , ) , ) def test_get_task_behavior ( task , expected , raises ) : [EOL] if raises : [EOL] with pytest . raises ( ValueError ) : [EOL] get_task_behavior ( task , { [string] : [string] } ) [EOL] else : [EOL] assert get_task_behavior ( task , { [string] : [string] } ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import typing [EOL] import logging [EOL] import json [EOL] import logging [EOL] import os [EOL] import re [EOL] import sys [EOL] [EOL] import jsonschema [EOL] [EOL] from balrogscript . constants import VALID_ACTIONS [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def validate_task_schema ( script_config , task_definition , action ) : [EOL] [docstring] [EOL] schema_path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) , script_config [ [string] ] [ action ] ) [EOL] with open ( schema_path ) as fh : [EOL] schema = json . load ( fh ) [EOL] [EOL] try : [EOL] jsonschema . validate ( task_definition , schema ) [EOL] except jsonschema . exceptions . ValidationError as exc : [EOL] log . critical ( [string] . format ( exc ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def get_task_behavior ( task , script_config ) : [EOL] [docstring] [EOL] behavior = task . get ( [string] , { } ) . get ( [string] ) [EOL] [comment] [EOL] behaviors = { s . split ( [string] ) [ - [number] ] for s in task [ [string] ] if s . startswith ( script_config [ [string] ] + [string] ) } [EOL] if behavior : [EOL] behaviors . add ( behavior ) [EOL] if behaviors : [EOL] log . info ( [string] , behaviors ) [EOL] if len ( behaviors ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] behavior = behaviors . pop ( ) [EOL] else : [EOL] behavior = [string] [EOL] [EOL] if behavior not in VALID_ACTIONS : [EOL] raise ValueError ( [string] ) [EOL] [EOL] return behavior [EOL] [EOL] [EOL] def get_task_server ( task , script_config ) : [EOL] [docstring] [EOL] servers = [ s . split ( [string] ) [ - [number] ] for s in task [ [string] ] if s . startswith ( script_config [ [string] ] + [string] ) ] [EOL] log . info ( [string] , servers ) [EOL] if len ( servers ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] server = servers [ [number] ] [EOL] if re . search ( [string] , server ) is None : [EOL] raise ValueError ( [string] . format ( server ) ) [EOL] [EOL] if server not in script_config [ [string] ] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] return server [EOL] [EOL] [EOL] def get_manifest ( script_config , upstream_artifacts ) : [EOL] [comment] [EOL] task_id = upstream_artifacts [ [number] ] [ [string] ] [EOL] [comment] [EOL] path = os . path . join ( script_config [ [string] ] , [string] , task_id , upstream_artifacts [ [number] ] [ [string] ] [ [number] ] ) [EOL] log . info ( [string] % path ) [EOL] try : [EOL] with open ( path , [string] ) as fh : [EOL] manifest = json . load ( fh ) [EOL] except ( ValueError , OSError , IOError ) as e : [EOL] log . critical ( [string] . format ( path , e ) ) [EOL] sys . exit ( [number] ) [EOL] return manifest [EOL] [EOL] [EOL] def get_upstream_artifacts ( task ) : [EOL] [docstring] [EOL] return task [ [string] ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import balrogscript [EOL] [docstring] [EOL] import json [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] import scriptworker_client . client [EOL] from immutabledict import immutabledict [EOL] from redo import retry [comment] [EOL] [EOL] from . submitter . cli import NightlySubmitterV4 , ReleaseCreatorV9 , ReleasePusher , ReleaseScheduler , ReleaseStateUpdater , ReleaseSubmitterV9 [EOL] from . task import get_manifest , get_task_behavior , get_task_server , get_upstream_artifacts , validate_task_schema [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] def create_locale_submitter ( e , extra_suffix , auth0_secrets , config ) : [EOL] if [string] in e : [EOL] log . info ( [string] ) [EOL] [EOL] submitter = ReleaseSubmitterV9 ( api_root = config [ [string] ] , auth0_secrets = auth0_secrets , dummy = config [ [string] ] , suffix = e . get ( [string] , [string] ) + extra_suffix ) [EOL] [EOL] data = { [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , } [EOL] if [string] in e : [EOL] data [ [string] ] = e [ [string] ] [EOL] return submitter , data [EOL] [EOL] elif [string] in e : [EOL] log . info ( [string] ) [EOL] [EOL] submitter = NightlySubmitterV4 ( api_root = config [ [string] ] , auth0_secrets = auth0_secrets , dummy = config [ [string] ] , url_replacements = e . get ( [string] , [ ] ) ) [EOL] [EOL] data = { [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , [string] : e [ [string] ] , } [EOL] if [string] in e : [EOL] data [ [string] ] = e [ [string] ] [EOL] return submitter , data [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] def submit_locale ( task , config , auth0_secrets ) : [EOL] [docstring] [EOL] upstream_artifacts = get_upstream_artifacts ( task ) [EOL] [EOL] [comment] [EOL] manifest = get_manifest ( config , upstream_artifacts ) [EOL] [EOL] suffixes = task [ [string] ] . get ( [string] , [ [string] ] ) [EOL] [EOL] for e in manifest : [EOL] for suffix in suffixes : [EOL] [comment] [EOL] submitter , release = create_locale_submitter ( e , suffix , auth0_secrets , config ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] retry ( lambda : submitter . run ( ** release ) , jitter = [number] , sleeptime = [number] , max_sleeptime = [number] , attempts = [number] ) [EOL] [EOL] [EOL] [comment] [EOL] def create_scheduler ( ** kwargs ) : [EOL] return ReleaseScheduler ( ** kwargs ) [EOL] [EOL] [EOL] def schedule ( task , config , auth0_secrets ) : [EOL] [docstring] [EOL] scheduler = create_scheduler ( api_root = config [ [string] ] , auth0_secrets = auth0_secrets , dummy = config [ [string] ] , suffix = task [ [string] ] . get ( [string] , [string] ) ) [EOL] args = [ task [ [string] ] [ [string] ] . capitalize ( ) , task [ [string] ] [ [string] ] , task [ [string] ] [ [string] ] , task [ [string] ] [ [string] ] , task [ [string] ] . get ( [string] , False ) , task [ [string] ] [ [string] ] or None , task [ [string] ] . get ( [string] ) , ] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] retry ( lambda : scheduler . run ( * args ) ) [EOL] [EOL] [EOL] [comment] [EOL] def create_creator ( ** kwargs ) : [EOL] return ReleaseCreatorV9 ( ** kwargs ) [EOL] [EOL] [EOL] def create_pusher ( ** kwargs ) : [EOL] return ReleasePusher ( ** kwargs ) [EOL] [EOL] [EOL] def submit_toplevel ( task , config , auth0_secrets ) : [EOL] [docstring] [EOL] partials = { } [EOL] if task [ [string] ] . get ( [string] ) : [EOL] for v in task [ [string] ] [ [string] ] . split ( [string] ) : [EOL] v = v . strip ( ) [comment] [EOL] version , build_number = v . split ( [string] ) [EOL] partials [ version ] = { [string] : build_number } [EOL] [EOL] suffixes = list ( task [ [string] ] . get ( [string] , { } ) . keys ( ) ) or [ [string] ] [EOL] [EOL] for suffix in suffixes : [EOL] creator = create_creator ( api_root = config [ [string] ] , auth0_secrets = auth0_secrets , dummy = config [ [string] ] , suffix = task [ [string] ] . get ( [string] , [string] ) + suffix , complete_mar_filename_pattern = task [ [string] ] . get ( [string] ) , complete_mar_bouncer_product_pattern = task [ [string] ] . get ( [string] ) , ) [EOL] [EOL] retry ( lambda : creator . run ( appVersion = task [ [string] ] [ [string] ] , productName = task [ [string] ] [ [string] ] . capitalize ( ) , version = task [ [string] ] [ [string] ] , buildNumber = task [ [string] ] [ [string] ] , updateChannels = task [ [string] ] [ [string] ] , ftpServer = task [ [string] ] [ [string] ] , bouncerServer = task [ [string] ] [ [string] ] , enUSPlatforms = task [ [string] ] [ [string] ] , hashFunction = [string] , partialUpdates = partials , requiresMirrors = task [ [string] ] [ [string] ] , updateLine = task [ [string] ] . get ( [string] , { } ) . get ( suffix ) , ) ) [EOL] [EOL] pusher = create_pusher ( api_root = config [ [string] ] , auth0_secrets = auth0_secrets , dummy = config [ [string] ] , suffix = task [ [string] ] . get ( [string] , [string] ) ) [EOL] retry ( lambda : pusher . run ( productName = task [ [string] ] [ [string] ] . capitalize ( ) , version = task [ [string] ] [ [string] ] , build_number = task [ [string] ] [ [string] ] , rule_ids = task [ [string] ] [ [string] ] , ) ) [EOL] [EOL] [EOL] [comment] [EOL] def create_state_updater ( ** kwargs ) : [EOL] return ReleaseStateUpdater ( ** kwargs ) [EOL] [EOL] [EOL] def set_readonly ( task , config , auth0_secrets ) : [EOL] state_updater = create_state_updater ( api_root = config [ [string] ] , auth0_secrets = auth0_secrets ) [EOL] args = [ task [ [string] ] [ [string] ] . capitalize ( ) , task [ [string] ] [ [string] ] , task [ [string] ] [ [string] ] ] [EOL] retry ( lambda : state_updater . run ( * args ) ) [EOL] [EOL] [EOL] [comment] [EOL] def update_config ( config , server = [string] ) : [EOL] config = dict ( config ) [EOL] [EOL] config [ [string] ] = config [ [string] ] [ server ] [ [string] ] [EOL] auth0_secrets = dict ( domain = config [ [string] ] [ server ] [ [string] ] , client_id = config [ [string] ] [ server ] [ [string] ] , client_secret = config [ [string] ] [ server ] [ [string] ] , audience = config [ [string] ] [ server ] [ [string] ] , ) [EOL] del config [ [string] ] [EOL] return auth0_secrets , immutabledict ( config ) [EOL] [EOL] [EOL] [comment] [EOL] def load_config ( path = None ) : [EOL] try : [EOL] with open ( path ) as fh : [EOL] config = json . load ( fh ) [EOL] except ( ValueError , OSError , IOError ) : [EOL] log . fatal ( [string] , path ) [EOL] sys . exit ( [number] ) [EOL] return config [EOL] [EOL] [EOL] [comment] [EOL] def get_default_config ( ) : [EOL] [docstring] [EOL] data_dir = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] default_config = { [string] : { [string] : os . path . join ( data_dir , [string] ) , [string] : os . path . join ( data_dir , [string] ) , [string] : os . path . join ( data_dir , [string] ) , [string] : os . path . join ( data_dir , [string] ) , } } [EOL] return default_config [EOL] [EOL] [EOL] [comment] [EOL] async def async_main ( config , task ) : [EOL] behavior = get_task_behavior ( task , config ) [EOL] validate_task_schema ( config , task , behavior ) [EOL] [EOL] server = get_task_server ( task , config ) [EOL] auth0_secrets , config = update_config ( config , server ) [EOL] [EOL] if behavior == [string] : [EOL] submit_toplevel ( task , config , auth0_secrets ) [EOL] elif behavior == [string] : [EOL] schedule ( task , config , auth0_secrets ) [EOL] elif behavior == [string] : [EOL] set_readonly ( task , config , auth0_secrets ) [EOL] else : [EOL] submit_locale ( task , config , auth0_secrets ) [EOL] [EOL] [EOL] def main ( ) : [EOL] return scriptworker_client . client . sync_main ( async_main , default_config = get_default_config ( ) , should_verify_task = False ) [EOL] [EOL] [EOL] __name__ == [string] and main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] VALID_ACTIONS = ( [string] , [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import collections [EOL] [EOL] [EOL] [comment] [EOL] def recursive_update ( d , u ) : [EOL] for k , v in u . items ( ) : [EOL] if isinstance ( v , collections . Mapping ) : [EOL] r = recursive_update ( d . get ( k , { } ) , v ) [EOL] d [ k ] = r [EOL] else : [EOL] d [ k ] = u [ k ] [EOL] return d [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict , List [EOL] import typing [EOL] import re [EOL] from urllib . parse import urlunsplit [EOL] [EOL] [EOL] def getProductDetails ( product , appVersion ) : [EOL] return [string] % ( product , appVersion ) [EOL] [EOL] [EOL] def getPrettyVersion ( version ) : [EOL] version = re . sub ( [string] , [string] , version ) [EOL] version = re . sub ( [string] , [string] , version ) [EOL] version = re . sub ( [string] , [string] , version ) [EOL] return version [EOL] [EOL] [EOL] product_ftp_map = { [string] : [string] } [EOL] [EOL] [EOL] def product2ftp ( product ) : [EOL] return product_ftp_map . get ( product , product ) [EOL] [EOL] [EOL] def makeCandidatesDir ( product , version , buildNumber , nightlyDir = [string] , protocol = None , server = None , ftp_root = [string] ) : [EOL] if protocol : [EOL] assert server is not None , [string] [EOL] [EOL] product = product2ftp ( product ) [EOL] directory = ftp_root + product + [string] + nightlyDir + [string] + str ( version ) + [string] + str ( buildNumber ) + [string] [EOL] [EOL] if protocol : [EOL] return urlunsplit ( ( protocol , server , directory , None , None ) ) [EOL] else : [EOL] return directory [EOL] [EOL] [EOL] bouncer_platform_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [comment] [EOL] ftp_platform_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [comment] [EOL] update_platform_map = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] , [string] , [string] , ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def buildbot2bouncer ( platform ) : [EOL] return bouncer_platform_map . get ( platform , platform ) [EOL] [EOL] [EOL] def buildbot2ftp ( platform ) : [EOL] return ftp_platform_map . get ( platform , platform ) [EOL] [EOL] [EOL] def buildbot2updatePlatforms ( platform ) : [EOL] return update_platform_map . get ( platform , [ platform ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import json [EOL] import logging [EOL] [EOL] import arrow [EOL] from balrogclient import Release , ReleaseState , Rule , ScheduledRuleChange , SingleLocale [EOL] from redo import retry [EOL] from requests . exceptions import HTTPError [EOL] [EOL] from . release import buildbot2bouncer , buildbot2ftp , buildbot2updatePlatforms , getPrettyVersion , getProductDetails , makeCandidatesDir [EOL] from . util import recursive_update [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_nightly_blob_name ( productName , branch , build_type , suffix , dummy = False ) : [EOL] if dummy : [EOL] branch = [string] % branch [EOL] return [string] % ( productName , branch , build_type , suffix ) [EOL] [EOL] [EOL] def get_release_blob_name ( productName , version , build_number , suffix = None ) : [EOL] if suffix is None : [EOL] suffix = [string] [EOL] return [string] % ( productName , version , build_number , suffix ) [EOL] [EOL] [EOL] class ReleaseCreatorFileUrlsMixin ( object ) : [EOL] def _getFileUrls ( self , productName , version , buildNumber , updateChannels , ftpServer , bouncerServer , partialUpdates , requiresMirrors = True ) : [EOL] data = { [string] : { } } [EOL] file_prefix = productName . lower ( ) [EOL] if file_prefix == [string] : [EOL] file_prefix = [string] [EOL] [comment] [EOL] protocol = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] uniqueChannels = [ [string] ] [EOL] for c in updateChannels : [EOL] [comment] [EOL] [comment] [EOL] if [string] in c : [EOL] uniqueChannels . append ( c ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not requiresMirrors and c in ( [string] , [string] ) : [EOL] uniqueChannels . append ( c ) [EOL] [EOL] for channel in uniqueChannels : [EOL] data [ [string] ] [ channel ] = { [string] : { } } [EOL] if [string] in channel : [EOL] dir_ = makeCandidatesDir ( productName . lower ( ) , version , buildNumber , server = ftpServer , protocol = protocol ) [EOL] filename = self . complete_mar_filename_pattern % ( file_prefix , version ) [EOL] data [ [string] ] [ channel ] [ [string] ] [ [string] ] = [string] % ( dir_ , filename ) [EOL] else : [EOL] [comment] [EOL] if not requiresMirrors and channel in ( [string] , [string] ) : [EOL] bouncerProduct = [string] % ( productName . lower ( ) , version , buildNumber ) [EOL] else : [EOL] if productName . lower ( ) == [string] : [EOL] bouncerProduct = [string] % ( productName . lower ( ) , version ) [EOL] else : [EOL] bouncerProduct = self . complete_mar_bouncer_product_pattern % ( productName . lower ( ) , version ) [EOL] url = [string] % ( protocol , bouncerServer , bouncerProduct ) [EOL] data [ [string] ] [ channel ] [ [string] ] [ [string] ] = url [EOL] [EOL] if not partialUpdates : [EOL] return data [EOL] [EOL] for channel in uniqueChannels : [EOL] data [ [string] ] [ channel ] [ [string] ] = { } [EOL] for previousVersion , previousInfo in partialUpdates . items ( ) : [EOL] from_ = get_release_blob_name ( productName , previousVersion , previousInfo [ [string] ] , self . from_suffix ) [EOL] if [string] in channel : [EOL] dir_ = makeCandidatesDir ( productName . lower ( ) , version , buildNumber , server = ftpServer , protocol = protocol ) [EOL] filename = [string] % ( file_prefix , previousVersion , version ) [EOL] data [ [string] ] [ channel ] [ [string] ] [ from_ ] = [string] % ( dir_ , filename ) [EOL] else : [EOL] [comment] [EOL] if not requiresMirrors and channel in ( [string] , [string] ) : [EOL] bouncerProduct = [string] % ( productName . lower ( ) , version , buildNumber , previousVersion , previousInfo [ [string] ] , ) [EOL] else : [EOL] bouncerProduct = [string] % ( productName . lower ( ) , version , previousVersion ) [EOL] url = [string] % ( protocol , bouncerServer , bouncerProduct ) [EOL] data [ [string] ] [ channel ] [ [string] ] [ from_ ] = url [EOL] [EOL] return data [EOL] [EOL] [EOL] class ReleaseCreatorV9 ( ReleaseCreatorFileUrlsMixin ) : [EOL] schemaVersion = [number] [EOL] [EOL] def __init__ ( self , api_root , auth0_secrets = None , dummy = False , suffix = [string] , from_suffix = [string] , complete_mar_filename_pattern = None , complete_mar_bouncer_product_pattern = None , ) : [EOL] self . api_root = api_root [EOL] self . auth0_secrets = auth0_secrets [EOL] self . suffix = suffix [EOL] self . from_suffix = from_suffix [EOL] if dummy : [EOL] self . suffix += [string] [EOL] self . complete_mar_filename_pattern = complete_mar_filename_pattern or [string] [EOL] self . complete_mar_bouncer_product_pattern = complete_mar_bouncer_product_pattern or [string] [EOL] [EOL] def generate_data ( self , appVersion , productName , version , buildNumber , updateChannels , ftpServer , bouncerServer , enUSPlatforms , updateLine , ** updateKwargs ) : [EOL] details_product = productName . lower ( ) [EOL] if details_product == [string] : [EOL] details_product = [string] [EOL] if updateLine is None : [EOL] updateLine = [ { [string] : { } , [string] : { [string] : getProductDetails ( details_product , appVersion ) , [string] : [string] } } ] [EOL] [EOL] data = { [string] : { } , [string] : { } , [string] : appVersion , [string] : getPrettyVersion ( version ) , [string] : updateLine } [EOL] [EOL] fileUrls = self . _getFileUrls ( productName , version , buildNumber , updateChannels , ftpServer , bouncerServer , ** updateKwargs ) [EOL] if fileUrls : [EOL] data . update ( fileUrls ) [EOL] [EOL] for platform in enUSPlatforms : [EOL] updatePlatforms = buildbot2updatePlatforms ( platform ) [EOL] bouncerPlatform = buildbot2bouncer ( platform ) [EOL] ftpPlatform = buildbot2ftp ( platform ) [EOL] data [ [string] ] [ updatePlatforms [ [number] ] ] = { [string] : bouncerPlatform , [string] : ftpPlatform } [EOL] for aliasedPlatform in updatePlatforms [ [number] : ] : [EOL] data [ [string] ] [ aliasedPlatform ] = { [string] : updatePlatforms [ [number] ] } [EOL] [EOL] return data [EOL] [EOL] def run ( self , appVersion , productName , version , buildNumber , updateChannels , ftpServer , bouncerServer , enUSPlatforms , hashFunction , updateLine , ** updateKwargs ) : [EOL] data = self . generate_data ( appVersion , productName , version , buildNumber , updateChannels , ftpServer , bouncerServer , enUSPlatforms , updateLine , ** updateKwargs ) [EOL] name = get_release_blob_name ( productName , version , buildNumber , self . suffix ) [EOL] api = Release ( name = name , auth0_secrets = self . auth0_secrets , api_root = self . api_root ) [EOL] try : [EOL] current_data , data_version = api . get_data ( ) [EOL] except HTTPError as e : [EOL] if e . response . status_code == [number] : [EOL] log . warning ( [string] ) [EOL] current_data , data_version = { } , None [EOL] else : [EOL] raise [EOL] [EOL] data = recursive_update ( current_data , data ) [EOL] api . update_release ( product = productName , hashFunction = hashFunction , releaseData = json . dumps ( data ) , schemaVersion = self . schemaVersion , data_version = data_version ) [EOL] [EOL] [EOL] class NightlySubmitterBase ( object ) : [EOL] build_type = [string] [EOL] [EOL] def __init__ ( self , api_root , auth0_secrets = None , dummy = False , url_replacements = None ) : [EOL] self . api_root = api_root [EOL] self . auth0_secrets = auth0_secrets [EOL] self . dummy = dummy [EOL] self . url_replacements = url_replacements [EOL] [EOL] def _replace_canocical_url ( self , url ) : [EOL] if self . url_replacements : [EOL] for string_from , string_to in self . url_replacements : [EOL] if string_from in url : [EOL] new_url = url . replace ( string_from , string_to ) [EOL] log . warning ( [string] , url , new_url ) [EOL] return new_url [EOL] [EOL] return url [EOL] [EOL] def run ( self , platform , buildID , productName , branch , appVersion , locale , hashFunction , extVersion , schemaVersion , isOSUpdate = None , ** updateKwargs ) : [EOL] assert schemaVersion in ( [number] , [number] ) , [string] % schemaVersion [EOL] targets = buildbot2updatePlatforms ( platform ) [EOL] build_target = targets [ [number] ] [EOL] alias = None [EOL] if len ( targets ) > [number] : [EOL] alias = targets [ [number] : ] [EOL] data = { [string] : buildID , [string] : appVersion , [string] : extVersion , [string] : appVersion } [EOL] if isOSUpdate : [EOL] data [ [string] ] = isOSUpdate [EOL] [EOL] data . update ( self . _get_update_data ( productName , branch , ** updateKwargs ) ) [EOL] [EOL] if [string] in platform : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] build_type = [string] % self . build_type [EOL] else : [EOL] build_type = self . build_type [EOL] [EOL] name = get_nightly_blob_name ( productName , branch , build_type , buildID , self . dummy ) [EOL] api = SingleLocale ( name = name , build_target = build_target , locale = locale , auth0_secrets = self . auth0_secrets , api_root = self . api_root ) [EOL] [EOL] [comment] [EOL] def update_dated ( ) : [EOL] current_data , data_version = api . get_data ( ) [EOL] [comment] [EOL] [comment] [EOL] skip_submission = bool ( current_data [EOL] and current_data . get ( [string] ) == data . get ( [string] ) [EOL] and all ( p in current_data . get ( [string] , [ ] ) for p in data . get ( [string] , [ ] ) ) ) [EOL] if skip_submission : [EOL] log . warning ( [string] ) [EOL] return [EOL] [comment] [EOL] api . update_build ( product = productName , hashFunction = hashFunction , buildData = json . dumps ( data ) , alias = json . dumps ( alias ) , schemaVersion = schemaVersion , data_version = data_version , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] retry ( update_dated , sleeptime = [number] , max_sleeptime = [number] , attempts = [number] ) [EOL] [EOL] latest = SingleLocale ( api_root = self . api_root , auth0_secrets = self . auth0_secrets , name = get_nightly_blob_name ( productName , branch , build_type , [string] , self . dummy ) , build_target = build_target , locale = locale , ) [EOL] [EOL] def update_latest ( ) : [EOL] [comment] [EOL] latest_data , latest_data_version = latest . get_data ( ) [EOL] source_data , _ = api . get_data ( ) [EOL] if source_data == latest_data : [EOL] log . warning ( [string] ) [EOL] return [EOL] log . debug ( f" [string] { latest_data_version }" ) [EOL] latest . update_build ( product = productName , hashFunction = hashFunction , buildData = json . dumps ( source_data ) , alias = json . dumps ( alias ) , schemaVersion = schemaVersion , data_version = latest_data_version , ) [EOL] [EOL] retry ( update_latest , sleeptime = [number] , max_sleeptime = [number] , attempts = [number] ) [EOL] [EOL] [EOL] class MultipleUpdatesNightlyMixin ( object ) : [EOL] def _get_update_data ( self , productName , branch , completeInfo = None , partialInfo = None ) : [EOL] data = { } [EOL] [EOL] if completeInfo : [EOL] data [ [string] ] = [ ] [EOL] for info in completeInfo : [EOL] if [string] in info : [EOL] from_ = get_nightly_blob_name ( productName , branch , self . build_type , info [ [string] ] , self . dummy ) [EOL] else : [EOL] from_ = [string] [EOL] data [ [string] ] . append ( { [string] : from_ , [string] : info [ [string] ] , [string] : info [ [string] ] , [string] : self . _replace_canocical_url ( info [ [string] ] ) } ) [EOL] if partialInfo : [EOL] data [ [string] ] = [ ] [EOL] for info in partialInfo : [EOL] data [ [string] ] . append ( { [string] : get_nightly_blob_name ( productName , branch , self . build_type , info [ [string] ] , self . dummy ) , [string] : info [ [string] ] , [string] : info [ [string] ] , [string] : self . _replace_canocical_url ( info [ [string] ] ) , } ) [EOL] [EOL] return data [EOL] [EOL] [EOL] class NightlySubmitterV4 ( NightlySubmitterBase , MultipleUpdatesNightlyMixin ) : [EOL] def run ( self , * args , ** kwargs ) : [EOL] return NightlySubmitterBase . run ( self , * args , schemaVersion = [number] , ** kwargs ) [EOL] [EOL] [EOL] class MultipleUpdatesReleaseMixin ( object ) : [EOL] def _get_update_data ( self , productName , version , build_number , completeInfo = None , partialInfo = None ) : [EOL] data = { } [EOL] [EOL] if completeInfo : [EOL] data [ [string] ] = [ ] [EOL] for info in completeInfo : [EOL] if [string] in info : [EOL] from_ = get_release_blob_name ( productName , version , build_number , self . from_suffix ) [EOL] else : [EOL] from_ = [string] [EOL] data [ [string] ] . append ( { [string] : from_ , [string] : info [ [string] ] , [string] : info [ [string] ] } ) [EOL] if partialInfo : [EOL] data [ [string] ] = [ ] [EOL] for info in partialInfo : [EOL] data [ [string] ] . append ( { [string] : get_release_blob_name ( productName , info [ [string] ] , info [ [string] ] , self . from_suffix ) , [string] : info [ [string] ] , [string] : info [ [string] ] , } ) [EOL] [EOL] return data [EOL] [EOL] [EOL] class ReleaseSubmitterV9 ( MultipleUpdatesReleaseMixin ) : [EOL] def __init__ ( self , api_root , auth0_secrets = None , dummy = False , suffix = [string] , from_suffix = [string] ) : [EOL] self . api_root = api_root [EOL] self . auth0_secrets = auth0_secrets [EOL] self . suffix = suffix [EOL] if dummy : [EOL] self . suffix += [string] [EOL] self . from_suffix = from_suffix [EOL] [EOL] def run ( self , platform , productName , appVersion , version , build_number , locale , hashFunction , extVersion , buildID , ** updateKwargs ) : [EOL] targets = buildbot2updatePlatforms ( platform ) [EOL] [comment] [EOL] [comment] [EOL] build_target = targets [ [number] ] [EOL] [EOL] name = get_release_blob_name ( productName , version , build_number , self . suffix ) [EOL] data = { [string] : buildID , [string] : appVersion , [string] : getPrettyVersion ( version ) } [EOL] [EOL] data . update ( self . _get_update_data ( productName , version , build_number , ** updateKwargs ) ) [EOL] [EOL] api = SingleLocale ( name = name , build_target = build_target , locale = locale , auth0_secrets = self . auth0_secrets , api_root = self . api_root ) [EOL] current_data , data_version = api . get_data ( ) [EOL] api . update_build ( data_version = data_version , product = productName , hashFunction = hashFunction , buildData = json . dumps ( data ) , schemaVersion = [number] ) [EOL] [EOL] [EOL] class ReleasePusher ( object ) : [EOL] def __init__ ( self , api_root , auth0_secrets = None , dummy = False , suffix = [string] ) : [EOL] self . api_root = api_root [EOL] self . auth0_secrets = auth0_secrets [EOL] self . suffix = suffix [EOL] if dummy : [EOL] self . suffix += [string] [EOL] [EOL] def run ( self , productName , version , build_number , rule_ids , backgroundRate = None ) : [EOL] name = get_release_blob_name ( productName , version , build_number , self . suffix ) [EOL] for rule_id in rule_ids : [EOL] data = { [string] : name } [EOL] if backgroundRate : [EOL] data [ [string] ] = backgroundRate [EOL] Rule ( api_root = self . api_root , auth0_secrets = self . auth0_secrets , rule_id = rule_id ) . update_rule ( ** data ) [EOL] [EOL] [EOL] class ReleaseScheduler ( object ) : [EOL] def __init__ ( self , api_root , auth0_secrets = None , dummy = False , suffix = [string] ) : [EOL] self . api_root = api_root [EOL] self . auth0_secrets = auth0_secrets [EOL] self . suffix = suffix [EOL] if dummy : [EOL] self . suffix = [string] [EOL] [EOL] def run ( self , productName , version , build_number , rule_ids , forceFallbackMappingUpdate = False , when = None , backgroundRate = None ) : [EOL] name = get_release_blob_name ( productName , version , build_number , self . suffix ) [EOL] [EOL] if when is not None : [EOL] when = arrow . get ( when ) [EOL] [EOL] soon = arrow . now ( ) . shift ( minutes = [number] ) [EOL] if when is None or when < soon : [EOL] when = soon [EOL] [EOL] for rule_id in rule_ids : [EOL] data , data_version = Rule ( api_root = self . api_root , auth0_secrets = self . auth0_secrets , rule_id = rule_id ) . get_data ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if data [ [string] ] == [number] or forceFallbackMappingUpdate : [EOL] data [ [string] ] = data [ [string] ] [EOL] data [ [string] ] = name [EOL] data [ [string] ] = data_version [EOL] data [ [string] ] = rule_id [EOL] data [ [string] ] = [string] [EOL] [comment] [EOL] data [ [string] ] = when . timestamp * [number] [EOL] if backgroundRate : [EOL] data [ [string] ] = backgroundRate [EOL] [EOL] ScheduledRuleChange ( api_root = self . api_root , auth0_secrets = self . auth0_secrets , rule_id = rule_id ) . add_scheduled_rule_change ( ** data ) [EOL] [EOL] [EOL] class ReleaseStateUpdater ( object ) : [EOL] def __init__ ( self , api_root , auth0_secrets = None ) : [EOL] self . api_root = api_root [EOL] self . auth0_secrets = auth0_secrets [EOL] [EOL] def run ( self , productName , version , build_number ) : [EOL] name = get_release_blob_name ( productName , version , build_number ) [EOL] ReleaseState ( name , api_root = self . api_root , auth0_secrets = self . auth0_secrets ) . set_readonly ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]]]$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.Any]]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import os [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] with open ( os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , [string] ) ) as f : [EOL] version = f . read ( ) . rstrip ( ) [EOL] [EOL] setup ( name = [string] , version = version , description = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( [string] ) , package_data = { [string] : [ [string] ] } , package_dir = { [string] : [string] } , include_package_data = True , zip_safe = False , entry_points = { [string] : [ [string] ] } , python_requires = [string] , license = [string] , install_requires = [ [string] , [string] , [string] , [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] from scriptworker . utils import get_single_item_from_sequence [EOL] [EOL] [comment] [EOL] _VALID_SCOPES_PREFIX = [string] [EOL] [EOL] [EOL] def get_channel ( task ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] channel = task . get ( [string] , { } ) . get ( [string] ) [EOL] if not channel : [EOL] raise TaskVerificationError ( [string] ) [EOL] return channel [EOL] [EOL] [EOL] def build_filelist ( context ) : [EOL] [docstring] [EOL] filelist = [ ] [EOL] messages = [ ] [EOL] for artifact_dict in context . task [ [string] ] [ [string] ] : [EOL] for path in artifact_dict [ [string] ] : [EOL] full_path = os . path . join ( context . config [ [string] ] , [string] , artifact_dict [ [string] ] , path ) [EOL] if not os . path . exists ( full_path ) : [EOL] messages . append ( [string] . format ( full_path ) ) [EOL] filelist . append ( full_path ) [EOL] if messages : [EOL] raise TaskVerificationError ( messages ) [EOL] return filelist [EOL] [EOL] [EOL] def get_amo_instance_config_from_scope ( context ) : [EOL] [docstring] [EOL] scope = _get_scope ( context . task ) [EOL] configured_instances = context . config [ [string] ] [EOL] [EOL] try : [EOL] return configured_instances [ scope ] [EOL] except KeyError : [EOL] raise TaskVerificationError ( [string] . format ( scope ) ) [EOL] [EOL] [EOL] def _get_scope ( task ) : [EOL] return get_single_item_from_sequence ( task [ [string] ] , condition = lambda scope : scope . startswith ( _VALID_SCOPES_PREFIX ) , ErrorClass = TaskVerificationError , no_item_error_message = [string] . format ( _VALID_SCOPES_PREFIX ) , too_many_item_error_message = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import time [EOL] from uuid import uuid4 [EOL] [EOL] from async_timeout import timeout [EOL] from jose import jws [EOL] [EOL] from addonscript . task import get_amo_instance_config_from_scope [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def generate_JWT ( context ) : [EOL] [docstring] [EOL] amo_instance = get_amo_instance_config_from_scope ( context ) [EOL] user = amo_instance [ [string] ] [EOL] secret = amo_instance [ [string] ] [EOL] jti = str ( uuid4 ( ) ) [EOL] iat = int ( time . time ( ) ) [EOL] exp = iat + [number] * [number] [comment] [EOL] payload = { [string] : user , [string] : jti , [string] : iat , [string] : exp } [EOL] token_str = jws . sign ( payload , secret , algorithm = [string] ) [EOL] return token_str [EOL] [EOL] [EOL] async def amo_get ( context , url ) : [EOL] [docstring] [EOL] log . debug ( [string] . format ( url ) ) [EOL] async with timeout ( [number] ) : [EOL] resp = context . session . get ( url , headers = { [string] : [string] . format ( generate_JWT ( context ) ) } ) [EOL] async with resp as r : [EOL] log . debug ( [string] . format ( url , r . status ) ) [EOL] r . raise_for_status ( ) [EOL] returned_value = await r . json ( ) [EOL] log . debug ( [string] . format ( url , returned_value ) ) [EOL] return returned_value [EOL] [EOL] [EOL] async def amo_download ( context , url , file ) : [EOL] [docstring] [EOL] log . debug ( [string] . format ( url ) ) [EOL] async with timeout ( [number] ) : [EOL] resp = context . session . get ( url , headers = { [string] : [string] . format ( generate_JWT ( context ) ) } ) [EOL] async with resp as r : [EOL] log . debug ( [string] . format ( url , r . status ) ) [EOL] r . raise_for_status ( ) [EOL] log . debug ( [string] . format ( url , file . name ) ) [EOL] file . write ( await r . read ( ) ) [EOL] [EOL] [EOL] async def amo_put ( context , url , data ) : [EOL] [docstring] [EOL] log . debug ( [string] . format ( url ) ) [EOL] async with timeout ( [number] ) : [comment] [EOL] resp = context . session . put ( url , headers = { [string] : [string] . format ( generate_JWT ( context ) ) } , data = data ) [EOL] async with resp as r : [EOL] log . debug ( [string] . format ( url , r . status ) ) [EOL] r . raise_for_status ( ) [EOL] returned_value = await r . json ( ) [EOL] log . debug ( [string] . format ( url , returned_value ) ) [EOL] return returned_value [EOL] [EOL] [EOL] def get_api_url ( context , path , ** kwargs ) : [EOL] [docstring] [EOL] amo_instance = get_amo_instance_config_from_scope ( context ) [EOL] server = amo_instance [ [string] ] [EOL] if [string] in path : [EOL] path = path . format ( ** kwargs ) [EOL] return [string] . format ( server , path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import asyncio [EOL] import logging [EOL] import os [EOL] [EOL] import aiohttp [EOL] import scriptworker . client [EOL] from aiohttp . client_exceptions import ClientError [EOL] from scriptworker . utils import retry_async [EOL] [EOL] from addonscript . api import do_upload , get_signed_addon_url , get_signed_xpi [EOL] from addonscript . exceptions import AMOConflictError , SignatureError [EOL] from addonscript . task import build_filelist [EOL] from addonscript . xpi import get_langpack_info [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def _craft_aiohttp_connector ( context ) : [EOL] return aiohttp . TCPConnector ( ) [EOL] [EOL] [EOL] def get_default_config ( base_dir = None ) : [EOL] base_dir = base_dir or os . path . dirname ( os . getcwd ( ) ) [EOL] default_config = { [string] : os . path . join ( base_dir , [string] ) , [string] : os . path . join ( base_dir , [string] ) , [string] : os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) , } [EOL] return default_config [EOL] [EOL] [EOL] async def sign_addon ( context , locale ) : [EOL] try : [EOL] upload_data = await retry_async ( do_upload , args = ( context , locale ) , retry_exceptions = tuple ( [ ClientError , asyncio . TimeoutError ] ) ) [EOL] except AMOConflictError as exc : [EOL] log . info ( exc . message ) [EOL] upload_data = { [string] : None } [EOL] [EOL] signed_addon_url = await retry_async ( get_signed_addon_url , args = ( context , locale , upload_data [ [string] ] ) , attempts = [number] , retry_exceptions = tuple ( [ ClientError , asyncio . TimeoutError , SignatureError ] ) , ) [EOL] destination = os . path . join ( context . config [ [string] ] , [string] , locale , [string] ) [EOL] os . makedirs ( os . path . dirname ( destination ) ) [EOL] await retry_async ( get_signed_xpi , args = ( context , signed_addon_url , destination ) ) [EOL] [EOL] [EOL] def build_locales_context ( context ) : [EOL] langpack_info = [ ] [EOL] for f in build_filelist ( context ) : [EOL] current_info = get_langpack_info ( context , f ) [EOL] langpack_info . append ( current_info ) [EOL] context . locales = { locale_info [ [string] ] : { [string] : locale_info [ [string] ] , [string] : locale_info [ [string] ] , [string] : locale_info [ [string] ] } for locale_info in langpack_info } [EOL] [EOL] [EOL] async def async_main ( context ) : [EOL] connector = _craft_aiohttp_connector ( context ) [EOL] async with aiohttp . ClientSession ( connector = connector ) as session : [EOL] context . session = session [EOL] build_locales_context ( context ) [EOL] tasks = [ ] [EOL] for locale in context . locales : [EOL] tasks . append ( asyncio . ensure_future ( sign_addon ( context , locale ) ) ) [EOL] await asyncio . gather ( * tasks ) [EOL] [EOL] [EOL] def main ( config_path = None ) : [EOL] return scriptworker . client . sync_main ( async_main , config_path = config_path , default_config = get_default_config ( ) ) [EOL] [EOL] [EOL] __name__ == [string] and main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import addonscript [EOL] import typing [EOL] [docstring] [EOL] [EOL] from scriptworker . constants import STATUSES [EOL] from scriptworker . exceptions import ScriptWorkerException , ScriptWorkerTaskException [EOL] [EOL] [EOL] class SignatureError ( ScriptWorkerException ) : [EOL] [docstring] [EOL] [EOL] exit_code = STATUSES [ [string] ] [EOL] [EOL] [EOL] class FatalSignatureError ( ScriptWorkerTaskException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class AMOConflictError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , message ) : [EOL] [docstring] [EOL] self . message = message [EOL] Exception . __init__ ( self , message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] from aiohttp . client_exceptions import ClientResponseError [EOL] [EOL] from addonscript . exceptions import AMOConflictError , FatalSignatureError , SignatureError [EOL] from addonscript . task import get_channel [EOL] from addonscript . utils import amo_download , amo_get , amo_put , get_api_url [EOL] [EOL] [comment] [EOL] UPLOAD_VERSION = [string] [EOL] [EOL] [comment] [EOL] UPLOAD_STATUS = [string] [EOL] UPLOAD_STATUS_PK = [string] [EOL] [EOL] [EOL] async def do_upload ( context , locale ) : [EOL] [docstring] [EOL] locale_info = context . locales [ locale ] [EOL] langpack_id = locale_info [ [string] ] [EOL] version = locale_info [ [string] ] [EOL] url = get_api_url ( context , UPLOAD_VERSION , id = langpack_id , version = version ) [EOL] with open ( context . locales [ locale ] [ [string] ] , [string] ) as file : [EOL] data = { [string] : get_channel ( context . task ) , [string] : file } [EOL] try : [EOL] result = await amo_put ( context , url , data ) [EOL] except ClientResponseError as exc : [EOL] [comment] [EOL] if exc . status == [number] : [EOL] raise AMOConflictError ( [string] . format ( langpack_id , version ) ) [EOL] [comment] [EOL] raise exc [EOL] return result [EOL] [EOL] [EOL] async def get_signed_addon_url ( context , locale , pk ) : [EOL] [docstring] [EOL] [comment] [EOL] upload_status = await get_upload_status ( context , locale , pk ) [EOL] [EOL] if len ( upload_status [ [string] ] ) != [number] : [EOL] raise SignatureError ( [string] . format ( len ( upload_status [ [string] ] ) , upload_status ) ) [EOL] [EOL] if upload_status . get ( [string] ) : [EOL] validation_errors = upload_status [ [string] ] . get ( [string] ) [EOL] if validation_errors : [EOL] raise FatalSignatureError ( [string] . format ( validation_errors ) ) [EOL] [EOL] signed_data = upload_status [ [string] ] [ [number] ] [EOL] [EOL] if not signed_data . get ( [string] ) : [EOL] raise SignatureError ( [string] . format ( signed_data ) ) [EOL] [EOL] if not signed_data . get ( [string] ) : [EOL] raise SignatureError ( [string] . format ( signed_data ) ) [EOL] [EOL] return signed_data [ [string] ] [EOL] [EOL] [EOL] async def get_upload_status ( context , locale , upload_pk ) : [EOL] [docstring] [EOL] locale_info = context . locales [ locale ] [EOL] langpack_id = locale_info [ [string] ] [EOL] version = locale_info [ [string] ] [EOL] if upload_pk : [EOL] format_string = UPLOAD_STATUS_PK [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] format_string = UPLOAD_STATUS [EOL] url = get_api_url ( context , format_string , id = langpack_id , version = version , upload_pk = upload_pk ) [EOL] return await amo_get ( context , url ) [EOL] [EOL] [EOL] async def get_signed_xpi ( context , download_path , destination_path ) : [EOL] [docstring] [EOL] with open ( destination_path , [string] ) as file : [EOL] await amo_download ( context , download_path , file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import zipfile [EOL] [docstring] [EOL] [EOL] import json [EOL] from zipfile import ZipFile [EOL] [EOL] [EOL] def get_langpack_info ( context , path ) : [EOL] [docstring] [EOL] with ZipFile ( path , [string] ) as langpack_xpi : [EOL] manifest = langpack_xpi . getinfo ( [string] ) [EOL] with langpack_xpi . open ( manifest ) as f : [EOL] contents = f . read ( ) . decode ( [string] ) [EOL] manifest_info = json . loads ( contents ) [EOL] langpack_info = { [string] : manifest_info [ [string] ] , [string] : manifest_info [ [string] ] , [string] : manifest_info [ [string] ] [ [string] ] [ [string] ] , [string] : path , } [EOL] return langpack_info [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Union , Any , Dict [EOL] import typing [EOL] import contextlib [EOL] import json [EOL] import os [EOL] import time [EOL] import uuid [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] from aioresponses import aioresponses [EOL] from freezegun import freeze_time [EOL] from jose import jws [EOL] from jose . constants import ALGORITHMS [EOL] from scriptworker . context import Context [EOL] [EOL] import addonscript . utils as utils [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def context ( ) : [EOL] context = Context ( ) [EOL] context . config = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } } } [EOL] context . task = { [string] : [ [string] ] } [EOL] return context [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def payload ( ) : [EOL] [comment] [EOL] with freeze_time ( [string] ) : [EOL] _iat = int ( time . time ( ) ) [EOL] payload = { [string] : [string] , [string] : str ( uuid . uuid4 ( ) ) , [string] : _iat , [string] : _iat + [number] * [number] } [EOL] return payload [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) async def fake_session ( event_loop ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] return session [EOL] [EOL] [EOL] @ freeze_time ( [string] ) def test_generate_JWT ( mocker , context , payload ) : [EOL] mocker . patch . object ( utils , [string] , side_effect = lambda : payload [ [string] ] ) [EOL] token = utils . generate_JWT ( context ) [EOL] verify_bytes = jws . verify ( token , [string] , ALGORITHMS . HS256 ) [EOL] assert json . loads ( verify_bytes . decode ( [string] ) ) == payload [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [number] , [number] , [number] , [number] , [number] ) ) async def test_amo_get_raises_status ( fake_session , context , http_code ) : [EOL] with aioresponses ( ) as m : [EOL] context . session = fake_session [EOL] m . get ( [string] , status = http_code , body = [string] ) [EOL] [EOL] [comment] [EOL] raises = contextlib . suppress ( ) [EOL] if http_code >= [number] : [EOL] raises = pytest . raises ( aiohttp . client_exceptions . ClientResponseError ) [EOL] with raises : [EOL] resp = await utils . amo_get ( context , [string] ) [EOL] assert resp == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_amo_get_header ( fake_session , mocker , context ) : [EOL] headers = { } [EOL] [EOL] with aioresponses ( ) as m : [EOL] context . session = fake_session [EOL] m . get ( [string] , status = [number] , body = [string] ) [EOL] [EOL] def header_test ( * args , ** kwargs ) : [EOL] headers . update ( kwargs [ [string] ] ) [EOL] mocker . stopall ( ) [EOL] return context . session . get ( * args , ** kwargs ) [EOL] [EOL] mocker . patch . object ( context . session , [string] , new = header_test ) [EOL] [EOL] await utils . amo_get ( context , [string] ) [EOL] assert [string] in headers [EOL] assert headers [ [string] ] . startswith ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_amo_download_header ( fake_session , mocker , context , tmpdir ) : [EOL] headers = { } [EOL] [EOL] with aioresponses ( ) as m : [EOL] context . session = fake_session [EOL] m . get ( [string] , status = [number] , body = [string] ) [EOL] [EOL] def header_test ( * args , ** kwargs ) : [EOL] headers . update ( kwargs [ [string] ] ) [EOL] mocker . stopall ( ) [EOL] return context . session . get ( * args , ** kwargs ) [EOL] [EOL] mocker . patch . object ( context . session , [string] , new = header_test ) [EOL] [EOL] with open ( os . path . join ( tmpdir , [string] ) , [string] ) as f : [EOL] await utils . amo_download ( context , [string] , file = f ) [EOL] assert [string] in headers [EOL] assert headers [ [string] ] . startswith ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [number] , [number] , [number] , [number] , [number] ) ) async def test_amo_download_raises_status ( fake_session , context , tmpdir , http_code ) : [EOL] testfile = os . path . join ( tmpdir , [string] ) [EOL] with aioresponses ( ) as m : [EOL] context . session = fake_session [EOL] m . get ( [string] , status = http_code , body = [string] ) [EOL] [EOL] [comment] [EOL] raises = contextlib . suppress ( ) [EOL] expect_empty_file = False [EOL] if http_code >= [number] : [EOL] raises = pytest . raises ( aiohttp . client_exceptions . ClientResponseError ) [EOL] expect_empty_file = True [EOL] with raises : [EOL] with open ( testfile , [string] ) as f : [EOL] await utils . amo_download ( context , [string] , file = f ) [EOL] assert os . path . isfile ( testfile ) [EOL] if expect_empty_file : [EOL] os . stat ( testfile ) . st_size == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [number] , [number] , [number] , [number] , [number] ) ) async def test_amo_put_raises_status ( fake_session , context , http_code ) : [EOL] with aioresponses ( ) as m : [EOL] context . session = fake_session [EOL] m . put ( [string] , status = http_code , body = [string] ) [EOL] [EOL] [comment] [EOL] raises = contextlib . suppress ( ) [EOL] if http_code >= [number] : [EOL] raises = pytest . raises ( aiohttp . client_exceptions . ClientResponseError ) [EOL] with raises : [EOL] resp = await utils . amo_put ( context , [string] , data = { } ) [EOL] assert resp == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_amo_put_header ( fake_session , mocker , context ) : [EOL] headers = { } [EOL] [EOL] with aioresponses ( ) as m : [EOL] context . session = fake_session [EOL] m . put ( [string] , status = [number] , body = [string] ) [EOL] [EOL] def header_test ( * args , ** kwargs ) : [EOL] headers . update ( kwargs [ [string] ] ) [EOL] mocker . stopall ( ) [EOL] return context . session . put ( * args , ** kwargs ) [EOL] [EOL] mocker . patch . object ( context . session , [string] , new = header_test ) [EOL] [EOL] await utils . amo_put ( context , [string] , data = { } ) [EOL] assert [string] in headers [EOL] assert headers [ [string] ] . startswith ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) ) ) def test_get_api_url ( host , path , context ) : [EOL] context . config [ [string] ] [ [string] ] [ [string] ] = host [EOL] url = utils . get_api_url ( context , path ) [EOL] assert url . startswith ( host ) [EOL] assert url . endswith ( path ) [EOL] [EOL] [EOL] def test_get_api_formatted ( context ) : [EOL] host = [string] [EOL] context . config [ [string] ] [ [string] ] [ [string] ] = host [EOL] url = utils . get_api_url ( context , [string] , api = [string] ) [EOL] assert url . startswith ( host ) [EOL] assert url . endswith ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import typing [EOL] import contextlib [EOL] import os [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] from aioresponses import aioresponses [EOL] from scriptworker . context import Context [EOL] [EOL] import addonscript . api as api [EOL] from addonscript . exceptions import AMOConflictError , FatalSignatureError , SignatureError [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def context ( ) : [EOL] context = Context ( ) [EOL] context . config = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } } } [EOL] context . task = { [string] : [ [string] ] } [EOL] return context [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) async def fake_session ( event_loop ) : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] return session [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [number] , None ) , ( [number] , None ) , ( [number] , None ) , ( [number] , aiohttp . client_exceptions . ClientResponseError ) , ( [number] , aiohttp . client_exceptions . ClientResponseError ) , ( [number] , AMOConflictError ) , ) , ) async def test_do_upload ( fake_session , context , tmpdir , mocker , statuscode , raises ) : [EOL] upload_file = [string] . format ( tmpdir ) [EOL] context . locales = { } [EOL] context . locales [ [string] ] = { [string] : [string] , [string] : [string] , [string] : upload_file } [EOL] with open ( upload_file , [string] ) as f : [EOL] f . write ( [string] ) [EOL] expected_url = [string] . format ( id = [string] , version = [string] ) [EOL] mocked_url = [string] . format ( [string] , expected_url ) [EOL] [EOL] mocker . patch . object ( api , [string] , return_value = [string] ) [EOL] [EOL] with aioresponses ( ) as m : [EOL] context . session = fake_session [EOL] m . put ( mocked_url , status = statuscode , body = [string] ) [EOL] [EOL] raisectx = contextlib . suppress ( ) [EOL] if raises : [EOL] raisectx = pytest . raises ( raises ) [EOL] with raisectx : [EOL] resp = await api . do_upload ( context , [string] ) [EOL] assert resp == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_signed_addon_url_success ( context , mocker ) : [EOL] status_json = { [string] : [ { [string] : True , [string] : [string] } ] } [EOL] [EOL] async def new_upload_status ( * args , ** kwargs ) : [EOL] return status_json [EOL] [EOL] mocker . patch . object ( api , [string] , new = new_upload_status ) [EOL] resp = await api . get_signed_addon_url ( context , [string] , [string] ) [EOL] assert resp == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [number] , True ) , ( [number] , False ) , ( [number] , True ) , ( [number] , True ) ) ) async def test_get_signed_addon_url_files ( context , mocker , num_files , raises ) : [EOL] status_json = { [string] : [ ] } [EOL] for _ in range ( num_files ) : [EOL] status_json [ [string] ] . append ( { [string] : True , [string] : [string] } ) [EOL] [EOL] async def new_upload_status ( * args , ** kwargs ) : [EOL] return status_json [EOL] [EOL] mocker . patch . object ( api , [string] , new = new_upload_status ) [EOL] [EOL] raisectx = contextlib . suppress ( ) [EOL] if raises : [EOL] raisectx = pytest . raises ( SignatureError ) [EOL] with raisectx as excinfo : [EOL] resp = await api . get_signed_addon_url ( context , [string] , [string] ) [EOL] assert resp == [string] [EOL] if raises : [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [ ] , False ) , ( [ [string] , [string] ] , True ) , ( [ [string] ] , True ) ) ) async def test_get_signed_addon_url_validation_errors ( context , mocker , errors , raises ) : [EOL] status_json = { [string] : [ { [string] : True , [string] : [string] } ] , [string] : { [string] : errors } } [EOL] [EOL] async def new_upload_status ( * args , ** kwargs ) : [EOL] return status_json [EOL] [EOL] mocker . patch . object ( api , [string] , new = new_upload_status ) [EOL] [EOL] raisectx = contextlib . suppress ( ) [EOL] if raises : [EOL] raisectx = pytest . raises ( FatalSignatureError ) [EOL] with raisectx as excinfo : [EOL] resp = await api . get_signed_addon_url ( context , [string] , [string] ) [EOL] assert resp == [string] [EOL] if raises : [EOL] assert [string] in str ( excinfo . value ) [EOL] for val in errors : [EOL] assert val in str ( excinfo . value ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) async def test_get_signed_addon_url_other_errors ( context , mocker , variant ) : [EOL] status_json = { [string] : [ { [string] : True if variant != [string] else False } ] } [EOL] if variant != [string] : [EOL] status_json [ [string] ] [ [number] ] [ [string] ] = [string] [EOL] [EOL] async def new_upload_status ( * args , ** kwargs ) : [EOL] return status_json [EOL] [EOL] mocker . patch . object ( api , [string] , new = new_upload_status ) [EOL] [EOL] raisectx = pytest . raises ( SignatureError ) [EOL] with raisectx as excinfo : [EOL] await api . get_signed_addon_url ( context , [string] , [string] ) [EOL] if variant == [string] : [EOL] assert [string] in str ( excinfo . value ) [EOL] if variant == [string] : [EOL] assert [string] in str ( excinfo . value ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_signed_xpi ( fake_session , context , tmpdir ) : [EOL] destination = os . path . join ( tmpdir , [string] ) [EOL] download_path = [string] [EOL] with aioresponses ( ) as m : [EOL] context . session = fake_session [EOL] m . get ( download_path , status = [number] , body = [string] ) [EOL] [EOL] [comment] [EOL] await api . get_signed_xpi ( context , download_path , destination ) [EOL] with open ( destination , [string] ) as f : [EOL] contents = f . read ( ) [EOL] assert contents == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , None ) , ) , ) async def test_get_upload_status ( context , fake_session , expected_url , pk ) : [EOL] context . locales = { } [EOL] context . locales [ [string] ] = { [string] : [string] , [string] : [string] } [EOL] mocked_url = [string] . format ( [string] , expected_url ) [EOL] with aioresponses ( ) as m : [EOL] context . session = fake_session [EOL] m . get ( mocked_url , status = [number] , body = [string] ) [EOL] [EOL] resp = await api . get_upload_status ( context , [string] , pk ) [EOL] assert resp == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , Dict [EOL] import typing [EOL] import os [EOL] [EOL] import pytest [EOL] from scriptworker . context import Context [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] import addonscript . task as task [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def context ( tmpdir ) : [EOL] context = Context ( ) [EOL] context . config = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } } , [string] : tmpdir , } [EOL] context . task = { [string] : [ [string] ] , [string] : { [string] : [string] } , [string] : [ [string] ] , } [EOL] [EOL] return context [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = ( ( [string] , ( [string] , [string] ) ) , ( [string] , ( [string] , [string] , [string] ) ) ) , ids = ( [string] , [string] ) ) async def task_dfn ( request ) : [EOL] channel , locales = request . param [EOL] payload = { [string] : channel , [string] : [ ] } [EOL] i = [number] [EOL] for locale in locales : [EOL] i += [number] [EOL] payload [ [string] ] . append ( { [string] : [ [string] . format ( locale ) ] , [string] : [string] . format ( i ) , [string] : [string] } ) [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] . format ( n + [number] ) for n in range ( i ) ] , [string] : [ ] , [string] : payload , [string] : { [string] : [string] [string] } , } [EOL] [EOL] [EOL] def test_get_channel ( task_dfn ) : [EOL] channel = task_dfn [ [string] ] [ [string] ] [EOL] assert channel == task . get_channel ( task_dfn ) [EOL] [EOL] [EOL] def test_get_channel_missing ( task_dfn ) : [EOL] del task_dfn [ [string] ] [ [string] ] [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] task . get_channel ( task_dfn ) [EOL] [EOL] [EOL] def test_build_filelist ( context , task_dfn ) : [EOL] expected_paths = set ( ) [EOL] for a in task_dfn [ [string] ] [ [string] ] : [EOL] abs_path = os . path . join ( context . config [ [string] ] , [string] , a [ [string] ] , a [ [string] ] [ [number] ] ) [EOL] expected_paths . add ( abs_path ) [EOL] os . makedirs ( os . path . dirname ( abs_path ) ) [EOL] with open ( abs_path , [string] ) as f : [EOL] [comment] [EOL] print ( [string] , file = f ) [EOL] context . task = task_dfn [EOL] file_list = task . build_filelist ( context ) [EOL] assert len ( file_list ) == len ( task_dfn [ [string] ] [ [string] ] ) [EOL] assert expected_paths == set ( file_list ) [EOL] assert isinstance ( file_list , type ( [ ] ) ) [EOL] [EOL] [EOL] def test_build_filelist_missing_file ( context , task_dfn ) : [EOL] expected_paths = set ( ) [EOL] for a in task_dfn [ [string] ] [ [string] ] : [EOL] abs_path = os . path . join ( context . config [ [string] ] , [string] , a [ [string] ] , a [ [string] ] [ [number] ] ) [EOL] expected_paths . add ( abs_path ) [EOL] os . makedirs ( os . path . dirname ( abs_path ) ) [EOL] with open ( abs_path , [string] ) as f : [EOL] [comment] [EOL] print ( [string] , file = f ) [EOL] task_dfn [ [string] ] [ [string] ] [ - [number] ] [ [string] ] = [string] [EOL] context . task = task_dfn [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] task . build_filelist ( context ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) , ) def test_get_amo_instance_config_from_scope ( context , api_root , scope ) : [EOL] context . config [ [string] ] [ scope ] = context . config [ [string] ] [ [string] ] [EOL] context . config [ [string] ] [ scope ] [ [string] ] = api_root [EOL] context . task [ [string] ] = [ scope ] [EOL] [EOL] assert task . get_amo_instance_config_from_scope ( context ) == { [string] : api_root , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) def test_fail_get_amo_instance_config_from_scope ( context , scope ) : [EOL] context . task [ [string] ] = [ scope ] [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] task . get_amo_instance_config_from_scope ( context ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( [string] , ) , False ) , ( ( [string] , ) , False ) , ( ( [string] , ) , False ) , ( ( [string] , [string] ) , True ) , ( ( [string] , ) , True ) , ) , ) def test_get_scope ( scopes , raises ) : [EOL] task_ = { [string] : scopes } [EOL] [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] task . _get_scope ( task_ ) [EOL] else : [EOL] assert task . _get_scope ( task_ ) == scopes [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tempfile [EOL] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def tmpdir ( ) : [EOL] with tempfile . TemporaryDirectory ( ) as tmp : [EOL] yield tmp [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] import os [EOL] from glob import glob [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] with open ( os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , [string] ) ) as f : [EOL] version = f . read ( ) . rstrip ( ) [EOL] [EOL] with open ( os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , [string] , [string] ) ) as f : [EOL] install_requires = f . read ( ) . splitlines ( ) [EOL] [EOL] setup ( name = [string] , version = version , description = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( [string] ) , package_dir = { [string] : [string] } , py_modules = [ os . path . splitext ( os . path . basename ( path ) ) [ [number] ] for path in glob ( [string] ) ] , include_package_data = True , zip_safe = True , license = [string] , install_requires = install_requires , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0
[comment] [EOL] from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] STATUSES = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[comment] [EOL] [docstring] [EOL] [EOL] import builtins [EOL] [EOL] from scriptworker_client . constants import STATUSES [EOL] [EOL] [EOL] class ClientError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , exit_code = [number] , ** kwargs ) : [EOL] [docstring] [EOL] self . exit_code = exit_code [EOL] super ( ClientError , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class TaskError ( ClientError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TimeoutError ( ClientError , builtins . TimeoutError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TaskVerificationError ( ClientError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( msg , exit_code = STATUSES [ [string] ] ) [EOL] [EOL] [EOL] class RetryError ( ClientError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Download404 ( ClientError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class DownloadError ( ClientError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class LockfileError ( ClientError ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , Callable , Union , Dict , List [EOL] import mock [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] import logging [EOL] import os [EOL] import sys [EOL] from copy import deepcopy [EOL] [EOL] import mock [EOL] import pytest [EOL] [EOL] import scriptworker_client . client as client [EOL] from scriptworker_client . exceptions import TaskError , TaskVerificationError [EOL] [EOL] [comment] [EOL] [EOL] FAKE_SCHEMA = { [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : True , [string] : { [string] : [string] } , } } , [string] : [ [string] ] , } [EOL] [EOL] [comment] [EOL] def test_get_task ( tmpdir ) : [EOL] [docstring] [EOL] expected = { [string] : [string] } [EOL] config = { [string] : str ( tmpdir ) } [EOL] with open ( os . path . join ( tmpdir , [string] ) , [string] ) as fh : [EOL] fh . write ( json . dumps ( expected ) ) [EOL] assert client . get_task ( config ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] , [string] ] } , FAKE_SCHEMA , False ) , ( { [string] : [ [string] , [string] ] } , FAKE_SCHEMA , True ) , ( { [string] : [ ] } , FAKE_SCHEMA , True ) , ( { [string] : { [string] : [string] } } , FAKE_SCHEMA , True ) , ( { [string] : { } } , FAKE_SCHEMA , True ) , ) , ) def test_verify_json_schema ( data , schema , raises ) : [EOL] [docstring] [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] client . verify_json_schema ( data , schema ) [EOL] else : [EOL] client . verify_json_schema ( data , schema ) [EOL] [EOL] [EOL] [comment] [EOL] def test_verify_task_schema ( tmpdir ) : [EOL] [docstring] [EOL] path = os . path . join ( tmpdir , [string] ) [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( json . dumps ( FAKE_SCHEMA ) ) [EOL] config = { [string] : { [string] : path } } [EOL] client . verify_task_schema ( config , { [string] : [ [string] ] } , [string] ) [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] client . verify_task_schema ( config , { [string] : [ [string] , [string] ] } , [string] ) [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] client . verify_task_schema ( config , { [string] : [ [string] , [string] ] } , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_sync_main_runs_fully ( tmpdir , should_verify_task ) : [EOL] [docstring] [EOL] work_dir = str ( tmpdir ) [EOL] config = { [string] : work_dir , [string] : os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) , } [EOL] with open ( os . path . join ( config [ [string] ] , [string] ) , [string] ) as fh : [EOL] fh . write ( json . dumps ( { [string] : True , [string] : { [string] : [string] } , } ) ) [EOL] async_main_calls = [ ] [EOL] run_until_complete_calls = [ ] [EOL] [EOL] async def async_main ( * args ) : [EOL] async_main_calls . append ( args ) [EOL] [EOL] def count_run_until_complete ( arg1 ) : [EOL] run_until_complete_calls . append ( arg1 ) [EOL] [EOL] fake_loop = mock . MagicMock ( ) [EOL] fake_loop . run_until_complete = count_run_until_complete [EOL] [EOL] def loop_function ( ) : [EOL] return fake_loop [EOL] [EOL] kwargs = { [string] : loop_function } [EOL] [EOL] if not should_verify_task : [EOL] kwargs [ [string] ] = False [EOL] [EOL] config_path = os . path . join ( tmpdir , [string] ) [EOL] with open ( config_path , [string] ) as fh : [EOL] json . dump ( config , fh ) [EOL] [EOL] kwargs [ [string] ] = config_path [EOL] client . sync_main ( async_main , ** kwargs ) [EOL] [EOL] for i in run_until_complete_calls : [EOL] await i [comment] [EOL] assert len ( run_until_complete_calls ) == [number] [comment] [EOL] assert len ( async_main_calls ) == [number] [comment] [EOL] [EOL] [EOL] def test_usage ( capsys , monkeypatch ) : [EOL] [docstring] [EOL] monkeypatch . setattr ( sys , [string] , [ [string] ] ) [EOL] with pytest . raises ( SystemExit ) : [EOL] client . _usage ( ) [EOL] [EOL] captured = capsys . readouterr ( ) [EOL] assert captured . out == [string] [EOL] assert captured . err == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( True , logging . DEBUG ) , ( False , logging . INFO ) ) ) def test_init_logging ( monkeypatch , is_verbose , log_level ) : [EOL] [docstring] [EOL] basic_config_mock = mock . MagicMock ( ) [EOL] config = { [string] : is_verbose } [EOL] [EOL] monkeypatch . setattr ( logging , [string] , basic_config_mock ) [EOL] client . _init_logging ( config ) [EOL] [EOL] basic_config_mock . assert_called_once_with ( format = [string] , level = log_level ) [EOL] assert logging . getLogger ( [string] ) . level == logging . WARNING [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_handle_asyncio_loop ( ) : [EOL] [docstring] [EOL] config = { } [EOL] [EOL] async def async_main ( * args , ** kwargs ) : [EOL] config [ [string] ] = True [EOL] [EOL] await client . _handle_asyncio_loop ( async_main , config , { } ) [EOL] [EOL] assert config . get ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_fail_handle_asyncio_loop ( mocker ) : [EOL] [docstring] [EOL] m = mocker . patch . object ( client , [string] ) [EOL] [EOL] async def async_error ( * args , ** kwargs ) : [EOL] exception = TaskError ( [string] ) [EOL] exception . exit_code = [number] [EOL] raise exception [EOL] [EOL] with pytest . raises ( SystemExit ) as excinfo : [EOL] await client . _handle_asyncio_loop ( async_error , { } , { } ) [EOL] [EOL] assert excinfo . value . code == [number] [EOL] m . exception . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_init_config_cli ( mocker , tmpdir ) : [EOL] [docstring] [EOL] mocker . patch . object ( sys , [string] , new = [ [string] ] ) [EOL] with pytest . raises ( SystemExit ) : [EOL] client . init_config ( ) [EOL] path = os . path . join ( tmpdir , [string] ) [EOL] config = { [string] : [string] } [EOL] default_config = { [string] : [string] } [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( json . dumps ( config ) ) [EOL] expected = deepcopy ( default_config ) [EOL] expected . update ( config ) [EOL] mocker . patch . object ( sys , [string] , new = [ [string] , path ] ) [EOL] assert client . init_config ( default_config = default_config ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Awaitable , Dict [EOL] import typing [EOL] import logging [EOL] import notarization_poller [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import signal [EOL] import socket [EOL] import sys [EOL] import typing [EOL] from asyncio import sleep [EOL] [EOL] import aiohttp [EOL] import arrow [EOL] import taskcluster [EOL] from scriptworker_client . constants import STATUSES [EOL] from scriptworker_client . utils import makedirs , rm [EOL] from taskcluster . aio import Queue [EOL] [EOL] from notarization_poller . config import get_config_from_cmdln , update_logging_config [EOL] from notarization_poller . constants import MAX_CLAIM_WORK_TASKS [EOL] from notarization_poller . task import Task [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] async def claim_work ( config , worker_queue , num_tasks = [number] ) : [EOL] [docstring] [EOL] log . debug ( [string] . format ( config [ [string] ] , config [ [string] ] ) ) [EOL] payload = { [string] : config [ [string] ] , [string] : config [ [string] ] , [string] : num_tasks } [EOL] try : [EOL] return await worker_queue . claimWork ( config [ [string] ] , config [ [string] ] , payload ) [EOL] except ( taskcluster . exceptions . TaskclusterFailure , aiohttp . ClientError , asyncio . TimeoutError ) as exc : [EOL] log . warning ( [string] . format ( exc . __class__ , exc ) ) [EOL] [EOL] [EOL] [comment] [EOL] class RunTasks : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . config = config [EOL] self . running_tasks = [ ] [EOL] self . last_claim_work = arrow . get ( [number] ) [EOL] self . is_stopped = False [EOL] self . is_cancelled = False [EOL] self . future = None [EOL] [EOL] async def invoke ( self ) : [EOL] [docstring] [EOL] while not self . is_cancelled and not self . is_stopped : [EOL] num_tasks_to_claim = min ( self . config [ [string] ] - len ( self . running_tasks ) , MAX_CLAIM_WORK_TASKS ) [EOL] if num_tasks_to_claim > [number] : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] queue = Queue ( options = { [string] : { [string] : self . config [ [string] ] , [string] : self . config [ [string] ] } , [string] : self . config [ [string] ] , } , session = session , ) [EOL] new_tasks = await self . _run_cancellable ( claim_work ( self . config , queue , num_tasks = num_tasks_to_claim ) ) or { } [EOL] self . last_claim_work = arrow . utcnow ( ) [EOL] for claim_task in new_tasks . get ( [string] , [ ] ) : [EOL] new_task = Task ( self . config , claim_task ) [EOL] new_task . start ( ) [EOL] self . running_tasks . append ( new_task ) [EOL] await self . prune_running_tasks ( ) [EOL] sleep_time = self . last_claim_work . timestamp + self . config [ [string] ] - arrow . utcnow ( ) . timestamp [EOL] sleep_time > [number] and await self . _run_cancellable ( sleep ( sleep_time ) ) [EOL] self . running_tasks and await asyncio . wait ( [ task . main_fut for task in self . running_tasks if task . main_fut ] ) [EOL] [EOL] async def prune_running_tasks ( self ) : [EOL] [docstring] [EOL] for task in self . running_tasks : [EOL] if task . complete : [EOL] self . running_tasks . remove ( task ) [EOL] [EOL] async def _run_cancellable ( self , coroutine ) : [EOL] if not self . is_cancelled : [EOL] self . future = asyncio . ensure_future ( coroutine ) [EOL] try : [EOL] result = await self . future [EOL] finally : [EOL] self . future = None [EOL] return result [EOL] [EOL] async def cancel ( self , status = STATUSES [ [string] ] ) : [EOL] [docstring] [EOL] self . is_cancelled = True [EOL] self . future and self . future . cancel ( ) [EOL] try : [EOL] for task in self . running_tasks : [EOL] task . task_fut and task . task_fut . cancel ( ) [EOL] await asyncio . wait ( [ task . main_fut for task in self . running_tasks if task . main_fut ] ) [EOL] except ( asyncio . CancelledError , ValueError ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] def main ( event_loop = None ) : [EOL] [docstring] [EOL] event_loop = event_loop or asyncio . get_event_loop ( ) [EOL] config = get_config_from_cmdln ( sys . argv [ [number] : ] ) [EOL] update_logging_config ( config ) [EOL] [EOL] log . info ( [string] . format ( arrow . utcnow ( ) . format ( ) ) ) [EOL] log . info ( [string] . format ( socket . getfqdn ( ) ) ) [EOL] rm ( config [ [string] ] ) [EOL] makedirs ( config [ [string] ] ) [EOL] running_tasks = RunTasks ( config ) [EOL] [EOL] async def _handle_sigterm ( ) : [EOL] log . info ( [string] ) [EOL] await running_tasks . cancel ( ) [EOL] [EOL] def _handle_sigusr1 ( ) : [EOL] [docstring] [EOL] log . info ( [string] ) [EOL] running_tasks . is_stopped = True [EOL] [EOL] event_loop . add_signal_handler ( signal . SIGTERM , lambda : asyncio . ensure_future ( _handle_sigterm ( ) ) ) [EOL] event_loop . add_signal_handler ( signal . SIGUSR1 , _handle_sigusr1 ) [EOL] [EOL] try : [EOL] event_loop . run_until_complete ( running_tasks . invoke ( ) ) [EOL] except Exception : [EOL] log . critical ( [string] , exc_info = [number] ) [EOL] raise [EOL] finally : [EOL] log . info ( [string] . format ( arrow . utcnow ( ) . format ( ) ) ) [EOL] log . info ( [string] . format ( socket . getfqdn ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import logging [EOL] import argparse [EOL] [docstring] [EOL] import argparse [EOL] import logging [EOL] import logging . handlers [EOL] import os [EOL] [EOL] from scriptworker_client . client import _init_logging , init_config [EOL] [EOL] from notarization_poller . constants import DEFAULT_CONFIG [EOL] from notarization_poller . exceptions import ConfigError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def update_logging_config ( config , log_name = [string] , file_name = [string] ) : [EOL] [docstring] [EOL] _init_logging ( config ) [EOL] top_level_logger = logging . getLogger ( log_name ) [EOL] [EOL] datefmt = config [ [string] ] [EOL] fmt = config [ [string] ] [EOL] formatter = logging . Formatter ( fmt = fmt , datefmt = datefmt ) [EOL] [EOL] if config . get ( [string] ) : [EOL] top_level_logger . setLevel ( logging . DEBUG ) [EOL] else : [EOL] top_level_logger . setLevel ( logging . INFO ) [EOL] [EOL] if len ( top_level_logger . handlers ) == [number] : [EOL] handler = logging . StreamHandler ( ) [EOL] handler . setFormatter ( formatter ) [EOL] top_level_logger . addHandler ( handler ) [EOL] [EOL] [comment] [EOL] os . makedirs ( config [ [string] ] , exist_ok = True ) [EOL] path = os . path . join ( config [ [string] ] , file_name ) [EOL] if config [ [string] ] : [EOL] [comment] [EOL] [comment] [EOL] handler = logging . handlers . WatchedFileHandler ( path ) [EOL] else : [EOL] [comment] [EOL] handler = logging . FileHandler ( path ) [EOL] handler . setFormatter ( formatter ) [EOL] top_level_logger . addHandler ( handler ) [EOL] top_level_logger . addHandler ( logging . NullHandler ( ) ) [EOL] [EOL] [EOL] [comment] [EOL] def _validate_config ( config ) : [EOL] if [string] in config . values ( ) : [EOL] raise ConfigError ( [string] ) [EOL] [EOL] [EOL] def get_config_from_cmdln ( args , desc = [string] ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( description = desc ) [EOL] parser . add_argument ( [string] , type = str , nargs = [string] , default = [string] , help = [string] ) [EOL] parsed_args = parser . parse_args ( args ) [EOL] config = init_config ( config_path = parsed_args . config_path , default_config = DEFAULT_CONFIG , validator_callback = _validate_config ) [EOL] update_logging_config ( config ) [EOL] return config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type [EOL] import typing [EOL] import notarization_poller [EOL] [docstring] [EOL] [EOL] from scriptworker_client . constants import STATUSES [EOL] [EOL] [EOL] class WorkerError ( Exception ) : [EOL] [docstring] [EOL] [EOL] exit_code = STATUSES [ [string] ] [EOL] [EOL] [EOL] class RetryError ( WorkerError ) : [EOL] [docstring] [EOL] [EOL] exit_code = STATUSES [ [string] ] [EOL] [EOL] [EOL] class ConfigError ( WorkerError ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[comment] [EOL] import builtins [EOL] from typing import Pattern , Any , Type , Dict , List [EOL] import typing [EOL] import logging [EOL] import notarization_poller [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import gzip [EOL] import logging [EOL] import os [EOL] import pprint [EOL] import re [EOL] import traceback [EOL] [EOL] import aiohttp [EOL] import arrow [EOL] import async_timeout [EOL] import taskcluster [EOL] import taskcluster . exceptions [EOL] from scriptworker_client . aio import download_file , retry_async [EOL] from scriptworker_client . constants import STATUSES [EOL] from scriptworker_client . exceptions import Download404 , DownloadError , TaskError [EOL] from scriptworker_client . utils import load_json_or_yaml , makedirs , rm , run_command [EOL] from taskcluster . aio import Queue [EOL] [EOL] from notarization_poller . constants import get_reversed_statuses [EOL] from notarization_poller . exceptions import RetryError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] NOTARIZATION_POLL_REGEX = re . compile ( [string] ) [EOL] [EOL] [EOL] class Task : [EOL] [docstring] [EOL] [EOL] reclaim_fut = None [EOL] task_fut = None [EOL] complete = False [EOL] uuids = None [EOL] [EOL] def __init__ ( self , config , claim_task , event_loop = None ) : [EOL] [docstring] [EOL] self . config = config [EOL] self . task_id = claim_task [ [string] ] [ [string] ] [EOL] self . run_id = claim_task [ [string] ] [EOL] self . claim_task = claim_task [EOL] self . event_loop = event_loop or asyncio . get_event_loop ( ) [EOL] self . task_dir = os . path . join ( self . config [ [string] ] , [string] . format ( self . task_id , self . run_id ) ) [EOL] self . log_path = os . path . join ( self . task_dir , [string] ) [EOL] self . poll_log_path = os . path . join ( self . task_dir , [string] ) [EOL] [EOL] def start ( self ) : [EOL] [docstring] [EOL] rm ( self . task_dir ) [EOL] makedirs ( self . task_dir ) [EOL] self . _reclaim_task = { } [EOL] self . main_fut = self . event_loop . create_task ( self . async_start ( ) ) [EOL] [EOL] async def async_start ( self ) : [EOL] [docstring] [EOL] self . reclaim_fut = self . event_loop . create_task ( self . reclaim_task ( ) ) [EOL] self . task_fut = self . event_loop . create_task ( self . run_task ( ) ) [EOL] [EOL] try : [EOL] await self . task_fut [EOL] except Download404 : [EOL] self . status = STATUSES [ [string] ] [EOL] self . task_log ( traceback . format_exc ( ) , level = logging . CRITICAL ) [EOL] except ( DownloadError , RetryError ) : [EOL] self . status = STATUSES [ [string] ] [EOL] self . task_log ( traceback . format_exc ( ) , level = logging . CRITICAL ) [EOL] except TaskError : [EOL] self . status = STATUSES [ [string] ] [EOL] self . task_log ( traceback . format_exc ( ) , level = logging . CRITICAL ) [EOL] except asyncio . CancelledError : [EOL] [comment] [EOL] self . task_log ( traceback . format_exc ( ) , level = logging . CRITICAL ) [EOL] log . info ( [string] , self . task_id , self . run_id , self . status ) [EOL] self . reclaim_fut . cancel ( ) [EOL] await self . upload_task ( ) [EOL] await self . complete_task ( ) [EOL] rm ( self . task_dir ) [EOL] self . complete = True [EOL] [EOL] @ property def task_credentials ( self ) : [EOL] [docstring] [EOL] return self . _reclaim_task . get ( [string] , self . claim_task [ [string] ] ) [EOL] [EOL] async def reclaim_task ( self ) : [EOL] [docstring] [EOL] while True : [EOL] log . debug ( [string] % self . config [ [string] ] ) [EOL] await asyncio . sleep ( self . config [ [string] ] ) [EOL] log . debug ( [string] , self . task_id , self . run_id ) [EOL] try : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] temp_queue = Queue ( options = { [string] : self . task_credentials , [string] : self . config [ [string] ] } , session = session ) [EOL] self . _reclaim_task = await temp_queue . reclaimTask ( self . task_id , self . run_id ) [EOL] except taskcluster . exceptions . TaskclusterRestFailure as exc : [EOL] if exc . status_code == [number] : [EOL] log . warning ( [string] , self . task_id , self . run_id ) [EOL] self . status = STATUSES [ [string] ] [EOL] else : [EOL] log . exception ( [string] , self . task_id , self . run_id ) [EOL] self . status = STATUSES [ [string] ] [EOL] self . task_fut and self . task_fut . cancel ( ) [EOL] break [EOL] [EOL] async def upload_task ( self ) : [EOL] [docstring] [EOL] try : [EOL] with open ( self . log_path , [string] ) as f_in : [EOL] text_content = f_in . read ( ) [EOL] with gzip . open ( self . log_path , [string] ) as f_out : [EOL] f_out . write ( text_content ) [EOL] await retry_async ( self . _upload_log , retry_exceptions = ( KeyError , RetryError , TypeError , aiohttp . ClientError ) ) [EOL] except aiohttp . ClientError as e : [EOL] self . status = self . status or STATUSES [ [string] ] [EOL] log . error ( [string] . format ( e ) ) [EOL] except Exception as e : [EOL] self . status = self . status or STATUSES [ [string] ] [EOL] log . exception ( [string] . format ( e ) ) [EOL] [EOL] async def _upload_log ( self ) : [EOL] payload = { [string] : [string] , [string] : arrow . get ( self . claim_task [ [string] ] [ [string] ] ) . isoformat ( ) , [string] : [string] } [EOL] args = [ self . task_id , self . run_id , [string] , payload ] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] temp_queue = Queue ( options = { [string] : self . task_credentials , [string] : self . config [ [string] ] } , session = session ) [EOL] tc_response = await temp_queue . createArtifact ( * args ) [EOL] headers = { aiohttp . hdrs . CONTENT_TYPE : [string] , aiohttp . hdrs . CONTENT_ENCODING : [string] } [EOL] skip_auto_headers = [ aiohttp . hdrs . CONTENT_TYPE ] [EOL] with open ( self . log_path , [string] ) as fh : [EOL] async with async_timeout . timeout ( self . config [ [string] ] ) : [EOL] async with session . put ( tc_response [ [string] ] , data = fh , headers = headers , skip_auto_headers = skip_auto_headers , compress = False ) as resp : [EOL] log . info ( [string] . format ( resp . status ) ) [EOL] response_text = await resp . text ( ) [EOL] log . info ( response_text ) [EOL] if resp . status not in ( [number] , [number] ) : [EOL] raise RetryError ( [string] . format ( resp . status ) ) [EOL] [EOL] async def complete_task ( self ) : [EOL] [docstring] [EOL] reversed_statuses = get_reversed_statuses ( ) [EOL] args = [ self . task_id , self . run_id ] [EOL] try : [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] temp_queue = Queue ( options = { [string] : self . task_credentials , [string] : self . config [ [string] ] } , session = session ) [EOL] if self . status == STATUSES [ [string] ] : [EOL] log . info ( [string] ) [EOL] response = await temp_queue . reportCompleted ( * args ) [EOL] elif self . status != [number] and self . status in reversed_statuses : [EOL] reason = reversed_statuses [ self . status ] [EOL] log . info ( [string] . format ( reason ) ) [EOL] payload = { [string] : reason } [EOL] response = await temp_queue . reportException ( * args , payload ) [EOL] else : [EOL] log . info ( [string] ) [EOL] response = await temp_queue . reportFailed ( * args ) [EOL] log . debug ( [string] . format ( pprint . pformat ( response ) ) ) [EOL] except taskcluster . exceptions . TaskclusterRestFailure as exc : [EOL] if exc . status_code == [number] : [EOL] log . info ( [string] , self . task_id , self . run_id ) [EOL] else : [EOL] log . exception ( [string] , self . task_id , self . run_id ) [EOL] [EOL] def task_log ( self , msg , * args , level = logging . INFO , worker_log = True ) : [EOL] [docstring] [EOL] with open ( self . log_path , [string] ) as log_fh : [EOL] print ( [string] . format ( arrow . utcnow ( ) . format ( self . config [ [string] ] ) , logging . _levelToName . get ( level , str ( level ) ) , msg % args ) , file = log_fh , ) [EOL] worker_log and log . log ( level , [string] . format ( msg ) , self . task_id , self . run_id , * args ) [EOL] [EOL] async def download_uuids ( self ) : [EOL] [docstring] [EOL] payload = self . claim_task [ [string] ] [ [string] ] [EOL] if payload . get ( [string] ) : [EOL] [comment] [EOL] uuids = payload [ [string] ] [EOL] else : [EOL] url = self . claim_task [ [string] ] [ [string] ] [ [string] ] [EOL] path = os . path . join ( self . task_dir , [string] ) [EOL] self . task_log ( [string] , url ) [EOL] await retry_async ( download_file , args = ( url , path ) , retry_exceptions = ( DownloadError , ) ) [EOL] uuids = load_json_or_yaml ( path , is_path = True ) [EOL] self . uuids = tuple ( uuids ) [EOL] self . task_log ( [string] , self . uuids ) [EOL] [EOL] async def run_task ( self ) : [EOL] [docstring] [EOL] self . status = [number] [EOL] username = self . config [ [string] ] [EOL] password = self . config [ [string] ] [EOL] [EOL] await self . download_uuids ( ) [EOL] self . pending_uuids = list ( self . uuids ) [EOL] while True : [EOL] self . task_log ( [string] , self . pending_uuids ) [EOL] for uuid in sorted ( self . pending_uuids ) : [EOL] self . task_log ( [string] , uuid ) [EOL] base_cmd = list ( self . config [ [string] ] ) + [ [string] , [string] , uuid , [string] , username , [string] ] [EOL] log_cmd = base_cmd + [ [string] ] [EOL] rm ( self . poll_log_path ) [EOL] status = await retry_async ( run_command , args = [ base_cmd + [ password ] ] , kwargs = { [string] : self . poll_log_path , [string] : log_cmd , [string] : RetryError } , retry_exceptions = ( RetryError , ) , attempts = [number] , ) [EOL] with open ( self . poll_log_path , [string] ) as fh : [EOL] contents = fh . read ( ) [EOL] self . task_log ( [string] , status , worker_log = False ) [EOL] for line in contents . splitlines ( ) : [EOL] self . task_log ( [string] , line , worker_log = False ) [EOL] if status == STATUSES [ [string] ] : [EOL] m = NOTARIZATION_POLL_REGEX . search ( contents ) [EOL] if m is not None : [EOL] if m [ [string] ] == [string] : [EOL] self . status = STATUSES [ [string] ] [EOL] self . task_log ( [string] , uuid , level = logging . CRITICAL ) [EOL] raise TaskError ( [string] % uuid ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if m [ [string] ] == [string] : [comment] [EOL] self . task_log ( [string] , uuid ) [EOL] self . pending_uuids . remove ( uuid ) [EOL] if len ( self . pending_uuids ) == [number] : [EOL] self . task_log ( [string] , self . uuids ) [EOL] break [EOL] else : [EOL] await asyncio . sleep ( self . config [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.list$ 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 $typing.Dict[unknown,builtins.str]$ 0 $typing.list$ 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.list$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] [EOL] from immutabledict import immutabledict [EOL] from scriptworker_client . constants import STATUSES [EOL] [EOL] MAX_CLAIM_WORK_TASKS = [number] [EOL] [EOL] DEFAULT_CONFIG = immutabledict ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : os . path . join ( os . getcwd ( ) , [string] ) , [string] : os . path . join ( os . getcwd ( ) , [string] ) , [string] : os . environ . get ( [string] , [string] ) , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , [string] : False , [string] : ( [string] , ) , [string] : [string] , [string] : [string] , [string] : [number] , } ) [EOL] [EOL] [EOL] [comment] [EOL] def get_reversed_statuses ( ) : [EOL] [docstring] [EOL] _rev = { v : k for k , v in STATUSES . items ( ) } [EOL] _rev . update ( { - [number] : [string] , - [number] : [string] } ) [EOL] return immutabledict ( _rev ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import arrow [EOL] [EOL] [EOL] def integration_create_task_payload ( config , task_group_id , scopes = None , task_payload = None , task_extra = None ) : [EOL] [docstring] [EOL] now = arrow . utcnow ( ) [EOL] deadline = now . shift ( hours = [number] ) [EOL] expires = now . shift ( days = [number] ) [EOL] scopes = scopes or [ ] [EOL] task_payload = task_payload or { } [EOL] task_extra = task_extra or { } [EOL] return { [string] : config [ [string] ] , [string] : [string] , [string] : config [ [string] ] , [string] : task_group_id , [string] : [ ] , [string] : [string] , [string] : [ ] , [string] : [string] , [string] : [number] , [string] : now . isoformat ( ) , [string] : deadline . isoformat ( ) , [string] : expires . isoformat ( ) , [string] : scopes , [string] : task_payload , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { } , [string] : task_extra , } [EOL] [EOL] [EOL] async def noop_async ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] def noop_sync ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] def create_async ( result = None ) : [EOL] async def fn ( * args , ** kwargs ) : [EOL] return result [EOL] [EOL] return fn [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import json [EOL] import logging [EOL] import os [EOL] from copy import deepcopy [EOL] [EOL] import pytest [EOL] from immutabledict import immutabledict [EOL] [EOL] import notarization_poller . config as npconfig [EOL] from notarization_poller . constants import DEFAULT_CONFIG [EOL] from notarization_poller . exceptions import ConfigError [EOL] [EOL] [EOL] [comment] [EOL] def close_handlers ( log_name = None ) : [EOL] log_name = log_name or __name__ . split ( [string] ) [ [number] ] [EOL] log = logging . getLogger ( log_name ) [EOL] handlers = log . handlers [ : ] [EOL] for handler in handlers : [EOL] handler . close ( ) [EOL] log . removeHandler ( handler ) [EOL] log . addHandler ( logging . NullHandler ( ) ) [EOL] [EOL] [EOL] [comment] [EOL] def test_update_logging_config_verbose ( config ) : [EOL] config [ [string] ] = True [EOL] npconfig . update_logging_config ( config , log_name = config [ [string] ] ) [EOL] log = logging . getLogger ( config [ [string] ] ) [EOL] assert log . level == logging . DEBUG [EOL] assert len ( log . handlers ) == [number] [EOL] close_handlers ( log_name = config [ [string] ] ) [EOL] [EOL] [EOL] def test_update_logging_config_verbose_existing_handler ( config ) : [EOL] log = logging . getLogger ( config [ [string] ] ) [EOL] log . addHandler ( logging . NullHandler ( ) ) [EOL] log . addHandler ( logging . NullHandler ( ) ) [EOL] config [ [string] ] = True [EOL] npconfig . update_logging_config ( config , log_name = config [ [string] ] ) [EOL] assert log . level == logging . DEBUG [EOL] assert len ( log . handlers ) == [number] [EOL] close_handlers ( log_name = config [ [string] ] ) [EOL] [EOL] [EOL] def test_update_logging_config_not_verbose ( config ) : [EOL] config [ [string] ] = False [EOL] npconfig . update_logging_config ( config , log_name = config [ [string] ] ) [EOL] log = logging . getLogger ( config [ [string] ] ) [EOL] assert log . level == logging . INFO [EOL] assert len ( log . handlers ) == [number] [EOL] close_handlers ( log_name = config [ [string] ] ) [EOL] [EOL] [EOL] def test_watched_log_file ( config ) : [EOL] config [ [string] ] = True [EOL] config [ [string] ] = [string] [EOL] npconfig . update_logging_config ( config , log_name = config [ [string] ] ) [EOL] path = os . path . join ( config [ [string] ] , [string] ) [EOL] log = logging . getLogger ( config [ [string] ] ) [EOL] log . info ( [string] ) [EOL] os . rename ( path , [string] . format ( path ) ) [EOL] log . info ( [string] ) [EOL] with open ( path , [string] ) as fh : [EOL] assert fh . read ( ) . rstrip ( ) == [string] [EOL] close_handlers ( log_name = config [ [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] def test_get_config_from_cmdln ( ) : [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] c = deepcopy ( dict ( DEFAULT_CONFIG ) ) [EOL] with open ( path ) as fh : [EOL] c . update ( json . load ( fh ) ) [EOL] expected_config = immutabledict ( c ) [EOL] [EOL] config = npconfig . get_config_from_cmdln ( [ path ] ) [EOL] assert config == expected_config [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) , None ) , ( os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) , ConfigError ) ) , ) def test_validate_config ( path , raises ) : [EOL] if raises : [EOL] with pytest . raises ( raises ) : [EOL] npconfig . get_config_from_cmdln ( [ path ] ) [EOL] else : [EOL] npconfig . get_config_from_cmdln ( [ path ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] import os [EOL] from copy import deepcopy [EOL] [EOL] import pytest [EOL] from scriptworker_client . utils import makedirs [EOL] [EOL] from notarization_poller . constants import DEFAULT_CONFIG [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def config ( tmpdir ) : [EOL] _config = deepcopy ( dict ( DEFAULT_CONFIG ) ) [EOL] with open ( os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) ) as fh : [EOL] _config . update ( json . load ( fh ) ) [EOL] _config [ [string] ] = os . path . join ( str ( tmpdir ) , [string] ) [EOL] _config [ [string] ] = os . path . join ( str ( tmpdir ) , [string] ) [EOL] _config [ [string] ] = os . path . join ( str ( tmpdir ) , [string] ) [EOL] for name in ( [string] , [string] , [string] ) : [EOL] makedirs ( _config [ name ] ) [EOL] yield _config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Coroutine , Any , Union , Dict , List [EOL] import typing [EOL] import asyncio [EOL] [docstring] [EOL] import asyncio [EOL] import json [EOL] import os [EOL] import signal [EOL] import sys [EOL] from copy import deepcopy [EOL] [EOL] import arrow [EOL] import pytest [EOL] from taskcluster . exceptions import TaskclusterRestFailure [EOL] [EOL] import notarization_poller . worker as worker [EOL] from notarization_poller . exceptions import WorkerError [EOL] from notarization_poller . worker import RunTasks [EOL] [EOL] from . import noop_async [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_claim_work ( raises , config , mocker ) : [EOL] async def foo ( * args ) : [EOL] raise TaskclusterRestFailure ( [string] , None , status_code = [number] ) [EOL] [EOL] queue = mocker . MagicMock ( ) [EOL] if raises : [EOL] queue . claimWork = foo [EOL] else : [EOL] queue . claimWork = noop_async [EOL] assert await worker . claim_work ( config , queue ) is None [EOL] [EOL] [EOL] [comment] [EOL] def test_main ( mocker , config , event_loop ) : [EOL] async def foo ( * args ) : [EOL] raise WorkerError ( [string] ) [EOL] [EOL] fake_run_tasks = mocker . MagicMock ( ) [EOL] fake_run_tasks . invoke = foo [EOL] mocker . patch . object ( worker , [string] , return_value = fake_run_tasks ) [EOL] [EOL] tmp = os . path . join ( config [ [string] ] , [string] ) [EOL] with open ( tmp , [string] ) as fh : [EOL] json . dump ( config , fh ) [EOL] mocker . patch . object ( sys , [string] , new = [ [string] , tmp ] ) [EOL] with pytest . raises ( WorkerError ) : [EOL] worker . main ( event_loop = event_loop ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_main_running_sigterm ( mocker , config , event_loop , running ) : [EOL] [docstring] [EOL] run_tasks_cancelled = event_loop . create_future ( ) [EOL] [EOL] class MockRunTasks : [EOL] async def cancel ( * args ) : [EOL] run_tasks_cancelled . set_result ( True ) [EOL] [EOL] async def invoke ( * args ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGTERM ) [EOL] [EOL] mrt = MockRunTasks ( ) [EOL] [EOL] mocker . patch . object ( worker , [string] , return_value = mrt ) [EOL] [EOL] tmp = os . path . join ( config [ [string] ] , [string] ) [EOL] with open ( tmp , [string] ) as fh : [EOL] json . dump ( config , fh ) [EOL] mocker . patch . object ( sys , [string] , new = [ [string] , tmp ] ) [EOL] worker . main ( event_loop = event_loop ) [EOL] [EOL] if running : [EOL] event_loop . run_until_complete ( run_tasks_cancelled ) [EOL] assert run_tasks_cancelled . result ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_main_running_sigusr1 ( mocker , config , event_loop , running ) : [EOL] [docstring] [EOL] run_tasks_cancelled = event_loop . create_future ( ) [EOL] [EOL] class MockRunTasks : [EOL] is_stopped = False [EOL] [EOL] async def cancel ( * args ) : [EOL] run_tasks_cancelled . set_result ( True ) [EOL] [EOL] async def invoke ( * args ) : [EOL] os . kill ( os . getpid ( ) , signal . SIGUSR1 ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] mrt = MockRunTasks ( ) [EOL] mrt . running_tasks = [ ] [EOL] if running : [EOL] fake_task1 = mocker . MagicMock ( ) [EOL] fake_task1 . main_fut = noop_async ( ) [EOL] fake_task2 = mocker . MagicMock ( ) [EOL] fake_task2 . main_fut = noop_async ( ) [EOL] mrt . running_tasks = [ fake_task1 , fake_task2 ] [EOL] [EOL] tmp = os . path . join ( config [ [string] ] , [string] ) [EOL] with open ( tmp , [string] ) as fh : [EOL] json . dump ( config , fh ) [EOL] mocker . patch . object ( worker , [string] , return_value = mrt ) [EOL] mocker . patch . object ( sys , [string] , new = [ [string] , tmp ] ) [EOL] worker . main ( event_loop = event_loop ) [EOL] [EOL] assert not run_tasks_cancelled . done ( ) [EOL] assert mrt . is_stopped [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_mocker_invoke ( config , mocker ) : [EOL] task = { [string] : [string] , [string] : { [string] : [string] } , [string] : { [string] : True } } [EOL] rt = worker . RunTasks ( config ) [EOL] [EOL] async def claim_work ( * args , ** kwargs ) : [EOL] return { [string] : [ deepcopy ( task ) ] } [EOL] [EOL] async def fake_sleep ( * args , ** kwargs ) : [EOL] await asyncio . sleep ( [number] ) [EOL] await rt . cancel ( ) [EOL] [EOL] fake_task = mocker . MagicMock ( ) [EOL] fake_task . complete = False [EOL] fake_task . main_fut = asyncio . ensure_future ( noop_async ( ) ) [EOL] [EOL] mocker . patch . object ( worker , [string] , new = claim_work ) [EOL] mocker . patch . object ( worker , [string] , return_value = fake_task ) [EOL] mocker . patch . object ( worker , [string] ) [EOL] mocker . patch . object ( worker , [string] , new = fake_sleep ) [EOL] await rt . invoke ( ) [EOL] assert rt . is_cancelled [EOL] assert len ( rt . running_tasks ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_mocker_invoke_noop ( config , mocker ) : [EOL] config [ [string] ] = [number] [EOL] config [ [string] ] = [number] [EOL] rt = RunTasks ( config ) [EOL] rt . running_tasks = [ ] [EOL] [comment] [EOL] [comment] [EOL] rt . last_claim_work = arrow . utcnow ( ) [EOL] [EOL] async def cancel_rt ( ) : [EOL] await rt . cancel ( ) [EOL] [EOL] tasks = [ asyncio . ensure_future ( rt . invoke ( ) ) , asyncio . ensure_future ( cancel_rt ( ) ) ] [EOL] await asyncio . wait ( tasks ) [EOL] assert rt . is_cancelled [EOL] assert len ( rt . running_tasks ) == [number] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_prune_running_tasks ( config , mocker ) : [EOL] task1 = mocker . MagicMock ( ) [EOL] task1 . complete = True [EOL] task2 = mocker . MagicMock ( ) [EOL] task2 . complete = False [EOL] task3 = mocker . MagicMock ( ) [EOL] task3 . complete = False [EOL] task4 = mocker . MagicMock ( ) [EOL] task4 . complete = True [EOL] rt = RunTasks ( config ) [EOL] rt . running_tasks = [ task1 , task2 , task3 , task4 ] [EOL] await rt . prune_running_tasks ( ) [EOL] assert rt . running_tasks == [ task2 , task3 ] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_run_cancellable ( config ) : [EOL] async def return_true ( ) : [EOL] return True [EOL] [EOL] rt = RunTasks ( config ) [EOL] future1 = return_true ( ) [EOL] result = await rt . _run_cancellable ( future1 ) [EOL] assert result is True [EOL] [EOL] [comment] [EOL] rt . is_cancelled = True [EOL] future2 = return_true ( ) [EOL] result = await rt . _run_cancellable ( future2 ) [EOL] assert result is None [EOL] await future2 [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [docstring] [EOL] from immutabledict import immutabledict [EOL] [EOL] import notarization_poller . constants as constants [EOL] [EOL] [EOL] def test_get_reversed_statuses ( ) : [EOL] assert constants . get_reversed_statuses ( ) == immutabledict ( { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , - [number] : [string] , - [number] : [string] , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from scriptworker . constants import STATUSES [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] [EOL] class SigningServerError ( ScriptWorkerTaskException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg ) : [EOL] [docstring] [EOL] super ( SigningServerError , self ) . __init__ ( msg , exit_code = STATUSES [ [string] ] ) [EOL] [EOL] [EOL] class SigningScriptError ( ScriptWorkerTaskException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg ) : [EOL] [docstring] [EOL] super ( SigningScriptError , self ) . __init__ ( msg , exit_code = STATUSES [ [string] ] ) [EOL] [EOL] [EOL] class FailedSubprocess ( ScriptWorkerTaskException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg ) : [EOL] [docstring] [EOL] super ( FailedSubprocess , self ) . __init__ ( msg , exit_code = STATUSES [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Set , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] [EOL] from immutabledict import immutabledict [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] from scriptworker . utils import get_single_item_from_sequence [EOL] [EOL] from signingscript . sign import ( sign_authenticode_zip , sign_file , sign_gpg , sign_gpg_with_autograph , sign_jar , sign_macapp , sign_mar384_with_autograph_hash , sign_omnija , sign_widevine , sign_xpi , ) [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] FORMAT_TO_SIGNING_FUNCTION = immutabledict ( { [string] : sign_jar , [string] : sign_mar384_with_autograph_hash , [string] : sign_mar384_with_autograph_hash , [string] : sign_gpg , [string] : sign_gpg_with_autograph , [string] : sign_jar , [string] : sign_jar , [string] : sign_macapp , [string] : sign_widevine , [string] : sign_widevine , [string] : sign_omnija , [string] : sign_xpi , [string] : sign_authenticode_zip , [string] : sign_authenticode_zip , [string] : sign_authenticode_zip , [string] : sign_xpi , [string] : sign_xpi , [string] : sign_file , } ) [EOL] [EOL] [EOL] [comment] [EOL] def task_cert_type ( context ) : [EOL] [docstring] [EOL] if not context . task or not context . task [ [string] ] : [EOL] raise TaskVerificationError ( [string] ) [EOL] [EOL] prefixes = _get_cert_prefixes ( context ) [EOL] scopes = _extract_scopes_from_unique_prefix ( scopes = context . task [ [string] ] , prefixes = prefixes ) [EOL] return get_single_item_from_sequence ( scopes , condition = lambda _ : True , ErrorClass = TaskVerificationError , no_item_error_message = [string] . format ( prefixes ) , too_many_item_error_message = [string] , ) [EOL] [EOL] [EOL] [comment] [EOL] def task_signing_formats ( context ) : [EOL] [docstring] [EOL] formats = set ( ) [EOL] for u in context . task . get ( [string] , { } ) . get ( [string] , [ ] ) : [EOL] formats . update ( u [ [string] ] ) [EOL] return formats [EOL] [EOL] [EOL] def _extract_scopes_from_unique_prefix ( scopes , prefixes ) : [EOL] scopes = [ scope for scope in scopes for prefix in prefixes if scope . startswith ( prefix ) ] [EOL] _check_scopes_exist_and_all_have_the_same_prefix ( scopes , prefixes ) [EOL] return scopes [EOL] [EOL] [EOL] def _get_cert_prefixes ( context ) : [EOL] return _get_scope_prefixes ( context , [string] ) [EOL] [EOL] [EOL] def _get_scope_prefixes ( context , sub_namespace ) : [EOL] prefixes = context . config [ [string] ] [EOL] prefixes = [ prefix if prefix . endswith ( [string] ) else [string] . format ( prefix ) for prefix in prefixes ] [EOL] return [ [string] . format ( prefix , sub_namespace ) for prefix in prefixes ] [EOL] [EOL] [EOL] def _check_scopes_exist_and_all_have_the_same_prefix ( scopes , prefixes ) : [EOL] for prefix in prefixes : [EOL] if all ( scope . startswith ( prefix ) for scope in scopes ) : [EOL] break [EOL] else : [EOL] raise TaskVerificationError ( [string] [string] . format ( scopes , prefixes ) ) [EOL] [EOL] [EOL] [comment] [EOL] async def sign ( context , path , signing_formats , ** kwargs ) : [EOL] [docstring] [EOL] output = path [EOL] [comment] [EOL] for fmt in signing_formats : [EOL] signing_func = _get_signing_function_from_format ( fmt ) [EOL] try : [EOL] size = os . path . getsize ( output ) [EOL] except OSError : [EOL] size = [string] [EOL] log . info ( [string] , size , output , fmt ) [EOL] output = await signing_func ( context , output , fmt , ** kwargs ) [EOL] [comment] [EOL] if not isinstance ( output , ( tuple , list ) ) : [EOL] output = [ output ] [EOL] return output [EOL] [EOL] [EOL] def _get_signing_function_from_format ( fmt ) : [EOL] return FORMAT_TO_SIGNING_FUNCTION . get ( fmt . split ( [string] ) [ [number] ] , FORMAT_TO_SIGNING_FUNCTION [ [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] def _sort_formats ( formats ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] for fmt in ( [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] if fmt in formats : [EOL] formats . remove ( fmt ) [EOL] formats . append ( fmt ) [EOL] return formats [EOL] [EOL] [EOL] [comment] [EOL] def build_filelist_dict ( context ) : [EOL] [docstring] [EOL] filelist_dict = { } [EOL] messages = [ ] [EOL] for artifact_dict in context . task [ [string] ] [ [string] ] : [EOL] authenticode_comment = artifact_dict . get ( [string] ) [EOL] if authenticode_comment and not any ( [string] in fmt for fmt in artifact_dict [ [string] ] ) : [EOL] raise TaskVerificationError ( [string] ) [EOL] [EOL] if authenticode_comment and not any ( path . endswith ( [string] ) for path in artifact_dict [ [string] ] ) : [EOL] [comment] [EOL] raise TaskVerificationError ( [string] ) [EOL] for path in artifact_dict [ [string] ] : [EOL] full_path = os . path . join ( context . config [ [string] ] , [string] , artifact_dict [ [string] ] , path ) [EOL] if not os . path . exists ( full_path ) : [EOL] messages . append ( [string] . format ( full_path ) ) [EOL] filelist_dict [ path ] = { [string] : full_path , [string] : _sort_formats ( artifact_dict [ [string] ] ) } [EOL] if authenticode_comment : [EOL] filelist_dict [ path ] [ [string] ] = authenticode_comment [EOL] [EOL] if messages : [EOL] raise TaskVerificationError ( messages ) [EOL] return filelist_dict [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , IO , Pattern , Any , Literal , Union , Dict , List [EOL] import typing [EOL] import hashlib [EOL] import logging [EOL] import typing_extensions [EOL] import tarfile [EOL] import zipfile [EOL] import io [EOL] [docstring] [EOL] import asyncio [EOL] import base64 [EOL] import difflib [EOL] import fnmatch [EOL] import glob [EOL] import hashlib [EOL] import json [EOL] import logging [EOL] import os [EOL] import re [EOL] import resource [EOL] import shutil [EOL] import subprocess [EOL] import sys [EOL] import tarfile [EOL] import tempfile [EOL] import time [EOL] import zipfile [EOL] from functools import wraps [EOL] from io import BytesIO [EOL] [EOL] import mohawk [EOL] import winsign . sign [EOL] from mardor . reader import MarReader [EOL] from mardor . writer import add_signature_block [EOL] from scriptworker . utils import get_single_item_from_sequence , makedirs , raise_future_exceptions , retry_async , rm [EOL] from winsign . crypto import load_pem_certs [EOL] [EOL] from signingscript import task , utils [EOL] from signingscript . createprecomplete import generate_precomplete [EOL] from signingscript . exceptions import SigningScriptError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] try : [EOL] [comment] [EOL] import widevine [EOL] except ImportError : [EOL] log . exception ( [string] ) [EOL] widevine = None [EOL] [EOL] sys . path . append ( os . path . abspath ( os . path . join ( os . path . realpath ( os . path . dirname ( __file__ ) ) , [string] , [string] ) ) ) [comment] [EOL] [EOL] from mozpack import mozjar [comment] [EOL] [EOL] _ZIP_ALIGNMENT = [string] [comment] [EOL] [EOL] [comment] [EOL] _WIDEVINE_BLESSED_FILENAMES = ( [string] , [string] , ) [EOL] [comment] [EOL] _WIDEVINE_NONBLESSED_FILENAMES = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [comment] [EOL] _DEFAULT_MAR_VERIFY_KEYS = { [string] : { [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , } [EOL] [EOL] [comment] [EOL] LANGPACK_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] def get_rss ( ) : [EOL] [docstring] [EOL] return resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss [EOL] [EOL] [EOL] def time_async_function ( f ) : [EOL] [docstring] [EOL] [comment] [EOL] @ wraps ( f ) async def wrapped ( * args , ** kwargs ) : [EOL] start = time . time ( ) [EOL] start_rss = get_rss ( ) [EOL] try : [EOL] return await f ( * args , ** kwargs ) [EOL] finally : [EOL] rss = get_rss ( ) [EOL] log . debug ( [string] , f . __name__ , time . time ( ) - start , rss , rss - start_rss ) [EOL] [EOL] return wrapped [EOL] [EOL] [EOL] def time_function ( f ) : [EOL] [docstring] [EOL] [comment] [EOL] @ wraps ( f ) def wrapped ( * args , ** kwargs ) : [EOL] start = time . time ( ) [EOL] start_rss = get_rss ( ) [EOL] try : [EOL] return f ( * args , ** kwargs ) [EOL] finally : [EOL] rss = get_rss ( ) [EOL] log . debug ( [string] , f . __name__ , time . time ( ) - start , rss , rss - start_rss ) [EOL] [EOL] return wrapped [EOL] [EOL] [EOL] [comment] [EOL] def get_autograph_config ( autograph_configs , cert_type , signing_formats , raise_on_empty = False ) : [EOL] [docstring] [EOL] for a in autograph_configs . get ( cert_type , [ ] ) : [EOL] if a and ( set ( a . formats ) & set ( signing_formats ) ) : [EOL] return a [EOL] [EOL] if raise_on_empty : [EOL] raise SigningScriptError ( f" [string] { cert_type } [string] { signing_formats }" ) [EOL] return None [EOL] [EOL] [EOL] [comment] [EOL] async def sign_file ( context , from_ , fmt , to = None , ** kwargs ) : [EOL] [docstring] [EOL] log . info ( [string] , from_ , fmt ) [EOL] await sign_file_with_autograph ( context , from_ , fmt , to = to ) [EOL] return to or from_ [EOL] [EOL] [EOL] [comment] [EOL] async def sign_gpg ( context , from_ , fmt , ** kwargs ) : [EOL] [docstring] [EOL] to = f"{ from_ } [string] " [EOL] await sign_file ( context , from_ , fmt , to = to ) [EOL] return [ from_ , to ] [EOL] [EOL] [EOL] [comment] [EOL] async def sign_jar ( context , from_ , fmt , ** kwargs ) : [EOL] [docstring] [EOL] await sign_file ( context , from_ , fmt ) [EOL] await zip_align_apk ( context , from_ ) [EOL] return from_ [EOL] [EOL] [EOL] [comment] [EOL] async def sign_macapp ( context , from_ , fmt , ** kwargs ) : [EOL] [docstring] [EOL] file_base , file_extension = os . path . splitext ( from_ ) [EOL] if file_extension == [string] : [EOL] await _convert_dmg_to_tar_gz ( context , from_ ) [EOL] from_ = [string] . format ( file_base ) [EOL] await sign_file ( context , from_ , fmt ) [EOL] return from_ [EOL] [EOL] [EOL] [comment] [EOL] async def sign_xpi ( context , orig_path , fmt , ** kwargs ) : [EOL] [docstring] [EOL] file_base , file_extension = os . path . splitext ( orig_path ) [EOL] [EOL] if file_extension not in ( [string] , [string] ) : [EOL] raise SigningScriptError ( [string] ) [EOL] [EOL] ext_id = _extension_id ( orig_path , fmt ) [EOL] log . info ( [string] . format ( orig_path , id ) ) [EOL] kwargs = { [string] : ext_id } [EOL] [comment] [EOL] await sign_file_with_autograph ( context , orig_path , fmt , ** kwargs ) [EOL] return orig_path [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def sign_widevine ( context , orig_path , fmt , ** kwargs ) : [EOL] [docstring] [EOL] file_base , file_extension = os . path . splitext ( orig_path ) [EOL] [comment] [EOL] if file_extension == [string] : [EOL] await _convert_dmg_to_tar_gz ( context , orig_path ) [EOL] orig_path = [string] . format ( file_base ) [EOL] ext_to_fn = { [string] : sign_widevine_zip , [string] : sign_widevine_tar , [string] : sign_widevine_tar } [EOL] for ext , signing_func in ext_to_fn . items ( ) : [EOL] if orig_path . endswith ( ext ) : [EOL] return await signing_func ( context , orig_path , fmt ) [EOL] raise SigningScriptError ( [string] . format ( orig_path ) ) [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def sign_widevine_zip ( context , orig_path , fmt ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tmp_dir = tempfile . mkdtemp ( prefix = [string] , dir = context . config [ [string] ] ) [EOL] [comment] [EOL] all_files = await _get_zipfile_files ( orig_path ) [EOL] files_to_sign = _get_widevine_signing_files ( all_files ) [EOL] log . debug ( [string] , files_to_sign ) [EOL] if files_to_sign : [EOL] [comment] [EOL] [comment] [EOL] all_files = await _extract_zipfile ( context , orig_path , tmp_dir = tmp_dir ) [EOL] tasks = [ ] [EOL] [comment] [EOL] for from_ , fmt in files_to_sign . items ( ) : [EOL] from_ = os . path . join ( tmp_dir , from_ ) [EOL] to = f"{ from_ } [string] " [EOL] tasks . append ( asyncio . ensure_future ( sign_widevine_with_autograph ( context , from_ , [string] in fmt , to = to ) ) ) [EOL] all_files . append ( to ) [EOL] await raise_future_exceptions ( tasks ) [EOL] remove_extra_files ( tmp_dir , all_files ) [EOL] [comment] [EOL] [comment] [EOL] _run_generate_precomplete ( context , tmp_dir ) [EOL] await _create_zipfile ( context , orig_path , all_files , mode = [string] , tmp_dir = tmp_dir ) [EOL] return orig_path [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def sign_widevine_tar ( context , orig_path , fmt ) : [EOL] [docstring] [EOL] _ , compression = os . path . splitext ( orig_path ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tmp_dir = tempfile . mkdtemp ( prefix = [string] , dir = context . config [ [string] ] ) [EOL] [comment] [EOL] all_files = await _get_tarfile_files ( orig_path , compression ) [EOL] files_to_sign = _get_widevine_signing_files ( all_files ) [EOL] log . debug ( [string] , files_to_sign ) [EOL] if files_to_sign : [EOL] [comment] [EOL] [comment] [EOL] all_files = await _extract_tarfile ( context , orig_path , compression , tmp_dir = tmp_dir ) [EOL] tasks = [ ] [EOL] [comment] [EOL] for from_ , fmt in files_to_sign . items ( ) : [EOL] from_ = os . path . join ( tmp_dir , from_ ) [EOL] [comment] [EOL] if not os . path . isfile ( from_ ) : [EOL] continue [EOL] [comment] [EOL] to = _get_mac_sigpath ( from_ ) [EOL] log . debug ( [string] , to ) [EOL] makedirs ( os . path . dirname ( to ) ) [EOL] tasks . append ( asyncio . ensure_future ( sign_widevine_with_autograph ( context , from_ , [string] in fmt , to = to ) ) ) [EOL] all_files . append ( to ) [EOL] await raise_future_exceptions ( tasks ) [EOL] remove_extra_files ( tmp_dir , all_files ) [EOL] [comment] [EOL] [comment] [EOL] _run_generate_precomplete ( context , tmp_dir ) [EOL] await _create_tarfile ( context , orig_path , all_files , compression , tmp_dir = tmp_dir ) [EOL] return orig_path [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def sign_omnija ( context , orig_path , fmt , ** kwargs ) : [EOL] [docstring] [EOL] file_base , file_extension = os . path . splitext ( orig_path ) [EOL] [comment] [EOL] if file_extension == [string] : [EOL] await _convert_dmg_to_tar_gz ( context , orig_path ) [EOL] orig_path = [string] . format ( file_base ) [EOL] ext_to_fn = { [string] : sign_omnija_zip , [string] : sign_omnija_tar , [string] : sign_omnija_tar } [EOL] for ext , signing_func in ext_to_fn . items ( ) : [EOL] if orig_path . endswith ( ext ) : [EOL] return await signing_func ( context , orig_path , fmt ) [EOL] raise SigningScriptError ( [string] . format ( orig_path ) ) [EOL] [EOL] [EOL] [comment] [EOL] async def sign_omnija_zip ( context , orig_path , fmt ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tmp_dir = tempfile . mkdtemp ( prefix = [string] , dir = context . config [ [string] ] ) [EOL] [comment] [EOL] all_files = await _get_zipfile_files ( orig_path ) [EOL] files_to_sign = _get_omnija_signing_files ( all_files ) [EOL] log . debug ( [string] , files_to_sign ) [EOL] if files_to_sign : [EOL] all_files = await _extract_zipfile ( context , orig_path , tmp_dir = tmp_dir ) [EOL] tasks = [ ] [EOL] [comment] [EOL] for from_ , fmt in files_to_sign . items ( ) : [EOL] from_ = os . path . join ( tmp_dir , from_ ) [EOL] tasks . append ( asyncio . ensure_future ( sign_omnija_with_autograph ( context , from_ ) ) ) [EOL] await raise_future_exceptions ( tasks ) [EOL] await _create_zipfile ( context , orig_path , all_files , mode = [string] , tmp_dir = tmp_dir ) [EOL] return orig_path [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def sign_omnija_tar ( context , orig_path , fmt ) : [EOL] [docstring] [EOL] _ , compression = os . path . splitext ( orig_path ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tmp_dir = tempfile . mkdtemp ( prefix = [string] , dir = context . config [ [string] ] ) [EOL] [comment] [EOL] all_files = await _get_tarfile_files ( orig_path , compression ) [EOL] files_to_sign = _get_omnija_signing_files ( all_files ) [EOL] log . debug ( [string] , files_to_sign ) [EOL] if files_to_sign : [EOL] [comment] [EOL] [comment] [EOL] all_files = await _extract_tarfile ( context , orig_path , compression , tmp_dir = tmp_dir ) [EOL] tasks = [ ] [EOL] [comment] [EOL] for from_ , fmt in files_to_sign . items ( ) : [EOL] from_ = os . path . join ( tmp_dir , from_ ) [EOL] [comment] [EOL] if not os . path . isfile ( from_ ) : [EOL] continue [EOL] tasks . append ( asyncio . ensure_future ( sign_omnija_with_autograph ( context , from_ ) ) ) [EOL] await raise_future_exceptions ( tasks ) [EOL] await _create_tarfile ( context , orig_path , all_files , compression , tmp_dir = tmp_dir ) [EOL] return orig_path [EOL] [EOL] [EOL] [comment] [EOL] def _should_sign_windows ( filename ) : [EOL] [docstring] [EOL] [comment] [EOL] _dont_sign = [ [string] , [string] , [string] , [string] , [string] ] [EOL] ext = os . path . splitext ( filename ) [ [number] ] [EOL] b = os . path . basename ( filename ) [EOL] if ext in ( [string] , [string] , [string] , [string] ) and not any ( fnmatch . fnmatch ( b , p ) for p in _dont_sign ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def _extension_id ( filename , fmt ) : [EOL] [docstring] [EOL] xpi = zipfile . ZipFile ( filename , [string] ) [EOL] manifest = { } [EOL] for manifest_name in ( [string] , [string] ) : [EOL] try : [EOL] with xpi . open ( manifest_name , [string] ) as f : [EOL] manifest = json . load ( f ) [EOL] break [EOL] except KeyError : [EOL] log . debug ( [string] . format ( manifest_name , filename ) ) [EOL] if not manifest . get ( [string] , { } ) . get ( [string] , { } ) . get ( [string] ) : [EOL] raise SigningScriptError ( [string] . format ( filename ) ) [EOL] if [string] in fmt and not ( [string] in manifest and [string] in manifest and LANGPACK_RE . match ( manifest [ [string] ] [ [string] ] [ [string] ] ) and filename . endswith ( [string] ) ) : [EOL] raise SigningScriptError ( [string] . format ( filename ) ) [EOL] return manifest [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] def _get_mac_sigpath ( from_ ) : [EOL] [docstring] [EOL] to = from_ [EOL] if [string] in from_ : [EOL] parts = from_ . split ( [string] ) [EOL] parts . reverse ( ) [EOL] i = parts . index ( [string] ) [EOL] parts [ i ] = [string] [EOL] parts . reverse ( ) [EOL] to = [string] . join ( parts ) [EOL] log . debug ( [string] . format ( from_ , to ) ) [EOL] return [string] . format ( to ) [EOL] [EOL] [EOL] [comment] [EOL] def _get_widevine_signing_files ( file_list ) : [EOL] [docstring] [EOL] files = { } [EOL] for filename in file_list : [EOL] fmt = None [EOL] base_filename = os . path . basename ( filename ) [EOL] if base_filename in _WIDEVINE_BLESSED_FILENAMES : [EOL] fmt = [string] [EOL] elif base_filename in _WIDEVINE_NONBLESSED_FILENAMES : [EOL] fmt = [string] [EOL] if fmt : [EOL] log . debug ( [string] . format ( filename , fmt ) ) [EOL] sigpath = _get_mac_sigpath ( filename ) [EOL] if sigpath not in file_list : [EOL] files [ filename ] = fmt [EOL] else : [EOL] log . debug ( [string] . format ( filename ) ) [EOL] return files [EOL] [EOL] [EOL] [comment] [EOL] def _get_omnija_signing_files ( file_list ) : [EOL] [docstring] [EOL] files = { } [EOL] for filename in file_list : [EOL] fmt = None [EOL] base_filename = os . path . basename ( filename ) [EOL] if base_filename in { [string] } : [EOL] fmt = [string] [EOL] if fmt : [EOL] log . debug ( [string] . format ( filename , fmt ) ) [EOL] files [ filename ] = fmt [EOL] return files [EOL] [EOL] [EOL] [comment] [EOL] def _run_generate_precomplete ( context , tmp_dir ) : [EOL] [docstring] [EOL] log . info ( [string] ) [EOL] path = _ensure_one_precomplete ( tmp_dir , [string] ) [EOL] with open ( path , [string] ) as fh : [EOL] before = fh . readlines ( ) [EOL] generate_precomplete ( os . path . dirname ( path ) ) [EOL] path = _ensure_one_precomplete ( tmp_dir , [string] ) [EOL] with open ( path , [string] ) as fh : [EOL] after = fh . readlines ( ) [EOL] [comment] [EOL] diff_path = os . path . join ( context . config [ [string] ] , [string] ) [EOL] with open ( diff_path , [string] ) as fh : [EOL] for line in difflib . ndiff ( before , after ) : [EOL] fh . write ( line ) [EOL] utils . copy_to_dir ( diff_path , context . config [ [string] ] , target = [string] ) [EOL] [EOL] [EOL] [comment] [EOL] def _ensure_one_precomplete ( tmp_dir , adj ) : [EOL] [docstring] [EOL] return get_single_item_from_sequence ( glob . glob ( os . path . join ( tmp_dir , [string] , [string] ) , recursive = True ) , condition = lambda _ : True , ErrorClass = SigningScriptError , no_item_error_message = [string] . format ( tmp_dir ) , too_many_item_error_message = [string] . format ( adj , tmp_dir ) , ) [EOL] [EOL] [EOL] [comment] [EOL] def remove_extra_files ( top_dir , file_list ) : [EOL] [docstring] [EOL] all_files = [ os . path . realpath ( f ) for f in glob . glob ( os . path . join ( top_dir , [string] , [string] ) , recursive = True ) ] [EOL] good_files = [ os . path . realpath ( f ) for f in file_list ] [EOL] extra_files = list ( set ( all_files ) - set ( good_files ) ) [EOL] for f in extra_files : [EOL] if os . path . isfile ( f ) : [EOL] log . warning ( [string] . format ( f ) ) [EOL] rm ( f ) [EOL] return extra_files [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def zip_align_apk ( context , abs_to ) : [EOL] [docstring] [EOL] original_apk_location = abs_to [EOL] zipalign_executable_location = context . config [ [string] ] [EOL] [EOL] with tempfile . TemporaryDirectory ( ) as temp_dir : [EOL] temp_apk_location = os . path . join ( temp_dir , [string] ) [EOL] [EOL] zipalign_command = [ zipalign_executable_location ] [EOL] if context . config [ [string] ] is True : [EOL] zipalign_command += [ [string] ] [EOL] [EOL] zipalign_command += [ _ZIP_ALIGNMENT , original_apk_location , temp_apk_location ] [EOL] await utils . execute_subprocess ( zipalign_command ) [EOL] shutil . move ( temp_apk_location , abs_to ) [EOL] [EOL] log . info ( [string] . format ( abs_to ) ) [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def _convert_dmg_to_tar_gz ( context , from_ ) : [EOL] [docstring] [EOL] work_dir = context . config [ [string] ] [EOL] abs_from = os . path . join ( work_dir , from_ ) [EOL] [comment] [EOL] to = re . sub ( [string] , [string] , from_ , flags = re . I ) [EOL] abs_to = os . path . join ( work_dir , to ) [EOL] dmg_executable_location = context . config [ [string] ] [EOL] hfsplus_executable_location = context . config [ [string] ] [EOL] [EOL] with tempfile . TemporaryDirectory ( ) as temp_dir : [EOL] app_dir = os . path . join ( temp_dir , [string] ) [EOL] utils . mkdir ( app_dir ) [EOL] undmg_cmd = [ dmg_executable_location , [string] , abs_from , [string] ] [EOL] await utils . execute_subprocess ( undmg_cmd , cwd = temp_dir , log_level = logging . DEBUG ) [EOL] hfsplus_cmd = [ hfsplus_executable_location , [string] , [string] , [string] , app_dir ] [EOL] await utils . execute_subprocess ( hfsplus_cmd , cwd = temp_dir , log_level = logging . DEBUG ) [EOL] tar_cmd = [ [string] , [string] , abs_to , [string] ] [EOL] await utils . execute_subprocess ( tar_cmd , cwd = app_dir ) [EOL] [EOL] return to [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def _get_zipfile_files ( from_ ) : [EOL] with zipfile . ZipFile ( from_ , mode = [string] ) as z : [EOL] files = z . namelist ( ) [EOL] return files [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def _extract_zipfile ( context , from_ , files = None , tmp_dir = None ) : [EOL] work_dir = context . config [ [string] ] [EOL] tmp_dir = tmp_dir or os . path . join ( work_dir , [string] ) [EOL] log . debug ( [string] . format ( files or [string] , from_ , tmp_dir ) ) [EOL] try : [EOL] extracted_files = [ ] [EOL] rm ( tmp_dir ) [EOL] utils . mkdir ( tmp_dir ) [EOL] with zipfile . ZipFile ( from_ , mode = [string] ) as z : [EOL] if files is not None : [EOL] for name in files : [EOL] z . extract ( name , path = tmp_dir ) [EOL] extracted_files . append ( os . path . join ( tmp_dir , name ) ) [EOL] else : [EOL] for name in z . namelist ( ) : [EOL] extracted_files . append ( os . path . join ( tmp_dir , name ) ) [EOL] z . extractall ( path = tmp_dir ) [EOL] return extracted_files [EOL] except Exception as e : [EOL] raise SigningScriptError ( e ) [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def _create_zipfile ( context , to , files , tmp_dir = None , mode = [string] ) : [EOL] work_dir = context . config [ [string] ] [EOL] tmp_dir = tmp_dir or os . path . join ( work_dir , [string] ) [EOL] try : [EOL] log . info ( [string] . format ( to ) ) [EOL] with zipfile . ZipFile ( to , mode = mode , compression = zipfile . ZIP_DEFLATED ) as z : [EOL] for f in files : [EOL] relpath = os . path . relpath ( f , tmp_dir ) [EOL] z . write ( f , arcname = relpath ) [EOL] return to [EOL] except Exception as e : [EOL] raise SigningScriptError ( e ) [EOL] [EOL] [EOL] [comment] [EOL] def _get_tarfile_compression ( compression ) : [EOL] compression = compression . lstrip ( [string] ) [EOL] if compression not in ( [string] , [string] ) : [EOL] raise SigningScriptError ( [string] . format ( compression ) ) [EOL] return compression [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def _get_tarfile_files ( from_ , compression ) : [EOL] compression = _get_tarfile_compression ( compression ) [EOL] with tarfile . open ( from_ , mode = [string] . format ( compression ) ) as t : [EOL] files = t . getmembers ( ) [EOL] return [ f . name for f in files if f . isfile ( ) ] [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def _extract_tarfile ( context , from_ , compression , tmp_dir = None ) : [EOL] work_dir = context . config [ [string] ] [EOL] tmp_dir = tmp_dir or os . path . join ( work_dir , [string] ) [EOL] compression = _get_tarfile_compression ( compression ) [EOL] try : [EOL] files = [ ] [EOL] rm ( tmp_dir ) [EOL] utils . mkdir ( tmp_dir ) [EOL] with tarfile . open ( from_ , mode = [string] . format ( compression ) ) as t : [EOL] t . extractall ( path = tmp_dir ) [EOL] for name in t . getnames ( ) : [EOL] path = os . path . join ( tmp_dir , name ) [EOL] os . path . isfile ( path ) and files . append ( path ) [EOL] return files [EOL] except Exception as e : [EOL] raise SigningScriptError ( e ) [EOL] [EOL] [EOL] [comment] [EOL] def _owner_filter ( tarinfo_obj ) : [EOL] [docstring] [EOL] tarinfo_obj . uid = [number] [EOL] tarinfo_obj . gid = [number] [EOL] tarinfo_obj . uname = [string] [EOL] tarinfo_obj . gname = [string] [EOL] return tarinfo_obj [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def _create_tarfile ( context , to , files , compression , tmp_dir = None ) : [EOL] work_dir = context . config [ [string] ] [EOL] tmp_dir = tmp_dir or os . path . join ( work_dir , [string] ) [EOL] compression = _get_tarfile_compression ( compression ) [EOL] try : [EOL] log . info ( [string] . format ( to ) ) [EOL] with tarfile . open ( to , mode = [string] . format ( compression ) ) as t : [EOL] for f in files : [EOL] relpath = os . path . relpath ( f , tmp_dir ) [EOL] t . add ( f , arcname = relpath , filter = _owner_filter ) [EOL] return to [EOL] except Exception as e : [EOL] raise SigningScriptError ( e ) [EOL] [EOL] [EOL] def write_signing_req_to_disk ( fp , signing_req ) : [EOL] [docstring] [EOL] fp . write ( [string] ) [EOL] for k , v in signing_req . items ( ) : [EOL] fp . write ( json . dumps ( k ) . encode ( [string] ) ) [EOL] fp . write ( [string] ) [EOL] if hasattr ( v , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] v . seek ( [number] ) [EOL] fp . write ( [string] ) [EOL] while True : [EOL] block = v . read ( [number] ) [EOL] if not block : [EOL] break [EOL] e = b64encode ( block ) . encode ( [string] ) [EOL] fp . write ( e ) [EOL] fp . write ( [string] ) [EOL] else : [EOL] fp . write ( json . dumps ( v ) . encode ( [string] ) ) [EOL] fp . write ( [string] ) [EOL] fp . seek ( - [number] , [number] ) [EOL] fp . write ( [string] ) [EOL] [EOL] [EOL] def get_hawk_content_hash ( request_body , content_type ) : [EOL] [docstring] [EOL] h = hashlib . new ( [string] ) [EOL] h . update ( [string] ) [EOL] h . update ( content_type . encode ( [string] ) ) [EOL] h . update ( [string] ) [EOL] while True : [EOL] block = request_body . read ( [number] ) [EOL] if not block : [EOL] break [EOL] h . update ( block ) [EOL] h . update ( [string] ) [EOL] return b64encode ( h . digest ( ) ) [EOL] [EOL] [EOL] def get_hawk_header ( url , user , password , content_type , content_hash ) : [EOL] [docstring] [EOL] r = mohawk . base . Resource ( credentials = { [string] : user , [string] : password , [string] : [string] } , url = url , method = [string] , content_type = content_type ) [EOL] r . _content_hash = content_hash [EOL] mac = mohawk . util . calculate_mac ( [string] , r , r . content_hash ) [EOL] a = mohawk . base . HawkAuthority ( ) [EOL] auth_header = a . _make_header ( r , mac ) [EOL] return auth_header [EOL] [EOL] [EOL] @ time_async_function async def call_autograph ( session , url , user , password , sign_req ) : [EOL] [docstring] [EOL] content_type = [string] [EOL] [EOL] request_body = tempfile . TemporaryFile ( [string] ) [EOL] write_signing_req_to_disk ( request_body , sign_req ) [EOL] request_body . seek ( [number] ) [EOL] [EOL] content_hash = get_hawk_content_hash ( request_body , content_type ) [EOL] [EOL] auth_header = get_hawk_header ( url , user , password , content_type , content_hash ) [EOL] [EOL] request_body . seek ( [number] , [number] ) [EOL] req_size = request_body . tell ( ) [EOL] log . debug ( [string] , req_size ) [EOL] request_body . seek ( [number] ) [EOL] [EOL] resp = await session . post ( url , data = request_body , headers = { [string] : auth_header , [string] : content_type , [string] : str ( req_size ) } ) [EOL] log . debug ( [string] , resp . status ) [EOL] resp . raise_for_status ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return await resp . json ( ) [EOL] [EOL] [EOL] def b64encode ( input_bytes ) : [EOL] [docstring] [EOL] return base64 . b64encode ( input_bytes ) . decode ( [string] ) [EOL] [EOL] [EOL] def _is_xpi_format ( fmt ) : [EOL] if [string] in fmt or [string] in fmt : [EOL] return True [EOL] if fmt in ( [string] , [string] ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] @ time_function def make_signing_req ( input_file , fmt , keyid = None , extension_id = None ) : [EOL] [docstring] [EOL] sign_req = { [string] : input_file } [EOL] [EOL] if keyid : [EOL] sign_req [ [string] ] = keyid [EOL] [EOL] [comment] [EOL] if utils . is_apk_autograph_signing_format ( fmt ) : [EOL] [comment] [EOL] sign_req [ [string] ] = { [string] : [string] } [EOL] [EOL] if utils . is_sha1_apk_autograph_signing_format ( fmt ) : [EOL] [comment] [EOL] [comment] [EOL] sign_req [ [string] ] [ [string] ] = [string] [EOL] [EOL] if _is_xpi_format ( fmt ) : [EOL] sign_req . setdefault ( [string] , { } ) [EOL] [comment] [EOL] sign_req [ [string] ] [ [string] ] = extension_id [EOL] sign_req [ [string] ] [ [string] ] = [ [string] ] [EOL] sign_req [ [string] ] [ [string] ] = [string] [EOL] [EOL] return sign_req [EOL] [EOL] [EOL] @ time_async_function async def sign_with_autograph ( session , server , input_file , fmt , autograph_method , keyid = None , extension_id = None ) : [EOL] [docstring] [EOL] if autograph_method not in { [string] , [string] , [string] } : [EOL] raise SigningScriptError ( f" [string] { autograph_method }" ) [EOL] [EOL] keyid = keyid or server . key_id [EOL] sign_req = make_signing_req ( input_file , fmt , keyid , extension_id ) [EOL] [EOL] url = f"{ server . url } [string] { autograph_method }" [EOL] [EOL] sign_resp = await retry_async ( call_autograph , args = ( session , url , server . client_id , server . access_key , sign_req ) , attempts = [number] , sleeptime_kwargs = { [string] : [number] } ) [EOL] [EOL] if autograph_method == [string] : [EOL] return sign_resp [ [number] ] [ [string] ] [EOL] else : [EOL] return sign_resp [ [number] ] [ [string] ] [EOL] [EOL] [EOL] @ time_async_function async def sign_file_with_autograph ( context , from_ , fmt , to = None , extension_id = None ) : [EOL] [docstring] [EOL] cert_type = task . task_cert_type ( context ) [EOL] a = get_autograph_config ( context . autograph_configs , cert_type , [ fmt ] , raise_on_empty = True ) [EOL] to = to or from_ [EOL] input_file = open ( from_ , [string] ) [EOL] signed_bytes = base64 . b64decode ( await sign_with_autograph ( context . session , a , input_file , fmt , [string] , extension_id = extension_id ) ) [EOL] with open ( to , [string] ) as fout : [EOL] fout . write ( signed_bytes ) [EOL] return to [EOL] [EOL] [EOL] @ time_async_function async def sign_gpg_with_autograph ( context , from_ , fmt , ** kwargs ) : [EOL] [docstring] [EOL] cert_type = task . task_cert_type ( context ) [EOL] a = get_autograph_config ( context . autograph_configs , cert_type , [ fmt ] , raise_on_empty = True ) [EOL] to = f"{ from_ } [string] " [EOL] input_file = open ( from_ , [string] ) [EOL] signature = await sign_with_autograph ( context . session , a , input_file , fmt , [string] ) [EOL] with open ( to , [string] ) as fout : [EOL] fout . write ( signature ) [EOL] return [ from_ , to ] [EOL] [EOL] [EOL] @ time_async_function async def sign_hash_with_autograph ( context , hash_ , fmt , keyid = None ) : [EOL] [docstring] [EOL] cert_type = task . task_cert_type ( context ) [EOL] a = get_autograph_config ( context . autograph_configs , cert_type , [ fmt ] , raise_on_empty = True ) [EOL] input_file = BytesIO ( hash_ ) [EOL] signature = base64 . b64decode ( await sign_with_autograph ( context . session , a , input_file , fmt , [string] , keyid ) ) [EOL] return signature [EOL] [EOL] [EOL] def get_mar_verification_key ( cert_type , fmt , keyid ) : [EOL] [docstring] [EOL] [comment] [EOL] cert_type = cert_type . split ( [string] ) [ - [number] ] [EOL] data_dir = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] try : [EOL] if keyid is None : [EOL] return os . path . join ( data_dir , _DEFAULT_MAR_VERIFY_KEYS [ fmt ] [ cert_type ] ) [EOL] else : [EOL] [comment] [EOL] if [string] in keyid : [EOL] raise SigningScriptError ( [string] ) [EOL] keyid = os . path . basename ( keyid ) [EOL] return os . path . join ( data_dir , f"{ keyid } [string] " ) [EOL] except KeyError as err : [EOL] raise SigningScriptError ( f" [string] { fmt } [string] { cert_type } [string] { keyid } [string] { err }" ) [EOL] [EOL] [EOL] def verify_mar_signature ( cert_type , fmt , mar , keyid = None ) : [EOL] [docstring] [EOL] mar_verify_key = get_mar_verification_key ( cert_type , fmt , keyid ) [EOL] try : [EOL] mar_path = os . path . join ( os . path . dirname ( sys . executable ) , [string] ) [EOL] cmd = [ mar_path , [string] , mar_verify_key , [string] , mar ] [EOL] log . info ( [string] , cmd ) [EOL] subprocess . check_call ( cmd , stdout = sys . stdout , stderr = sys . stderr ) [EOL] log . info ( [string] ) [EOL] except subprocess . CalledProcessError as e : [EOL] raise SigningScriptError ( e ) [EOL] [EOL] [EOL] @ time_async_function async def sign_mar384_with_autograph_hash ( context , from_ , fmt , to = None , ** kwargs ) : [EOL] [docstring] [EOL] cert_type = task . task_cert_type ( context ) [EOL] [comment] [EOL] fmt , keyid = utils . split_autograph_format ( fmt ) [EOL] [comment] [EOL] get_autograph_config ( context . autograph_configs , cert_type , [ fmt ] , raise_on_empty = True ) [EOL] [EOL] hash_algo , expected_signature_length = [string] , [number] [EOL] [EOL] [comment] [EOL] with tempfile . TemporaryFile ( ) as tmp : [EOL] with open ( from_ , [string] ) as f : [EOL] add_signature_block ( f , tmp , hash_algo ) [EOL] [EOL] tmp . seek ( [number] ) [EOL] [EOL] with MarReader ( tmp ) as m : [EOL] hashes = m . calculate_hashes ( ) [EOL] h = hashes [ [number] ] [ [number] ] [EOL] [EOL] signature = await sign_hash_with_autograph ( context , h , fmt , keyid ) [EOL] [EOL] [comment] [EOL] if len ( signature ) != expected_signature_length : [EOL] raise SigningScriptError ( [string] . format ( hash_algo , len ( signature ) , expected_signature_length ) ) [EOL] [EOL] [comment] [EOL] tmp_dst = tempfile . NamedTemporaryFile ( mode = [string] , delete = False ) [EOL] with open ( tmp_dst . name , [string] ) as dst : [EOL] with open ( from_ , [string] ) as src : [EOL] add_signature_block ( src , dst , hash_algo , signature ) [EOL] [EOL] to = to or from_ [EOL] shutil . copyfile ( tmp_dst . name , to ) [EOL] os . unlink ( tmp_dst . name ) [EOL] [EOL] verify_mar_signature ( cert_type , fmt , to , keyid ) [EOL] [EOL] log . info ( [string] , from_ , to ) [EOL] return to [EOL] [EOL] [EOL] @ time_async_function async def sign_widevine_with_autograph ( context , from_ , blessed , to = None ) : [EOL] [docstring] [EOL] if not widevine : [EOL] raise ImportError ( [string] ) [EOL] [EOL] to = to or f"{ from_ } [string] " [EOL] flags = [number] if blessed else [number] [EOL] fmt = [string] [EOL] [EOL] h = widevine . generate_widevine_hash ( from_ , flags ) [EOL] [EOL] signature = await sign_hash_with_autograph ( context , h , fmt ) [EOL] [EOL] with open ( to , [string] ) as fout : [EOL] certificate = open ( context . config [ [string] ] , [string] ) . read ( ) [EOL] sig = widevine . generate_widevine_signature ( signature , certificate , flags ) [EOL] fout . write ( sig ) [EOL] return to [EOL] [EOL] [EOL] @ time_async_function async def sign_omnija_with_autograph ( context , from_ ) : [EOL] [docstring] [EOL] signed_out = tempfile . mkstemp ( prefix = [string] , suffix = [string] , dir = context . config [ [string] ] ) [ [number] ] [EOL] merged_out = tempfile . mkstemp ( prefix = [string] , suffix = [string] , dir = context . config [ [string] ] ) [ [number] ] [EOL] [EOL] await sign_file_with_autograph ( context , from_ , [string] , to = signed_out , extension_id = [string] ) [EOL] await merge_omnija_files ( orig = from_ , signed = signed_out , to = merged_out ) [EOL] with open ( from_ , [string] ) as fout : [EOL] with open ( merged_out , [string] ) as fin : [EOL] fout . write ( fin . read ( ) ) [EOL] return from_ [EOL] [EOL] [EOL] @ time_async_function async def merge_omnija_files ( orig , signed , to ) : [EOL] [docstring] [EOL] orig_jarreader = mozjar . JarReader ( orig ) [EOL] with mozjar . JarWriter ( to , compress = orig_jarreader . compression ) as to_writer : [EOL] for origjarfile in orig_jarreader : [EOL] to_writer . add ( origjarfile . filename , origjarfile , compress = origjarfile . compress ) [EOL] [comment] [EOL] signed_zip = zipfile . ZipFile ( signed , [string] ) [EOL] for fname in signed_zip . namelist ( ) : [EOL] if fname . startswith ( [string] ) : [EOL] to_writer . add ( fname , signed_zip . open ( fname , [string] ) ) [EOL] if orig_jarreader . last_preloaded : [EOL] jarlog = list ( orig_jarreader . entries . keys ( ) ) [EOL] preloads = jarlog [ : jarlog . index ( orig_jarreader . last_preloaded ) + [number] ] [EOL] to_writer . preload ( preloads ) [EOL] return True [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def sign_authenticode_file ( context , orig_path , fmt , * , authenticode_comment = None ) : [EOL] [docstring] [EOL] if winsign . osslsigncode . is_signed ( orig_path ) : [EOL] log . info ( [string] , orig_path ) [EOL] return True [EOL] [EOL] fmt , keyid = utils . split_autograph_format ( fmt ) [EOL] [EOL] async def signer ( digest , digest_algo ) : [EOL] try : [EOL] return await sign_hash_with_autograph ( context , digest , fmt , keyid ) [EOL] except Exception : [EOL] log . exception ( [string] ) [EOL] raise [EOL] [EOL] infile = orig_path [EOL] outfile = orig_path + [string] [EOL] if [string] in fmt : [EOL] digest_algo = [string] [EOL] else : [EOL] digest_algo = [string] [EOL] [EOL] if keyid : [EOL] certs = load_pem_certs ( open ( context . config [ f" [string] { keyid }" ] , [string] ) . read ( ) ) [EOL] else : [EOL] certs = load_pem_certs ( open ( context . config [ [string] ] , [string] ) . read ( ) ) [EOL] [EOL] url = context . config [ [string] ] [EOL] timestamp_style = context . config [ [string] ] [EOL] if fmt . endswith ( [string] ) : [EOL] crosscert = context . config [ [string] ] [EOL] else : [EOL] crosscert = None [EOL] [EOL] if authenticode_comment and orig_path . endswith ( [string] ) : [EOL] log . info ( [string] , authenticode_comment , orig_path ) [EOL] elif authenticode_comment : [EOL] log . info ( [string] , orig_path ) [EOL] authenticode_comment = None [EOL] [EOL] if not await winsign . sign . sign_file ( infile , outfile , digest_algo , certs , signer , url = url , comment = authenticode_comment , crosscert = crosscert , timestamp_style = timestamp_style , ) : [EOL] raise IOError ( f" [string] { orig_path }" ) [EOL] os . rename ( outfile , infile ) [EOL] [EOL] return True [EOL] [EOL] [EOL] [comment] [EOL] @ time_async_function async def sign_authenticode_zip ( context , orig_path , fmt , * , authenticode_comment = None , ** kwargs ) : [EOL] [docstring] [EOL] file_base , file_extension = os . path . splitext ( orig_path ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tmp_dir = None [EOL] [comment] [EOL] if file_extension == [string] : [EOL] tmp_dir = tempfile . mkdtemp ( prefix = [string] , dir = context . config [ [string] ] ) [EOL] files = await _extract_zipfile ( context , orig_path , tmp_dir = tmp_dir ) [EOL] else : [EOL] files = [ orig_path ] [EOL] files_to_sign = [ file for file in files if _should_sign_windows ( file ) ] [EOL] if not files_to_sign : [EOL] raise SigningScriptError ( [string] . format ( files ) ) [EOL] [EOL] [comment] [EOL] tasks = [ sign_authenticode_file ( context , file_ , fmt , authenticode_comment = authenticode_comment ) for file_ in files_to_sign ] [EOL] done , pending = await asyncio . wait ( tasks , return_when = asyncio . FIRST_EXCEPTION ) [EOL] [ f . result ( ) for f in done ] [EOL] if file_extension == [string] : [EOL] [comment] [EOL] await _create_zipfile ( context , orig_path , files , tmp_dir = tmp_dir ) [EOL] return orig_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] [EOL] import aiohttp [EOL] import scriptworker . client [EOL] [EOL] from signingscript . task import build_filelist_dict , sign , task_signing_formats [EOL] from signingscript . utils import copy_to_dir , load_autograph_configs [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] async def async_main ( context ) : [EOL] [docstring] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] all_signing_formats = task_signing_formats ( context ) [EOL] if [string] in all_signing_formats or [string] in all_signing_formats : [EOL] if not context . config . get ( [string] ) : [EOL] raise Exception ( [string] ) [EOL] if not os . path . exists ( context . config [ [string] ] ) : [EOL] raise Exception ( [string] . format ( context . config [ [string] ] ) ) [EOL] [EOL] if [string] in all_signing_formats : [EOL] if not context . config . get ( [string] ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] context . session = session [EOL] context . autograph_configs = load_autograph_configs ( context . config [ [string] ] ) [EOL] work_dir = context . config [ [string] ] [EOL] filelist_dict = build_filelist_dict ( context ) [EOL] for path , path_dict in filelist_dict . items ( ) : [EOL] copy_to_dir ( path_dict [ [string] ] , context . config [ [string] ] , target = path ) [EOL] log . info ( [string] , path ) [EOL] output_files = await sign ( context , os . path . join ( work_dir , path ) , path_dict [ [string] ] , authenticode_comment = path_dict . get ( [string] ) ) [EOL] for source in output_files : [EOL] source = os . path . relpath ( source , work_dir ) [EOL] copy_to_dir ( os . path . join ( work_dir , source ) , context . config [ [string] ] , target = source ) [EOL] if [string] in path_dict [ [string] ] or [string] in path_dict [ [string] ] : [EOL] copy_to_dir ( context . config [ [string] ] , context . config [ [string] ] , target = [string] ) [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] def get_default_config ( base_dir = None ) : [EOL] [docstring] [EOL] base_dir = base_dir or os . path . dirname ( os . getcwd ( ) ) [EOL] default_config = { [string] : os . path . join ( base_dir , [string] ) , [string] : os . path . join ( base_dir , [string] ) , [string] : [string] , [string] : os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) , [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : None , } [EOL] return default_config [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] mohawk_log = logging . getLogger ( [string] ) [EOL] mohawk_log . setLevel ( logging . INFO ) [EOL] return scriptworker . client . sync_main ( async_main , default_config = get_default_config ( ) ) [EOL] [EOL] [EOL] __name__ == [string] and main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set , List [EOL] import io [EOL] import typing [EOL] import os [EOL] import sys [EOL] [EOL] [EOL] def get_build_entries ( root_path ) : [EOL] [docstring] [EOL] rel_file_path_set = set ( ) [EOL] rel_dir_path_set = set ( ) [EOL] for root , dirs , files in os . walk ( root_path ) : [EOL] for file_name in files : [EOL] parent_dir_rel_path = root [ len ( root_path ) + [number] : ] [EOL] rel_path_file = os . path . join ( parent_dir_rel_path , file_name ) [EOL] rel_path_file = rel_path_file . replace ( [string] , [string] ) [EOL] if not ( rel_path_file . endswith ( [string] ) or rel_path_file . endswith ( [string] ) or rel_path_file . find ( [string] ) != - [number] ) : [EOL] rel_file_path_set . add ( rel_path_file ) [EOL] [EOL] for dir_name in dirs : [EOL] parent_dir_rel_path = root [ len ( root_path ) + [number] : ] [EOL] rel_path_dir = os . path . join ( parent_dir_rel_path , dir_name ) [EOL] rel_path_dir = rel_path_dir . replace ( [string] , [string] ) + [string] [EOL] if rel_path_dir . find ( [string] ) == - [number] : [EOL] rel_dir_path_set . add ( rel_path_dir ) [EOL] [EOL] rel_file_path_list = list ( rel_file_path_set ) [EOL] rel_file_path_list . sort ( reverse = True ) [EOL] rel_dir_path_list = list ( rel_dir_path_set ) [EOL] rel_dir_path_list . sort ( reverse = True ) [EOL] [EOL] return rel_file_path_list , rel_dir_path_list [EOL] [EOL] [EOL] def generate_precomplete ( root_path ) : [EOL] [docstring] [EOL] rel_path_precomplete = [string] [EOL] [comment] [EOL] if os . path . basename ( root_path ) == [string] : [EOL] root_path = os . path . abspath ( os . path . join ( root_path , [string] ) ) [EOL] rel_path_precomplete = [string] [EOL] [EOL] precomplete_file_path = os . path . join ( root_path , rel_path_precomplete ) [EOL] [comment] [EOL] [comment] [EOL] precomplete_file = open ( precomplete_file_path , [string] ) [EOL] rel_file_path_list , rel_dir_path_list = get_build_entries ( root_path ) [EOL] for rel_file_path in rel_file_path_list : [EOL] precomplete_file . write ( [string] . format ( rel_file_path ) . encode ( [string] ) ) [EOL] [EOL] for rel_dir_path in rel_dir_path_list : [EOL] precomplete_file . write ( [string] . format ( rel_dir_path ) . encode ( [string] ) ) [EOL] [EOL] precomplete_file . close ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] generate_precomplete ( os . getcwd ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import distutils [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] [EOL] from distutils . version import ( StrictVersion , ) [EOL] [EOL] [EOL] def iter_modules_in_path ( * paths ) : [EOL] paths = [ os . path . abspath ( os . path . normcase ( p ) ) + os . sep for p in paths ] [EOL] for name , module in sys . modules . items ( ) : [EOL] if not hasattr ( module , [string] ) : [EOL] continue [EOL] [EOL] path = module . __file__ [EOL] [EOL] if path . endswith ( [string] ) : [EOL] path = path [ : - [number] ] [EOL] path = os . path . abspath ( os . path . normcase ( path ) ) [EOL] [EOL] if any ( path . startswith ( p ) for p in paths ) : [EOL] yield path [EOL] [EOL] [EOL] def python_executable_version ( exe ) : [EOL] [docstring] [EOL] program = [string] [EOL] out = subprocess . check_output ( [ exe , [string] , program ] ) . rstrip ( ) [EOL] return StrictVersion ( out ) [EOL] [EOL] [EOL] def find_python3_executable ( min_version = [string] ) : [EOL] [docstring] [EOL] import which [EOL] [EOL] if not min_version . startswith ( [string] ) : [EOL] raise ValueError ( [string] % min_version ) [EOL] [EOL] min_version = StrictVersion ( min_version ) [EOL] [EOL] if sys . version_info . major >= [number] : [EOL] our_version = StrictVersion ( [string] % ( sys . version_info [ [number] : [number] ] ) ) [EOL] [EOL] if our_version >= min_version : [EOL] [comment] [EOL] [comment] [EOL] return sys . executable , our_version . version [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] names = [ [string] ] [EOL] [EOL] [comment] [EOL] for minor in range ( [number] , min_version . version [ [number] ] - [number] , - [number] ) : [EOL] names . append ( [string] % minor ) [EOL] [EOL] for name in names : [EOL] try : [EOL] exe = which . which ( name ) [EOL] except which . WhichError : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] version = python_executable_version ( exe ) [EOL] except ( subprocess . CalledProcessError , ValueError ) : [EOL] continue [EOL] [EOL] if version >= min_version : [EOL] return exe , version . version [EOL] [EOL] return None , None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import distutils [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import subprocess [EOL] import platform [EOL] from mozboot . util import get_state_dir [EOL] import which [EOL] [EOL] from distutils . version import ( StrictVersion , ) [EOL] [EOL] NODE_MIN_VERSION = StrictVersion ( [string] ) [EOL] NPM_MIN_VERSION = StrictVersion ( [string] ) [EOL] [EOL] [EOL] def find_node_paths ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] mozbuild_state_dir = get_state_dir ( ) [EOL] [EOL] if platform . system ( ) == [string] : [EOL] mozbuild_node_path = os . path . join ( mozbuild_state_dir , [string] ) [EOL] else : [EOL] mozbuild_node_path = os . path . join ( mozbuild_state_dir , [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] paths = [ mozbuild_node_path ] + os . environ . get ( [string] ) . split ( os . pathsep ) [EOL] [EOL] if platform . system ( ) == [string] : [EOL] paths += [ [string] % os . environ . get ( [string] ) , os . path . join ( os . environ . get ( [string] ) , [string] ) , os . path . join ( os . environ . get ( [string] ) , [string] ) , os . path . join ( os . environ . get ( [string] ) , [string] ) ] [EOL] [EOL] return paths [EOL] [EOL] [EOL] def check_executable_version ( exe , wrap_call_with_node = False ) : [EOL] [docstring] [EOL] out = None [EOL] [comment] [EOL] if wrap_call_with_node and platform . system ( ) != [string] : [EOL] binary , _ = find_node_executable ( ) [EOL] if binary : [EOL] out = subprocess . check_output ( [ binary , exe , [string] ] ) . lstrip ( [string] ) . rstrip ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not out : [EOL] out = subprocess . check_output ( [ exe , [string] ] ) . lstrip ( [string] ) . rstrip ( ) [EOL] return StrictVersion ( out ) [EOL] [EOL] [EOL] def simple_which ( filename , path = None ) : [EOL] [comment] [EOL] exts = [ [string] , [string] , [string] ] if platform . system ( ) == [string] else [ [string] ] [EOL] [EOL] for ext in exts : [EOL] try : [EOL] return which . which ( filename + ext , path ) [EOL] except which . WhichError : [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] [EOL] [EOL] def find_node_executable ( nodejs_exe = os . environ . get ( [string] ) , min_version = NODE_MIN_VERSION ) : [EOL] [docstring] [EOL] if nodejs_exe : [EOL] try : [EOL] version = check_executable_version ( nodejs_exe ) [EOL] except ( subprocess . CalledProcessError , ValueError ) : [EOL] return None , None [EOL] [EOL] if version >= min_version : [EOL] return nodejs_exe , version . version [EOL] [EOL] return None , None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return find_executable ( [ [string] , [string] ] , min_version ) [EOL] [EOL] [EOL] def find_npm_executable ( min_version = NPM_MIN_VERSION ) : [EOL] [docstring] [EOL] return find_executable ( [ [string] ] , min_version , True ) [EOL] [EOL] [EOL] def find_executable ( names , min_version , use_node_for_version_check = False ) : [EOL] paths = find_node_paths ( ) [EOL] [EOL] found_exe = None [EOL] for name in names : [EOL] try : [EOL] exe = simple_which ( name , paths ) [EOL] except which . WhichError : [EOL] continue [EOL] [EOL] if not exe : [EOL] continue [EOL] [EOL] if not found_exe : [EOL] found_exe = exe [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] version = check_executable_version ( exe , use_node_for_version_check ) [EOL] except ( subprocess . CalledProcessError , ValueError ) : [EOL] continue [EOL] [EOL] if version >= min_version : [EOL] return exe , version . version [EOL] [EOL] return found_exe , None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $distutils.version.StrictVersion$ 0 0 0 0 0 0 $distutils.version.StrictVersion$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $distutils.version.StrictVersion$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $distutils.version.StrictVersion$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import codecs [EOL] import re [EOL] import sys [EOL] [EOL] if sys . version_info [ [number] ] == [number] : [EOL] str_type = str [EOL] else : [EOL] str_type = basestring [EOL] [EOL] [EOL] class DotProperties : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file = None ) : [EOL] self . _properties = { } [EOL] if file : [EOL] self . update ( file ) [EOL] [EOL] def update ( self , file ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( file , str_type ) : [EOL] f = codecs . open ( file , [string] , [string] ) [EOL] else : [EOL] f = file [EOL] [EOL] for l in f . readlines ( ) : [EOL] line = l . strip ( ) [EOL] if not line or line . startswith ( [string] ) : [EOL] continue [EOL] ( k , v ) = re . split ( [string] , line , [number] ) [EOL] self . _properties [ k ] = v [EOL] [EOL] def get ( self , key , default = None ) : [EOL] return self . _properties . get ( key , default ) [EOL] [EOL] def get_list ( self , prefix ) : [EOL] [docstring] [EOL] [EOL] if not prefix . endswith ( [string] ) : [EOL] prefix = prefix + [string] [EOL] indexes = [ ] [EOL] for k , v in self . _properties . iteritems ( ) : [EOL] if not k . startswith ( prefix ) : [EOL] continue [EOL] key = k [ len ( prefix ) : ] [EOL] if [string] in key : [EOL] [comment] [EOL] continue [EOL] indexes . append ( int ( key ) ) [EOL] return [ self . _properties [ prefix + str ( index ) ] for index in sorted ( indexes ) ] [EOL] [EOL] def get_dict ( self , prefix , required_keys = [ ] ) : [EOL] [docstring] [EOL] [EOL] if not prefix . endswith ( [string] ) : [EOL] prefix = prefix + [string] [EOL] [EOL] D = dict ( ( k [ len ( prefix ) : ] , v ) for k , v in self . _properties . iteritems ( ) if k . startswith ( prefix ) and [string] not in k [ len ( prefix ) : ] ) [EOL] [EOL] for required_key in required_keys : [EOL] if required_key not in D : [EOL] raise ValueError ( [string] % required_key ) [EOL] [EOL] return D [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] [comment] [EOL] [comment] [EOL] JOB_CHOICES = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List , Tuple [EOL] import typing [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import cPickle as pickle [EOL] import os [EOL] import sys [EOL] [EOL] import mozpack . path as mozpath [EOL] [EOL] from mozpack . copier import FileCopier [EOL] from mozpack . manifests import InstallManifest [EOL] [EOL] import manifestparser [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] TEST_MANIFESTS = dict ( A11Y = ( [string] , [string] , [string] , True ) , BROWSER_CHROME = ( [string] , [string] , [string] , True ) , ANDROID_INSTRUMENTATION = ( [string] , [string] , [string] , False ) , FIREFOX_UI_FUNCTIONAL = ( [string] , [string] , [string] , False ) , FIREFOX_UI_UPDATE = ( [string] , [string] , [string] , False ) , PUPPETEER_FIREFOX = ( [string] , [string] , [string] , False ) , PYTHON_UNITTEST = ( [string] , [string] , [string] , False ) , CRAMTEST = ( [string] , [string] , [string] , False ) , TELEMETRY_TESTS_CLIENT = ( [string] , [string] , [string] , False ) , MARIONETTE = ( [string] , [string] , [string] , False ) , MARIONETTE_UNIT = ( [string] , [string] , [string] , False ) , MARIONETTE_WEBAPI = ( [string] , [string] , [string] , False ) , MOCHITEST = ( [string] , [string] , [string] , True ) , MOCHITEST_CHROME = ( [string] , [string] , [string] , True ) , WEBRTC_SIGNALLING_TEST = ( [string] , [string] , [string] , True ) , XPCSHELL_TESTS = ( [string] , [string] , [string] , True ) , ) [EOL] [EOL] [comment] [EOL] REFTEST_FLAVORS = ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] WEB_PLATFORM_TESTS_FLAVORS = ( [string] , ) [EOL] [EOL] [EOL] def all_test_flavors ( ) : [EOL] return ( [ v [ [number] ] for v in TEST_MANIFESTS . values ( ) ] + list ( REFTEST_FLAVORS ) + list ( WEB_PLATFORM_TESTS_FLAVORS ) ) [EOL] [EOL] [EOL] class TestInstallInfo ( object ) : [EOL] def __init__ ( self ) : [EOL] self . seen = set ( ) [EOL] self . pattern_installs = [ ] [EOL] self . installs = [ ] [EOL] self . external_installs = set ( ) [EOL] self . deferred_installs = set ( ) [EOL] [EOL] def __ior__ ( self , other ) : [EOL] self . pattern_installs . extend ( other . pattern_installs ) [EOL] self . installs . extend ( other . installs ) [EOL] self . external_installs |= other . external_installs [EOL] self . deferred_installs |= other . deferred_installs [EOL] return self [EOL] [EOL] [EOL] class SupportFilesConverter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _fields = ( ( [string] , set ( ) ) , ( [string] , set ( ) ) , ( [string] , set ( ) ) ) [EOL] [EOL] def convert_support_files ( self , test , install_root , manifest_dir , out_dir ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] info = TestInstallInfo ( ) [EOL] for field , seen in self . _fields : [EOL] value = test . get ( field , [string] ) [EOL] for pattern in value . split ( ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] key = field , pattern , out_dir [EOL] if key in info . seen : [EOL] raise ValueError ( [string] [string] % ( pattern , field ) ) [EOL] info . seen . add ( key ) [EOL] if key in seen : [EOL] continue [EOL] seen . add ( key ) [EOL] [EOL] if field == [string] : [EOL] info . external_installs . add ( mozpath . normpath ( mozpath . join ( out_dir , pattern ) ) ) [EOL] [comment] [EOL] [comment] [EOL] elif pattern [ [number] ] == [string] : [EOL] info . deferred_installs . add ( pattern ) [EOL] [comment] [EOL] [comment] [EOL] elif [string] in pattern and field == [string] : [EOL] info . pattern_installs . append ( ( manifest_dir , pattern , out_dir ) ) [EOL] [comment] [EOL] [comment] [EOL] elif pattern [ [number] ] == [string] : [EOL] full = mozpath . normpath ( mozpath . join ( manifest_dir , mozpath . basename ( pattern ) ) ) [EOL] info . installs . append ( ( full , mozpath . join ( install_root , pattern [ [number] : ] ) ) ) [EOL] else : [EOL] full = mozpath . normpath ( mozpath . join ( manifest_dir , pattern ) ) [EOL] dest_path = mozpath . join ( out_dir , pattern ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not full . startswith ( manifest_dir ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if field == [string] : [EOL] dest_path = mozpath . join ( out_dir , os . path . basename ( pattern ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] continue [EOL] info . installs . append ( ( full , mozpath . normpath ( dest_path ) ) ) [EOL] return info [EOL] [EOL] [EOL] def _resolve_installs ( paths , topobjdir , manifest ) : [EOL] [docstring] [EOL] filename = os . path . join ( topobjdir , [string] ) [EOL] with open ( filename , [string] ) as fh : [EOL] resolved_installs = pickle . load ( fh ) [EOL] [EOL] for path in paths : [EOL] path = path [ [number] : ] [EOL] if path not in resolved_installs : [EOL] raise Exception ( [string] [string] [string] [string] % ( path , path ) ) [EOL] installs = resolved_installs [ path ] [EOL] for install_info in installs : [EOL] try : [EOL] if len ( install_info ) == [number] : [EOL] manifest . add_pattern_link ( * install_info ) [EOL] if len ( install_info ) == [number] : [EOL] manifest . add_link ( * install_info ) [EOL] except ValueError : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] def _make_install_manifest ( topsrcdir , topobjdir , test_objs ) : [EOL] [EOL] flavor_info = { flavor : ( root , prefix , install ) for ( flavor , root , prefix , install ) in TEST_MANIFESTS . values ( ) } [EOL] [EOL] converter = SupportFilesConverter ( ) [EOL] install_info = TestInstallInfo ( ) [EOL] [EOL] for o in test_objs : [EOL] flavor = o [ [string] ] [EOL] if flavor not in flavor_info : [EOL] [comment] [EOL] continue [EOL] root , prefix , install = flavor_info [ flavor ] [EOL] if not install : [EOL] [comment] [EOL] continue [EOL] [EOL] manifest_path = o [ [string] ] [EOL] manifest_dir = mozpath . dirname ( manifest_path ) [EOL] [EOL] out_dir = mozpath . join ( root , prefix , manifest_dir [ len ( topsrcdir ) + [number] : ] ) [EOL] file_relpath = o [ [string] ] [EOL] source = mozpath . join ( topsrcdir , file_relpath ) [EOL] dest = mozpath . join ( root , prefix , file_relpath ) [EOL] if [string] in o : [EOL] out_dir = mozpath . join ( out_dir , o [ [string] ] ) [EOL] manifest_relpath = mozpath . relpath ( source , mozpath . dirname ( manifest_path ) ) [EOL] dest = mozpath . join ( out_dir , manifest_relpath ) [EOL] [EOL] install_info . installs . append ( ( source , dest ) ) [EOL] install_info |= converter . convert_support_files ( o , root , manifest_dir , out_dir ) [EOL] [EOL] manifest = InstallManifest ( ) [EOL] [EOL] for source , dest in set ( install_info . installs ) : [EOL] if dest in install_info . external_installs : [EOL] continue [EOL] manifest . add_link ( source , dest ) [EOL] for base , pattern , dest in install_info . pattern_installs : [EOL] manifest . add_pattern_link ( base , pattern , dest ) [EOL] [EOL] _resolve_installs ( install_info . deferred_installs , topobjdir , manifest ) [EOL] [EOL] return manifest [EOL] [EOL] [EOL] def install_test_files ( topsrcdir , topobjdir , tests_root , test_objs ) : [EOL] [docstring] [EOL] [EOL] if test_objs : [EOL] manifest = _make_install_manifest ( topsrcdir , topobjdir , test_objs ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] manifest = InstallManifest ( mozpath . join ( topobjdir , [string] , [string] , [string] ) ) [EOL] [EOL] harness_files_manifest = mozpath . join ( topobjdir , [string] , [string] , tests_root ) [EOL] [EOL] if os . path . isfile ( harness_files_manifest ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] manifest |= InstallManifest ( harness_files_manifest ) [EOL] [EOL] copier = FileCopier ( ) [EOL] manifest . populate_registry ( copier ) [EOL] copier . copy ( mozpath . join ( topobjdir , tests_root ) , remove_unaccounted = False ) [EOL] [EOL] [EOL] [comment] [EOL] def read_manifestparser_manifest ( context , manifest_path ) : [EOL] path = manifest_path . full_path [EOL] return manifestparser . TestManifest ( manifests = [ path ] , strict = True , rootdir = context . config . topsrcdir , finder = context . _finder , handle_defaults = False ) [EOL] [EOL] [EOL] def read_reftest_manifest ( context , manifest_path ) : [EOL] import reftest [EOL] path = manifest_path . full_path [EOL] manifest = reftest . ReftestManifest ( finder = context . _finder ) [EOL] manifest . load ( path ) [EOL] return manifest [EOL] [EOL] [EOL] def read_wpt_manifest ( context , paths ) : [EOL] manifest_path , tests_root = paths [EOL] full_path = mozpath . normpath ( mozpath . join ( context . srcdir , manifest_path ) ) [EOL] old_path = sys . path [ : ] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] paths_file = os . path . join ( context . config . topsrcdir , [string] , [string] , [string] , [string] , [string] ) [EOL] _globals = { [string] : paths_file } [EOL] execfile ( paths_file , _globals ) [EOL] import manifest as wptmanifest [EOL] finally : [EOL] sys . path = old_path [EOL] f = context . _finder . get ( full_path ) [EOL] try : [EOL] rv = wptmanifest . manifest . load ( tests_root , f ) [EOL] except wptmanifest . manifest . ManifestVersionMismatch : [EOL] [comment] [EOL] [comment] [EOL] rv = wptmanifest . manifest . Manifest ( ) [EOL] return rv [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.testing.TestInstallInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.testing.TestInstallInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.testing.TestInstallInfo$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.testing.TestInstallInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.testing.TestInstallInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.testing.TestInstallInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.testing.TestInstallInfo$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.testing.TestInstallInfo$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.testing.TestInstallInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import io [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import re [EOL] import json [EOL] [EOL] [EOL] def build_dict ( config , env = os . environ ) : [EOL] [docstring] [EOL] substs = config . substs [EOL] [EOL] [comment] [EOL] required = [ [string] , [string] ] [EOL] missing = [ r for r in required if r not in substs ] [EOL] if missing : [EOL] raise Exception ( [string] % [string] . join ( missing ) ) [EOL] [EOL] d = { } [EOL] d [ [string] ] = config . topsrcdir [EOL] [EOL] if config . mozconfig : [EOL] d [ [string] ] = config . mozconfig [EOL] [EOL] [comment] [EOL] o = substs [ [string] ] [EOL] known_os = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] if o in known_os : [EOL] d [ [string] ] = known_os [ o ] [EOL] else : [EOL] [comment] [EOL] d [ [string] ] = o . lower ( ) [EOL] [EOL] [comment] [EOL] d [ [string] ] = substs . get ( [string] ) [EOL] [EOL] [comment] [EOL] if [string] in substs : [EOL] d [ [string] ] = substs [ [string] ] [EOL] [EOL] [comment] [EOL] if [string] in substs : [EOL] d [ [string] ] = substs [ [string] ] [EOL] [EOL] [comment] [EOL] p = substs [ [string] ] [EOL] [comment] [EOL] [comment] [EOL] if p . startswith ( [string] ) : [EOL] p = [string] [EOL] elif re . match ( [string] , p ) : [EOL] p = [string] [EOL] d [ [string] ] = p [EOL] [comment] [EOL] if p in [ [string] , [string] , [string] ] : [EOL] d [ [string] ] = [number] [EOL] [comment] [EOL] elif p in [ [string] , [string] , [string] ] : [EOL] d [ [string] ] = [number] [EOL] [comment] [EOL] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = bool ( substs . get ( [string] ) ) [EOL] d [ [string] ] = bool ( substs . get ( [string] ) ) [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] [comment] [EOL] d [ [string] ] = True [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] , [string] ) [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = bool ( substs . get ( [string] ) ) [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) == [string] [EOL] d [ [string] ] = substs . get ( [string] ) [EOL] [EOL] def guess_platform ( ) : [EOL] if d [ [string] ] == [string] : [EOL] p = d [ [string] ] [EOL] if p == [string] : [EOL] p = [string] [EOL] elif d [ [string] ] == [number] : [EOL] p = [string] . format ( p ) [EOL] elif p in ( [string] , ) : [EOL] p = [string] . format ( p ) [EOL] [EOL] if d [ [string] ] : [EOL] p = [string] . format ( p ) [EOL] [EOL] return p [EOL] [EOL] if d [ [string] ] == [string] : [EOL] if d [ [string] ] == [string] : [EOL] return [string] [EOL] return [string] [EOL] [EOL] def guess_buildtype ( ) : [EOL] if d [ [string] ] : [EOL] return [string] [EOL] if d [ [string] ] : [EOL] return [string] [EOL] return [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in d and ( d [ [string] ] == [string] or [string] in d ) : [EOL] d [ [string] ] = guess_platform ( ) [EOL] d [ [string] ] = guess_buildtype ( ) [EOL] [EOL] if d . get ( [string] , [string] ) == [string] and [string] in substs : [EOL] d [ [string] ] = substs [ [string] ] [EOL] [EOL] return d [EOL] [EOL] [EOL] def write_mozinfo ( file , config , env = os . environ ) : [EOL] [docstring] [EOL] build_conf = build_dict ( config , env ) [EOL] if isinstance ( file , basestring ) : [EOL] file = open ( file , [string] ) [EOL] [EOL] json . dump ( build_conf , file , sort_keys = True , indent = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import , unicode_literals , print_function [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] INCLUSIVE_COMPONENTS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] INCLUSIVE_COMPONENTS = sorted ( INCLUSIVE_COMPONENTS ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] EXCLUSIVE_COMPONENTS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] EXCLUSIVE_COMPONENTS = sorted ( EXCLUSIVE_COMPONENTS ) [EOL] ALL_COMPONENTS = INCLUSIVE_COMPONENTS + EXCLUSIVE_COMPONENTS [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set , List , Pattern [EOL] import typing [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import re [EOL] import six [EOL] from collections import Iterable [EOL] [EOL] [EOL] class Makefile ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _statements = [ ] [EOL] [EOL] def create_rule ( self , targets = [ ] ) : [EOL] [docstring] [EOL] rule = Rule ( targets ) [EOL] self . _statements . append ( rule ) [EOL] return rule [EOL] [EOL] def add_statement ( self , statement ) : [EOL] [docstring] [EOL] self . _statements . append ( statement ) [EOL] [EOL] def dump ( self , fh , removal_guard = True ) : [EOL] [docstring] [EOL] all_deps = set ( ) [EOL] all_targets = set ( ) [EOL] for statement in self . _statements : [EOL] if isinstance ( statement , Rule ) : [EOL] statement . dump ( fh ) [EOL] all_deps . update ( statement . dependencies ( ) ) [EOL] all_targets . update ( statement . targets ( ) ) [EOL] else : [EOL] fh . write ( [string] % statement ) [EOL] if removal_guard : [EOL] guard = Rule ( sorted ( all_deps - all_targets ) ) [EOL] guard . dump ( fh ) [EOL] [EOL] [EOL] class _SimpleOrderedSet ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _list = [ ] [EOL] self . _set = set ( ) [EOL] [EOL] def __nonzero__ ( self ) : [EOL] return bool ( self . _set ) [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . _list ) [EOL] [EOL] def __contains__ ( self , key ) : [EOL] return key in self . _set [EOL] [EOL] def update ( self , iterable ) : [EOL] def _add ( iterable ) : [EOL] emitted = set ( ) [EOL] for i in iterable : [EOL] i = i . replace ( os . sep , [string] ) [EOL] if i not in self . _set and i not in emitted : [EOL] yield i [EOL] emitted . add ( i ) [EOL] added = list ( _add ( iterable ) ) [EOL] self . _set . update ( added ) [EOL] self . _list . extend ( added ) [EOL] [EOL] [EOL] class Rule ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , targets = [ ] ) : [EOL] self . _targets = _SimpleOrderedSet ( ) [EOL] self . _dependencies = _SimpleOrderedSet ( ) [EOL] self . _commands = [ ] [EOL] self . add_targets ( targets ) [EOL] [EOL] def add_targets ( self , targets ) : [EOL] [docstring] [EOL] assert isinstance ( targets , Iterable ) and not isinstance ( targets , six . string_types ) [EOL] self . _targets . update ( targets ) [EOL] return self [EOL] [EOL] def add_dependencies ( self , deps ) : [EOL] [docstring] [EOL] assert isinstance ( deps , Iterable ) and not isinstance ( deps , six . string_types ) [EOL] self . _dependencies . update ( deps ) [EOL] return self [EOL] [EOL] def add_commands ( self , commands ) : [EOL] [docstring] [EOL] assert isinstance ( commands , Iterable ) and not isinstance ( commands , six . string_types ) [EOL] self . _commands . extend ( commands ) [EOL] return self [EOL] [EOL] def targets ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] return iter ( self . _targets ) [EOL] [EOL] def dependencies ( self ) : [EOL] [docstring] [EOL] return iter ( d for d in self . _dependencies if d not in self . _targets ) [EOL] [EOL] def commands ( self ) : [EOL] [docstring] [EOL] return iter ( self . _commands ) [EOL] [EOL] def dump ( self , fh ) : [EOL] [docstring] [EOL] if not self . _targets : [EOL] return [EOL] fh . write ( [string] % [string] . join ( self . _targets ) ) [EOL] if self . _dependencies : [EOL] fh . write ( [string] % [string] . join ( self . dependencies ( ) ) ) [EOL] fh . write ( [string] ) [EOL] for cmd in self . _commands : [EOL] fh . write ( [string] % cmd ) [EOL] [EOL] [EOL] [comment] [EOL] _depfilesplitter = re . compile ( [string] ) [EOL] [EOL] [EOL] def read_dep_makefile ( fh ) : [EOL] [docstring] [EOL] [EOL] rule = [string] [EOL] for line in fh . readlines ( ) : [EOL] assert not line . startswith ( [string] ) [EOL] line = line . strip ( ) [EOL] if line . endswith ( [string] ) : [EOL] rule += line [ : - [number] ] [EOL] else : [EOL] rule += line [EOL] split_rule = _depfilesplitter . split ( rule , [number] ) [EOL] if len ( split_rule ) > [number] and split_rule [ [number] ] . strip ( ) : [EOL] yield Rule ( split_rule [ [number] ] . strip ( ) . split ( ) ) . add_dependencies ( split_rule [ [number] ] . strip ( ) . split ( ) ) [EOL] rule = [string] [EOL] [EOL] if rule : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def write_dep_makefile ( fh , target , deps ) : [EOL] [docstring] [EOL] mk = Makefile ( ) [EOL] rule = mk . create_rule ( targets = [ target ] ) [EOL] rule . add_dependencies ( deps ) [EOL] mk . dump ( fh , removal_guard = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.makeutil.Rule$ 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.makeutil.Rule$ 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.makeutil.Rule$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.makeutil.Rule$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.makeutil.Rule$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.makeutil._SimpleOrderedSet$ 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.makeutil._SimpleOrderedSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , Union , Dict , List [EOL] import typing [EOL] import datetime [EOL] import signingscript [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import datetime [EOL] import sys [EOL] import time [EOL] [EOL] import mozbuild . util [EOL] import mozpack . path as mozpath [EOL] from mozpack . manifests import ( InstallManifest , ) [EOL] from mozpack . copier import ( FileCopier , ) [EOL] from mozbuild . backend import ( get_backend_class , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] import pywatchman [EOL] [EOL] [EOL] def print_line ( prefix , m , now = None ) : [EOL] now = now or datetime . datetime . utcnow ( ) [EOL] print ( [string] % ( prefix , now . isoformat ( ) , m ) ) [EOL] [EOL] [EOL] def print_copy_result ( elapsed , destdir , result , verbose = True ) : [EOL] COMPLETE = [string] [string] [string] [EOL] [EOL] print_line ( [string] , COMPLETE . format ( elapsed = elapsed , dest = destdir , existing = result . existing_files_count , updated = result . updated_files_count , rm_files = result . removed_files_count , rm_dirs = result . removed_directories_count ) ) [EOL] [EOL] [EOL] class FasterBuildException ( Exception ) : [EOL] def __init__ ( self , message , cause ) : [EOL] Exception . __init__ ( self , message ) [EOL] self . cause = cause [EOL] [EOL] [EOL] class FasterBuildChange ( object ) : [EOL] def __init__ ( self ) : [EOL] self . unrecognized = set ( ) [EOL] self . input_to_outputs = { } [EOL] self . output_to_inputs = { } [EOL] [EOL] [EOL] class Daemon ( object ) : [EOL] def __init__ ( self , config_environment ) : [EOL] self . config_environment = config_environment [EOL] self . _client = None [EOL] [EOL] @ property def defines ( self ) : [EOL] defines = dict ( self . config_environment . acdefines ) [EOL] [comment] [EOL] [comment] [EOL] defines . update ( { [string] : [string] , [string] : [string] , } ) [EOL] return defines [EOL] [EOL] @ mozbuild . util . memoized_property def file_copier ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] file_copier = FileCopier ( ) [EOL] [EOL] unified_manifest = InstallManifest ( mozpath . join ( self . config_environment . topobjdir , [string] , [string] ) ) [EOL] [EOL] unified_manifest . populate_registry ( file_copier , defines_override = self . defines ) [EOL] [EOL] return file_copier [EOL] [EOL] def subscribe_to_topsrcdir ( self ) : [EOL] self . subscribe_to_dir ( [string] , self . config_environment . topsrcdir ) [EOL] [EOL] def subscribe_to_dir ( self , name , dir_to_watch ) : [EOL] query = { [string] : True , [string] : [ [string] , [ [string] , [string] ] , [ [string] , [ [string] , [ [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] , [string] ] , ] , ] , ] , [string] : [ [string] ] , } [EOL] watch = self . client . query ( [string] , dir_to_watch ) [EOL] if [string] in watch : [EOL] print ( [string] , watch [ [string] ] , file = sys . stderr ) [EOL] [EOL] root = watch [ [string] ] [EOL] if [string] in watch : [EOL] query [ [string] ] = watch [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] query [ [string] ] = self . client . query ( [string] , root , { [string] : [number] } ) [ [string] ] [EOL] [EOL] return self . client . query ( [string] , root , name , query ) [EOL] [EOL] def changed_files ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] files = set ( ) [EOL] [EOL] data = self . client . getSubscription ( [string] ) [EOL] if data : [EOL] for dat in data : [EOL] files |= set ( [ mozpath . normpath ( mozpath . join ( self . config_environment . topsrcdir , f ) ) for f in dat . get ( [string] , [ ] ) ] ) [EOL] [EOL] return files [EOL] [EOL] def incremental_copy ( self , copier , force = False , verbose = True ) : [EOL] [comment] [EOL] if [string] == self . config_environment . substs [ [string] ] : [EOL] bundledir = mozpath . join ( self . config_environment . topobjdir , [string] , self . config_environment . substs [ [string] ] , [string] , [string] ) [EOL] start = time . time ( ) [EOL] result = copier . copy ( bundledir , skip_if_older = not force , remove_unaccounted = False , remove_all_directory_symlinks = False , remove_empty_directories = False ) [EOL] print_copy_result ( time . time ( ) - start , bundledir , result , verbose = verbose ) [EOL] [EOL] destdir = mozpath . join ( self . config_environment . topobjdir , [string] , [string] ) [EOL] start = time . time ( ) [EOL] result = copier . copy ( destdir , skip_if_older = not force , remove_unaccounted = False , remove_all_directory_symlinks = False , remove_empty_directories = False ) [EOL] print_copy_result ( time . time ( ) - start , destdir , result , verbose = verbose ) [EOL] [EOL] def input_changes ( self , verbose = True ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if verbose : [EOL] print_line ( [string] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . client = pywatchman . client ( timeout = [number] ) [EOL] [EOL] try : [EOL] if verbose : [EOL] print_line ( [string] , [string] ) [EOL] [comment] [EOL] self . client . capabilityCheck ( required = [ [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] if verbose : [EOL] print_line ( [string] , [string] . format ( self . config_environment . topsrcdir ) ) [EOL] self . subscribe_to_topsrcdir ( ) [EOL] if verbose : [EOL] print_line ( [string] , [string] . format ( self . config_environment . topsrcdir ) ) [EOL] [EOL] input_to_outputs = self . file_copier . input_to_outputs_tree ( ) [EOL] for input , outputs in input_to_outputs . items ( ) : [EOL] if not outputs : [EOL] raise Exception ( [string] . format ( input ) ) [EOL] [EOL] while True : [EOL] try : [EOL] self . client . receive ( ) [EOL] [EOL] changed = self . changed_files ( ) [EOL] if not changed : [EOL] continue [EOL] [EOL] result = FasterBuildChange ( ) [EOL] [EOL] for change in changed : [EOL] if change in input_to_outputs : [EOL] result . input_to_outputs [ change ] = set ( input_to_outputs [ change ] ) [EOL] else : [EOL] result . unrecognized . add ( change ) [EOL] [EOL] for input , outputs in result . input_to_outputs . items ( ) : [EOL] for output in outputs : [EOL] if output not in result . output_to_inputs : [EOL] result . output_to_inputs [ output ] = set ( ) [EOL] result . output_to_inputs [ output ] . add ( input ) [EOL] [EOL] yield result [EOL] [EOL] except pywatchman . SocketTimeout : [EOL] [comment] [EOL] self . client . query ( [string] ) [EOL] [EOL] except pywatchman . CommandError as e : [EOL] [comment] [EOL] raise FasterBuildException ( e , [string] . format ( self . config_environment . topsrcdir ) ) [EOL] [EOL] except pywatchman . SocketTimeout as e : [EOL] [comment] [EOL] raise FasterBuildException ( e , [string] . format ( self . config_environment . topsrcdir ) ) [EOL] [EOL] finally : [EOL] self . client . close ( ) [EOL] [EOL] def output_changes ( self , verbose = True ) : [EOL] [docstring] [EOL] for change in self . input_changes ( verbose = verbose ) : [EOL] now = datetime . datetime . utcnow ( ) [EOL] [EOL] for unrecognized in sorted ( change . unrecognized ) : [EOL] print_line ( [string] , [string] . format ( unrecognized ) , now = now ) [EOL] [EOL] all_outputs = set ( ) [EOL] for input in sorted ( change . input_to_outputs ) : [EOL] outputs = change . input_to_outputs [ input ] [EOL] [EOL] print_line ( [string] , [string] . format ( input ) , now = now ) [EOL] for output in sorted ( outputs ) : [EOL] print_line ( [string] , [string] . format ( output ) , now = now ) [EOL] all_outputs |= outputs [EOL] [EOL] if all_outputs : [EOL] partial_copier = FileCopier ( ) [EOL] for output in all_outputs : [EOL] partial_copier . add ( output , self . file_copier [ output ] ) [EOL] [EOL] self . incremental_copy ( partial_copier , force = True , verbose = verbose ) [EOL] yield change [EOL] [EOL] def watch ( self , verbose = True ) : [EOL] try : [EOL] active_backend = self . config_environment . substs . get ( [string] , [ None ] ) [ [number] ] [EOL] if active_backend : [EOL] backend_cls = get_backend_class ( active_backend ) ( self . config_environment ) [EOL] except Exception : [EOL] backend_cls = None [EOL] [EOL] for change in self . output_changes ( verbose = verbose ) : [EOL] [comment] [EOL] if backend_cls : [EOL] backend_cls . post_build ( self . config_environment , None , [number] , False , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]],builtins.str]],builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]],builtins.str]],builtins.bool]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]],builtins.str]],builtins.bool]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]],builtins.str]],builtins.bool]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]],builtins.str]],builtins.bool]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]],builtins.str]],builtins.bool]]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[builtins.str],typing.List[typing.Union[typing.List[typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]],builtins.str]],builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.faster_daemon.FasterBuildChange$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.faster_daemon.FasterBuildChange$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.faster_daemon.FasterBuildChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.faster_daemon.FasterBuildChange$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.faster_daemon.FasterBuildChange$ 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.faster_daemon.FasterBuildChange$ 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.faster_daemon.FasterBuildChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.faster_daemon.FasterBuildChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 $typing.Set[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import absolute_import , unicode_literals , print_function [EOL] [EOL] from mozbuild . backend . base import PartialBackend [EOL] from mozbuild . backend . common import CommonBackend [EOL] from mozbuild . frontend . context import ( ObjDirPath , ) [EOL] from mozbuild . frontend . data import ( ChromeManifestEntry , FinalTargetPreprocessedFiles , FinalTargetFiles , GeneratedFile , JARManifest , LocalizedFiles , LocalizedPreprocessedFiles , XPIDLModule , ) [EOL] from mozbuild . makeutil import Makefile [EOL] from mozbuild . util import OrderedDefaultDict [EOL] from mozpack . manifests import InstallManifest [EOL] import mozpack . path as mozpath [EOL] [EOL] [EOL] class FasterMakeBackend ( CommonBackend , PartialBackend ) : [EOL] def _init ( self ) : [EOL] super ( FasterMakeBackend , self ) . _init ( ) [EOL] [EOL] self . _manifest_entries = OrderedDefaultDict ( set ) [EOL] [EOL] self . _install_manifests = OrderedDefaultDict ( InstallManifest ) [EOL] [EOL] self . _dependencies = OrderedDefaultDict ( list ) [EOL] self . _l10n_dependencies = OrderedDefaultDict ( list ) [EOL] [EOL] self . _has_xpidl = False [EOL] [EOL] self . _generated_files_map = { } [EOL] [EOL] def _add_preprocess ( self , obj , path , dest , target = None , ** kwargs ) : [EOL] if target is None : [EOL] target = mozpath . basename ( path ) [EOL] [comment] [EOL] if target . endswith ( [string] ) : [EOL] target = target [ : - [number] ] [EOL] if target . endswith ( [string] ) : [EOL] kwargs [ [string] ] = [string] [EOL] depfile = mozpath . join ( self . environment . topobjdir , [string] , [string] , mozpath . join ( obj . install_target , dest , target ) . replace ( [string] , [string] ) ) [EOL] self . _install_manifests [ obj . install_target ] . add_preprocess ( mozpath . join ( obj . srcdir , path ) , mozpath . join ( dest , target ) , depfile , ** kwargs ) [EOL] [EOL] def consume_object ( self , obj ) : [EOL] if isinstance ( obj , JARManifest ) and obj . install_target . startswith ( [string] ) : [EOL] self . _consume_jar_manifest ( obj ) [EOL] [EOL] elif isinstance ( obj , ( FinalTargetFiles , FinalTargetPreprocessedFiles ) ) and obj . install_target . startswith ( [string] ) : [EOL] ab_cd = self . environment . substs [ [string] ] [ [number] ] [EOL] localized = isinstance ( obj , ( LocalizedFiles , LocalizedPreprocessedFiles ) ) [EOL] defines = obj . defines or { } [EOL] if defines : [EOL] defines = defines . defines [EOL] for path , files in obj . files . walk ( ) : [EOL] for f in files : [EOL] [comment] [EOL] if ( localized and not isinstance ( f , ObjDirPath ) and ab_cd != [string] ) : [EOL] src = self . localized_path ( obj . relsrcdir , f ) [EOL] [EOL] dep_target = [string] % obj . install_target [EOL] [EOL] if [string] not in src : [EOL] merge = mozpath . abspath ( mozpath . join ( self . environment . topobjdir , [string] , obj . relsrcdir , f ) ) [EOL] self . _l10n_dependencies [ dep_target ] . append ( ( merge , f . full_path , src ) ) [EOL] src = merge [EOL] else : [EOL] src = f . full_path [EOL] [EOL] if isinstance ( obj , FinalTargetPreprocessedFiles ) : [EOL] self . _add_preprocess ( obj , src , path , target = f . target_basename , defines = defines ) [EOL] elif [string] in f : [EOL] def _prefix ( s ) : [EOL] for p in mozpath . split ( s ) : [EOL] if [string] not in p : [EOL] yield p + [string] [EOL] prefix = [string] . join ( _prefix ( src ) ) [EOL] [EOL] if [string] in f . target_basename : [EOL] target = path [EOL] else : [EOL] target = mozpath . join ( path , f . target_basename ) [EOL] mozpath . join ( path , f . target_basename ) [EOL] self . _install_manifests [ obj . install_target ] . add_pattern_link ( prefix , src [ len ( prefix ) : ] , target ) [EOL] else : [EOL] self . _install_manifests [ obj . install_target ] . add_link ( src , mozpath . join ( path , f . target_basename ) ) [EOL] if isinstance ( f , ObjDirPath ) : [EOL] dep_target = [string] % obj . install_target [EOL] dep = mozpath . relpath ( f . full_path , self . environment . topobjdir ) [EOL] if dep in self . _generated_files_map : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dep = self . _generated_files_map [ dep ] [EOL] self . _dependencies [ dep_target ] . append ( dep ) [EOL] [EOL] elif isinstance ( obj , ChromeManifestEntry ) and obj . install_target . startswith ( [string] ) : [EOL] top_level = mozpath . join ( obj . install_target , [string] ) [EOL] if obj . path != top_level : [EOL] entry = [string] % mozpath . relpath ( obj . path , obj . install_target ) [EOL] self . _manifest_entries [ top_level ] . add ( entry ) [EOL] self . _manifest_entries [ obj . path ] . add ( str ( obj . entry ) ) [EOL] [EOL] elif isinstance ( obj , GeneratedFile ) : [EOL] if obj . outputs : [EOL] first_output = mozpath . relpath ( mozpath . join ( obj . objdir , obj . outputs [ [number] ] ) , self . environment . topobjdir ) [EOL] for o in obj . outputs [ [number] : ] : [EOL] fullpath = mozpath . join ( obj . objdir , o ) [EOL] self . _generated_files_map [ mozpath . relpath ( fullpath , self . environment . topobjdir ) ] = first_output [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return False [EOL] [EOL] elif isinstance ( obj , XPIDLModule ) : [EOL] self . _has_xpidl = True [EOL] [comment] [EOL] return False [EOL] [EOL] else : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def consume_finished ( self ) : [EOL] mk = Makefile ( ) [EOL] [comment] [EOL] mk . create_rule ( [ [string] ] ) [EOL] mk . add_statement ( [string] % self . environment . topsrcdir ) [EOL] mk . add_statement ( [string] % self . environment . topobjdir ) [EOL] if not self . _has_xpidl : [EOL] mk . add_statement ( [string] ) [EOL] [EOL] [comment] [EOL] for var in ( [string] , [string] , [string] , [string] , ) : [EOL] value = self . environment . substs . get ( var ) [EOL] if value is not None : [EOL] mk . add_statement ( [string] % ( var , value ) ) [EOL] [EOL] install_manifests_bases = self . _install_manifests . keys ( ) [EOL] [EOL] [comment] [EOL] manifest_targets = [ ] [EOL] [EOL] for target , entries in self . _manifest_entries . iteritems ( ) : [EOL] manifest_targets . append ( target ) [EOL] install_target = mozpath . basedir ( target , install_manifests_bases ) [EOL] self . _install_manifests [ install_target ] . add_content ( [string] . join ( [string] % e for e in sorted ( entries ) ) , mozpath . relpath ( target , install_target ) ) [EOL] [EOL] [comment] [EOL] mk . add_statement ( [string] % [string] . join ( self . _install_manifests . keys ( ) ) ) [EOL] [EOL] [comment] [EOL] for target , deps in self . _dependencies . iteritems ( ) : [EOL] mk . create_rule ( [ target ] ) . add_dependencies ( [string] % d for d in deps ) [EOL] [EOL] [comment] [EOL] python_deps = [ [string] , [string] , [string] , ] [EOL] [comment] [EOL] for target , deps in self . _l10n_dependencies . iteritems ( ) : [EOL] mk . create_rule ( [ target ] ) . add_dependencies ( [string] % d [ [number] ] for d in deps ) [EOL] for ( merge , ref_file , l10n_file ) in deps : [EOL] rule = mk . create_rule ( [ merge ] ) . add_dependencies ( [ ref_file , l10n_file ] + python_deps ) [EOL] rule . add_commands ( [ [string] [string] . format ( merge , ref_file , l10n_file ) ] ) [EOL] [comment] [EOL] mk . create_rule ( [ l10n_file ] ) [EOL] [EOL] mk . add_statement ( [string] ) [EOL] [EOL] for base , install_manifest in self . _install_manifests . iteritems ( ) : [EOL] with self . _write_file ( mozpath . join ( self . environment . topobjdir , [string] , [string] % base . replace ( [string] , [string] ) ) ) as fh : [EOL] install_manifest . write ( fileobj = fh ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . environment . is_artifact_build : [EOL] unified_manifest = InstallManifest ( ) [EOL] for base , install_manifest in self . _install_manifests . iteritems ( ) : [EOL] [comment] [EOL] assert base . startswith ( [string] ) [EOL] base = base [ len ( [string] ) : ] [EOL] if base and base [ [number] ] == [string] : [EOL] base = base [ [number] : ] [EOL] unified_manifest . add_entries_from ( install_manifest , base = base ) [EOL] [EOL] with self . _write_file ( mozpath . join ( self . environment . topobjdir , [string] , [string] ) ) as fh : [EOL] unified_manifest . write ( fileobj = fh ) [EOL] [EOL] with self . _write_file ( mozpath . join ( self . environment . topobjdir , [string] , [string] ) ) as fh : [EOL] mk . dump ( fh , removal_guard = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import urllib [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] from collections import defaultdict [EOL] [EOL] try : [EOL] import urlparse [EOL] except ImportError : [EOL] import urllib . parse as urlparse [EOL] [EOL] from mozpack . chrome . manifest import ( Manifest , ManifestChrome , ManifestOverride , ManifestResource , parse_manifest , ) [EOL] import mozpack . path as mozpath [EOL] [EOL] [EOL] class ChromeManifestHandler ( object ) : [EOL] def __init__ ( self ) : [EOL] self . overrides = { } [EOL] self . chrome_mapping = defaultdict ( set ) [EOL] [EOL] def handle_manifest_entry ( self , entry ) : [EOL] format_strings = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] if isinstance ( entry , ( ManifestChrome , ManifestResource ) ) : [EOL] if isinstance ( entry , ManifestResource ) : [EOL] dest = entry . target [EOL] url = urlparse . urlparse ( dest ) [EOL] if not url . scheme : [EOL] dest = mozpath . normpath ( mozpath . join ( entry . base , dest ) ) [EOL] if url . scheme == [string] : [EOL] dest = mozpath . normpath ( url . path ) [EOL] else : [EOL] dest = mozpath . normpath ( entry . path ) [EOL] [EOL] base_uri = format_strings [ entry . type ] % entry . name [EOL] self . chrome_mapping [ base_uri ] . add ( dest ) [EOL] if isinstance ( entry , ManifestOverride ) : [EOL] self . overrides [ entry . overloaded ] = entry . overload [EOL] if isinstance ( entry , Manifest ) : [EOL] for e in parse_manifest ( None , entry . path ) : [EOL] self . handle_manifest_entry ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , Union , Dict , List [EOL] import typing [EOL] import zipfile [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import sys [EOL] import tempfile [EOL] import shutil [EOL] import zipfile [EOL] import tarfile [EOL] import subprocess [EOL] import mozpack . path as mozpath [EOL] from mozbuild . repackaging . application_ini import get_application_ini_value [EOL] from mozbuild . util import ( ensureParentDir , ensure_bytes , ) [EOL] [EOL] [EOL] _BCJ_OPTIONS = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ ] , } [EOL] [EOL] [EOL] def repackage_mar ( topsrcdir , package , mar , output , mar_format = [string] , arch = None ) : [EOL] if not zipfile . is_zipfile ( package ) and not tarfile . is_tarfile ( package ) : [EOL] raise Exception ( [string] % package ) [EOL] if arch and arch not in _BCJ_OPTIONS : [EOL] raise Exception ( [string] . format ( arch , _BCJ_OPTIONS . keys ( ) ) ) [EOL] [EOL] ensureParentDir ( output ) [EOL] tmpdir = tempfile . mkdtemp ( ) [EOL] try : [EOL] if tarfile . is_tarfile ( package ) : [EOL] z = tarfile . open ( package ) [EOL] z . extractall ( tmpdir ) [EOL] filelist = z . getnames ( ) [EOL] z . close ( ) [EOL] else : [EOL] z = zipfile . ZipFile ( package ) [EOL] z . extractall ( tmpdir ) [EOL] filelist = z . namelist ( ) [EOL] z . close ( ) [EOL] [EOL] toplevel_dirs = set ( [ mozpath . split ( f ) [ [number] ] for f in filelist ] ) [EOL] excluded_stuff = set ( [ [string] , [string] , [string] , [string] ] ) [EOL] toplevel_dirs = toplevel_dirs - excluded_stuff [EOL] [comment] [EOL] [comment] [EOL] if len ( toplevel_dirs ) != [number] : [EOL] raise Exception ( [string] [string] % toplevel_dirs ) [EOL] ffxdir = mozpath . join ( tmpdir , toplevel_dirs . pop ( ) ) [EOL] [EOL] make_full_update = mozpath . join ( topsrcdir , [string] ) [EOL] [EOL] env = os . environ . copy ( ) [EOL] env [ [string] ] = get_application_ini_value ( tmpdir , [string] , [string] ) [EOL] env [ [string] ] = mozpath . normpath ( mar ) [EOL] if arch : [EOL] env [ [string] ] = [string] . join ( _BCJ_OPTIONS [ arch ] ) [EOL] if mar_format == [string] : [EOL] env [ [string] ] = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] xz_path = mozpath . join ( topsrcdir , [string] ) [EOL] if os . path . exists ( xz_path ) : [EOL] env [ [string] ] = mozpath . normpath ( xz_path ) [EOL] [EOL] cmd = [ make_full_update , output , ffxdir ] [EOL] if sys . platform == [string] : [EOL] [comment] [EOL] [comment] [EOL] cmd . insert ( [number] , env [ [string] ] + [string] ) [EOL] [comment] [EOL] env = { ensure_bytes ( k ) : ensure_bytes ( v ) for k , v in env . iteritems ( ) } [EOL] subprocess . check_call ( cmd , env = env ) [EOL] [EOL] finally : [EOL] shutil . rmtree ( tmpdir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import errno [EOL] import os [EOL] import tempfile [EOL] import tarfile [EOL] import shutil [EOL] import mozpack . path as mozpath [EOL] from mozpack . dmg import create_dmg [EOL] from mozbuild . repackaging . application_ini import get_application_ini_value [EOL] [EOL] [EOL] def repackage_dmg ( infile , output ) : [EOL] [EOL] if not tarfile . is_tarfile ( infile ) : [EOL] raise Exception ( [string] % infile ) [EOL] [EOL] tmpdir = tempfile . mkdtemp ( ) [EOL] try : [EOL] with tarfile . open ( infile ) as tar : [EOL] tar . extractall ( path = tmpdir ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] os . remove ( mozpath . join ( tmpdir , [string] ) ) [EOL] except OSError as e : [EOL] if e . errno != errno . ENOENT : [EOL] raise [EOL] [EOL] volume_name = get_application_ini_value ( tmpdir , [string] , [string] , fallback = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] create_dmg ( tmpdir , output , volume_name , [ ] ) [EOL] [EOL] finally : [EOL] shutil . rmtree ( tmpdir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import errno [EOL] import os [EOL] import shutil [EOL] [EOL] from buildconfig import topsrcdir [EOL] [EOL] from mach . logging import LoggingManager [EOL] [EOL] from mozbuild . util import ReadOnlyDict [EOL] [EOL] import mozpack . path as mozpath [EOL] [EOL] [EOL] [comment] [EOL] log_manager = LoggingManager ( ) [EOL] log_manager . add_terminal_logging ( ) [EOL] [EOL] [EOL] def prepare_tmp_topsrcdir ( path ) : [EOL] for p in ( [string] , [string] , [string] , [string] , [string] , ) : [EOL] file_path = os . path . join ( path , p ) [EOL] try : [EOL] os . makedirs ( os . path . dirname ( file_path ) ) [EOL] except OSError as e : [EOL] if e . errno != errno . EEXIST : [EOL] raise [EOL] shutil . copy ( os . path . join ( topsrcdir , p ) , file_path ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class MockConfig ( object ) : [EOL] def __init__ ( self , topsrcdir = [string] , extra_substs = { } , error_is_fatal = True , ) : [EOL] self . topsrcdir = mozpath . abspath ( topsrcdir ) [EOL] self . topobjdir = mozpath . abspath ( [string] ) [EOL] [EOL] self . substs = ReadOnlyDict ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , ** extra_substs ) [EOL] [EOL] def decode_value ( value ) : [EOL] if isinstance ( value , list ) : [EOL] return [ v . decode ( [string] , [string] ) for v in value ] [EOL] return value . decode ( [string] , [string] ) [EOL] [EOL] self . substs_unicode = ReadOnlyDict ( { k . decode ( [string] ) : decode_value ( v ) for k , v in self . substs . items ( ) } ) [EOL] [EOL] self . defines = self . substs [EOL] [EOL] self . external_source_dir = None [EOL] self . lib_prefix = [string] [EOL] self . rust_lib_prefix = [string] [EOL] self . lib_suffix = [string] [EOL] self . rust_lib_suffix = [string] [EOL] self . import_prefix = [string] [EOL] self . import_suffix = [string] [EOL] self . dll_prefix = [string] [EOL] self . dll_suffix = [string] [EOL] self . error_is_fatal = error_is_fatal [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import json [EOL] import os [EOL] import tempfile [EOL] import unittest [EOL] [EOL] from StringIO import StringIO [EOL] [EOL] import mozunit [EOL] [EOL] from mozbuild . backend . configenvironment import ConfigEnvironment [EOL] [EOL] from mozbuild . mozinfo import ( build_dict , write_mozinfo , ) [EOL] [EOL] from mozfile . mozfile import NamedTemporaryFile [EOL] [EOL] [EOL] class Base ( object ) : [EOL] def _config ( self , substs = { } ) : [EOL] d = os . path . dirname ( __file__ ) [EOL] return ConfigEnvironment ( d , d , substs = substs ) [EOL] [EOL] [EOL] class TestBuildDict ( unittest . TestCase , Base ) : [EOL] def test_missing ( self ) : [EOL] [docstring] [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] build_dict ( self . _config ( substs = dict ( OS_TARGET = [string] ) ) ) [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] build_dict ( self . _config ( substs = dict ( TARGET_CPU = [string] ) ) ) [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] build_dict ( self . _config ( substs = dict ( MOZ_WIDGET_TOOLKIT = [string] ) ) ) [EOL] [EOL] def test_win ( self ) : [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [number] , d [ [string] ] ) [EOL] [EOL] def test_linux ( self ) : [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [number] , d [ [string] ] ) [EOL] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [number] , d [ [string] ] ) [EOL] [EOL] def test_mac ( self ) : [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [number] , d [ [string] ] ) [EOL] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [number] , d [ [string] ] ) [EOL] [EOL] def test_android ( self ) : [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [number] , d [ [string] ] ) [EOL] [EOL] def test_x86 ( self ) : [EOL] [docstring] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] [EOL] def test_arm ( self ) : [EOL] [docstring] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] [EOL] def test_unknown ( self ) : [EOL] [docstring] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] [comment] [EOL] self . assertFalse ( [string] in d ) [EOL] [EOL] def test_debug ( self ) : [EOL] [docstring] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( False , d [ [string] ] ) [EOL] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , MOZ_DEBUG = [string] , ) ) ) [EOL] self . assertEqual ( True , d [ [string] ] ) [EOL] [EOL] def test_crashreporter ( self ) : [EOL] [docstring] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) ) [EOL] self . assertEqual ( False , d [ [string] ] ) [EOL] [EOL] d = build_dict ( self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , MOZ_CRASHREPORTER = [string] , ) ) ) [EOL] self . assertEqual ( True , d [ [string] ] ) [EOL] [EOL] [EOL] class TestWriteMozinfo ( unittest . TestCase , Base ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] fd , self . f = tempfile . mkstemp ( ) [EOL] os . close ( fd ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . unlink ( self . f ) [EOL] [EOL] def test_basic ( self ) : [EOL] [docstring] [EOL] c = self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) [EOL] tempdir = tempfile . tempdir [EOL] c . topsrcdir = tempdir [EOL] with NamedTemporaryFile ( dir = os . path . normpath ( c . topsrcdir ) ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] c . mozconfig = mozconfig . name [EOL] write_mozinfo ( self . f , c ) [EOL] with open ( self . f ) as f : [EOL] d = json . load ( f ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( tempdir , d [ [string] ] ) [EOL] self . assertEqual ( mozconfig . name , d [ [string] ] ) [EOL] self . assertEqual ( [number] , d [ [string] ] ) [EOL] [EOL] def test_fileobj ( self ) : [EOL] [docstring] [EOL] s = StringIO ( ) [EOL] c = self . _config ( dict ( OS_TARGET = [string] , TARGET_CPU = [string] , MOZ_WIDGET_TOOLKIT = [string] , ) ) [EOL] write_mozinfo ( s , c ) [EOL] d = json . loads ( s . getvalue ( ) ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [string] , d [ [string] ] ) [EOL] self . assertEqual ( [number] , d [ [string] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , OrderedDict [EOL] import typing [EOL] import collections [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import unittest [EOL] [EOL] from mozunit import main [EOL] [EOL] from mozbuild . util import ( KeyedDefaultDict , List , OrderedDefaultDict , ReadOnlyNamespace , ReadOnlyDefaultDict , ReadOnlyDict , ReadOnlyKeyedDefaultDict , ) [EOL] [EOL] from collections import OrderedDict [EOL] [EOL] [EOL] class TestReadOnlyNamespace ( unittest . TestCase ) : [EOL] def test_basic ( self ) : [EOL] test = ReadOnlyNamespace ( foo = [number] , bar = [number] ) [EOL] [EOL] self . assertEqual ( test . foo , [number] ) [EOL] self . assertEqual ( test . bar , [number] ) [EOL] self . assertEqual ( sorted ( i for i in dir ( test ) if not i . startswith ( [string] ) ) , [ [string] , [string] ] ) [EOL] [EOL] with self . assertRaises ( AttributeError ) : [EOL] test . missing [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] test . foo = [number] [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] del test . foo [EOL] [EOL] self . assertEqual ( test , test ) [EOL] self . assertEqual ( test , ReadOnlyNamespace ( foo = [number] , bar = [number] ) ) [EOL] self . assertNotEqual ( test , ReadOnlyNamespace ( foo = [string] , bar = [number] ) ) [EOL] self . assertNotEqual ( test , ReadOnlyNamespace ( foo = [number] , bar = [number] , qux = [number] ) ) [EOL] self . assertNotEqual ( test , ReadOnlyNamespace ( foo = [number] , qux = [number] ) ) [EOL] self . assertNotEqual ( test , ReadOnlyNamespace ( foo = [number] , bar = [string] ) ) [EOL] [EOL] [EOL] class TestReadOnlyDict ( unittest . TestCase ) : [EOL] def test_basic ( self ) : [EOL] original = { [string] : [number] , [string] : [number] } [EOL] [EOL] test = ReadOnlyDict ( original ) [EOL] [EOL] self . assertEqual ( original , test ) [EOL] self . assertEqual ( test [ [string] ] , [number] ) [EOL] [EOL] with self . assertRaises ( KeyError ) : [EOL] test [ [string] ] [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] test [ [string] ] = True [EOL] [EOL] def test_update ( self ) : [EOL] original = { [string] : [number] , [string] : [number] } [EOL] [EOL] test = ReadOnlyDict ( original ) [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] test . update ( foo = [number] ) [EOL] [EOL] self . assertEqual ( original , test ) [EOL] [EOL] def test_del ( self ) : [EOL] original = { [string] : [number] , [string] : [number] } [EOL] [EOL] test = ReadOnlyDict ( original ) [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] del test [ [string] ] [EOL] [EOL] self . assertEqual ( original , test ) [EOL] [EOL] [EOL] class TestReadOnlyDefaultDict ( unittest . TestCase ) : [EOL] def test_simple ( self ) : [EOL] original = { [string] : [number] , [string] : [number] } [EOL] [EOL] test = ReadOnlyDefaultDict ( bool , original ) [EOL] [EOL] self . assertEqual ( original , test ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [number] ) [EOL] [EOL] def test_assignment ( self ) : [EOL] test = ReadOnlyDefaultDict ( bool , { } ) [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] test [ [string] ] = True [EOL] [EOL] def test_defaults ( self ) : [EOL] test = ReadOnlyDefaultDict ( bool , { [string] : [number] } ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [number] ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , False ) [EOL] [EOL] [EOL] class TestList ( unittest . TestCase ) : [EOL] def test_add_list ( self ) : [EOL] test = List ( [ [number] , [number] , [number] ] ) [EOL] [EOL] test += [ [number] , [number] , [number] ] [EOL] self . assertIsInstance ( test , List ) [EOL] self . assertEqual ( test , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] test = test + [ [number] , [number] ] [EOL] self . assertIsInstance ( test , List ) [EOL] self . assertEqual ( test , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_add_string ( self ) : [EOL] test = List ( [ [number] , [number] , [number] ] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] test += [string] [EOL] [EOL] def test_none ( self ) : [EOL] [docstring] [EOL] test = List ( [ [number] , [number] , [number] ] ) [EOL] [EOL] test += None [EOL] self . assertEqual ( test , [ [number] , [number] , [number] ] ) [EOL] [EOL] test = test + None [EOL] self . assertIsInstance ( test , List ) [EOL] self . assertEqual ( test , [ [number] , [number] , [number] ] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] test += False [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] test = test + False [EOL] [EOL] [EOL] class TestOrderedDefaultDict ( unittest . TestCase ) : [EOL] def test_simple ( self ) : [EOL] original = OrderedDict ( foo = [number] , bar = [number] ) [EOL] [EOL] test = OrderedDefaultDict ( bool , original ) [EOL] [EOL] self . assertEqual ( original , test ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [number] ) [EOL] [EOL] self . assertEqual ( test . keys ( ) , [ [string] , [string] ] ) [EOL] [EOL] def test_defaults ( self ) : [EOL] test = OrderedDefaultDict ( bool , { [string] : [number] } ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [number] ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , False ) [EOL] [EOL] self . assertEqual ( test . keys ( ) , [ [string] , [string] ] ) [EOL] [EOL] [EOL] class TestKeyedDefaultDict ( unittest . TestCase ) : [EOL] def test_simple ( self ) : [EOL] original = { [string] : [number] , [string] : [number] } [EOL] [EOL] test = KeyedDefaultDict ( lambda x : x , original ) [EOL] [EOL] self . assertEqual ( original , test ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [number] ) [EOL] [EOL] def test_defaults ( self ) : [EOL] test = KeyedDefaultDict ( lambda x : x , { [string] : [number] } ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [number] ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [string] ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [string] ) [EOL] [EOL] test [ [string] ] = [number] [EOL] test [ [string] ] = None [EOL] test [ [string] ] = [string] [EOL] [EOL] self . assertEqual ( test [ [string] ] , [number] ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , None ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [string] ) [EOL] [EOL] [EOL] class TestReadOnlyKeyedDefaultDict ( unittest . TestCase ) : [EOL] def test_defaults ( self ) : [EOL] test = ReadOnlyKeyedDefaultDict ( lambda x : x , { [string] : [number] } ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [number] ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [string] ) [EOL] [EOL] self . assertEqual ( test [ [string] ] , [string] ) [EOL] [EOL] copy = dict ( test ) [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] test [ [string] ] = [number] [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] test [ [string] ] = None [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] test [ [string] ] = [string] [EOL] [EOL] self . assertEqual ( test , copy ) [EOL] [EOL] self . assertEqual ( len ( test ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $collections.OrderedDict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $collections.OrderedDict[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import unittest [EOL] [EOL] from StringIO import StringIO [EOL] import os [EOL] import shutil [EOL] [EOL] from tempfile import mkdtemp [EOL] [EOL] from mozunit import main , MockedOpen [EOL] [EOL] from mozbuild . preprocessor import Preprocessor [EOL] [EOL] [EOL] class TestPreprocessor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . pp = Preprocessor ( ) [EOL] self . pp . out = StringIO ( ) [EOL] [EOL] def do_include_compare ( self , content_lines , expected_lines ) : [EOL] content = [string] % [string] . join ( content_lines ) [EOL] expected = [string] . rstrip ( ) % [string] . join ( expected_lines ) [EOL] [EOL] with MockedOpen ( { [string] : content } ) : [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( self . pp . out . getvalue ( ) . rstrip ( [string] ) , expected ) [EOL] [EOL] def do_include_pass ( self , content_lines ) : [EOL] self . do_include_compare ( content_lines , [ [string] ] ) [EOL] [EOL] def test_conditional_if_0 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_no_marker ( self ) : [EOL] lines = [ [string] , [string] , [string] , ] [EOL] self . pp . setMarker ( None ) [EOL] self . do_include_compare ( lines , lines ) [EOL] [EOL] def test_string_value ( self ) : [EOL] self . do_include_compare ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] , [ [string] ] ) [EOL] [EOL] def test_number_value ( self ) : [EOL] self . do_include_compare ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] , [ [string] ] ) [EOL] [EOL] def test_conditional_if_0_elif_1 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_conditional_if_1 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_conditional_if_0_or_1 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_conditional_if_1_elif_1_else ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_conditional_if_1_if_1 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_conditional_not_0 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_conditional_not_0_and_1 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_conditional_not_1 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_conditional_not_emptyval ( self ) : [EOL] self . do_include_compare ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [ [string] , [string] ] ) [EOL] [EOL] def test_conditional_not_nullval ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_expand ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , ] ) [EOL] [EOL] def test_undef_defined ( self ) : [EOL] self . do_include_compare ( [ [string] , [string] , [string] , ] , [ [string] ] ) [EOL] [EOL] def test_undef_undefined ( self ) : [EOL] self . do_include_compare ( [ [string] , ] , [ ] ) [EOL] [EOL] def test_filter_attemptSubstitution ( self ) : [EOL] self . do_include_compare ( [ [string] , [string] , [string] , ] , [ [string] ] ) [EOL] [EOL] def test_filter_emptyLines ( self ) : [EOL] self . do_include_compare ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_filter_slashslash ( self ) : [EOL] self . do_include_compare ( [ [string] , [string] , [string] , [string] , ] , [ [string] , [string] , ] ) [EOL] [EOL] def test_filter_spaces ( self ) : [EOL] self . do_include_compare ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_filter_substitution ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_error ( self ) : [EOL] with MockedOpen ( { [string] : [string] } ) : [EOL] with self . assertRaises ( Preprocessor . Error ) as e : [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( e . args [ [number] ] [ - [number] ] , [string] ) [EOL] [EOL] def test_javascript_line ( self ) : [EOL] [comment] [EOL] [comment] [EOL] tmpdir = mkdtemp ( ) [EOL] try : [EOL] full = os . path . join ( tmpdir , [string] ) [EOL] with open ( full , [string] ) as fh : [EOL] fh . write ( [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) ) [EOL] [EOL] self . pp . do_include ( full ) [EOL] out = [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] out = out . replace ( [string] , tmpdir + os . path . sep ) [EOL] self . assertEqual ( self . pp . out . getvalue ( ) , out ) [EOL] finally : [EOL] shutil . rmtree ( tmpdir ) [EOL] [EOL] def test_literal ( self ) : [EOL] self . do_include_pass ( [ [string] , ] ) [EOL] [EOL] def test_var_directory ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_file ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_if_0 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_if_0_elifdef ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_if_0_elifndef ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_ifdef_0 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_ifdef_1_or_undef ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_ifdef_undef ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_ifndef_0 ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_ifndef_0_and_undef ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_ifndef_undef ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_var_line ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_filterDefine ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_number_value_equals ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_default_defines ( self ) : [EOL] self . pp . handleCommandLine ( [ [string] ] ) [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_number_value_equals_defines ( self ) : [EOL] self . pp . handleCommandLine ( [ [string] ] ) [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_octal_value_equals ( self ) : [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_octal_value_equals_defines ( self ) : [EOL] self . pp . handleCommandLine ( [ [string] ] ) [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_value_quoted_expansion ( self ) : [EOL] [docstring] [EOL] self . pp . handleCommandLine ( [ [string] ] ) [EOL] self . do_include_compare ( [ [string] , [string] , ] , [ [string] ] ) [EOL] [EOL] def test_octal_value_quoted_expansion ( self ) : [EOL] self . pp . handleCommandLine ( [ [string] ] ) [EOL] self . do_include_compare ( [ [string] , [string] , ] , [ [string] ] ) [EOL] [EOL] def test_number_value_not_equals_quoted_defines ( self ) : [EOL] self . pp . handleCommandLine ( [ [string] ] ) [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_octal_value_not_equals_quoted_defines ( self ) : [EOL] self . pp . handleCommandLine ( [ [string] ] ) [EOL] self . do_include_pass ( [ [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] def test_undefined_variable ( self ) : [EOL] with MockedOpen ( { [string] : [string] } ) : [EOL] with self . assertRaises ( Preprocessor . Error ) as e : [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( e . key , [string] ) [EOL] [EOL] def test_include ( self ) : [EOL] files = { [string] : [string] . join ( [ [string] , [string] , [string] , [string] , ] ) , [string] : [string] . join ( [ [string] , [string] , [string] , ] ) , [string] : [string] . join ( [ [string] , [string] , [string] , [string] , ] ) , } [EOL] [EOL] with MockedOpen ( files ) : [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( self . pp . out . getvalue ( ) , [string] ) [EOL] [EOL] def test_include_line ( self ) : [EOL] files = { [string] : [string] . join ( [ [string] , [string] , [string] , [string] , ] ) , [string] : [string] . join ( [ [string] , [string] , [string] , ] ) , [string] : [string] . join ( [ [string] , [string] , [string] , [string] , ] ) , [string] : [string] , [string] : [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) , } [EOL] [EOL] preprocessed = ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) . replace ( [string] , [string] + os . sep ) [EOL] [EOL] [comment] [EOL] with MockedOpen ( files ) : [EOL] self . pp . topsrcdir = os . path . abspath ( [string] ) [EOL] self . pp . topobjdir = os . path . abspath ( [string] ) [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( self . pp . out . getvalue ( ) , preprocessed ) [EOL] [EOL] [comment] [EOL] self . setUp ( ) [EOL] files [ [string] ] = files [ [string] ] [EOL] del files [ [string] ] [EOL] files [ [string] ] = files [ [string] ] . replace ( [string] , [string] ) [EOL] with MockedOpen ( files ) : [EOL] self . pp . topsrcdir = os . path . abspath ( [string] ) [EOL] self . pp . topobjdir = os . path . abspath ( [string] ) [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( self . pp . out . getvalue ( ) , preprocessed ) [EOL] [EOL] def test_include_missing_file ( self ) : [EOL] with MockedOpen ( { [string] : [string] } ) : [EOL] with self . assertRaises ( Preprocessor . Error ) as e : [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( e . exception . key , [string] ) [EOL] [EOL] def test_include_undefined_variable ( self ) : [EOL] with MockedOpen ( { [string] : [string] } ) : [EOL] with self . assertRaises ( Preprocessor . Error ) as e : [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( e . exception . key , [string] ) [EOL] [EOL] def test_include_literal_at ( self ) : [EOL] files = { [string] : [string] , [string] : [string] , } [EOL] [EOL] with MockedOpen ( files ) : [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( self . pp . out . getvalue ( ) , [string] ) [EOL] [EOL] def test_command_line_literal_at ( self ) : [EOL] with MockedOpen ( { [string] : [string] } ) : [EOL] self . pp . handleCommandLine ( [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( self . pp . out . getvalue ( ) , [string] ) [EOL] [EOL] def test_invalid_ifdef ( self ) : [EOL] with MockedOpen ( { [string] : [string] } ) : [EOL] with self . assertRaises ( Preprocessor . Error ) as e : [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( e . exception . key , [string] ) [EOL] [EOL] with MockedOpen ( { [string] : [string] } ) : [EOL] with self . assertRaises ( Preprocessor . Error ) as e : [EOL] self . pp . do_include ( [string] ) [EOL] self . assertEqual ( e . exception . key , [string] ) [EOL] [EOL] [comment] [EOL] self . do_include_pass ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] from mozunit import main [EOL] import unittest [EOL] [EOL] from mozbuild . android_version_code import ( android_version_code_v0 , android_version_code_v1 , ) [EOL] [EOL] [EOL] class TestAndroidVersionCode ( unittest . TestCase ) : [EOL] def test_android_version_code_v0 ( self ) : [EOL] [comment] [EOL] buildid = [string] [EOL] arm_api9 = [number] [EOL] arm_api11 = [number] [EOL] x86_api9 = [number] [EOL] self . assertEqual ( android_version_code_v0 ( buildid , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) , arm_api9 ) [EOL] self . assertEqual ( android_version_code_v0 ( buildid , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) , arm_api11 ) [EOL] self . assertEqual ( android_version_code_v0 ( buildid , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) , x86_api9 ) [EOL] [EOL] def test_android_version_code_v1 ( self ) : [EOL] buildid = [string] [EOL] arm_api16 = [number] [EOL] arm64_api21 = [number] [EOL] x86_api9 = [number] [EOL] self . assertEqual ( android_version_code_v1 ( buildid , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) , arm_api16 ) [EOL] self . assertEqual ( android_version_code_v1 ( buildid , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) , arm64_api21 ) [EOL] self . assertEqual ( android_version_code_v1 ( buildid , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) , x86_api9 ) [EOL] [EOL] def test_android_version_code_v1_underflow ( self ) : [EOL] [docstring] [EOL] buildid = [string] [comment] [EOL] arm_api9 = [number] [EOL] self . assertEqual ( android_version_code_v1 ( buildid , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) , arm_api9 ) [EOL] with self . assertRaises ( ValueError ) as cm : [EOL] underflow = [string] [comment] [EOL] android_version_code_v1 ( underflow , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) [EOL] self . assertTrue ( [string] in cm . exception . message ) [EOL] [EOL] def test_android_version_code_v1_running_low ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( ValueError ) as cm : [EOL] overflow = [string] [EOL] android_version_code_v1 ( overflow , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) [EOL] self . assertTrue ( [string] in cm . exception . message ) [EOL] [EOL] def test_android_version_code_v1_overflow ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( ValueError ) as cm : [EOL] overflow = [string] [EOL] android_version_code_v1 ( overflow , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) [EOL] self . assertTrue ( [string] in cm . exception . message ) [EOL] [EOL] def test_android_version_code_v0_relative_v1 ( self ) : [EOL] [docstring] [EOL] buildid = [string] [EOL] self . assertGreater ( android_version_code_v1 ( buildid , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) , android_version_code_v0 ( buildid , cpu_arch = [string] , min_sdk = [number] , max_sdk = None ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
	0
	0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import unittest [EOL] import json [EOL] [EOL] import mozunit [EOL] [EOL] import mozbuild . action . langpack_manifest as langpack_manifest [EOL] from mozbuild . preprocessor import Context [EOL] [EOL] [EOL] class TestGenerateManifest ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_manifest ( self ) : [EOL] ctx = Context ( ) [EOL] ctx [ [string] ] = [string] [EOL] ctx [ [string] ] = [string] [EOL] ctx [ [string] ] = [string] [EOL] manifest = langpack_manifest . create_webmanifest ( [string] , [string] , [string] , [string] , [string] , [string] , ctx , { } , ) [EOL] [EOL] data = json . loads ( manifest ) [EOL] self . assertEquals ( data [ [string] ] , [string] ) [EOL] self . assertEquals ( data [ [string] ] , [string] ) [EOL] [EOL] def test_manifest_without_contributors ( self ) : [EOL] ctx = Context ( ) [EOL] ctx [ [string] ] = [string] [EOL] ctx [ [string] ] = [string] [EOL] manifest = langpack_manifest . create_webmanifest ( [string] , [string] , [string] , [string] , [string] , [string] , ctx , { } , ) [EOL] [EOL] data = json . loads ( manifest ) [EOL] self . assertEquals ( data [ [string] ] , [string] ) [EOL] self . assertEquals ( data [ [string] ] , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import os [EOL] import unittest [EOL] [EOL] import mozunit [EOL] [EOL] from mozbuild . action . package_fennec_apk import ( package_fennec_apk as package , ) [EOL] from mozpack . mozjar import JarReader [EOL] import mozpack . path as mozpath [EOL] [EOL] [EOL] test_data_path = mozpath . abspath ( mozpath . dirname ( __file__ ) ) [EOL] test_data_path = mozpath . join ( test_data_path , [string] , [string] ) [EOL] [EOL] [EOL] def data ( name ) : [EOL] return os . path . join ( test_data_path , name ) [EOL] [EOL] [EOL] class TestPackageFennecAPK ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_arguments ( self ) : [EOL] [comment] [EOL] [comment] [EOL] jarrer = package ( inputs = [ ] , omni_ja = data ( [string] ) , assets_dirs = [ data ( [string] ) ] , lib_dirs = [ data ( [string] ) ] , root_files = [ data ( [string] ) ] ) [EOL] [EOL] [comment] [EOL] self . assertEquals ( jarrer [ [string] ] . open ( ) . read ( ) . strip ( ) , [string] ) [EOL] [EOL] [comment] [EOL] for name in ( [string] , [string] , [string] ) : [EOL] self . assertEquals ( jarrer [ name ] . open ( ) . read ( ) . strip ( ) , name ) [EOL] [EOL] def test_inputs ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] jarrer = package ( inputs = [ data ( [string] ) , data ( [string] ) ] ) [EOL] [EOL] files1 = JarReader ( data ( [string] ) ) . entries . keys ( ) [EOL] files2 = JarReader ( data ( [string] ) ) . entries . keys ( ) [EOL] for name in files2 : [EOL] self . assertTrue ( name in files1 or jarrer [ name ] . open ( ) . read ( ) . startswith ( [string] ) ) [EOL] for name in files1 : [EOL] self . assertTrue ( jarrer [ name ] . open ( ) . read ( ) . startswith ( [string] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Tuple , Optional , Any , Union , Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import unittest [EOL] import shutil [EOL] from StringIO import StringIO [EOL] import json [EOL] from tempfile import NamedTemporaryFile [EOL] [EOL] from mozbuild . codecoverage import chrome_map [EOL] from mozbuild . codecoverage import lcov_rewriter [EOL] import buildconfig [EOL] import mozunit [EOL] [EOL] here = os . path . dirname ( __file__ ) [EOL] [EOL] BUILDCONFIG = { [string] : buildconfig . topobjdir , [string] : buildconfig . substs . get ( [string] ) , [string] : buildconfig . substs . get ( [string] ) , [string] : buildconfig . substs . get ( [string] ) , } [EOL] [EOL] basic_file = [string] [EOL] [EOL] [comment] [EOL] multiple_records = [string] [EOL] [EOL] fn_with_multiple_commas = [string] [EOL] [EOL] [EOL] class TempFile ( ) : [EOL] def __init__ ( self , content ) : [EOL] self . file = NamedTemporaryFile ( delete = False ) [EOL] self . file . write ( content ) [EOL] self . file . close ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] return self . file . name [EOL] [EOL] def __exit__ ( self , * args ) : [EOL] os . remove ( self . file . name ) [EOL] [EOL] [EOL] class TestLcovParser ( unittest . TestCase ) : [EOL] [EOL] def parser_roundtrip ( self , lcov_string ) : [EOL] with TempFile ( lcov_string ) as fname : [EOL] file_obj = lcov_rewriter . LcovFile ( [ fname ] ) [EOL] out = StringIO ( ) [EOL] file_obj . print_file ( out , lambda s : ( s , None ) , lambda x , pp : x ) [EOL] [EOL] return out . getvalue ( ) [EOL] [EOL] def test_basic_parse ( self ) : [EOL] output = self . parser_roundtrip ( basic_file ) [EOL] self . assertEqual ( basic_file , output ) [EOL] [EOL] output = self . parser_roundtrip ( multiple_records ) [EOL] self . assertEqual ( multiple_records , output ) [EOL] [EOL] def test_multiple_commas ( self ) : [EOL] output = self . parser_roundtrip ( fn_with_multiple_commas ) [EOL] self . assertEqual ( fn_with_multiple_commas , output ) [EOL] [EOL] [EOL] multiple_included_files = [string] [EOL] [EOL] [EOL] class TestLineRemapping ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] chrome_map_file = os . path . join ( buildconfig . topobjdir , [string] ) [EOL] self . _old_chrome_info_file = None [EOL] if os . path . isfile ( chrome_map_file ) : [EOL] backup_file = os . path . join ( buildconfig . topobjdir , [string] ) [EOL] self . _old_chrome_info_file = backup_file [EOL] self . _chrome_map_file = chrome_map_file [EOL] shutil . move ( chrome_map_file , backup_file ) [EOL] [EOL] empty_chrome_info = [ { } , { } , { } , BUILDCONFIG , ] [EOL] with open ( chrome_map_file , [string] ) as fh : [EOL] json . dump ( empty_chrome_info , fh ) [EOL] [EOL] self . lcov_rewriter = lcov_rewriter . LcovFileRewriter ( chrome_map_file , [string] , [string] , [ ] ) [EOL] self . pp_rewriter = self . lcov_rewriter . pp_rewriter [EOL] [EOL] def tearDown ( self ) : [EOL] if self . _old_chrome_info_file : [EOL] shutil . move ( self . _old_chrome_info_file , self . _chrome_map_file ) [EOL] [EOL] def test_map_multiple_included ( self ) : [EOL] with TempFile ( multiple_included_files ) as fname : [EOL] actual = chrome_map . generate_pp_info ( fname , [string] ) [EOL] expected = { [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , } [EOL] [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] def test_remap_lcov ( self ) : [EOL] pp_remap = { [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) , [string] : ( [string] , [number] ) } [EOL] [EOL] fpath = os . path . join ( here , [string] ) [EOL] [EOL] [comment] [EOL] lcov_file = lcov_rewriter . LcovFile ( [ fpath ] ) [EOL] records = [ lcov_file . parse_record ( r ) for _ , _ , r in lcov_file . iterate_records ( ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] for r in records : [EOL] r . resummarize ( ) [EOL] original_line_count = r . line_count [EOL] original_covered_line_count = r . covered_line_count [EOL] original_function_count = r . function_count [EOL] original_covered_function_count = r . covered_function_count [EOL] [EOL] self . assertEqual ( len ( records ) , [number] ) [EOL] [EOL] [comment] [EOL] lcov_file = lcov_rewriter . LcovFile ( [ fpath ] ) [EOL] r_num = [ ] [EOL] [EOL] def rewrite_source ( s ) : [EOL] r_num . append ( [number] ) [EOL] return s , pp_remap [EOL] [EOL] out = StringIO ( ) [EOL] lcov_file . print_file ( out , rewrite_source , self . pp_rewriter . rewrite_record ) [EOL] self . assertEqual ( len ( r_num ) , [number] ) [EOL] [EOL] [comment] [EOL] with TempFile ( out . getvalue ( ) ) as fname : [EOL] lcov_file = lcov_rewriter . LcovFile ( [ fname ] ) [EOL] records = [ lcov_file . parse_record ( r ) for _ , _ , r in lcov_file . iterate_records ( ) ] [EOL] [EOL] self . assertEqual ( len ( records ) , [number] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( original_line_count , sum ( r . line_count for r in records ) ) [EOL] self . assertEqual ( original_covered_line_count , sum ( r . covered_line_count for r in records ) ) [EOL] self . assertEqual ( original_function_count , sum ( r . function_count for r in records ) ) [EOL] self . assertEqual ( original_covered_function_count , sum ( r . covered_function_count for r in records ) ) [EOL] [EOL] [EOL] class TestUrlFinder ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] chrome_map_file = os . path . join ( buildconfig . topobjdir , [string] ) [EOL] self . _old_chrome_info_file = None [EOL] if os . path . isfile ( chrome_map_file ) : [EOL] backup_file = os . path . join ( buildconfig . topobjdir , [string] ) [EOL] self . _old_chrome_info_file = backup_file [EOL] self . _chrome_map_file = chrome_map_file [EOL] shutil . move ( chrome_map_file , backup_file ) [EOL] [EOL] dummy_chrome_info = [ { [string] : [ [string] , ] , [string] : [ [string] , ] , } , { [string] : [string] , } , { [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , { [string] : [ [string] , [number] ] , } ] , } , BUILDCONFIG , ] [EOL] with open ( chrome_map_file , [string] ) as fh : [EOL] json . dump ( dummy_chrome_info , fh ) [EOL] [EOL] def tearDown ( self ) : [EOL] if self . _old_chrome_info_file : [EOL] shutil . move ( self . _old_chrome_info_file , self . _chrome_map_file ) [EOL] [EOL] def test_jar_paths ( self ) : [EOL] app_name = buildconfig . substs . get ( [string] ) [EOL] omnijar_name = buildconfig . substs . get ( [string] ) [EOL] [EOL] paths = [ ( [string] + app_name + [string] + omnijar_name + [string] , [string] ) , ( [string] + app_name + [string] , [string] ) , ] [EOL] [EOL] url_finder = lcov_rewriter . UrlFinder ( self . _chrome_map_file , [string] , [string] , [ ] ) [EOL] for path , expected in paths : [EOL] self . assertEqual ( url_finder . rewrite_url ( path ) [ [number] ] , expected ) [EOL] [EOL] def test_wrong_scheme_paths ( self ) : [EOL] paths = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] url_finder = lcov_rewriter . UrlFinder ( self . _chrome_map_file , [string] , [string] , [ ] ) [EOL] for path in paths : [EOL] self . assertIsNone ( url_finder . rewrite_url ( path ) ) [EOL] [EOL] def test_chrome_resource_paths ( self ) : [EOL] paths = [ ( [string] , ( [string] , None ) ) , ( [string] , ( [string] , None ) ) , ( [string] , ( [string] , None ) ) , ( [string] , None ) , ( [string] , None ) , ( [string] , ( [string] , None ) ) , ( [string] , ( [string] , { [string] : [ [string] , [number] ] , } ) ) , ( [string] , ( [string] , None ) ) , ] [EOL] [EOL] url_finder = lcov_rewriter . UrlFinder ( self . _chrome_map_file , [string] , [string] , [ ] ) [EOL] for path , expected in paths : [EOL] self . assertEqual ( url_finder . rewrite_url ( path ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[typing.Tuple[builtins.str,typing.Optional[typing.Dict[builtins.str,typing.List[typing.Union[builtins.int,builtins.str]]]]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[typing.Tuple[builtins.str,typing.Optional[typing.Dict[builtins.str,typing.List[typing.Union[builtins.int,builtins.str]]]]]]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import unittest [EOL] from mozunit import main [EOL] [EOL] import mozbuild . backend . configenvironment as ConfigStatus [EOL] [EOL] from mozbuild . util import ReadOnlyDict [EOL] [EOL] import mozpack . path as mozpath [EOL] [EOL] [EOL] class ConfigEnvironment ( ConfigStatus . ConfigEnvironment ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] ConfigStatus . ConfigEnvironment . __init__ ( self , * args , ** kwargs ) [EOL] [comment] [EOL] if [string] not in self . substs : [EOL] if os . path . isabs ( self . topsrcdir ) : [EOL] top_srcdir = self . topsrcdir . replace ( os . sep , [string] ) [EOL] else : [EOL] top_srcdir = mozpath . relpath ( self . topsrcdir , self . topobjdir ) . replace ( os . sep , [string] ) [EOL] [EOL] d = dict ( self . substs ) [EOL] d [ [string] ] = top_srcdir [EOL] self . substs = ReadOnlyDict ( d ) [EOL] [EOL] d = dict ( self . substs_unicode ) [EOL] d [ [string] ] = top_srcdir . decode ( [string] ) [EOL] self . substs_unicode = ReadOnlyDict ( d ) [EOL] [EOL] [EOL] class TestEnvironment ( unittest . TestCase ) : [EOL] def test_auto_substs ( self ) : [EOL] [docstring] [EOL] env = ConfigEnvironment ( [string] , [string] , defines = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , non_global_defines = [ [string] , [string] ] , substs = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] [comment] [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] [comment] [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.backend.test_configenvironment.ConfigEnvironment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.backend.test_configenvironment.ConfigEnvironment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.backend.test_configenvironment.ConfigEnvironment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.backend.test_configenvironment.ConfigEnvironment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set , Dict [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import cPickle as pickle [EOL] import os [EOL] [EOL] import mozpack . path as mozpath [EOL] from mozunit import main [EOL] [EOL] from mozbuild . backend . test_manifest import TestManifestBackend [EOL] from mozbuild . test . backend . common import BackendTester [EOL] [EOL] [EOL] class TestTestManifestBackend ( BackendTester ) : [EOL] [EOL] def test_all_tests_metadata_file_written ( self ) : [EOL] [docstring] [EOL] env = self . _consume ( [string] , TestManifestBackend ) [EOL] [EOL] all_tests_path = mozpath . join ( env . topobjdir , [string] ) [EOL] self . assertTrue ( os . path . exists ( all_tests_path ) ) [EOL] [EOL] with open ( all_tests_path , [string] ) as fh : [EOL] o = pickle . load ( fh ) [EOL] [EOL] self . assertIn ( [string] , o ) [EOL] self . assertIn ( [string] , o ) [EOL] [EOL] self . assertEqual ( len ( o [ [string] ] ) , [number] ) [EOL] [EOL] def test_test_installs_metadata_file_written ( self ) : [EOL] [docstring] [EOL] env = self . _consume ( [string] , TestManifestBackend ) [EOL] all_tests_path = mozpath . join ( env . topobjdir , [string] ) [EOL] self . assertTrue ( os . path . exists ( all_tests_path ) ) [EOL] test_installs_path = mozpath . join ( env . topobjdir , [string] ) [EOL] [EOL] with open ( test_installs_path , [string] ) as fh : [EOL] test_installs = pickle . load ( fh ) [EOL] [EOL] self . assertEqual ( set ( test_installs . keys ( ) ) , set ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] for key in test_installs . keys ( ) : [EOL] self . assertIn ( key , test_installs ) [EOL] [EOL] def test_test_defaults_metadata_file_written ( self ) : [EOL] [docstring] [EOL] env = self . _consume ( [string] , TestManifestBackend ) [EOL] [EOL] test_defaults_path = mozpath . join ( env . topobjdir , [string] ) [EOL] self . assertTrue ( os . path . exists ( test_defaults_path ) ) [EOL] [EOL] with open ( test_defaults_path , [string] ) as fh : [EOL] o = { mozpath . normpath ( k ) : v for k , v in pickle . load ( fh ) . items ( ) } [EOL] [EOL] self . assertEquals ( set ( mozpath . relpath ( k , env . topsrcdir ) for k in o . keys ( ) ) , set ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] manifest_path = mozpath . join ( env . topsrcdir , [string] ) [EOL] self . assertIn ( [string] , o [ manifest_path ] ) [EOL] self . assertIn ( [string] , o [ manifest_path ] ) [EOL] [EOL] def test_test_manifest_sources ( self ) : [EOL] [docstring] [EOL] env = self . _consume ( [string] , TestManifestBackend ) [EOL] [EOL] backend_path = mozpath . join ( env . topobjdir , [string] ) [EOL] self . assertTrue ( os . path . exists ( backend_path ) ) [EOL] [EOL] status_path = mozpath . join ( env . topobjdir , [string] ) [EOL] [EOL] with open ( backend_path , [string] ) as fh : [EOL] sources = set ( source . strip ( ) for source in fh ) [EOL] [EOL] self . assertEquals ( sources , set ( [ mozpath . join ( env . topsrcdir , [string] ) , mozpath . join ( env . topsrcdir , [string] ) , mozpath . join ( env . topsrcdir , [string] ) , status_path ] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import copy [EOL] import errno [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] import tempfile [EOL] import unittest [EOL] [EOL] from mozbuild . configure import ConfigureSandbox [EOL] from mozbuild . util import ReadOnlyNamespace [EOL] from mozpack import path as mozpath [EOL] [EOL] from StringIO import StringIO [EOL] from which import WhichError [EOL] [EOL] from buildconfig import ( topobjdir , topsrcdir , ) [EOL] [EOL] [EOL] def fake_short_path ( path ) : [EOL] if sys . platform . startswith ( [string] ) : [EOL] return [string] . join ( p . split ( [string] , [number] ) [ [number] ] + [string] if [string] in p else p for p in mozpath . split ( path ) ) [EOL] return path [EOL] [EOL] [EOL] def ensure_exe_extension ( path ) : [EOL] if sys . platform . startswith ( [string] ) : [EOL] return path + [string] [EOL] return path [EOL] [EOL] [EOL] class ConfigureTestVFS ( object ) : [EOL] def __init__ ( self , paths ) : [EOL] self . _paths = set ( mozpath . abspath ( p ) for p in paths ) [EOL] [EOL] def exists ( self , path ) : [EOL] if path in self . _paths : [EOL] return True [EOL] if mozpath . basedir ( path , [ topsrcdir , topobjdir ] ) : [EOL] return os . path . exists ( path ) [EOL] return False [EOL] [EOL] def isfile ( self , path ) : [EOL] path = mozpath . abspath ( path ) [EOL] if path in self . _paths : [EOL] return True [EOL] if mozpath . basedir ( path , [ topsrcdir , topobjdir ] ) : [EOL] return os . path . isfile ( path ) [EOL] return False [EOL] [EOL] [EOL] class ConfigureTestSandbox ( ConfigureSandbox ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , paths , config , environ , * args , ** kwargs ) : [EOL] self . _search_path = environ . get ( [string] , [string] ) . split ( os . pathsep ) [EOL] [EOL] self . _subprocess_paths = { mozpath . abspath ( k ) : v for k , v in paths . iteritems ( ) if v } [EOL] [EOL] paths = paths . keys ( ) [EOL] [EOL] environ = copy . copy ( environ ) [EOL] if [string] not in environ : [EOL] environ [ [string] ] = mozpath . abspath ( [string] ) [EOL] self . _subprocess_paths [ environ [ [string] ] ] = self . shell [EOL] paths . append ( environ [ [string] ] ) [EOL] self . _subprocess_paths [ mozpath . join ( topsrcdir , [string] ) ] = self . vswhere [EOL] [EOL] vfs = ConfigureTestVFS ( paths ) [EOL] [EOL] os_path = { k : getattr ( vfs , k ) for k in dir ( vfs ) if not k . startswith ( [string] ) } [EOL] [EOL] os_path . update ( self . OS . path . __dict__ ) [EOL] [EOL] self . imported_os = ReadOnlyNamespace ( path = ReadOnlyNamespace ( ** os_path ) ) [EOL] [EOL] self . modules = kwargs . pop ( [string] , { } ) or { } [EOL] [EOL] super ( ConfigureTestSandbox , self ) . __init__ ( config , environ , * args , ** kwargs ) [EOL] [EOL] def _get_one_import ( self , what ) : [EOL] if what in self . modules : [EOL] return self . modules [ what ] [EOL] [EOL] if what == [string] : [EOL] return self . which [EOL] [EOL] if what == [string] : [EOL] return ReadOnlyNamespace ( which = self . which , WhichError = WhichError , ) [EOL] [EOL] if what == [string] : [EOL] return self . Popen [EOL] [EOL] if what == [string] : [EOL] return ReadOnlyNamespace ( CalledProcessError = subprocess . CalledProcessError , check_output = self . check_output , PIPE = subprocess . PIPE , STDOUT = subprocess . STDOUT , Popen = self . Popen , ) [EOL] [EOL] if what == [string] : [EOL] return self . imported_os . path [EOL] [EOL] if what == [string] : [EOL] return self . imported_os . path . exists [EOL] [EOL] if what == [string] : [EOL] return self . imported_os . path . isfile [EOL] [EOL] if what == [string] : [EOL] return ReadOnlyNamespace ( LPCWSTR = [number] , LPWSTR = [number] , DWORD = [number] , ) [EOL] [EOL] if what == [string] : [EOL] class CTypesFunc ( object ) : [EOL] def __init__ ( self , func ) : [EOL] self . _func = func [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return self . _func ( * args , ** kwargs ) [EOL] [EOL] return ReadOnlyNamespace ( create_unicode_buffer = self . create_unicode_buffer , windll = ReadOnlyNamespace ( kernel32 = ReadOnlyNamespace ( GetShortPathNameW = CTypesFunc ( self . GetShortPathNameW ) , ) ) , ) [EOL] [EOL] if what == [string] : [EOL] def OpenKey ( * args , ** kwargs ) : [EOL] raise WindowsError ( ) [EOL] [EOL] return ReadOnlyNamespace ( HKEY_LOCAL_MACHINE = [number] , OpenKey = OpenKey , ) [EOL] [EOL] return super ( ConfigureTestSandbox , self ) . _get_one_import ( what ) [EOL] [EOL] def create_unicode_buffer ( self , * args , ** kwargs ) : [EOL] class Buffer ( object ) : [EOL] def __init__ ( self ) : [EOL] self . value = [string] [EOL] [EOL] return Buffer ( ) [EOL] [EOL] def GetShortPathNameW ( self , path_in , path_out , length ) : [EOL] path_out . value = fake_short_path ( path_in ) [EOL] return length [EOL] [EOL] def which ( self , command , path = None , exts = None ) : [EOL] for parent in ( path or self . _search_path ) : [EOL] c = mozpath . abspath ( mozpath . join ( parent , command ) ) [EOL] for candidate in ( c , ensure_exe_extension ( c ) ) : [EOL] if self . imported_os . path . exists ( candidate ) : [EOL] return candidate [EOL] raise WhichError ( ) [EOL] [EOL] def Popen ( self , args , stdin = None , stdout = None , stderr = None , ** kargs ) : [EOL] try : [EOL] program = self . which ( args [ [number] ] ) [EOL] except WhichError : [EOL] raise OSError ( errno . ENOENT , [string] ) [EOL] [EOL] func = self . _subprocess_paths . get ( program ) [EOL] retcode , stdout , stderr = func ( stdin , args [ [number] : ] ) [EOL] [EOL] class Process ( object ) : [EOL] def communicate ( self , stdin = None ) : [EOL] return stdout , stderr [EOL] [EOL] def wait ( self ) : [EOL] return retcode [EOL] [EOL] return Process ( ) [EOL] [EOL] def check_output ( self , args , ** kwargs ) : [EOL] proc = self . Popen ( args , ** kwargs ) [EOL] stdout , stderr = proc . communicate ( ) [EOL] retcode = proc . wait ( ) [EOL] if retcode : [EOL] raise subprocess . CalledProcessError ( retcode , args , stdout ) [EOL] return stdout [EOL] [EOL] def shell ( self , stdin , args ) : [EOL] script = mozpath . abspath ( args [ [number] ] ) [EOL] if script in self . _subprocess_paths : [EOL] return self . _subprocess_paths [ script ] ( stdin , args [ [number] : ] ) [EOL] return [number] , [string] , [string] [EOL] [EOL] def vswhere ( self , stdin , args ) : [EOL] return [number] , [string] , [string] [EOL] [EOL] def get_config ( self , name ) : [EOL] [comment] [EOL] [comment] [EOL] for func , args in self . _execution_queue : [EOL] if ( func == self . _resolve_and_set and args [ [number] ] is self . _config [EOL] and args [ [number] ] == name ) : [EOL] func ( * args ) [EOL] return self . _config . get ( name ) [EOL] [EOL] [EOL] class BaseConfigureTest ( unittest . TestCase ) : [EOL] HOST = [string] [EOL] [EOL] def setUp ( self ) : [EOL] self . _cwd = os . getcwd ( ) [EOL] os . chdir ( topobjdir ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . chdir ( self . _cwd ) [EOL] [EOL] def config_guess ( self , stdin , args ) : [EOL] return [number] , self . HOST , [string] [EOL] [EOL] def config_sub ( self , stdin , args ) : [EOL] return [number] , args [ [number] ] , [string] [EOL] [EOL] def get_sandbox ( self , paths , config , args = [ ] , environ = { } , mozconfig = [string] , out = None , logger = None , modules = None ) : [EOL] kwargs = { } [EOL] if logger : [EOL] kwargs [ [string] ] = logger [EOL] else : [EOL] if not out : [EOL] out = StringIO ( ) [EOL] kwargs [ [string] ] = out [EOL] kwargs [ [string] ] = out [EOL] [EOL] if hasattr ( self , [string] ) : [EOL] target = [ [string] % self . TARGET ] [EOL] else : [EOL] target = [ ] [EOL] [EOL] if mozconfig : [EOL] fh , mozconfig_path = tempfile . mkstemp ( ) [EOL] os . write ( fh , mozconfig ) [EOL] os . close ( fh ) [EOL] else : [EOL] mozconfig_path = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] [EOL] try : [EOL] environ = dict ( environ , OLD_CONFIGURE = os . path . join ( topsrcdir , [string] ) , MOZCONFIG = mozconfig_path ) [EOL] [EOL] paths = dict ( paths ) [EOL] autoconf_dir = mozpath . join ( topsrcdir , [string] , [string] ) [EOL] paths [ mozpath . join ( autoconf_dir , [string] ) ] = self . config_guess [EOL] paths [ mozpath . join ( autoconf_dir , [string] ) ] = self . config_sub [EOL] [EOL] sandbox = ConfigureTestSandbox ( paths , config , environ , [ [string] ] + target + args , modules = modules , ** kwargs ) [EOL] sandbox . include_file ( os . path . join ( topsrcdir , [string] ) ) [EOL] [EOL] return sandbox [EOL] finally : [EOL] if mozconfig : [EOL] os . remove ( mozconfig_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.configure.common.ConfigureTestVFS$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.configure.common.ConfigureTestVFS$ 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.configure.common.ConfigureTestVFS$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.configure.common.ConfigureTestSandbox$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.configure.common.ConfigureTestSandbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.configure.common.ConfigureTestSandbox$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import os [EOL] [EOL] from StringIO import StringIO [EOL] from buildconfig import topsrcdir [EOL] from common import BaseConfigureTest [EOL] from mozunit import MockedOpen , main [EOL] from mozbuild . configure . options import InvalidOptionError [EOL] from mozbuild . configure . util import Version [EOL] from mozpack import path as mozpath [EOL] [EOL] [EOL] class TestToolkitMozConfigure ( BaseConfigureTest ) : [EOL] def test_moz_configure_options ( self ) : [EOL] def get_value_for ( args = [ ] , environ = { } , mozconfig = [string] ) : [EOL] sandbox = self . get_sandbox ( { } , { } , args , environ , mozconfig ) [EOL] [EOL] [comment] [EOL] sandbox . option_impl ( [string] , nargs = [string] , help = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] del sandbox . _implied_options [ : ] [EOL] result = sandbox . _value_for ( sandbox [ [string] ] ) [EOL] shell = mozpath . abspath ( [string] ) [EOL] return result . replace ( [string] % shell , [string] ) [EOL] [EOL] self . assertEquals ( [string] , get_value_for ( [ [string] ] ) ) [EOL] [EOL] self . assertEquals ( [string] [string] , get_value_for ( [ [string] , [string] ] ) ) [EOL] [EOL] value = get_value_for ( environ = { [string] : [string] } , mozconfig = [string] ) [EOL] [EOL] self . assertEquals ( [string] , value ) [EOL] [EOL] [comment] [EOL] self . assertEquals ( [string] , get_value_for ( [ [string] , [string] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertEquals ( [string] , get_value_for ( [ [string] , [string] ] ) ) [EOL] self . assertEquals ( [string] , get_value_for ( [ [string] , [string] ] ) ) [EOL] [EOL] self . assertEquals ( [string] , get_value_for ( [ [string] , [string] ] ) ) [EOL] [EOL] def test_developer_options ( self , milestone = [string] ) : [EOL] def get_value ( args = [ ] , environ = { } ) : [EOL] sandbox = self . get_sandbox ( { } , { } , args , environ ) [EOL] return sandbox . _value_for ( sandbox [ [string] ] ) [EOL] [EOL] milestone_path = os . path . join ( topsrcdir , [string] , [string] ) [EOL] with MockedOpen ( { milestone_path : milestone } ) : [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( get_value ( ) , [string] in milestone or None ) [EOL] [EOL] self . assertEqual ( get_value ( [ [string] ] ) , None ) [EOL] [EOL] self . assertEqual ( get_value ( environ = { [string] : [number] } ) , None ) [EOL] [EOL] self . assertEqual ( get_value ( [ [string] ] , environ = { [string] : [number] } ) , None ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) : [EOL] get_value ( [ [string] ] , environ = { [string] : [number] } ) [EOL] [EOL] self . assertEqual ( get_value ( environ = { [string] : [number] } ) , None ) [EOL] [EOL] def test_developer_options_release ( self ) : [EOL] self . test_developer_options ( [string] ) [EOL] [EOL] def test_valid_yasm_version ( self ) : [EOL] out = StringIO ( ) [EOL] sandbox = self . get_sandbox ( { } , { } , out = out ) [EOL] func = sandbox . _depends [ sandbox [ [string] ] ] . _func [EOL] [EOL] [comment] [EOL] func ( None , False , False , False ) [EOL] [EOL] [comment] [EOL] func ( Version ( [string] ) , False , False , False ) [EOL] [EOL] [comment] [EOL] func ( Version ( [string] ) , True , False , False ) [EOL] func ( Version ( [string] ) , True , True , False ) [EOL] func ( Version ( [string] ) , False , True , False ) [EOL] [EOL] [comment] [EOL] func ( Version ( [string] ) , Version ( [string] ) , True , False ) [EOL] func ( Version ( [string] ) , True , Version ( [string] ) , False ) [EOL] func ( Version ( [string] ) , Version ( [string] ) , Version ( [string] ) , False ) [EOL] [EOL] out . truncate ( [number] ) [EOL] with self . assertRaises ( SystemExit ) : [EOL] func ( None , Version ( [string] ) , False , False ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , ( [string] [string] ) , ) [EOL] [EOL] out . truncate ( [number] ) [EOL] with self . assertRaises ( SystemExit ) : [EOL] func ( None , Version ( [string] ) , Version ( [string] ) , False ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , ( [string] [string] ) , ) [EOL] [EOL] out . truncate ( [number] ) [EOL] with self . assertRaises ( SystemExit ) : [EOL] func ( None , Version ( [string] ) , Version ( [string] ) , Version ( [string] ) ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , ( [string] [string] ) , ) [EOL] [EOL] out . truncate ( [number] ) [EOL] with self . assertRaises ( SystemExit ) : [EOL] func ( Version ( [string] ) , Version ( [string] ) , Version ( [string] ) , False ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] [EOL] out . truncate ( [number] ) [EOL] with self . assertRaises ( SystemExit ) : [EOL] func ( Version ( [string] ) , True , Version ( [string] ) , False ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import unittest [EOL] [EOL] from mozunit import main [EOL] [EOL] from mozbuild . configure . options import ( CommandLineHelper , ConflictingOptionError , InvalidOptionError , NegativeOptionValue , Option , OptionValue , PositiveOptionValue , ) [EOL] [EOL] [EOL] class Option ( Option ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] kwargs [ [string] ] = [string] [EOL] super ( Option , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class TestOption ( unittest . TestCase ) : [EOL] def test_option ( self ) : [EOL] option = Option ( [string] ) [EOL] self . assertEquals ( option . prefix , [string] ) [EOL] self . assertEquals ( option . name , [string] ) [EOL] self . assertEquals ( option . env , None ) [EOL] self . assertFalse ( option . default ) [EOL] [EOL] option = Option ( [string] ) [EOL] self . assertEquals ( option . prefix , [string] ) [EOL] self . assertEquals ( option . name , [string] ) [EOL] self . assertEquals ( option . env , None ) [EOL] self . assertFalse ( option . default ) [EOL] [EOL] option = Option ( [string] ) [EOL] self . assertEquals ( option . prefix , [string] ) [EOL] self . assertEquals ( option . name , [string] ) [EOL] self . assertEquals ( option . env , None ) [EOL] self . assertTrue ( option . default ) [EOL] [EOL] option = Option ( [string] ) [EOL] self . assertEquals ( option . prefix , [string] ) [EOL] self . assertEquals ( option . name , [string] ) [EOL] self . assertEquals ( option . env , None ) [EOL] self . assertFalse ( option . default ) [EOL] [EOL] option = Option ( [string] ) [EOL] self . assertEquals ( option . prefix , [string] ) [EOL] self . assertEquals ( option . name , [string] ) [EOL] self . assertEquals ( option . env , None ) [EOL] self . assertTrue ( option . default ) [EOL] [EOL] option = Option ( [string] , env = [string] ) [EOL] self . assertEquals ( option . env , [string] ) [EOL] [EOL] option = Option ( env = [string] ) [EOL] self . assertEquals ( option . prefix , [string] ) [EOL] self . assertEquals ( option . name , None ) [EOL] self . assertEquals ( option . env , [string] ) [EOL] self . assertFalse ( option . default ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] , default = ( [string] , ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] , default = ( ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] , default = True ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] , default = ( [string] , [string] ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] , default = ( ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] , default = True ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] , default = ( [string] , ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [string] , default = ( [string] , [string] ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [string] , default = ( ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [string] , default = True ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] [comment] [EOL] option = Option ( [string] , default = True ) [EOL] self . assertEquals ( option . nargs , [number] ) [EOL] [EOL] option = Option ( [string] , default = False ) [EOL] self . assertEquals ( option . nargs , [number] ) [EOL] [EOL] option = Option ( [string] , default = [string] ) [EOL] self . assertEquals ( option . nargs , [string] ) [EOL] [EOL] option = Option ( [string] , default = ( [string] , ) ) [EOL] self . assertEquals ( option . nargs , [string] ) [EOL] [EOL] option = Option ( [string] , default = ( [string] , [string] ) ) [EOL] self . assertEquals ( option . nargs , [string] ) [EOL] [EOL] option = Option ( env = [string] , default = True ) [EOL] self . assertEquals ( option . nargs , [number] ) [EOL] [EOL] option = Option ( env = [string] , default = False ) [EOL] self . assertEquals ( option . nargs , [number] ) [EOL] [EOL] option = Option ( env = [string] , default = [string] ) [EOL] self . assertEquals ( option . nargs , [string] ) [EOL] [EOL] option = Option ( env = [string] , default = ( [string] , ) ) [EOL] self . assertEquals ( option . nargs , [string] ) [EOL] [EOL] option = Option ( env = [string] , default = ( [string] , [string] ) ) [EOL] self . assertEquals ( option . nargs , [string] ) [EOL] [EOL] def test_option_option ( self ) : [EOL] for option in ( [string] , [string] , [string] , [string] , [string] , ) : [EOL] self . assertEquals ( Option ( option ) . option , option ) [EOL] self . assertEquals ( Option ( option , env = [string] ) . option , option ) [EOL] [EOL] opt = Option ( option , default = False ) [EOL] self . assertEquals ( opt . option , option . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] [EOL] opt = Option ( option , default = True ) [EOL] self . assertEquals ( opt . option , option . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] [EOL] self . assertEquals ( Option ( env = [string] ) . option , [string] ) [EOL] [EOL] def test_option_choices ( self ) : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] , choices = ( [string] , [string] ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] , choices = ( [string] , [string] ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [string] , choices = ( [string] , [string] ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , default = [string] , choices = ( [string] , [string] ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , default = ( [string] , [string] , ) , choices = ( [string] , [string] ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , default = ( [string] , ) , choices = ( [string] , [string] ) ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] option = Option ( [string] , nargs = [string] , choices = ( [string] , [string] ) ) [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] value = option . get_value ( [string] ) [EOL] self . assertTrue ( value ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] [EOL] option = Option ( [string] , nargs = [string] , default = [string] , choices = ( [string] , [string] ) ) [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] value = option . get_value ( [string] ) [EOL] self . assertTrue ( value ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] [EOL] [comment] [EOL] option = Option ( [string] , choices = ( [string] , [string] ) ) [EOL] self . assertEqual ( option . nargs , [number] ) [EOL] [EOL] [comment] [EOL] option = Option ( [string] , nargs = [string] , default = ( [string] , [string] ) , choices = ( [string] , [string] , [string] , [string] ) ) [EOL] [EOL] value = option . get_value ( [string] ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] , [string] ) ) , value ) [EOL] [EOL] value = option . get_value ( [string] ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , ) ) , value ) [EOL] [EOL] value = option . get_value ( [string] ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] [EOL] [comment] [EOL] value = option . get_value ( [string] ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] value = option . get_value ( [string] ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] def test_option_value_compare ( self ) : [EOL] [comment] [EOL] val = PositiveOptionValue ( ( [string] , ) ) [EOL] [EOL] self . assertEqual ( val [ [number] ] , [string] ) [EOL] self . assertEqual ( val , PositiveOptionValue ( ( [string] , ) ) ) [EOL] self . assertNotEqual ( val , PositiveOptionValue ( ( [string] , [string] ) ) ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( val , ( [string] , ) ) [EOL] self . assertNotEqual ( val , ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] self . assertNotEqual ( val , OptionValue ( ( [string] , ) ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with self . assertRaisesRegexp ( TypeError , [string] ) : [EOL] val == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] empty_positive = PositiveOptionValue ( ) [EOL] empty_negative = NegativeOptionValue ( ) [EOL] self . assertEqual ( empty_positive , ( ) ) [EOL] self . assertEqual ( empty_positive , PositiveOptionValue ( ) ) [EOL] self . assertEqual ( empty_negative , ( ) ) [EOL] self . assertEqual ( empty_negative , NegativeOptionValue ( ) ) [EOL] self . assertNotEqual ( empty_positive , [string] ) [EOL] self . assertNotEqual ( empty_positive , ( [string] , ) ) [EOL] self . assertNotEqual ( empty_negative , [string] ) [EOL] self . assertNotEqual ( empty_negative , ( [string] , ) ) [EOL] [EOL] def test_option_value_format ( self ) : [EOL] val = PositiveOptionValue ( ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] [EOL] val = PositiveOptionValue ( ( [string] , ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] [EOL] val = PositiveOptionValue ( ( [string] , [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] [EOL] val = NegativeOptionValue ( ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] self . assertEquals ( [string] , val . format ( [string] ) ) [EOL] [EOL] def test_option_value ( self , name = [string] , nargs = [number] , default = None ) : [EOL] disabled = name . startswith ( ( [string] , [string] ) ) [EOL] if disabled : [EOL] negOptionValue = PositiveOptionValue [EOL] posOptionValue = NegativeOptionValue [EOL] else : [EOL] posOptionValue = PositiveOptionValue [EOL] negOptionValue = NegativeOptionValue [EOL] defaultValue = ( PositiveOptionValue ( default ) [EOL] if default else negOptionValue ( ) ) [EOL] [EOL] option = Option ( [string] % name , nargs = nargs , default = default ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] ) or disabled : [EOL] value = option . get_value ( [string] % name , [string] ) [EOL] self . assertEquals ( value , posOptionValue ( ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] % name ) [EOL] if nargs == [number] : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] elif nargs == [string] : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] else : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] [EOL] value = option . get_value ( [string] ) [EOL] self . assertEquals ( value , defaultValue ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] [EOL] value = option . get_value ( None ) [EOL] self . assertEquals ( value , defaultValue ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] value = option . get_value ( [string] , [string] ) [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] value = option . get_value ( [string] , [string] ) [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] value = option . get_value ( [string] ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] , [string] ) and not disabled : [EOL] value = option . get_value ( [string] % name , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] % name ) [EOL] if disabled : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] else : [EOL] self . assertEquals ( e . exception . message , [string] % ( name , nargs ) ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] , [string] ) and not disabled : [EOL] value = option . get_value ( [string] % name , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] % name ) [EOL] if disabled : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] else : [EOL] self . assertEquals ( e . exception . message , [string] % ( name , nargs ) ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] ) and not disabled : [EOL] value = option . get_value ( [string] % name , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , [string] ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] % name , [string] ) [EOL] if disabled : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] elif nargs == [string] : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] else : [EOL] self . assertEquals ( e . exception . message , [string] % ( name , nargs , [string] if nargs != [number] else [string] ) ) [EOL] [EOL] option = Option ( [string] % name , env = [string] , nargs = nargs , default = default ) [EOL] if nargs in ( [number] , [string] , [string] ) or disabled : [EOL] value = option . get_value ( [string] % name , [string] ) [EOL] self . assertEquals ( value , posOptionValue ( ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] % name ) [EOL] if disabled : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] elif nargs == [string] : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] else : [EOL] self . assertEquals ( e . exception . message , [string] % ( name , nargs , [string] if nargs != [number] else [string] ) ) [EOL] [EOL] value = option . get_value ( [string] ) [EOL] self . assertEquals ( value , defaultValue ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] [EOL] value = option . get_value ( None ) [EOL] self . assertEquals ( value , defaultValue ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] [EOL] value = option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , NegativeOptionValue ( ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] ) : [EOL] value = option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] elif nargs in ( [number] , [string] ) : [EOL] value = option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] , [string] ) and not disabled : [EOL] value = option . get_value ( [string] % name , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] % name , [string] ) [EOL] if disabled : [EOL] self . assertEquals ( e . exception . message , [string] % name ) [EOL] else : [EOL] self . assertEquals ( e . exception . message , [string] % ( name , nargs ) ) [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] value = option . get_value ( [string] , [string] ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] , [string] ) : [EOL] value = option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( e . exception . message , [string] % nargs ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] ) : [EOL] value = option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , [string] ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] , [string] ) [EOL] if nargs == [string] : [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] else : [EOL] self . assertEquals ( e . exception . message , [string] % ( nargs , [string] if nargs != [number] else [string] ) ) [EOL] [EOL] if disabled : [EOL] return option [EOL] [EOL] env_option = Option ( env = [string] , nargs = nargs , default = default ) [EOL] with self . assertRaises ( AssertionError ) : [EOL] env_option . get_value ( [string] % name ) [EOL] [EOL] value = env_option . get_value ( [string] ) [EOL] self . assertEquals ( value , defaultValue ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] [EOL] value = env_option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , negOptionValue ( ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] ) : [EOL] value = env_option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , posOptionValue ( ) ) [EOL] self . assertTrue ( value ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] elif nargs in ( [number] , [string] ) : [EOL] value = env_option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] env_option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( AssertionError ) as e : [EOL] env_option . get_value ( [string] % name ) [EOL] [EOL] with self . assertRaises ( AssertionError ) as e : [EOL] env_option . get_value ( [string] ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] , [string] ) : [EOL] value = env_option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] env_option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( e . exception . message , [string] % nargs ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] ) : [EOL] value = env_option . get_value ( [string] , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ( [string] , [string] ) ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] env_option . get_value ( [string] , [string] ) [EOL] if nargs == [string] : [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] else : [EOL] self . assertEquals ( e . exception . message , [string] % ( nargs , [string] if nargs != [number] else [string] ) ) [EOL] [EOL] return option [EOL] [EOL] def test_option_value_enable ( self , enable = [string] , disable = [string] , nargs = [number] , default = None ) : [EOL] option = self . test_option_value ( [string] % enable , nargs = nargs , default = default ) [EOL] [EOL] value = option . get_value ( [string] % disable , [string] ) [EOL] self . assertEquals ( value , NegativeOptionValue ( ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] [EOL] option = self . test_option_value ( [string] % disable , nargs = nargs , default = default ) [EOL] [EOL] if nargs in ( [number] , [string] , [string] ) : [EOL] value = option . get_value ( [string] % enable , [string] ) [EOL] self . assertEquals ( value , PositiveOptionValue ( ) ) [EOL] self . assertEquals ( value . origin , [string] ) [EOL] else : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] option . get_value ( [string] % enable , [string] ) [EOL] if nargs == [number] : [EOL] self . assertEquals ( e . exception . message , [string] % enable ) [EOL] elif nargs == [string] : [EOL] self . assertEquals ( e . exception . message , [string] % enable ) [EOL] else : [EOL] self . assertEquals ( e . exception . message , [string] % enable ) [EOL] [EOL] def test_option_value_with ( self ) : [EOL] self . test_option_value_enable ( [string] , [string] ) [EOL] [EOL] def test_option_value_invalid_nargs ( self ) : [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = - [number] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] def test_option_value_nargs_1 ( self ) : [EOL] self . test_option_value ( nargs = [number] ) [EOL] self . test_option_value ( nargs = [number] , default = ( [string] , ) ) [EOL] self . test_option_value_enable ( nargs = [number] , default = ( [string] , ) ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] def test_option_value_nargs_2 ( self ) : [EOL] self . test_option_value ( nargs = [number] ) [EOL] self . test_option_value ( nargs = [number] , default = ( [string] , [string] ) ) [EOL] self . test_option_value_enable ( nargs = [number] , default = ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [number] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] def test_option_value_nargs_0_or_1 ( self ) : [EOL] self . test_option_value ( nargs = [string] ) [EOL] self . test_option_value ( nargs = [string] , default = ( [string] , ) ) [EOL] self . test_option_value_enable ( nargs = [string] ) [EOL] self . test_option_value_enable ( nargs = [string] , default = ( [string] , ) ) [EOL] [EOL] def test_option_value_nargs_0_or_more ( self ) : [EOL] self . test_option_value ( nargs = [string] ) [EOL] self . test_option_value ( nargs = [string] , default = ( [string] , ) ) [EOL] self . test_option_value ( nargs = [string] , default = ( [string] , [string] ) ) [EOL] self . test_option_value_enable ( nargs = [string] ) [EOL] self . test_option_value_enable ( nargs = [string] , default = ( [string] , ) ) [EOL] self . test_option_value_enable ( nargs = [string] , default = ( [string] , [string] ) ) [EOL] [EOL] def test_option_value_nargs_1_or_more ( self ) : [EOL] self . test_option_value ( nargs = [string] ) [EOL] self . test_option_value ( nargs = [string] , default = ( [string] , ) ) [EOL] self . test_option_value ( nargs = [string] , default = ( [string] , [string] ) ) [EOL] self . test_option_value_enable ( nargs = [string] , default = ( [string] , ) ) [EOL] self . test_option_value_enable ( nargs = [string] , default = ( [string] , [string] ) ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( InvalidOptionError ) as e : [EOL] Option ( [string] , nargs = [string] ) [EOL] self . assertEquals ( e . exception . message , [string] ) [EOL] [EOL] [EOL] class TestCommandLineHelper ( unittest . TestCase ) : [EOL] def test_basic ( self ) : [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] , [string] ] ) [EOL] [EOL] self . assertEquals ( [ [string] , [string] ] , list ( helper ) ) [EOL] [EOL] helper . add ( [string] ) [EOL] [EOL] self . assertEquals ( [ [string] , [string] , [string] ] , list ( helper ) ) [EOL] [EOL] value , option = helper . handle ( Option ( [string] ) ) [EOL] self . assertEquals ( [ [string] , [string] ] , list ( helper ) ) [EOL] self . assertEquals ( PositiveOptionValue ( ) , value ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] value , option = helper . handle ( Option ( [string] ) ) [EOL] self . assertEquals ( [ [string] , [string] ] , list ( helper ) ) [EOL] self . assertEquals ( NegativeOptionValue ( ) , value ) [EOL] self . assertEquals ( None , option ) [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] CommandLineHelper ( { } , [ [string] , [string] ] ) [EOL] [EOL] def test_precedence ( self ) : [EOL] foo = Option ( [string] , nargs = [string] ) [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( NegativeOptionValue ( ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] foo = Option ( [string] , env = [string] , nargs = [string] ) [EOL] helper = CommandLineHelper ( { [string] : [string] } , [ [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { [string] : [string] } , [ [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( NegativeOptionValue ( ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { [string] : [string] } , [ [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( NegativeOptionValue ( ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { [string] : [string] } , [ [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( NegativeOptionValue ( ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] , [string] ] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( NegativeOptionValue ( ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] def test_extra_args ( self ) : [EOL] foo = Option ( [string] , env = [string] , nargs = [string] ) [EOL] helper = CommandLineHelper ( { } , [ [string] ] ) [EOL] helper . add ( [string] , [string] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] helper = CommandLineHelper ( { } , [ [string] ] ) [EOL] helper . add ( [string] , [string] ) [EOL] helper . add ( [string] , [string] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] [comment] [EOL] helper = CommandLineHelper ( { } , [ [string] ] ) [EOL] helper . add ( [string] , [string] ) [EOL] with self . assertRaises ( ConflictingOptionError ) as cm : [EOL] helper . add ( [string] , [string] ) [EOL] self . assertEqual ( [string] , cm . exception . arg ) [EOL] self . assertEqual ( [string] , cm . exception . origin ) [EOL] self . assertEqual ( [string] , cm . exception . old_arg ) [EOL] self . assertEqual ( [string] , cm . exception . old_origin ) [EOL] with self . assertRaises ( ConflictingOptionError ) as cm : [EOL] helper . add ( [string] , [string] ) [EOL] self . assertEqual ( [string] , cm . exception . arg ) [EOL] self . assertEqual ( [string] , cm . exception . origin ) [EOL] self . assertEqual ( [string] , cm . exception . old_arg ) [EOL] self . assertEqual ( [string] , cm . exception . old_origin ) [EOL] [comment] [EOL] helper . add ( [string] , [string] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] helper = CommandLineHelper ( { } , [ [string] ] ) [EOL] helper . add ( [string] , [string] ) [EOL] helper . add ( [string] , [string] ) [EOL] with self . assertRaises ( ConflictingOptionError ) as cm : [EOL] helper . handle ( foo ) [EOL] self . assertEqual ( [string] , cm . exception . arg ) [EOL] self . assertEqual ( [string] , cm . exception . origin ) [EOL] self . assertEqual ( [string] , cm . exception . old_arg ) [EOL] self . assertEqual ( [string] , cm . exception . old_origin ) [EOL] helper = CommandLineHelper ( { } , [ [string] ] ) [EOL] helper . add ( [string] , [string] ) [EOL] helper . add ( [string] , [string] ) [EOL] with self . assertRaises ( ConflictingOptionError ) as cm : [EOL] helper . handle ( foo ) [EOL] self . assertEqual ( [string] , cm . exception . arg ) [EOL] self . assertEqual ( [string] , cm . exception . origin ) [EOL] self . assertEqual ( [string] , cm . exception . old_arg ) [EOL] self . assertEqual ( [string] , cm . exception . old_origin ) [EOL] helper = CommandLineHelper ( { } , [ [string] ] ) [EOL] helper . add ( [string] , [string] ) [EOL] helper . add ( [string] , [string] ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ( [string] , [string] , [string] ) ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] ] ) [EOL] helper . add ( [string] , [string] ) [EOL] with self . assertRaises ( ConflictingOptionError ) as cm : [EOL] helper . handle ( foo ) [EOL] self . assertEqual ( [string] , cm . exception . arg ) [EOL] self . assertEqual ( [string] , cm . exception . origin ) [EOL] self . assertEqual ( [string] , cm . exception . old_arg ) [EOL] self . assertEqual ( [string] , cm . exception . old_origin ) [EOL] [EOL] helper = CommandLineHelper ( { } , [ [string] , [string] ] ) [EOL] helper . add ( [string] , [string] ) [EOL] with self . assertRaises ( ConflictingOptionError ) as cm : [EOL] helper . handle ( foo ) [EOL] self . assertEqual ( [string] , cm . exception . arg ) [EOL] self . assertEqual ( [string] , cm . exception . origin ) [EOL] self . assertEqual ( [string] , cm . exception . old_arg ) [EOL] self . assertEqual ( [string] , cm . exception . old_origin ) [EOL] [EOL] def test_possible_origins ( self ) : [EOL] with self . assertRaises ( InvalidOptionError ) : [EOL] Option ( [string] , possible_origins = [string] ) [EOL] [EOL] helper = CommandLineHelper ( { [string] : [string] } , [ [string] , [string] , [string] ] ) [EOL] foo = Option ( [string] , possible_origins = ( [string] , ) ) [EOL] value , option = helper . handle ( foo ) [EOL] self . assertEquals ( PositiveOptionValue ( ) , value ) [EOL] self . assertEquals ( [string] , value . origin ) [EOL] self . assertEquals ( [string] , option ) [EOL] [EOL] bar = Option ( [string] , possible_origins = ( [string] , ) ) [EOL] with self . assertRaisesRegexp ( InvalidOptionError , [string] ) : [EOL] helper . handle ( bar ) [EOL] [EOL] baz = Option ( env = [string] , possible_origins = ( [string] , ) ) [EOL] with self . assertRaisesRegexp ( InvalidOptionError , [string] ) : [EOL] helper . handle ( baz ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import typing [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import os [EOL] import unittest [EOL] from mozunit import main [EOL] from buildconfig import ( topobjdir , topsrcdir , ) [EOL] [EOL] from mozbuild . configure . lint import LintSandbox [EOL] [EOL] [EOL] test_path = os . path . abspath ( __file__ ) [EOL] [EOL] [EOL] class LintMeta ( type ) : [EOL] def __new__ ( mcs , name , bases , attrs ) : [EOL] def create_test ( project , func ) : [EOL] def test ( self ) : [EOL] return func ( self , project ) [EOL] return test [EOL] [EOL] for project in ( [string] , [string] , [string] , [string] , [string] , ) : [EOL] attrs [ [string] % project . replace ( [string] , [string] ) ] = create_test ( project , attrs [ [string] ] ) [EOL] [EOL] return type . __new__ ( mcs , name , bases , attrs ) [EOL] [EOL] [EOL] class Lint ( unittest . TestCase ) : [EOL] __metaclass__ = LintMeta [EOL] [EOL] def setUp ( self ) : [EOL] self . _curdir = os . getcwd ( ) [EOL] os . chdir ( topobjdir ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . chdir ( self . _curdir ) [EOL] [EOL] def lint ( self , project ) : [EOL] sandbox = LintSandbox ( { [string] : os . path . join ( topsrcdir , [string] ) , [string] : os . path . join ( os . path . dirname ( test_path ) , [string] , [string] ) , } , [ [string] , [string] % project , [string] ] ) [EOL] sandbox . run ( os . path . join ( topsrcdir , [string] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[signingscript.src.signingscript.vendored.mozbuild.mozbuild.test.configure.lint.LintMeta]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set , List , Tuple [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import unittest [EOL] [EOL] from mozfile . mozfile import NamedTemporaryFile [EOL] [EOL] from mozbuild . compilation . warnings import CompilerWarning [EOL] from mozbuild . compilation . warnings import WarningsCollector [EOL] from mozbuild . compilation . warnings import WarningsDatabase [EOL] [EOL] from mozunit import main [EOL] [EOL] CLANG_TESTS = [ ( [string] , [string] , [number] , [number] , [string] , [string] ) , ( [string] [string] , [string] , [number] , [number] , [string] , [string] ) ] [EOL] [EOL] MSVC_TESTS = [ ( [string] [string] , [string] , [number] , [string] , [string] [string] ) ] [EOL] [EOL] CURRENT_LINE = [number] [EOL] [EOL] [EOL] def get_warning ( ) : [EOL] global CURRENT_LINE [EOL] [EOL] w = CompilerWarning ( ) [EOL] w [ [string] ] = [string] [EOL] w [ [string] ] = CURRENT_LINE [EOL] w [ [string] ] = [number] [EOL] w [ [string] ] = [string] [EOL] [EOL] CURRENT_LINE += [number] [EOL] [EOL] return w [EOL] [EOL] [EOL] class TestCompilerWarning ( unittest . TestCase ) : [EOL] def test_equivalence ( self ) : [EOL] w1 = CompilerWarning ( ) [EOL] w2 = CompilerWarning ( ) [EOL] [EOL] s = set ( ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( w1 , w2 ) [EOL] [EOL] s . add ( w1 ) [EOL] s . add ( w2 ) [EOL] [EOL] self . assertEqual ( len ( s ) , [number] ) [EOL] [EOL] w1 [ [string] ] = [string] [EOL] w2 [ [string] ] = [string] [EOL] [EOL] self . assertNotEqual ( w1 , w2 ) [EOL] [EOL] s = set ( ) [EOL] s . add ( w1 ) [EOL] s . add ( w2 ) [EOL] [EOL] self . assertEqual ( len ( s ) , [number] ) [EOL] [EOL] w1 [ [string] ] = [string] [EOL] w1 [ [string] ] = [number] [EOL] w2 [ [string] ] = [number] [EOL] [EOL] w2 [ [string] ] = [string] [EOL] w1 [ [string] ] = [number] [EOL] w2 [ [string] ] = [number] [EOL] [EOL] self . assertEqual ( w1 , w2 ) [EOL] [EOL] def test_comparison ( self ) : [EOL] w1 = CompilerWarning ( ) [EOL] w2 = CompilerWarning ( ) [EOL] [EOL] w1 [ [string] ] = [string] [EOL] w1 [ [string] ] = [number] [EOL] w1 [ [string] ] = [number] [EOL] [EOL] w2 [ [string] ] = [string] [EOL] w2 [ [string] ] = [number] [EOL] w2 [ [string] ] = [number] [EOL] [EOL] self . assertLess ( w1 , w2 ) [EOL] self . assertGreater ( w2 , w1 ) [EOL] self . assertGreaterEqual ( w2 , w1 ) [EOL] [EOL] w2 [ [string] ] = [string] [EOL] w2 [ [string] ] = [number] [EOL] w2 [ [string] ] = [number] [EOL] [EOL] self . assertLess ( w2 , w1 ) [EOL] self . assertGreater ( w1 , w2 ) [EOL] self . assertGreaterEqual ( w1 , w2 ) [EOL] [EOL] w2 [ [string] ] = [string] [EOL] w2 [ [string] ] = [number] [EOL] w2 [ [string] ] = [number] [EOL] [EOL] self . assertLess ( w1 , w2 ) [EOL] self . assertGreater ( w2 , w1 ) [EOL] self . assertGreaterEqual ( w2 , w1 ) [EOL] [EOL] w2 [ [string] ] = [string] [EOL] w2 [ [string] ] = [number] [EOL] w2 [ [string] ] = [number] [EOL] [EOL] self . assertLessEqual ( w1 , w2 ) [EOL] self . assertLessEqual ( w2 , w1 ) [EOL] self . assertGreaterEqual ( w2 , w1 ) [EOL] self . assertGreaterEqual ( w1 , w2 ) [EOL] [EOL] [EOL] class TestWarningsParsing ( unittest . TestCase ) : [EOL] def test_clang_parsing ( self ) : [EOL] for source , filename , line , column , message , flag in CLANG_TESTS : [EOL] collector = WarningsCollector ( lambda w : None ) [EOL] warning = collector . process_line ( source ) [EOL] [EOL] self . assertIsNotNone ( warning ) [EOL] [EOL] self . assertEqual ( warning [ [string] ] , filename ) [EOL] self . assertEqual ( warning [ [string] ] , line ) [EOL] self . assertEqual ( warning [ [string] ] , column ) [EOL] self . assertEqual ( warning [ [string] ] , message ) [EOL] self . assertEqual ( warning [ [string] ] , flag ) [EOL] [EOL] def test_msvc_parsing ( self ) : [EOL] for source , filename , line , flag , message in MSVC_TESTS : [EOL] collector = WarningsCollector ( lambda w : None ) [EOL] warning = collector . process_line ( source ) [EOL] [EOL] self . assertIsNotNone ( warning ) [EOL] [EOL] self . assertEqual ( warning [ [string] ] , os . path . normpath ( filename ) ) [EOL] self . assertEqual ( warning [ [string] ] , line ) [EOL] self . assertEqual ( warning [ [string] ] , flag ) [EOL] self . assertEqual ( warning [ [string] ] , message ) [EOL] [EOL] [EOL] class TestWarningsDatabase ( unittest . TestCase ) : [EOL] def test_basic ( self ) : [EOL] db = WarningsDatabase ( ) [EOL] [EOL] self . assertEqual ( len ( db ) , [number] ) [EOL] [EOL] for i in range ( [number] ) : [EOL] db . insert ( get_warning ( ) , compute_hash = False ) [EOL] [EOL] self . assertEqual ( len ( db ) , [number] ) [EOL] [EOL] warnings = list ( db ) [EOL] self . assertEqual ( len ( warnings ) , [number] ) [EOL] [EOL] def test_hashing ( self ) : [EOL] [docstring] [EOL] db = WarningsDatabase ( ) [EOL] [EOL] temp = NamedTemporaryFile ( mode = [string] ) [EOL] temp . write ( [string] * [number] ) [EOL] temp . flush ( ) [EOL] [EOL] w = CompilerWarning ( ) [EOL] w [ [string] ] = temp . name [EOL] w [ [string] ] = [number] [EOL] w [ [string] ] = [number] [EOL] w [ [string] ] = [string] [EOL] [EOL] [comment] [EOL] db . insert ( w ) [EOL] [EOL] w [ [string] ] = [string] [EOL] [EOL] with self . assertRaises ( Exception ) : [EOL] db . insert ( w ) [EOL] [EOL] def test_pruning ( self ) : [EOL] [docstring] [EOL] db = WarningsDatabase ( ) [EOL] [EOL] source_files = [ ] [EOL] for i in range ( [number] , [number] ) : [EOL] temp = NamedTemporaryFile ( mode = [string] ) [EOL] temp . write ( [string] * ( [number] * i ) ) [EOL] temp . flush ( ) [EOL] [EOL] [comment] [EOL] source_files . append ( temp ) [EOL] [EOL] w = CompilerWarning ( ) [EOL] w [ [string] ] = temp . name [EOL] w [ [string] ] = [number] [EOL] w [ [string] ] = i * [number] [EOL] w [ [string] ] = [string] [EOL] [EOL] db . insert ( w ) [EOL] [EOL] self . assertEqual ( len ( db ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] source_files [ [number] ] . write ( [string] ) [EOL] source_files [ [number] ] . flush ( ) [EOL] [EOL] w = CompilerWarning ( ) [EOL] w [ [string] ] = source_files [ [number] ] . name [EOL] w [ [string] ] = [number] [EOL] w [ [string] ] = [number] [EOL] w [ [string] ] = [string] [EOL] [EOL] db . insert ( w ) [EOL] [EOL] self . assertEqual ( len ( db ) , [number] ) [EOL] [EOL] warnings = list ( db . warnings_for_file ( source_files [ [number] ] . name ) ) [EOL] self . assertEqual ( len ( warnings ) , [number] ) [EOL] self . assertEqual ( warnings [ [number] ] [ [string] ] , w [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] old_filename = source_files [ [number] ] . name [EOL] del source_files [ [number] ] [EOL] [EOL] self . assertFalse ( os . path . exists ( old_filename ) ) [EOL] [EOL] db . prune ( ) [EOL] self . assertEqual ( len ( db ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.int,builtins.str,builtins.str]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.str,builtins.str]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import typing [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import time [EOL] import unittest [EOL] [EOL] from mozunit import main [EOL] [EOL] from mozbuild . controller . building import CCacheStats [EOL] [EOL] [EOL] class TestCcacheStats ( unittest . TestCase ) : [EOL] STAT_GARBAGE = [string] [EOL] [EOL] STAT0 = [string] [EOL] [EOL] STAT1 = [string] [EOL] [EOL] STAT2 = [string] [EOL] [EOL] STAT3 = [string] [EOL] [EOL] STAT4 = [string] [EOL] [EOL] STAT5 = [string] [EOL] [EOL] STAT6 = [string] [EOL] [EOL] STAT7 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] STAT8 = [string] . format ( timestamp = time . strftime ( [string] ) ) [EOL] [EOL] STAT9 = [string] . format ( timestamp = time . strftime ( [string] ) , timestamp2 = time . strftime ( [string] ) ) [EOL] [EOL] def test_parse_garbage_stats_message ( self ) : [EOL] self . assertRaises ( ValueError , CCacheStats , self . STAT_GARBAGE ) [EOL] [EOL] def test_parse_zero_stats_message ( self ) : [EOL] stats = CCacheStats ( self . STAT0 ) [EOL] self . assertEqual ( stats . cache_dir , [string] ) [EOL] self . assertEqual ( stats . hit_rates ( ) , ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_hit_rate_of_diff_stats ( self ) : [EOL] stats1 = CCacheStats ( self . STAT1 ) [EOL] stats2 = CCacheStats ( self . STAT2 ) [EOL] stats_diff = stats2 - stats1 [EOL] self . assertEqual ( stats_diff . hit_rates ( ) , ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_stats_contains_data ( self ) : [EOL] stats0 = CCacheStats ( self . STAT0 ) [EOL] stats1 = CCacheStats ( self . STAT1 ) [EOL] stats2 = CCacheStats ( self . STAT2 ) [EOL] stats_diff_zero = stats1 - stats1 [EOL] stats_diff_negative1 = stats0 - stats1 [EOL] stats_diff_negative2 = stats1 - stats2 [EOL] [EOL] self . assertFalse ( stats0 ) [EOL] self . assertTrue ( stats1 ) [EOL] self . assertTrue ( stats2 ) [EOL] self . assertFalse ( stats_diff_zero ) [EOL] self . assertFalse ( stats_diff_negative1 ) [EOL] self . assertFalse ( stats_diff_negative2 ) [EOL] [EOL] def test_stats_version32 ( self ) : [EOL] stat2 = CCacheStats ( self . STAT2 ) [EOL] stat3 = CCacheStats ( self . STAT3 ) [EOL] stats_diff = stat3 - stat2 [EOL] self . assertTrue ( stat3 ) [EOL] self . assertTrue ( stats_diff ) [EOL] [EOL] def test_cache_size_shrinking ( self ) : [EOL] stat4 = CCacheStats ( self . STAT4 ) [EOL] stat5 = CCacheStats ( self . STAT5 ) [EOL] stats_diff = stat5 - stat4 [EOL] self . assertTrue ( stat4 ) [EOL] self . assertTrue ( stat5 ) [EOL] self . assertTrue ( stats_diff ) [EOL] [EOL] def test_stats_version33 ( self ) : [EOL] [comment] [EOL] stat3 = CCacheStats ( self . STAT3 ) [EOL] stat6 = CCacheStats ( self . STAT6 ) [EOL] stats_diff = stat6 - stat3 [EOL] self . assertTrue ( stat6 ) [EOL] self . assertTrue ( stat3 ) [EOL] self . assertTrue ( stats_diff ) [EOL] [EOL] [comment] [EOL] stat7 = CCacheStats ( self . STAT7 ) [EOL] self . assertTrue ( stat7 ) [EOL] [EOL] def test_stats_version34 ( self ) : [EOL] [comment] [EOL] stat8 = CCacheStats ( self . STAT8 ) [EOL] self . assertTrue ( stat8 ) [EOL] [EOL] def test_stats_version35 ( self ) : [EOL] [comment] [EOL] stat9 = CCacheStats ( self . STAT9 ) [EOL] self . assertTrue ( stat9 ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set , Dict [EOL] import _importlib_modulespec [EOL] import typing [EOL] import argparse [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import argparse [EOL] import imp [EOL] import os [EOL] import sys [EOL] import traceback [EOL] [EOL] from mozbuild . pythonutil import iter_modules_in_path [EOL] from mozbuild . makeutil import Makefile [EOL] from mozbuild . util import FileAvoidWrite [EOL] import buildconfig [EOL] [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( [string] , add_help = False ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , nargs = argparse . REMAINDER , help = [string] ) [EOL] [EOL] args = parser . parse_args ( argv ) [EOL] [EOL] kwargs = { } [EOL] if args . locale : [EOL] kwargs [ [string] ] = args . locale [EOL] script = args . python_script [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . path . append ( os . path . dirname ( script ) ) [EOL] with open ( script , [string] ) as fh : [EOL] module = imp . load_module ( [string] , fh , script , ( [string] , [string] , imp . PY_SOURCE ) ) [EOL] method = args . method_name [EOL] if not hasattr ( module , method ) : [EOL] print ( [string] . format ( script , method ) , file = sys . stderr ) [EOL] return [number] [EOL] [EOL] ret = [number] [EOL] try : [EOL] with FileAvoidWrite ( args . output_file , mode = [string] ) as output : [EOL] try : [EOL] ret = module . __dict__ [ method ] ( output , * args . additional_arguments , ** kwargs ) [EOL] except Exception : [EOL] [comment] [EOL] output . avoid_writing_to_file ( ) [EOL] raise [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( ret , set ) : [EOL] deps = ret [EOL] [comment] [EOL] ret = None [EOL] else : [EOL] deps = set ( ) [EOL] [EOL] [comment] [EOL] if not ret : [EOL] [comment] [EOL] [comment] [EOL] deps |= set ( iter_modules_in_path ( buildconfig . topsrcdir , buildconfig . topobjdir ) ) [EOL] [comment] [EOL] [comment] [EOL] deps |= set ( buildconfig . get_dependencies ( ) ) [EOL] [EOL] mk = Makefile ( ) [EOL] mk . create_rule ( [ args . dep_target ] ) . add_dependencies ( deps ) [EOL] with FileAvoidWrite ( args . dep_file ) as dep_file : [EOL] mk . dump ( dep_file ) [EOL] else : [EOL] [comment] [EOL] output . avoid_writing_to_file ( ) [EOL] [EOL] except IOError as e : [EOL] print ( [string] . format ( e . filename ) , file = sys . stderr ) [EOL] traceback . print_exc ( ) [EOL] return [number] [EOL] return ret [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import sys [EOL] [EOL] import mozbuild . jar [EOL] [EOL] [EOL] def main ( args ) : [EOL] return mozbuild . jar . main ( args ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import sys [EOL] import subprocess [EOL] [EOL] [EOL] def make_zip ( source , package ) : [EOL] subprocess . check_call ( [ [string] , [string] , package , source , [string] , [string] ] ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] if len ( args ) != [number] : [EOL] print ( [string] , file = sys . stderr ) [EOL] return [number] [EOL] else : [EOL] make_zip ( args [ [number] ] , args [ [number] ] ) [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import shutil [EOL] import sys [EOL] import subprocess [EOL] [EOL] [EOL] def extract_exe ( package , target ) : [EOL] subprocess . check_call ( [ [string] , [string] , package , [string] ] ) [EOL] shutil . move ( [string] , target ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] if len ( args ) != [number] : [EOL] print ( [string] , file = sys . stderr ) [EOL] return [number] [EOL] else : [EOL] extract_exe ( args [ [number] ] , args [ [number] ] ) [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import sys [EOL] import os [EOL] [EOL] from mozbuild . util import ( ensureParentDir , lock_file , ) [EOL] [EOL] [EOL] def addEntriesToListFile ( listFile , entries ) : [EOL] [docstring] [EOL] ensureParentDir ( listFile ) [EOL] lock = lock_file ( listFile + [string] ) [EOL] try : [EOL] if os . path . exists ( listFile ) : [EOL] f = open ( listFile ) [EOL] existing = set ( x . strip ( ) for x in f . readlines ( ) ) [EOL] f . close ( ) [EOL] else : [EOL] existing = set ( ) [EOL] for e in entries : [EOL] if e not in existing : [EOL] existing . add ( e ) [EOL] with open ( listFile , [string] ) as f : [EOL] f . write ( [string] . join ( sorted ( existing ) ) + [string] ) [EOL] finally : [EOL] del lock [comment] [EOL] [EOL] [EOL] def main ( args ) : [EOL] if len ( args ) < [number] : [EOL] print ( [string] , file = sys . stderr ) [EOL] return [number] [EOL] [EOL] return addEntriesToListFile ( args [ [number] ] , args [ [number] : ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import argparse [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import argparse [EOL] import os [EOL] import sys [EOL] [EOL] from xpidl import jsonxpt [EOL] from buildconfig import topsrcdir [EOL] from xpidl . header import print_header [EOL] from xpidl . rust import print_rust_bindings [EOL] from xpidl . rust_macros import print_rust_macros_bindings [EOL] from xpidl . xpidl import IDLParser [EOL] [EOL] from mozbuild . makeutil import Makefile [EOL] from mozbuild . pythonutil import iter_modules_in_path [EOL] from mozbuild . util import FileAvoidWrite [EOL] [EOL] [EOL] def process ( input_dirs , inc_paths , bindings_conf , cache_dir , header_dir , xpcrs_dir , xpt_dir , deps_dir , module , idl_files ) : [EOL] p = IDLParser ( outputdir = cache_dir ) [EOL] [EOL] xpts = [ ] [EOL] mk = Makefile ( ) [EOL] rule = mk . create_rule ( ) [EOL] [EOL] glbl = { } [EOL] execfile ( bindings_conf , glbl ) [EOL] webidlconfig = glbl [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] rule . add_dependencies ( iter_modules_in_path ( topsrcdir ) ) [EOL] [EOL] for path in idl_files : [EOL] basename = os . path . basename ( path ) [EOL] stem , _ = os . path . splitext ( basename ) [EOL] idl_data = open ( path ) . read ( ) [EOL] [EOL] idl = p . parse ( idl_data , filename = path ) [EOL] idl . resolve ( inc_paths , p , webidlconfig ) [EOL] [EOL] header_path = os . path . join ( header_dir , [string] % stem ) [EOL] rs_rt_path = os . path . join ( xpcrs_dir , [string] , [string] % stem ) [EOL] rs_bt_path = os . path . join ( xpcrs_dir , [string] , [string] % stem ) [EOL] [EOL] xpts . append ( jsonxpt . build_typelib ( idl ) ) [EOL] [EOL] rule . add_dependencies ( idl . deps ) [EOL] [EOL] with FileAvoidWrite ( header_path ) as fh : [EOL] print_header ( idl , fh , path ) [EOL] [EOL] with FileAvoidWrite ( rs_rt_path ) as fh : [EOL] print_rust_bindings ( idl , fh , path ) [EOL] [EOL] with FileAvoidWrite ( rs_bt_path ) as fh : [EOL] print_rust_macros_bindings ( idl , fh , path ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] xpt_path = os . path . join ( xpt_dir , [string] % module ) [EOL] with open ( xpt_path , [string] ) as fh : [EOL] jsonxpt . write ( jsonxpt . link ( xpts ) , fh ) [EOL] [EOL] rule . add_targets ( [ xpt_path ] ) [EOL] if deps_dir : [EOL] deps_path = os . path . join ( deps_dir , [string] % module ) [EOL] with FileAvoidWrite ( deps_path ) as fh : [EOL] mk . dump ( fh ) [EOL] [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = [ ] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = [ ] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( argv ) [EOL] incpath = [ os . path . join ( topsrcdir , p ) for p in args . incpath ] [EOL] process ( args . input_dirs , incpath , args . bindings_conf , args . cache_dir , args . headerdir , args . xpcrsdir , args . xptdir , args . depsdir , args . module , args . idls ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import sys [EOL] [EOL] from mozwebidlcodegen import BuildSystemWebIDL [EOL] [EOL] [EOL] def main ( argv ) : [EOL] [docstring] [EOL] manager = BuildSystemWebIDL . from_environment ( ) . manager [EOL] manager . generate_build_files ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set , List [EOL] import typing [EOL] import argparse [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import argparse [EOL] import buildconfig [EOL] import subprocess [EOL] import shutil [EOL] import sys [EOL] import os [EOL] [EOL] [EOL] def dump_symbols ( target , tracking_file , count_ctors = False ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if os . path . isfile ( os . path . normpath ( tracking_file ) ) : [EOL] with open ( tracking_file , [string] ) as fh : [EOL] files = fh . read ( ) . splitlines ( ) [EOL] dirs = set ( os . path . dirname ( f ) for f in files ) [EOL] for d in dirs : [EOL] shutil . rmtree ( os . path . join ( buildconfig . topobjdir , [string] , [string] , d ) , ignore_errors = True ) [EOL] [EOL] [comment] [EOL] sym_store_args = [ ] [EOL] [EOL] dump_syms_bin = os . path . join ( buildconfig . topobjdir , [string] , [string] , [string] , [string] ) [EOL] dump_syms_bin = [string] % ( dump_syms_bin , buildconfig . substs [ [string] ] ) [EOL] [EOL] os_arch = buildconfig . substs [ [string] ] [EOL] if os_arch == [string] : [EOL] sym_store_args . extend ( [ [string] , [string] ] ) [EOL] if os . environ . get ( [string] ) : [EOL] sym_store_args . append ( [string] ) [EOL] os . environ [ [string] ] = os . pathsep . join ( ( buildconfig . substs [ [string] ] , os . environ [ [string] ] ) ) [EOL] elif os_arch == [string] : [EOL] cpu = { [string] : [string] , } . get ( buildconfig . substs [ [string] ] , buildconfig . substs [ [string] ] ) [EOL] sym_store_args . extend ( [ [string] , [string] , cpu , [string] ] ) [EOL] elif os_arch == [string] : [EOL] sym_store_args . extend ( [ [string] , [string] ] ) [EOL] [EOL] sym_store_args . append ( [string] % ( os . path . join ( buildconfig . topobjdir , [string] , [string] , [string] ) , os . path . join ( buildconfig . topobjdir , [string] , [string] ) ) ) [EOL] objcopy = buildconfig . substs . get ( [string] ) [EOL] if objcopy : [EOL] os . environ [ [string] ] = objcopy [EOL] [EOL] args = ( [ buildconfig . substs [ [string] ] , os . path . join ( buildconfig . topsrcdir , [string] , [string] , [string] , [string] ) ] + sym_store_args + [ [string] , buildconfig . topsrcdir , dump_syms_bin , os . path . join ( buildconfig . topobjdir , [string] , [string] ) , os . path . abspath ( target ) ] ) [EOL] if count_ctors : [EOL] args . append ( [string] ) [EOL] print ( [string] % [string] . join ( args ) ) [EOL] out_files = subprocess . check_output ( args ) [EOL] with open ( tracking_file , [string] ) as fh : [EOL] fh . write ( out_files ) [EOL] fh . flush ( ) [EOL] [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( usage = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] return dump_symbols ( args . library_or_program , args . tracking_file , args . count_ctors ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import argparse [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import argparse [EOL] import subprocess [EOL] import sys [EOL] import os [EOL] [EOL] [EOL] def parse_outputs ( crate_output , dep_outputs , pass_l_flag ) : [EOL] env = { } [EOL] args = [ ] [EOL] [EOL] def parse_line ( line ) : [EOL] if line . startswith ( [string] ) : [EOL] return line [ len ( [string] ) : ] . split ( [string] , [number] ) [EOL] [EOL] def parse_file ( f ) : [EOL] with open ( f ) as fh : [EOL] return [ parse_line ( line . rstrip ( ) ) for line in fh . readlines ( ) ] [EOL] [EOL] for f in dep_outputs : [EOL] for entry in parse_file ( f ) : [EOL] if not entry : [EOL] continue [EOL] key , value = entry [EOL] if key == [string] : [EOL] args += [ [string] , value ] [EOL] elif key == [string] : [EOL] flags = value . split ( ) [EOL] for flag , val in zip ( flags [ [number] : : [number] ] , flags [ [number] : : [number] ] ) : [EOL] if flag == [string] and f == crate_output : [EOL] args += [ [string] , val ] [EOL] elif flag == [string] : [EOL] args += [ [string] , val ] [EOL] else : [EOL] raise Exception ( [string] [string] % flag ) [EOL] elif key == [string] and f == crate_output : [EOL] args += [ [string] , value ] [EOL] elif key == [string] and f == crate_output : [EOL] args += [ [string] , value ] [EOL] elif key == [string] and f == crate_output : [EOL] env_key , env_value = value . split ( [string] , [number] ) [EOL] env [ env_key ] = env_value [EOL] elif key == [string] : [EOL] pass [EOL] elif key == [string] : [EOL] pass [EOL] elif key == [string] : [EOL] pass [EOL] elif key : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [EOL] return env , args [EOL] [EOL] [EOL] def wrap_rustc ( args ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , nargs = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] ) [EOL] parser . add_argument ( [string] ) [EOL] parser . add_argument ( [string] , action = [string] ) [EOL] parser . add_argument ( [string] , nargs = argparse . REMAINDER ) [EOL] args = parser . parse_args ( args ) [EOL] [EOL] new_env , new_args = parse_outputs ( args . crate_out , args . deps_out , args . pass_l_flag ) [EOL] os . environ . update ( new_env ) [EOL] return subprocess . Popen ( args . cmd + new_args , cwd = args . cwd ) . wait ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( wrap_rustc ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import sys [EOL] [EOL] from mozbuild . preprocessor import Preprocessor [EOL] [EOL] [EOL] def generate ( output , * args ) : [EOL] pp = Preprocessor ( ) [EOL] pp . out = output [EOL] pp . handleCommandLine ( list ( args ) , True ) [EOL] return set ( pp . includes ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] pp = Preprocessor ( ) [EOL] pp . handleCommandLine ( args , True ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import os [EOL] import sys [EOL] [EOL] sys . path . append ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] [EOL] from shellutil import quote [EOL] [EOL] for key , value in os . environ . items ( ) : [EOL] print ( [string] % ( key , quote ( value ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , List [EOL] import typing [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import os [EOL] import re [EOL] from mozbuild . configure . options import Option [EOL] [EOL] [EOL] class HelpFormatter ( object ) : [EOL] def __init__ ( self , argv0 ) : [EOL] self . intro = [ [string] % os . path . basename ( argv0 ) ] [EOL] self . options = [ [string] ] [EOL] self . env = [ [string] ] [EOL] [EOL] def add ( self , option ) : [EOL] assert isinstance ( option , Option ) [EOL] [EOL] if option . possible_origins == ( [string] , ) : [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] target = self . options if option . name else self . env [EOL] opt = option . option [EOL] if option . choices : [EOL] opt += [string] % [string] . join ( option . choices ) [EOL] help = self . format_help ( option ) [EOL] if len ( option . default ) : [EOL] if help : [EOL] help += [string] [EOL] help += [string] % [string] . join ( option . default ) [EOL] [EOL] if len ( opt ) > [number] or not help : [EOL] target . append ( [string] % opt ) [EOL] if help : [EOL] target . append ( [string] % ( [string] * [number] , help ) ) [EOL] else : [EOL] target . append ( [string] % ( opt , help ) ) [EOL] [EOL] RE_FORMAT = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def format_help ( self , option ) : [EOL] if not option . help : [EOL] return [string] [EOL] [EOL] if option . prefix in ( [string] , [string] ) : [EOL] replacement = [string] [EOL] elif option . prefix in ( [string] , [string] ) : [EOL] replacement = [string] [EOL] else : [EOL] return option . help [EOL] [EOL] return self . RE_FORMAT . sub ( replacement , option . help ) [EOL] [EOL] def usage ( self , out ) : [EOL] print ( [string] . join ( [string] . join ( t ) for t in ( self . intro , self . options , self . env ) ) , file = out ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any , List , Match [EOL] import subprocess [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import subprocess [EOL] import sys [EOL] import re [EOL] [EOL] [EOL] def get_range_for ( compilation_unit , debug_info ) : [EOL] [docstring] [EOL] name = ranges = [string] [EOL] search_cu = False [EOL] for nfo in debug_info . splitlines ( ) : [EOL] if [string] in nfo : [EOL] search_cu = True [EOL] elif [string] in nfo or not nfo . strip ( ) : [EOL] if name == compilation_unit and ranges != [string] : [EOL] return int ( ranges , [number] ) [EOL] name = ranges = [string] [EOL] search_cu = False [EOL] if search_cu : [EOL] if [string] in nfo : [EOL] name = nfo . rsplit ( None , [number] ) [ [number] ] [EOL] elif [string] in nfo : [EOL] ranges = nfo . rsplit ( None , [number] ) [ [number] ] [EOL] return None [EOL] [EOL] [EOL] def get_range_length ( range , debug_ranges ) : [EOL] [docstring] [EOL] length = [number] [EOL] for line in debug_ranges . splitlines ( ) : [EOL] m = re . match ( [string] , line ) [EOL] if m and int ( m . group ( [number] ) , [number] ) == range : [EOL] length += [number] [EOL] return length [EOL] [EOL] [EOL] def main ( bin , compilation_unit ) : [EOL] p = subprocess . Popen ( [ [string] , [string] , bin ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] ( out , err ) = p . communicate ( ) [EOL] sections = re . split ( [string] , out ) [EOL] debug_info = [ s for s in sections if s . startswith ( [string] ) ] [EOL] debug_ranges = [ s for s in sections if s . startswith ( [string] ) ] [EOL] if not debug_ranges or not debug_info : [EOL] return [number] [EOL] [EOL] range = get_range_for ( compilation_unit , debug_info [ [number] ] ) [EOL] if range is not None : [EOL] return get_range_length ( range , debug_ranges [ [number] ] ) [EOL] [EOL] return - [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( main ( * sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import DefaultDict , Tuple , Set , Any , Literal , Union , List [EOL] import typing [EOL] import typing_extensions [EOL] import signingscript [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] from mozbuild . frontend . context import ( ObjDirPath , SourcePath , ) [EOL] from mozpack . chrome . manifest import ManifestEntry [EOL] [EOL] import mozpack . path as mozpath [EOL] from . context import FinalTargetValue [EOL] [EOL] from collections import defaultdict [EOL] import itertools [EOL] [EOL] from . . util import ( group_unified_files , ) [EOL] [EOL] from . . testing import ( all_test_flavors , ) [EOL] [EOL] [EOL] class TreeMetadata ( object ) : [EOL] [docstring] [EOL] __slots__ = ( ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { k . lower ( ) : getattr ( self , k ) for k in self . DICT_ATTRS } [EOL] [EOL] [EOL] class ContextDerived ( TreeMetadata ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context ) : [EOL] TreeMetadata . __init__ ( self ) [EOL] [EOL] [comment] [EOL] self . context_main_path = context . main_path [EOL] self . context_all_paths = context . all_paths [EOL] [EOL] [comment] [EOL] self . topsrcdir = context . config . topsrcdir [EOL] self . topobjdir = context . config . topobjdir [EOL] [EOL] self . relsrcdir = context . relsrcdir [EOL] self . srcdir = context . srcdir [EOL] self . objdir = context . objdir [EOL] [EOL] self . config = context . config [EOL] [EOL] self . _context = context [EOL] [EOL] @ property def install_target ( self ) : [EOL] return self . _context [ [string] ] [EOL] [EOL] @ property def installed ( self ) : [EOL] return self . _context [ [string] ] is not False [EOL] [EOL] @ property def defines ( self ) : [EOL] defines = self . _context [ [string] ] [EOL] return Defines ( self . _context , defines ) if defines else None [EOL] [EOL] @ property def relobjdir ( self ) : [EOL] return mozpath . relpath ( self . objdir , self . topobjdir ) [EOL] [EOL] [EOL] class HostMixin ( object ) : [EOL] @ property def defines ( self ) : [EOL] defines = self . _context [ [string] ] [EOL] return HostDefines ( self . _context , defines ) if defines else None [EOL] [EOL] [EOL] class DirectoryTraversal ( ContextDerived ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , context ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] [EOL] self . dirs = [ ] [EOL] [EOL] [EOL] class BaseConfigSubstitution ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] [EOL] self . input_path = None [EOL] self . output_path = None [EOL] self . relpath = None [EOL] [EOL] [EOL] class ConfigFileSubstitution ( BaseConfigSubstitution ) : [EOL] [docstring] [EOL] [EOL] [EOL] class VariablePassthru ( ContextDerived ) : [EOL] [docstring] [EOL] __slots__ = ( [string] ) [EOL] [EOL] def __init__ ( self , context ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . variables = { } [EOL] [EOL] [EOL] class ComputedFlags ( ContextDerived ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , context , reader_flags ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . flags = reader_flags [EOL] [EOL] def resolve_flags ( self , key , value ) : [EOL] [comment] [EOL] [comment] [EOL] dict . __setitem__ ( self . flags , key , value ) [EOL] [EOL] def get_flags ( self ) : [EOL] flags = defaultdict ( list ) [EOL] for key , _ , dest_vars in self . flags . flag_variables : [EOL] value = self . flags . get ( key ) [EOL] if value : [EOL] for dest_var in dest_vars : [EOL] flags [ dest_var ] . extend ( value ) [EOL] return flags . items ( ) [EOL] [EOL] [EOL] class XPIDLModule ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , name , idl_files ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] [EOL] assert all ( isinstance ( idl , SourcePath ) for idl in idl_files ) [EOL] self . name = name [EOL] self . idl_files = idl_files [EOL] [EOL] [EOL] class BaseDefines ( ContextDerived ) : [EOL] [docstring] [EOL] __slots__ = ( [string] ) [EOL] [EOL] def __init__ ( self , context , defines ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . defines = defines [EOL] [EOL] def get_defines ( self ) : [EOL] for define , value in self . defines . iteritems ( ) : [EOL] if value is True : [EOL] yield( [string] % define ) [EOL] elif value is False : [EOL] yield( [string] % define ) [EOL] else : [EOL] yield( [string] % ( define , value ) ) [EOL] [EOL] def update ( self , more_defines ) : [EOL] if isinstance ( more_defines , Defines ) : [EOL] self . defines . update ( more_defines . defines ) [EOL] else : [EOL] self . defines . update ( more_defines ) [EOL] [EOL] [EOL] class Defines ( BaseDefines ) : [EOL] pass [EOL] [EOL] [EOL] class HostDefines ( BaseDefines ) : [EOL] pass [EOL] [EOL] [EOL] class WebIDLCollection ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , context ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . sources = set ( ) [EOL] self . generated_sources = set ( ) [EOL] self . generated_events_sources = set ( ) [EOL] self . preprocessed_sources = set ( ) [EOL] self . test_sources = set ( ) [EOL] self . preprocessed_test_sources = set ( ) [EOL] self . example_interfaces = set ( ) [EOL] [EOL] def all_regular_sources ( self ) : [EOL] return self . sources | self . generated_sources | self . generated_events_sources | self . preprocessed_sources [EOL] [EOL] def all_regular_basenames ( self ) : [EOL] return [ mozpath . basename ( source ) for source in self . all_regular_sources ( ) ] [EOL] [EOL] def all_regular_stems ( self ) : [EOL] return [ mozpath . splitext ( b ) [ [number] ] for b in self . all_regular_basenames ( ) ] [EOL] [EOL] def all_regular_bindinggen_stems ( self ) : [EOL] for stem in self . all_regular_stems ( ) : [EOL] yield [string] % stem [EOL] [EOL] for source in self . generated_events_sources : [EOL] yield mozpath . splitext ( mozpath . basename ( source ) ) [ [number] ] [EOL] [EOL] def all_regular_cpp_basenames ( self ) : [EOL] for stem in self . all_regular_bindinggen_stems ( ) : [EOL] yield [string] % stem [EOL] [EOL] def all_test_sources ( self ) : [EOL] return self . test_sources | self . preprocessed_test_sources [EOL] [EOL] def all_test_basenames ( self ) : [EOL] return [ mozpath . basename ( source ) for source in self . all_test_sources ( ) ] [EOL] [EOL] def all_test_stems ( self ) : [EOL] return [ mozpath . splitext ( b ) [ [number] ] for b in self . all_test_basenames ( ) ] [EOL] [EOL] def all_test_cpp_basenames ( self ) : [EOL] return sorted ( [string] % s for s in self . all_test_stems ( ) ) [EOL] [EOL] def all_static_sources ( self ) : [EOL] return self . sources | self . generated_events_sources | self . test_sources [EOL] [EOL] def all_non_static_sources ( self ) : [EOL] return self . generated_sources | self . all_preprocessed_sources ( ) [EOL] [EOL] def all_non_static_basenames ( self ) : [EOL] return [ mozpath . basename ( s ) for s in self . all_non_static_sources ( ) ] [EOL] [EOL] def all_preprocessed_sources ( self ) : [EOL] return self . preprocessed_sources | self . preprocessed_test_sources [EOL] [EOL] def all_sources ( self ) : [EOL] return set ( self . all_regular_sources ( ) ) | set ( self . all_test_sources ( ) ) [EOL] [EOL] def all_basenames ( self ) : [EOL] return [ mozpath . basename ( source ) for source in self . all_sources ( ) ] [EOL] [EOL] def all_stems ( self ) : [EOL] return [ mozpath . splitext ( b ) [ [number] ] for b in self . all_basenames ( ) ] [EOL] [EOL] def generated_events_basenames ( self ) : [EOL] return [ mozpath . basename ( s ) for s in self . generated_events_sources ] [EOL] [EOL] def generated_events_stems ( self ) : [EOL] return [ mozpath . splitext ( b ) [ [number] ] for b in self . generated_events_basenames ( ) ] [EOL] [EOL] @ property def unified_source_mapping ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return list ( group_unified_files ( self . all_regular_cpp_basenames ( ) , unified_prefix = [string] , unified_suffix = [string] , files_per_unified_file = [number] ) ) [EOL] [EOL] def all_source_files ( self ) : [EOL] from mozwebidlcodegen import WebIDLCodegenManager [EOL] return ( sorted ( list ( WebIDLCodegenManager . GLOBAL_DEFINE_FILES ) ) + sorted ( set ( p for p , _ in self . unified_source_mapping ) ) ) [EOL] [EOL] [EOL] class IPDLCollection ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , context ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . sources = set ( ) [EOL] self . preprocessed_sources = set ( ) [EOL] [EOL] def all_sources ( self ) : [EOL] return self . sources | self . preprocessed_sources [EOL] [EOL] def all_regular_sources ( self ) : [EOL] return self . sources [EOL] [EOL] def all_preprocessed_sources ( self ) : [EOL] return self . preprocessed_sources [EOL] [EOL] def all_generated_sources ( self ) : [EOL] sorted_ipdl_sources = list ( sorted ( self . all_sources ( ) ) ) [EOL] [EOL] def files_from ( ipdl ) : [EOL] base = mozpath . basename ( ipdl ) [EOL] root , ext = mozpath . splitext ( base ) [EOL] [EOL] [comment] [EOL] files = [ [string] % root ] [EOL] if ext == [string] : [EOL] [comment] [EOL] files . extend ( [ [string] % root , [string] % root ] ) [EOL] return files [EOL] [EOL] return list ( itertools . chain ( * [ files_from ( p ) for p in sorted_ipdl_sources ] ) ) [EOL] [EOL] @ property def unified_source_mapping ( self ) : [EOL] return list ( group_unified_files ( self . all_generated_sources ( ) , unified_prefix = [string] , unified_suffix = [string] , files_per_unified_file = [number] ) ) [EOL] [EOL] def all_source_files ( self ) : [EOL] return sorted ( set ( p for p , _ in self . unified_source_mapping ) ) [EOL] [EOL] [EOL] class XPCOMComponentManifests ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , context ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . manifests = set ( ) [EOL] [EOL] def all_sources ( self ) : [EOL] return self . manifests [EOL] [EOL] def all_source_files ( self ) : [EOL] return [ ] [EOL] [EOL] [EOL] class LinkageWrongKindError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class LinkageMultipleRustLibrariesError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Linkable ( ContextDerived ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . cxx_link = False [EOL] self . linked_libraries = [ ] [EOL] self . linked_system_libs = [ ] [EOL] self . lib_defines = Defines ( context , { } ) [EOL] self . sources = defaultdict ( list ) [EOL] self . no_pgo_sources = [ ] [EOL] self . no_pgo = False [EOL] [EOL] def link_library ( self , obj ) : [EOL] assert isinstance ( obj , BaseLibrary ) [EOL] if obj . KIND != self . KIND : [EOL] raise LinkageWrongKindError ( [string] % ( obj . KIND , self . KIND ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( obj , RustLibrary ) and any ( isinstance ( l , RustLibrary ) for l in self . linked_libraries ) : [EOL] raise LinkageMultipleRustLibrariesError ( [string] % self ) [EOL] self . linked_libraries . append ( obj ) [EOL] if obj . cxx_link and not isinstance ( obj , SharedLibrary ) : [EOL] self . cxx_link = True [EOL] obj . refs . append ( self ) [EOL] [EOL] def link_system_library ( self , lib ) : [EOL] [comment] [EOL] [comment] [EOL] if not lib . startswith ( [string] ) and not lib . startswith ( [string] ) : [EOL] type_var = [string] if self . KIND == [string] else [string] [EOL] compiler_type = self . config . substs . get ( type_var ) [EOL] if compiler_type in ( [string] , [string] ) : [EOL] lib = [string] % lib [EOL] else : [EOL] lib = [string] % ( self . config . import_prefix , lib , self . config . import_suffix , ) [EOL] self . linked_system_libs . append ( lib ) [EOL] [EOL] def source_files ( self ) : [EOL] all_sources = [ ] [EOL] [comment] [EOL] [comment] [EOL] for suffix in ( [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] all_sources += self . sources . get ( suffix , [ ] ) [EOL] return all_sources [EOL] [EOL] def _get_objs ( self , sources ) : [EOL] obj_prefix = [string] [EOL] if self . KIND == [string] : [EOL] obj_prefix = [string] [EOL] [EOL] return [ mozpath . join ( self . objdir , [string] % ( obj_prefix , mozpath . splitext ( mozpath . basename ( f ) ) [ [number] ] , self . config . substs . get ( [string] , [string] ) ) ) for f in sources ] [EOL] [EOL] @ property def no_pgo_objs ( self ) : [EOL] return self . _get_objs ( self . no_pgo_sources ) [EOL] [EOL] @ property def objs ( self ) : [EOL] return self . _get_objs ( self . source_files ( ) ) [EOL] [EOL] [EOL] class BaseProgram ( Linkable ) : [EOL] [docstring] [EOL] __slots__ = ( [string] ) [EOL] [EOL] DICT_ATTRS = { [string] , [string] , [string] , [string] , } [EOL] [EOL] def __init__ ( self , context , program , is_unit_test = False ) : [EOL] Linkable . __init__ ( self , context ) [EOL] [EOL] bin_suffix = context . config . substs . get ( self . SUFFIX_VAR , [string] ) [EOL] if not program . endswith ( bin_suffix ) : [EOL] program += bin_suffix [EOL] self . program = program [EOL] self . is_unit_test = is_unit_test [EOL] [EOL] @ property def output_path ( self ) : [EOL] if self . installed : [EOL] return ObjDirPath ( self . _context , [string] + mozpath . join ( self . install_target , self . program ) ) [EOL] else : [EOL] return ObjDirPath ( self . _context , [string] + self . program ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . relobjdir , self . program ) [EOL] [EOL] @ property def name ( self ) : [EOL] return self . program [EOL] [EOL] [EOL] class Program ( BaseProgram ) : [EOL] [docstring] [EOL] SUFFIX_VAR = [string] [EOL] KIND = [string] [EOL] [EOL] [EOL] class HostProgram ( HostMixin , BaseProgram ) : [EOL] [docstring] [EOL] SUFFIX_VAR = [string] [EOL] KIND = [string] [EOL] [EOL] @ property def install_target ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class SimpleProgram ( BaseProgram ) : [EOL] [docstring] [EOL] SUFFIX_VAR = [string] [EOL] KIND = [string] [EOL] [EOL] def source_files ( self ) : [EOL] for srcs in self . sources . values ( ) : [EOL] for f in srcs : [EOL] if mozpath . basename ( mozpath . splitext ( f ) [ [number] ] ) == mozpath . splitext ( self . program ) [ [number] ] : [EOL] return [ f ] [EOL] return [ ] [EOL] [EOL] [EOL] class HostSimpleProgram ( HostMixin , BaseProgram ) : [EOL] [docstring] [EOL] SUFFIX_VAR = [string] [EOL] KIND = [string] [EOL] [EOL] def source_files ( self ) : [EOL] for srcs in self . sources . values ( ) : [EOL] for f in srcs : [EOL] if ( [string] % mozpath . basename ( mozpath . splitext ( f ) [ [number] ] ) == mozpath . splitext ( self . program ) [ [number] ] ) : [EOL] return [ f ] [EOL] return [ ] [EOL] [EOL] [EOL] def cargo_output_directory ( context , target_var ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] rust_build_kind = [string] [EOL] if context . config . substs . get ( [string] ) : [EOL] rust_build_kind = [string] [EOL] return mozpath . join ( context . config . substs [ target_var ] , rust_build_kind ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class BaseRustProgram ( ContextDerived ) : [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , name , cargo_file ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . name = name [EOL] self . cargo_file = cargo_file [EOL] cargo_dir = cargo_output_directory ( context , self . TARGET_SUBST_VAR ) [EOL] exe_file = [string] % ( name , context . config . substs . get ( self . SUFFIX_VAR , [string] ) ) [EOL] self . location = mozpath . join ( cargo_dir , exe_file ) [EOL] [EOL] [EOL] class RustProgram ( BaseRustProgram ) : [EOL] SUFFIX_VAR = [string] [EOL] KIND = [string] [EOL] TARGET_SUBST_VAR = [string] [EOL] [EOL] [EOL] class HostRustProgram ( BaseRustProgram ) : [EOL] SUFFIX_VAR = [string] [EOL] KIND = [string] [EOL] TARGET_SUBST_VAR = [string] [EOL] [EOL] [EOL] class RustTests ( ContextDerived ) : [EOL] __slots__ = ( [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , names , features ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . names = names [EOL] self . features = features [EOL] self . output_category = [string] [EOL] [EOL] [EOL] class BaseLibrary ( Linkable ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , basename ) : [EOL] Linkable . __init__ ( self , context ) [EOL] [EOL] self . basename = self . lib_name = basename [EOL] if self . lib_name : [EOL] self . lib_name = [string] % ( context . config . lib_prefix , self . lib_name , context . config . lib_suffix ) [EOL] self . import_name = self . lib_name [EOL] [EOL] self . refs = [ ] [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . relobjdir , self . lib_name ) [EOL] [EOL] @ property def name ( self ) : [EOL] return self . lib_name [EOL] [EOL] [EOL] class Library ( BaseLibrary ) : [EOL] [docstring] [EOL] KIND = [string] [EOL] __slots__ = ( ) [EOL] [EOL] def __init__ ( self , context , basename , real_name = None ) : [EOL] BaseLibrary . __init__ ( self , context , real_name or basename ) [EOL] self . basename = basename [EOL] [EOL] [EOL] class StaticLibrary ( Library ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , basename , real_name = None , link_into = None , no_expand_lib = False ) : [EOL] Library . __init__ ( self , context , basename , real_name ) [EOL] self . link_into = link_into [EOL] self . no_expand_lib = no_expand_lib [EOL] [EOL] [EOL] class RustLibrary ( StaticLibrary ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] TARGET_SUBST_VAR = [string] [EOL] FEATURES_VAR = [string] [EOL] LIB_FILE_VAR = [string] [EOL] [EOL] def __init__ ( self , context , basename , cargo_file , crate_type , dependencies , features , target_dir , ** args ) : [EOL] StaticLibrary . __init__ ( self , context , basename , ** args ) [EOL] self . cargo_file = cargo_file [EOL] self . crate_type = crate_type [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert self . crate_type == [string] [EOL] self . lib_name = [string] % ( context . config . rust_lib_prefix , basename . replace ( [string] , [string] ) , context . config . rust_lib_suffix ) [EOL] self . dependencies = dependencies [EOL] self . features = features [EOL] self . target_dir = target_dir [EOL] self . output_category = context . get ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not context . config . substs . get ( [string] ) : [EOL] return [EOL] build_dir = mozpath . join ( target_dir , cargo_output_directory ( context , self . TARGET_SUBST_VAR ) ) [EOL] self . import_name = mozpath . join ( build_dir , self . lib_name ) [EOL] self . deps_path = mozpath . join ( build_dir , [string] ) [EOL] [EOL] [EOL] class SharedLibrary ( Library ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] DICT_ATTRS = { [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] FRAMEWORK = [number] [EOL] MAX_VARIANT = [number] [EOL] [EOL] def __init__ ( self , context , basename , real_name = None , soname = None , variant = None , symbols_file = False ) : [EOL] assert ( variant in range ( [number] , self . MAX_VARIANT ) or variant is None ) [EOL] Library . __init__ ( self , context , basename , real_name ) [EOL] self . variant = variant [EOL] self . lib_name = real_name or basename [EOL] self . output_category = context . get ( [string] ) [EOL] assert self . lib_name [EOL] [EOL] if variant == self . FRAMEWORK : [EOL] self . import_name = self . lib_name [EOL] else : [EOL] self . import_name = [string] % ( context . config . import_prefix , self . lib_name , context . config . import_suffix , ) [EOL] self . lib_name = [string] % ( context . config . dll_prefix , self . lib_name , context . config . dll_suffix , ) [EOL] if soname : [EOL] self . soname = [string] % ( context . config . dll_prefix , soname , context . config . dll_suffix , ) [EOL] else : [EOL] self . soname = self . lib_name [EOL] [EOL] if symbols_file is False : [EOL] [comment] [EOL] self . symbols_file = None [EOL] elif symbols_file is True : [EOL] [comment] [EOL] if context . config . substs [ [string] ] == [string] : [EOL] self . symbols_file = [string] % self . lib_name [EOL] else : [EOL] self . symbols_file = [string] % self . lib_name [EOL] else : [EOL] [comment] [EOL] self . symbols_file = symbols_file [EOL] [EOL] if self . symbols_file : [EOL] os_target = context . config . substs [ [string] ] [EOL] if os_target == [string] : [EOL] self . symbols_link_arg = [string] + self . symbols_file [EOL] elif os_target == [string] : [EOL] if context . config . substs . get ( [string] ) : [EOL] self . symbols_link_arg = self . symbols_file [EOL] else : [EOL] self . symbols_link_arg = [string] + self . symbols_file [EOL] elif context . config . substs . get ( [string] ) : [EOL] self . symbols_link_arg = [string] + self . symbols_file [EOL] [EOL] [EOL] class HostSharedLibrary ( HostMixin , Library ) : [EOL] [docstring] [EOL] KIND = [string] [EOL] [EOL] def __init__ ( self , context , basename ) : [EOL] Library . __init__ ( self , context , basename ) [EOL] self . lib_name = [string] % ( context . config . host_dll_prefix , self . basename , context . config . host_dll_suffix , ) [EOL] [EOL] [EOL] class ExternalLibrary ( object ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ExternalStaticLibrary ( StaticLibrary , ExternalLibrary ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ExternalSharedLibrary ( SharedLibrary , ExternalLibrary ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HostLibrary ( HostMixin , BaseLibrary ) : [EOL] [docstring] [EOL] KIND = [string] [EOL] [EOL] [EOL] class HostRustLibrary ( HostMixin , RustLibrary ) : [EOL] [docstring] [EOL] KIND = [string] [EOL] TARGET_SUBST_VAR = [string] [EOL] FEATURES_VAR = [string] [EOL] LIB_FILE_VAR = [string] [EOL] [EOL] [EOL] class TestManifest ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , path , manifest , flavor = None , install_prefix = None , relpath = None , sources = ( ) , dupe_manifest = False ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] [EOL] assert flavor in all_test_flavors ( ) [EOL] [EOL] self . path = path [EOL] self . directory = mozpath . dirname ( path ) [EOL] self . manifest = manifest [EOL] self . flavor = flavor [EOL] self . install_prefix = install_prefix [EOL] self . manifest_relpath = relpath [EOL] self . manifest_obj_relpath = relpath [EOL] self . source_relpaths = sources [EOL] self . dupe_manifest = dupe_manifest [EOL] self . installs = { } [EOL] self . pattern_installs = [ ] [EOL] self . tests = [ ] [EOL] self . external_installs = set ( ) [EOL] self . deferred_installs = set ( ) [EOL] [EOL] [EOL] class LocalInclude ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , context , path ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] [EOL] self . path = path [EOL] [EOL] [EOL] class PerSourceFlag ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , file_name , flags ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] [EOL] self . file_name = file_name [EOL] self . flags = flags [EOL] [EOL] [EOL] class JARManifest ( ContextDerived ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , context , path ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] [EOL] self . path = path [EOL] [EOL] [EOL] class BaseSources ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , files , canonical_suffix ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] [EOL] self . files = files [EOL] self . canonical_suffix = canonical_suffix [EOL] [EOL] [EOL] class Sources ( BaseSources ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , context , files , canonical_suffix ) : [EOL] BaseSources . __init__ ( self , context , files , canonical_suffix ) [EOL] [EOL] [EOL] class PgoGenerateOnlySources ( BaseSources ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , context , files ) : [EOL] BaseSources . __init__ ( self , context , files , [string] ) [EOL] [EOL] [EOL] class GeneratedSources ( BaseSources ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , context , files , canonical_suffix ) : [EOL] BaseSources . __init__ ( self , context , files , canonical_suffix ) [EOL] [EOL] [EOL] class HostSources ( HostMixin , BaseSources ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , context , files , canonical_suffix ) : [EOL] BaseSources . __init__ ( self , context , files , canonical_suffix ) [EOL] [EOL] [EOL] class HostGeneratedSources ( HostMixin , BaseSources ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , context , files , canonical_suffix ) : [EOL] BaseSources . __init__ ( self , context , files , canonical_suffix ) [EOL] [EOL] [EOL] class UnifiedSources ( BaseSources ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , context , files , canonical_suffix , files_per_unified_file ) : [EOL] BaseSources . __init__ ( self , context , files , canonical_suffix ) [EOL] [EOL] self . have_unified_mapping = files_per_unified_file > [number] [EOL] [EOL] if self . have_unified_mapping : [EOL] [comment] [EOL] source_files = list ( sorted ( self . files ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] unified_prefix = context . relsrcdir [EOL] if len ( unified_prefix ) > [number] : [EOL] unified_prefix = unified_prefix [ - [number] : ] . split ( [string] , [number] ) [ - [number] ] [EOL] unified_prefix = unified_prefix . replace ( [string] , [string] ) [EOL] [EOL] suffix = self . canonical_suffix [ [number] : ] [EOL] unified_prefix = [string] % ( suffix , unified_prefix ) [EOL] self . unified_source_mapping = list ( group_unified_files ( source_files , unified_prefix = unified_prefix , unified_suffix = suffix , files_per_unified_file = files_per_unified_file ) ) [EOL] [EOL] [EOL] class InstallationTarget ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , context ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] [EOL] self . xpiname = context . get ( [string] , [string] ) [EOL] self . subdir = context . get ( [string] , [string] ) [EOL] self . target = context [ [string] ] [EOL] self . enabled = context [ [string] ] is not False [EOL] [EOL] def is_custom ( self ) : [EOL] [docstring] [EOL] [EOL] return FinalTargetValue ( dict ( XPI_NAME = self . xpiname , DIST_SUBDIR = self . subdir ) ) == self . target [EOL] [EOL] [EOL] class FinalTargetFiles ( ContextDerived ) : [EOL] [docstring] [EOL] __slots__ = ( [string] ) [EOL] [EOL] def __init__ ( self , sandbox , files ) : [EOL] ContextDerived . __init__ ( self , sandbox ) [EOL] self . files = files [EOL] [EOL] [EOL] class FinalTargetPreprocessedFiles ( ContextDerived ) : [EOL] [docstring] [EOL] __slots__ = ( [string] ) [EOL] [EOL] def __init__ ( self , sandbox , files ) : [EOL] ContextDerived . __init__ ( self , sandbox ) [EOL] self . files = files [EOL] [EOL] [EOL] class LocalizedFiles ( FinalTargetFiles ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class LocalizedPreprocessedFiles ( FinalTargetPreprocessedFiles ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ObjdirFiles ( FinalTargetFiles ) : [EOL] [docstring] [EOL] @ property def install_target ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class ObjdirPreprocessedFiles ( FinalTargetPreprocessedFiles ) : [EOL] [docstring] [EOL] @ property def install_target ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class TestHarnessFiles ( FinalTargetFiles ) : [EOL] [docstring] [EOL] @ property def install_target ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class Exports ( FinalTargetFiles ) : [EOL] [docstring] [EOL] @ property def install_target ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class GeneratedFile ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , script , method , outputs , inputs , flags = ( ) , localized = False , force = False ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . script = script [EOL] self . method = method [EOL] self . outputs = outputs if isinstance ( outputs , tuple ) else ( outputs , ) [EOL] self . inputs = inputs [EOL] self . flags = flags [EOL] self . localized = localized [EOL] self . force = force [EOL] [EOL] suffixes = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] self . required_for_compile = [ f for f in self . outputs if f . endswith ( suffixes ) or [string] in f ] [EOL] [EOL] [EOL] class ChromeManifestEntry ( ContextDerived ) : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] , ) [EOL] [EOL] def __init__ ( self , context , manifest_path , entry ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] assert isinstance ( entry , ManifestEntry ) [EOL] self . path = mozpath . join ( self . install_target , manifest_path ) [EOL] [comment] [EOL] [comment] [EOL] entry = entry . rebase ( mozpath . dirname ( manifest_path ) ) [EOL] [comment] [EOL] self . entry = entry . move ( mozpath . dirname ( self . path ) ) [EOL] [EOL] [EOL] class GnProjectData ( ContextDerived ) : [EOL] def __init__ ( self , context , target_dir , gn_dir_attrs , non_unified_sources ) : [EOL] ContextDerived . __init__ ( self , context ) [EOL] self . target_dir = target_dir [EOL] self . non_unified_sources = non_unified_sources [EOL] self . gn_input_variables = gn_dir_attrs . variables [EOL] self . gn_sandbox_variables = gn_dir_attrs . sandbox_vars [EOL] self . mozilla_flags = gn_dir_attrs . mozilla_flags [EOL] self . gn_target = gn_dir_attrs . gn_target [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import os [EOL] import struct [EOL] import subprocess [EOL] from mozpack . errors import errors [EOL] [EOL] MACHO_SIGNATURES = [ [number] , [number] , [number] , [number] , ] [EOL] [EOL] FAT_SIGNATURE = [number] [comment] [EOL] [EOL] ELF_SIGNATURE = [number] [comment] [EOL] [EOL] UNKNOWN = [number] [EOL] MACHO = [number] [EOL] ELF = [number] [EOL] [EOL] [EOL] def get_type ( path ) : [EOL] [docstring] [EOL] with open ( path , [string] ) as f : [EOL] signature = f . read ( [number] ) [EOL] if len ( signature ) < [number] : [EOL] return UNKNOWN [EOL] signature = struct . unpack ( [string] , signature ) [ [number] ] [EOL] if signature == ELF_SIGNATURE : [EOL] return ELF [EOL] if signature in MACHO_SIGNATURES : [EOL] return MACHO [EOL] if signature != FAT_SIGNATURE : [EOL] return UNKNOWN [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] num = f . read ( [number] ) [EOL] if len ( num ) < [number] : [EOL] return UNKNOWN [EOL] num = struct . unpack ( [string] , num ) [ [number] ] [EOL] if num < [number] : [EOL] return MACHO [EOL] return UNKNOWN [EOL] [EOL] [EOL] def is_executable ( path ) : [EOL] [docstring] [EOL] from buildconfig import substs [EOL] if not os . path . exists ( path ) : [EOL] return False [EOL] [EOL] if substs [ [string] ] == [string] : [EOL] return path . lower ( ) . endswith ( ( substs [ [string] ] , substs [ [string] ] ) ) [EOL] [EOL] return get_type ( path ) != UNKNOWN [EOL] [EOL] [EOL] def may_strip ( path ) : [EOL] [docstring] [EOL] from buildconfig import substs [EOL] return not substs [ [string] ] [EOL] [EOL] [EOL] def strip ( path ) : [EOL] [docstring] [EOL] from buildconfig import substs [EOL] strip = substs [ [string] ] [EOL] flags = substs [ [string] ] . split ( ) if [string] in substs else [ ] [EOL] cmd = [ strip ] + flags + [ path ] [EOL] if subprocess . call ( cmd ) != [number] : [EOL] errors . fatal ( [string] + [string] . join ( cmd ) ) [EOL] [EOL] [EOL] def may_elfhack ( path ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] from buildconfig import substs [EOL] return ( [string] in substs and substs [ [string] ] and path . endswith ( substs [ [string] ] ) and [string] in substs and substs [ [string] ] ) [EOL] [EOL] [EOL] def elfhack ( path ) : [EOL] [docstring] [EOL] from buildconfig import topobjdir [EOL] cmd = [ os . path . join ( topobjdir , [string] ) , path ] [EOL] if [string] in os . environ : [EOL] cmd [ [number] : [number] ] = os . environ [ [string] ] . split ( ) [EOL] if subprocess . call ( cmd ) != [number] : [EOL] errors . fatal ( [string] + [string] . join ( cmd ) ) [EOL] [EOL] [EOL] def xz_compress ( path ) : [EOL] [docstring] [EOL] if open ( path , [string] ) . read ( [number] ) [ [number] : ] == [string] : [EOL] print ( [string] % path ) [EOL] return [EOL] [EOL] from buildconfig import substs [EOL] xz = substs . get ( [string] ) [EOL] cmd = [ xz , [string] , path ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cmd . extend ( [ [string] ] ) [EOL] [EOL] bcj = None [EOL] if substs . get ( [string] ) : [EOL] bcj = [string] [EOL] elif substs . get ( [string] ) == [string] : [EOL] bcj = [string] [EOL] elif substs . get ( [string] ) == [string] : [EOL] bcj = [string] [EOL] [EOL] if bcj : [EOL] cmd . extend ( [ bcj ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cmd . extend ( [ [string] ] ) [EOL] print ( [string] % ( path , [string] . join ( cmd ) ) ) [EOL] [EOL] if subprocess . call ( cmd ) != [number] : [EOL] errors . fatal ( [string] + [string] . join ( cmd ) ) [EOL] return [EOL] [EOL] os . rename ( path + [string] , path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import mozpack . path as mozpath [EOL] from mozpack . files import ( BaseFinder , FileFinder , DeflatedFile , ManifestFile , ) [EOL] from mozpack . chrome . manifest import ( parse_manifest , ManifestEntryWithRelPath , ManifestResource , is_manifest , ) [EOL] from mozpack . mozjar import JarReader [EOL] from mozpack . copier import ( FileRegistry , FileCopier , ) [EOL] from mozpack . packager import SimplePackager [EOL] from mozpack . packager . formats import FlatFormatter [EOL] from six . moves . urllib . parse import urlparse [EOL] [EOL] [EOL] class UnpackFinder ( BaseFinder ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , source , omnijar_name = None ) : [EOL] if isinstance ( source , BaseFinder ) : [EOL] self . _finder = source [EOL] else : [EOL] self . _finder = FileFinder ( source ) [EOL] self . base = self . _finder . base [EOL] self . files = FileRegistry ( ) [EOL] self . kind = [string] [EOL] if omnijar_name : [EOL] self . omnijar = omnijar_name [EOL] else : [EOL] [comment] [EOL] from buildconfig import substs [EOL] self . omnijar = substs . get ( [string] , [string] ) [EOL] self . jarlogs = { } [EOL] self . compressed = False [EOL] [EOL] jars = set ( ) [EOL] [EOL] for p , f in self . _finder . find ( [string] ) : [EOL] [comment] [EOL] if p == [string] : [EOL] continue [EOL] base = mozpath . dirname ( p ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . _maybe_zip ( f ) and mozpath . match ( p , [string] % self . omnijar ) : [EOL] jar = self . _open_jar ( p , f ) [EOL] if [string] in jar : [EOL] self . kind = [string] [EOL] self . _fill_with_jar ( p [ : - len ( self . omnijar ) - [number] ] , jar ) [EOL] continue [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if is_manifest ( p ) : [EOL] m = self . files [ p ] if self . files . contains ( p ) \ [EOL] else ManifestFile ( base ) [EOL] for e in parse_manifest ( self . base , p , f . open ( ) ) : [EOL] m . add ( self . _handle_manifest_entry ( e , jars ) ) [EOL] if self . files . contains ( p ) : [EOL] continue [EOL] f = m [EOL] [comment] [EOL] [comment] [EOL] if p . endswith ( [string] ) and self . _maybe_zip ( f ) : [EOL] self . _fill_with_jar ( p [ : - [number] ] , self . _open_jar ( p , f ) ) [EOL] continue [EOL] if p not in jars : [EOL] self . files . add ( p , f ) [EOL] [EOL] def _fill_with_jar ( self , base , jar ) : [EOL] for j in jar : [EOL] path = mozpath . join ( base , j . filename ) [EOL] if is_manifest ( j . filename ) : [EOL] m = self . files [ path ] if self . files . contains ( path ) \ [EOL] else ManifestFile ( mozpath . dirname ( path ) ) [EOL] for e in parse_manifest ( None , path , j ) : [EOL] m . add ( e ) [EOL] if not self . files . contains ( path ) : [EOL] self . files . add ( path , m ) [EOL] continue [EOL] else : [EOL] self . files . add ( path , DeflatedFile ( j ) ) [EOL] [EOL] def _handle_manifest_entry ( self , entry , jars ) : [EOL] jarpath = None [EOL] if isinstance ( entry , ManifestEntryWithRelPath ) and urlparse ( entry . relpath ) . scheme == [string] : [EOL] jarpath , entry = self . _unjarize ( entry , entry . relpath ) [EOL] elif isinstance ( entry , ManifestResource ) and urlparse ( entry . target ) . scheme == [string] : [EOL] jarpath , entry = self . _unjarize ( entry , entry . target ) [EOL] if jarpath : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . files . contains ( jarpath ) : [EOL] jar = self . files [ jarpath ] [EOL] self . files . remove ( jarpath ) [EOL] else : [EOL] jar = [ f for p , f in self . _finder . find ( jarpath ) ] [EOL] assert len ( jar ) == [number] [EOL] jar = jar [ [number] ] [EOL] if jarpath not in jars : [EOL] base = mozpath . splitext ( jarpath ) [ [number] ] [EOL] for j in self . _open_jar ( jarpath , jar ) : [EOL] self . files . add ( mozpath . join ( base , j . filename ) , DeflatedFile ( j ) ) [EOL] jars . add ( jarpath ) [EOL] self . kind = [string] [EOL] return entry [EOL] [EOL] def _open_jar ( self , path , file ) : [EOL] [docstring] [EOL] jar = JarReader ( fileobj = file . open ( ) ) [EOL] self . compressed = max ( self . compressed , jar . compression ) [EOL] if jar . last_preloaded : [EOL] jarlog = jar . entries . keys ( ) [EOL] self . jarlogs [ path ] = jarlog [ : jarlog . index ( jar . last_preloaded ) + [number] ] [EOL] return jar [EOL] [EOL] def find ( self , path ) : [EOL] for p in self . files . match ( path ) : [EOL] yield p , self . files [ p ] [EOL] [EOL] def _maybe_zip ( self , file ) : [EOL] [docstring] [EOL] header = file . open ( ) . read ( [number] ) [EOL] return len ( header ) == [number] and ( header [ [number] : [number] ] == [string] or header [ [number] : [number] ] == [string] ) [EOL] [EOL] def _unjarize ( self , entry , relpath ) : [EOL] [docstring] [EOL] base = entry . base [EOL] jar , relpath = urlparse ( relpath ) . path . split ( [string] , [number] ) [EOL] entry = entry . rebase ( mozpath . join ( base , [string] % jar ) ) . move ( mozpath . join ( base , mozpath . splitext ( jar ) [ [number] ] ) ) . rebase ( base ) [EOL] return mozpath . join ( base , jar ) , entry [EOL] [EOL] [EOL] def unpack_to_registry ( source , registry , omnijar_name = None ) : [EOL] [docstring] [EOL] finder = UnpackFinder ( source , omnijar_name ) [EOL] packager = SimplePackager ( FlatFormatter ( registry ) ) [EOL] for p , f in finder . find ( [string] ) : [EOL] packager . add ( p , f ) [EOL] packager . close ( ) [EOL] [EOL] [EOL] def unpack ( source , omnijar_name = None ) : [EOL] [docstring] [EOL] copier = FileCopier ( ) [EOL] unpack_to_registry ( source , copier , omnijar_name ) [EOL] copier . copy ( source , skip_if_older = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] from mozpack . chrome . manifest import ( Manifest , ManifestInterfaces , ManifestChrome , ManifestBinaryComponent , ManifestResource , ManifestMultiContent , ) [EOL] from mozpack . errors import errors [EOL] from six . moves . urllib . parse import urlparse [EOL] import mozpack . path as mozpath [EOL] from mozpack . files import ManifestFile [EOL] from mozpack . copier import ( FileRegistry , FileRegistrySubtree , Jarrer , ) [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class PiecemealFormatter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , copier ) : [EOL] assert isinstance ( copier , ( FileRegistry , FileRegistrySubtree ) ) [EOL] self . copier = copier [EOL] self . _sub_formatter = { } [EOL] self . _frozen_bases = False [EOL] [EOL] def add_base ( self , base , addon = False ) : [EOL] [comment] [EOL] assert not self . _frozen_bases [EOL] assert base not in self . _sub_formatter [EOL] assert all ( base > b for b in self . _sub_formatter ) [EOL] self . _add_base ( base , addon ) [EOL] [EOL] def _get_base ( self , path ) : [EOL] [docstring] [EOL] self . _frozen_bases = True [EOL] base = mozpath . basedir ( path , self . _sub_formatter . keys ( ) ) [EOL] relpath = mozpath . relpath ( path , base ) if base else path [EOL] return base , relpath [EOL] [EOL] def add ( self , path , content ) : [EOL] base , relpath = self . _get_base ( path ) [EOL] if base is None : [EOL] return self . copier . add ( relpath , content ) [EOL] return self . _sub_formatter [ base ] . add ( relpath , content ) [EOL] [EOL] def add_manifest ( self , entry ) : [EOL] base , relpath = self . _get_base ( entry . base ) [EOL] assert base is not None [EOL] return self . _sub_formatter [ base ] . add_manifest ( entry . move ( relpath ) ) [EOL] [EOL] def add_interfaces ( self , path , content ) : [EOL] base , relpath = self . _get_base ( path ) [EOL] assert base is not None [EOL] return self . _sub_formatter [ base ] . add_interfaces ( relpath , content ) [EOL] [EOL] def contains ( self , path ) : [EOL] assert [string] not in path [EOL] base , relpath = self . _get_base ( path ) [EOL] if base is None : [EOL] return self . copier . contains ( relpath ) [EOL] return self . _sub_formatter [ base ] . contains ( relpath ) [EOL] [EOL] [EOL] class FlatFormatter ( PiecemealFormatter ) : [EOL] [docstring] [EOL] [EOL] def _add_base ( self , base , addon = False ) : [EOL] self . _sub_formatter [ base ] = FlatSubFormatter ( FileRegistrySubtree ( base , self . copier ) ) [EOL] [EOL] [EOL] class FlatSubFormatter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , copier ) : [EOL] assert isinstance ( copier , ( FileRegistry , FileRegistrySubtree ) ) [EOL] self . copier = copier [EOL] self . _chrome_db = { } [EOL] [EOL] def add ( self , path , content ) : [EOL] self . copier . add ( path , content ) [EOL] [EOL] def add_manifest ( self , entry ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if entry . base : [EOL] name = mozpath . basename ( entry . base ) [EOL] else : [EOL] name = [string] [EOL] path = mozpath . normpath ( mozpath . join ( entry . base , [string] % name ) ) [EOL] if not self . copier . contains ( path ) : [EOL] [comment] [EOL] [comment] [EOL] if entry . base : [EOL] parent = mozpath . dirname ( entry . base ) [EOL] relbase = mozpath . basename ( entry . base ) [EOL] relpath = mozpath . join ( relbase , mozpath . basename ( path ) ) [EOL] self . add_manifest ( Manifest ( parent , relpath ) ) [EOL] self . copier . add ( path , ManifestFile ( entry . base ) ) [EOL] [EOL] if isinstance ( entry , ManifestChrome ) : [EOL] data = self . _chrome_db . setdefault ( entry . name , { } ) [EOL] if isinstance ( entry , ManifestMultiContent ) : [EOL] entries = data . setdefault ( entry . type , { } ) . setdefault ( entry . id , [ ] ) [EOL] else : [EOL] entries = data . setdefault ( entry . type , [ ] ) [EOL] for e in entries : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if entry == e : [EOL] errors . warn ( [string] % entry ) [EOL] return [EOL] if not entry . flags or e . flags and entry . flags == e . flags : [EOL] errors . fatal ( [string] % ( entry , e ) ) [EOL] entries . append ( entry ) [EOL] [EOL] self . copier [ path ] . add ( entry ) [EOL] [EOL] def add_interfaces ( self , path , content ) : [EOL] self . copier . add ( path , content ) [EOL] self . add_manifest ( ManifestInterfaces ( mozpath . dirname ( path ) , mozpath . basename ( path ) ) ) [EOL] [EOL] def contains ( self , path ) : [EOL] assert [string] not in path [EOL] return self . copier . contains ( path ) [EOL] [EOL] [EOL] class JarFormatter ( PiecemealFormatter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , copier , compress = True ) : [EOL] PiecemealFormatter . __init__ ( self , copier ) [EOL] self . _compress = compress [EOL] [EOL] def _add_base ( self , base , addon = False ) : [EOL] if addon is True : [EOL] jarrer = Jarrer ( self . _compress ) [EOL] self . copier . add ( base + [string] , jarrer ) [EOL] self . _sub_formatter [ base ] = FlatSubFormatter ( jarrer ) [EOL] else : [EOL] self . _sub_formatter [ base ] = JarSubFormatter ( FileRegistrySubtree ( base , self . copier ) , self . _compress ) [EOL] [EOL] [EOL] class JarSubFormatter ( PiecemealFormatter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , copier , compress = True ) : [EOL] PiecemealFormatter . __init__ ( self , copier ) [EOL] self . _frozen_chrome = False [EOL] self . _compress = compress [EOL] self . _sub_formatter [ [string] ] = FlatSubFormatter ( copier ) [EOL] [EOL] def _jarize ( self , entry , relpath ) : [EOL] [docstring] [EOL] base = entry . base [EOL] basepath = mozpath . split ( relpath ) [ [number] ] [EOL] chromepath = mozpath . join ( base , basepath ) [EOL] entry = entry . rebase ( chromepath ) . move ( mozpath . join ( base , [string] % basepath ) ) . rebase ( base ) [EOL] return chromepath , entry [EOL] [EOL] def add_manifest ( self , entry ) : [EOL] if isinstance ( entry , ManifestChrome ) and not urlparse ( entry . relpath ) . scheme : [EOL] chromepath , entry = self . _jarize ( entry , entry . relpath ) [EOL] assert not self . _frozen_chrome [EOL] if chromepath not in self . _sub_formatter : [EOL] jarrer = Jarrer ( self . _compress ) [EOL] self . copier . add ( chromepath + [string] , jarrer ) [EOL] self . _sub_formatter [ chromepath ] = FlatSubFormatter ( jarrer ) [EOL] elif isinstance ( entry , ManifestResource ) and not urlparse ( entry . target ) . scheme : [EOL] chromepath , new_entry = self . _jarize ( entry , entry . target ) [EOL] if chromepath in self . _sub_formatter : [EOL] entry = new_entry [EOL] PiecemealFormatter . add_manifest ( self , entry ) [EOL] [EOL] [EOL] class OmniJarFormatter ( JarFormatter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , copier , omnijar_name , compress = True , non_resources = ( ) ) : [EOL] JarFormatter . __init__ ( self , copier , compress ) [EOL] self . _omnijar_name = omnijar_name [EOL] self . _non_resources = non_resources [EOL] [EOL] def _add_base ( self , base , addon = False ) : [EOL] if addon : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parent_base = mozpath . basedir ( base , self . _sub_formatter . keys ( ) ) [EOL] rel_base = mozpath . relpath ( base , parent_base ) [EOL] [comment] [EOL] [comment] [EOL] parent_sub_formatter = self . _sub_formatter [ parent_base ] [EOL] if parent_sub_formatter . is_resource ( rel_base ) : [EOL] omnijar_sub_formatter = parent_sub_formatter . _sub_formatter [ self . _omnijar_name ] [EOL] self . _sub_formatter [ base ] = FlatSubFormatter ( FileRegistrySubtree ( rel_base , omnijar_sub_formatter . copier ) ) [EOL] return [EOL] JarFormatter . _add_base ( self , base , addon ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] path = mozpath . normpath ( mozpath . join ( base , [string] ) ) [EOL] if not self . copier . contains ( path ) : [EOL] self . copier . add ( path , ManifestFile ( [string] ) ) [EOL] self . _sub_formatter [ base ] = OmniJarSubFormatter ( FileRegistrySubtree ( base , self . copier ) , self . _omnijar_name , self . _compress , self . _non_resources ) [EOL] [EOL] [EOL] class OmniJarSubFormatter ( PiecemealFormatter ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , copier , omnijar_name , compress = True , non_resources = ( ) ) : [EOL] PiecemealFormatter . __init__ ( self , copier ) [EOL] self . _omnijar_name = omnijar_name [EOL] self . _compress = compress [EOL] self . _non_resources = non_resources [EOL] self . _sub_formatter [ [string] ] = FlatSubFormatter ( copier ) [EOL] jarrer = Jarrer ( self . _compress ) [EOL] self . _sub_formatter [ omnijar_name ] = FlatSubFormatter ( jarrer ) [EOL] [EOL] def _get_base ( self , path ) : [EOL] base = self . _omnijar_name if self . is_resource ( path ) else [string] [EOL] [comment] [EOL] if base and not self . copier . contains ( base ) : [EOL] self . copier . add ( base , self . _sub_formatter [ base ] . copier ) [EOL] return base , path [EOL] [EOL] def add_manifest ( self , entry ) : [EOL] base = [string] [EOL] if not isinstance ( entry , ManifestBinaryComponent ) : [EOL] base = self . _omnijar_name [EOL] formatter = self . _sub_formatter [ base ] [EOL] return formatter . add_manifest ( entry ) [EOL] [EOL] def is_resource ( self , path ) : [EOL] [docstring] [EOL] if any ( mozpath . match ( path , p . replace ( [string] , [string] ) ) for p in self . _non_resources ) : [EOL] return False [EOL] path = mozpath . split ( path ) [EOL] if path [ [number] ] == [string] : [EOL] return len ( path ) == [number] or path [ [number] ] != [string] [EOL] if path [ [number] ] == [string] : [EOL] return path [ - [number] ] . endswith ( ( [string] , [string] ) ) [EOL] if path [ [number] ] == [string] : [EOL] return len ( path ) == [number] or ( path [ [number] ] != [string] and path [ [number] ] != [string] and path [ [number] ] != [string] ) [EOL] if path [ [number] ] == [string] : [EOL] return len ( path ) != [number] or not ( path [ [number] ] == [string] and path [ [number] ] in [ [string] , [string] ] ) [EOL] if len ( path ) <= [number] and path [ - [number] ] == [string] : [EOL] [comment] [EOL] return True [EOL] return path [ [number] ] in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set , Dict , List [EOL] import typing [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] [docstring] [EOL] [EOL] import json [EOL] import os [EOL] import six [EOL] import mozpack . path as mozpath [EOL] from mozpack . packager . formats import ( FlatFormatter , JarFormatter , OmniJarFormatter , ) [EOL] from mozpack . packager import ( Component , SimplePackager , SimpleManifestSink , ) [EOL] from mozpack . files import ( ComposedFinder , GeneratedFile , ManifestFile , ) [EOL] from mozpack . copier import ( FileCopier , Jarrer , ) [EOL] from mozpack . chrome . manifest import ( ManifestLocale , ManifestEntryWithRelPath , is_manifest , ManifestChrome , Manifest , ) [EOL] from mozpack . errors import errors [EOL] from mozpack . mozjar import JAR_DEFLATED [EOL] from mozpack . packager . unpack import UnpackFinder [EOL] from createprecomplete import generate_precomplete [EOL] [EOL] [EOL] class LocaleManifestFinder ( object ) : [EOL] def __init__ ( self , finder ) : [EOL] entries = self . entries = [ ] [EOL] bases = self . bases = [ ] [EOL] [EOL] class MockFormatter ( object ) : [EOL] def add_interfaces ( self , path , content ) : [EOL] pass [EOL] [EOL] def add ( self , path , content ) : [EOL] pass [EOL] [EOL] def add_manifest ( self , entry ) : [EOL] if entry . localized : [EOL] entries . append ( entry ) [EOL] [EOL] def add_base ( self , base , addon = False ) : [EOL] bases . append ( base ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class WrapFinder ( object ) : [EOL] def __init__ ( self , finder ) : [EOL] self . _finder = finder [EOL] [EOL] def find ( self , pattern ) : [EOL] for p , f in self . _finder . find ( pattern ) : [EOL] if isinstance ( f , ManifestFile ) : [EOL] unwanted = [ e for e in f . _entries if isinstance ( e , Manifest ) and e . flags ] [EOL] if unwanted : [EOL] f = ManifestFile ( f . _base , [ e for e in f . _entries if e not in unwanted ] ) [EOL] yield p , f [EOL] [EOL] sink = SimpleManifestSink ( WrapFinder ( finder ) , MockFormatter ( ) ) [EOL] sink . add ( Component ( [string] ) , [string] ) [EOL] sink . close ( False ) [EOL] [EOL] [comment] [EOL] self . locales = list ( set ( e . id for e in self . entries if isinstance ( e , ManifestLocale ) ) ) [EOL] [EOL] [EOL] class L10NRepackFormatterMixin ( object ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( L10NRepackFormatterMixin , self ) . __init__ ( * args , ** kwargs ) [EOL] self . _dictionaries = { } [EOL] [EOL] def add ( self , path , file ) : [EOL] if path . endswith ( [string] ) : [EOL] base , relpath = self . _get_base ( path ) [EOL] if relpath . startswith ( [string] ) : [EOL] root , ext = mozpath . splitext ( mozpath . basename ( path ) ) [EOL] self . _dictionaries [ root ] = path [EOL] elif path . endswith ( [string] ) : [EOL] data = json . load ( file . open ( ) ) [EOL] data [ [string] ] = self . _dictionaries [EOL] [comment] [EOL] [comment] [EOL] file = GeneratedFile ( lambda : json . dumps ( data ) ) [EOL] super ( L10NRepackFormatterMixin , self ) . add ( path , file ) [EOL] [EOL] [EOL] def L10NRepackFormatter ( klass ) : [EOL] class L10NRepackFormatter ( L10NRepackFormatterMixin , klass ) : [EOL] pass [EOL] return L10NRepackFormatter [EOL] [EOL] [EOL] FlatFormatter = L10NRepackFormatter ( FlatFormatter ) [EOL] JarFormatter = L10NRepackFormatter ( JarFormatter ) [EOL] OmniJarFormatter = L10NRepackFormatter ( OmniJarFormatter ) [EOL] [EOL] [EOL] def _repack ( app_finder , l10n_finder , copier , formatter , non_chrome = set ( ) ) : [EOL] app = LocaleManifestFinder ( app_finder ) [EOL] l10n = LocaleManifestFinder ( l10n_finder ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if len ( app . locales ) > [number] : [EOL] errors . fatal ( [string] + [string] . join ( app . locales ) ) [EOL] if len ( l10n . locales ) > [number] : [EOL] errors . fatal ( [string] + [string] . join ( l10n . locales ) ) [EOL] locale = app . locales [ [number] ] [EOL] l10n_locale = l10n . locales [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def key ( entry ) : [EOL] if entry . flags : [EOL] return [string] % ( entry . name , entry . flags ) [EOL] return entry . name [EOL] [EOL] l10n_paths = { } [EOL] for e in l10n . entries : [EOL] if isinstance ( e , ManifestChrome ) : [EOL] base = mozpath . basedir ( e . path , app . bases ) [EOL] l10n_paths . setdefault ( base , { } ) [EOL] l10n_paths [ base ] [ key ( e ) ] = e . path [EOL] [EOL] [comment] [EOL] [comment] [EOL] paths = { } [EOL] for e in app . entries : [EOL] if isinstance ( e , ManifestEntryWithRelPath ) : [EOL] base = mozpath . basedir ( e . path , app . bases ) [EOL] if base not in l10n_paths : [EOL] errors . fatal ( [string] % base ) [EOL] [comment] [EOL] continue [EOL] if key ( e ) not in l10n_paths [ base ] : [EOL] errors . fatal ( [string] % e . name ) [EOL] [comment] [EOL] continue [EOL] paths [ e . path ] = l10n_paths [ base ] [ key ( e ) ] [EOL] [EOL] for pattern in non_chrome : [EOL] for base in app . bases : [EOL] path = mozpath . join ( base , pattern ) [EOL] left = set ( p for p , f in app_finder . find ( path ) ) [EOL] right = set ( p for p , f in l10n_finder . find ( path ) ) [EOL] for p in right : [EOL] paths [ p ] = p [EOL] for p in left - right : [EOL] paths [ p ] = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] packager = SimplePackager ( formatter ) [EOL] for p , f in app_finder : [EOL] if is_manifest ( p ) : [EOL] [comment] [EOL] for e in [ e for e in f if e . localized ] : [EOL] f . remove ( e ) [EOL] [comment] [EOL] [comment] [EOL] path = None [EOL] if p in paths : [EOL] path = paths [ p ] [EOL] if not path : [EOL] continue [EOL] else : [EOL] base = mozpath . basedir ( p , paths . keys ( ) ) [EOL] if base : [EOL] subpath = mozpath . relpath ( p , base ) [EOL] path = mozpath . normpath ( mozpath . join ( paths [ base ] , subpath ) ) [EOL] [EOL] if path : [EOL] files = [ f for p , f in l10n_finder . find ( path ) ] [EOL] if not len ( files ) : [EOL] if base not in non_chrome : [EOL] finderBase = [string] [EOL] if hasattr ( l10n_finder , [string] ) : [EOL] finderBase = l10n_finder . base [EOL] errors . error ( [string] % os . path . join ( finderBase , path ) ) [EOL] else : [EOL] packager . add ( path , files [ [number] ] ) [EOL] else : [EOL] packager . add ( p , f ) [EOL] [EOL] [comment] [EOL] l10n_manifests = [ ] [EOL] for base in set ( e . base for e in l10n . entries ) : [EOL] m = ManifestFile ( base , [ e for e in l10n . entries if e . base == base ] ) [EOL] path = mozpath . join ( base , [string] % l10n_locale ) [EOL] l10n_manifests . append ( ( path , m ) ) [EOL] bases = packager . get_bases ( ) [EOL] for path , m in l10n_manifests : [EOL] base = mozpath . basedir ( path , bases ) [EOL] packager . add ( path , m ) [EOL] [comment] [EOL] m = ManifestFile ( base ) [EOL] m . add ( Manifest ( base , mozpath . relpath ( path , base ) ) ) [EOL] packager . add ( mozpath . join ( base , [string] ) , m ) [EOL] [EOL] packager . close ( ) [EOL] [EOL] [comment] [EOL] for pattern in non_chrome : [EOL] for base in bases : [EOL] for p , f in l10n_finder . find ( mozpath . join ( base , pattern ) ) : [EOL] if not formatter . contains ( p ) : [EOL] formatter . add ( p , f ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for p , f in l10n_finder . find ( [string] ) : [EOL] if not formatter . contains ( p ) : [EOL] formatter . add ( p , f ) [EOL] [EOL] [comment] [EOL] for path , log in six . iteritems ( app_finder . jarlogs ) : [EOL] assert isinstance ( copier [ path ] , Jarrer ) [EOL] copier [ path ] . preload ( [ l . replace ( locale , l10n_locale ) for l in log ] ) [EOL] [EOL] [EOL] def repack ( source , l10n , extra_l10n = { } , non_resources = [ ] , non_chrome = set ( ) ) : [EOL] [docstring] [EOL] app_finder = UnpackFinder ( source ) [EOL] l10n_finder = UnpackFinder ( l10n ) [EOL] if extra_l10n : [EOL] finders = { [string] : l10n_finder , } [EOL] for base , path in six . iteritems ( extra_l10n ) : [EOL] finders [ base ] = UnpackFinder ( path ) [EOL] l10n_finder = ComposedFinder ( finders ) [EOL] copier = FileCopier ( ) [EOL] compress = min ( app_finder . compressed , JAR_DEFLATED ) [EOL] if app_finder . kind == [string] : [EOL] formatter = FlatFormatter ( copier ) [EOL] elif app_finder . kind == [string] : [EOL] formatter = JarFormatter ( copier , compress = compress ) [EOL] elif app_finder . kind == [string] : [EOL] formatter = OmniJarFormatter ( copier , app_finder . omnijar , compress = compress , non_resources = non_resources ) [EOL] [EOL] with errors . accumulate ( ) : [EOL] _repack ( app_finder , l10n_finder , copier , formatter , non_chrome ) [EOL] copier . copy ( source , skip_if_older = False ) [EOL] generate_precomplete ( source ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] import sys [EOL] [EOL] [EOL] if len ( sys . argv ) != [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] retcode = int ( sys . argv [ [number] ] ) [EOL] [EOL] if retcode : [EOL] print ( [string] , file = sys . stderr ) [EOL] [EOL] sys . exit ( retcode ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type , Union , Dict , List [EOL] import typing [EOL] import distutils [EOL] import signingscript [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import re [EOL] import six [EOL] from distutils . version import LooseVersion [EOL] from mozpack . errors import errors [EOL] from collections import OrderedDict [EOL] [EOL] [EOL] class Flag ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name ) : [EOL] [docstring] [EOL] self . name = name [EOL] self . value = None [EOL] [EOL] def add_definition ( self , definition ) : [EOL] [docstring] [EOL] if definition == self . name : [EOL] self . value = True [EOL] return [EOL] assert ( definition . startswith ( self . name ) ) [EOL] if definition [ len ( self . name ) ] != [string] : [EOL] return errors . fatal ( [string] % definition ) [EOL] value = definition [ len ( self . name ) + [number] : ] [EOL] if value in ( [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] self . value = value [EOL] else : [EOL] return errors . fatal ( [string] % definition ) [EOL] [EOL] def matches ( self , value ) : [EOL] [docstring] [EOL] if value in ( [string] , [string] , [string] , True ) : [EOL] return self . value in ( [string] , [string] , [string] , True ) [EOL] if value in ( [string] , [string] , [string] , False ) : [EOL] return self . value in ( [string] , [string] , [string] , False , None ) [EOL] raise RuntimeError ( [string] % value ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] if self . value is None : [EOL] return [string] [EOL] if self . value is True : [EOL] return self . name [EOL] return [string] % ( self . name , self . value ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return str ( self ) == other [EOL] [EOL] [EOL] class StringFlag ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name ) : [EOL] [docstring] [EOL] self . name = name [EOL] self . values = [ ] [EOL] [EOL] def add_definition ( self , definition ) : [EOL] [docstring] [EOL] assert ( definition . startswith ( self . name ) ) [EOL] value = definition [ len ( self . name ) : ] [EOL] if value . startswith ( [string] ) : [EOL] self . values . append ( ( [string] , value [ [number] : ] ) ) [EOL] elif value . startswith ( [string] ) : [EOL] self . values . append ( ( [string] , value [ [number] : ] ) ) [EOL] else : [EOL] return errors . fatal ( [string] % definition ) [EOL] [EOL] def matches ( self , value ) : [EOL] [docstring] [EOL] if not self . values : [EOL] return True [EOL] for comparison , val in self . values : [EOL] if eval ( [string] % comparison ) : [EOL] return True [EOL] return False [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] res = [ ] [EOL] for comparison , val in self . values : [EOL] if comparison == [string] : [EOL] res . append ( [string] % ( self . name , val ) ) [EOL] else : [EOL] res . append ( [string] % ( self . name , val ) ) [EOL] return [string] . join ( res ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return str ( self ) == other [EOL] [EOL] [EOL] class VersionFlag ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name ) : [EOL] [docstring] [EOL] self . name = name [EOL] self . values = [ ] [EOL] [EOL] def add_definition ( self , definition ) : [EOL] [docstring] [EOL] assert ( definition . startswith ( self . name ) ) [EOL] value = definition [ len ( self . name ) : ] [EOL] if value . startswith ( [string] ) : [EOL] self . values . append ( ( [string] , LooseVersion ( value [ [number] : ] ) ) ) [EOL] elif len ( value ) > [number] and value [ [number] ] in [ [string] , [string] ] : [EOL] if value [ [number] ] == [string] : [EOL] if len ( value ) < [number] : [EOL] return errors . fatal ( [string] % definition ) [EOL] self . values . append ( ( value [ [number] : [number] ] , LooseVersion ( value [ [number] : ] ) ) ) [EOL] else : [EOL] self . values . append ( ( value [ [number] ] , LooseVersion ( value [ [number] : ] ) ) ) [EOL] else : [EOL] return errors . fatal ( [string] % definition ) [EOL] [EOL] def matches ( self , value ) : [EOL] [docstring] [EOL] value = LooseVersion ( value ) [EOL] if not self . values : [EOL] return True [EOL] for comparison , val in self . values : [EOL] if eval ( [string] % comparison ) : [EOL] return True [EOL] return False [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] res = [ ] [EOL] for comparison , val in self . values : [EOL] if comparison == [string] : [EOL] res . append ( [string] % ( self . name , val ) ) [EOL] else : [EOL] res . append ( [string] % ( self . name , comparison , val ) ) [EOL] return [string] . join ( res ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return str ( self ) == other [EOL] [EOL] [EOL] class Flags ( OrderedDict ) : [EOL] [docstring] [EOL] FLAGS = { [string] : StringFlag , [string] : VersionFlag , [string] : VersionFlag , [string] : Flag , [string] : StringFlag , [string] : VersionFlag , [string] : StringFlag , [string] : Flag , [string] : Flag , [string] : Flag , [string] : StringFlag , } [EOL] RE = re . compile ( [string] ) [EOL] [EOL] def __init__ ( self , * flags ) : [EOL] [docstring] [EOL] OrderedDict . __init__ ( self ) [EOL] for f in flags : [EOL] name = self . RE . split ( f ) [EOL] name = name [ [number] ] [EOL] if name not in self . FLAGS : [EOL] errors . fatal ( [string] % name ) [EOL] continue [EOL] if name not in self : [EOL] self [ name ] = self . FLAGS [ name ] ( name ) [EOL] self [ name ] . add_definition ( f ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return [string] . join ( str ( self [ k ] ) for k in self ) [EOL] [EOL] def match ( self , ** filter ) : [EOL] [docstring] [EOL] for name , value in six . iteritems ( filter ) : [EOL] if name not in self : [EOL] continue [EOL] if not self [ name ] . matches ( value ) : [EOL] return False [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import os [EOL] import mock [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] import mock [EOL] import pytest [EOL] from conftest import PUB_KEY_PATH , read_file [EOL] from scriptworker . context import Context [EOL] [EOL] import signingscript . utils as utils [EOL] from signingscript . exceptions import FailedSubprocess , SigningServerError [EOL] [EOL] ID_RSA_PUB_HASH = [string] + [string] [EOL] [EOL] SERVER_CONFIG_PATH = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] def test_mkdir_does_make_dirs ( tmpdir ) : [EOL] def assertDirIsUniqueAndNamed ( dirs , name ) : [EOL] assert len ( dirs ) == [number] [EOL] assert dirs [ [number] ] . is_dir ( ) [EOL] assert dirs [ [number] ] . name == name [EOL] [EOL] end_dir = os . path . join ( tmpdir , [string] , [string] ) [EOL] utils . mkdir ( end_dir ) [EOL] [EOL] middle_dirs = list ( os . scandir ( tmpdir ) ) [EOL] assertDirIsUniqueAndNamed ( middle_dirs , [string] ) [EOL] [EOL] leaf_dirs = list ( os . scandir ( middle_dirs [ [number] ] . path ) ) [EOL] assertDirIsUniqueAndNamed ( leaf_dirs , [string] ) [EOL] [EOL] [EOL] def test_mkdir_mutes_os_errors ( mocker ) : [EOL] m = mocker . patch . object ( os , [string] ) [EOL] m . side_effect = OSError [EOL] utils . mkdir ( [string] ) [EOL] m . assert_called_with ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] def test_get_hash ( ) : [EOL] assert utils . get_hash ( PUB_KEY_PATH , hash_type = [string] ) == ID_RSA_PUB_HASH [EOL] [EOL] [EOL] [comment] [EOL] def test_load_json_from_file ( tmpdir ) : [EOL] json_object = { [string] : [string] } [EOL] [EOL] output_file = os . path . join ( tmpdir , [string] ) [EOL] with open ( output_file , [string] ) as f : [EOL] json . dump ( json_object , f ) [EOL] [EOL] assert utils . load_json ( output_file ) == json_object [EOL] [EOL] [EOL] [comment] [EOL] def test_load_autograph_configs ( ) : [EOL] context = Context ( ) [EOL] context . config = { [string] : SERVER_CONFIG_PATH } [EOL] cfg = utils . load_autograph_configs ( SERVER_CONFIG_PATH ) [EOL] assert cfg [ [string] ] [ [number] ] . url == [string] [EOL] assert cfg [ [string] ] [ [number] ] . client_id == [string] [EOL] assert cfg [ [string] ] [ [number] ] . access_key == [string] [EOL] assert cfg [ [string] ] [ [number] ] . formats == [ [string] ] [EOL] assert cfg [ [string] ] [ [number] ] . key_id == [string] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_log_output ( tmpdir , mocker ) : [EOL] logged = [ ] [EOL] with open ( SERVER_CONFIG_PATH , [string] ) as fh : [EOL] contents = fh . read ( ) [EOL] [EOL] def log ( _ , msg ) : [EOL] logged . append ( msg ) [EOL] [EOL] class AsyncIterator : [EOL] def __init__ ( self ) : [EOL] self . contents = contents . split ( [string] ) [EOL] [EOL] async def __aiter__ ( self ) : [EOL] return self [EOL] [EOL] async def __anext__ ( self ) : [EOL] while self . contents : [EOL] return self . contents . pop ( [number] ) . encode ( [string] ) [EOL] [EOL] mocklog = mocker . patch . object ( utils , [string] ) [EOL] mocklog . log = log [EOL] mockfh = mock . MagicMock ( ) [EOL] aiter = AsyncIterator ( ) [EOL] mockfh . readline = aiter . __anext__ [EOL] await utils . log_output ( mockfh ) [EOL] assert contents . rstrip ( ) == [string] . join ( logged ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( SERVER_CONFIG_PATH , None , os . path . basename ( SERVER_CONFIG_PATH ) , None ) , ( SERVER_CONFIG_PATH , [string] , [string] , None ) , ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) , None , None , SigningServerError ) , ) , ) def test_copy_to_dir ( tmpdir , source , target , expected , exc ) : [EOL] if exc : [EOL] with pytest . raises ( exc ) : [EOL] utils . copy_to_dir ( source , tmpdir , target = target ) [EOL] else : [EOL] newpath = utils . copy_to_dir ( source , tmpdir , target = target ) [EOL] assert newpath == os . path . join ( tmpdir , expected ) [EOL] contents1 = read_file ( source ) [EOL] contents2 = read_file ( newpath ) [EOL] assert contents1 == contents2 [EOL] [EOL] [EOL] def test_copy_to_dir_no_copy ( ) : [EOL] assert utils . copy_to_dir ( SERVER_CONFIG_PATH , os . path . dirname ( SERVER_CONFIG_PATH ) ) is None [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [number] , [number] ) ) async def test_execute_subprocess ( exit_code ) : [EOL] command = [ [string] , [string] , [string] . format ( exit_code ) ] [EOL] if exit_code != [number] : [EOL] with pytest . raises ( FailedSubprocess ) : [EOL] await utils . execute_subprocess ( command ) [EOL] else : [EOL] await utils . execute_subprocess ( command , cwd = [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , True ) , ( [string] , False ) , ( [string] , False ) , ( [string] , False ) ) ) def test_is_sha1_apk_autograph_signing_format ( format , expected ) : [EOL] assert utils . is_sha1_apk_autograph_signing_format ( format ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import unittest [EOL] import mock [EOL] import typing [EOL] import os [EOL] from unittest . mock import MagicMock [EOL] [EOL] import mock [EOL] import pytest [EOL] import scriptworker . client [EOL] from conftest import BASE_DIR , noop_sync [EOL] [EOL] import signingscript . script as script [EOL] [EOL] [comment] [EOL] EXAMPLE_CONFIG = os . path . join ( BASE_DIR , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] async def async_main_helper ( tmpdir , mocker , formats , extra_config = { } , server_type = [string] , use_comment = None ) : [EOL] def fake_filelist_dict ( * args , ** kwargs ) : [EOL] ret = { [string] : { [string] : [string] , [string] : formats } } [EOL] if use_comment : [EOL] ret = { [string] : { [string] : [string] , [string] : formats , [string] : [string] } } [EOL] return ret [EOL] [EOL] async def fake_sign ( _ , val , * args , authenticode_comment = None ) : [EOL] if not use_comment : [EOL] assert authenticode_comment is None [EOL] else : [EOL] assert authenticode_comment == [string] [EOL] return [ val ] [EOL] [EOL] mocker . patch . object ( script , [string] , new = noop_sync ) [EOL] [comment] [EOL] mocker . patch . object ( script , [string] , return_value = formats ) [EOL] mocker . patch . object ( script , [string] , new = fake_filelist_dict ) [EOL] mocker . patch . object ( script , [string] , new = fake_sign ) [EOL] context = mock . MagicMock ( ) [EOL] context . config = { [string] : tmpdir , [string] : tmpdir , [string] : { } } [EOL] context . config . update ( extra_config ) [EOL] await script . async_main ( context ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_main_gpg ( tmpdir , tmpfile , mocker ) : [EOL] formats = [ [string] ] [EOL] fake_gpg_pubkey = tmpfile [EOL] mocked_copy_to_dir = mocker . Mock ( ) [EOL] mocker . patch . object ( script , [string] , new = mocked_copy_to_dir ) [EOL] [EOL] await async_main_helper ( tmpdir , mocker , formats , { [string] : fake_gpg_pubkey } ) [EOL] for call in mocked_copy_to_dir . call_args_list : [EOL] if call [ [number] ] . get ( [string] ) == [string] : [EOL] break [EOL] else : [EOL] assert False , [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_main_gpg_no_pubkey_defined ( tmpdir , mocker ) : [EOL] formats = [ [string] ] [EOL] [EOL] try : [EOL] await async_main_helper ( tmpdir , mocker , formats ) [EOL] except Exception as e : [EOL] assert e . args [ [number] ] == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_main_gpg_pubkey_doesnt_exist ( tmpdir , mocker ) : [EOL] formats = [ [string] ] [EOL] [EOL] try : [EOL] await async_main_helper ( tmpdir , mocker , formats , { [string] : [string] } ) [EOL] except Exception as e : [EOL] assert e . args [ [number] ] == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_main_multiple_formats ( tmpdir , mocker ) : [EOL] formats = [ [string] , [string] ] [EOL] mocker . patch . object ( script , [string] , new = noop_sync ) [EOL] await async_main_helper ( tmpdir , mocker , formats ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_main_autograph ( tmpdir , mocker ) : [EOL] formats = [ [string] ] [EOL] mocker . patch . object ( script , [string] , new = noop_sync ) [EOL] await async_main_helper ( tmpdir , mocker , formats , { } ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_async_main_autograph_authenticode ( tmpdir , mocker , use_comment ) : [EOL] formats = [ [string] ] [EOL] mocker . patch . object ( script , [string] , new = noop_sync ) [EOL] await async_main_helper ( tmpdir , mocker , formats , { } , [string] , use_comment = use_comment ) [EOL] [EOL] [EOL] def test_get_default_config ( ) : [EOL] parent_dir = os . path . dirname ( os . getcwd ( ) ) [EOL] c = script . get_default_config ( ) [EOL] assert c [ [string] ] == os . path . join ( parent_dir , [string] ) [EOL] [EOL] [EOL] def test_main ( monkeypatch ) : [EOL] sync_main_mock = MagicMock ( ) [EOL] monkeypatch . setattr ( scriptworker . client , [string] , sync_main_mock ) [EOL] script . main ( ) [EOL] sync_main_mock . asset_called_once_with ( script . async_main , default_config = script . get_default_config ( ) ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_main_widevine_no_cert_defined ( tmpdir , mocker ) : [EOL] formats = [ [string] ] [EOL] with pytest . raises ( Exception ) as e : [EOL] await async_main_helper ( tmpdir , mocker , formats ) [EOL] assert e . args [ [number] ] == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_main_widevine ( tmp_path , mocker ) : [EOL] mocker . patch . object ( script , [string] ) [EOL] tmp_cert = tmp_path / [string] [EOL] formats = [ [string] ] [EOL] await async_main_helper ( tmp_path , mocker , formats , { [string] : tmp_cert } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] from signingscript . exceptions import FailedSubprocess , SigningServerError [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( SigningServerError , FailedSubprocess ) ) def test_exception ( exc ) : [EOL] a = exc ( [string] ) [EOL] assert isinstance ( a , ScriptWorkerTaskException ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import tempfile [EOL] from contextlib import contextmanager [EOL] from distutils . util import strtobool [EOL] [EOL] import pytest [EOL] from scriptworker . context import Context [EOL] [EOL] from signingscript . exceptions import SigningScriptError [EOL] from signingscript . script import get_default_config [EOL] from signingscript . utils import load_autograph_configs , mkdir [EOL] [EOL] [EOL] def read_file ( path ) : [EOL] with open ( path , [string] ) as fh : [EOL] return fh . read ( ) [EOL] [EOL] [EOL] BASE_DIR = os . path . dirname ( os . path . dirname ( __file__ ) ) [EOL] SERVER_CONFIG_PATH = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] DEFAULT_SCOPE_PREFIX = [string] [EOL] TEST_DATA_DIR = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] PUB_KEY_PATH = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] PUB_KEY = read_file ( PUB_KEY_PATH ) [EOL] [EOL] [EOL] def noop_sync ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] async def noop_async ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def tmpfile ( ) : [EOL] with tempfile . NamedTemporaryFile ( delete = False ) as tmp : [EOL] tmp . write ( bytes ( [string] , [string] ) ) [EOL] tmp . flush ( ) [EOL] return tmp . name [EOL] [EOL] [EOL] def die ( * args , ** kwargs ) : [EOL] raise SigningScriptError ( [string] ) [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def context ( tmpdir ) : [EOL] context = Context ( ) [EOL] context . config = get_default_config ( ) [EOL] context . config [ [string] ] = SERVER_CONFIG_PATH [EOL] context . config [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] context . config [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] context . config [ [string] ] = [ DEFAULT_SCOPE_PREFIX ] [EOL] context . autograph_configs = load_autograph_configs ( SERVER_CONFIG_PATH ) [EOL] mkdir ( context . config [ [string] ] ) [EOL] mkdir ( context . config [ [string] ] ) [EOL] yield context [EOL] [EOL] [EOL] @ contextmanager def does_not_raise ( ) : [EOL] yield [EOL] [EOL] [EOL] def skip_when_no_autograph_server ( function ) : [EOL] return pytest . mark . skipif ( not strtobool ( os . environ . get ( [string] , [string] ) ) , reason = [string] ) ( function ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import subprocess [EOL] import typing [EOL] import logging [EOL] import copy [EOL] import json [EOL] import logging [EOL] import os [EOL] import shutil [EOL] import subprocess [EOL] import zipfile [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] from conftest import skip_when_no_autograph_server [EOL] from mardor . cli import do_verify [EOL] from scriptworker . utils import makedirs [EOL] [EOL] from signingscript . script import async_main [EOL] from signingscript . sign import sign_file_with_autograph [EOL] from signingscript . utils import Autograph [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] DATA_DIR = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] , [string] ) [EOL] TEST_DATA_DIR = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] [EOL] [EOL] DEFAULT_SERVER_CONFIG = { [string] : [ [ [string] , [string] , [string] , [ [string] ] ] , [ [string] , [string] , [string] , [ [string] ] ] , [ [string] , [string] , [string] , [ [string] ] ] , [ [string] , [string] , [string] , [ [string] ] ] , ] } [EOL] [EOL] [EOL] DEFAULT_CONFIG = { [string] : [string] , [string] : [string] , [string] : os . path . join ( DATA_DIR , [string] ) , [string] : [ [string] ] , [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] DEFAULT_TASK = { [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : [string] , [string] : { } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [ ] } ] , [string] : [number] , } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [ ] , [string] : [string] , [string] : [ [string] , [string] , ] , [string] : { } , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def _copy_files_to_work_dir ( file_name , context ) : [EOL] original_file_path = os . path . join ( TEST_DATA_DIR , file_name ) [EOL] copied_file_folder = os . path . join ( context . config [ [string] ] , [string] , [string] ) [EOL] makedirs ( copied_file_folder ) [EOL] shutil . copy ( original_file_path , copied_file_folder ) [EOL] [EOL] [EOL] def _write_server_config ( tmpdir ) : [EOL] server_config_path = os . path . join ( tmpdir , [string] ) [EOL] with open ( server_config_path , mode = [string] ) as f : [EOL] json . dump ( DEFAULT_SERVER_CONFIG , f ) [EOL] [EOL] return server_config_path [EOL] [EOL] [EOL] def _craft_task ( file_names , signing_format ) : [EOL] task = copy . deepcopy ( DEFAULT_TASK ) [EOL] task [ [string] ] [ [string] ] [ [number] ] [ [string] ] = file_names [EOL] task [ [string] ] [ [string] ] [ [number] ] [ [string] ] = [ signing_format ] [EOL] task [ [string] ] . append ( [string] . format ( signing_format ) ) [EOL] [EOL] return task [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ skip_when_no_autograph_server async def test_integration_autograph_mar_sign_file ( context , tmpdir ) : [EOL] file_names = [ [string] , [string] ] [EOL] for file_name in file_names : [EOL] _copy_files_to_work_dir ( file_name , context ) [EOL] [EOL] context . config [ [string] ] = _write_server_config ( tmpdir ) [EOL] context . task = _craft_task ( file_names , signing_format = [string] ) [EOL] [EOL] await async_main ( context ) [EOL] [EOL] mar_pub_key_path = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] signed_paths = [ os . path . join ( context . config [ [string] ] , file_name ) for file_name in file_names ] [EOL] for signed_path in signed_paths : [EOL] assert do_verify ( signed_path , keyfiles = [ mar_pub_key_path ] ) , [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ skip_when_no_autograph_server async def test_integration_autograph_mar_sign_hash ( context , tmpdir , mocker ) : [EOL] file_names = [ [string] , [string] ] [EOL] for file_name in file_names : [EOL] _copy_files_to_work_dir ( file_name , context ) [EOL] [EOL] mocker . patch ( [string] , new = lambda * args : None ) [EOL] context . config [ [string] ] = _write_server_config ( tmpdir ) [EOL] context . task = _craft_task ( file_names , signing_format = [string] ) [EOL] [EOL] await async_main ( context ) [EOL] [EOL] mar_pub_key_path = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] signed_paths = [ os . path . join ( context . config [ [string] ] , file_name ) for file_name in file_names ] [EOL] for signed_path in signed_paths : [EOL] assert do_verify ( signed_path , keyfiles = [ mar_pub_key_path ] ) , [string] [EOL] [EOL] [EOL] def _get_java_path ( tool_name ) : [EOL] if os . environ . get ( [string] ) : [EOL] return os . path . join ( os . environ [ [string] ] , [string] , tool_name ) [EOL] return tool_name [EOL] [EOL] [EOL] def _instantiate_keystore ( keystore_path , certificate_path , certificate_alias ) : [EOL] keystore_password = [string] [EOL] cmd = [ _get_java_path ( [string] ) , [string] , [string] , [string] , keystore_path , [string] , keystore_password , [string] , certificate_path , [string] , certificate_alias , ] [EOL] log . info ( [string] . format ( cmd ) ) [EOL] subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = True ) [EOL] [EOL] [EOL] def _verify_apk_signature ( keystore_path , apk_path , certificate_alias , strict = True ) : [EOL] cmd = [ _get_java_path ( [string] ) , [string] , [string] , [string] , keystore_path , apk_path , certificate_alias ] [EOL] if strict : [EOL] cmd += [ [string] ] [EOL] log . info ( [string] . format ( cmd ) ) [EOL] command = subprocess . run ( cmd , universal_newlines = True ) [EOL] return command . returncode == [number] [EOL] [EOL] [EOL] def _extract_compress_type_per_filename ( path ) : [EOL] with zipfile . ZipFile ( path ) as zip : [EOL] return { zip_info . filename : zip_info . compress_type for zip_info in zip . infolist ( ) } [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ skip_when_no_autograph_server async def test_integration_autograph_focus ( context , tmpdir ) : [EOL] file_name = [string] [EOL] original_file_path = os . path . join ( TEST_DATA_DIR , file_name ) [EOL] copied_file_folder = os . path . join ( context . config [ [string] ] , [string] , [string] ) [EOL] makedirs ( copied_file_folder ) [EOL] shutil . copy ( original_file_path , copied_file_folder ) [EOL] [EOL] zip_infos_before_signature = _extract_compress_type_per_filename ( os . path . join ( copied_file_folder , file_name ) ) [EOL] [EOL] context . config [ [string] ] = _write_server_config ( tmpdir ) [EOL] context . task = _craft_task ( [ file_name ] , signing_format = [string] ) [EOL] [EOL] keystore_path = os . path . join ( tmpdir , [string] ) [EOL] certificate_path = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] certificate_alias = [string] [EOL] _instantiate_keystore ( keystore_path , certificate_path , certificate_alias ) [EOL] [EOL] await async_main ( context ) [EOL] [EOL] signed_path = os . path . join ( tmpdir , [string] , file_name ) [EOL] assert _verify_apk_signature ( keystore_path , signed_path , certificate_alias , strict = False ) [EOL] [EOL] zip_infos_after_signature = _extract_compress_type_per_filename ( signed_path ) [EOL] for signature_file in ( [string] , [string] , [string] ) : [EOL] del zip_infos_after_signature [ signature_file ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] assert zip_infos_before_signature == zip_infos_after_signature [EOL] [EOL] [EOL] def _extract_apk_signature_algorithm ( apk_path ) : [EOL] cmd = [ _get_java_path ( [string] ) , [string] , [string] , apk_path ] [EOL] log . info ( [string] . format ( cmd ) ) [EOL] command = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = True ) [EOL] [EOL] assert command . returncode == [number] [EOL] [EOL] algorithm_line = [ line for line in command . stdout . split ( [string] ) if [string] in line ] [ [number] ] [EOL] algorithm = algorithm_line . strip ( ) . split ( [string] ) [ [number] ] [EOL] return algorithm . rstrip ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ skip_when_no_autograph_server @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) ) ) async def test_integration_autograph_custom_digest_algorithm ( context , tmpdir , format , expected_algorithm ) : [EOL] file_name = [string] [EOL] original_file_path = os . path . join ( TEST_DATA_DIR , file_name ) [EOL] shutil . copy ( original_file_path , tmpdir ) [EOL] apk_path = os . path . join ( tmpdir , file_name ) [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] context . session = session [EOL] [EOL] context . autograph_configs = { [string] : [ Autograph ( * [ [string] , [string] , [string] , [ format ] ] ) ] } [EOL] context . task = _craft_task ( [ file_name ] , signing_format = format ) [EOL] [EOL] await sign_file_with_autograph ( context , apk_path , format ) [EOL] assert _extract_apk_signature_algorithm ( apk_path ) == expected_algorithm [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ skip_when_no_autograph_server async def test_integration_autograph_authenticode ( context , tmpdir ) : [EOL] context . config [ [string] ] = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] context . config [ [string] ] = None [EOL] context . config [ [string] ] = [string] [EOL] context . autograph_configs = { [string] : [ Autograph ( * [ [string] , [string] , [string] , [ [string] ] ] ) ] } [EOL] context . config [ [string] ] = _write_server_config ( tmpdir ) [EOL] _copy_files_to_work_dir ( [string] , context ) [EOL] context . task = _craft_task ( [ [string] ] , signing_format = [string] ) [EOL] [EOL] await async_main ( context ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.List[typing.Union[typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.str]]],builtins.int]],typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.List[typing.Union[typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.str]]],builtins.int]],typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any , Dict , List [EOL] import githubscript [EOL] import unittest [EOL] import typing [EOL] import builtins [EOL] from contextlib import asynccontextmanager [EOL] from contextlib import nullcontext as does_not_raise [EOL] from dataclasses import dataclass [EOL] from unittest . mock import MagicMock , mock_open , patch [EOL] [EOL] import pytest [EOL] from github3 . exceptions import NotFoundError [EOL] from scriptworker_client . exceptions import TaskError [EOL] [EOL] import githubscript . github as github [EOL] [EOL] [EOL] @ pytest . fixture def release_config ( ) : [EOL] return { [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , } [EOL] [EOL] [EOL] @ dataclass class _DummyRelease : [EOL] tag_name = [string] [EOL] target_commitish = [string] [EOL] name = [string] [EOL] prerelease = False [EOL] [EOL] [EOL] @ dataclass class _DummyArtifact : [EOL] content_type = [string] [EOL] browser_download_url = [string] [EOL] name = [string] [EOL] size = [number] [EOL] [EOL] [EOL] def _create_async_mock ( monkeypatch_ , target , max_calls = [number] ) : [EOL] counter = ( n for n in range ( [number] , max_calls + [number] ) ) [EOL] [EOL] async def async_mock ( * args , ** kwargs ) : [EOL] next ( counter ) [EOL] [EOL] monkeypatch_ . setattr ( github , target , async_mock ) [EOL] return counter [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( False , False , [number] , [number] , [number] , [number] ) , ( True , False , [number] , [number] , [number] , [number] ) , ( True , True , [number] , [number] , [number] , [number] ) ) , ) async def test_release ( monkeypatch , release_config , contact_github , release_exists , expected_init_calls , expected_update_calls , expected_create_calls , expected_upload_calls ) : [EOL] release_config [ [string] ] = contact_github [EOL] init_call_counter = _create_async_mock ( monkeypatch , [string] ) [EOL] _create_async_mock ( monkeypatch , [string] ) [EOL] [EOL] get_release_call_counter = ( n for n in range ( [number] , [number] ) ) [EOL] [EOL] async def _mock_get_release ( * args ) : [EOL] if release_exists or next ( get_release_call_counter ) >= [number] : [EOL] return _DummyRelease ( ) [EOL] raise NotFoundError ( MagicMock ( ) ) [EOL] [EOL] monkeypatch . setattr ( github , [string] , _mock_get_release ) [EOL] [EOL] update_call_counter = _create_async_mock ( monkeypatch , [string] ) [EOL] create_call_counter = _create_async_mock ( monkeypatch , [string] ) [EOL] upload_call_counter = _create_async_mock ( monkeypatch , [string] ) [EOL] _create_async_mock ( monkeypatch , [string] ) [EOL] [EOL] await github . release ( release_config ) [EOL] assert next ( init_call_counter ) == expected_init_calls [EOL] assert next ( update_call_counter ) == expected_update_calls [EOL] assert next ( create_call_counter ) == expected_create_calls [EOL] assert next ( upload_call_counter ) == expected_upload_calls [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_init_github_client ( monkeypatch ) : [EOL] github_library = MagicMock ( ) [EOL] monkeypatch . setattr ( github , [string] , github_library ) [EOL] await github . _init_github_client ( [string] ) [EOL] github_library . GitHub . assert_called_once_with ( token = [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_github_repository ( release_config ) : [EOL] github_client = MagicMock ( ) [EOL] await github . _get_github_repository ( github_client , release_config ) [EOL] github_client . repository . assert_called_once_with ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_release_from_tag ( ) : [EOL] github_repository = MagicMock ( ) [EOL] await github . _get_release_from_tag ( github_repository , [string] ) [EOL] github_repository . release_from_tag . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_create_release ( release_config ) : [EOL] github_repository = MagicMock ( ) [EOL] await github . _create_release ( github_repository , release_config ) [EOL] github_repository . create_release . assert_called_once_with ( tag_name = [string] , target_commitish = [string] , name = [string] , draft = False , prerelease = False , ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_edit_existing_release ( release_config ) : [EOL] existing_release = MagicMock ( ) [EOL] await github . _edit_existing_release ( existing_release , release_config ) [EOL] existing_release . edit . assert_called_once_with ( tag_name = [string] , target_commitish = [string] , name = [string] , draft = False , prerelease = False , ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_delete_artifact ( ) : [EOL] existing_release = MagicMock ( ) [EOL] await github . _delete_artifact ( existing_release ) [EOL] existing_release . delete . assert_called_once_with ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_upload_artifact ( tmpdir ) : [EOL] existing_release = MagicMock ( ) [EOL] file_path = tmpdir . join ( [string] ) [EOL] artifact = { [string] : [string] , [string] : file_path , [string] : [string] , } [EOL] [EOL] mock_open_ = mock_open ( ) [EOL] [comment] [EOL] [comment] [EOL] with patch ( [string] , mock_open_ ) : [EOL] await github . _upload_artifact ( existing_release , artifact ) [EOL] [EOL] mock_open_ . assert_called_once_with ( file_path , [string] ) [EOL] file_handle = mock_open_ ( ) [EOL] [EOL] existing_release . upload_asset . assert_called_once_with ( content_type = [string] , name = [string] , asset = file_handle , ) [EOL] [EOL] [EOL] def test_get_github_release_kwargs ( release_config ) : [EOL] assert github . _get_github_release_kwargs ( release_config ) == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , [string] : False , } [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( False , [number] ) , ( True , [number] ) ) ) async def test_update_release_if_needed ( monkeypatch , release_config , update_release , expected_edit_calls ) : [EOL] existing_release = _DummyRelease ( ) [EOL] monkeypatch . setattr ( github , [string] , lambda * args : update_release ) [EOL] edit_call_counter = _create_async_mock ( monkeypatch , [string] ) [EOL] [EOL] await github . _update_release_if_needed ( existing_release , release_config ) [EOL] assert next ( edit_call_counter ) == expected_edit_calls [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( _DummyRelease ( ) , False ) , ( _DummyRelease ( tag_name = [string] ) , True ) , ( _DummyRelease ( target_commitish = [string] ) , True ) , ( _DummyRelease ( name = [string] ) , True ) , ( _DummyRelease ( prerelease = True ) , True ) , ) , ) def test_does_release_need_to_be_updated ( release_config , existing_release , expected_result ) : [EOL] assert github . _does_release_need_to_be_updated ( existing_release , release_config ) == expected_result [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_upload_artifacts_if_needed ( monkeypatch ) : [EOL] existing_release = MagicMock ( ) [EOL] existing_release . assets . return_value = ( _DummyArtifact ( ) , _DummyArtifact ( name = [string] ) ) [EOL] release_config = { [string] : [ { [string] : [string] } , { [string] : [string] } ] } [EOL] upload_call_counter = _create_async_mock ( monkeypatch , [string] , max_calls = [number] ) [EOL] [EOL] await github . _upload_artifacts_if_needed ( existing_release , release_config ) [EOL] assert next ( upload_call_counter ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( False , False , [number] , [number] ) , ( False , True , [number] , [number] ) , ( True , False , [number] , [number] ) , ( True , True , [number] , [number] ) ) , ) async def test_upload_artifact_if_needed ( monkeypatch , artifact_exists , update_artifact , expected_delete_calls , expected_upload_calls ) : [EOL] existing_release = MagicMock ( ) [EOL] existing_artifacts = [ _DummyArtifact ( ) ] [EOL] artifact = { [string] : [string] } [EOL] [EOL] def _dummy_get_artifact ( * args ) : [EOL] if artifact_exists : [EOL] return _DummyArtifact ( ) [EOL] raise ValueError ( [string] ) [EOL] [EOL] monkeypatch . setattr ( github , [string] , _dummy_get_artifact ) [EOL] [EOL] async def _dummy_artifact_reupload ( * args ) : [EOL] return update_artifact [EOL] [EOL] monkeypatch . setattr ( github , [string] , _dummy_artifact_reupload ) [EOL] [EOL] delete_call_counter = _create_async_mock ( monkeypatch , [string] ) [EOL] upload_call_counter = _create_async_mock ( monkeypatch , [string] ) [EOL] [EOL] await github . _upload_artifact_if_needed ( existing_release , existing_artifacts , artifact ) [EOL] assert next ( delete_call_counter ) == expected_delete_calls [EOL] assert next ( upload_call_counter ) == expected_upload_calls [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ _DummyArtifact ( ) ] , { [string] : [string] } , does_not_raise ( ) , _DummyArtifact ( ) , ) , ( [ _DummyArtifact ( ) , _DummyArtifact ( name = [string] ) ] , { [string] : [string] } , does_not_raise ( ) , _DummyArtifact ( name = [string] ) , ) , ( [ _DummyArtifact ( ) ] , { [string] : [string] } , pytest . raises ( ValueError ) , None , ) , ( [ _DummyArtifact ( ) , _DummyArtifact ( ) ] , { [string] : [string] } , pytest . raises ( ValueError ) , None , ) , ) , ) def test_get_existing_artifact ( existing_artifacts , target_artifact , expectation , expected_result ) : [EOL] with expectation : [EOL] assert github . _get_existing_artifact ( existing_artifacts , target_artifact ) == expected_result [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( _DummyArtifact ( ) , { [string] : [string] , [string] : [string] , [string] : [number] } , True , False , ) , ( _DummyArtifact ( [string] ) , { [string] : [string] , [string] : [string] , [string] : [number] } , True , True , ) , ( _DummyArtifact ( size = [number] ) , { [string] : [string] , [string] : [string] , [string] : [number] } , True , True , ) , ( _DummyArtifact ( ) , { [string] : [string] , [string] : [string] , [string] : [number] } , False , True , ) , ) , ) async def test_does_existing_artifact_need_to_be_reuploaded ( monkeypatch , existing_artifact , target_artifact , artifact_exists , expected_result ) : [EOL] http_response = MagicMock ( ) [EOL] http_response . status = [number] if artifact_exists else [number] [EOL] [EOL] @ asynccontextmanager async def _dummy_http_get ( * args , ** kwargs ) : [EOL] yield http_response [EOL] [EOL] @ asynccontextmanager async def _dummy_http_client ( * args , ** kwargs ) : [EOL] client_dummy = MagicMock ( ) [EOL] client_dummy . get = _dummy_http_get [EOL] yield client_dummy [EOL] [EOL] monkeypatch . setattr ( github , [string] , _dummy_http_client ) [EOL] assert await github . _does_existing_artifact_need_to_be_reuploaded ( existing_artifact , target_artifact ) == expected_result [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( False , False , does_not_raise ( ) , ) , ( True , False , pytest . raises ( TaskError ) , ) , ( False , True , pytest . raises ( TaskError ) , ) , ) , ) async def test_check_final_state_of_release ( monkeypatch , update_release , update_artifact , expectation ) : [EOL] existing_release = MagicMock ( ) [EOL] existing_release . assets . return_value = [ ] [EOL] monkeypatch . setattr ( github , [string] , lambda * args : update_release ) [EOL] monkeypatch . setattr ( github , [string] , lambda * args : { } ) [EOL] [EOL] async def _dummy_artifact_reupload ( * args , ** kwargs ) : [EOL] return update_artifact [EOL] [EOL] monkeypatch . setattr ( github , [string] , _dummy_artifact_reupload ) [EOL] [EOL] release_config = { [string] : [ { [string] : [string] } ] } [EOL] with expectation : [EOL] await github . _check_final_state_of_release ( existing_release , release_config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List [EOL] import typing [EOL] from contextlib import nullcontext as does_not_raise [EOL] [EOL] import pytest [EOL] from scriptworker_client . exceptions import TaskVerificationError [EOL] [EOL] import githubscript . release_config as release_config [EOL] [EOL] [EOL] def test_release_config ( monkeypatch ) : [EOL] def _dummy_get_artifacts ( * args , ** kwargs ) : [EOL] return [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } ] [EOL] [EOL] monkeypatch . setattr ( release_config , [string] , _dummy_get_artifacts ) [EOL] [EOL] config = { [string] : True , } [EOL] [EOL] product_config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] task_payload = { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , } [EOL] [EOL] assert release_config . get_release_config ( product_config , task_payload , config ) == { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } ] , [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , } [EOL] [EOL] [EOL] def test_get_artifacts ( monkeypatch ) : [EOL] config = { [string] : [string] , } [EOL] [EOL] task_payload = { [string] : [string] , [string] : [ { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] ] , [string] : [string] } , ] , } [EOL] [EOL] def _dummy_find_target_path ( taskcluster_path , _ ) : [EOL] if taskcluster_path . endswith ( [string] ) : [EOL] return [string] [EOL] elif taskcluster_path . endswith ( [string] ) : [EOL] return [string] [EOL] elif taskcluster_path . endswith ( [string] ) : [EOL] return [string] [EOL] else : [EOL] raise ValueError ( f' [string] { taskcluster_path } [string] ' ) [EOL] [EOL] monkeypatch . setattr ( release_config , [string] , _dummy_find_target_path ) [EOL] monkeypatch . setattr ( [string] , lambda _ : [number] ) [EOL] [EOL] assert release_config . _get_artifacts ( task_payload , config ) == [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [ { [string] : { [string] : { [string] : [ [string] ] } } } ] , does_not_raise ( ) , [string] , ) , ( [string] , [ { [string] : { [string] : { [string] : [ [string] ] } } } , { [string] : { [string] : { [string] : [ [string] ] } } } , ] , does_not_raise ( ) , [string] , ) , ( [string] , [ { [string] : { [string] : { [string] : [ ] } } } ] , pytest . raises ( TaskVerificationError ) , None , ) , ( [string] , [ { [string] : { [string] : { [string] : [ [string] , [string] ] } } } ] , pytest . raises ( TaskVerificationError ) , None , ) , ( [string] , [ { [string] : { [string] : { [string] : [ [string] ] } } } , { [string] : { [string] : { [string] : [ [string] ] } } } , ] , pytest . raises ( TaskVerificationError ) , None , ) , ( [string] , [ ] , pytest . raises ( TaskVerificationError ) , None , ) , ) , ) def test_find_target_path ( taskcluster_path , artifact_map , expectation , expected_result ) : [EOL] with expectation : [EOL] assert release_config . _find_target_path ( taskcluster_path , artifact_map ) == expected_result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from contextlib import nullcontext as does_not_raise [EOL] [EOL] import pytest [EOL] from scriptworker_client . exceptions import TaskVerificationError [EOL] [EOL] import githubscript . task as gstask [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] ] } , { [string] : [ [string] ] } , does_not_raise ( ) , [string] , ) , ( { [string] : [ [string] ] } , { [string] : [ [string] ] } , does_not_raise ( ) , [string] , ) , ( { [string] : [ [string] ] } , { [string] : [ [string] , [string] ] } , does_not_raise ( ) , [string] , ) , ( { [string] : [ [string] ] } , { [string] : [ [string] , [string] ] } , pytest . raises ( TaskVerificationError ) , None , ) , ( { [string] : [ [string] , [string] ] } , { [string] : [ [string] , [string] ] } , pytest . raises ( TaskVerificationError ) , None , ) , ) , ) def test_extract_common_scope_prefix ( config , task , expectation , expected_result ) : [EOL] with expectation : [EOL] assert gstask . extract_common_scope_prefix ( config , task ) == expected_result [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] ] } , [ [string] ] , ) , ( { [string] : [ [string] , [string] ] } , [ [string] , [string] ] , ) , ( { [string] : [ ] } , [ ] , ) , ) , ) def test_get_allowed_scope_prefixes ( config , expected_result ) : [EOL] assert gstask . _get_allowed_scope_prefixes ( config ) == expected_result [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] ] } , [string] , does_not_raise ( ) , [string] , ) , ( { [string] : [ ] } , [string] , pytest . raises ( TaskVerificationError ) , None , ) , ( { [string] : [ [string] , [string] ] } , [string] , pytest . raises ( TaskVerificationError ) , None , ) , ( { [string] : [ [string] ] } , [string] , pytest . raises ( TaskVerificationError ) , None , ) , ) , ) def test_get_action ( task , prefix , expectation , expected_result ) : [EOL] with expectation : [EOL] assert gstask . get_action ( task , prefix ) == expected_result [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] ] } , [string] , does_not_raise ( ) , [string] , ) , ( { [string] : [ ] } , [string] , pytest . raises ( TaskVerificationError ) , None , ) , ( { [string] : [ [string] , [string] ] } , [string] , pytest . raises ( TaskVerificationError ) , None , ) , ( { [string] : [ [string] ] } , [string] , pytest . raises ( TaskVerificationError ) , None , ) , ) , ) def test_get_github_project ( task , prefix , expectation , expected_result ) : [EOL] with expectation : [EOL] assert gstask . get_github_project ( task , prefix ) == expected_result [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] ] } , [string] , does_not_raise ( ) , [string] , ) , ( { [string] : [ [string] ] } , [string] , does_not_raise ( ) , [string] , ) , ( { [string] : [ [string] ] } , [string] , does_not_raise ( ) , [string] , ) , ( { [string] : [ ] } , [string] , pytest . raises ( TaskVerificationError ) , None , ) , ( { [string] : [ [string] , [string] ] } , [string] , pytest . raises ( TaskVerificationError ) , None , ) , ) , ) def test_extract_last_chunk_of_scope ( task , prefix , expectation , expected_result ) : [EOL] with expectation : [EOL] assert gstask . _extract_last_chunk_of_scope ( task , prefix ) == expected_result [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] ] } , [string] , does_not_raise ( ) , ) , ( { [string] : [ ] } , [string] , pytest . raises ( TaskVerificationError ) , ) , ( { [string] : [ [string] ] } , [string] , pytest . raises ( TaskVerificationError ) , ) , ) , ) def test_check_action_is_allowed ( project_config , action , expectation ) : [EOL] with expectation : [EOL] gstask . check_action_is_allowed ( project_config , action ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] import json [EOL] from contextlib import asynccontextmanager [EOL] from copy import deepcopy [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] [EOL] import githubscript . github [EOL] from githubscript . script import main [EOL] [EOL] [EOL] @ pytest . fixture def config ( ) : [EOL] return { [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , [string] : [string] , [string] : [string] } } , [string] : [ [string] ] , [string] : True , [string] : True , } [EOL] [EOL] [EOL] @ pytest . fixture def task ( ) : [EOL] return { [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : { [string] : [ { [string] : { [string] : { [string] : [ [string] ] } , [string] : { [string] : [ [string] ] } , } } ] , [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : [ { [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , } ] , } , } [EOL] [EOL] [EOL] def test_main_update_release ( monkeypatch , tmp_path , config , task ) : [EOL] github3_mock = MagicMock ( ) [EOL] monkeypatch . setattr ( githubscript . github , [string] , github3_mock ) [EOL] [EOL] github_client_mock = MagicMock ( ) [EOL] github3_mock . GitHub . return_value = github_client_mock [EOL] github_repository_mock = MagicMock ( ) [EOL] github_client_mock . repository . return_value = github_repository_mock [EOL] [EOL] incomplete_release_mock = MagicMock ( tag_name = [string] , target_commitish = [string] , prerelease = False , ) [EOL] incomplete_release_mock . configure_mock ( name = [string] ) [EOL] [EOL] valid_release_mock = deepcopy ( incomplete_release_mock ) [EOL] valid_release_mock = MagicMock ( tag_name = [string] , target_commitish = [string] , prerelease = False , ) [EOL] valid_release_mock . configure_mock ( name = [string] ) [EOL] [EOL] valid_release_with_assets_mock = deepcopy ( valid_release_mock ) [EOL] first_asset_mock = MagicMock ( content_type = [string] , size = [number] ) [EOL] first_asset_mock . configure_mock ( name = [string] ) [EOL] second_asset_mock = MagicMock ( content_type = [string] , size = [number] ) [EOL] second_asset_mock . configure_mock ( name = [string] ) [EOL] valid_release_with_assets_mock . assets . return_value = [ first_asset_mock , second_asset_mock ] [EOL] [EOL] github_repository_mock . release_from_tag . side_effect = [ incomplete_release_mock , valid_release_mock , valid_release_with_assets_mock , ] [EOL] [EOL] @ asynccontextmanager async def RetryClientMock ( * args , ** kwargs ) : [EOL] client_mock = MagicMock ( ) [EOL] [EOL] @ asynccontextmanager async def get_mock ( * args , ** kwargs ) : [EOL] response_mock = MagicMock ( status = [number] ) [EOL] yield response_mock [EOL] [EOL] client_mock . get = get_mock [EOL] yield client_mock [EOL] [EOL] monkeypatch . setattr ( githubscript . github , [string] , RetryClientMock ) [EOL] [EOL] work_dir = tmp_path / [string] [EOL] work_dir . mkdir ( ) [EOL] config [ [string] ] = str ( work_dir ) [EOL] [EOL] config_path = tmp_path / [string] [EOL] with open ( config_path , [string] ) as config_file : [EOL] json . dump ( config , config_file ) [EOL] [EOL] with open ( work_dir / [string] , [string] ) as task_file : [EOL] json . dump ( task , task_file ) [EOL] [EOL] for arch in ( [string] , [string] ) : [EOL] dir = work_dir / [string] / arch / [string] [EOL] dir . mkdir ( parents = True ) [EOL] file_path = dir / [string] [EOL] with open ( file_path , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] main ( config_path = config_path ) [EOL] incomplete_release_mock . edit . assert_called_with ( tag_name = [string] , target_commitish = [string] , name = [string] , draft = False , prerelease = False , ) [EOL] assert valid_release_mock . upload_asset . call_count == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict [EOL] import unittest [EOL] import typing [EOL] import os [EOL] from contextlib import nullcontext as does_not_raise [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] [EOL] import githubscript . script as script [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [string] , does_not_raise ( ) ) , ( [string] , pytest . raises ( NotImplementedError ) ) , ) , ) async def test_async_main ( monkeypatch , action , expectation ) : [EOL] config = { [string] : [string] , [string] : { [string] : { } } } [EOL] task = { [string] : { } } [EOL] monkeypatch . setattr ( script , [string] , lambda * args : [string] ) [EOL] monkeypatch . setattr ( script , [string] , lambda * args : [string] ) [EOL] monkeypatch . setattr ( script , [string] , lambda * args : { [string] : [string] } ) [EOL] monkeypatch . setattr ( script , [string] , lambda * args : action ) [EOL] monkeypatch . setattr ( script , [string] , lambda * args : None ) [EOL] [EOL] async def _dummy_release ( release_config ) : [EOL] assert release_config == { [string] : [string] } [EOL] [EOL] monkeypatch . setattr ( script , [string] , _dummy_release ) [EOL] with expectation : [EOL] await script . async_main ( config , task ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( False , [number] , [string] ) , ( True , [number] , None ) , ) , ) def test_warn_contact_github ( caplog , monkeypatch , contact_github , expected_records , expected_text ) : [EOL] script . _warn_contact_github ( contact_github ) [EOL] [EOL] assert len ( caplog . records ) == expected_records [EOL] if expected_records > [number] : [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert expected_text in caplog . text [EOL] [EOL] [EOL] def test_get_default_config ( ) : [EOL] parent_dir = os . path . dirname ( os . getcwd ( ) ) [EOL] assert script . get_default_config ( ) == { [string] : os . path . join ( parent_dir , [string] ) , [string] : False , } [EOL] [EOL] [EOL] def test_main ( monkeypatch ) : [EOL] sync_main_mock = MagicMock ( ) [EOL] monkeypatch . setattr ( script , [string] , sync_main_mock ) [EOL] script . main ( ) [EOL] sync_main_mock . asset_called_once_with ( script . async_main , default_config = script . get_default_config ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] [EOL] from scriptworker_client . client import sync_main [EOL] [EOL] from githubscript . github import release [EOL] from githubscript . release_config import get_release_config [EOL] from githubscript . task import check_action_is_allowed , extract_common_scope_prefix , get_action , get_github_project [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_main ( config , task ) : [EOL] prefix = extract_common_scope_prefix ( config , task ) [EOL] project = get_github_project ( task , prefix ) [EOL] project_config = config [ [string] ] [ project ] [EOL] [EOL] release_config = get_release_config ( project_config , task [ [string] ] , config ) [EOL] [EOL] contact_github = bool ( config . get ( [string] ) ) [EOL] _warn_contact_github ( contact_github ) [EOL] [EOL] action = get_action ( task , prefix ) [EOL] check_action_is_allowed ( project_config , action ) [EOL] if action == [string] : [EOL] await release ( release_config ) [EOL] else : [EOL] raise NotImplementedError ( f' [string] { action } [string] ' ) [EOL] [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] def _warn_contact_github ( contact_github ) : [EOL] if not contact_github : [EOL] log . warning ( [string] ) [EOL] [EOL] [EOL] def get_default_config ( ) : [EOL] cwd = os . getcwd ( ) [EOL] parent_dir = os . path . dirname ( cwd ) [EOL] [EOL] return { [string] : os . path . join ( parent_dir , [string] ) , [string] : False , } [EOL] [EOL] [EOL] def main ( config_path = None ) : [EOL] sync_main ( async_main , config_path = config_path , default_config = get_default_config ( ) , should_verify_task = False ) [EOL] [EOL] [EOL] __name__ == [string] and main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Set [EOL] import typing [EOL] from scriptworker_client . exceptions import TaskVerificationError [EOL] from scriptworker_client . utils import get_single_item_from_sequence [EOL] [EOL] [EOL] def extract_common_scope_prefix ( config , task ) : [EOL] prefixes = _get_allowed_scope_prefixes ( config ) [EOL] scopes = task [ [string] ] [EOL] [EOL] found_prefixes = set ( ( prefix for prefix in prefixes for scope in scopes if scope . startswith ( prefix ) ) ) [EOL] [EOL] return get_single_item_from_sequence ( sequence = found_prefixes , condition = lambda _ : True , ErrorClass = TaskVerificationError , no_item_error_message = f" [string] { prefixes } [string] " , too_many_item_error_message = [string] , ) [EOL] [EOL] [EOL] def _get_allowed_scope_prefixes ( config ) : [EOL] prefixes = config [ [string] ] [EOL] return [ prefix if prefix . endswith ( [string] ) else [string] . format ( prefix ) for prefix in prefixes ] [EOL] [EOL] [EOL] def get_action ( task , prefix ) : [EOL] action_prefix = f"{ prefix } [string] " [EOL] return _extract_last_chunk_of_scope ( task , action_prefix ) [EOL] [EOL] [EOL] def get_github_project ( task , prefix ) : [EOL] project_prefix = f"{ prefix } [string] " [EOL] return _extract_last_chunk_of_scope ( task , project_prefix ) [EOL] [EOL] [EOL] def _extract_last_chunk_of_scope ( task , prefix ) : [EOL] scope = get_single_item_from_sequence ( sequence = task [ [string] ] , condition = lambda scope : scope . startswith ( prefix ) , ErrorClass = TaskVerificationError , no_item_error_message = f' [string] { prefix } [string] ' , too_many_item_error_message = f' [string] { prefix } [string] ' , ) [EOL] [EOL] last_chunk = scope . split ( [string] ) [ prefix . count ( [string] ) : ] [comment] [EOL] return [string] . join ( last_chunk ) [EOL] [EOL] [EOL] def check_action_is_allowed ( project_config , action ) : [EOL] if action not in project_config [ [string] ] : [EOL] raise TaskVerificationError ( f' [string] { action } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any , Union , Dict , List [EOL] import logging [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] from asyncio import ensure_future [EOL] [EOL] import github3 [EOL] from aiohttp_retry import RetryClient [EOL] from scriptworker_client . exceptions import TaskError [EOL] from scriptworker_client . utils import async_wrap , get_single_item_from_sequence , raise_future_exceptions , retry_async_decorator [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def release ( release_config ) : [EOL] if not release_config [ [string] ] : [EOL] log . warning ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] github_client = await _init_github_client ( release_config . pop ( [string] ) ) [EOL] github_repository = await _get_github_repository ( github_client , release_config ) [EOL] release_name = release_config [ [string] ] [EOL] git_tag = release_config [ [string] ] [EOL] [EOL] try : [EOL] existing_release = await _get_release_from_tag ( github_repository , git_tag ) [EOL] log . info ( f" [string] { release_name } [string] " ) [EOL] await _update_release_if_needed ( existing_release , release_config ) [EOL] except github3 . exceptions . NotFoundError : [EOL] log . info ( f" [string] { release_name } [string] " ) [EOL] await _create_release ( github_repository , release_config ) [EOL] [EOL] log . info ( [string] ) [EOL] existing_release = await _get_release_from_tag ( github_repository , git_tag ) [EOL] await _upload_artifacts_if_needed ( existing_release , release_config ) [EOL] [EOL] log . info ( [string] ) [EOL] existing_release = await _get_release_from_tag ( github_repository , git_tag ) [EOL] await _check_final_state_of_release ( existing_release , release_config ) [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _GITHUB_LIBRARY_SLEEP_TIME_KWARGS = { [string] : [number] } [EOL] github_retry = retry_async_decorator ( retry_exceptions = github3 . exceptions . ServerError , sleeptime_kwargs = _GITHUB_LIBRARY_SLEEP_TIME_KWARGS ) [EOL] [EOL] [EOL] @ github_retry async def _init_github_client ( token ) : [EOL] async_github_constructor = async_wrap ( github3 . GitHub ) [EOL] return await async_github_constructor ( token = token ) [EOL] [EOL] [EOL] @ github_retry async def _get_github_repository ( github_client , release_config ) : [EOL] async_get_github_repository = async_wrap ( github_client . repository ) [EOL] return await async_get_github_repository ( release_config [ [string] ] , release_config [ [string] ] ) [EOL] [EOL] [EOL] @ github_retry async def _get_release_from_tag ( github_repository , git_tag ) : [EOL] async_release_from_tag = async_wrap ( github_repository . release_from_tag ) [EOL] return await async_release_from_tag ( git_tag ) [EOL] [EOL] [EOL] @ github_retry async def _create_release ( github_repository , release_config ) : [EOL] async_create_release = async_wrap ( github_repository . create_release ) [EOL] await async_create_release ( ** _get_github_release_kwargs ( release_config ) ) [EOL] [EOL] [EOL] @ github_retry async def _edit_existing_release ( existing_release , release_config ) : [EOL] async_edit_release = async_wrap ( existing_release . edit ) [EOL] await async_edit_release ( ** _get_github_release_kwargs ( release_config ) ) [EOL] [EOL] [EOL] @ github_retry async def _delete_artifact ( existing_artifact ) : [EOL] async_delete_release = async_wrap ( existing_artifact . delete ) [EOL] await async_delete_release ( ) [EOL] [EOL] [EOL] @ github_retry async def _upload_artifact ( existing_release , artifact ) : [EOL] async_func = async_wrap ( existing_release . upload_asset ) [EOL] [EOL] with open ( artifact [ [string] ] , [string] ) as f : [EOL] log . debug ( f' [string] { artifact [ [string] ] } [string] ' ) [EOL] await async_func ( content_type = artifact [ [string] ] , name = artifact [ [string] ] , asset = f ) [EOL] [EOL] [EOL] def _get_github_release_kwargs ( release_config ) : [EOL] return dict ( tag_name = release_config [ [string] ] , target_commitish = release_config [ [string] ] , name = release_config [ [string] ] , draft = False , prerelease = release_config [ [string] ] , ) [EOL] [EOL] [EOL] async def _update_release_if_needed ( existing_release , release_config ) : [EOL] if not _does_release_need_to_be_updated ( existing_release , release_config ) : [EOL] log . info ( [string] ) [EOL] return [EOL] [EOL] log . info ( [string] ) [EOL] await _edit_existing_release ( existing_release , release_config ) [EOL] [EOL] [EOL] def _does_release_need_to_be_updated ( existing_release , release_config ) : [EOL] should_release_be_updated = False [EOL] for config_field , github_field in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] target_value = release_config [ config_field ] [EOL] existing_value = getattr ( existing_release , github_field , None ) [EOL] if target_value != existing_value : [EOL] log . info ( f' [string] { config_field } [string] { target_value } [string] { existing_value }' ) [EOL] should_release_be_updated = True [EOL] [EOL] return should_release_be_updated [EOL] [EOL] [EOL] async def _upload_artifacts_if_needed ( existing_release , release_config ) : [EOL] existing_artifacts = list ( existing_release . assets ( ) ) [EOL] log . debug ( f" [string] { existing_artifacts }" ) [EOL] [EOL] coroutines = [ ensure_future ( _upload_artifact_if_needed ( existing_release , existing_artifacts , artifact ) ) for artifact in release_config [ [string] ] ] [EOL] await raise_future_exceptions ( coroutines ) [EOL] [EOL] [EOL] async def _upload_artifact_if_needed ( existing_release , existing_artifacts , artifact ) : [EOL] artifact_name = artifact [ [string] ] [EOL] try : [EOL] existing_artifact = _get_existing_artifact ( existing_artifacts , artifact ) [EOL] if await _does_existing_artifact_need_to_be_reuploaded ( existing_artifact , artifact ) : [EOL] [comment] [EOL] [comment] [EOL] log . info ( f' [string] { artifact_name } [string] ' ) [EOL] await _delete_artifact ( existing_artifact ) [EOL] else : [EOL] log . info ( f' [string] { artifact_name } [string] ' ) [EOL] return [EOL] except ValueError : [EOL] log . info ( f' [string] { artifact_name } [string] ' ) [EOL] [EOL] await _upload_artifact ( existing_release , artifact ) [EOL] [EOL] [EOL] def _get_existing_artifact ( existing_artifacts , target_artifact ) : [EOL] return get_single_item_from_sequence ( sequence = existing_artifacts , condition = lambda github_asset : github_asset . name == target_artifact [ [string] ] ) [EOL] [EOL] [EOL] async def _does_existing_artifact_need_to_be_reuploaded ( existing_artifact , target_artifact , retry_on_404 = False ) : [EOL] should_artifact_be_reuploaded = False [EOL] [EOL] artifact_name = target_artifact [ [string] ] [EOL] [EOL] for field in ( [string] , [string] ) : [EOL] target_value = target_artifact [ field ] [EOL] existing_value = getattr ( existing_artifact , field , None ) [EOL] if existing_value != target_value : [EOL] log . info ( f' [string] { artifact_name } [string] { field } [string] { target_value } [string] { existing_value }' ) [EOL] should_artifact_be_reuploaded = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] download_url = existing_artifact . browser_download_url [EOL] [comment] [EOL] retry_for_statuses = { [number] } if retry_on_404 else { } [EOL] async with RetryClient ( ) as client : [EOL] [comment] [EOL] [comment] [EOL] async with client . get ( download_url , retry_for_statuses = retry_for_statuses ) as response : [EOL] response_status = response . status [EOL] if response_status != [number] : [EOL] log . warning ( f' [string] { artifact_name } [string] { response_status }' ) [EOL] should_artifact_be_reuploaded = True [EOL] [EOL] return should_artifact_be_reuploaded [EOL] [EOL] [EOL] async def _check_final_state_of_release ( existing_release , release_config ) : [EOL] if _does_release_need_to_be_updated ( existing_release , release_config ) : [EOL] raise TaskError ( [string] ) [EOL] [EOL] existing_artifacts = list ( existing_release . assets ( ) ) [EOL] for artifact in release_config [ [string] ] : [EOL] existing_artifact = _get_existing_artifact ( existing_artifacts , artifact ) [EOL] if await _does_existing_artifact_need_to_be_reuploaded ( existing_artifact , artifact , retry_on_404 = True ) : [EOL] raise TaskError ( f' [string] { artifact [ [string] ] } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import os [EOL] from mimetypes import guess_type [EOL] [EOL] from scriptworker_client . exceptions import TaskVerificationError [EOL] from scriptworker_client . utils import get_artifact_path , get_single_item_from_sequence [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_release_config ( product_config , task_payload , config ) : [EOL] return { [string] : _get_artifacts ( task_payload , config ) , [string] : config [ [string] ] , [string] : task_payload [ [string] ] , [string] : task_payload [ [string] ] , [string] : product_config [ [string] ] , [string] : product_config [ [string] ] , [string] : product_config [ [string] ] , [string] : task_payload [ [string] ] , [string] : task_payload [ [string] ] , } [EOL] [EOL] [EOL] def _get_artifacts ( task_payload , config ) : [EOL] artifacts = [ ] [EOL] [EOL] for upstream_artifact_definition in task_payload [ [string] ] : [EOL] task_id = upstream_artifact_definition [ [string] ] [EOL] for taskcluster_path in upstream_artifact_definition [ [string] ] : [EOL] local_path = get_artifact_path ( task_id , taskcluster_path , work_dir = config [ [string] ] ) [EOL] target_path = _find_target_path ( taskcluster_path , task_payload [ [string] ] ) [EOL] [EOL] artifacts . append ( { [string] : guess_type ( local_path ) [ [number] ] , [string] : local_path , [string] : target_path , [string] : os . path . getsize ( local_path ) } ) [EOL] [EOL] return artifacts [EOL] [EOL] [EOL] def _find_target_path ( taskcluster_path , artifact_map ) : [EOL] target_path = None [EOL] for map_ in artifact_map : [EOL] if taskcluster_path in map_ [ [string] ] : [EOL] destinations = map_ [ [string] ] [ taskcluster_path ] [ [string] ] [EOL] candidate_destination = get_single_item_from_sequence ( sequence = destinations , condition = lambda _ : True , ErrorClass = TaskVerificationError , no_item_error_message = f' [string] { taskcluster_path } [string] ' , too_many_item_error_message = f' [string] { taskcluster_path } [string] ' , ) [EOL] [EOL] if target_path is not None : [EOL] raise TaskVerificationError ( f' [string] { taskcluster_path } [string] ' [string] ) [EOL] [EOL] target_path = candidate_destination [EOL] [EOL] if target_path is None : [EOL] raise TaskVerificationError ( f' [string] { taskcluster_path } [string] ' ) [EOL] [EOL] return target_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any , Union , Dict , List [EOL] import typing [EOL] import unittest [EOL] import contextlib [EOL] import tempfile [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] from mozilla_version . gecko import GeckoSnapVersion [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] from pushsnapscript import snap_store [EOL] from pushsnapscript . exceptions import AlreadyLatestError [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , False , None , False ) , ( [string] , [string] , False , None , False ) , ( [string] , [string] , True , [string] , True ) , ( [string] , [string] , True , [string] , False ) , ) , ) def test_push ( monkeypatch , channel , expected_macaroon_location , raises , exception_message , bubbles_up_exception ) : [EOL] fake_release_if_needed_count = ( n for n in range ( [number] , [number] ) ) [EOL] [EOL] context = MagicMock ( ) [EOL] context . config = { [string] : True , [string] : { [string] : [string] , [string] : [string] } } [EOL] store = MagicMock ( ) [EOL] store_client_mock = MagicMock ( ) [EOL] [EOL] @ contextlib . contextmanager def fake_store_session ( macaroon_location ) : [EOL] assert macaroon_location == expected_macaroon_location [EOL] yield store [EOL] [EOL] monkeypatch . setattr ( snap_store , [string] , fake_store_session ) [EOL] monkeypatch . setattr ( snap_store , [string] , store_client_mock ) [EOL] store_client_mock . push . side_effect = ( snap_store . StoreReviewError ( { [string] : [ { [string] : exception_message } ] , [string] : [string] } ) if raises else None ) [EOL] [EOL] def fake_release_if_needed ( store_ , channel_ , snap_file_path ) : [EOL] assert store_ is store [EOL] assert channel_ == channel_ [EOL] assert snap_file_path == [string] [EOL] next ( fake_release_if_needed_count ) [EOL] [EOL] monkeypatch . setattr ( snap_store , [string] , fake_release_if_needed ) [EOL] [EOL] if bubbles_up_exception : [EOL] with pytest . raises ( snap_store . StoreReviewError ) : [EOL] snap_store . push ( context , [string] , channel ) [EOL] assert next ( fake_release_if_needed_count ) == [number] [EOL] else : [EOL] snap_store . push ( context , [string] , channel ) [EOL] assert next ( fake_release_if_needed_count ) == [number] [EOL] [EOL] [EOL] def test_push_early_return_if_not_allowed ( monkeypatch ) : [EOL] call_count = ( n for n in range ( [number] , [number] ) ) [EOL] [EOL] context = MagicMock ( ) [EOL] [EOL] def increase_call_count ( _ , __ ) : [EOL] next ( call_count ) [EOL] [EOL] monkeypatch . setattr ( snap_store . snapcraft_store_client , [string] , increase_call_count ) [EOL] snap_store . push ( context , [string] , channel = [string] ) [EOL] [EOL] assert next ( call_count ) == [number] [EOL] [EOL] [EOL] class SomeSpecificException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_store_session ( monkeypatch , raises ) : [EOL] store_client_mock = MagicMock ( ) [EOL] monkeypatch . setattr ( snap_store , [string] , lambda : store_client_mock ) [EOL] [EOL] with tempfile . NamedTemporaryFile ( [string] ) as fake_macaroon : [EOL] if raises : [EOL] with pytest . raises ( SomeSpecificException ) : [EOL] with snap_store . _store_session ( fake_macaroon . name ) : [EOL] store_client_mock . login . assert_called_once ( ) [EOL] store_client_mock . logout . assert_not_called ( ) [EOL] raise SomeSpecificException ( [string] ) [EOL] else : [EOL] with snap_store . _store_session ( fake_macaroon . name ) : [EOL] store_client_mock . login . assert_called_once ( ) [EOL] store_client_mock . logout . assert_not_called ( ) [EOL] [EOL] assert store_client_mock . login . call_count == [number] [EOL] store_client_mock . logout . assert_called_once_with ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , True , TaskVerificationError , True , False , None ) , ( [string] , True , AlreadyLatestError , False , False , None ) , ( [string] , False , None , False , True , { [string] : [string] , [string] : [number] , [string] : [ [string] ] } ) , ( [string] , False , None , False , True , { [string] : [string] , [string] : [number] , [string] : [ [string] ] } ) , ) , ) def test_release_if_needed ( monkeypatch , channel , raises , exception , bubbles_up_exception , must_release , release_kwargs ) : [EOL] store = MagicMock ( ) [EOL] [EOL] def return_dummy ( * args , ** kwargs ) : [EOL] return [string] [EOL] [EOL] def return_dummy_tuple ( * args , ** kwargs ) : [EOL] return ( [string] , [string] ) [EOL] [EOL] monkeypatch . setattr ( snap_store , [string] , return_dummy ) [EOL] monkeypatch . setattr ( snap_store , [string] , return_dummy ) [EOL] monkeypatch . setattr ( snap_store , [string] , return_dummy ) [EOL] monkeypatch . setattr ( snap_store , [string] , return_dummy ) [EOL] monkeypatch . setattr ( snap_store , [string] , return_dummy ) [EOL] monkeypatch . setattr ( snap_store , [string] , lambda _ , __ : ( [number] , [string] ) ) [EOL] monkeypatch . setattr ( snap_store , [string] , return_dummy_tuple ) [EOL] [EOL] def check_current ( * args ) : [EOL] if raises : [EOL] if exception == AlreadyLatestError : [EOL] raise exception ( [string] , [string] ) [EOL] else : [EOL] raise exception ( [string] ) [EOL] [EOL] monkeypatch . setattr ( snap_store , [string] , check_current ) [EOL] [EOL] if bubbles_up_exception : [EOL] with pytest . raises ( exception ) : [EOL] snap_store . _release_if_needed ( store , channel , [string] ) [EOL] else : [EOL] snap_store . _release_if_needed ( store , channel , [string] ) [EOL] [EOL] if must_release : [EOL] store . release . assert_called_once_with ( ** release_kwargs ) [EOL] else : [EOL] store . release . assert_not_called ( ) [EOL] [EOL] [EOL] def test_list_all_revisions ( ) : [EOL] store = MagicMock ( ) [EOL] store . get_snap_revisions . return_value = [ { [string] : [number] , [string] : [string] , [string] : [ ] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ ] } , ] [EOL] [EOL] assert snap_store . _list_all_revisions ( store ) == [ { [string] : [number] , [string] : [string] , [string] : [ ] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ ] } , ] [EOL] store . get_snap_revisions . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] def test_pluck_metadata ( ) : [EOL] assert snap_store . _pluck_metadata ( [ { [string] : [number] , [string] : [string] , [string] : [ ] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ ] } , { [string] : [number] , [string] : [string] , [string] : [ [string] , [string] ] } , { [string] : [number] , [string] : [string] , [string] : [ [string] , [string] ] } , { [string] : [number] , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] ] } , ] ) == { [number] : { [string] : GeckoSnapVersion . parse ( [string] ) , [string] : [ ] } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) , [string] : [ ] } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) , [string] : [ [string] , [string] ] } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) , [string] : [ [string] , [string] ] } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) , [string] : [ [string] , [string] , [string] , [string] ] } , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , { [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } , } , ) , ( [string] , { [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } } ) , ( [string] , { [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } } ) , ( [string] , { [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } } ) , ) , ) def test_filter_versions_that_are_not_the_same_type ( channel , expected ) : [EOL] assert ( snap_store . _filter_versions_that_are_not_the_same_type ( { [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } , [number] : { [string] : GeckoSnapVersion . parse ( [string] ) } , } , channel , ) == expected ) [EOL] [EOL] [EOL] def test_populate_sha3_384 ( monkeypatch ) : [EOL] metadata_per_revision = { [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] ] } , [number] : { [string] : [string] , [string] : [ [string] ] } , } [EOL] [EOL] def gen_fake_hash ( _ , revision ) : [EOL] return [string] . format ( revision ) [EOL] [EOL] store = MagicMock ( ) [EOL] [EOL] monkeypatch . setattr ( snap_store , [string] , gen_fake_hash ) [EOL] [EOL] assert snap_store . _populate_sha3_384 ( store , metadata_per_revision ) == { [number] : { [string] : [string] , [string] : [ [string] ] , [string] : [string] } , [number] : { [string] : [string] , [string] : [ [string] ] , [string] : [string] } , } [EOL] [EOL] [EOL] def test_get_from_sha3_384_from_revision ( ) : [EOL] store = MagicMock ( ) [EOL] store . cpi . get_default_headers . return_value = { [string] : [string] } [EOL] store_get_mock = MagicMock ( ) [EOL] store_get_mock . json . return_value = { [string] : [string] } [EOL] store . cpi . get . return_value = store_get_mock [EOL] [EOL] assert snap_store . _get_from_sha3_384_from_revision ( store , [number] ) == [string] [EOL] store . cpi . get . assert_called_once_with ( [string] , headers = { [string] : [string] , [string] : [string] , [string] : [string] } , params = { [string] : [string] , [string] : [number] } , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [number] : { [string] : [string] , [string] : [string] } , [number] : { [string] : [string] , [string] : [string] } , [number] : { [string] : [string] , [string] : [string] } , } , False , ( [number] , [string] ) , ) , ( { [number] : { [string] : [string] , [string] : [string] } } , True , ValueError ) , ( { [number] : { [string] : [string] , [string] : [string] } , [number] : { [string] : [string] , [string] : [string] } } , True , ValueError , ) , ) , ) def test_find_revision_and_version_of_current_snap ( metadata_per_revision , raises , expected ) : [EOL] if raises : [EOL] with pytest . raises ( expected ) : [EOL] snap_store . _find_revision_and_version_of_current_snap ( metadata_per_revision , [string] ) [EOL] else : [EOL] snap_store . _find_revision_and_version_of_current_snap ( metadata_per_revision , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [number] , GeckoSnapVersion . parse ( [string] ) , [number] , GeckoSnapVersion . parse ( [string] ) , False , None ) , ( [number] , GeckoSnapVersion . parse ( [string] ) , [number] , GeckoSnapVersion . parse ( [string] ) , True , AlreadyLatestError ) , ( [number] , GeckoSnapVersion . parse ( [string] ) , [number] , GeckoSnapVersion . parse ( [string] ) , True , TaskVerificationError ) , ( [number] , GeckoSnapVersion . parse ( [string] ) , [number] , GeckoSnapVersion . parse ( [string] ) , True , TaskVerificationError ) , ( [number] , GeckoSnapVersion . parse ( [string] ) , [number] , GeckoSnapVersion . parse ( [string] ) , True , TaskVerificationError ) , ( [number] , GeckoSnapVersion . parse ( [string] ) , [number] , GeckoSnapVersion . parse ( [string] ) , True , TaskVerificationError ) , ) , ) def test_check_current_snap_is_not_released ( current_revision , current_version , latest_released_version , latest_released_revision , raises , expected ) : [EOL] if raises : [EOL] with pytest . raises ( expected ) : [EOL] snap_store . _check_current_snap_is_not_released ( current_revision , current_version , latest_released_revision , latest_released_version ) [EOL] else : [EOL] snap_store . _check_current_snap_is_not_released ( current_revision , current_version , latest_released_revision , latest_released_version ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , { [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] ] } , } , False , ( [number] , [string] ) , ) , ( [string] , { [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] ] } , [number] : { [string] : [string] , [string] : [ ] } , } , False , ( [number] , [string] ) , ) , ( [string] , { [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ ] } , } , True , ValueError , ) , ( [string] , { [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] ] } , } , True , ValueError , ) , ( [string] , { [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] ] } , [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] , [string] , [string] ] } , } , False , ( [number] , [string] ) , ) , ( [string] , { [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] ] } , [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] , [string] ] } , } , False , ( [number] , [string] ) , ) , ( [string] , { [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] ] } , [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] , [string] ] } , } , False , ( [number] , [string] ) , ) , ( [string] , { [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] ] } , [number] : { [string] : [string] , [string] : [ ] } , [number] : { [string] : [string] , [string] : [ [string] ] } , [number] : { [string] : [string] , [string] : [ [string] , [string] , [string] ] } , } , False , ( [number] , [string] ) , ) , ) , ) def test_pick_revision_and_version_of_latest_released_snap ( channel , metadata_per_revision , raises , expected ) : [EOL] if raises : [EOL] with pytest . raises ( expected ) : [EOL] snap_store . _pick_revision_and_version_of_latest_released_snap ( channel , metadata_per_revision ) [EOL] else : [EOL] assert snap_store . _pick_revision_and_version_of_latest_released_snap ( channel , metadata_per_revision ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict , List [EOL] import typing [EOL] import pytest [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] from pushsnapscript . task import get_snap_channel , is_allowed_to_push_to_snap_store [EOL] [EOL] [EOL] def test_get_snap_channel_without_payload_raises ( ) : [EOL] task = { [string] : { } } [EOL] config = { } [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] get_snap_channel ( config , task ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( False , [string] ) , ( False , [string] ) , ( False , [string] ) , ( False , [string] ) , ( False , [string] ) , ( False , [string] ) , ( True , [string] ) ) ) def test_get_snap_channel_dep ( raises , channel ) : [EOL] task = { [string] : [ ] , [string] : { [string] : channel } } [EOL] config = { [string] : False } [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] get_snap_channel ( config , task ) [EOL] else : [EOL] assert get_snap_channel ( config , task ) == channel [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( False , [ [string] ] , [string] ) , ( False , [ [string] ] , [string] ) , ( False , [ [string] ] , [string] ) , ( False , [ [string] ] , [string] ) , ( False , [ [string] ] , [string] ) , ( False , [ [string] , [string] ] , [string] ) , ( False , [ [string] , [string] ] , [string] ) , ( True , [ [string] ] , [string] ) , ( True , [ [string] ] , [string] ) , ) , ) def test_get_snap_channel_prod ( raises , scopes , channel ) : [EOL] task = { [string] : scopes , [string] : { [string] : channel } } [EOL] config = { [string] : True } [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] get_snap_channel ( config , task ) [EOL] else : [EOL] assert get_snap_channel ( config , task ) == channel [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , True , True ) , ( [string] , True , True ) , ( [string] , True , True ) , ( [string] , True , True ) , ( [string] , False , False ) , ( [string] , False , False ) , ( [string] , False , False ) , ( [string] , False , False ) , ( [string] , True , False ) , ( [string] , False , False ) , ) , ) def test_is_allowed_to_push_to_snap_store ( channel , push_to_store , expected ) : [EOL] config = { [string] : push_to_store } [EOL] assert is_allowed_to_push_to_snap_store ( config , channel ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import pytest [EOL] from scriptworker import artifacts [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] from pushsnapscript . artifacts import get_snap_file_path [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( False , ( { [string] : [ [string] ] } , { } ) , [string] ) , ( False , ( { [string] : [ [string] , [string] ] } , { } ) , [string] ) , ( False , ( { [string] : [ [string] ] , [string] : [string] } , { } ) , [string] ) , ( True , ( { } , { [string] : [ [string] ] } ) , None ) , ( True , ( { [string] : [ [string] ] } , { } ) , None ) , ( True , ( { [string] : [ [string] ] , [string] : [ [string] ] } , { } ) , None ) , ) , ) def test_get_snap_file_path ( monkeypatch , raises , returned , expected ) : [EOL] context = None [EOL] [EOL] monkeypatch . setattr ( artifacts , [string] , lambda _ : returned ) [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] get_snap_file_path ( context ) [EOL] else : [EOL] assert get_snap_file_path ( context ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Union , Any , Dict , List [EOL] import unittest [EOL] import typing [EOL] import json [EOL] import os [EOL] import tempfile [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] from scriptworker . utils import makedirs [EOL] [EOL] from pushsnapscript import snap_store [EOL] from pushsnapscript . script import main [EOL] [EOL] _ALL_REVISIONS_ABSTRACT = [ { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [string] , [string] : [number] , } , { [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [string] , [string] : [number] , } , { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , [string] : [string] , [string] : [number] , } , { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } ] , [string] : [string] , [string] : [number] , } , { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [string] , [string] : [number] , } , { [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } ] , [string] : [string] , [string] : [number] , } , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [number] ) , ( [string] , [number] ) ) ) def test_script_can_push_snaps_with_credentials ( monkeypatch , channel , expected_revision ) : [EOL] task = { [string] : [ [string] ] , [string] : [ [string] . format ( channel ) ] , [string] : { [string] : channel , [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } ] , } , } [EOL] [EOL] snapcraft_store_client_mock = MagicMock ( ) [EOL] store_mock = MagicMock ( ) [EOL] store_mock . get_snap_revisions . return_value = _ALL_REVISIONS_ABSTRACT [EOL] [EOL] def cpi_get_side_effect ( * args , ** kwargs ) : [EOL] revision = kwargs [ [string] ] [ [string] ] [EOL] cpi_get_mock = MagicMock ( ) [EOL] cpi_get_mock . json . return_value = { [string] : [string] . format ( revision ) } [EOL] return cpi_get_mock [EOL] [EOL] store_mock . cpi . get . side_effect = cpi_get_side_effect [EOL] [EOL] monkeypatch . setattr ( snap_store , [string] , lambda : store_mock ) [EOL] monkeypatch . setattr ( snap_store , [string] , lambda * args , ** kwargs : [string] . format ( expected_revision ) ) [EOL] [EOL] with tempfile . NamedTemporaryFile ( [string] ) as macaroon_beta , tempfile . NamedTemporaryFile ( [string] ) as macaroon_candidate : [EOL] config = { [string] : True , [string] : { [string] : macaroon_candidate . name , [string] : macaroon_beta . name } } [EOL] [EOL] with tempfile . TemporaryDirectory ( ) as work_dir : [EOL] config [ [string] ] = work_dir [EOL] [EOL] with open ( os . path . join ( work_dir , [string] ) , [string] ) as task_file : [EOL] json . dump ( task , task_file ) [EOL] [EOL] snap_artifact_dir = os . path . join ( work_dir , [string] ) [EOL] makedirs ( snap_artifact_dir ) [EOL] snap_artifact_path = os . path . join ( snap_artifact_dir , [string] ) [EOL] with open ( snap_artifact_path , [string] ) as snap_file : [EOL] snap_file . write ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with tempfile . NamedTemporaryFile ( [string] ) as config_file : [EOL] json . dump ( config , config_file ) [EOL] config_file . seek ( [number] ) [EOL] [EOL] monkeypatch . setattr ( snap_store , [string] , snapcraft_store_client_mock ) [EOL] main ( config_path = config_file . name ) [EOL] [EOL] snapcraft_store_client_mock . push . assert_called_once_with ( snap_filename = snap_artifact_path ) [EOL] store_mock . release . assert_called_once_with ( snap_name = [string] , revision = expected_revision , channels = [ channel ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] [EOL] class AlreadyLatestError ( TaskVerificationError ) : [EOL] def __init__ ( self , latest_released_version , latest_released_revision ) : [EOL] super ( AlreadyLatestError , self ) . __init__ ( [string] . format ( latest_released_version , latest_released_revision ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from scriptworker import artifacts [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] from scriptworker . utils import get_single_item_from_sequence [EOL] [EOL] [EOL] def get_snap_file_path ( context ) : [EOL] artifacts_per_task_id , _ = artifacts . get_upstream_artifacts_full_paths_per_task_id ( context ) [EOL] [EOL] all_artifacts = [ artifact for artifacts in artifacts_per_task_id . values ( ) for artifact in artifacts ] [EOL] [EOL] return get_single_item_from_sequence ( all_artifacts , condition = lambda artifact : artifact . endswith ( [string] ) , ErrorClass = TaskVerificationError , no_item_error_message = [string] , too_many_item_error_message = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Literal , Any , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] SNAP_SCOPES_PREFIX = [string] [EOL] [EOL] _CHANNELS_AUTHORIZED_TO_REACH_SNAP_STORE = ( [string] , [string] , [string] , [string] ) [EOL] ALLOWED_CHANNELS = ( [string] , * _CHANNELS_AUTHORIZED_TO_REACH_SNAP_STORE ) [EOL] [EOL] [EOL] def get_snap_channel ( config , task ) : [EOL] payload = task [ [string] ] [EOL] if [string] not in payload : [EOL] raise TaskVerificationError ( f" [string] { payload }" ) [EOL] [EOL] channel = payload [ [string] ] [EOL] scope = SNAP_SCOPES_PREFIX + channel . split ( [string] ) [ [number] ] [EOL] if config [ [string] ] and scope not in task [ [string] ] : [EOL] raise TaskVerificationError ( f" [string] { channel } [string] { scope }" ) [EOL] [EOL] if channel not in ALLOWED_CHANNELS : [EOL] raise TaskVerificationError ( [string] . format ( channel , ALLOWED_CHANNELS ) ) [EOL] [EOL] return channel [EOL] [EOL] [EOL] def is_allowed_to_push_to_snap_store ( config , channel ) : [EOL] return config [ [string] ] and channel in _CHANNELS_AUTHORIZED_TO_REACH_SNAP_STORE [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Union , Any , Dict , Tuple [EOL] import typing [EOL] import logging [EOL] import contextlib [EOL] import logging [EOL] [EOL] from mozilla_version . gecko import GeckoSnapVersion [EOL] from mozilla_version . version import VersionType [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] from scriptworker . utils import get_hash , get_single_item_from_sequence [EOL] from snapcraft import _store as snapcraft_store_client [comment] [EOL] from snapcraft . storeapi import StoreClient [EOL] from snapcraft . storeapi . constants import DEFAULT_SERIES [EOL] from snapcraft . storeapi . errors import StoreReviewError [EOL] [EOL] from pushsnapscript import task [EOL] from pushsnapscript . exceptions import AlreadyLatestError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] _VERSION_TYPES_PER_CHANNEL = { [string] : ( VersionType . BETA , ) , [string] : ( VersionType . BETA , VersionType . RELEASE ) , [string] : ( VersionType . RELEASE , ) , [string] : ( VersionType . RELEASE , ) , [string] : ( VersionType . ESR , ) , [string] : ( VersionType . ESR , ) , } [EOL] [EOL] [comment] [EOL] _SNAP_NAME_ON_STORE = [string] [EOL] [EOL] [EOL] def push ( context , snap_file_path , channel ) : [EOL] [docstring] [EOL] if not task . is_allowed_to_push_to_snap_store ( context . config , channel = channel ) : [EOL] log . warning ( [string] ) [EOL] [comment] [EOL] return [EOL] [EOL] macaroon_location = context . config [ [string] ] [ channel . split ( [string] , [number] ) [ [number] ] ] [EOL] with _store_session ( macaroon_location ) as store : [EOL] try : [EOL] log . debug ( [string] . format ( snap_file_path ) ) [EOL] [comment] [EOL] snapcraft_store_client . push ( snap_filename = snap_file_path ) [EOL] except StoreReviewError as e : [EOL] if [string] in e . additional : [EOL] log . warning ( e ) [EOL] else : [EOL] raise [EOL] [EOL] _release_if_needed ( store , channel , snap_file_path ) [EOL] [EOL] [EOL] @ contextlib . contextmanager def _store_session ( macaroon_location ) : [EOL] store = StoreClient ( ) [EOL] [EOL] with open ( macaroon_location ) as macaroon : [EOL] log . debug ( [string] . format ( macaroon . name ) ) [EOL] [comment] [EOL] [comment] [EOL] store . login ( email = [string] , password = [string] , config_fd = macaroon ) [EOL] [EOL] log . info ( [string] ) [EOL] try : [EOL] yield store [EOL] finally : [EOL] log . debug ( [string] ) [EOL] store . logout ( ) [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] def _release_if_needed ( store , channel , snap_file_path ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] all_revisions = _list_all_revisions ( store ) [EOL] metadata_per_revision = _pluck_metadata ( all_revisions ) [EOL] metadata_per_revision = _filter_versions_that_are_not_the_same_type ( metadata_per_revision , channel ) [EOL] metadata_per_revision = _populate_sha3_384 ( store , metadata_per_revision ) [EOL] current_sha3_384 = get_hash ( snap_file_path , hash_alg = [string] ) [EOL] current_snap_revision , current_snap_version = _find_revision_and_version_of_current_snap ( metadata_per_revision , current_sha3_384 ) [EOL] latest_released_revision , latest_released_version = _pick_revision_and_version_of_latest_released_snap ( channel , metadata_per_revision ) [EOL] [EOL] try : [EOL] _check_current_snap_is_not_released ( current_snap_revision , current_snap_version , latest_released_revision , latest_released_version ) [EOL] except AlreadyLatestError as e : [EOL] [comment] [EOL] [comment] [EOL] log . warning ( e ) [EOL] return [EOL] [EOL] release_kwargs = { [string] : _SNAP_NAME_ON_STORE , [string] : current_snap_revision , [string] : [ channel ] } [EOL] [EOL] log . debug ( [string] . format ( snap_file_path ) ) [EOL] store . release ( ** release_kwargs ) [EOL] [EOL] [EOL] def _list_all_revisions ( store ) : [EOL] return store . get_snap_revisions ( _SNAP_NAME_ON_STORE ) [EOL] [EOL] [EOL] def _pluck_metadata ( snap_revisions ) : [EOL] return { revision [ [string] ] : { [string] : GeckoSnapVersion . parse ( revision [ [string] ] ) , [string] : revision . get ( [string] , [ ] ) } for revision in snap_revisions } [EOL] [EOL] [EOL] def _filter_versions_that_are_not_the_same_type ( metadata_per_revision , channel ) : [EOL] expected_version_types = _VERSION_TYPES_PER_CHANNEL [ channel ] [EOL] [EOL] return { revision : revision_metadata for revision , revision_metadata in metadata_per_revision . items ( ) if revision_metadata [ [string] ] . version_type in expected_version_types } [EOL] [EOL] [EOL] def _populate_sha3_384 ( store , metadata_per_revision ) : [EOL] return { revision : { ** revision_metadata , [string] : _get_from_sha3_384_from_revision ( store , revision ) } for revision , revision_metadata in metadata_per_revision . items ( ) if revision > [number] } [EOL] [EOL] [EOL] def _get_from_sha3_384_from_revision ( store , revision ) : [EOL] [comment] [EOL] headers = store . cpi . get_default_headers ( ) [EOL] headers . update ( { [string] : [string] , [string] : DEFAULT_SERIES } ) [EOL] params = { [string] : [string] , [string] : revision } [EOL] url = [string] . format ( _SNAP_NAME_ON_STORE ) [EOL] resp = store . cpi . get ( url , headers = headers , params = params ) [EOL] return resp . json ( ) [ [string] ] [EOL] [EOL] [EOL] def _find_revision_and_version_of_current_snap ( metadata_per_revision , current_sha3_384 ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] item = get_single_item_from_sequence ( metadata_per_revision . items ( ) , lambda item : item [ [number] ] [ [string] ] == current_sha3_384 , ErrorClass = ValueError , no_item_error_message = [string] . format ( current_sha3_384 ) , too_many_item_error_message = [string] . format ( current_sha3_384 ) , ) [EOL] revision = item [ [number] ] [EOL] version = item [ [number] ] [ [string] ] [EOL] log . debug ( [string] . format ( version , revision ) ) [EOL] return revision , version [EOL] [EOL] [EOL] def _check_current_snap_is_not_released ( current_revision , current_version , latest_released_revision , latest_released_version ) : [EOL] if latest_released_version == current_version : [EOL] if latest_released_revision == current_revision : [EOL] raise AlreadyLatestError ( latest_released_version , latest_released_revision ) [EOL] else : [EOL] raise TaskVerificationError ( [string] [string] . format ( latest_released_version , latest_released_revision , current_revision ) ) [EOL] elif latest_released_version > current_version : [EOL] [comment] [EOL] raise TaskVerificationError ( [string] . format ( current_version , latest_released_version ) ) [EOL] [EOL] log . debug ( [string] . format ( current_version , latest_released_version ) ) [EOL] [EOL] [EOL] def _pick_revision_and_version_of_latest_released_snap ( channel , metadata_per_revision ) : [EOL] item = get_single_item_from_sequence ( metadata_per_revision . items ( ) , lambda item : channel in item [ [number] ] [ [string] ] , ErrorClass = ValueError , no_item_error_message = [string] . format ( channel ) , too_many_item_error_message = [string] . format ( channel ) , ) [EOL] revision = item [ [number] ] [EOL] version = item [ [number] ] [ [string] ] [EOL] log . debug ( [string] . format ( version , revision ) ) [EOL] return revision , version [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] from scriptworker import client [EOL] [EOL] from pushflatpakscript import artifacts , flathub , task [EOL] from pushflatpakscript . script import _log_warning_forewords , async_main [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_main ( monkeypatch ) : [EOL] function_call_counter = ( n for n in range ( [number] , [number] ) ) [EOL] [EOL] context = MagicMock ( ) [EOL] context . config = { [string] : True } [EOL] monkeypatch . setattr ( client , [string] , lambda _ : { } ) [EOL] monkeypatch . setattr ( artifacts , [string] , lambda _ : [string] ) [EOL] monkeypatch . setattr ( task , [string] , lambda config , channel : [string] ) [EOL] [EOL] def assert_push ( context_ , file_ , channel ) : [EOL] assert context_ == context [EOL] assert file_ == [string] [EOL] assert channel == [string] [EOL] next ( function_call_counter ) [EOL] [EOL] monkeypatch . setattr ( flathub , [string] , assert_push ) [EOL] [EOL] await async_main ( context ) [EOL] [EOL] assert next ( function_call_counter ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_log_warning_forewords ( caplog , monkeypatch , is_allowed ) : [EOL] monkeypatch . setattr ( task , [string] , lambda config , channel : is_allowed ) [EOL] _log_warning_forewords ( { } , channel = [string] ) [EOL] [EOL] if is_allowed : [EOL] assert not caplog . records [EOL] else : [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert [string] in caplog . text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
TAR_MAX_SIZE_IN_MB = [number] [EOL]	$builtins.int$ 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] [EOL] from scriptworker_client . aio import retry_async [EOL] from scriptworker_client . client import sync_main [EOL] [EOL] from treescript . exceptions import CheckoutError , PushError , TreeScriptError [EOL] from treescript . l10n import l10n_bump [EOL] from treescript . mercurial import checkout_repo , do_tagging , log_mercurial_version , log_outgoing , push , strip_outgoing , validate_robustcheckout_works [EOL] from treescript . merges import do_merge [EOL] from treescript . task import get_source_repo , should_push , task_action_types [EOL] from treescript . versionmanip import bump_version [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def perform_merge_actions ( config , task , actions , repo_path ) : [EOL] [docstring] [EOL] log . info ( [string] ) [EOL] push_activity = await do_merge ( config , task , repo_path ) [EOL] [EOL] if should_push ( task , actions ) and push_activity : [EOL] log . info ( [string] , len ( push_activity ) ) [EOL] for target_repo , revision in push_activity : [EOL] log . info ( [string] , revision , target_repo ) [EOL] await push ( config , task , repo_path , target_repo = target_repo , revision = revision ) [EOL] [EOL] [EOL] async def do_actions ( config , task , actions , repo_path ) : [EOL] [docstring] [EOL] await checkout_repo ( config , task , repo_path ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in actions : [EOL] await perform_merge_actions ( config , task , actions , repo_path ) [EOL] return [EOL] [EOL] num_changes = [number] [EOL] if [string] in actions : [EOL] num_changes += await do_tagging ( config , task , repo_path ) [EOL] if [string] in actions : [EOL] num_changes += await bump_version ( config , task , repo_path ) [EOL] if [string] in actions : [EOL] num_changes += await l10n_bump ( config , task , repo_path ) [EOL] [EOL] num_outgoing = await log_outgoing ( config , task , repo_path ) [EOL] if num_outgoing != num_changes : [EOL] raise TreeScriptError ( [string] [string] . format ( num_outgoing , num_changes ) ) [EOL] if should_push ( task , actions ) : [EOL] if num_changes : [EOL] await push ( config , task , repo_path , target_repo = get_source_repo ( task ) ) [EOL] else : [EOL] log . info ( [string] ) [EOL] await strip_outgoing ( config , task , repo_path ) [EOL] [EOL] [EOL] [comment] [EOL] async def async_main ( config , task ) : [EOL] [docstring] [EOL] work_dir = config [ [string] ] [EOL] repo_path = os . path . join ( work_dir , [string] ) [EOL] actions_to_perform = task_action_types ( config , task ) [EOL] await log_mercurial_version ( config ) [EOL] if not await validate_robustcheckout_works ( config ) : [EOL] raise TreeScriptError ( [string] ) [EOL] await retry_async ( do_actions , args = ( config , task , actions_to_perform , repo_path ) , retry_exceptions = ( CheckoutError , PushError ) ) [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] def get_default_config ( base_dir = None ) : [EOL] [docstring] [EOL] base_dir = base_dir or os . path . dirname ( os . getcwd ( ) ) [EOL] default_config = { [string] : os . path . join ( base_dir , [string] ) , [string] : [string] , [string] : os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) , } [EOL] return default_config [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] return sync_main ( async_main , default_config = get_default_config ( ) ) [EOL] [EOL] [EOL] __name__ == [string] and main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import treescript [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] import shutil [EOL] import string [EOL] [EOL] import attr [EOL] from scriptworker_client . utils import makedirs [EOL] [EOL] from treescript . mercurial import get_revision , run_hg_command [EOL] from treescript . task import get_merge_config [EOL] from treescript . versionmanip import do_bump_version , get_version [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class BashFormatter ( string . Formatter ) : [EOL] [docstring] [EOL] [EOL] def get_value ( self , key , args , kwds ) : [EOL] [docstring] [EOL] if isinstance ( key , str ) : [EOL] return kwds . get ( key , [string] + key + [string] ) [EOL] else : [EOL] return string . Formatter ( ) . get_value ( key , args , kwds ) [EOL] [EOL] [EOL] def replace ( file_name , from_ , to_ ) : [EOL] [docstring] [EOL] log . info ( [string] , from_ , to_ , file_name ) [EOL] with open ( file_name ) as f : [EOL] text = f . read ( ) [EOL] new_text = text . replace ( from_ , to_ ) [EOL] if text == new_text : [EOL] raise ValueError ( f"{ file_name } [string] { from_ }" ) [EOL] with open ( file_name , [string] ) as f : [EOL] f . write ( new_text ) [EOL] [EOL] [EOL] def touch_clobber_file ( config , repo_path ) : [EOL] [docstring] [EOL] if not config [ [string] ] : [EOL] log . info ( [string] ) [EOL] else : [EOL] log . info ( [string] ) [EOL] clobber_file = os . path . join ( repo_path , config [ [string] ] ) [EOL] with open ( clobber_file ) as f : [EOL] contents = f . read ( ) [EOL] new_contents = [string] [EOL] for line in contents . splitlines ( ) : [EOL] line = line . strip ( ) [EOL] if line . startswith ( [string] ) or line == [string] : [EOL] new_contents += f"{ line } [string] " [EOL] new_contents += [string] [EOL] with open ( clobber_file , [string] ) as f : [EOL] f . write ( new_contents ) [EOL] [EOL] [EOL] def create_new_version ( version_config , repo_path ) : [EOL] [docstring] [EOL] version = get_version ( version_config [ [string] ] , repo_path ) [EOL] if version_config . get ( [string] ) == [string] : [EOL] version = version . bump ( [string] ) [EOL] elif version_config . get ( [string] ) == [string] : [EOL] version = version . bump ( [string] ) [EOL] if [string] in version_config : [comment] [EOL] version = attr . evolve ( version , is_esr = False , beta_number = None , is_nightly = False ) [EOL] version = f"{ version }{ version_config [ [string] ] }" [EOL] else : [EOL] version = f"{ version }" [EOL] log . info ( [string] , version ) [EOL] return version [EOL] [EOL] [EOL] async def apply_rebranding ( config , repo_path , merge_config ) : [EOL] [docstring] [EOL] log . info ( [string] , merge_config . get ( [string] ) , merge_config . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] version = get_version ( core_version_file ( merge_config ) , repo_path ) [EOL] [comment] [EOL] format_options = { [string] : version . major_number , [string] : version . major_number + [number] , [string] : version . major_number + [number] , [string] : version . major_number + [number] , } [EOL] [EOL] if merge_config . get ( [string] ) : [EOL] for version_config in merge_config [ [string] ] : [EOL] await do_bump_version ( config , repo_path , [ version_config [ [string] ] ] , create_new_version ( version_config , repo_path ) ) [EOL] [EOL] for f in merge_config . get ( [string] , list ( ) ) : [EOL] shutil . copyfile ( os . path . join ( repo_path , f [ [number] ] ) , os . path . join ( repo_path , f [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] fmt = BashFormatter ( ) [EOL] for f , from_ , to in merge_config . get ( [string] , list ( ) ) : [EOL] from_ = fmt . format ( from_ , ** format_options ) [EOL] to = fmt . format ( to , ** format_options ) [EOL] replace ( os . path . join ( repo_path , f ) , from_ , to ) [EOL] [EOL] touch_clobber_file ( config , repo_path ) [EOL] [EOL] [EOL] async def preserve_tags ( config , repo_path , to_branch ) : [EOL] [docstring] [EOL] tag_diff = await run_hg_command ( config , [string] , [string] , to_branch , os . path . join ( repo_path , [string] ) , [string] , return_output = True , repo_path = repo_path ) [EOL] await run_hg_command ( config , [string] , [string] , to_branch , os . path . join ( repo_path , [string] ) , repo_path = repo_path ) [EOL] with open ( os . path . join ( repo_path , [string] ) , [string] ) as fh : [EOL] [comment] [EOL] for line in tag_diff . splitlines ( ) [ [number] : ] : [EOL] [comment] [EOL] if not line . startswith ( [string] ) : [EOL] continue [EOL] line = line . lstrip ( [string] ) [EOL] changeset , _ = line . split ( ) [EOL] [comment] [EOL] if len ( changeset ) != [number] : [EOL] continue [EOL] fh . write ( f"{ line } [string] " ) [EOL] status_out = await run_hg_command ( config , [string] , os . path . join ( repo_path , [string] ) , return_output = True , repo_path = repo_path ) [EOL] if status_out : [EOL] await run_hg_command ( config , [string] , [string] , [string] , repo_path = repo_path ) [EOL] [EOL] [EOL] def core_version_file ( merge_config ) : [EOL] [docstring] [EOL] return merge_config . get ( [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] async def do_merge ( config , task , repo_path ) : [EOL] [docstring] [EOL] merge_config = get_merge_config ( task ) [EOL] [EOL] upstream_repo = config [ [string] ] [EOL] from_branch = merge_config . get ( [string] ) [EOL] to_branch = merge_config . get ( [string] ) [EOL] [EOL] await run_hg_command ( config , [string] , upstream_repo , repo_path = repo_path ) [EOL] [EOL] [comment] [EOL] await run_hg_command ( config , [string] , [string] , to_branch , repo_path = repo_path ) [EOL] to_fx_major_version = get_version ( core_version_file ( merge_config ) , repo_path ) . major_number [EOL] base_to_rev = await get_revision ( config , repo_path , branch = to_branch ) [EOL] [EOL] if from_branch : [EOL] await run_hg_command ( config , [string] , [string] , from_branch , repo_path = repo_path ) [EOL] base_from_rev = await get_revision ( config , repo_path , branch = from_branch ) [EOL] [EOL] base_tag = merge_config . get ( [string] ) [EOL] if base_tag : [EOL] base_tag = base_tag . format ( major_version = get_version ( core_version_file ( merge_config ) , repo_path ) . major_number ) [EOL] tag_message = f" [string] { base_from_rev } [string] { base_tag } [string] " [EOL] await run_hg_command ( config , [string] , [string] , tag_message , [string] , base_from_rev , [string] , base_tag , repo_path = repo_path ) [EOL] [EOL] tagged_from_rev = await get_revision ( config , repo_path , branch = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if merge_config . get ( [string] , False ) : [EOL] await run_hg_command ( config , [string] , tagged_from_rev , base_to_rev , repo_path = repo_path ) [EOL] await run_hg_command ( config , [string] , [string] , [string] . format ( tagged_from_rev , base_to_rev ) , repo_path = repo_path , ) [EOL] await preserve_tags ( config , repo_path , to_branch ) [EOL] [EOL] end_tag = merge_config . get ( [string] ) [comment] [EOL] if end_tag : [EOL] end_tag = end_tag . format ( major_version = to_fx_major_version ) [EOL] tag_message = f" [string] { base_to_rev } [string] { end_tag } [string] " [EOL] await run_hg_command ( config , [string] , [string] , tag_message , [string] , base_to_rev , [string] , end_tag , repo_path = repo_path ) [EOL] [EOL] await apply_rebranding ( config , repo_path , merge_config ) [EOL] [EOL] diff_output = await run_hg_command ( config , [string] , repo_path = repo_path , return_output = True ) [EOL] path = os . path . join ( config [ [string] ] , [string] , [string] , [string] . format ( to_branch ) ) [EOL] makedirs ( os . path . dirname ( path ) ) [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( diff_output ) [EOL] [EOL] await run_hg_command ( config , [string] , [string] , [string] , repo_path = repo_path ) [EOL] push_revision_to = await get_revision ( config , repo_path , branch = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] desired_pushes = list ( ) [EOL] if merge_config . get ( [string] ) : [EOL] desired_pushes . append ( ( merge_config [ [string] ] , tagged_from_rev ) ) [EOL] if merge_config . get ( [string] ) : [EOL] desired_pushes . append ( ( merge_config [ [string] ] , push_revision_to ) ) [EOL] return desired_pushes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import scriptworker_client . exceptions as sce [EOL] [EOL] [EOL] class TaskVerificationError ( sce . TaskVerificationError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TreeScriptError ( sce . TaskError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class FailedSubprocess ( TreeScriptError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CheckoutError ( TreeScriptError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class PushError ( TreeScriptError ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Set [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from treescript . exceptions import TaskVerificationError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] VALID_ACTIONS = { [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] DONTBUILD_MSG = [string] [EOL] CLOSED_TREE_MSG = [string] [EOL] [EOL] [EOL] [comment] [EOL] def get_metadata_source_repo ( task ) : [EOL] [docstring] [EOL] source = task . get ( [string] , { } ) . get ( [string] , None ) [EOL] if not source : [EOL] raise TaskVerificationError ( [string] ) [EOL] if not source . startswith ( [string] ) : [EOL] raise TaskVerificationError ( [string] ) [EOL] parts = source . split ( [string] ) [EOL] if len ( parts ) < [number] : [EOL] raise TaskVerificationError ( [string] ) [EOL] return parts [ [number] ] [EOL] [EOL] [EOL] def get_source_repo ( task ) : [EOL] [docstring] [EOL] if task [ [string] ] . get ( [string] ) : [EOL] return task [ [string] ] [ [string] ] [EOL] return get_metadata_source_repo ( task ) [EOL] [EOL] [EOL] def get_short_source_repo ( task ) : [EOL] [docstring] [EOL] source_repo = get_source_repo ( task ) [EOL] parts = source_repo . split ( [string] ) [EOL] return parts [ - [number] ] [EOL] [EOL] [EOL] [comment] [EOL] def get_branch ( task , default = None ) : [EOL] [docstring] [EOL] return task . get ( [string] , { } ) . get ( [string] , default ) [EOL] [EOL] [EOL] [comment] [EOL] def get_tag_info ( task ) : [EOL] [docstring] [EOL] tag_info = task . get ( [string] , { } ) . get ( [string] ) [EOL] if not tag_info : [EOL] raise TaskVerificationError ( [string] ) [EOL] return tag_info [EOL] [EOL] [EOL] [comment] [EOL] def get_version_bump_info ( task ) : [EOL] [docstring] [EOL] version_info = task . get ( [string] , { } ) . get ( [string] ) [EOL] if not version_info : [EOL] raise TaskVerificationError ( [string] ) [EOL] return version_info [EOL] [EOL] [EOL] [comment] [EOL] def get_l10n_bump_info ( task ) : [EOL] [docstring] [EOL] l10n_bump_info = task . get ( [string] , { } ) . get ( [string] ) [EOL] if not l10n_bump_info : [EOL] raise TaskVerificationError ( [string] ) [EOL] return l10n_bump_info [EOL] [EOL] [EOL] [comment] [EOL] def get_dontbuild ( task ) : [EOL] [docstring] [EOL] return task . get ( [string] , { } ) . get ( [string] , False ) [EOL] [EOL] [EOL] [comment] [EOL] def get_ignore_closed_tree ( task ) : [EOL] [docstring] [EOL] return task . get ( [string] , { } ) . get ( [string] , False ) [EOL] [EOL] [EOL] [comment] [EOL] def task_action_types ( config , task ) : [EOL] [docstring] [EOL] actions = set ( task [ [string] ] . get ( [string] , [ ] ) ) [EOL] log . info ( [string] , actions ) [EOL] invalid_actions = actions - VALID_ACTIONS [EOL] if len ( invalid_actions ) > [number] : [EOL] raise TaskVerificationError ( [string] . format ( invalid_actions ) ) [EOL] [EOL] return actions [EOL] [EOL] [EOL] [comment] [EOL] def should_push ( task , actions ) : [EOL] [docstring] [EOL] dry_run = task [ [string] ] . get ( [string] , False ) [EOL] push = task [ [string] ] . get ( [string] ) [EOL] push_action = [string] in actions [EOL] if dry_run : [EOL] log . info ( [string] ) [EOL] return False [EOL] elif push is not None : [EOL] if not push and push_action : [EOL] log . warning ( [string] ) [EOL] return push [EOL] elif push_action : [EOL] log . warning ( [string] ) [EOL] return True [EOL] else : [EOL] log . info ( [string] ) [EOL] return False [EOL] [EOL] [EOL] [comment] [EOL] def get_ssh_user ( task ) : [EOL] [docstring] [EOL] return task . get ( [string] , { } ) . get ( [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] def get_merge_config ( task ) : [EOL] [docstring] [EOL] try : [EOL] return task . get ( [string] , { } ) [ [string] ] [EOL] except KeyError : [EOL] raise TaskVerificationError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Set , Dict , List [EOL] import logging [EOL] import typing [EOL] import asyncio [EOL] [docstring] [EOL] import asyncio [EOL] import json [EOL] import logging [EOL] import os [EOL] import pprint [EOL] import tempfile [EOL] from copy import deepcopy [EOL] [EOL] from scriptworker_client . aio import download_file , retry_async , semaphore_wrapper [EOL] from scriptworker_client . exceptions import DownloadError [EOL] from scriptworker_client . utils import load_json_or_yaml [EOL] [EOL] from treescript . mercurial import run_hg_command [EOL] from treescript . task import CLOSED_TREE_MSG , DONTBUILD_MSG , get_dontbuild , get_ignore_closed_tree , get_l10n_bump_info , get_short_source_repo [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] def build_locale_map ( old_contents , new_contents ) : [EOL] [docstring] [EOL] locale_map = { } [EOL] for key in old_contents : [EOL] if key not in new_contents : [EOL] locale_map [ key ] = [string] [EOL] for k , v in new_contents . items ( ) : [EOL] if old_contents . get ( k , { } ) . get ( [string] ) != v [ [string] ] : [EOL] locale_map [ k ] = v [ [string] ] [EOL] elif old_contents . get ( k , { } ) . get ( [string] ) != v [ [string] ] : [EOL] locale_map [ k ] = v [ [string] ] [EOL] return locale_map [EOL] [EOL] [EOL] [comment] [EOL] def build_platform_dict ( bump_config , repo_path ) : [EOL] [docstring] [EOL] platform_dict = { } [EOL] ignore_config = bump_config . get ( [string] , { } ) [EOL] for platform_config in bump_config [ [string] ] : [EOL] path = os . path . join ( repo_path , platform_config [ [string] ] ) [EOL] log . info ( [string] , path , platform_config [ [string] ] ) [EOL] with open ( path , [string] ) as fh : [EOL] contents = fh . read ( ) [EOL] for locale in contents . splitlines ( ) : [EOL] [comment] [EOL] if platform_config . get ( [string] ) == [string] : [EOL] locale = locale . split ( [string] ) [ [number] ] [EOL] if locale in ( [string] , ) : [EOL] continue [EOL] existing_platforms = set ( platform_dict . get ( locale , { } ) . get ( [string] , [ ] ) ) [EOL] platforms = set ( platform_config [ [string] ] ) [EOL] ignore_platforms = set ( ignore_config . get ( locale , [ ] ) ) [EOL] platforms = ( platforms | existing_platforms ) - ignore_platforms [EOL] platform_dict [ locale ] = { [string] : sorted ( list ( platforms ) ) } [EOL] log . info ( [string] % pprint . pformat ( platform_dict ) ) [EOL] return platform_dict [EOL] [EOL] [EOL] [comment] [EOL] async def get_latest_revision ( locale , url ) : [EOL] [docstring] [EOL] url = url % { [string] : locale } [EOL] with tempfile . NamedTemporaryFile ( ) as fp : [EOL] path = fp . name [EOL] await retry_async ( download_file , args = ( url , path ) , retry_exceptions = ( DownloadError , ) ) [EOL] revision_info = load_json_or_yaml ( path , is_path = True ) [EOL] last_push_id = revision_info [ [string] ] [EOL] revision = revision_info [ [string] ] [ str ( last_push_id ) ] [ [string] ] [ [number] ] [EOL] log . info ( f" [string] { locale } [string] { revision }" ) [EOL] return ( locale , revision ) [EOL] [EOL] [EOL] [comment] [EOL] async def build_revision_dict ( bump_config , repo_path , old_contents ) : [EOL] [docstring] [EOL] log . info ( [string] ) [EOL] platform_dict = build_platform_dict ( bump_config , repo_path ) [EOL] revision_dict = { } [EOL] if bump_config . get ( [string] ) : [EOL] semaphore = asyncio . Semaphore ( [number] ) [EOL] tasks = [ ] [EOL] for locale , value in platform_dict . items ( ) : [EOL] if old_contents . get ( locale , { } ) . get ( [string] ) : [EOL] value [ [string] ] = old_contents [ locale ] [ [string] ] [EOL] value [ [string] ] = old_contents [ locale ] [ [string] ] [EOL] else : [EOL] tasks . append ( asyncio . create_task ( semaphore_wrapper ( semaphore , get_latest_revision ( locale , bump_config [ [string] ] ) ) ) ) [EOL] value [ [string] ] = False [EOL] revision_dict [ locale ] = value [EOL] await asyncio . gather ( * tasks ) [EOL] for task in tasks : [EOL] ( locale , revision ) = task . result ( ) [EOL] revision_dict [ locale ] [ [string] ] = revision [EOL] else : [EOL] for k , v in platform_dict . items ( ) : [EOL] v [ [string] ] = [string] [EOL] revision_dict [ k ] = v [EOL] log . info ( [string] % pprint . pformat ( revision_dict ) ) [EOL] return revision_dict [EOL] [EOL] [EOL] [comment] [EOL] def build_commit_message ( name , locale_map , dontbuild = False , ignore_closed_tree = False ) : [EOL] [docstring] [EOL] comments = [string] [EOL] approval_str = [string] [EOL] for locale , revision in sorted ( locale_map . items ( ) ) : [EOL] comments += [string] % ( locale , revision ) [EOL] if dontbuild : [EOL] approval_str += DONTBUILD_MSG [EOL] if ignore_closed_tree : [EOL] approval_str += CLOSED_TREE_MSG [EOL] message = [string] % ( name , approval_str ) [EOL] message += comments [EOL] return message [EOL] [EOL] [EOL] [comment] [EOL] async def check_treestatus ( config , task ) : [EOL] [docstring] [EOL] tree = get_short_source_repo ( task ) [EOL] url = [string] % ( config [ [string] ] , tree ) [EOL] path = os . path . join ( config [ [string] ] , [string] ) [EOL] await retry_async ( download_file , args = ( url , path ) , retry_exceptions = ( DownloadError , ) ) [EOL] [EOL] treestatus = load_json_or_yaml ( path , is_path = True ) [EOL] if treestatus [ [string] ] [ [string] ] != [string] : [EOL] log . info ( [string] , repr ( treestatus [ [string] ] [ [string] ] ) ) [EOL] return True [EOL] return False [EOL] [EOL] [EOL] [comment] [EOL] async def l10n_bump ( config , task , repo_path ) : [EOL] [docstring] [EOL] log . info ( [string] ) [EOL] [EOL] ignore_closed_tree = get_ignore_closed_tree ( task ) [EOL] if not ignore_closed_tree : [EOL] if not await check_treestatus ( config , task ) : [EOL] log . info ( [string] ) [EOL] return [number] [EOL] [EOL] dontbuild = get_dontbuild ( task ) [EOL] l10n_bump_info = get_l10n_bump_info ( task ) [EOL] changes = [number] [EOL] [EOL] for bump_config in l10n_bump_info : [EOL] path = os . path . join ( repo_path , bump_config [ [string] ] ) [EOL] old_contents = load_json_or_yaml ( path , is_path = True ) [EOL] new_contents = await build_revision_dict ( bump_config , repo_path , deepcopy ( old_contents ) ) [EOL] if old_contents == new_contents : [EOL] continue [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( json . dumps ( new_contents , sort_keys = True , indent = [number] , separators = ( [string] , [string] ) ) ) [EOL] locale_map = build_locale_map ( old_contents , new_contents ) [EOL] message = build_commit_message ( bump_config [ [string] ] , locale_map , dontbuild = dontbuild , ignore_closed_tree = ignore_closed_tree ) [EOL] await run_hg_command ( config , [string] , [string] , message , repo_path = repo_path ) [EOL] changes += [number] [EOL] return changes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] import sys [EOL] import tempfile [EOL] [EOL] from scriptworker_client . utils import load_json_or_yaml , makedirs , run_command [EOL] [EOL] from treescript . exceptions import CheckoutError , FailedSubprocess , PushError [EOL] from treescript . task import DONTBUILD_MSG , get_branch , get_dontbuild , get_source_repo , get_ssh_user , get_tag_info [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] HGRCPATH = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] TAG_MSG = [string] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] def build_hg_command ( config , * args ) : [EOL] [docstring] [EOL] hg = config [ [string] ] [EOL] if not isinstance ( hg , ( list , tuple ) ) : [EOL] hg = [ hg ] [EOL] return hg + [ * args ] [EOL] [EOL] [EOL] [comment] [EOL] def build_hg_environment ( ) : [EOL] [docstring] [EOL] env = os . environ . copy ( ) [EOL] env [ [string] ] = [string] + sys . executable + [string] + [string] [EOL] env [ [string] ] = [string] [EOL] env [ [string] ] = [string] [EOL] env [ [string] ] = [string] [EOL] env [ [string] ] = env [ [string] ] = env [ [string] ] = [string] [EOL] env [ [string] ] = [string] [EOL] [comment] [EOL] [comment] [EOL] for k in ( [string] + [string] ) . split ( ) : [EOL] if k in env : [EOL] del env [ k ] [EOL] return env [EOL] [EOL] [EOL] [comment] [EOL] async def run_hg_command ( config , * args , repo_path = None , exception = FailedSubprocess , return_output = False , ** kwargs ) : [EOL] [docstring] [EOL] command = build_hg_command ( config , * args ) [EOL] env = build_hg_environment ( ) [EOL] return_value = None [EOL] if repo_path : [EOL] command . extend ( [ [string] , repo_path ] ) [EOL] with tempfile . NamedTemporaryFile ( ) as fp : [EOL] log_path = fp . name [EOL] await run_command ( command , env = env , exception = exception , log_path = log_path , ** kwargs ) [EOL] if return_output : [EOL] with open ( log_path , [string] ) as fh : [EOL] return_value = fh . read ( ) [EOL] [EOL] return return_value [EOL] [EOL] [EOL] [comment] [EOL] async def log_mercurial_version ( config ) : [EOL] [docstring] [EOL] await run_hg_command ( config , [string] , [string] ) [EOL] await run_hg_command ( config , [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] async def validate_robustcheckout_works ( config ) : [EOL] [docstring] [EOL] try : [EOL] await run_hg_command ( config , [string] , [string] , [string] ) [EOL] return True [EOL] except FailedSubprocess : [EOL] return False [EOL] [EOL] [EOL] [comment] [EOL] async def checkout_repo ( config , task , repo_path ) : [EOL] [docstring] [EOL] share_base = config [ [string] ] [EOL] upstream_repo = config [ [string] ] [EOL] source_repo = get_source_repo ( task ) [EOL] [comment] [EOL] branch = get_branch ( task , [string] ) [EOL] await run_hg_command ( config , [string] , source_repo , repo_path , [string] , share_base , [string] , upstream_repo , [string] , branch , exception = CheckoutError ) [EOL] [EOL] [EOL] [comment] [EOL] async def get_existing_tags ( config , repo_path ) : [EOL] [docstring] [EOL] existing_tags = { } [EOL] output = load_json_or_yaml ( await run_hg_command ( config , [string] , [string] , repo_path = repo_path , return_output = True ) ) [EOL] for tag_info in output : [EOL] existing_tags [ tag_info [ [string] ] ] = tag_info [ [string] ] [EOL] return existing_tags [EOL] [EOL] [EOL] async def check_tags ( config , tag_info , repo_path ) : [EOL] [docstring] [EOL] tags = [ ] [EOL] existing_tags = await get_existing_tags ( config , repo_path ) [EOL] revision = tag_info [ [string] ] [EOL] for tag in tag_info [ [string] ] : [EOL] if tag in existing_tags : [EOL] if revision == existing_tags [ tag ] : [EOL] log . info ( [string] , tag , revision ) [EOL] continue [EOL] else : [EOL] log . warning ( [string] , tag , revision ) [EOL] tags . append ( tag ) [EOL] return tags [EOL] [EOL] [EOL] async def get_revision ( config , repo_path , branch ) : [EOL] [docstring] [EOL] return await run_hg_command ( config , [string] , [string] , branch , [string] , [string] , return_output = True , repo_path = repo_path ) [EOL] [EOL] [EOL] async def do_tagging ( config , task , repo_path ) : [EOL] [docstring] [EOL] tag_info = get_tag_info ( task ) [EOL] desired_tags = await check_tags ( config , tag_info , repo_path ) [EOL] if not desired_tags : [EOL] log . info ( [string] ) [EOL] return [number] [EOL] desired_rev = tag_info [ [string] ] [EOL] dontbuild = get_dontbuild ( task ) [EOL] source_repo = get_source_repo ( task ) [EOL] commit_msg = TAG_MSG . format ( revision = desired_rev , tags = [string] . join ( desired_tags ) ) [EOL] if dontbuild : [EOL] commit_msg += DONTBUILD_MSG [EOL] log . info ( [string] . format ( revision = desired_rev , repo = source_repo ) ) [EOL] await run_hg_command ( config , [string] , [string] , desired_rev , source_repo , repo_path = repo_path ) [EOL] log . info ( commit_msg ) [EOL] await run_hg_command ( config , [string] , [string] , commit_msg , [string] , desired_rev , [string] , * desired_tags , repo_path = repo_path ) [comment] [EOL] return [number] [EOL] [EOL] [EOL] [comment] [EOL] def _count_outgoing ( output ) : [EOL] [docstring] [EOL] count = [number] [EOL] for line in output . splitlines ( ) : [EOL] if line . startswith ( [string] ) : [EOL] count += [number] [EOL] return count [EOL] [EOL] [EOL] [comment] [EOL] async def log_outgoing ( config , task , repo_path ) : [EOL] [docstring] [EOL] source_repo = get_source_repo ( task ) [EOL] log . info ( [string] ) [EOL] num_changesets = [number] [EOL] output = await run_hg_command ( config , [string] , [string] , [string] , [string] , source_repo , repo_path = repo_path , return_output = True , expected_exit_codes = ( [number] , [number] ) ) [EOL] if output : [EOL] path = os . path . join ( config [ [string] ] , [string] , [string] , [string] ) [EOL] makedirs ( os . path . dirname ( path ) ) [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( output ) [EOL] num_changesets = _count_outgoing ( output ) [EOL] return num_changesets [EOL] [EOL] [EOL] [comment] [EOL] async def strip_outgoing ( config , task , repo_path ) : [EOL] [docstring] [EOL] log . info ( [string] , repo_path ) [EOL] [comment] [EOL] await run_hg_command ( config , [string] , [string] , [string] , repo_path = repo_path , exception = None , expected_exit_codes = ( [number] , [number] ) ) [EOL] await run_hg_command ( config , [string] , [string] , [string] , [string] , repo_path = repo_path ) [EOL] await run_hg_command ( config , [string] , [string] , repo_path = repo_path ) [EOL] [EOL] [EOL] [comment] [EOL] async def push ( config , task , repo_path , target_repo , revision = None ) : [EOL] [docstring] [EOL] target_repo_ssh = target_repo . replace ( [string] , [string] ) [EOL] ssh_config = config . get ( [string] , { } ) . get ( get_ssh_user ( task ) , { } ) [EOL] ssh_username = ssh_config . get ( [string] ) [EOL] ssh_key = ssh_config . get ( [string] ) [EOL] ssh_opt = [ ] [EOL] if ssh_username or ssh_key : [EOL] ssh_opt = [ [string] , [string] ] [EOL] if ssh_username : [EOL] ssh_opt [ [number] ] += [string] % ssh_username [EOL] if ssh_key : [EOL] ssh_opt [ [number] ] += [string] % ssh_key [EOL] log . info ( [string] . format ( target_repo_ssh ) ) [EOL] try : [EOL] await run_hg_command ( config , [string] , * ssh_opt , [string] , revision if revision else [string] , [string] , target_repo_ssh , repo_path = repo_path , exception = PushError ) [EOL] except PushError as exc : [EOL] log . warning ( [string] , str ( exc ) ) [EOL] await strip_outgoing ( config , task , repo_path ) [EOL] raise [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Any , Dict , List , Tuple [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import os [EOL] [EOL] from mozilla_version . gecko import FennecVersion , FirefoxVersion , GeckoVersion , ThunderbirdVersion [EOL] [EOL] from treescript . exceptions import TaskVerificationError , TreeScriptError [EOL] from treescript . mercurial import run_hg_command [EOL] from treescript . task import DONTBUILD_MSG , get_dontbuild , get_version_bump_info [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] ALLOWED_BUMP_FILES = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] _VERSION_CLASS_PER_BEGINNING_OF_PATH = { [string] : FirefoxVersion , [string] : GeckoVersion , [string] : FennecVersion , [string] : ThunderbirdVersion , } [EOL] [EOL] [EOL] def _find_what_version_parser_to_use ( file_ ) : [EOL] start_string_then_version_class = [ cls for path , cls in _VERSION_CLASS_PER_BEGINNING_OF_PATH . items ( ) if file_ . startswith ( path ) ] [EOL] [EOL] try : [EOL] return start_string_then_version_class [ [number] ] [EOL] except IndexError as exc : [EOL] raise TreeScriptError ( exc ) from exc [EOL] [EOL] [EOL] def get_version ( file_ , parent_directory = None ) : [EOL] [docstring] [EOL] abs_path = os . path . join ( parent_directory , file_ ) [EOL] log . info ( [string] . format ( abs_path ) ) [EOL] VersionClass = _find_what_version_parser_to_use ( file_ ) [EOL] with open ( abs_path , [string] ) as f : [EOL] contents = f . read ( ) [EOL] log . info ( [string] ) [EOL] for line in contents . splitlines ( ) : [EOL] log . info ( [string] . format ( line ) ) [EOL] lines = [ line for line in contents . splitlines ( ) if line and not line . startswith ( [string] ) ] [EOL] return VersionClass . parse ( lines [ - [number] ] ) [EOL] [EOL] [EOL] async def bump_version ( config , task , repo_path ) : [EOL] [docstring] [EOL] bump_info = get_version_bump_info ( task ) [EOL] num_commits = [number] [EOL] [EOL] changed = await do_bump_version ( config , repo_path , bump_info [ [string] ] , bump_info [ [string] ] ) [EOL] if changed : [EOL] commit_msg = [string] [EOL] if get_dontbuild ( task ) : [EOL] commit_msg += DONTBUILD_MSG [EOL] await run_hg_command ( config , [string] , [string] , commit_msg , repo_path = repo_path ) [EOL] num_commits += [number] [EOL] return num_commits [EOL] [EOL] [EOL] async def do_bump_version ( config , repo_path , files , next_version ) : [EOL] [docstring] [EOL] changed = False [EOL] saved_next_version = next_version [EOL] [EOL] for file_ in files : [EOL] abs_file = os . path . join ( repo_path , file_ ) [EOL] if file_ not in ALLOWED_BUMP_FILES : [EOL] raise TaskVerificationError ( [string] . format ( file_ ) ) [EOL] if not os . path . exists ( abs_file ) : [EOL] raise TaskVerificationError ( [string] . format ( abs_file ) ) [EOL] [EOL] VersionClass = _find_what_version_parser_to_use ( file_ ) [EOL] curr_version = get_version ( file_ , repo_path ) [EOL] next_version = VersionClass . parse ( saved_next_version ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if curr_version . is_esr and not any ( ( next_version . is_esr , next_version . is_aurora_or_devedition , next_version . is_beta , ) ) : [EOL] next_version = VersionClass . parse ( [string] . format ( next_version ) ) [EOL] [EOL] if next_version < curr_version : [EOL] log . warning ( [string] [string] . format ( next_version , curr_version ) ) [EOL] continue [EOL] elif next_version == curr_version : [EOL] log . info ( [string] ) [EOL] continue [EOL] else : [EOL] changed = True [EOL] replace_ver_in_file ( abs_file , curr_version , next_version ) [EOL] [EOL] return changed [EOL] [EOL] [EOL] def replace_ver_in_file ( file_ , curr_version , new_version ) : [EOL] [docstring] [EOL] with open ( file_ , [string] ) as f : [EOL] contents = f . read ( ) [EOL] new_contents = contents . replace ( str ( curr_version ) , str ( new_version ) ) [EOL] if contents == new_contents : [EOL] raise Exception ( [string] ) [EOL] with open ( file_ , [string] ) as f : [EOL] f . write ( new_contents ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Literal , Union , Dict , List [EOL] import typing [EOL] import typing_extensions [EOL] import json [EOL] import os [EOL] [EOL] import pytest [EOL] from scriptworker_client . utils import makedirs [EOL] [EOL] import treescript . l10n as l10n [EOL] [EOL] [EOL] async def noop_async ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] def test_build_locale_map ( ) : [EOL] [docstring] [EOL] my_platforms = [ [string] , [string] ] [EOL] my_rev = [string] [EOL] my_dict = { [string] : my_platforms , [string] : my_rev } [EOL] old_contents = { [string] : { [string] : [string] , [string] : my_platforms } , [string] : my_dict , [string] : { [string] : my_rev , [string] : [ [string] , [string] ] } , [string] : { [string] : [string] , [string] : [ [string] , [string] ] } , [string] : { [string] : [string] , [string] : my_platforms } , } [EOL] new_contents = { [string] : my_dict , [string] : my_dict , [string] : my_dict , [string] : my_dict , [string] : my_dict , } [EOL] expected = { [string] : my_rev , [string] : my_platforms , [string] : my_rev , [string] : [string] , [string] : my_rev , } [EOL] assert l10n . build_locale_map ( old_contents , new_contents ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] , ] , { [string] : [ { [string] : [ [string] , [string] ] , [string] : [string] } , { [string] : [ [string] ] , [string] : [string] } , ] } , { [string] : { [string] : [ [string] , [string] , [string] ] } , [string] : { [string] : [ [string] , [string] ] } , [string] : { [string] : [ [string] , [string] , [string] ] } , [string] : { [string] : [ [string] , [string] ] } , [string] : { [string] : [ [string] , [string] , [string] ] } , [string] : { [string] : [ [string] , [string] ] } , } , ) , ( [ [string] ] , { [string] : { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] } , [string] : [ { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] ] , [string] : [string] , [string] : [string] , } ] , } , { [string] : { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] ] } , [string] : { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] ] } , [string] : { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] ] } , [string] : { [string] : [ [string] , [string] , [string] , [string] ] } , [string] : { [string] : [ [string] , [string] ] } , } , ) , ) , ) def test_build_platform_dict ( contents , mocker , bump_config , expected , tmpdir ) : [EOL] [docstring] [EOL] for pc in bump_config [ [string] ] : [EOL] path = os . path . join ( tmpdir , pc [ [string] ] ) [EOL] makedirs ( os . path . dirname ( path ) ) [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( contents . pop ( [number] ) ) [EOL] [EOL] assert l10n . build_platform_dict ( bump_config , tmpdir ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_get_latest_revision ( mocker ) : [EOL] [docstring] [EOL] expected = ( [string] , [string] ) [EOL] pushlog = { [string] : [string] , [string] : { [string] : { } , [string] : { [string] : [ [string] ] } } , } [EOL] [EOL] async def fake_download ( url , path ) : [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( json . dumps ( pushlog ) ) [EOL] [EOL] mocker . patch . object ( l10n , [string] , new = fake_download ) [EOL] assert await l10n . get_latest_revision ( [string] , [string] ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( { [string] : { [string] : True , [string] : [string] } , [string] : { [string] : False , [string] : [string] } , [string] : { [string] : [string] } , } , { [string] : { [string] : True , [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : False , [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : False , [string] : [string] , [string] : [ [string] ] } , } , ) , ( None , { [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } , } , ) , ) , ) async def test_build_revision_dict ( mocker , old_contents , expected ) : [EOL] [docstring] [EOL] platform_dict = { [string] : { [string] : [ [string] ] } , [string] : { [string] : [ [string] ] } , [string] : { [string] : [ [string] ] } } [EOL] bump_config = { } [EOL] if old_contents : [EOL] bump_config [ [string] ] = [string] [EOL] [EOL] def build_platform_dict ( * args ) : [EOL] return platform_dict [EOL] [EOL] async def get_latest_revision ( locale , url ) : [EOL] return ( locale , f"{ locale } [string] " ) [EOL] [EOL] mocker . patch . object ( l10n , [string] , new = build_platform_dict ) [EOL] mocker . patch . object ( l10n , [string] , new = get_latest_revision ) [EOL] assert await l10n . build_revision_dict ( bump_config , [string] , old_contents ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( True , True ) , ( False , False ) ) ) def test_build_commit_message ( dontbuild , ignore_closed_tree ) : [EOL] [docstring] [EOL] locale_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] } [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] if dontbuild : [EOL] expected [ [number] ] += l10n . DONTBUILD_MSG [EOL] if ignore_closed_tree : [EOL] expected [ [number] ] += l10n . CLOSED_TREE_MSG [EOL] assert l10n . build_commit_message ( [string] , locale_map , dontbuild = dontbuild , ignore_closed_tree = ignore_closed_tree ) . splitlines ( ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , True ) , ( [string] , False ) , ( [string] , True ) ) ) @ pytest . mark . asyncio async def test_check_treestatus ( status , mocker , expected ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] } [EOL] treestatus = { [string] : { [string] : [string] , [string] : [string] , [string] : status , [string] : [string] } } [EOL] mocker . patch . object ( l10n , [string] , new = noop_async ) [EOL] mocker . patch . object ( l10n , [string] , return_value = [string] ) [EOL] mocker . patch . object ( l10n , [string] , return_value = treestatus ) [EOL] assert await l10n . check_treestatus ( config , { } ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( True , [ { [string] : [string] , [string] : [string] } ] , { [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } } , { [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } } , [number] , ) , ( False , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] , { [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } } , { [string] : { [string] : [string] , [string] : [ [string] ] } , [string] : { [string] : [string] , [string] : [ [string] ] } } , [number] , ) , ) , ) @ pytest . mark . asyncio async def test_l10n_bump ( mocker , ignore_closed_tree , l10n_bump_info , tmpdir , old_contents , new_contents , changes ) : [EOL] [docstring] [EOL] calls = [ ] [EOL] [EOL] async def check_treestatus ( * args ) : [EOL] return True [EOL] [EOL] async def fake_hg ( * args , ** kwargs ) : [EOL] calls . append ( args ) [EOL] [EOL] async def fake_build_revision_dict ( * args , ** kwargs ) : [EOL] return new_contents [EOL] [EOL] mocker . patch . object ( l10n , [string] , return_value = False ) [EOL] mocker . patch . object ( l10n , [string] , return_value = ignore_closed_tree ) [EOL] mocker . patch . object ( l10n , [string] , new = check_treestatus ) [EOL] mocker . patch . object ( l10n , [string] , return_value = l10n_bump_info ) [EOL] mocker . patch . object ( l10n , [string] , return_value = old_contents ) [EOL] mocker . patch . object ( l10n , [string] , new = noop_async ) [EOL] mocker . patch . object ( l10n , [string] , new = fake_build_revision_dict ) [EOL] mocker . patch . object ( l10n , [string] , new = fake_hg ) [EOL] [EOL] assert await l10n . l10n_bump ( { } , { } , tmpdir ) == changes [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_l10n_bump_closed_tree ( mocker ) : [EOL] [docstring] [EOL] [EOL] async def check_treestatus ( * args ) : [EOL] return False [EOL] [EOL] mocker . patch . object ( l10n , [string] , return_value = False ) [EOL] mocker . patch . object ( l10n , [string] , return_value = False ) [EOL] mocker . patch . object ( l10n , [string] , new = check_treestatus ) [EOL] [comment] [EOL] [comment] [EOL] mocker . patch . object ( l10n , [string] , return_value = [ { } ] ) [EOL] [EOL] assert await l10n . l10n_bump ( { } , { } , [string] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import os [EOL] [EOL] import pytest [EOL] from scriptworker_client . client import verify_task_schema [EOL] from scriptworker_client . exceptions import TaskVerificationError [EOL] [EOL] import treescript . task as ttask [EOL] from treescript . script import get_default_config [EOL] [EOL] SCRIPT_CONFIG = { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def task_defn ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] } ] } , [string] : { [string] : [string] [string] } , } [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def config ( tmpdir ) : [EOL] config_ = get_default_config ( ) [EOL] config_ [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] yield config_ [EOL] [EOL] [EOL] [comment] [EOL] def test_missing_mandatory_urls_are_reported ( config , task_defn ) : [EOL] del task_defn [ [string] ] [EOL] [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] verify_task_schema ( config , task_defn ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] , [string] } , { [string] : [string] } , { [string] : [ [string] ] } , { [string] : [string] , [string] : [string] } , { [string] : [ ] , [string] : [string] } , { [string] : [ [number] ] , [string] : [string] } , { [string] : [ [string] , - [number] ] , [string] : [string] } , { [string] : [ [string] ] , [string] : [number] } , ) , ) def test_tag_info_invalid ( config , task_defn , tag_info ) : [EOL] task = task_defn [EOL] task [ [string] ] [ [string] ] = tag_info [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] verify_task_schema ( config , task ) [EOL] [EOL] [EOL] def test_no_error_is_reported_when_no_missing_url ( config , task_defn ) : [EOL] verify_task_schema ( config , task_defn ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , TaskVerificationError ) , ( [string] , TaskVerificationError ) , ( [string] , TaskVerificationError ) , ) , ) def test_get_source_repo_raises ( task_defn , source_url , raises ) : [EOL] task_defn [ [string] ] [ [string] ] = source_url [EOL] with pytest . raises ( raises ) : [EOL] ttask . get_source_repo ( task_defn ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] , ) , ) def test_get_metadata_source_repo ( task_defn , source_repo ) : [EOL] task_defn [ [string] ] [ [string] ] = [string] . format ( source_repo ) [EOL] assert source_repo == ttask . get_source_repo ( task_defn ) [EOL] [EOL] [EOL] def test_get_source_repo_no_source ( task_defn ) : [EOL] del task_defn [ [string] ] [ [string] ] [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] ttask . get_source_repo ( task_defn ) [EOL] del task_defn [ [string] ] [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] ttask . get_source_repo ( task_defn ) [EOL] [EOL] [EOL] def test_get_short_source_repo ( task_defn ) : [EOL] assert ttask . get_short_source_repo ( task_defn ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] , ) , ) def test_get_payload_source_repo ( task_defn , source_repo ) : [EOL] task_defn [ [string] ] [ [string] ] = source_repo [EOL] assert source_repo == ttask . get_source_repo ( task_defn ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , None ) ) def test_get_branch ( task_defn , branch ) : [EOL] if branch : [EOL] task_defn [ [string] ] [ [string] ] = branch [EOL] assert ttask . get_branch ( task_defn ) == branch [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { } , { [string] : [number] } ) ) def test_get_merge_config ( task_defn , config ) : [EOL] task_defn [ [string] ] [ [string] ] = config [EOL] assert ttask . get_merge_config ( task_defn ) == config [EOL] [EOL] [EOL] def test_get_merge_config_missing ( task_defn ) : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] ttask . get_merge_config ( task_defn ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : [string] , [string] : [ [string] , [string] ] } , { [string] : [string] , [string] : [ [string] , [string] ] } ) ) def test_tag_info ( task_defn , tag_info ) : [EOL] task_defn [ [string] ] [ [string] ] = tag_info [EOL] tested_info = ttask . get_tag_info ( task_defn ) [EOL] assert tested_info == tag_info [EOL] [EOL] [EOL] def test_tag_missing_tag_info ( task_defn ) : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] ttask . get_tag_info ( task_defn ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : [string] , [string] : [ [string] ] } , { [string] : [string] , [string] : [ [string] , [string] ] } , ) , ) def test_bump_info ( task_defn , bump_info ) : [EOL] task_defn [ [string] ] [ [string] ] = bump_info [EOL] tested_info = ttask . get_version_bump_info ( task_defn ) [EOL] assert tested_info == bump_info [EOL] [EOL] [EOL] def test_bump_missing_bump_info ( task_defn ) : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] ttask . get_version_bump_info ( task_defn ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [ [string] ] , [string] : [string] } ] , } ] , [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , } , [string] : [ { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [string] , [string] : [string] , } ] , } ] , ) , ) def test_get_l10n_bump_info ( task_defn , l10n_bump_info ) : [EOL] task_defn [ [string] ] [ [string] ] = l10n_bump_info [EOL] tested_info = ttask . get_l10n_bump_info ( task_defn ) [EOL] assert tested_info == l10n_bump_info [EOL] [EOL] [EOL] def test_missing_l10n_bump_info ( task_defn ) : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] ttask . get_l10n_bump_info ( task_defn ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_get_dontbuild ( task_defn , dontbuild ) : [EOL] if dontbuild : [EOL] task_defn [ [string] ] [ [string] ] = True [EOL] assert ttask . get_dontbuild ( task_defn ) == dontbuild [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) def test_get_ignore_closed_tree ( task_defn , closed_tree ) : [EOL] if closed_tree : [EOL] task_defn [ [string] ] [ [string] ] = True [EOL] assert ttask . get_ignore_closed_tree ( task_defn ) == closed_tree [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( [ [string] ] , [ [string] ] , [ [string] , [string] , [string] ] ) ) def test_task_action_types_actions ( actions ) : [EOL] task = { [string] : { [string] : actions } } [EOL] assert set ( actions ) == ttask . task_action_types ( SCRIPT_CONFIG , task ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( [ [string] , [string] ] , [ [string] ] ) ) def test_task_action_types_actions_invalid ( actions ) : [EOL] task = { [string] : { [string] : actions } } [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] ttask . task_action_types ( SCRIPT_CONFIG , task ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : { [string] : True } } , { [string] : { [string] : False , [string] : True } } , { [string] : { [string] : [ [string] ] } } ) ) def test_should_push_true ( task ) : [EOL] actions = ttask . task_action_types ( SCRIPT_CONFIG , task ) [EOL] assert True is ttask . should_push ( task , actions ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : { [string] : True } } , { [string] : { [string] : True , [string] : [ [string] ] } } , { [string] : { [string] : True , [string] : True } } , { [string] : { [string] : False , [string] : [ [string] ] } } , { [string] : { } } , ) , ) def test_should_push_false ( task ) : [EOL] actions = ttask . task_action_types ( SCRIPT_CONFIG , task ) [EOL] assert False is ttask . should_push ( task , actions ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( None , [string] ) , ( [string] , [string] ) ) ) def test_get_ssh_user ( task_defn , ssh_user , expected ) : [EOL] if ssh_user : [EOL] task_defn [ [string] ] [ [string] ] = ssh_user [EOL] assert ttask . get_ssh_user ( task_defn ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] import jsone [EOL] import jsonschema [EOL] import yaml [EOL] [EOL] [EOL] def load_config ( context ) : [EOL] path_to_worker_template = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] , [string] ) [EOL] with open ( path_to_worker_template , [string] ) as file : [EOL] worker_template = yaml . safe_load ( file ) [EOL] [EOL] return jsone . render ( worker_template , context ) [EOL] [EOL] [EOL] def load_schema ( ) : [EOL] path_to_schema = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] , [string] , [string] , [string] ) [EOL] with open ( path_to_schema , [string] ) as file : [EOL] return json . load ( file ) [EOL] [EOL] [EOL] def _validate_config ( context ) : [EOL] config = load_config ( context ) [EOL] schema = load_schema ( ) [EOL] [EOL] jsonschema . validate ( config , schema ) [EOL] [EOL] [EOL] def test_config ( ) : [EOL] context = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] _validate_config ( context ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , List , Tuple [EOL] import typing [EOL] import os [EOL] import shutil [EOL] from contextlib import contextmanager [EOL] [EOL] import pytest [EOL] from mozilla_version . gecko import FennecVersion , FirefoxVersion [EOL] [EOL] import treescript . merges as merges [EOL] from treescript . exceptions import TaskVerificationError [EOL] from treescript . script import get_default_config [EOL] [EOL] [EOL] @ contextmanager def does_not_raise ( ) : [EOL] yield [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def task ( ) : [EOL] return { [string] : { } , [string] : { [string] : [string] } } [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def merge_info ( ) : [EOL] return { [string] : [ [string] , [string] ] , [string] : [ [string] ] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [ [ [string] , [string] , [string] , ] , [ [string] , [string] , [string] , ] , ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def merge_bump_info ( ) : [EOL] return { [string] : [ ] , [string] : [ [string] , [string] , [string] ] , [string] : [string] , [string] : [ ] , [string] : [ ] , [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def config ( tmpdir ) : [EOL] config_ = get_default_config ( ) [EOL] config_ [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] config_ [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] config_ [ [string] ] = [string] [EOL] config_ [ [string] ] = [string] [EOL] config_ [ [string] ] = [string] [EOL] yield config_ [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def repo_context ( tmpdir , config , request , mocker ) : [EOL] context = mocker . MagicMock ( ) [EOL] context . repo = os . path . join ( tmpdir , [string] ) [EOL] context . task = { [string] : { [string] : [string] } } [EOL] context . config = config [EOL] os . mkdir ( context . repo ) [EOL] os . mkdir ( os . path . join ( context . repo , [string] ) ) [EOL] replacement_file = os . path . join ( context . repo , [string] , [string] ) [EOL] with open ( replacement_file , [string] ) as f : [EOL] f . write ( [string] ) [EOL] clobber_file = os . path . join ( context . repo , config [ [string] ] ) [EOL] with open ( clobber_file , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] version_file = os . path . join ( context . repo , [string] ) [EOL] os . makedirs ( os . path . dirname ( version_file ) ) [EOL] with open ( version_file , [string] ) as f : [EOL] f . write ( [string] ) [EOL] yield context [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( does_not_raise ( ) , [string] , [string] , [string] ) , ( pytest . raises ( ValueError ) , [string] , [string] , [string] ) , ( pytest . raises ( FileNotFoundError ) , [string] , [string] , [string] ) , ) , ) def test_replace ( repo_context , expectation , filename , from_ , to_ ) : [EOL] file_path = os . path . join ( repo_context . repo , filename ) [EOL] with expectation : [EOL] merges . replace ( file_path , from_ , to_ ) [EOL] with open ( file_path ) as f : [EOL] assert f . read ( ) == to_ [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( False , False , does_not_raise ( ) ) , ( False , True , pytest . raises ( FileNotFoundError ) ) , ( True , False , does_not_raise ( ) ) , ) , ) def test_touch_clobber_file ( repo_context , config_no_clobber , break_things , expectation ) : [EOL] if config_no_clobber : [EOL] repo_context . config [ [string] ] = [string] [EOL] os . unlink ( os . path . join ( repo_context . repo , [string] ) ) [EOL] clobber_file = None [EOL] else : [EOL] clobber_file = os . path . join ( repo_context . repo , repo_context . config [ [string] ] ) [EOL] [EOL] if break_things : [EOL] os . unlink ( clobber_file ) [EOL] [EOL] with expectation : [EOL] merges . touch_clobber_file ( repo_context . config , repo_context . repo ) [EOL] [EOL] if clobber_file : [EOL] with open ( clobber_file ) as f : [EOL] contents = f . read ( ) [EOL] assert [string] in contents [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ { [string] : [string] , [string] : [string] } ] } , [ [ [string] ] ] ) , ( { [string] : [ [ [string] , [string] ] ] } , [string] ) , ( { [string] : [ ( [string] , [string] , [string] ) ] } , [string] , ) , ) , ) async def test_apply_rebranding ( config , repo_context , mocker , merge_config , expected ) : [EOL] [comment] [EOL] called_args = [ ] [EOL] [EOL] async def noop_bump_version ( * arguments , ** kwargs ) : [EOL] called_args . append ( [ arguments [ [number] ] ] ) [EOL] [EOL] def sync_noop ( * arguments , ** kwargs ) : [EOL] called_args . extend ( arguments ) [EOL] [EOL] def noop_copyfile ( * arguments , ** kwargs ) : [EOL] called_args . append ( [string] ) [EOL] [EOL] def noop_replace ( * arguments , ** kwargs ) : [EOL] called_args . append ( [string] ) [EOL] [EOL] def mocked_get_version ( path , repo_path ) : [EOL] return FirefoxVersion . parse ( [string] ) [EOL] [EOL] mocker . patch . object ( merges , [string] , new = mocked_get_version ) [EOL] mocker . patch . object ( merges , [string] , new = noop_bump_version ) [EOL] mocker . patch . object ( shutil , [string] , new = noop_copyfile ) [EOL] mocker . patch . object ( merges , [string] , new = noop_replace ) [EOL] mocker . patch . object ( merges , [string] , new = sync_noop ) [EOL] [EOL] await merges . apply_rebranding ( config , repo_context . repo , merge_config ) [EOL] assert called_args [ [number] ] == expected [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( { [string] : [string] , [string] : [string] } , FirefoxVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FirefoxVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FirefoxVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FirefoxVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FirefoxVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FirefoxVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FirefoxVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FennecVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FennecVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FennecVersion . parse ( [string] ) , [string] ) , ( { [string] : [string] , [string] : [string] } , FennecVersion . parse ( [string] ) , [string] ) , ) , ) async def test_create_new_version ( config , mocker , version_config , current_version , expected ) : [EOL] def mocked_get_version ( path , repo_path ) : [EOL] return current_version [EOL] [EOL] mocker . patch . object ( merges , [string] , new = mocked_get_version ) [EOL] [EOL] result = merges . create_new_version ( version_config , repo_path = [string] ) [comment] [EOL] assert result == expected [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( True , does_not_raise ( ) , [number] , [ ( [string] , [string] ) , ( [string] , [string] ) ] , ) , ( False , pytest . raises ( TaskVerificationError ) , [number] , None ) , ) , ) async def test_do_merge ( mocker , config , task , repo_context , merge_info , add_merge_info , raises , expected_calls , expected_return ) : [EOL] [EOL] called_args = [ ] [EOL] if add_merge_info : [EOL] task [ [string] ] [ [string] ] = merge_info [EOL] [EOL] async def mocked_run_hg_command ( config , * arguments , repo_path = None , ** kwargs ) : [EOL] called_args . append ( [ arguments ] ) [EOL] if [string] in kwargs : [EOL] return [string] [EOL] [EOL] async def mocked_get_revision ( * args , ** kwargs ) : [EOL] return [string] [EOL] [EOL] async def noop_apply_rebranding ( * arguments , ** kwargs ) : [EOL] called_args . append ( [string] ) [EOL] [EOL] mocker . patch . object ( merges , [string] , new = mocked_run_hg_command ) [EOL] mocker . patch . object ( merges , [string] , new = mocked_get_revision ) [EOL] mocker . patch . object ( merges , [string] , new = noop_apply_rebranding ) [EOL] [EOL] result = None [EOL] with raises : [EOL] result = await merges . do_merge ( config , task , repo_context . repo ) [EOL] [EOL] assert len ( called_args ) == expected_calls [EOL] assert result == expected_return [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_bump_central ( mocker , config , task , repo_context , merge_bump_info ) : [EOL] task [ [string] ] [ [string] ] = merge_bump_info [EOL] called_args = [ ] [EOL] [EOL] async def mocked_run_hg_command ( config , * arguments , repo_path = None , ** kwargs ) : [EOL] called_args . append ( arguments ) [EOL] if [string] in kwargs : [EOL] return [string] [EOL] [EOL] async def mocked_get_revision ( * args , ** kwargs ) : [EOL] return [string] [EOL] [EOL] async def noop_apply_rebranding ( * arguments , ** kwargs ) : [EOL] called_args . append ( ( [string] ) ) [EOL] [EOL] mocker . patch . object ( merges , [string] , new = mocked_run_hg_command ) [EOL] mocker . patch . object ( merges , [string] , new = mocked_get_revision ) [EOL] mocker . patch . object ( merges , [string] , new = noop_apply_rebranding ) [EOL] [EOL] result = await merges . do_merge ( config , task , repo_context . repo ) [EOL] [EOL] expected_calls = [ ( [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) , ( [string] , ) , ( [string] ) , ( [string] , [string] , [string] ) , ] [EOL] for expected in expected_calls : [EOL] assert expected in called_args [EOL] assert result == [ ( [string] , [string] ) ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { } , [string] ) , ( { [string] : [string] } , [string] ) ) ) def test_core_version_file ( merge_config , expected ) : [EOL] assert merges . core_version_file ( merge_config ) == expected [EOL] [EOL] [EOL] def test_formatter ( ) : [EOL] fmt = merges . BashFormatter ( ) [EOL] assert fmt . format ( [string] , baz = [string] ) == [string] [EOL] assert fmt . format ( [string] , [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import unittest [EOL] import mock [EOL] import typing [EOL] import json [EOL] import os [EOL] from unittest . mock import MagicMock [EOL] [EOL] import mock [EOL] import pytest [EOL] from scriptworker_client . exceptions import TaskError [EOL] [EOL] import treescript . mercurial as mercurial [EOL] import treescript . script as script [EOL] from treescript . exceptions import TreeScriptError [EOL] [EOL] [comment] [EOL] BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . dirname ( __file__ ) ) ) [EOL] EXAMPLE_CONFIG = os . path . join ( BASE_DIR , [string] ) [EOL] [EOL] [EOL] def noop_sync ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] async def noop_async ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] def read_file ( path ) : [EOL] with open ( path , [string] ) as fh : [EOL] return fh . read ( ) [EOL] [EOL] [EOL] def get_conf_file ( tmpdir , ** kwargs ) : [EOL] conf = json . loads ( read_file ( EXAMPLE_CONFIG ) ) [EOL] conf . update ( kwargs ) [EOL] conf [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] conf [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] path = os . path . join ( tmpdir , [string] ) [EOL] with open ( path , [string] ) as fh : [EOL] json . dump ( conf , fh ) [EOL] return path [EOL] [EOL] [EOL] async def die_async ( * args , ** kwargs ) : [EOL] raise TaskError ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( False , TaskError , [ [string] ] ) , ( True , None , [ [string] ] ) , ( True , None , None ) ) ) async def test_async_main ( tmpdir , mocker , robustcheckout_works , raises , actions ) : [EOL] async def fake_validate_robustcheckout ( _ ) : [EOL] return robustcheckout_works [EOL] [EOL] def action_fun ( * args , ** kwargs ) : [EOL] return actions [EOL] [EOL] mocker . patch . object ( script , [string] , new = action_fun ) [EOL] mocker . patch . object ( script , [string] , new = fake_validate_robustcheckout ) [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] config = mock . MagicMock ( ) [EOL] task = mock . MagicMock ( ) [EOL] if raises : [EOL] with pytest . raises ( raises ) : [EOL] await script . async_main ( config , task ) [EOL] else : [EOL] await script . async_main ( config , task ) [EOL] [EOL] [EOL] [comment] [EOL] def test_get_default_config ( ) : [EOL] parent_dir = os . path . dirname ( os . getcwd ( ) ) [EOL] c = script . get_default_config ( ) [EOL] assert c [ [string] ] == os . path . join ( parent_dir , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [ [string] ] , False , False , False ) , ( [ [string] ] , False , True , False ) , ( [ [string] ] , True , False , True ) , ( [ [string] ] , True , True , False ) , ( [ ] , False , False , False ) , ( [ ] , False , True , False ) , ( [ ] , True , False , True ) , ( [ ] , True , True , False ) , ) , ) async def test_do_actions ( mocker , push_scope , push_payload , dry_run , push_expect_called ) : [EOL] actions = [ [string] , [string] , [string] ] [EOL] actions += push_scope [EOL] called = { [string] : False , [string] : False , [string] : False , [string] : False , [string] : False } [EOL] [EOL] async def mocked_tag ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_bump ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_l10n ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_perform_merge_actions ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] [EOL] async def mocked_push ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] [EOL] async def mocked_outgoing ( * args ) : [EOL] return [number] [EOL] [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( mercurial , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = mocked_tag ) [EOL] mocker . patch . object ( script , [string] , new = mocked_bump ) [EOL] mocker . patch . object ( script , [string] , new = mocked_l10n ) [EOL] [EOL] mocker . patch . object ( script , [string] , new = mocked_perform_merge_actions ) [EOL] mocker . patch . object ( mercurial , [string] , new = mocked_push ) [EOL] mocker . patch . object ( script , [string] , new = mocked_push ) [EOL] mocker . patch . object ( script , [string] , new = mocked_outgoing ) [EOL] [EOL] task_defn = { [string] : { [string] : push_payload , [string] : dry_run } , [string] : { [string] : [string] [string] } , } [EOL] await script . do_actions ( { } , task_defn , actions , [string] ) [EOL] for action in [ [string] , [string] , [string] ] : [EOL] if action in actions : [EOL] assert called [ action ] [EOL] [EOL] assert called [ [string] ] is push_expect_called [EOL] assert called [ [string] ] is False [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [ [string] ] , False , False , False ) , ( [ [string] ] , False , True , False ) , ( [ [string] ] , True , False , True ) , ( [ [string] ] , True , True , False ) , ( [ ] , False , False , False ) , ( [ ] , False , True , False ) , ( [ ] , True , False , True ) , ( [ ] , True , True , False ) , ) , ) async def test_do_actions_merge_tasks ( mocker , push_scope , push_payload , dry_run , push_expect_called ) : [EOL] actions = [ [string] ] [EOL] actions += push_scope [EOL] called = { [string] : False , [string] : False , [string] : False , [string] : False , [string] : False } [EOL] [EOL] async def mocked_tag ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_bump ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_l10n ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_perform_merge_actions ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] [EOL] async def mocked_push ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] [EOL] async def mocked_outgoing ( * args ) : [EOL] return [number] [EOL] [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( mercurial , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = mocked_tag ) [EOL] mocker . patch . object ( script , [string] , new = mocked_bump ) [EOL] mocker . patch . object ( script , [string] , new = mocked_l10n ) [EOL] [EOL] mocker . patch . object ( script , [string] , new = mocked_perform_merge_actions ) [EOL] mocker . patch . object ( mercurial , [string] , new = mocked_push ) [EOL] mocker . patch . object ( script , [string] , new = mocked_push ) [EOL] mocker . patch . object ( script , [string] , new = mocked_outgoing ) [EOL] [EOL] task_defn = { [string] : { [string] : push_payload , [string] : dry_run } , [string] : { [string] : [string] [string] } , } [EOL] await script . do_actions ( { } , task_defn , actions , [string] ) [EOL] for action in [ [string] , [string] , [string] ] : [EOL] assert called [ action ] is False [EOL] assert called [ [string] ] is True [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [ [string] ] , False , False ) , ( [ [string] ] , True , True ) , ( [ ] , False , False ) , ( [ ] , False , False ) ) ) async def test_perform_merge_actions ( mocker , push_scope , should_push , push_expect_called ) : [EOL] actions = [ [string] ] [EOL] actions += push_scope [EOL] called = { [string] : False , [string] : False } [EOL] [EOL] async def mocked_do_merge ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [ ( [string] , [string] ) ] [EOL] [EOL] async def mocked_push ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = mocked_do_merge ) [EOL] mocker . patch . object ( script , [string] , new = mocked_push ) [EOL] mocker . patch . object ( script , [string] , return_value = should_push ) [EOL] await script . perform_merge_actions ( { } , { } , actions , [string] ) [EOL] assert called [ [string] ] is True [EOL] assert called [ [string] ] is push_expect_called [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_do_actions_no_changes ( mocker ) : [EOL] actions = [ [string] ] [EOL] called = { [string] : False , [string] : False , [string] : False , [string] : False } [EOL] [EOL] async def mocked_tag ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_bump ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_l10n ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_push ( * args , ** kwargs ) : [EOL] called [ [string] ] = True [EOL] return [number] [EOL] [EOL] async def mocked_outgoing ( * args ) : [EOL] return [number] [EOL] [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = mocked_tag ) [EOL] mocker . patch . object ( script , [string] , new = mocked_bump ) [EOL] mocker . patch . object ( script , [string] , new = mocked_l10n ) [EOL] mocker . patch . object ( script , [string] , new = mocked_push ) [EOL] mocker . patch . object ( script , [string] , new = mocked_outgoing ) [EOL] await script . do_actions ( { } , { [string] : { [string] : True } } , actions , [string] ) [EOL] assert not any ( called . values ( ) ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_do_actions_mismatch_change_count ( mocker ) : [EOL] actions = [ [string] ] [EOL] [EOL] async def mocked_tag ( * args , ** kwargs ) : [EOL] return [number] [EOL] [EOL] async def mocked_bump ( * args , ** kwargs ) : [EOL] return [number] [EOL] [EOL] async def mocked_l10n ( * args , ** kwargs ) : [EOL] return [number] [EOL] [EOL] async def mocked_push ( * args , ** kwargs ) : [EOL] return [number] [EOL] [EOL] async def mocked_outgoing ( * args ) : [EOL] return [number] [EOL] [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = noop_async ) [EOL] mocker . patch . object ( script , [string] , new = mocked_tag ) [EOL] mocker . patch . object ( script , [string] , new = mocked_bump ) [EOL] mocker . patch . object ( script , [string] , new = mocked_l10n ) [EOL] mocker . patch . object ( script , [string] , new = mocked_push ) [EOL] mocker . patch . object ( script , [string] , new = mocked_outgoing ) [EOL] with pytest . raises ( TreeScriptError ) : [EOL] await script . do_actions ( { } , { [string] : { [string] : False } } , actions , [string] ) [EOL] [EOL] [EOL] def test_main ( monkeypatch ) : [EOL] sync_main_mock = MagicMock ( ) [EOL] monkeypatch . setattr ( script , [string] , sync_main_mock ) [EOL] script . main ( ) [EOL] sync_main_mock . asset_called_once_with ( script . async_main , default_config = script . get_default_config ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] import pytest [EOL] [EOL] from treescript . mercurial import HGRCPATH [EOL] [EOL] ROBUSTCHECKOUT_PATH = os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) ) [EOL] HGRC_ROBUSTCHECKOUT = os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def set_hgrc ( monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , os . path . pathsep . join ( [ HGRCPATH , HGRC_ROBUSTCHECKOUT ] ) ) [EOL] monkeypatch . setenv ( [string] , ROBUSTCHECKOUT_PATH ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from scriptworker_client . exceptions import TaskError , TaskVerificationError [EOL] [EOL] import treescript . exceptions as exceptions [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( exceptions . TaskVerificationError , TaskVerificationError ) , ( exceptions . FailedSubprocess , TaskError ) , ( exceptions . TreeScriptError , TaskError ) ) ) def test_exception ( exc , from_ ) : [EOL] a = exc ( [string] ) [EOL] assert isinstance ( a , from_ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import os [EOL] from contextlib import contextmanager [EOL] [EOL] import pytest [EOL] from mozilla_version . gecko import FennecVersion , FirefoxVersion , GeckoVersion , ThunderbirdVersion [EOL] [EOL] import treescript . versionmanip as vmanip [EOL] from treescript . exceptions import TaskVerificationError , TreeScriptError [EOL] from treescript . script import get_default_config [EOL] from treescript . task import DONTBUILD_MSG [EOL] [EOL] [EOL] def is_slice_in_list ( myslice , mylist ) : [EOL] [comment] [EOL] [comment] [EOL] len_s = len ( myslice ) [comment] [EOL] return any ( myslice == mylist [ i : len_s + i ] for i in range ( len ( mylist ) - len_s + [number] ) ) [EOL] [EOL] [EOL] @ contextmanager def does_not_raise ( ) : [EOL] yield [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def config ( tmpdir ) : [EOL] config_ = get_default_config ( ) [EOL] config_ [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] yield config_ [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = ( [string] , [string] , [string] , [string] ) ) def repo_context ( tmpdir , config , request , mocker ) : [EOL] context = mocker . MagicMock ( ) [EOL] context . repo = os . path . join ( tmpdir , [string] ) [EOL] context . task = { [string] : { [string] : [string] } } [EOL] context . config = config [EOL] context . xtest_version = request . param [EOL] if [string] in request . param : [EOL] context . xtest_version = [ line for line in request . param . splitlines ( ) if not line . startswith ( [string] ) ] [ [number] ] [EOL] os . mkdir ( context . repo ) [EOL] os . mkdir ( os . path . join ( context . repo , [string] ) ) [EOL] version_file = os . path . join ( context . repo , [string] , [string] ) [EOL] with open ( version_file , [string] ) as f : [EOL] f . write ( request . param ) [EOL] yield context [EOL] [EOL] [EOL] def test_get_version ( repo_context ) : [EOL] ver = vmanip . get_version ( [string] , repo_context . repo ) [EOL] assert ver == repo_context . xtest_version [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) def test_replace_ver_in_file ( repo_context , new_version ) : [EOL] filepath = [string] [EOL] old_ver = repo_context . xtest_version [EOL] vmanip . replace_ver_in_file ( os . path . join ( repo_context . repo , filepath ) , old_ver , new_version ) [EOL] assert new_version == vmanip . get_version ( filepath , repo_context . repo ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) def test_replace_ver_in_file_invalid_old_ver ( repo_context , new_version ) : [EOL] filepath = os . path . join ( repo_context . repo , [string] , [string] ) [EOL] old_ver = [string] [EOL] with pytest . raises ( Exception ) : [EOL] vmanip . replace_ver_in_file ( filepath , old_ver , new_version ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , does_not_raise ( ) , FirefoxVersion ) , ( [string] , does_not_raise ( ) , FirefoxVersion ) , ( [string] , does_not_raise ( ) , ThunderbirdVersion ) , ( [string] , does_not_raise ( ) , ThunderbirdVersion ) , ( [string] , does_not_raise ( ) , GeckoVersion ) , ( [string] , does_not_raise ( ) , FennecVersion ) , ( [string] , does_not_raise ( ) , FennecVersion ) , ( [string] , does_not_raise ( ) , FennecVersion ) , ( [string] , does_not_raise ( ) , FennecVersion ) , ( [string] , pytest . raises ( TreeScriptError ) , None ) , ) , ) def test_find_what_version_parser_to_use ( file , expectation , expected_result ) : [EOL] with expectation : [EOL] assert vmanip . _find_what_version_parser_to_use ( file ) == expected_result [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [string] , True ) , ( [string] , False ) ) ) async def test_bump_version ( mocker , repo_context , new_version , should_append_esr ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( context , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ context ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] test_version = new_version [EOL] if repo_context . xtest_version . endswith ( [string] ) and should_append_esr : [EOL] test_version = new_version + [string] [EOL] [EOL] relative_files = [ os . path . join ( [string] , [string] ) ] [EOL] bump_info = { [string] : relative_files , [string] : new_version } [EOL] mocked_bump_info = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_bump_info . return_value = bump_info [EOL] mocker . patch . object ( vmanip , [string] , new = run_command ) [EOL] await vmanip . bump_version ( repo_context . config , repo_context . task , repo_context . repo ) [EOL] assert test_version == vmanip . get_version ( relative_files [ [number] ] , repo_context . repo ) [EOL] assert len ( called_args ) == [number] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert is_slice_in_list ( ( [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) async def test_bump_version_DONTBUILD_true ( mocker , repo_context , new_version ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( context , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ context ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] relative_files = [ os . path . join ( [string] , [string] ) ] [EOL] bump_info = { [string] : relative_files , [string] : new_version } [EOL] mocked_bump_info = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_bump_info . return_value = bump_info [EOL] mocked_dontbuild = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_dontbuild . return_value = True [EOL] mocker . patch . object ( vmanip , [string] , new = run_command ) [EOL] await vmanip . bump_version ( repo_context . config , repo_context . task , repo_context . repo ) [EOL] command = called_args [ [number] ] [ [number] ] [EOL] commit_msg = command [ command . index ( [string] ) + [number] ] [EOL] assert DONTBUILD_MSG in commit_msg [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) async def test_bump_version_DONTBUILD_false ( mocker , repo_context , new_version ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( context , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ context ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] relative_files = [ os . path . join ( [string] , [string] ) ] [EOL] bump_info = { [string] : relative_files , [string] : new_version } [EOL] mocked_bump_info = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_bump_info . return_value = bump_info [EOL] mocked_dontbuild = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_dontbuild . return_value = False [EOL] mocker . patch . object ( vmanip , [string] , new = run_command ) [EOL] await vmanip . bump_version ( repo_context . config , repo_context . task , repo_context . repo ) [EOL] command = called_args [ [number] ] [ [number] ] [EOL] commit_msg = command [ command . index ( [string] ) + [number] ] [EOL] assert DONTBUILD_MSG not in commit_msg [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) async def test_bump_version_invalid_file ( mocker , repo_context , new_version ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( context , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ context ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] relative_files = [ os . path . join ( [string] , [string] ) , os . path . join ( [string] , [string] ) ] [EOL] bump_info = { [string] : relative_files , [string] : new_version } [EOL] mocked_bump_info = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_bump_info . return_value = bump_info [EOL] mocker . patch . object ( vmanip , [string] , new = run_command ) [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] await vmanip . bump_version ( repo_context . config , repo_context . task , repo_context . repo ) [EOL] assert repo_context . xtest_version == vmanip . get_version ( relative_files [ [number] ] , repo_context . repo ) [EOL] assert len ( called_args ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) async def test_bump_version_missing_file ( mocker , repo_context , new_version ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( context , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ context ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] [comment] [EOL] relative_files = [ os . path . join ( [string] , [string] , [string] ) , os . path . join ( [string] , [string] ) ] [EOL] bump_info = { [string] : relative_files , [string] : new_version } [EOL] mocked_bump_info = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_bump_info . return_value = bump_info [EOL] mocker . patch . object ( vmanip , [string] , new = run_command ) [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] await vmanip . bump_version ( repo_context . config , repo_context . task , repo_context . repo ) [EOL] assert repo_context . xtest_version == vmanip . get_version ( relative_files [ [number] ] , repo_context . repo ) [EOL] assert len ( called_args ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) async def test_bump_version_smaller_version ( mocker , repo_context , new_version ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( context , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ context ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] relative_files = [ os . path . join ( [string] , [string] ) ] [EOL] bump_info = { [string] : relative_files , [string] : new_version } [EOL] mocked_bump_info = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_bump_info . return_value = bump_info [EOL] mocker . patch . object ( vmanip , [string] , new = run_command ) [EOL] await vmanip . bump_version ( repo_context . config , repo_context . task , repo_context . repo ) [EOL] assert repo_context . xtest_version == vmanip . get_version ( relative_files [ [number] ] , repo_context . repo ) [EOL] assert len ( called_args ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ) ) async def test_bump_version_esr ( mocker , repo_context , new_version , expect_version ) : [EOL] if not repo_context . xtest_version . endswith ( [string] ) : [EOL] [comment] [EOL] return [EOL] [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( context , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ context ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] relative_files = [ os . path . join ( [string] , [string] ) ] [EOL] bump_info = { [string] : relative_files , [string] : new_version } [EOL] mocked_bump_info = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_bump_info . return_value = bump_info [EOL] mocker . patch . object ( vmanip , [string] , new = run_command ) [EOL] await vmanip . bump_version ( repo_context . config , repo_context . task , repo_context . repo ) [EOL] assert expect_version == vmanip . get_version ( relative_files [ [number] ] , repo_context . repo ) [EOL] assert len ( called_args ) == [number] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert is_slice_in_list ( ( [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) ) ) async def test_bump_version_esr_dont_bump_non_esr ( mocker , config , tmpdir , new_version , expect_esr_version ) : [EOL] version = [string] [EOL] repo = os . path . join ( tmpdir , [string] ) [EOL] os . mkdir ( repo ) [EOL] os . mkdir ( os . path . join ( repo , [string] ) ) [EOL] os . makedirs ( os . path . join ( repo , [string] , [string] ) ) [EOL] version_file = os . path . join ( [string] , [string] ) [EOL] with open ( os . path . join ( repo , version_file ) , [string] ) as f : [EOL] f . write ( version ) [EOL] display_version_file = os . path . join ( [string] , [string] , [string] ) [EOL] with open ( os . path . join ( repo , display_version_file ) , [string] ) as f : [EOL] f . write ( version + [string] ) [EOL] [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( context , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ context ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] relative_files = [ os . path . join ( [string] , [string] , [string] ) , os . path . join ( [string] , [string] ) ] [EOL] bump_info = { [string] : relative_files , [string] : new_version } [EOL] mocked_bump_info = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_bump_info . return_value = bump_info [EOL] mocker . patch . object ( vmanip , [string] , new = run_command ) [EOL] await vmanip . bump_version ( config , { } , repo ) [EOL] assert expect_esr_version == vmanip . get_version ( display_version_file , repo ) [EOL] assert new_version == vmanip . get_version ( version_file , repo ) [EOL] assert len ( called_args ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_bump_version_same_version ( mocker , repo_context ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( context , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ context ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] relative_files = [ os . path . join ( [string] , [string] ) ] [EOL] bump_info = { [string] : relative_files , [string] : repo_context . xtest_version } [EOL] mocked_bump_info = mocker . patch . object ( vmanip , [string] ) [EOL] mocked_bump_info . return_value = bump_info [EOL] mocker . patch . object ( vmanip , [string] , new = run_command ) [EOL] await vmanip . bump_version ( repo_context . config , repo_context . task , repo_context . repo ) [EOL] assert repo_context . xtest_version == vmanip . get_version ( relative_files [ [number] ] , repo_context . repo ) [EOL] assert len ( called_args ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Union , Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] import os [EOL] [EOL] import pytest [EOL] from scriptworker_client . utils import makedirs [EOL] [EOL] from treescript import mercurial [EOL] from treescript . exceptions import FailedSubprocess , PushError [EOL] from treescript . script import get_default_config [EOL] from treescript . task import DONTBUILD_MSG [EOL] [EOL] [comment] [EOL] UNEXPECTED_ENV_KEYS = [string] [string] . split ( ) [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def task ( ) : [EOL] return { [string] : { } , [string] : { [string] : [string] } } [EOL] [EOL] [EOL] async def noop_async ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] async def check_tags ( _ , tag_info , * args ) : [EOL] return tag_info [ [string] ] [EOL] [EOL] [EOL] def is_slice_in_list ( myslice , mylist ) : [EOL] [comment] [EOL] [comment] [EOL] len_s = len ( myslice ) [comment] [EOL] return any ( myslice == mylist [ i : len_s + i ] for i in range ( len ( mylist ) - len_s + [number] ) ) [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def config ( tmpdir ) : [EOL] config = get_default_config ( ) [EOL] config [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] config [ [string] ] = os . path . join ( tmpdir , [string] ) [EOL] makedirs ( config [ [string] ] ) [EOL] makedirs ( config [ [string] ] ) [EOL] yield config [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [ [string] , [string] , [string] ] ) , ( [ [string] ] , [ [string] , [string] , [string] ] ) ) ) def test_build_hg_cmd ( config , hg , args ) : [EOL] config [ [string] ] = hg [EOL] assert mercurial . build_hg_command ( config , * args ) == [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( { } , { [string] : [string] , [string] : [string] } , { k : [string] for k in UNEXPECTED_ENV_KEYS } , ) , ) def test_build_hg_env ( mocker , my_env ) : [EOL] mocker . patch . dict ( mercurial . os . environ , my_env ) [EOL] returned_env = mercurial . build_hg_environment ( ) [EOL] assert ( set ( UNEXPECTED_ENV_KEYS ) & set ( returned_env . keys ( ) ) ) == set ( ) [EOL] assert returned_env [ [string] ] == [string] [EOL] assert returned_env [ [string] ] == [string] [EOL] for key in returned_env . keys ( ) : [EOL] assert type ( returned_env [ key ] ) == str [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [ [string] , [string] ] , [ [string] , [string] , [string] ] ) ) async def test_run_hg_command ( mocker , config , args ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( * arguments , ** kwargs ) : [EOL] called_args . append ( [ * arguments , kwargs ] ) [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] env_call = mocker . patch . object ( mercurial , [string] ) [EOL] cmd_call = mocker . patch . object ( mercurial , [string] ) [EOL] env = { [string] : [number] , [string] : [string] } [EOL] env_call . return_value = env [EOL] cmd_call . return_value = [ [string] , * args ] [EOL] [EOL] await mercurial . run_hg_command ( config , * args ) [EOL] [EOL] env_call . assert_called_with ( ) [EOL] cmd_call . assert_called_with ( config , * args ) [EOL] assert called_args [ [number] ] [ [number] ] == [ [string] ] + args [EOL] assert called_args [ [number] ] [ [number] ] [ [string] ] == env [EOL] assert len ( called_args ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_run_hg_command_localrepo ( mocker , config ) : [EOL] args = [ [string] , [string] ] [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( * arguments , ** kwargs ) : [EOL] called_args . append ( [ * arguments , kwargs ] ) [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] env_call = mocker . patch . object ( mercurial , [string] ) [EOL] cmd_call = mocker . patch . object ( mercurial , [string] ) [EOL] env = { [string] : [number] , [string] : [string] } [EOL] env_call . return_value = env [EOL] cmd_call . return_value = [ [string] , * args ] [EOL] [EOL] await mercurial . run_hg_command ( config , * args , repo_path = [string] ) [EOL] [EOL] env_call . assert_called_with ( ) [EOL] cmd_call . assert_called_with ( config , * args ) [EOL] assert len ( called_args ) == [number] [EOL] is_slice_in_list ( [ [string] , [string] ] , called_args [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_run_hg_command_return_output ( mocker , config ) : [EOL] args = [ [string] , [string] ] [EOL] called_args = [ ] [EOL] [EOL] expected_run_output = [string] [EOL] [EOL] async def run_command ( * arguments , ** kwargs ) : [EOL] called_args . append ( [ * arguments , kwargs ] ) [EOL] if [string] in kwargs : [EOL] with open ( kwargs [ [string] ] , [string] ) as f : [EOL] f . write ( expected_run_output ) [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] env_call = mocker . patch . object ( mercurial , [string] ) [EOL] cmd_call = mocker . patch . object ( mercurial , [string] ) [EOL] env = { [string] : [number] , [string] : [string] } [EOL] env_call . return_value = env [EOL] cmd_call . return_value = [ [string] , * args ] [EOL] [EOL] actual_run_output = await mercurial . run_hg_command ( config , * args , return_output = True ) [EOL] [EOL] env_call . assert_called_with ( ) [EOL] cmd_call . assert_called_with ( config , * args ) [EOL] assert len ( called_args ) == [number] [EOL] assert actual_run_output == expected_run_output [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_hg_version ( config , caplog ) : [EOL] caplog . set_level ( logging . INFO ) [EOL] [EOL] await mercurial . log_mercurial_version ( config ) [EOL] [EOL] assert [string] in caplog . text [EOL] assert [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_validate_robustcheckout_works ( config , mocker ) : [EOL] mocker . patch . object ( mercurial , [string] , new = noop_async ) [EOL] ret = await mercurial . validate_robustcheckout_works ( config ) [EOL] assert ret is True [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_validate_robustcheckout_works_doesnt ( config , mocker ) : [EOL] mocked = mocker . patch . object ( mercurial , [string] ) [EOL] mocked . side_effect = FailedSubprocess ( [string] ) [EOL] ret = await mercurial . validate_robustcheckout_works ( config ) [EOL] assert ret is False [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( None , [string] ) ) @ pytest . mark . asyncio async def test_checkout_repo ( config , task , mocker , branch ) : [EOL] [docstring] [EOL] calls = [ ( [string] , [string] , os . path . join ( config [ [string] ] ) ) , ( [string] , [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] if branch : [EOL] task [ [string] ] [ [string] ] = branch [EOL] [EOL] async def check_params ( * args , ** kwargs ) : [EOL] assert is_slice_in_list ( calls . pop ( [number] ) , args ) [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = check_params ) [EOL] mocker . patch . object ( mercurial , [string] ) . return_value = [string] [EOL] [EOL] config [ [string] ] = [string] [EOL] config [ [string] ] = [string] [EOL] [EOL] await mercurial . checkout_repo ( config , task , config [ [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_get_existing_tags ( config , mocker , tmpdir ) : [EOL] [docstring] [EOL] expected = { [string] : [string] , [string] : [string] } [EOL] [EOL] async def fake_hg_command ( * args , ** kwargs ) : [EOL] return [string] [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = fake_hg_command ) [EOL] assert await mercurial . get_existing_tags ( config , tmpdir ) == expected [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_check_tags ( config , mocker , tmpdir ) : [EOL] [docstring] [EOL] existing_tags = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] expected = [ [string] , [string] ] [EOL] tag_info = { [string] : [string] , [string] : [ [string] , [string] , [string] ] } [EOL] [EOL] async def get_existing_tags ( * args ) : [EOL] return existing_tags [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = get_existing_tags ) [EOL] assert await mercurial . check_tags ( config , tag_info , tmpdir ) == expected [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_do_tagging_DONTBUILD_true ( config , task , mocker ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( config , * arguments , repo_path = None , ** kwargs ) : [EOL] called_args . append ( [ tuple ( [ config ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] mocked_tag_info = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_tag_info . return_value = { [string] : [string] , [string] : [ [string] , [string] ] } [EOL] mocked_source_repo = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_source_repo . return_value = [string] [EOL] mocked_dontbuild = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_dontbuild . return_value = True [EOL] mocker . patch . object ( mercurial , [string] , new = check_tags ) [EOL] await mercurial . do_tagging ( config , task , config [ [string] ] ) [EOL] [EOL] assert len ( called_args ) == [number] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] command = called_args [ [number] ] [ [number] ] [EOL] commit_msg = command [ command . index ( [string] ) + [number] ] [EOL] assert DONTBUILD_MSG in commit_msg [EOL] assert is_slice_in_list ( ( [string] , [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] assert is_slice_in_list ( ( [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] assert is_slice_in_list ( ( [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_do_tagging_DONTBUILD_false ( config , task , mocker ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( config , * arguments , repo_path = None ) : [EOL] called_args . append ( [ tuple ( [ config ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] mocked_tag_info = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_tag_info . return_value = { [string] : [string] , [string] : [ [string] , [string] ] } [EOL] mocked_source_repo = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_source_repo . return_value = [string] [EOL] mocked_dontbuild = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_dontbuild . return_value = False [EOL] mocker . patch . object ( mercurial , [string] , new = check_tags ) [EOL] await mercurial . do_tagging ( config , task , config [ [string] ] ) [EOL] [EOL] assert len ( called_args ) == [number] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] command = called_args [ [number] ] [ [number] ] [EOL] commit_msg = command [ command . index ( [string] ) + [number] ] [EOL] assert DONTBUILD_MSG not in commit_msg [EOL] assert is_slice_in_list ( ( [string] , [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] assert is_slice_in_list ( ( [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] assert is_slice_in_list ( ( [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_do_tagging_no_tags ( config , task , mocker ) : [EOL] [docstring] [EOL] [EOL] async def check_tags ( * args ) : [EOL] return [ ] [EOL] [EOL] async def run_command ( config , * arguments , repo_path = None ) : [EOL] assert False , [string] [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] mocked_tag_info = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_tag_info . return_value = { [string] : [string] , [string] : [ [string] , [string] ] } [EOL] mocked_source_repo = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_source_repo . return_value = [string] [EOL] mocked_dontbuild = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_dontbuild . return_value = False [EOL] mocker . patch . object ( mercurial , [string] , new = check_tags ) [EOL] await mercurial . do_tagging ( config , task , config [ [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [number] ) , ( [string] , [number] , ) , ) , ) def test_count_outgoing ( output , expected ) : [EOL] assert mercurial . _count_outgoing ( output ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] ) ) @ pytest . mark . asyncio async def test_get_revision ( config , task , mocker , output ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( config , * arguments , repo_path = None , ** kwargs ) : [EOL] called_args . append ( [ tuple ( [ config ] ) + arguments , { [string] : repo_path } ] ) [EOL] if output : [EOL] return output [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] [EOL] assert output == await mercurial . get_revision ( config , config [ [string] ] , branch = [string] ) [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert is_slice_in_list ( ( [string] , [string] , [string] , [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , None ) ) @ pytest . mark . asyncio async def test_log_outgoing ( config , task , mocker , output ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( config , * arguments , repo_path = None , ** kwargs ) : [EOL] called_args . append ( [ tuple ( [ config ] ) + arguments , { [string] : repo_path } ] ) [EOL] if output : [EOL] return output [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] mocked_source_repo = mocker . patch . object ( mercurial , [string] ) [EOL] mocked_source_repo . return_value = [string] [EOL] await mercurial . log_outgoing ( config , task , config [ [string] ] ) [EOL] [EOL] assert len ( called_args ) == [number] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert is_slice_in_list ( ( [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] assert is_slice_in_list ( ( [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] if output : [EOL] with open ( os . path . join ( config [ [string] ] , [string] , [string] , [string] ) , [string] ) as fh : [EOL] assert fh . read ( ) . rstrip ( ) == output [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_strip_outgoing ( config , task , mocker ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( config , * arguments , repo_path = None , ** kwargs ) : [EOL] called_args . append ( [ tuple ( [ config ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] await mercurial . strip_outgoing ( config , task , config [ [string] ] ) [EOL] [EOL] assert len ( called_args ) == [number] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert is_slice_in_list ( ( [string] , [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( None , None ) , ( [string] , None ) , ( None , [string] ) ) ) async def test_push ( config , task , mocker , tmpdir , source_repo , revision ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( config , * arguments , repo_path = None , ** kwargs ) : [EOL] called_args . append ( [ tuple ( [ config ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] await mercurial . push ( config , task , tmpdir , [string] , revision ) [EOL] [EOL] assert len ( called_args ) == [number] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert is_slice_in_list ( ( [string] , [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert [string] not in called_args [ [number] ] [ [number] ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( { [string] : { [string] : { [string] : [string] } } } , [string] ) , ( { [string] : { [string] : { [string] : [string] } } } , [string] ) , ( { [string] : { [string] : { [string] : [string] , [string] : [string] } } } , [string] ) , ) , ) async def test_push_ssh ( config , task , mocker , options , expect , tmpdir ) : [EOL] called_args = [ ] [EOL] [EOL] async def run_command ( config , * arguments , repo_path = None , ** kwargs ) : [EOL] called_args . append ( [ tuple ( [ config ] ) + arguments , { [string] : repo_path } ] ) [EOL] [EOL] print ( ) [EOL] config . update ( options ) [EOL] mocker . patch . object ( mercurial , [string] , new = run_command ) [EOL] await mercurial . push ( config , task , tmpdir , [string] ) [EOL] [EOL] assert len ( called_args ) == [number] [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert is_slice_in_list ( ( [string] , [string] ) , called_args [ [number] ] [ [number] ] ) [EOL] assert [string] in called_args [ [number] ] [ [number] ] [EOL] assert is_slice_in_list ( ( [string] , [string] , expect ) , called_args [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_push_fail ( config , task , mocker , tmpdir ) : [EOL] [docstring] [EOL] called_args = [ ] [EOL] [EOL] async def blow_up ( * args , ** kwargs ) : [EOL] raise PushError ( [string] ) [EOL] [EOL] async def clean_up ( * args ) : [EOL] assert args == ( config , task , tmpdir ) [EOL] called_args . append ( args ) [EOL] [EOL] mocker . patch . object ( mercurial , [string] , new = blow_up ) [EOL] mocker . patch . object ( mercurial , [string] , new = clean_up ) [EOL] with pytest . raises ( PushError ) : [EOL] await mercurial . push ( config , task , tmpdir , [string] ) [EOL] assert len ( called_args ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Literal , Union , Dict , List [EOL] import typing [EOL] import typing_extensions [EOL] import json [EOL] import tempfile [EOL] [EOL] import pytest [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] import beetmoverscript . utils as butils [EOL] from beetmoverscript . constants import BUILDHUB_ARTIFACT , HASH_BLOCK_SIZE , INSTALLER_ARTIFACTS [EOL] from beetmoverscript . utils import ( _check_locale_consistency , exists_or_endswith , extract_file_config_from_artifact_map , extract_full_artifact_map_path , generate_beetmover_manifest , generate_beetmover_template_args , get_candidates_prefix , get_hash , get_partials_props , get_partner_candidates_prefix , get_partner_match , get_partner_releases_prefix , get_product_name , get_releases_prefix , is_partner_private_task , is_partner_public_task , is_promotion_action , is_release_action , matches_exclude , validated_task_id , write_file , write_json , ) [EOL] [EOL] from . import get_fake_checksums_manifest , get_fake_valid_task , get_test_jinja_env [EOL] [EOL] [EOL] [comment] [EOL] def test_get_hash ( ) : [EOL] correct_sha1s = ( [string] , [string] ) [EOL] text = [string] [EOL] [EOL] with tempfile . NamedTemporaryFile ( delete = True ) as fp : [EOL] [comment] [EOL] [comment] [EOL] count = int ( HASH_BLOCK_SIZE / len ( text ) ) * [number] [EOL] for i in range ( count ) : [EOL] fp . write ( text ) [EOL] sha1digest = get_hash ( fp . name , hash_type = [string] ) [EOL] [EOL] assert sha1digest in correct_sha1s [EOL] [EOL] [EOL] [comment] [EOL] def test_write_json ( ) : [EOL] sample_data = get_fake_valid_task ( ) [ [string] ] [ [string] ] [EOL] [EOL] with tempfile . NamedTemporaryFile ( delete = True ) as fp : [EOL] write_json ( fp . name , sample_data ) [EOL] [EOL] with open ( fp . name , [string] ) as fread : [EOL] retrieved_data = json . load ( fread ) [EOL] [EOL] assert sample_data == retrieved_data [EOL] [EOL] [EOL] [comment] [EOL] def test_write_file ( ) : [EOL] sample_data = [string] . join ( get_fake_checksums_manifest ( ) ) [EOL] [EOL] with tempfile . NamedTemporaryFile ( delete = True ) as fp : [EOL] write_file ( fp . name , sample_data ) [EOL] [EOL] with open ( fp . name , [string] ) as fread : [EOL] retrieved_data = fread . read ( ) [EOL] [EOL] assert sample_data == retrieved_data [EOL] [EOL] [EOL] [comment] [EOL] def test_generate_manifest ( context , mocker ) : [EOL] mocker . patch ( [string] , get_test_jinja_env ( ) ) [EOL] manifest = generate_beetmover_manifest ( context ) [EOL] mapping = manifest [ [string] ] [EOL] s3_keys = [ mapping [ m ] . get ( [string] , { } ) . get ( [string] ) for m in mapping ] [EOL] assert sorted ( mapping . keys ( ) ) == [ [string] , [string] ] [EOL] assert sorted ( s3_keys ) == [ [string] , [string] ] [EOL] [EOL] expected_destinations = { [string] : [ [string] , [string] , ] , [string] : [ [string] , [string] , ] , } [EOL] [EOL] actual_destinations = { k : mapping [ k ] [ [string] ] [ [string] ] for k in sorted ( mapping . keys ( ) ) } [EOL] [EOL] assert expected_destinations == actual_destinations [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , { } ) , ( [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } } , ) , ] , ) def test_beetmover_template_args_generation ( context , taskjson , partials ) : [EOL] context . task = get_fake_valid_task ( taskjson ) [EOL] expected_template_args = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : partials , [string] : [ [string] ] , } [EOL] [EOL] template_args = generate_beetmover_template_args ( context ) [EOL] assert template_args == expected_template_args [EOL] [EOL] context . task [ [string] ] [ [string] ] = [string] [EOL] context . task [ [string] ] [ [string] ] [ [number] ] [ [string] ] = [string] [EOL] expected_template_args [ [string] ] = [string] [EOL] expected_template_args [ [string] ] = [ [string] ] [EOL] template_args = generate_beetmover_template_args ( context ) [EOL] assert template_args == expected_template_args [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } ] } , None ) , ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } , [ [string] ] ) , ( { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } , [ [string] ] ) , ( { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } , [ [string] ] ) , ( { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , ] } , [ [string] , [string] ] , ) , ( { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } ] } , [ [string] ] ) , ) , ) def test_beetmover_template_args_locales ( context , payload , expected_locales ) : [EOL] context . task = get_fake_valid_task ( [string] ) [EOL] context . task [ [string] ] = payload [EOL] context . task [ [string] ] [ [string] ] = [string] [EOL] [EOL] template_args = generate_beetmover_template_args ( context ) [EOL] if expected_locales : [EOL] assert [string] not in template_args [comment] [EOL] assert template_args [ [string] ] == expected_locales [EOL] else : [EOL] assert [string] not in template_args [EOL] assert [string] not in template_args [EOL] [EOL] [EOL] def test_beetmover_template_args_fennec_nightly ( context ) : [EOL] [docstring] [EOL] context . task = get_fake_valid_task ( [string] ) [EOL] template_args = generate_beetmover_template_args ( context ) [EOL] assert [string] not in template_args [EOL] assert template_args [ [string] ] == [ [string] , [string] ] [EOL] assert template_args [ [string] ] == [string] [EOL] [EOL] [EOL] def test_beetmover_template_args_generation_release ( context ) : [EOL] context . bucket = [string] [EOL] context . action = [string] [EOL] context . task [ [string] ] [ [string] ] = [number] [EOL] context . task [ [string] ] [ [string] ] = [string] [EOL] [EOL] expected_template_args = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { } , [string] : [number] , [string] : [ [string] ] , } [EOL] [EOL] template_args = generate_beetmover_template_args ( context ) [EOL] assert template_args == expected_template_args [EOL] [EOL] [EOL] def test_beetmover_template_args_generation_release_is_jar ( context ) : [EOL] context . bucket = [string] [EOL] context . action = [string] [EOL] context . task [ [string] ] [ [string] ] = [string] [EOL] context . task [ [string] ] [ [string] ] = [string] [EOL] context . task [ [string] ] [ [string] ] = True [EOL] [EOL] expected_template_args = { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] } [EOL] [EOL] template_args = generate_beetmover_template_args ( context ) [EOL] assert template_args == expected_template_args [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] , [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , [string] , None , [string] , False ) , ( [string] , [string] , [string] , [string] , None , [string] , False ) , ( [string] , [string] , [string] , [string] , None , None , True ) , ) , ) def test_beetmover_template_args_maven ( product , context , branch , version , artifact_id , build_id , expected_version , raises ) : [EOL] context . bucket = [string] [EOL] context . action = [string] [EOL] context . task [ [string] ] [ [string] ] = version [EOL] context . task [ [string] ] [ [string] ] = artifact_id [EOL] context . release_props [ [string] ] = branch [EOL] context . release_props [ [string] ] = build_id [EOL] context . release_props [ [string] ] = product [EOL] [EOL] if not raises : [EOL] assert generate_beetmover_template_args ( context ) == { [string] : artifact_id , [string] : [string] . format ( product ) , [string] : None , [string] : expected_version , } [EOL] else : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] generate_beetmover_template_args ( context ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [ ] , False ) , ( [string] , [ [string] ] , False ) , ( [string] , [ [string] ] , False ) , ( [string] , [ [string] ] , True ) , ( [string] , [ [string] , [string] ] , True ) ) , ) def test_check_locale_consistency ( locale_in_payload , locales_in_upstream_artifacts , raises ) : [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] _check_locale_consistency ( locale_in_payload , locales_in_upstream_artifacts ) [EOL] else : [EOL] _check_locale_consistency ( locale_in_payload , locales_in_upstream_artifacts ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , False , False ) , ( [string] , False , True ) , ( [string] , True , False ) ) ) def test_is_action_release_or_promotion ( action , release , promotion ) : [EOL] assert is_release_action ( action ) is release [EOL] assert is_promotion_action ( action ) is promotion [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , { } ) , ( [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } } , ) , ] , ) def test_get_partials_props ( taskjson , expected ) : [EOL] partials_props = get_partials_props ( get_fake_valid_task ( taskjson ) ) [EOL] assert partials_props == expected [EOL] [EOL] [EOL] [comment] [EOL] def test_alter_unpretty_contents ( context , mocker ) : [EOL] context . artifacts_to_beetmove = { [string] : { [string] : [string] } , [string] : { [string] : [string] } } [EOL] [EOL] mappings = { [string] : { [string] : { [string] : { [string] : [string] } } , [string] : { } } } [EOL] [EOL] def fake_json ( * args , ** kwargs ) : [EOL] return { [string] : [ [string] ] } [EOL] [EOL] mocker . patch . object ( butils , [string] , new = fake_json ) [EOL] mocker . patch . object ( butils , [string] , new = fake_json ) [EOL] butils . alter_unpretty_contents ( context , [ [string] ] , mappings ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] , [string] ) , ( [string] , [string] , [number] , [string] ) ) , ) def test_get_candidates_prefix ( product , version , build_number , expected ) : [EOL] assert get_candidates_prefix ( product , version , build_number ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ) ) def test_get_releases_prefix ( product , version , expected ) : [EOL] assert get_releases_prefix ( product , version ) == expected [EOL] [EOL] [EOL] [comment] [EOL] def test_get_partner_candidates_prefix ( ) : [EOL] assert get_partner_candidates_prefix ( [string] , [string] ) == [string] [EOL] [EOL] [EOL] [comment] [EOL] def test_get_partner_releases_prefix ( ) : [EOL] expected = [string] [EOL] assert get_partner_releases_prefix ( [string] , [string] , [string] ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , True ) , ( [string] , True ) , ( [string] , False ) ) ) def test_matches_exclude ( keyname , expected ) : [EOL] excludes = [ [string] , [string] ] [EOL] assert matches_exclude ( keyname , excludes ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [ ] , None ) , ( [string] , [ [string] ] , [string] ) , ( [string] , [ [string] , [string] ] , [string] ) , ( [string] , [ [string] , [string] ] , [string] ) , ( [string] , [ [string] , [string] ] , None ) , ) , ) def test_get_partner_match ( keyname , partners , expected ) : [EOL] assert get_partner_match ( keyname , [string] , partners ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) , ) def test_get_product_name ( appName , tmpl_key , expected ) : [EOL] assert get_product_name ( appName , tmpl_key ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , False , False ) , ( [string] , [string] , False , False ) , ( [string] , [string] , True , False ) , ( [string] , [string] , False , True ) , ) , ) def test_is_partner_private_public_task ( context , action , bucket , expected_private , expected_public ) : [EOL] context . action = action [EOL] context . bucket = bucket [EOL] [EOL] assert is_partner_private_task ( context ) == expected_private [EOL] assert is_partner_public_task ( context ) == expected_public [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) def test_validated_task_id ( task_id ) : [EOL] assert validated_task_id ( task_id ) == task_id [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) def test_validated_task_id_raises ( task_id ) : [EOL] with pytest . raises ( ValueError ) : [EOL] validated_task_id ( task_id ) [EOL] [EOL] [EOL] def test_extract_file_config_from_artifact_map ( ) : [EOL] task_def = get_fake_valid_task ( taskjson = [string] ) [EOL] task_id = [string] [EOL] locale = [string] [EOL] filename = [string] [EOL] expected = { [string] : [ [string] , [string] , ] , [string] : [string] , [string] : [number] , [string] : True , } [EOL] assert extract_file_config_from_artifact_map ( task_def [ [string] ] [ [string] ] , filename , task_id , locale ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) , ) def test_extract_file_config_from_artifact_map_raises ( task_id , locale , filename ) : [EOL] task_def = get_fake_valid_task ( taskjson = [string] ) [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] extract_file_config_from_artifact_map ( task_def [ [string] ] [ [string] ] , filename , task_id , locale ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] ) , ( [string] , [string] , None ) , ( [string] , [string] , None ) , ( [string] , [string] , None ) ) ) def test_extract_full_artifact_map_path ( path , locale , found ) : [EOL] task_def = get_fake_valid_task ( taskjson = [string] ) [EOL] assert extract_full_artifact_map_path ( task_def [ [string] ] [ [string] ] , path , locale ) == found [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , INSTALLER_ARTIFACTS , True ) , ( [string] , INSTALLER_ARTIFACTS , True ) , ( [string] , INSTALLER_ARTIFACTS , False ) , ( [string] , INSTALLER_ARTIFACTS , False ) , ( [string] , INSTALLER_ARTIFACTS , True ) , ( [string] , INSTALLER_ARTIFACTS , False ) , ( [string] , BUILDHUB_ARTIFACT , True ) , ( [string] , BUILDHUB_ARTIFACT , True ) , ( [string] , BUILDHUB_ARTIFACT , True ) , ( [string] , BUILDHUB_ARTIFACT , False ) , ( [string] , BUILDHUB_ARTIFACT , False ) , ( [string] , BUILDHUB_ARTIFACT , False ) , ) , ) def test_exists_or_endswith ( filename , basenames , expected ) : [EOL] assert exists_or_endswith ( filename , basenames ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Literal , Union , Dict , List [EOL] import mock [EOL] import typing [EOL] import typing_extensions [EOL] import logging [EOL] import mimetypes [EOL] import os [EOL] [EOL] import boto3 [EOL] import mock [EOL] import pytest [EOL] from scriptworker . context import Context [EOL] from scriptworker . exceptions import ScriptWorkerRetryException , ScriptWorkerTaskException [EOL] from yarl import URL [EOL] [EOL] import beetmoverscript . script [EOL] from beetmoverscript . constants import PARTNER_REPACK_PRIVATE_REGEXES , PARTNER_REPACK_PUBLIC_REGEXES [EOL] from beetmoverscript . script import ( async_main , copy_beets , enrich_balrog_manifest , get_destination_for_partner_repack_path , list_bucket_objects , main , move_beet , move_beets , move_partner_beets , push_to_partner , push_to_releases , put , sanity_check_partner_path , setup_mimetypes , ) [EOL] from beetmoverscript . task import get_release_props , get_upstream_artifacts [EOL] from beetmoverscript . utils import generate_beetmover_manifest , is_promotion_action [EOL] [EOL] from . import get_fake_valid_config , get_fake_valid_task , get_test_jinja_env , noop_async , noop_sync [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_push_to_partner ( context , mocker ) : [EOL] mocker . patch ( [string] , new = noop_async ) [EOL] mocker . patch ( [string] , get_test_jinja_env ( ) ) [EOL] await push_to_partner ( context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [string] , [string] : [string] } , { } , None ) , ( { [string] : [string] , [string] : [string] } , { [string] : [number] } , None ) , ( { } , { [string] : [number] } , ScriptWorkerTaskException ) ) , ) @ pytest . mark . asyncio async def test_push_to_releases ( context , mocker , candidates_keys , releases_keys , exception_type ) : [EOL] context . task = { [string] : { [string] : [string] , [string] : [number] , [string] : [string] } } [EOL] [EOL] objects = [ candidates_keys , releases_keys ] [EOL] [EOL] def check ( _ , _2 , r ) : [EOL] assert r == releases_keys [EOL] [EOL] def fake_list ( * args ) : [EOL] return objects . pop ( [number] ) [EOL] [EOL] mocker . patch . object ( boto3 , [string] ) [EOL] mocker . patch . object ( beetmoverscript . script , [string] , new = fake_list ) [EOL] mocker . patch . object ( beetmoverscript . script , [string] , new = check ) [EOL] [EOL] if exception_type is not None : [EOL] with pytest . raises ( exception_type ) : [EOL] await push_to_releases ( context ) [EOL] else : [EOL] await push_to_releases ( context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , True ) ) ) def test_copy_beets ( context , mocker , releases_keys , raises ) : [EOL] called_with = [ ] [EOL] [EOL] def fake_copy_object ( ** kwargs ) : [EOL] called_with . append ( kwargs ) [EOL] [EOL] boto_client = mock . MagicMock ( ) [EOL] boto_client . copy_object = fake_copy_object [EOL] mocker . patch . object ( boto3 , [string] , return_value = boto_client ) [EOL] context . artifacts_to_beetmove = { [string] : [string] , [string] : [string] } [EOL] candidates_keys = { [string] : [string] , [string] : [string] } [EOL] context . bucket_name = [string] [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] copy_beets ( context , candidates_keys , releases_keys ) [EOL] else : [EOL] copy_beets ( context , candidates_keys , releases_keys ) [EOL] a = { [string] : context . bucket_name , [string] : { [string] : context . bucket_name , [string] : [string] } , [string] : [string] } [EOL] b = { [string] : context . bucket_name , [string] : { [string] : context . bucket_name , [string] : [string] } , [string] : [string] } [EOL] if releases_keys : [EOL] expected = [ [ a ] ] [EOL] else : [EOL] [comment] [EOL] expected = [ [ a , b ] , [ b , a ] ] [EOL] assert called_with in expected [EOL] [EOL] [EOL] [comment] [EOL] def test_list_bucket_objects ( ) : [EOL] bucket = mock . MagicMock ( ) [EOL] s3_resource = mock . MagicMock ( ) [EOL] [EOL] def fake_bucket ( _ ) : [EOL] return bucket [EOL] [EOL] def fake_filter ( ** kwargs ) : [EOL] one = mock . MagicMock ( ) [EOL] two = mock . MagicMock ( ) [EOL] one . key = [string] [EOL] one . e_tag = [string] [EOL] two . key = [string] [EOL] two . e_tag = [string] [EOL] return [ one , two ] [EOL] [EOL] s3_resource . Bucket = fake_bucket [EOL] bucket . objects . filter = fake_filter [EOL] [EOL] assert list_bucket_objects ( mock . MagicMock ( ) , s3_resource , None ) == { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] [comment] [EOL] def test_setup_mimetypes ( ) : [EOL] non_default_types = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] assert [ mimetypes . guess_type ( url ) [ [number] ] for url in non_default_types ] == [ None , None ] [EOL] [EOL] setup_mimetypes ( ) [EOL] [EOL] [comment] [EOL] assert sorted ( [ mimetypes . guess_type ( url ) [ [number] ] for url in non_default_types ] ) == [ [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_put_success ( fake_session ) : [EOL] context = Context ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . session = fake_session [EOL] response = await put ( context , url = URL ( [string] ) , headers = { } , abs_filename = [string] , session = fake_session ) [EOL] assert response . status == [number] [EOL] assert response . resp == [ [string] , [string] ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_put_failure ( fake_session_500 ) : [EOL] context = Context ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . session = fake_session_500 [EOL] with pytest . raises ( ScriptWorkerRetryException ) : [EOL] await put ( context , url = URL ( [string] ) , headers = { } , abs_filename = [string] , session = fake_session_500 ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ) ) def test_enrich_balrog_manifest ( context , branch , action ) : [EOL] context . task [ [string] ] [ [string] ] = [number] [EOL] context . task [ [string] ] [ [string] ] = [string] [EOL] context . action = action [EOL] context . release_props [ [string] ] = branch [EOL] [EOL] expected_data = { [string] : context . release_props [ [string] ] , [string] : context . release_props [ [string] ] , [string] : context . release_props [ [string] ] , [string] : context . release_props [ [string] ] , [string] : context . release_props [ [string] ] , [string] : context . release_props [ [string] ] , [string] : [string] , [string] : context . release_props [ [string] ] , [string] : [ ] , } [EOL] if branch != [string] : [EOL] expected_data [ [string] ] = [ [ [string] , [string] ] ] [EOL] if action != [string] : [EOL] expected_data [ [string] ] = True [EOL] expected_data [ [string] ] = [number] [EOL] expected_data [ [string] ] = [string] [EOL] else : [EOL] expected_data [ [string] ] = True [EOL] [EOL] data = enrich_balrog_manifest ( context , [string] ) [EOL] assert data == expected_data [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_retry_upload ( context , mocker ) : [EOL] mocker . patch . object ( beetmoverscript . script , [string] , new = noop_async ) [EOL] await beetmoverscript . script . retry_upload ( context , [ [string] , [string] ] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_upload_to_s3 ( context , mocker ) : [EOL] context . release_props [ [string] ] = [string] [EOL] mocker . patch . object ( beetmoverscript . script , [string] , new = noop_async ) [EOL] mocker . patch . object ( beetmoverscript . script , [string] ) [EOL] await beetmoverscript . script . upload_to_s3 ( context , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_upload_to_s3_raises ( context , mocker ) : [EOL] context . release_props [ [string] ] = [string] [EOL] mocker . patch . object ( beetmoverscript . script , [string] , new = noop_async ) [EOL] mocker . patch . object ( beetmoverscript . script , [string] ) [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await beetmoverscript . script . upload_to_s3 ( context , [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) @ pytest . mark . parametrize ( [string] , ( False , True ) ) async def test_move_beets ( task_filename , partials , mocker ) : [EOL] mocker . patch ( [string] , get_test_jinja_env ( ) ) [EOL] [EOL] context = Context ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . task = get_fake_valid_task ( taskjson = task_filename ) [EOL] context . release_props = context . task [ [string] ] [ [string] ] [EOL] context . release_props [ [string] ] = context . release_props [ [string] ] [EOL] context . bucket = [string] [EOL] context . action = [string] [EOL] context . raw_balrog_manifest = dict ( ) [EOL] context . balrog_manifest = list ( ) [EOL] context . artifacts_to_beetmove = get_upstream_artifacts ( context ) [EOL] if context . task [ [string] ] . get ( [string] ) : [EOL] artifact_map = context . task [ [string] ] . get ( [string] ) [EOL] manifest = None [EOL] else : [EOL] artifact_map = None [EOL] manifest = generate_beetmover_manifest ( context ) [EOL] [EOL] expected_sources = [ os . path . abspath ( [string] ) , os . path . abspath ( [string] ) , os . path . abspath ( [string] ) , os . path . abspath ( [string] ) , os . path . abspath ( [string] ) , os . path . abspath ( [string] ) , ] [EOL] expected_destinations = [ [ [string] , [string] , ] , [ [string] , [string] , ] , [ [string] , [string] , ] , [ [string] , [string] , ] , [ [string] , [string] , ] , [ [string] , [string] , ] , ] [EOL] [EOL] expected_balrog_manifest = [ ] [EOL] for complete_info in [ { [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] , } ] } , { [string] : [string] , [string] : [ { [string] : [string] , [string] : [number] , [string] : [string] , } ] , } , ] : [EOL] entry = { [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , } [EOL] entry . update ( complete_info ) [EOL] if partials : [EOL] entry [ [string] ] = [ { [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] , } ] [EOL] expected_balrog_manifest . append ( entry ) [EOL] [EOL] actual_sources = [ ] [EOL] actual_destinations = [ ] [EOL] [EOL] def sort_manifest ( manifest ) : [EOL] manifest . sort ( key = lambda entry : entry . get ( [string] , [string] ) ) [EOL] [EOL] async def fake_move_beet ( context , source , destinations , locale , update_balrog_manifest , balrog_format , artifact_pretty_name , from_buildid ) : [EOL] actual_sources . append ( source ) [EOL] actual_destinations . append ( destinations ) [EOL] if update_balrog_manifest : [EOL] [EOL] data = { [string] : [string] , [string] : [number] , [string] : destinations [ [number] ] } [EOL] context . raw_balrog_manifest . setdefault ( locale , { } ) [EOL] if from_buildid : [EOL] if partials : [EOL] data [ [string] ] = from_buildid [EOL] context . raw_balrog_manifest [ locale ] . setdefault ( [string] , [ ] ) . append ( data ) [EOL] else : [EOL] return [EOL] else : [EOL] context . raw_balrog_manifest [ locale ] . setdefault ( [string] , { } ) [ balrog_format ] = data [EOL] [EOL] with mock . patch ( [string] , fake_move_beet ) : [EOL] await move_beets ( context , context . artifacts_to_beetmove , manifest = manifest , artifact_map = artifact_map ) [EOL] [EOL] assert sorted ( expected_sources ) == sorted ( actual_sources ) [EOL] assert sorted ( expected_destinations ) == sorted ( actual_destinations ) [EOL] [EOL] [comment] [EOL] sort_manifest ( context . balrog_manifest ) [EOL] sort_manifest ( expected_balrog_manifest ) [EOL] assert context . balrog_manifest == expected_balrog_manifest [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_move_beets_raises ( mocker ) : [EOL] mocker . patch ( [string] , get_test_jinja_env ( ) ) [EOL] [EOL] context = Context ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . task = get_fake_valid_task ( taskjson = [string] ) [EOL] context . release_props = context . task [ [string] ] [ [string] ] [EOL] context . release_props [ [string] ] = context . release_props [ [string] ] [EOL] context . bucket = [string] [EOL] context . action = [string] [EOL] context . raw_balrog_manifest = dict ( ) [EOL] context . balrog_manifest = list ( ) [EOL] context . artifacts_to_beetmove = get_upstream_artifacts ( context ) [EOL] [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await move_beets ( context , context . artifacts_to_beetmove , manifest = None , artifact_map = None ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( True , [string] ) , ( True , [string] ) , ( False , [string] ) , ( False , [string] ) ] ) async def test_move_beet ( update_manifest , action ) : [EOL] context = Context ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . task = get_fake_valid_task ( ) [EOL] context . task [ [string] ] = dict ( ) [EOL] context . task [ [string] ] [ [string] ] = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] [EOL] context . action = action [EOL] context . bucket = [string] [EOL] context . checksums = dict ( ) [EOL] context . balrog_manifest = list ( ) [EOL] context . raw_balrog_manifest = dict ( ) [EOL] context . release_props = context . task [ [string] ] [ [string] ] [EOL] locale = [string] [EOL] [EOL] target_source = [string] [EOL] pretty_name = [string] [EOL] target_destinations = ( [string] , [string] , ) [EOL] expected_upload_args = [ ( [string] , [string] , ) , [string] , ] [EOL] expected_balrog_manifest = { [string] : [string] , [string] : [number] , [string] : [string] , } [EOL] actual_upload_args = [ ] [EOL] [EOL] async def fake_retry_upload ( context , destinations , path ) : [EOL] actual_upload_args . extend ( [ destinations , path ] ) [EOL] [EOL] with mock . patch ( [string] , fake_retry_upload ) : [EOL] await move_beet ( context , target_source , target_destinations , locale , update_balrog_manifest = update_manifest , balrog_format = [string] , artifact_pretty_name = pretty_name , from_buildid = None , ) [EOL] assert expected_upload_args == actual_upload_args [EOL] if update_manifest : [EOL] for k in expected_balrog_manifest . keys ( ) : [EOL] assert context . raw_balrog_manifest [ locale ] [ [string] ] [ [string] ] [ k ] == expected_balrog_manifest [ k ] [EOL] [EOL] expected_balrog_manifest [ [string] ] = [string] [EOL] with mock . patch ( [string] , fake_retry_upload ) : [EOL] await move_beet ( context , target_source , target_destinations , locale , update_balrog_manifest = update_manifest , balrog_format = [string] , artifact_pretty_name = pretty_name , from_buildid = [string] , ) [EOL] if update_manifest : [EOL] if is_promotion_action ( context . action ) : [EOL] expected_balrog_manifest [ [string] ] = [string] [EOL] expected_balrog_manifest [ [string] ] = [string] [EOL] for k in expected_balrog_manifest . keys ( ) : [EOL] assert context . raw_balrog_manifest [ locale ] [ [string] ] [ [number] ] [ k ] == expected_balrog_manifest [ k ] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_move_partner_beets ( context , mocker ) : [EOL] context . artifacts_to_beetmove = get_upstream_artifacts ( context , preserve_full_paths = True ) [EOL] context . release_props = get_release_props ( context ) [EOL] mocker . patch ( [string] , get_test_jinja_env ( ) ) [EOL] mapping_manifest = generate_beetmover_manifest ( context ) [EOL] [EOL] mocker . patch . object ( beetmoverscript . script , [string] , new = noop_sync ) [EOL] mocker . patch . object ( beetmoverscript . script , [string] , new = noop_async ) [EOL] await move_partner_beets ( context , mapping_manifest ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] , False , [string] , ) , ( [string] , [string] , [string] , True , [string] , ) , ( [string] , [string] , [string] , False , [string] , ) , ) , ) def test_get_destination_for_partner_repack_path ( context , full_path , expected , bucket , raises , locale ) : [EOL] context . bucket = bucket [EOL] context . action = [string] [EOL] context . task [ [string] ] [ [string] ] = [number] [EOL] context . task [ [string] ] [ [string] ] = [string] [EOL] context . task [ [string] ] [ [string] ] = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [comment] [EOL] for artifact_dict in context . task [ [string] ] [ [string] ] : [EOL] artifact_dict [ [string] ] = locale [EOL] context . artifacts_to_beetmove = get_upstream_artifacts ( context , preserve_full_paths = True ) [EOL] context . release_props = get_release_props ( context ) [EOL] mapping_manifest = generate_beetmover_manifest ( context ) [EOL] [EOL] if raises : [EOL] context . action = [string] [EOL] with pytest . raises ( ScriptWorkerRetryException ) : [EOL] get_destination_for_partner_repack_path ( context , mapping_manifest , full_path , locale ) [EOL] else : [EOL] assert expected == get_destination_for_partner_repack_path ( context , mapping_manifest , full_path , locale ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , True , PARTNER_REPACK_PRIVATE_REGEXES ) , ( [string] , False , PARTNER_REPACK_PRIVATE_REGEXES ) , ( [string] , True , PARTNER_REPACK_PRIVATE_REGEXES ) , ( [string] , True , PARTNER_REPACK_PRIVATE_REGEXES ) , ( [string] , True , PARTNER_REPACK_PRIVATE_REGEXES ) , ( [string] , False , PARTNER_REPACK_PUBLIC_REGEXES ) , ( [string] , True , PARTNER_REPACK_PUBLIC_REGEXES ) , ( [string] , False , PARTNER_REPACK_PUBLIC_REGEXES ) , ( [string] , True , PARTNER_REPACK_PUBLIC_REGEXES ) , ( [string] , True , PARTNER_REPACK_PUBLIC_REGEXES ) , ) , ) def test_sanity_check_partner_path ( path , raises , regexes ) : [EOL] repl_dict = { [string] : [string] , [string] : [number] } [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] sanity_check_partner_path ( path , repl_dict , regexes ) [EOL] else : [EOL] sanity_check_partner_path ( path , repl_dict , regexes ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , False , [string] ) , ( [string] , False , [string] ) , ( [string] , True , [string] ) ) , ) @ pytest . mark . asyncio async def test_async_main ( context , mocker , action , raises , task_filename ) : [EOL] context . action = action [EOL] context . task = get_fake_valid_task ( taskjson = task_filename ) [EOL] [EOL] def fake_action ( * args , ** kwargs ) : [EOL] return action [EOL] [EOL] mocker . patch ( [string] , get_test_jinja_env ( ) ) [EOL] mocker . patch ( [string] , new = noop_async ) [EOL] mocker . patch . object ( beetmoverscript . script , [string] , new = fake_action ) [EOL] if raises : [EOL] with pytest . raises ( SystemExit ) : [EOL] await async_main ( context ) [EOL] else : [EOL] await async_main ( context ) [EOL] [EOL] for module in ( [string] , [string] , [string] ) : [EOL] assert logging . getLogger ( module ) . level == logging . INFO [EOL] [EOL] [EOL] [comment] [EOL] def test_main ( fake_session ) : [EOL] context = Context ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] [EOL] async def fake_async_main ( context ) : [EOL] pass [EOL] [EOL] async def fake_async_main_with_exception ( context ) : [EOL] raise ScriptWorkerTaskException ( [string] ) [EOL] [EOL] with mock . patch ( [string] , new = fake_async_main ) : [EOL] main ( config_path = [string] ) [EOL] [EOL] with mock . patch ( [string] , new = fake_async_main_with_exception ) : [EOL] try : [EOL] main ( config_path = [string] ) [EOL] except SystemExit as exc : [EOL] assert exc . code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import mock [EOL] import typing [EOL] import beetmoverscript [EOL] import asyncio [EOL] import functools [EOL] import json [EOL] [EOL] import aiohttp [EOL] import mock [EOL] import pytest [EOL] from scriptworker . context import Context [EOL] [EOL] from . import get_fake_valid_config , get_fake_valid_task [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def context ( ) : [EOL] context = Context ( ) [EOL] context . task = get_fake_valid_task ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . release_props = context . task [ [string] ] [ [string] ] [EOL] context . release_props [ [string] ] = context . release_props [ [string] ] [EOL] [EOL] context . bucket = [string] [EOL] context . action = [string] [EOL] yield context [EOL] [EOL] [EOL] class FakeResponse ( aiohttp . client_reqrep . ClientResponse ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , status = [number] , payload = None , ** kwargs ) : [EOL] self . _connection = mock . MagicMock ( ) [EOL] self . _payload = payload or { } [EOL] self . status = status [EOL] self . _headers = { [string] : [string] } [EOL] self . _cache = { } [EOL] self . _loop = mock . MagicMock ( ) [EOL] self . content = self [EOL] self . resp = [ [string] , [string] ] [EOL] self . _url = args [ [number] ] [EOL] self . _history = ( ) [EOL] [EOL] @ asyncio . coroutine def text ( self , * args , ** kwargs ) : [EOL] return json . dumps ( self . _payload ) [EOL] [EOL] @ asyncio . coroutine def json ( self , * args , ** kwargs ) : [EOL] return self . _payload [EOL] [EOL] @ asyncio . coroutine def release ( self ) : [EOL] return [EOL] [EOL] async def read ( self , * args ) : [EOL] if self . resp : [EOL] return self . resp . pop ( [number] ) [EOL] [EOL] [EOL] @ asyncio . coroutine def _fake_request ( resp_status , method , url , * args , ** kwargs ) : [EOL] resp = FakeResponse ( method , url , status = resp_status ) [EOL] resp . _history = ( FakeResponse ( method , url , status = [number] ) , ) [EOL] return resp [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . fixture ( scope = [string] ) async def fake_session ( ) : [EOL] session = aiohttp . ClientSession ( ) [EOL] session . _request = functools . partial ( _fake_request , [number] ) [EOL] yield session [EOL] await session . close ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . fixture ( scope = [string] ) async def fake_session_500 ( ) : [EOL] session = aiohttp . ClientSession ( ) [EOL] session . _request = functools . partial ( _fake_request , [number] ) [EOL] yield session [EOL] await session . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import jinja2 [EOL] [EOL] from beetmoverscript . utils import load_json [EOL] [EOL] [EOL] def noop_sync ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] async def noop_async ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] def get_fake_valid_config ( ) : [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] config . update ( load_json ( path = [string] ) ) [EOL] return config [EOL] [EOL] [EOL] def get_fake_valid_task ( taskjson = [string] ) : [EOL] return load_json ( path = [string] . format ( taskjson ) ) [EOL] [EOL] [EOL] def get_fake_checksums_manifest ( ) : [EOL] return ( [string] [string] ) [EOL] [EOL] [EOL] def get_test_jinja_env ( ) : [EOL] return jinja2 . Environment ( loader = jinja2 . PackageLoader ( [string] ) , undefined = jinja2 . StrictUndefined ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict [EOL] import typing [EOL] import json [EOL] import os [EOL] import tempfile [EOL] [EOL] import pytest [EOL] from scriptworker . context import Context [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] from beetmoverscript . task import ( add_balrog_manifest_to_artifacts , generate_checksums_manifest , get_release_props , get_schema_key_by_action , get_task_action , get_task_bucket , get_taskId_from_full_path , get_upstream_artifacts , is_custom_checksums_task , validate_bucket_paths , validate_task_schema , ) [EOL] [EOL] from . import get_fake_checksums_manifest , get_fake_valid_config , get_fake_valid_task [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] ] , [string] ) , ( [ [string] , [string] ] , [string] ) , ( [ [string] , [string] ] , [string] ) , ( [ [string] , [string] ] , [string] ) , ( [ [string] , [string] ] , [string] ) , ) , ) def test_get_schema_key_by_action ( scopes , expected ) : [EOL] context = Context ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . task = get_fake_valid_task ( ) [EOL] context . task [ [string] ] = scopes [EOL] [EOL] assert expected == get_schema_key_by_action ( context ) [EOL] [EOL] [EOL] [comment] [EOL] def test_exception_get_upstream_artifacts ( ) : [EOL] context = Context ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . task = get_fake_valid_task ( ) [EOL] context . properties = context . task [ [string] ] [ [string] ] [EOL] [EOL] context . task [ [string] ] [ [string] ] [ [number] ] [ [string] ] . append ( [string] ) [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] context . artifacts_to_beetmove = get_upstream_artifacts ( context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] , [string] , [string] , [string] , [string] ] , False ) , ( [ [string] , [string] , [string] , [string] , [string] , [string] , ] , True , ) , ) , ) def test_get_upstream_artifacts ( expected , preserve ) : [EOL] context = Context ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . task = get_fake_valid_task ( ) [EOL] context . properties = context . task [ [string] ] [ [string] ] [EOL] [EOL] artifacts_to_beetmove = get_upstream_artifacts ( context , preserve_full_paths = preserve ) [EOL] assert sorted ( list ( artifacts_to_beetmove [ [string] ] ) ) == sorted ( expected ) [EOL] [EOL] [EOL] [comment] [EOL] def test_validate_task ( context ) : [EOL] validate_task_schema ( context ) [EOL] [EOL] [comment] [EOL] context . task [ [string] ] = [ [string] ] [EOL] context . task [ [string] ] = { [string] : [string] , [string] : [number] , [string] : [string] } [EOL] validate_task_schema ( context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] ] , None , True ) , ( [ [string] ] , None , True ) , ( [ [string] , [string] ] , [string] , False ) , ) , ) def test_get_task_bucket ( scopes , expected , raises ) : [EOL] task = { [string] : scopes } [EOL] config = { [string] : { [string] : [string] } , [string] : [string] } [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] get_task_bucket ( task , config ) [EOL] else : [EOL] assert expected == get_task_bucket ( task , config ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] ] , None , True ) , ( [ [string] ] , None , True ) , ( [ [string] ] , [string] , False ) , ) , ) def test_get_task_action ( scopes , expected , raises ) : [EOL] task = { [string] : scopes } [EOL] config = { [string] : { [string] : [string] } , [string] : [string] } [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] get_task_action ( task , config , valid_actions = [ [string] ] ) [EOL] else : [EOL] assert expected == get_task_action ( task , config ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ) , ) def test_validate_bucket_paths ( bucket , path , raises ) : [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] validate_bucket_paths ( bucket , path ) [EOL] else : [EOL] validate_bucket_paths ( bucket , path ) [EOL] [EOL] [EOL] [comment] [EOL] def test_balrog_manifest_to_artifacts ( ) : [EOL] context = Context ( ) [EOL] context . task = get_fake_valid_task ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] [EOL] fake_balrog_manifest = context . task [ [string] ] [ [string] ] [EOL] context . balrog_manifest = fake_balrog_manifest [EOL] [EOL] [comment] [EOL] with tempfile . TemporaryDirectory ( ) as tmpdirname : [EOL] context . config [ [string] ] = tmpdirname [EOL] file_path = os . path . join ( context . config [ [string] ] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] public_tmpdirname = os . path . join ( tmpdirname , [string] ) [EOL] if not os . path . exists ( public_tmpdirname ) : [EOL] os . makedirs ( public_tmpdirname ) [EOL] [EOL] add_balrog_manifest_to_artifacts ( context ) [EOL] [EOL] with open ( file_path , [string] ) as fread : [EOL] retrieved_data = json . load ( fread ) [EOL] [EOL] assert fake_balrog_manifest == retrieved_data [EOL] [EOL] [EOL] [comment] [EOL] def test_checksums_manifest_generation ( ) : [EOL] checksums = { [string] : { [string] : [string] , [string] : [number] , [string] : [string] , } } [EOL] [EOL] context = Context ( ) [EOL] context . task = get_fake_valid_task ( ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . checksums = checksums [EOL] [EOL] expected_checksums_manifest_dump = get_fake_checksums_manifest ( ) [EOL] checksums_manifest_dump = generate_checksums_manifest ( context ) [EOL] assert checksums_manifest_dump == expected_checksums_manifest_dump [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , False , { [string] : [string] } , { [string] : [string] , [string] : [string] } ) , ( [string] , True , { [string] : [string] } , { [string] : [string] , [string] : [string] } ) , ( [string] , False , { [string] : [string] } , { [string] : [string] , [string] : [string] } ) , ( [string] , False , { [string] : [string] } , { [string] : [string] , [string] : [string] } ) , ( [string] , True , { [string] : [string] } , { [string] : [string] , [string] : [string] } ) , ) , ) def test_get_release_props ( context , mocker , taskjson , locale , relprops , expected ) : [EOL] context . task = get_fake_valid_task ( taskjson ) [EOL] if locale : [EOL] context . task [ [string] ] [ [string] ] = [string] [EOL] [EOL] context . task [ [string] ] [ [string] ] = relprops [EOL] assert get_release_props ( context ) == expected [EOL] [EOL] context . task [ [string] ] [ [string] ] = None [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] get_release_props ( context ) [EOL] [EOL] [EOL] [comment] [EOL] def test_get_release_props_raises ( context , mocker ) : [EOL] context . task = get_fake_valid_task ( taskjson = [string] ) [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] get_release_props ( context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ) ) def test_is_custom_beetmover_task ( context , kind , expected ) : [EOL] context . task [ [string] ] [ [string] ] = kind [EOL] assert is_custom_checksums_task ( context ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) , ) def test_get_taskId_from_full_path ( path , expected ) : [EOL] assert get_taskId_from_full_path ( path ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] ) , ( [string] ) , ( [string] ) , ) , ) def test_get_taskId_from_full_path_raises ( path ) : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] get_taskId_from_full_path ( path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple [EOL] import typing [EOL] MIME_MAP = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] STAGE_PLATFORM_MAP = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] NORMALIZED_BALROG_PLATFORMS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] NORMALIZED_FILENAME_PLATFORMS = NORMALIZED_BALROG_PLATFORMS . copy ( ) [EOL] NORMALIZED_FILENAME_PLATFORMS . update ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] HASH_BLOCK_SIZE = [number] * [number] [EOL] [EOL] RELEASE_BRANCHES = ( [string] , [string] , [string] , [string] [string] , [string] , [string] ) [EOL] [EOL] RESTRICTED_BUCKET_PATHS = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] PROMOTION_ACTIONS = ( [string] , ) [EOL] [EOL] RELEASE_ACTIONS = ( [string] , ) [EOL] [EOL] PARTNER_REPACK_ACTIONS = ( [string] , ) [EOL] [EOL] MAVEN_ACTIONS = ( [string] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] RELEASE_EXCLUDE = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] CACHE_CONTROL_MAXAGE = [number] * [number] [EOL] [EOL] PRODUCT_TO_PATH = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] PARTNER_REPACK_PUBLIC_PREFIX_TMPL = [string] [EOL] PARTNER_REPACK_PRIVATE_REGEXES = ( [string] , ) [EOL] PARTNER_REPACK_PUBLIC_REGEXES = ( [string] , [string] , ) [EOL] [EOL] CHECKSUMS_CUSTOM_FILE_NAMING = { [string] : [string] , [string] : [string] } [EOL] [EOL] BUILDHUB_ARTIFACT = [string] [EOL] [EOL] [comment] [EOL] INSTALLER_ARTIFACTS = ( [string] , [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import os [EOL] import re [EOL] import urllib . parse [EOL] from copy import deepcopy [EOL] [EOL] import arrow [EOL] from scriptworker import artifacts as scriptworker_artifacts [EOL] from scriptworker import client [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] from beetmoverscript import utils [EOL] from beetmoverscript . constants import CHECKSUMS_CUSTOM_FILE_NAMING , RESTRICTED_BUCKET_PATHS , STAGE_PLATFORM_MAP [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_schema_key_by_action ( context ) : [EOL] action = get_task_action ( context . task , context . config ) [EOL] if utils . is_release_action ( action ) : [EOL] return [string] [EOL] elif utils . is_maven_action ( action ) : [EOL] return [string] [EOL] [EOL] return [string] [EOL] [EOL] [EOL] def validate_task_schema ( context ) : [EOL] [docstring] [EOL] schema_key = get_schema_key_by_action ( context ) [EOL] client . validate_task_schema ( context , schema_key = schema_key ) [EOL] [EOL] [EOL] def get_task_bucket ( task , script_config ) : [EOL] [docstring] [EOL] buckets = [ s . split ( [string] ) [ - [number] ] for s in task [ [string] ] if s . startswith ( script_config [ [string] ] + [string] ) ] [EOL] log . info ( [string] , buckets ) [EOL] messages = [ ] [EOL] if len ( buckets ) != [number] : [EOL] messages . append ( [string] ) [EOL] [EOL] bucket = buckets [ [number] ] [EOL] if re . search ( [string] , bucket ) is None : [EOL] messages . append ( [string] . format ( bucket ) ) [EOL] [EOL] if bucket not in script_config [ [string] ] : [EOL] messages . append ( [string] ) [EOL] [EOL] if messages : [EOL] raise ScriptWorkerTaskException ( [string] . join ( messages ) ) [EOL] [EOL] return bucket [EOL] [EOL] [EOL] def get_task_action ( task , script_config , valid_actions = None ) : [EOL] [docstring] [EOL] actions = [ s . split ( [string] ) [ - [number] ] for s in task [ [string] ] if s . startswith ( script_config [ [string] ] + [string] ) ] [EOL] [EOL] log . info ( [string] , actions ) [EOL] messages = [ ] [EOL] if len ( actions ) != [number] : [EOL] messages . append ( [string] ) [EOL] [EOL] action = actions [ [number] ] [EOL] if valid_actions is not None and action not in valid_actions : [EOL] messages . append ( [string] ) [EOL] [EOL] if messages : [EOL] raise ScriptWorkerTaskException ( [string] . join ( messages ) ) [EOL] [EOL] return action [EOL] [EOL] [EOL] def validate_bucket_paths ( bucket , s3_bucket_path ) : [EOL] [docstring] [EOL] try : [EOL] paths = RESTRICTED_BUCKET_PATHS [ bucket ] [EOL] except KeyError : [EOL] raise ScriptWorkerTaskException ( [string] . format ( s3_bucket_path ) ) [EOL] if not any ( [ s3_bucket_path . startswith ( p ) for p in paths ] ) : [EOL] raise ScriptWorkerTaskException ( [string] . format ( s3_bucket_path ) ) [EOL] [EOL] [EOL] def generate_checksums_manifest ( context ) : [EOL] checksums_dict = context . checksums [EOL] content = list ( ) [EOL] for artifact , values in sorted ( checksums_dict . items ( ) ) : [EOL] for algo in context . config [ [string] ] : [EOL] content . append ( [string] . format ( values [ algo ] , algo , values [ [string] ] , artifact ) ) [EOL] [EOL] return [string] . join ( content ) [EOL] [EOL] [EOL] def is_custom_checksums_task ( context ) : [EOL] return CHECKSUMS_CUSTOM_FILE_NAMING . get ( context . task [ [string] ] [ [string] ] , [string] ) [EOL] [EOL] [EOL] def add_checksums_to_artifacts ( context ) : [EOL] name = is_custom_checksums_task ( context ) [EOL] filename = [string] . format ( name ) [EOL] [EOL] abs_file_path = os . path . join ( context . config [ [string] ] , filename ) [EOL] manifest = generate_checksums_manifest ( context ) [EOL] utils . write_file ( abs_file_path , manifest ) [EOL] [EOL] [EOL] def add_balrog_manifest_to_artifacts ( context ) : [EOL] abs_file_path = os . path . join ( context . config [ [string] ] , [string] ) [EOL] utils . write_json ( abs_file_path , context . balrog_manifest ) [EOL] [EOL] [EOL] def get_upstream_artifacts ( context , preserve_full_paths = False ) : [EOL] artifacts = { } [EOL] for artifact_dict in context . task [ [string] ] [ [string] ] : [EOL] locale = artifact_dict . get ( [string] , [string] ) [EOL] artifacts [ locale ] = artifacts . get ( locale , { } ) [EOL] for path in artifact_dict [ [string] ] : [EOL] abs_path = scriptworker_artifacts . get_and_check_single_upstream_artifact_full_path ( context , artifact_dict [ [string] ] , path ) [EOL] if preserve_full_paths : [EOL] artifacts [ locale ] [ path ] = abs_path [EOL] else : [EOL] artifacts [ locale ] [ os . path . basename ( abs_path ) ] = abs_path [EOL] return artifacts [EOL] [EOL] [EOL] def get_release_props ( context , platform_mapping = STAGE_PLATFORM_MAP ) : [EOL] [docstring] [EOL] payload_properties = context . task . get ( [string] , { } ) . get ( [string] , None ) [EOL] [EOL] if not payload_properties : [EOL] raise ScriptWorkerTaskException ( [string] ) [EOL] [EOL] log . debug ( [string] . format ( payload_properties ) ) [EOL] return update_props ( context , payload_properties , platform_mapping ) [EOL] [EOL] [EOL] def update_props ( context , props , platform_mapping ) : [EOL] [docstring] [EOL] props = deepcopy ( props ) [EOL] [EOL] stage_platform = props . get ( [string] , [string] ) [EOL] [comment] [EOL] props [ [string] ] = platform_mapping . get ( stage_platform , stage_platform ) [EOL] props [ [string] ] = stage_platform [EOL] return props [EOL] [EOL] [EOL] def get_updated_buildhub_artifact ( path , installer_artifact , installer_path , context , locale , manifest = None , artifact_map = None ) : [EOL] [docstring] [EOL] contents = utils . load_json ( path ) [EOL] url_prefix = context . config [ [string] ] [ context . bucket ] [ [string] ] [EOL] if artifact_map : [EOL] task_id = get_taskId_from_full_path ( installer_path ) [EOL] cfg = utils . extract_file_config_from_artifact_map ( artifact_map , installer_artifact , task_id , locale ) [EOL] path = urllib . parse . quote ( cfg [ [string] ] [ [number] ] ) [EOL] else : [EOL] dest = manifest [ [string] ] [ locale ] [ installer_artifact ] [ [string] ] [ [number] ] [EOL] path = urllib . parse . quote ( urllib . parse . urljoin ( manifest [ [string] ] , dest ) ) [EOL] url = urllib . parse . urljoin ( url_prefix , path ) [EOL] [EOL] [comment] [EOL] contents [ [string] ] [ [string] ] = utils . get_size ( installer_path ) [EOL] contents [ [string] ] [ [string] ] = str ( arrow . utcnow ( ) ) [EOL] contents [ [string] ] [ [string] ] = url [EOL] [EOL] return contents [EOL] [EOL] [EOL] def get_taskId_from_full_path ( full_path_artifact ) : [EOL] [docstring] [EOL] split_path = full_path_artifact . split ( os . path . sep ) [EOL] try : [EOL] cot_dir_index = split_path . index ( [string] ) [EOL] possible_task_id = split_path [ cot_dir_index + [number] ] [EOL] return utils . validated_task_id ( possible_task_id ) [EOL] except ( IndexError , ValueError ) : [EOL] raise ScriptWorkerTaskException ( [string] . format ( full_path_artifact ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import logging [EOL] import jinja2 [EOL] import typing [EOL] import hashlib [EOL] import hashlib [EOL] import json [EOL] import logging [EOL] import os [EOL] import pprint [EOL] import re [EOL] from copy import deepcopy [EOL] [EOL] import arrow [EOL] import jinja2 [EOL] import yaml [EOL] from mozilla_version . gecko import FirefoxVersion [EOL] from mozilla_version . maven import MavenVersion [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] from beetmoverscript . constants import ( HASH_BLOCK_SIZE , MAVEN_ACTIONS , NORMALIZED_FILENAME_PLATFORMS , PARTNER_REPACK_ACTIONS , PRODUCT_TO_PATH , PROMOTION_ACTIONS , RELEASE_ACTIONS , ) [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] JINJA_ENV = jinja2 . Environment ( loader = jinja2 . PackageLoader ( [string] ) , undefined = jinja2 . StrictUndefined ) [EOL] [EOL] [EOL] def get_hash ( filepath , hash_type = [string] ) : [EOL] [docstring] [EOL] digest = hashlib . new ( hash_type ) [EOL] with open ( filepath , [string] ) as fobj : [EOL] while True : [EOL] chunk = fobj . read ( HASH_BLOCK_SIZE ) [EOL] if not chunk : [EOL] break [EOL] digest . update ( chunk ) [EOL] return digest . hexdigest ( ) [EOL] [EOL] [EOL] def get_size ( filepath ) : [EOL] [docstring] [EOL] return os . path . getsize ( filepath ) [EOL] [EOL] [EOL] def load_json ( path ) : [EOL] [docstring] [EOL] with open ( path , [string] ) as fh : [EOL] return json . load ( fh ) [EOL] [EOL] [EOL] def write_json ( path , contents ) : [EOL] [docstring] [EOL] with open ( path , [string] ) as fh : [EOL] json . dump ( contents , fh , indent = [number] ) [EOL] [EOL] [EOL] def write_file ( path , contents ) : [EOL] [docstring] [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( contents ) [EOL] [EOL] [EOL] def is_release_action ( action ) : [EOL] [docstring] [EOL] return action in RELEASE_ACTIONS [EOL] [EOL] [EOL] def is_promotion_action ( action ) : [EOL] [docstring] [EOL] return action in PROMOTION_ACTIONS [EOL] [EOL] [EOL] def is_partner_action ( action ) : [EOL] [docstring] [EOL] return action in PARTNER_REPACK_ACTIONS [EOL] [EOL] [EOL] def is_maven_action ( action ) : [EOL] [docstring] [EOL] return action in MAVEN_ACTIONS [EOL] [EOL] [EOL] def is_partner_private_task ( context ) : [EOL] [docstring] [EOL] return is_partner_action ( context . action ) and [string] in context . bucket [EOL] [EOL] [EOL] def is_partner_public_task ( context ) : [EOL] [docstring] [EOL] return is_partner_action ( context . action ) and [string] not in context . bucket [EOL] [EOL] [EOL] def get_product_name ( appName , platform ) : [EOL] if [string] in platform : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if appName [ [number] ] . isupper ( ) : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] return appName [EOL] [EOL] [EOL] def generate_beetmover_template_args ( context ) : [EOL] task = context . task [EOL] release_props = context . release_props [EOL] [EOL] if is_maven_action ( context . action ) : [EOL] return _generate_beetmover_template_args_maven ( task , release_props ) [EOL] [EOL] upload_date = task [ [string] ] [ [string] ] [EOL] args = [ ] [EOL] try : [EOL] upload_date = float ( upload_date ) [EOL] except ValueError : [EOL] upload_date = upload_date . split ( [string] ) [ - [number] ] [EOL] args . append ( [string] ) [EOL] [EOL] tmpl_args = { [string] : arrow . get ( upload_date , * args ) . format ( [string] ) , [string] : release_props [ [string] ] , [string] : release_props [ [string] ] , [string] : release_props [ [string] ] , [string] : release_props [ [string] ] , [string] : release_props [ [string] ] , [string] : release_props [ [string] ] , [string] : get_partials_props ( task ) , [string] : NORMALIZED_FILENAME_PLATFORMS . get ( release_props [ [string] ] , release_props [ [string] ] ) , } [EOL] [EOL] if is_promotion_action ( context . action ) or is_release_action ( context . action ) or is_partner_action ( context . action ) : [EOL] tmpl_args [ [string] ] = task [ [string] ] [ [string] ] [EOL] tmpl_args [ [string] ] = task [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] tmpl_bucket = context . action . split ( [string] ) [ - [number] ] [EOL] [EOL] locales_in_upstream_artifacts = [ upstream_artifact [ [string] ] for upstream_artifact in task [ [string] ] [ [string] ] if [string] in upstream_artifact ] [EOL] uniques_locales_in_upstream_artifacts = sorted ( list ( set ( locales_in_upstream_artifacts ) ) ) [EOL] [EOL] if [string] in task [ [string] ] and uniques_locales_in_upstream_artifacts : [EOL] _check_locale_consistency ( task [ [string] ] [ [string] ] , uniques_locales_in_upstream_artifacts ) [EOL] tmpl_args [ [string] ] = uniques_locales_in_upstream_artifacts [EOL] elif uniques_locales_in_upstream_artifacts : [EOL] tmpl_args [ [string] ] = uniques_locales_in_upstream_artifacts [EOL] elif [string] in task [ [string] ] : [EOL] tmpl_args [ [string] ] = [ task [ [string] ] [ [string] ] ] [EOL] [EOL] product_name = get_product_name ( release_props [ [string] ] . lower ( ) , release_props [ [string] ] ) [EOL] if tmpl_args . get ( [string] ) and ( set ( tmpl_args . get ( [string] ) ) . isdisjoint ( { [string] , [string] } ) ) : [EOL] tmpl_args [ [string] ] = [string] % ( product_name , tmpl_bucket ) [EOL] else : [EOL] tmpl_args [ [string] ] = [string] % ( product_name , tmpl_bucket ) [EOL] [EOL] return tmpl_args [EOL] [EOL] [EOL] def _generate_beetmover_template_args_maven ( task , release_props ) : [EOL] tmpl_args = { [string] : task [ [string] ] [ [string] ] , [string] : [string] . format ( release_props [ [string] ] ) } [EOL] [EOL] [comment] [EOL] if release_props . get ( [string] ) == [string] : [EOL] payload_version = FirefoxVersion . parse ( task [ [string] ] [ [string] ] ) [EOL] [comment] [EOL] version = [ payload_version . major_number , payload_version . minor_number , release_props [ [string] ] ] [EOL] else : [EOL] payload_version = MavenVersion . parse ( task [ [string] ] [ [string] ] ) [EOL] version = [ payload_version . major_number , payload_version . minor_number , payload_version . patch_number ] [EOL] [EOL] if any ( number is None for number in version ) : [EOL] raise TaskVerificationError ( [string] . format ( version ) ) [EOL] tmpl_args [ [string] ] = [string] . join ( str ( n ) for n in version ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] tmpl_args [ [string] ] = task [ [string] ] . get ( [string] ) [EOL] [EOL] return tmpl_args [EOL] [EOL] [EOL] def _check_locale_consistency ( locale_in_payload , uniques_locales_in_upstream_artifacts ) : [EOL] if len ( uniques_locales_in_upstream_artifacts ) > [number] : [EOL] raise TaskVerificationError ( [string] . format ( locale_in_payload , uniques_locales_in_upstream_artifacts ) ) [EOL] elif len ( uniques_locales_in_upstream_artifacts ) == [number] : [EOL] locale_in_upstream_artifacts = uniques_locales_in_upstream_artifacts [ [number] ] [EOL] if locale_in_payload != locale_in_upstream_artifacts : [EOL] raise TaskVerificationError ( [string] . format ( locale_in_payload , locale_in_upstream_artifacts ) ) [EOL] [EOL] [EOL] def generate_beetmover_manifest ( context ) : [EOL] [docstring] [EOL] tmpl_args = generate_beetmover_template_args ( context ) [EOL] [EOL] tmpl_name = [string] . format ( tmpl_args [ [string] ] ) [EOL] jinja_env = JINJA_ENV [EOL] tmpl = jinja_env . get_template ( tmpl_name ) [EOL] [EOL] log . info ( [string] . format ( tmpl . filename ) ) [EOL] [EOL] manifest = yaml . safe_load ( tmpl . render ( ** tmpl_args ) ) [EOL] [EOL] log . info ( [string] ) [EOL] log . info ( pprint . pformat ( manifest ) ) [EOL] [EOL] return manifest [EOL] [EOL] [EOL] def get_partials_props ( task ) : [EOL] [docstring] [EOL] partials = task . get ( [string] , { } ) . get ( [string] , { } ) [EOL] return { p [ [string] ] : p for p in partials } [EOL] [EOL] [EOL] def alter_unpretty_contents ( context , blobs , mappings ) : [EOL] [docstring] [EOL] for blob in blobs : [EOL] for locale in context . artifacts_to_beetmove : [EOL] source = context . artifacts_to_beetmove [ locale ] . get ( blob ) [EOL] if not source : [EOL] continue [EOL] [EOL] contents = load_json ( source ) [EOL] pretty_contents = deepcopy ( contents ) [EOL] for package , tests in contents . items ( ) : [EOL] new_tests = [ ] [EOL] for artifact in tests : [EOL] pretty_dict = mappings [ [string] ] [ locale ] . get ( artifact ) [EOL] if pretty_dict : [EOL] new_tests . append ( pretty_dict [ [string] ] ) [EOL] else : [EOL] new_tests . append ( artifact ) [EOL] if new_tests != tests : [EOL] pretty_contents [ package ] = new_tests [EOL] [EOL] if pretty_contents != contents : [EOL] write_json ( source , pretty_contents ) [EOL] [EOL] [EOL] def get_candidates_prefix ( product , version , build_number ) : [EOL] return [string] . format ( PRODUCT_TO_PATH [ product ] , version , str ( build_number ) ) [EOL] [EOL] [EOL] def get_releases_prefix ( product , version ) : [EOL] return [string] . format ( PRODUCT_TO_PATH [ product ] , version ) [EOL] [EOL] [EOL] def get_partner_candidates_prefix ( prefix , partner ) : [EOL] return [string] . format ( prefix , partner ) [EOL] [EOL] [EOL] def get_partner_releases_prefix ( product , version , partner ) : [EOL] return [string] . format ( PRODUCT_TO_PATH [ product ] , partner , version ) [EOL] [EOL] [EOL] def matches_exclude ( keyname , excludes ) : [EOL] for exclude in excludes : [EOL] if re . search ( exclude , keyname ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def get_partner_match ( keyname , candidates_prefix , partners ) : [EOL] for partner in partners : [EOL] if keyname . startswith ( get_partner_candidates_prefix ( candidates_prefix , partner ) ) : [EOL] return partner [EOL] return None [EOL] [EOL] [EOL] def get_creds ( context ) : [EOL] return context . config [ [string] ] [ context . bucket ] [ [string] ] [EOL] [EOL] [EOL] def get_bucket_name ( context , product ) : [EOL] return context . config [ [string] ] [ context . bucket ] [ [string] ] [ product ] [EOL] [EOL] [EOL] def get_bucket_url_prefix ( context ) : [EOL] return context . config [ [string] ] [ context . bucket ] [ [string] ] [EOL] [EOL] [EOL] def validated_task_id ( task_id ) : [EOL] [docstring] [EOL] pattern = [string] [EOL] if re . fullmatch ( pattern , task_id ) : [EOL] return task_id [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def exists_or_endswith ( filename , basenames ) : [EOL] if isinstance ( basenames , str ) : [EOL] basenames = [ basenames ] [EOL] for artifact in basenames : [EOL] if filename == artifact or filename . endswith ( artifact ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def extract_full_artifact_map_path ( artifact_map , basepath , locale ) : [EOL] [docstring] [EOL] for entry in artifact_map : [EOL] if entry [ [string] ] != locale : [EOL] continue [EOL] for path in entry [ [string] ] : [EOL] if path . endswith ( basepath ) : [EOL] return path [EOL] [EOL] [EOL] def extract_file_config_from_artifact_map ( artifact_map , path , task_id , locale ) : [EOL] [docstring] [EOL] for entry in artifact_map : [EOL] if entry [ [string] ] != task_id or entry [ [string] ] != locale : [EOL] continue [EOL] if not entry [ [string] ] . get ( path ) : [EOL] continue [EOL] return entry [ [string] ] [ path ] [EOL] raise TaskVerificationError ( [string] . format ( task_id , locale , path ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Dict [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] from scriptworker import client [EOL] from scriptworker . exceptions import ScriptWorkerTaskException , TaskVerificationError [EOL] from scriptworker . utils import get_single_item_from_sequence [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] SCHEMA_MAP = { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def _get_scope ( context , suffix ) : [EOL] scope_root = context . config [ [string] ] + suffix [EOL] [EOL] return get_single_item_from_sequence ( context . task [ [string] ] , condition = lambda scope : scope . startswith ( scope_root ) , ErrorClass = TaskVerificationError , no_item_error_message = [string] . format ( scope_root ) , too_many_item_error_message = [string] , ) [EOL] [EOL] [EOL] def get_ship_it_instance_config_from_scope ( context ) : [EOL] scope = _get_scope ( context , [string] ) [EOL] configured_instance = context . config [ [string] ] [EOL] [EOL] if configured_instance . get ( [string] ) == scope : [EOL] return configured_instance [EOL] [EOL] raise TaskVerificationError ( [string] . format ( scope ) ) [EOL] [EOL] [EOL] def validate_task_schema ( context ) : [EOL] [docstring] [EOL] action = get_task_action ( context ) [EOL] schema_key = SCHEMA_MAP . get ( action ) [EOL] client . validate_task_schema ( context , schema_key = schema_key ) [EOL] [EOL] [EOL] def get_task_action ( context ) : [EOL] [docstring] [EOL] scope = _get_scope ( context , [string] ) [EOL] action = scope . split ( [string] ) [ - [number] ] [EOL] [EOL] [comment] [EOL] if action not in SCHEMA_MAP : [EOL] raise ScriptWorkerTaskException ( [string] . format ( action ) ) [EOL] [EOL] return action [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import sys [EOL] [EOL] from shipitscript import pushlog_scan [EOL] from shipitscript . shipitapi import Release_V2 [EOL] from shipitscript . utils import check_release_has_values_v2 , get_auth_primitives_v2 , get_request_headers [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_shipit_api_instance ( shipit_config ) : [EOL] ( tc_client_id , tc_access_token , api_root , timeout_in_seconds ) = get_auth_primitives_v2 ( shipit_config ) [EOL] [EOL] release_api = Release_V2 ( taskcluster_client_id = tc_client_id , taskcluster_access_token = tc_access_token , api_root = api_root , timeout = timeout_in_seconds ) [EOL] headers = get_request_headers ( api_root ) [EOL] [EOL] return release_api , headers [EOL] [EOL] [EOL] def get_shippable_revision ( branch , last_shipped_revision , cron_revision ) : [EOL] return pushlog_scan . get_shippable_revision_build ( branch , last_shipped_revision , cron_revision ) [EOL] [EOL] [EOL] def get_most_recent_shipped_revision ( shipit_config , product , branch ) : [EOL] release_api , headers = get_shipit_api_instance ( shipit_config ) [EOL] [EOL] log . info ( [string] ) [EOL] all_releases = release_api . get_releases ( product , branch , status = [string] , headers = headers ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] most_recent_release = all_releases [ - [number] ] [EOL] return most_recent_release [ [string] ] [EOL] except IndexError : [EOL] [comment] [EOL] log . error ( [string] ) [EOL] return [EOL] except KeyError : [EOL] log . error ( [string] ) [EOL] return [EOL] [EOL] [EOL] def calculate_build_number ( shipit_config , product , branch , version ) : [EOL] release_api , headers = get_shipit_api_instance ( shipit_config ) [EOL] [EOL] log . info ( [string] ) [EOL] all_builds = release_api . get_releases ( product , branch , status = [string] , version = version , headers = headers ) [EOL] [EOL] build_numbers = [ r [ [string] ] for r in all_builds ] [EOL] if not build_numbers : [EOL] log . info ( [string] ) [EOL] return [number] [EOL] [EOL] log . info ( [string] ) [EOL] return max ( build_numbers ) + [number] [EOL] [EOL] [EOL] def releases_are_disabled ( shipit_config , product , branch ) : [EOL] release_api , headers = get_shipit_api_instance ( shipit_config ) [EOL] [EOL] log . info ( [string] ) [EOL] disabled_products = release_api . get_disabled_products ( headers = headers ) [EOL] [EOL] return branch in disabled_products . get ( product , [ ] ) [EOL] [EOL] [EOL] def start_new_release ( shipit_config , product , product_key , branch , version , revision , phase ) : [EOL] [comment] [EOL] if releases_are_disabled ( shipit_config , product , branch ) : [EOL] log . info ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] build_number = calculate_build_number ( shipit_config , product , branch , version ) [EOL] if build_number != [number] : [EOL] log . info ( f" [string] { build_number } [string] " ) [EOL] sys . exit ( [number] ) [EOL] [EOL] release_api , headers = get_shipit_api_instance ( shipit_config ) [EOL] log . info ( [string] ) [EOL] release_details = release_api . create_new_release ( product , product_key , branch , version , build_number , revision , headers = headers ) [EOL] [EOL] [comment] [EOL] release_name = release_details [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if releases_are_disabled ( shipit_config , product , branch ) : [EOL] log . info ( [string] ) [EOL] return [EOL] release_api . trigger_release_phase ( release_name , phase , headers = headers ) [EOL] [EOL] [EOL] def mark_as_shipped_v2 ( shipit_config , release_name ) : [EOL] [docstring] [EOL] release_api , headers = get_shipit_api_instance ( shipit_config ) [EOL] [EOL] log . info ( [string] ) [EOL] release_api . update_status ( release_name , status = [string] , headers = headers ) [EOL] check_release_has_values_v2 ( release_api , release_name , headers , status = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import requests [EOL] import logging [EOL] from enum import Enum , auto , unique [EOL] [EOL] import requests [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] URL = [string] [EOL] [EOL] [EOL] @ unique class Importance ( Enum ) : [EOL] MAYBE = auto ( ) [EOL] IMPORTANT = auto ( ) [EOL] UNIMPORTANT = auto ( ) [EOL] [EOL] [EOL] _push_checks = [ ] [EOL] [EOL] [EOL] def push_check ( func ) : [EOL] _push_checks . append ( func ) [EOL] return func [EOL] [EOL] [EOL] def get_shippable_revision_build ( branch , last_shipped_rev , cron_rev ) : [EOL] [docstring] [EOL] [comment] [EOL] resp = requests . get ( URL . format ( branch = branch ) , params = { [string] : [string] , [string] : last_shipped_rev , [string] : cron_rev } ) [EOL] pushlog = resp . json ( ) [EOL] [comment] [EOL] reversed_pushes = [ pushlog [ k ] for k in sorted ( pushlog . keys ( ) , reverse = True ) if pushlog [ k ] [ [string] ] [ [number] ] [ [string] ] == [string] ] [EOL] for push in reversed_pushes : [EOL] push_importance = is_push_important ( push ) [EOL] if push_importance == Importance . IMPORTANT : [EOL] [comment] [EOL] return push [ [string] ] [ - [number] ] [ [string] ] [EOL] [EOL] [EOL] def is_push_important ( push ) : [EOL] [docstring] [EOL] isimportant = Importance . IMPORTANT [EOL] for check in _push_checks : [EOL] isimportant = check ( push ) [EOL] if not isimportant == Importance . MAYBE : [EOL] return isimportant [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] log . info ( f" [string] { push [ [string] ] [ - [number] ] [ [string] ] } [string] " ) [EOL] return Importance . IMPORTANT [EOL] [EOL] [EOL] @ push_check def skip_dontbuild ( push ) : [EOL] [docstring] [EOL] if [string] in push [ [string] ] [ - [number] ] [ [string] ] : [EOL] return Importance . UNIMPORTANT [EOL] return Importance . MAYBE [EOL] [EOL] [EOL] @ push_check def is_l10n_bump ( push ) : [EOL] [docstring] [EOL] if push [ [string] ] [ - [number] ] [ [string] ] == [string] : [EOL] [comment] [EOL] return Importance . IMPORTANT [EOL] return Importance . MAYBE [EOL] [EOL] [EOL] @ push_check def skip_test_only ( push ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if len ( push [ [string] ] ) > [number] : [EOL] return Importance . IMPORTANT [EOL] [EOL] for commit in push [ [string] ] : [EOL] if [string] not in commit [ [string] ] and [string] not in commit [ [string] ] : [EOL] [comment] [EOL] return Importance . MAYBE [EOL] return Importance . UNIMPORTANT [EOL] [EOL] [EOL] @ push_check def skip_version_bump ( push ) : [EOL] [docstring] [EOL] cset = push [ [string] ] [ - [number] ] [EOL] if push [ [string] ] [ - [number] ] [ [string] ] == [string] : [EOL] if [string] in cset [ [string] ] : [EOL] [comment] [EOL] return Importance . UNIMPORTANT [EOL] [comment] [EOL] return Importance . MAYBE [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] import json [EOL] import logging [EOL] import urllib [EOL] [EOL] import certifi [EOL] import mohawk [EOL] import requests [EOL] from redo import retry [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Release_V2 ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , taskcluster_client_id , taskcluster_access_token , api_root , ca_certs = certifi . where ( ) , timeout = [number] , retry_attempts = [number] ) : [EOL] self . taskcluster_client_id = taskcluster_client_id [EOL] self . taskcluster_access_token = taskcluster_access_token [EOL] self . api_root = api_root . rstrip ( [string] ) [EOL] self . verify = ca_certs [EOL] self . timeout = timeout [EOL] self . retries = retry_attempts [EOL] self . session = requests . session ( ) [EOL] [EOL] @ staticmethod def _get_taskcluster_headers ( request_url , method , content , taskcluster_client_id , taskcluster_access_token ) : [EOL] hawk = mohawk . Sender ( { [string] : taskcluster_client_id , [string] : taskcluster_access_token , [string] : [string] } , request_url , method , content , content_type = [string] ) [EOL] return { [string] : hawk . request_header , [string] : [string] } [EOL] [EOL] def _request ( self , api_endpoint , data = None , method = [string] , headers = { } ) : [EOL] url = [string] . format ( self . api_root , api_endpoint ) [EOL] headers = headers . copy ( ) [EOL] if method . upper ( ) not in ( [string] , [string] ) : [EOL] headers . update ( self . _get_taskcluster_headers ( url , method , data , self . taskcluster_client_id , self . taskcluster_access_token ) ) [EOL] try : [EOL] [EOL] def _req ( ) : [EOL] req = self . session . request ( method = method , url = url , data = data , timeout = self . timeout , verify = self . verify , headers = headers ) [EOL] req . raise_for_status ( ) [EOL] return req [EOL] [EOL] return retry ( _req , sleeptime = [number] , max_sleeptime = [number] , retry_exceptions = ( requests . HTTPError , requests . ConnectionError ) , attempts = self . retries ) [EOL] except requests . HTTPError as err : [EOL] log . error ( [string] , err . response . status_code , err . response . content , exc_info = True ) [EOL] raise [EOL] [EOL] def getRelease ( self , name , headers = { } ) : [EOL] resp = None [EOL] try : [EOL] resp = self . _request ( api_endpoint = [string] . format ( name ) , headers = headers ) [EOL] return json . loads ( resp . content ) [EOL] except Exception : [EOL] log . error ( [string] , exc_info = True ) [EOL] if resp : [EOL] log . error ( resp . content ) [EOL] log . error ( f" [string] { resp . status_code }" ) [EOL] raise [EOL] [EOL] def get_releases ( self , product , branch , status , version = [string] , headers = { } ) : [EOL] [docstring] [EOL] resp = None [EOL] params = { [string] : product , [string] : branch , [string] : status } [EOL] if version : [EOL] params [ [string] ] = version [EOL] [EOL] try : [EOL] resp = self . _request ( api_endpoint = f" [string] { urllib . parse . urlencode ( params ) }" , headers = headers ) [EOL] return resp . json ( ) [EOL] except Exception : [EOL] log . error ( [string] , exc_info = True ) [EOL] if resp : [EOL] log . error ( resp . content ) [EOL] log . error ( f" [string] { resp . status_code }" ) [EOL] raise [EOL] [EOL] def update_status ( self , name , status , headers = { } ) : [EOL] [docstring] [EOL] data = json . dumps ( { [string] : status } ) [EOL] resp = self . _request ( api_endpoint = [string] . format ( name ) , method = [string] , data = data , headers = headers ) . content [EOL] return resp [EOL] [EOL] def get_disabled_products ( self , headers = { } ) : [EOL] [docstring] [EOL] resp = None [EOL] try : [EOL] resp = self . _request ( api_endpoint = [string] , headers = headers ) [EOL] [EOL] return resp . json ( ) [EOL] except Exception : [EOL] log . error ( [string] , exc_info = True ) [EOL] if resp : [EOL] log . error ( resp . content ) [EOL] log . error ( f" [string] { resp . status_code }" ) [EOL] raise [EOL] [EOL] def create_new_release ( self , product , product_key , branch , version , build_number , revision , headers = { } ) : [EOL] [docstring] [EOL] resp = None [EOL] params = { [string] : product , [string] : branch , [string] : version , [string] : build_number , [string] : revision , [string] : [string] } [EOL] [EOL] [comment] [EOL] [comment] [EOL] if product_key : [EOL] params . update ( { [string] : product_key } ) [EOL] [comment] [EOL] if product == [string] : [EOL] del params [ [string] ] [EOL] data = json . dumps ( params ) [EOL] [EOL] try : [EOL] resp = self . _request ( api_endpoint = [string] , method = [string] , data = data , headers = headers ) [EOL] return resp . json ( ) [EOL] except Exception : [EOL] log . error ( [string] , exc_info = True ) [EOL] if resp : [EOL] log . error ( resp . content ) [EOL] log . error ( f" [string] { resp . status_code }" ) [EOL] raise [EOL] [EOL] def trigger_release_phase ( self , release_name , phase , headers = { } ) : [EOL] [docstring] [EOL] resp = None [EOL] try : [EOL] resp = self . _request ( api_endpoint = f" [string] { release_name } [string] { phase }" , method = [string] , data = None , headers = headers ) [EOL] except Exception : [EOL] log . error ( f" [string] { phase } [string] { release_name }" , exc_info = True ) [EOL] if resp : [EOL] log . error ( resp . content ) [EOL] log . error ( f" [string] { resp . status_code }" ) [EOL] raise [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import urllib [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import urllib . parse [EOL] [EOL] import arrow [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def same_timing ( time1 , time2 ) : [EOL] [docstring] [EOL] return arrow . get ( time1 ) == arrow . get ( time2 ) [EOL] [EOL] [EOL] def get_auth_primitives_v2 ( ship_it_instance_config ) : [EOL] [docstring] [EOL] taskcluster_client_id = ship_it_instance_config [ [string] ] [EOL] taskcluster_access_token = ship_it_instance_config [ [string] ] [EOL] api_root = ship_it_instance_config [ [string] ] [EOL] timeout_in_seconds = int ( ship_it_instance_config . get ( [string] , [number] ) ) [EOL] [EOL] return ( taskcluster_client_id , taskcluster_access_token , api_root , timeout_in_seconds ) [EOL] [EOL] [EOL] def get_request_headers ( api_root ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] parsed_url = urllib . parse . urlsplit ( api_root ) [EOL] if parsed_url . port : [EOL] port = parsed_url . port [EOL] else : [EOL] if parsed_url . scheme == [string] : [EOL] port = [number] [EOL] else : [EOL] port = [number] [EOL] headers = { [string] : [string] , [string] : str ( port ) } [EOL] return headers [EOL] [EOL] [EOL] def check_release_has_values_v2 ( release_api , release_name , headers , ** kwargs ) : [EOL] [docstring] [EOL] release_info = release_api . getRelease ( release_name , headers = headers ) [EOL] log . info ( [string] . format ( release_info ) ) [EOL] [EOL] for key , value in kwargs . items ( ) : [EOL] [comment] [EOL] if not release_info . get ( key ) or release_info [ key ] != value : [EOL] err_msg = [string] . format ( key , value ) [EOL] raise ScriptWorkerTaskException ( err_msg ) [EOL] [EOL] log . info ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import json [EOL] [EOL] import mock [EOL] import pytest [EOL] import redo [EOL] import requests [EOL] [EOL] from shipitscript . shipitapi import Release_V2 [EOL] [EOL] [comment] [EOL] real_retry = redo . retry [EOL] [EOL] [EOL] def fake ( * args , ** kwargs ) : [EOL] kwargs . pop ( [string] ) [EOL] kwargs . pop ( [string] ) [EOL] return real_retry ( sleeptime = [number] , max_sleeptime = [number] , jitter = [number] , * args , ** kwargs ) [EOL] [EOL] [EOL] redo . retry = fake [EOL] [EOL] [EOL] def test_release_v2_class ( mocker ) : [EOL] class MockResponse ( requests . Response ) : [EOL] content = json . dumps ( { [string] : True , [string] : True } ) [EOL] [EOL] def __init__ ( self ) : [EOL] super ( MockResponse , self ) . __init__ ( ) [EOL] self . status_code = [number] [EOL] [EOL] [comment] [EOL] release = Release_V2 ( taskcluster_client_id = [string] , taskcluster_access_token = [string] , api_root = [string] , retry_attempts = [number] ) [EOL] [comment] [EOL] mocker . patch . object ( release , [string] ) [EOL] release_name = [string] [EOL] release . session . request . return_value = MockResponse ( ) [EOL] api_call_count = [number] [EOL] [EOL] [comment] [EOL] ret = release . getRelease ( release_name ) [EOL] assert ret [ [string] ] is True [EOL] correct_url = [string] [EOL] release . session . request . assert_called_with ( data = None , headers = { } , method = [string] , timeout = mock . ANY , verify = mock . ANY , url = correct_url ) [EOL] assert release . session . request . call_count == api_call_count + [number] [EOL] api_call_count += [number] [EOL] [EOL] [comment] [EOL] ret = release . getRelease ( release_name , headers = { [string] : [string] } ) [EOL] assert ret [ [string] ] is True [EOL] correct_url = [string] [EOL] release . session . request . assert_called_with ( data = None , headers = { [string] : [string] } , method = [string] , timeout = mock . ANY , verify = mock . ANY , url = correct_url ) [EOL] assert release . session . request . call_count == api_call_count + [number] [EOL] api_call_count += [number] [EOL] [EOL] [comment] [EOL] headers = { [string] : [string] } [EOL] ret = release . update_status ( release_name , status = [string] , headers = headers ) [EOL] ret_json = json . loads ( ret ) [EOL] assert ret_json [ [string] ] is True [EOL] correct_url = [string] [EOL] release . session . request . assert_called_with ( data = json . dumps ( { [string] : [string] } ) , headers = mock . ANY , method = [string] , timeout = mock . ANY , verify = mock . ANY , url = correct_url ) [EOL] api_call_count += [number] [EOL] assert release . session . request . call_count == api_call_count [EOL] [comment] [EOL] assert headers == { [string] : [string] } [EOL] [EOL] [comment] [EOL] release . session . request . return_value . status_code = [number] [EOL] with pytest . raises ( requests . exceptions . HTTPError ) : [EOL] release . getRelease ( release_name ) [EOL] correct_url = [string] [EOL] release . session . request . assert_called_with ( data = None , headers = { } , method = [string] , timeout = mock . ANY , verify = mock . ANY , url = correct_url ) [EOL] assert release . session . request . call_count == api_call_count + release . retries [EOL] [EOL] release . session . request . return_value . status_code = [number] [EOL] release . session . request . return_value . content = [string] [EOL] with pytest . raises ( json . decoder . JSONDecodeError ) : [EOL] release . getRelease ( release_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import copy [EOL] [EOL] import pytest [EOL] from scriptworker . exceptions import ScriptWorkerTaskException , TaskVerificationError [EOL] [EOL] from shipitscript . task import _get_scope , get_ship_it_instance_config_from_scope , get_task_action , validate_task_schema [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( [string] , ) , [string] , False ) , ( ( [string] , ) , [string] , False ) , ( ( [string] , ) , [string] , False ) , ( ( [string] , [string] ) , [string] , True ) , ( ( [string] , ) , [string] , True ) , ( ( [string] , ) , [string] , False ) , ( ( [string] , ) , [string] , True ) , ) , ) def test_get_scope ( context , scopes , sufix , raises ) : [EOL] context . task [ [string] ] = scopes [EOL] [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] _get_scope ( context , sufix ) [EOL] else : [EOL] assert _get_scope ( context , sufix ) == scopes [ [number] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ) , ) def test_get_ship_it_instance_config_from_scope ( context , api_root_v2 , scope , raises ) : [EOL] context . config [ [string] ] = copy . deepcopy ( context . config [ [string] ] ) [EOL] context . config [ [string] ] [ [string] ] = scope [EOL] context . config [ [string] ] [ [string] ] = api_root_v2 [EOL] context . task [ [string] ] = [ scope ] [EOL] [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] get_ship_it_instance_config_from_scope ( context ) [EOL] else : [EOL] assert get_ship_it_instance_config_from_scope ( context ) == { [string] : scope , [string] : api_root_v2 , [string] : [number] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] ) ) def test_fail_get_ship_it_instance_config_from_scope ( context , scope ) : [EOL] context . task [ [string] ] = [ scope ] [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] get_ship_it_instance_config_from_scope ( context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] ] , [string] : { [string] : [string] } , [string] : [ [string] , [string] ] , } , False , ) , ( { [string] : { [string] : [string] } , [string] : [ [string] , [string] ] , } , True , ) , ( { [string] : { [string] : [string] } , [string] : [ [string] ] } , True ) , ) , ) def test_validate_task ( context , task , raises ) : [EOL] context . task = task [EOL] [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] validate_task_schema ( context ) [EOL] else : [EOL] validate_task_schema ( context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( [string] ) , None , True ) , ( ( [string] ) , [string] , False ) ) , ) def test_get_task_action ( context , scopes , expected , raises ) : [EOL] context . task [ [string] ] = [ scopes ] [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] get_task_action ( context ) [EOL] else : [EOL] assert expected == get_task_action ( context ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] import pytest [EOL] from scriptworker . context import Context [EOL] [EOL] import shipitscript [EOL] [EOL] [EOL] @ pytest . fixture def context ( ) : [EOL] context = Context ( ) [EOL] context . config = { [string] : os . path . join ( os . path . dirname ( shipitscript . __file__ ) , [string] , [string] ) } [EOL] context . config [ [string] ] = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , } [EOL] context . config [ [string] ] = [string] [EOL] context . task = { [string] : [ [string] ] , [string] : { [string] : [string] } , [string] : [ [string] ] } [EOL] [EOL] return context [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] [EOL] import shipitscript . ship_actions [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [number] , [number] ) , ( [string] , [number] ) , ( None , [number] ) ) ) def test_mark_as_shipped_v2 ( monkeypatch , timeout , expected_timeout ) : [EOL] ReleaseClassMock = MagicMock ( ) [EOL] release_instance_mock = MagicMock ( ) [EOL] release_info = { [string] : [string] } [EOL] attrs = { [string] : release_info } [EOL] release_instance_mock . configure_mock ( ** attrs ) [EOL] ReleaseClassMock . side_effect = lambda * args , ** kwargs : release_instance_mock [EOL] monkeypatch . setattr ( shipitscript . ship_actions , [string] , ReleaseClassMock ) [EOL] [EOL] ship_it_instance_config = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] if timeout is not None : [EOL] ship_it_instance_config [ [string] ] = timeout [EOL] release_name = [string] [EOL] [EOL] shipitscript . ship_actions . mark_as_shipped_v2 ( ship_it_instance_config , release_name ) [EOL] [EOL] ReleaseClassMock . assert_called_with ( taskcluster_client_id = [string] , taskcluster_access_token = [string] , api_root = [string] , timeout = expected_timeout ) [EOL] release_instance_mock . update_status . assert_called_with ( [string] , status = [string] , headers = { [string] : [string] , [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import unittest [EOL] import typing [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] from shipitscript . utils import check_release_has_values_v2 , get_auth_primitives_v2 , get_request_headers , same_timing [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } , ( [string] , [string] , [string] , [number] ) , ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , ( [string] , [string] , [string] , [number] ) , ) , ) , ) def test_get_auth_primitives_v2 ( ship_it_instance_config , expected ) : [EOL] assert get_auth_primitives_v2 ( ship_it_instance_config ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : [string] , [string] : None , [string] : None , [string] : True , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : None , [string] : [number] , [string] : { } , } , { [string] : [string] } , False , ) , ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : [string] , [string] : None , [string] : None , [string] : True , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : None , [string] : [number] , [string] : { } , } , { [string] : [string] } , True , ) , ) , ) def test_generic_validation_v2 ( monkeypatch , release_info , values , raises ) : [EOL] release_name = [string] [EOL] ReleaseClassMock = MagicMock ( ) [EOL] attrs = { [string] : release_info } [EOL] ReleaseClassMock . configure_mock ( ** attrs ) [EOL] [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] check_release_has_values_v2 ( ReleaseClassMock , release_name , { } , ** values ) [EOL] else : [EOL] check_release_has_values_v2 ( ReleaseClassMock , release_name , { } , ** values ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ) , ) def test_same_timing ( time1 , time2 , expected ) : [EOL] assert same_timing ( time1 , time2 ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , { [string] : [string] , [string] : [string] } ) , ( [string] , { [string] : [string] , [string] : [string] } ) , ( [string] , { [string] : [string] , [string] : [string] } ) , ) , ) def test_request_headers ( api_root , expected ) : [EOL] assert get_request_headers ( api_root ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] import os [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] from scriptworker import client [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] import shipitscript [EOL] from shipitscript import script , ship_actions [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [ [string] , [string] ] , ) ) @ pytest . mark . asyncio async def test_mark_as_shipped ( context , monkeypatch , scopes ) : [EOL] context . task [ [string] ] = scopes [EOL] [EOL] mark_as_shipped_v2_mock = MagicMock ( ) [EOL] monkeypatch . setattr ( ship_actions , [string] , mark_as_shipped_v2_mock ) [EOL] [EOL] await script . async_main ( context ) [EOL] mark_as_shipped_v2_mock . assert_called_with ( { [string] : scopes [ - [number] ] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , } , [string] , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [ [string] ] , [string] : { [string] : [string] } , [string] : [ [string] , [string] ] , } , False , ) , ( { [string] : [ [string] ] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } , [string] : [ [string] ] , } , True , ) , ) , ) @ pytest . mark . asyncio async def test_async_main ( context , monkeypatch , task , raises ) : [EOL] context . task = task [EOL] [EOL] mark_as_shipped_v2_mock = MagicMock ( ) [EOL] monkeypatch . setattr ( ship_actions , [string] , mark_as_shipped_v2_mock ) [EOL] [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await script . async_main ( context ) [EOL] else : [EOL] await script . async_main ( context ) [EOL] [EOL] [EOL] def test_get_default_config ( ) : [EOL] parent_dir = os . path . dirname ( os . getcwd ( ) ) [EOL] data_dir = os . path . join ( os . path . dirname ( shipitscript . __file__ ) , [string] ) [EOL] assert script . get_default_config ( ) == { [string] : os . path . join ( parent_dir , [string] ) , [string] : False , [string] : os . path . join ( data_dir , [string] ) , [string] : os . path . join ( data_dir , [string] ) , } [EOL] [EOL] [EOL] def test_main ( monkeypatch ) : [EOL] sync_main_mock = MagicMock ( ) [EOL] monkeypatch . setattr ( client , [string] , sync_main_mock ) [EOL] script . main ( ) [EOL] sync_main_mock . asset_called_once_with ( script . async_main , default_config = script . get_default_config ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] import shipitscript . pushlog_scan as pushlog [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [string] , { [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , } , [string] , ) , ( [string] , [string] , [string] , { [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , } , [string] , ) , ( [string] , [string] , [string] , { [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , } , [string] , ) , ( [string] , [string] , [string] , { [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , } , [string] , ) , ( [string] , [string] , [string] , { [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , [string] : { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } , } , [string] , ) , ] , ) def test_get_shippable_revision_build ( requests_mock , branch , last_shipped_rev , cron_rev , ret_json , shippable_rev ) : [EOL] requests_mock . get ( pushlog . URL . format ( branch = branch ) , json = ret_json ) [EOL] assert pushlog . get_shippable_revision_build ( branch , last_shipped_rev , cron_rev ) == shippable_rev [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import unittest [EOL] import json [EOL] import os [EOL] import tempfile [EOL] from unittest . mock import MagicMock [EOL] [EOL] import shipitscript . ship_actions [EOL] from shipitscript . script import main [EOL] [EOL] this_dir = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] project_dir = os . path . dirname ( shipitscript . __file__ ) [EOL] project_data_dir = os . path . join ( project_dir , [string] ) [EOL] [EOL] [EOL] MARK_AS_SHIPPED_TASK_DEFINITION_TEMPLATE = [string] [EOL] [EOL] CONFIG_TEMPLATE = [string] [EOL] [EOL] [EOL] def test_main_mark_release_as_shipped_v2 ( monkeypatch ) : [EOL] ReleaseClassMock = MagicMock ( ) [EOL] release_instance_mock = MagicMock ( ) [EOL] release_info = { [string] : [string] } [EOL] attrs = { [string] : release_info } [EOL] release_instance_mock . configure_mock ( ** attrs ) [EOL] ReleaseClassMock . side_effect = lambda * args , ** kwargs : release_instance_mock [EOL] monkeypatch . setattr ( shipitscript . ship_actions , [string] , ReleaseClassMock ) [EOL] [EOL] with tempfile . TemporaryDirectory ( ) as temp_dir : [EOL] work_dir = os . path . join ( temp_dir , [string] ) [EOL] os . makedirs ( work_dir ) [EOL] config_path = os . path . join ( temp_dir , [string] ) [EOL] config_v2 = json . loads ( CONFIG_TEMPLATE . format ( work_dir = work_dir , project_data_dir = project_data_dir ) ) [EOL] with open ( config_path , [string] ) as config_file : [EOL] json . dump ( config_v2 , config_file ) [EOL] [EOL] with open ( os . path . join ( work_dir , [string] ) , [string] ) as task_file : [EOL] task_file . write ( MARK_AS_SHIPPED_TASK_DEFINITION_TEMPLATE . format ( release_name = [string] ) ) [EOL] [EOL] main ( config_path = config_path ) [EOL] [EOL] ReleaseClassMock . assert_called_with ( api_root = [string] , taskcluster_access_token = [string] , taskcluster_client_id = [string] , timeout = [number] ) [EOL] release_instance_mock . update_status . assert_called_with ( [string] , status = [string] , headers = { [string] : [string] , [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Any , Type , Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import re [EOL] [EOL] [EOL] def _tokens2re ( ** tokens ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] all_tokens = [string] . join ( [string] % ( name , value ) for name , value in tokens . items ( ) ) [EOL] nonescaped = [string] % all_tokens [EOL] [EOL] [comment] [EOL] [comment] [EOL] return re . compile ( [string] % ( nonescaped , [string] ) ) [EOL] [EOL] [EOL] UNQUOTED_TOKENS_RE = _tokens2re ( whitespace = [string] , quote = [string] , comment = [string] , special = [string] , backslashed = [string] , ) [EOL] [EOL] DOUBLY_QUOTED_TOKENS_RE = _tokens2re ( quote = [string] , backslashedquote = [string] , special = [string] , backslashed = [string] , ) [EOL] [EOL] ESCAPED_NEWLINES_RE = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] SHELL_QUOTE_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] class MetaCharacterException ( Exception ) : [EOL] def __init__ ( self , char ) : [EOL] self . char = char [EOL] [EOL] [EOL] class _ClineSplitter ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cline ) : [EOL] self . arg = None [EOL] self . cline = cline [EOL] self . result = [ ] [EOL] self . _parse_unquoted ( ) [EOL] [EOL] def _push ( self , str ) : [EOL] [docstring] [EOL] if self . arg is None : [EOL] self . arg = [string] [EOL] self . arg += str [EOL] [EOL] def _next ( self ) : [EOL] [docstring] [EOL] if self . arg is None : [EOL] return [EOL] self . result . append ( self . arg ) [EOL] self . arg = None [EOL] [EOL] def _parse_unquoted ( self ) : [EOL] [docstring] [EOL] while self . cline : [EOL] [comment] [EOL] m = UNQUOTED_TOKENS_RE . search ( self . cline ) [EOL] [comment] [EOL] [comment] [EOL] if not m : [EOL] self . _push ( self . cline ) [EOL] break [EOL] [comment] [EOL] [comment] [EOL] if m . start ( ) : [EOL] self . _push ( self . cline [ : m . start ( ) ] ) [EOL] self . cline = self . cline [ m . end ( ) : ] [EOL] [EOL] match = { name : value for name , value in m . groupdict ( ) . items ( ) if value } [EOL] if [string] in match : [EOL] [comment] [EOL] if match [ [string] ] == [string] : [EOL] self . _parse_doubly_quoted ( ) [EOL] else : [EOL] self . _parse_quoted ( ) [EOL] elif [string] in match : [EOL] [comment] [EOL] [comment] [EOL] break [EOL] elif [string] in match : [EOL] [comment] [EOL] [comment] [EOL] raise MetaCharacterException ( match [ [string] ] ) [EOL] elif [string] in match : [EOL] [comment] [EOL] self . _next ( ) [EOL] elif [string] in match : [EOL] [comment] [EOL] self . _push ( [string] ) [EOL] elif [string] in match : [EOL] [comment] [EOL] [comment] [EOL] self . _push ( match [ [string] ] [ [number] ] ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL] if self . arg : [EOL] self . _next ( ) [EOL] [EOL] def _parse_quoted ( self ) : [EOL] [comment] [EOL] index = self . cline . find ( [string] ) [EOL] if index == - [number] : [EOL] raise Exception ( [string] ) [EOL] self . _push ( self . cline [ : index ] ) [EOL] self . cline = self . cline [ index + [number] : ] [EOL] [EOL] def _parse_doubly_quoted ( self ) : [EOL] if not self . cline : [EOL] raise Exception ( [string] ) [EOL] while self . cline : [EOL] m = DOUBLY_QUOTED_TOKENS_RE . search ( self . cline ) [EOL] if not m : [EOL] raise Exception ( [string] ) [EOL] self . _push ( self . cline [ : m . start ( ) ] ) [EOL] self . cline = self . cline [ m . end ( ) : ] [EOL] match = { name : value for name , value in m . groupdict ( ) . items ( ) if value } [EOL] if [string] in match : [EOL] [comment] [EOL] [comment] [EOL] return [EOL] elif [string] in match : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] raise MetaCharacterException ( match [ [string] ] ) [EOL] elif [string] in match : [EOL] [comment] [EOL] self . _push ( [string] ) [EOL] elif [string] in match : [EOL] [comment] [EOL] self . _push ( [string] ) [EOL] elif [string] in match : [EOL] [comment] [EOL] self . _push ( match [ [string] ] ) [EOL] [EOL] [EOL] def split ( cline ) : [EOL] [docstring] [EOL] s = ESCAPED_NEWLINES_RE . sub ( [string] , cline ) [EOL] return _ClineSplitter ( s ) . result [EOL] [EOL] [EOL] def _quote ( s ) : [EOL] [docstring] [EOL] if type ( s ) == int : [EOL] return [string] % s [EOL] [EOL] [comment] [EOL] if s and not SHELL_QUOTE_RE . search ( s ) and not s . startswith ( [string] ) : [EOL] return s [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] t = type ( s ) [EOL] return t ( [string] ) % s . replace ( t ( [string] ) , t ( [string] ) ) [EOL] [EOL] [EOL] def quote ( * strings ) : [EOL] [docstring] [EOL] return [string] . join ( _quote ( s ) for s in strings ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import vendored [EOL] [docstring] [EOL] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import binascii [EOL] import hashlib [EOL] import logging [EOL] import os [EOL] import urlparse [EOL] [EOL] from mozbuild . util import ( mkdir , ) [EOL] import mozpack . path as mozpath [EOL] from dlmanager import ( DownloadManager , PersistLimit , ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] MIN_CACHED_ARTIFACTS = [number] [EOL] [EOL] [comment] [EOL] MAX_CACHED_ARTIFACTS_SIZE = [number] * [number] * [number] [EOL] [EOL] [EOL] class ArtifactPersistLimit ( PersistLimit ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , log = None ) : [EOL] super ( ArtifactPersistLimit , self ) . __init__ ( size_limit = MAX_CACHED_ARTIFACTS_SIZE , file_limit = MIN_CACHED_ARTIFACTS ) [EOL] self . _log = log [EOL] self . _registering_dir = False [EOL] self . _downloaded_now = set ( ) [EOL] [EOL] def log ( self , * args , ** kwargs ) : [EOL] if self . _log : [EOL] self . _log ( * args , ** kwargs ) [EOL] [EOL] def register_file ( self , path ) : [EOL] if path . endswith ( [string] ) or path . endswith ( [string] ) or os . path . basename ( path ) == [string] : [EOL] return [EOL] if not self . _registering_dir : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] os . utime ( path , None ) [EOL] except OSError : [EOL] pass [EOL] self . _downloaded_now . add ( path ) [EOL] super ( ArtifactPersistLimit , self ) . register_file ( path ) [EOL] [EOL] def register_dir_content ( self , directory , pattern = [string] ) : [EOL] self . _registering_dir = True [EOL] super ( ArtifactPersistLimit , self ) . register_dir_content ( directory , pattern ) [EOL] self . _registering_dir = False [EOL] [EOL] def remove_old_files ( self ) : [EOL] from dlmanager import fs [EOL] files = sorted ( self . files , key = lambda f : f . stat . st_atime ) [EOL] kept = [ ] [EOL] while len ( files ) > self . file_limit and self . _files_size >= self . size_limit : [EOL] f = files . pop ( [number] ) [EOL] if f . path in self . _downloaded_now : [EOL] kept . append ( f ) [EOL] continue [EOL] try : [EOL] fs . remove ( f . path ) [EOL] except WindowsError : [EOL] [comment] [EOL] [comment] [EOL] kept . append ( f ) [EOL] continue [EOL] self . log ( logging . INFO , [string] , { [string] : f . path } , [string] ) [EOL] self . _files_size -= f . stat . st_size [EOL] self . files = files + kept [EOL] [EOL] def remove_all ( self ) : [EOL] from dlmanager import fs [EOL] for f in self . files : [EOL] fs . remove ( f . path ) [EOL] self . _files_size = [number] [EOL] self . files = [ ] [EOL] [EOL] [EOL] class ArtifactCache ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cache_dir , log = None , skip_cache = False ) : [EOL] mkdir ( cache_dir , not_indexed = True ) [EOL] self . _cache_dir = cache_dir [EOL] self . _log = log [EOL] self . _skip_cache = skip_cache [EOL] self . _persist_limit = ArtifactPersistLimit ( log ) [EOL] self . _download_manager = DownloadManager ( self . _cache_dir , persist_limit = self . _persist_limit ) [EOL] self . _last_dl_update = - [number] [EOL] [EOL] def log ( self , * args , ** kwargs ) : [EOL] if self . _log : [EOL] self . _log ( * args , ** kwargs ) [EOL] [EOL] def fetch ( self , url , force = False ) : [EOL] fname = os . path . basename ( url ) [EOL] try : [EOL] [comment] [EOL] if len ( fname ) not in ( [number] , [number] , [number] , [number] , [number] , [number] ) : [EOL] raise TypeError ( ) [EOL] binascii . unhexlify ( fname ) [EOL] except TypeError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] hash = hashlib . sha256 ( url ) . hexdigest ( ) [ : [number] ] [EOL] [comment] [EOL] basename = os . path . basename ( urlparse . urlparse ( url ) . path ) [EOL] fname = hash + [string] + basename [EOL] [EOL] path = os . path . abspath ( mozpath . join ( self . _cache_dir , fname ) ) [EOL] if self . _skip_cache and os . path . exists ( path ) : [EOL] self . log ( logging . INFO , [string] , { [string] : path } , [string] ) [EOL] os . remove ( path ) [EOL] [EOL] self . log ( logging . INFO , [string] , { [string] : path } , [string] ) [EOL] try : [EOL] dl = self . _download_manager . download ( url , fname ) [EOL] [EOL] def download_progress ( dl , bytes_so_far , total_size ) : [EOL] if not total_size : [EOL] return [EOL] percent = ( float ( bytes_so_far ) / total_size ) * [number] [EOL] now = int ( percent / [number] ) [EOL] if now == self . _last_dl_update : [EOL] return [EOL] self . _last_dl_update = now [EOL] self . log ( logging . INFO , [string] , { [string] : bytes_so_far , [string] : total_size , [string] : percent } , [string] ) [EOL] [EOL] if dl : [EOL] dl . set_progress ( download_progress ) [EOL] dl . wait ( ) [EOL] else : [EOL] [comment] [EOL] path = os . path . join ( self . _cache_dir , fname ) [EOL] self . _persist_limit . register_file ( path ) [EOL] [EOL] self . log ( logging . INFO , [string] , { [string] : os . path . abspath ( mozpath . join ( self . _cache_dir , fname ) ) } , [string] ) [EOL] return os . path . abspath ( mozpath . join ( self . _cache_dir , fname ) ) [EOL] finally : [EOL] [comment] [EOL] self . _download_manager . cancel ( ) [EOL] [EOL] def clear_cache ( self ) : [EOL] if self . _skip_cache : [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] return [EOL] [EOL] self . _persist_limit . remove_all ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.artifact_cache.ArtifactPersistLimit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.artifact_cache.ArtifactPersistLimit$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set , Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] [EOL] import psutil [EOL] [EOL] from distutils . util import strtobool [EOL] from distutils . version import LooseVersion [EOL] import mozpack . path as mozpath [EOL] [EOL] [comment] [EOL] PROCESSORS_THRESHOLD = [number] [EOL] [EOL] [comment] [EOL] MEMORY_THRESHOLD = [number] [EOL] [EOL] [comment] [EOL] FREESPACE_THRESHOLD = [number] [EOL] [EOL] [comment] [EOL] LATEST_MOZILLABUILD_VERSION = [string] [EOL] [EOL] DISABLE_LASTACCESS_WIN = [string] [EOL] [EOL] [EOL] class Doctor ( object ) : [EOL] def __init__ ( self , srcdir , objdir , fix ) : [EOL] self . srcdir = mozpath . normpath ( srcdir ) [EOL] self . objdir = mozpath . normpath ( objdir ) [EOL] self . srcdir_mount = self . getmount ( self . srcdir ) [EOL] self . objdir_mount = self . getmount ( self . objdir ) [EOL] self . path_mounts = [ ( [string] , self . srcdir , self . srcdir_mount ) , ( [string] , self . objdir , self . objdir_mount ) ] [EOL] self . fix = fix [EOL] self . results = [ ] [EOL] [EOL] def check_all ( self ) : [EOL] checks = [ [string] , [string] , [string] , [string] , [string] ] [EOL] for check in checks : [EOL] self . report ( getattr ( self , check ) ) [EOL] good = True [EOL] fixable = False [EOL] denied = False [EOL] for result in self . results : [EOL] if result . get ( [string] ) != [string] : [EOL] good = False [EOL] if result . get ( [string] , False ) : [EOL] fixable = True [EOL] if result . get ( [string] , False ) : [EOL] denied = True [EOL] if denied : [EOL] print ( [string] ) [EOL] elif False and fixable : [comment] [EOL] print ( [string] ) [EOL] return int ( not good ) [EOL] [EOL] def getmount ( self , path ) : [EOL] while path != [string] and not os . path . ismount ( path ) : [EOL] path = mozpath . abspath ( mozpath . join ( path , os . pardir ) ) [EOL] return path [EOL] [EOL] def prompt_bool ( self , prompt , limit = [number] ) : [EOL] [docstring] [EOL] valid = False [EOL] while not valid and limit > [number] : [EOL] try : [EOL] choice = strtobool ( raw_input ( prompt + [string] ) ) [EOL] valid = True [EOL] except ValueError : [EOL] print ( [string] ) [EOL] limit -= [number] [EOL] [EOL] if limit > [number] : [EOL] return choice [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] def report ( self , results ) : [EOL] [comment] [EOL] if isinstance ( results , dict ) : [EOL] results = [ results ] [EOL] for result in results : [EOL] status = result . get ( [string] , [string] ) [EOL] if status == [string] : [EOL] continue [EOL] self . results . append ( result ) [EOL] print ( [string] % ( result . get ( [string] , [string] ) , status ) ) . expandtabs ( [number] ) [EOL] [EOL] @ property def platform ( self ) : [EOL] platform = getattr ( self , [string] , None ) [EOL] if not platform : [EOL] platform = sys . platform [EOL] while platform [ - [number] ] . isdigit ( ) : [EOL] platform = platform [ : - [number] ] [EOL] setattr ( self , [string] , platform ) [EOL] return platform [EOL] [EOL] @ property def cpu ( self ) : [EOL] cpu_count = psutil . cpu_count ( ) [EOL] if cpu_count < PROCESSORS_THRESHOLD : [EOL] status = [string] [EOL] desc = [string] % ( cpu_count , PROCESSORS_THRESHOLD ) [EOL] else : [EOL] status = [string] [EOL] desc = [string] % ( cpu_count , PROCESSORS_THRESHOLD ) [EOL] return { [string] : status , [string] : desc } [EOL] [EOL] @ property def memory ( self ) : [EOL] memory = psutil . virtual_memory ( ) . total [EOL] [comment] [EOL] memory_GB = memory / [number] ** [number] [EOL] if memory_GB < MEMORY_THRESHOLD : [EOL] status = [string] [EOL] desc = [string] % ( memory_GB , MEMORY_THRESHOLD ) [EOL] else : [EOL] status = [string] [EOL] desc = [string] % ( memory_GB , MEMORY_THRESHOLD ) [EOL] return { [string] : status , [string] : desc } [EOL] [EOL] @ property def storage_freespace ( self ) : [EOL] results = [ ] [EOL] desc = [string] [EOL] mountpoint_line = self . srcdir_mount != self . objdir_mount [EOL] for ( purpose , path , mount ) in self . path_mounts : [EOL] desc += [string] % ( purpose , path ) [EOL] if not mountpoint_line : [EOL] mountpoint_line = True [EOL] continue [EOL] try : [EOL] usage = psutil . disk_usage ( mount ) [EOL] freespace , size = usage . free , usage . total [EOL] freespace_GB = freespace / [number] ** [number] [EOL] size_GB = size / [number] ** [number] [EOL] if freespace_GB < FREESPACE_THRESHOLD : [EOL] status = [string] [EOL] desc += [string] % ( mount , freespace_GB , size_GB , FREESPACE_THRESHOLD ) [EOL] else : [EOL] status = [string] [EOL] desc += [string] % ( mount , freespace_GB , size_GB , FREESPACE_THRESHOLD ) [EOL] except OSError : [EOL] status = [string] [EOL] desc += [string] [EOL] results . append ( { [string] : status , [string] : desc } ) [EOL] return results [EOL] [EOL] @ property def fs_lastaccess ( self ) : [EOL] results = [ ] [EOL] if self . platform == [string] : [EOL] fixable = False [EOL] denied = False [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] command = [string] . split ( [string] ) [EOL] fsutil_output = subprocess . check_output ( command ) [EOL] disablelastaccess = int ( fsutil_output . partition ( [string] ) [ [number] ] [ [number] ] ) [EOL] except subprocess . CalledProcessError : [EOL] disablelastaccess = - [number] [EOL] status = [string] [EOL] desc = [string] [EOL] if disablelastaccess == [number] : [EOL] status = [string] [EOL] desc = [string] [EOL] elif disablelastaccess == [number] : [EOL] if False : [comment] [EOL] choice = self . prompt_bool ( DISABLE_LASTACCESS_WIN ) [EOL] if not choice : [EOL] return { [string] : [string] , [string] : [string] } [EOL] try : [EOL] command = [string] . split ( [string] ) [EOL] fsutil_output = subprocess . check_output ( command ) [EOL] status = [string] [EOL] desc = [string] [EOL] except subprocess . CalledProcessError as e : [EOL] desc = [string] [EOL] if e . output . find ( [string] ) != - [number] : [EOL] status = [string] [EOL] denied = True [EOL] else : [EOL] status = [string] [EOL] else : [EOL] status = [string] [EOL] desc = [string] [EOL] fixable = True [EOL] results . append ( { [string] : status , [string] : desc , [string] : fixable , [string] : denied } ) [EOL] elif self . platform in [ [string] , [string] , [string] ] : [EOL] common_mountpoint = self . srcdir_mount == self . objdir_mount [EOL] for ( purpose , path , mount ) in self . path_mounts : [EOL] results . append ( self . check_mount_lastaccess ( mount ) ) [EOL] if common_mountpoint : [EOL] break [EOL] else : [EOL] results . append ( { [string] : [string] } ) [EOL] return results [EOL] [EOL] def check_mount_lastaccess ( self , mount ) : [EOL] partitions = psutil . disk_partitions ( ) [EOL] atime_opts = { [string] , [string] , [string] , [string] } [EOL] option = [string] [EOL] for partition in partitions : [EOL] if partition . mountpoint == mount : [EOL] mount_opts = set ( partition . opts . split ( [string] ) ) [EOL] intersection = list ( atime_opts & mount_opts ) [EOL] if len ( intersection ) == [number] : [EOL] option = intersection [ [number] ] [EOL] break [EOL] if not option : [EOL] status = [string] [EOL] if self . platform == [string] : [EOL] option = [string] [EOL] else : [EOL] option = [string] [EOL] desc = [string] % ( mount , option ) [EOL] elif option == [string] or option == [string] : [EOL] status = [string] [EOL] desc = [string] % ( mount , option ) [EOL] elif option == [string] or option == [string] : [EOL] status = [string] [EOL] desc = [string] % ( mount , option ) [EOL] return { [string] : status , [string] : desc } [EOL] [EOL] @ property def mozillabuild ( self ) : [EOL] if self . platform != [string] : [EOL] return { [string] : [string] } [EOL] MOZILLABUILD = mozpath . normpath ( os . environ . get ( [string] , [string] ) ) [EOL] if not MOZILLABUILD or not os . path . exists ( MOZILLABUILD ) : [EOL] return { [string] : [string] } [EOL] try : [EOL] with open ( mozpath . join ( MOZILLABUILD , [string] ) , [string] ) as fh : [EOL] version = fh . readline ( ) [EOL] if not version : [EOL] raise ValueError ( ) [EOL] if LooseVersion ( version ) < LooseVersion ( LATEST_MOZILLABUILD_VERSION ) : [EOL] status = [string] [EOL] desc = [string] % ( version , LATEST_MOZILLABUILD_VERSION ) [EOL] else : [EOL] status = [string] [EOL] desc = [string] % version [EOL] except ( IOError , ValueError ) : [EOL] status = [string] [EOL] desc = [string] [EOL] return { [string] : status , [string] : desc } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Optional , Any , Literal , Union , Dict , List [EOL] import typing [EOL] import distutils [EOL] import vendored [EOL] import typing_extensions [EOL] import subprocess [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import distutils . sysconfig [EOL] import os [EOL] import shutil [EOL] import subprocess [EOL] import sys [EOL] import warnings [EOL] [EOL] from distutils . version import LooseVersion [EOL] [EOL] IS_NATIVE_WIN = ( sys . platform == [string] and os . sep == [string] ) [EOL] IS_MSYS2 = ( sys . platform == [string] and os . sep == [string] ) [EOL] IS_CYGWIN = ( sys . platform == [string] ) [EOL] [EOL] [comment] [EOL] MINIMUM_PYTHON_VERSIONS = { [number] : LooseVersion ( [string] ) , [number] : LooseVersion ( [string] ) } [EOL] [EOL] [EOL] UPGRADE_WINDOWS = [string] . lstrip ( ) [EOL] [EOL] UPGRADE_OTHER = [string] . lstrip ( ) [EOL] [EOL] here = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] class VirtualenvManager ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , topsrcdir , topobjdir , virtualenv_path , log_handle , manifest_path ) : [EOL] [docstring] [EOL] assert os . path . isabs ( manifest_path ) , [string] % (manifest_path) [EOL] self . topsrcdir = topsrcdir [EOL] self . topobjdir = topobjdir [EOL] self . virtualenv_root = virtualenv_path [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . exe_info_path = os . path . join ( self . virtualenv_root , [string] ) [EOL] [EOL] self . log_handle = log_handle [EOL] self . manifest_path = manifest_path [EOL] [EOL] @ property def virtualenv_script_path ( self ) : [EOL] [docstring] [EOL] return os . path . join ( self . topsrcdir , [string] , [string] , [string] , [string] ) [EOL] [EOL] @ property def bin_path ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if IS_CYGWIN or IS_NATIVE_WIN : [EOL] return os . path . join ( self . virtualenv_root , [string] ) [EOL] [EOL] return os . path . join ( self . virtualenv_root , [string] ) [EOL] [EOL] @ property def python_path ( self ) : [EOL] binary = [string] [EOL] if sys . platform in ( [string] , [string] ) : [EOL] binary += [string] [EOL] [EOL] return os . path . join ( self . bin_path , binary ) [EOL] [EOL] @ property def version_info ( self ) : [EOL] return eval ( subprocess . check_output ( [ self . python_path , [string] , [string] ] ) ) [EOL] [EOL] @ property def activate_path ( self ) : [EOL] return os . path . join ( self . bin_path , [string] ) [EOL] [EOL] def get_exe_info ( self ) : [EOL] [docstring] [EOL] with open ( self . exe_info_path , [string] ) as fh : [EOL] version , size = fh . read ( ) . splitlines ( ) [EOL] return int ( version ) , int ( size ) [EOL] [EOL] def write_exe_info ( self , python ) : [EOL] [docstring] [EOL] ver = subprocess . check_output ( [ python , [string] , [string] ] ) . rstrip ( ) [EOL] with open ( self . exe_info_path , [string] ) as fh : [EOL] fh . write ( [string] % ver ) [EOL] fh . write ( [string] % os . path . getsize ( python ) ) [EOL] [EOL] def up_to_date ( self , python = sys . executable ) : [EOL] [docstring] [EOL] [EOL] deps = [ self . manifest_path , __file__ ] [EOL] [EOL] [comment] [EOL] if not os . path . exists ( self . virtualenv_root ) or not os . path . exists ( self . activate_path ) : [EOL] [EOL] return False [EOL] [EOL] [comment] [EOL] activate_mtime = os . path . getmtime ( self . activate_path ) [EOL] dep_mtime = max ( os . path . getmtime ( p ) for p in deps ) [EOL] if dep_mtime > activate_mtime : [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] python_size = os . path . getsize ( python ) [EOL] if ( ( python , python_size ) != ( self . python_path , os . path . getsize ( self . python_path ) ) and ( sys . hexversion , python_size ) != self . get_exe_info ( ) ) : [EOL] return False [EOL] [EOL] [comment] [EOL] submanifests = [ i [ [number] ] for i in self . packages ( ) if i [ [number] ] == [string] ] [EOL] for submanifest in submanifests : [EOL] submanifest = os . path . join ( self . topsrcdir , submanifest ) [EOL] submanager = VirtualenvManager ( self . topsrcdir , self . topobjdir , self . virtualenv_root , self . log_handle , submanifest ) [EOL] if not submanager . up_to_date ( python ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def ensure ( self , python = sys . executable ) : [EOL] [docstring] [EOL] if self . up_to_date ( python ) : [EOL] return self . virtualenv_root [EOL] return self . build ( python ) [EOL] [EOL] def _log_process_output ( self , * args , ** kwargs ) : [EOL] if hasattr ( self . log_handle , [string] ) : [EOL] return subprocess . call ( * args , stdout = self . log_handle , stderr = subprocess . STDOUT , ** kwargs ) [EOL] [EOL] proc = subprocess . Popen ( * args , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , ** kwargs ) [EOL] [EOL] for line in proc . stdout : [EOL] self . log_handle . write ( line ) [EOL] [EOL] return proc . wait ( ) [EOL] [EOL] def create ( self , python = sys . executable ) : [EOL] [docstring] [EOL] env = dict ( os . environ ) [EOL] env . pop ( [string] , None ) [EOL] [EOL] args = [ python , self . virtualenv_script_path , [string] , self . virtualenv_root ] [EOL] [EOL] result = self . _log_process_output ( args , env = env ) [EOL] [EOL] if result : [EOL] raise Exception ( [string] % self . virtualenv_root ) [EOL] [EOL] self . write_exe_info ( python ) [EOL] [EOL] return self . virtualenv_root [EOL] [EOL] def packages ( self ) : [EOL] with open ( self . manifest_path , [string] ) as fh : [EOL] packages = [ line . rstrip ( ) . split ( [string] ) for line in fh ] [EOL] return packages [EOL] [EOL] def populate ( self ) : [EOL] [docstring] [EOL] packages = self . packages ( ) [EOL] python_lib = distutils . sysconfig . get_python_lib ( ) [EOL] [EOL] def handle_package ( package ) : [EOL] if package [ [number] ] == [string] : [EOL] assert len ( package ) >= [number] [EOL] [EOL] self . call_setup ( os . path . join ( self . topsrcdir , package [ [number] ] ) , package [ [number] : ] ) [EOL] [EOL] return True [EOL] [EOL] if package [ [number] ] == [string] : [EOL] assert len ( package ) == [number] [EOL] [EOL] src = os . path . join ( self . topsrcdir , package [ [number] ] ) [EOL] dst = os . path . join ( python_lib , os . path . basename ( package [ [number] ] ) ) [EOL] [EOL] shutil . copy ( src , dst ) [EOL] [EOL] return True [EOL] [EOL] if package [ [number] ] == [string] : [EOL] assert len ( package ) == [number] [EOL] [EOL] src = os . path . join ( self . topsrcdir , package [ [number] ] ) [EOL] assert os . path . isfile ( src ) , [string] % src [EOL] submanager = VirtualenvManager ( self . topsrcdir , self . topobjdir , self . virtualenv_root , self . log_handle , src ) [EOL] submanager . populate ( ) [EOL] [EOL] return True [EOL] [EOL] if package [ [number] ] . endswith ( [string] ) : [EOL] assert len ( package ) == [number] [EOL] [EOL] path = os . path . join ( self . topsrcdir , package [ [number] ] ) [EOL] [EOL] with open ( os . path . join ( python_lib , package [ [number] ] ) , [string] ) as f : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] f . write ( [string] % os . path . relpath ( path , python_lib ) ) [EOL] except ValueError : [EOL] [comment] [EOL] f . write ( [string] % os . path . join ( python_lib , path ) ) [EOL] [EOL] return True [EOL] [EOL] if package [ [number] ] == [string] : [EOL] try : [EOL] handle_package ( package [ [number] : ] ) [EOL] return True [EOL] except Exception : [EOL] print ( [string] , [string] % [string] . join ( package ) , file = self . log_handle ) [EOL] return False [EOL] [EOL] if package [ [number] ] in ( [string] , [string] ) : [EOL] for_win = not package [ [number] ] . startswith ( [string] ) [EOL] is_win = sys . platform == [string] [EOL] if is_win == for_win : [EOL] handle_package ( package [ [number] : ] ) [EOL] return True [EOL] [EOL] if package [ [number] ] in ( [string] , [string] ) : [EOL] for_python3 = package [ [number] ] . endswith ( [string] ) [EOL] is_python3 = sys . version_info [ [number] ] > [number] [EOL] if is_python3 == for_python3 : [EOL] handle_package ( package [ [number] : ] ) [EOL] return True [EOL] [EOL] if package [ [number] ] == [string] : [EOL] assert len ( package ) == [number] [EOL] path = os . path . join ( self . topobjdir , package [ [number] ] ) [EOL] [EOL] with open ( os . path . join ( python_lib , [string] ) , [string] ) as f : [EOL] f . write ( [string] % path ) [EOL] [EOL] return True [EOL] [EOL] raise Exception ( [string] % package [ [number] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] IGNORE_ENV_VARIABLES = ( [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] try : [EOL] old_target = os . environ . get ( [string] , None ) [EOL] sysconfig_target = distutils . sysconfig . get_config_var ( [string] ) [EOL] [EOL] if sysconfig_target is not None : [EOL] os . environ [ [string] ] = sysconfig_target [EOL] [EOL] old_env_variables = { } [EOL] for k in IGNORE_ENV_VARIABLES : [EOL] if k not in os . environ : [EOL] continue [EOL] [EOL] old_env_variables [ k ] = os . environ [ k ] [EOL] del os . environ [ k ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if sys . platform in ( [string] , [string] ) and [string] not in os . environ : [EOL] [EOL] warnings . warn ( [string] [string] [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for ver in ( [string] , [string] , [string] ) : [EOL] var = [string] % ver [EOL] if var in os . environ : [EOL] os . environ [ [string] ] = os . environ [ var ] [EOL] break [EOL] [EOL] for package in packages : [EOL] handle_package ( package ) [EOL] [EOL] sitecustomize = os . path . join ( os . path . dirname ( os . __file__ ) , [string] ) [EOL] with open ( sitecustomize , [string] ) as f : [EOL] f . write ( [string] [string] [string] ) [EOL] [EOL] finally : [EOL] os . environ . pop ( [string] , None ) [EOL] [EOL] if old_target is not None : [EOL] os . environ [ [string] ] = old_target [EOL] [EOL] os . environ . update ( old_env_variables ) [EOL] [EOL] def call_setup ( self , directory , arguments ) : [EOL] [docstring] [EOL] setup = os . path . join ( directory , [string] ) [EOL] [EOL] program = [ self . python_path , setup ] [EOL] program . extend ( arguments ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] try : [EOL] output = subprocess . check_output ( program , cwd = directory , stderr = subprocess . STDOUT ) [EOL] print ( output ) [EOL] except subprocess . CalledProcessError as e : [EOL] if [string] in e . output : [EOL] print ( [string] ) [EOL] else : [EOL] print ( e . output ) [EOL] [EOL] raise Exception ( [string] % directory ) [EOL] [EOL] def build ( self , python = sys . executable ) : [EOL] [docstring] [EOL] [EOL] self . create ( python ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] args = [ self . python_path , __file__ , [string] , self . topsrcdir , self . topobjdir , self . virtualenv_root , self . manifest_path ] [EOL] [EOL] result = self . _log_process_output ( args , cwd = self . topsrcdir ) [EOL] [EOL] if result != [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] os . utime ( self . activate_path , None ) [EOL] [EOL] return self . virtualenv_root [EOL] [EOL] def activate ( self ) : [EOL] [docstring] [EOL] [EOL] execfile ( self . activate_path , dict ( __file__ = self . activate_path ) ) [EOL] if isinstance ( os . environ [ [string] ] , unicode ) : [EOL] os . environ [ [string] ] = os . environ [ [string] ] . encode ( [string] ) [EOL] [EOL] def install_pip_package ( self , package , vendored = False ) : [EOL] [docstring] [EOL] from pip . req import InstallRequirement [EOL] [EOL] req = InstallRequirement . from_line ( package ) [EOL] req . check_if_exists ( ) [EOL] if req . satisfied_by is not None : [EOL] return [EOL] [EOL] args = [ [string] , [string] , package , ] [EOL] [EOL] if vendored : [EOL] args . extend ( [ [string] , [string] , ] ) [EOL] [EOL] return self . _run_pip ( args ) [EOL] [EOL] def install_pip_requirements ( self , path , require_hashes = True , quiet = False , vendored = False ) : [EOL] [docstring] [EOL] [EOL] if not os . path . isabs ( path ) : [EOL] path = os . path . join ( self . topsrcdir , path ) [EOL] [EOL] args = [ [string] , [string] , path , ] [EOL] [EOL] if require_hashes : [EOL] args . append ( [string] ) [EOL] [EOL] if quiet : [EOL] args . append ( [string] ) [EOL] [EOL] if vendored : [EOL] args . extend ( [ [string] , [string] , ] ) [EOL] [EOL] return self . _run_pip ( args ) [EOL] [EOL] def _run_pip ( self , args ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pip = os . path . join ( self . bin_path , [string] ) [EOL] subprocess . check_call ( [ pip ] + args , stderr = subprocess . STDOUT , cwd = self . topsrcdir ) [EOL] [EOL] def activate_pipenv ( self , pipfile = None , populate = False , python = None ) : [EOL] [docstring] [EOL] pipenv = os . path . join ( self . bin_path , [string] ) [EOL] env = os . environ . copy ( ) [EOL] env . update ( { [string] : [string] , [string] : str ( os . path . normpath ( os . path . join ( self . topobjdir , [string] ) ) ) , } ) [EOL] [EOL] if python is not None : [EOL] env [ [string] ] = str ( python ) [EOL] env [ [string] ] = str ( python ) [EOL] [EOL] def ensure_venv ( ) : [EOL] [docstring] [EOL] venv = get_venv ( ) [EOL] if venv is not None : [EOL] return venv [EOL] if python is not None : [EOL] subprocess . check_call ( [ pipenv , [string] , python ] , stderr = subprocess . STDOUT , env = env ) [EOL] return get_venv ( ) [EOL] [EOL] def get_venv ( ) : [EOL] [docstring] [EOL] try : [EOL] return subprocess . check_output ( [ pipenv , [string] ] , stderr = subprocess . STDOUT , env = env ) . rstrip ( ) [EOL] except subprocess . CalledProcessError : [EOL] [comment] [EOL] return None [EOL] [EOL] if pipfile is not None : [EOL] [comment] [EOL] env [ [string] ] = str ( pipfile ) [EOL] subprocess . check_call ( [ pipenv , [string] ] , stderr = subprocess . STDOUT , env = env ) [EOL] [EOL] self . virtualenv_root = ensure_venv ( ) [EOL] [EOL] if populate : [EOL] [comment] [EOL] subprocess . check_call ( [ pipenv , [string] , [string] , os . path . join ( here , [string] ) , [string] , self . topsrcdir , self . topobjdir , self . virtualenv_root , self . manifest_path ] , stderr = subprocess . STDOUT , env = env ) [EOL] [EOL] self . activate ( ) [EOL] [EOL] [EOL] def verify_python_version ( log_handle ) : [EOL] [docstring] [EOL] major , minor , micro = sys . version_info [ : [number] ] [EOL] [EOL] our = LooseVersion ( [string] % ( major , minor , micro ) ) [EOL] [EOL] if major not in MINIMUM_PYTHON_VERSIONS or our < MINIMUM_PYTHON_VERSIONS [ major ] : [EOL] log_handle . write ( [string] ) [EOL] for minver in MINIMUM_PYTHON_VERSIONS . values ( ) : [EOL] log_handle . write ( [string] % minver ) [EOL] log_handle . write ( [string] % our ) [EOL] [EOL] if os . name in ( [string] , [string] ) : [EOL] log_handle . write ( UPGRADE_WINDOWS ) [EOL] else : [EOL] log_handle . write ( UPGRADE_OTHER ) [EOL] [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) < [number] : [EOL] print ( [string] [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] verify_python_version ( sys . stdout ) [EOL] [EOL] topsrcdir , topobjdir , virtualenv_path , manifest_path = sys . argv [ [number] : [number] ] [EOL] populate = False [EOL] [EOL] [comment] [EOL] if sys . argv [ [number] ] == [string] : [EOL] populate = True [EOL] topsrcdir , topobjdir , virtualenv_path , manifest_path = sys . argv [ [number] : ] [EOL] [EOL] manager = VirtualenvManager ( topsrcdir , topobjdir , virtualenv_path , sys . stdout , manifest_path ) [EOL] [EOL] if populate : [EOL] manager . populate ( ) [EOL] else : [EOL] manager . ensure ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,distutils.version.LooseVersion]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $vendored.mozbuild.mozbuild.virtualenv.VirtualenvManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $vendored.mozbuild.mozbuild.virtualenv.VirtualenvManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.list$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $vendored.mozbuild.mozbuild.virtualenv.VirtualenvManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $vendored.mozbuild.mozbuild.virtualenv.VirtualenvManager$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.int,builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,distutils.version.LooseVersion]$ 0 0 0 $typing.Dict[builtins.int,distutils.version.LooseVersion]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,distutils.version.LooseVersion]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.virtualenv.VirtualenvManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $vendored.mozbuild.mozbuild.virtualenv.VirtualenvManager$ 0 $builtins.bool$ 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.virtualenv.VirtualenvManager$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Iterator [EOL] import tarfile [EOL] import typing [EOL] import requests [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import logging [EOL] from mozbuild . base import ( MozbuildObject , ) [EOL] import mozfile [EOL] import mozpack . path as mozpath [EOL] import os [EOL] import requests [EOL] import re [EOL] import sys [EOL] import tarfile [EOL] from urlparse import urlparse [EOL] [EOL] [EOL] class VendorDav1d ( MozbuildObject ) : [EOL] def upstream_snapshot ( self , revision ) : [EOL] [docstring] [EOL] if [string] in self . repo_url : [EOL] return mozpath . join ( self . repo_url , [string] , [string] , revision + [string] ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def upstream_commit ( self , revision ) : [EOL] [docstring] [EOL] if [string] in self . repo_url : [EOL] return self . upstream_gitlab_commit ( revision ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def upstream_validate ( self , url ) : [EOL] [docstring] [EOL] host = urlparse ( url ) . netloc [EOL] valid_domains = ( [string] ) [EOL] if not any ( filter ( lambda domain : domain in host , valid_domains ) ) : [EOL] self . log ( logging . ERROR , [string] , { } , [string] % host ) [EOL] sys . exit ( [number] ) [EOL] [EOL] def upstream_gitlab_commit ( self , revision ) : [EOL] [docstring] [EOL] gitlab_api = [string] [comment] [EOL] url = mozpath . join ( gitlab_api , revision ) [EOL] self . log ( logging . INFO , [string] , { [string] : url } , [string] ) [EOL] req = requests . get ( url ) [EOL] req . raise_for_status ( ) [EOL] info = req . json ( ) [EOL] return ( info [ [string] ] , info [ [string] ] ) [EOL] [EOL] def fetch_and_unpack ( self , revision , target ) : [EOL] [docstring] [EOL] url = self . upstream_snapshot ( revision ) [EOL] self . log ( logging . INFO , [string] , { [string] : url } , [string] ) [EOL] prefix = [string] + revision [EOL] filename = prefix + [string] [EOL] with open ( filename , [string] ) as f : [EOL] req = requests . get ( url , stream = True ) [EOL] for data in req . iter_content ( [number] ) : [EOL] f . write ( data ) [EOL] tar = tarfile . open ( filename ) [EOL] bad_paths = filter ( lambda name : name . startswith ( [string] ) or [string] in name , tar . getnames ( ) ) [EOL] if any ( bad_paths ) : [EOL] raise Exception ( [string] [string] % bad_paths [ [number] ] ) [EOL] self . log ( logging . INFO , [string] , { } , [string] % target ) [EOL] mozfile . remove ( target ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] tar . extractall ( target ) [EOL] [comment] [EOL] if all ( map ( lambda name : name . startswith ( prefix ) , tar . getnames ( ) ) ) : [EOL] tardir = mozpath . join ( target , prefix ) [EOL] os . system ( [string] % ( tardir , tardir , target ) ) [EOL] os . rmdir ( tardir ) [EOL] [comment] [EOL] mozfile . remove ( filename ) [EOL] [EOL] def update_yaml ( self , revision , timestamp , target ) : [EOL] filename = mozpath . join ( target , [string] ) [EOL] with open ( filename ) as f : [EOL] yaml = f . read ( ) [EOL] [EOL] prefix = [string] [EOL] if prefix in yaml : [EOL] new_yaml = re . sub ( prefix + [string] , prefix + [string] % ( revision , timestamp ) , yaml , flags = re . MULTILINE ) [EOL] else : [EOL] new_yaml = [string] % ( yaml , prefix , revision ) [EOL] [EOL] if yaml != new_yaml : [EOL] with open ( filename , [string] ) as f : [EOL] f . write ( new_yaml ) [EOL] [EOL] def update_vcs_version ( self , revision , vendor_dir , glue_dir ) : [EOL] src_filename = mozpath . join ( vendor_dir , [string] ) [EOL] dst_filename = mozpath . join ( glue_dir , [string] ) [EOL] with open ( src_filename ) as f : [EOL] vcs_version_in = f . read ( ) [EOL] vcs_version = vcs_version_in . replace ( [string] , revision ) [EOL] with open ( dst_filename , [string] ) as f : [EOL] f . write ( vcs_version ) [EOL] [EOL] def clean_upstream ( self , target ) : [EOL] [docstring] [EOL] mozfile . remove ( mozpath . join ( target , [string] ) ) [EOL] mozfile . remove ( mozpath . join ( target , [string] ) ) [EOL] mozfile . remove ( mozpath . join ( target , [string] , [string] ) ) [EOL] mozfile . remove ( mozpath . join ( target , [string] , [string] ) ) [EOL] [EOL] def check_modified_files ( self ) : [EOL] [docstring] [EOL] modified = self . repository . get_changed_files ( [string] ) [EOL] if modified : [EOL] self . log ( logging . ERROR , [string] , { } , [string] . format ( files = [string] . join ( sorted ( modified ) ) ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] def vendor ( self , revision , repo , ignore_modified = False ) : [EOL] self . populate_logger ( ) [EOL] self . log_manager . enable_unstructured ( ) [EOL] [EOL] if not ignore_modified : [EOL] self . check_modified_files ( ) [EOL] if not revision : [EOL] revision = [string] [EOL] if repo : [EOL] self . repo_url = repo [EOL] else : [EOL] self . repo_url = [string] [EOL] self . upstream_validate ( self . repo_url ) [EOL] [EOL] commit , timestamp = self . upstream_commit ( revision ) [EOL] [EOL] vendor_dir = mozpath . join ( self . topsrcdir , [string] ) [EOL] self . fetch_and_unpack ( commit , vendor_dir ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] self . clean_upstream ( vendor_dir ) [EOL] glue_dir = mozpath . join ( self . topsrcdir , [string] ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] self . update_yaml ( commit , timestamp , glue_dir ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] self . update_vcs_version ( commit , vendor_dir , glue_dir ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] self . repository . add_remove_files ( vendor_dir ) [EOL] self . repository . add_remove_files ( glue_dir ) [EOL] self . log ( logging . INFO , [string] , { [string] : revision } , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import requests [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import BaseHTTPServer [EOL] import json [EOL] import os [EOL] [EOL] import requests [EOL] [EOL] [EOL] class HTTPHandler ( BaseHTTPServer . BaseHTTPRequestHandler ) : [EOL] def do_GET ( self ) : [EOL] s = self . server . wrapper [EOL] p = self . path [EOL] [EOL] if p == [string] : [EOL] self . send_response ( [number] ) [EOL] self . send_header ( [string] , [string] ) [EOL] self . end_headers ( ) [EOL] [EOL] keys = sorted ( s . json_files . keys ( ) ) [EOL] json . dump ( { [string] : keys } , self . wfile ) [EOL] return [EOL] [EOL] if p . startswith ( [string] ) : [EOL] key = p [ len ( [string] ) : ] [EOL] [EOL] if key not in s . json_files : [EOL] self . send_error ( [number] ) [EOL] return [EOL] [EOL] self . send_response ( [number] ) [EOL] self . send_header ( [string] , [string] ) [EOL] self . end_headers ( ) [EOL] [EOL] self . wfile . write ( s . json_files [ key ] ) [EOL] return [EOL] [EOL] if p == [string] : [EOL] p = [string] [EOL] [EOL] self . serve_docroot ( s . doc_root , p [ [number] : ] ) [EOL] [EOL] def do_POST ( self ) : [EOL] if self . path == [string] : [EOL] self . server . wrapper . do_shutdown = True [EOL] self . send_response ( [number] ) [EOL] return [EOL] [EOL] self . send_error ( [number] ) [EOL] [EOL] def serve_docroot ( self , root , path ) : [EOL] local_path = os . path . normpath ( os . path . join ( root , path ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not local_path . startswith ( root ) : [EOL] self . send_error ( [number] ) [EOL] [EOL] if not os . path . exists ( local_path ) : [EOL] self . send_error ( [number] ) [EOL] return [EOL] [EOL] if os . path . isdir ( local_path ) : [EOL] self . send_error ( [number] ) [EOL] return [EOL] [EOL] self . send_response ( [number] ) [EOL] ct = [string] [EOL] if path . endswith ( [string] ) : [EOL] ct = [string] [EOL] [EOL] self . send_header ( [string] , ct ) [EOL] self . end_headers ( ) [EOL] [EOL] with open ( local_path , [string] ) as fh : [EOL] self . wfile . write ( fh . read ( ) ) [EOL] [EOL] [EOL] class BuildViewerServer ( object ) : [EOL] def __init__ ( self , address = [string] , port = [number] ) : [EOL] [comment] [EOL] pkg_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] doc_root = os . path . join ( pkg_dir , [string] , [string] ) [EOL] assert os . path . isdir ( doc_root ) [EOL] [EOL] self . doc_root = doc_root [EOL] self . json_files = { } [EOL] [EOL] self . server = BaseHTTPServer . HTTPServer ( ( address , port ) , HTTPHandler ) [EOL] self . server . wrapper = self [EOL] self . do_shutdown = False [EOL] [EOL] @ property def url ( self ) : [EOL] hostname , port = self . server . server_address [EOL] return [string] % ( hostname , port ) [EOL] [EOL] def add_resource_json_file ( self , key , path ) : [EOL] [docstring] [EOL] with open ( path , [string] ) as fh : [EOL] self . json_files [ key ] = fh . read ( ) [EOL] [EOL] def add_resource_json_url ( self , key , url ) : [EOL] [docstring] [EOL] r = requests . get ( url ) [EOL] if r . status_code != [number] : [EOL] raise Exception ( [string] ) [EOL] self . json_files [ key ] = r . text [EOL] [EOL] def run ( self ) : [EOL] while not self . do_shutdown : [EOL] self . server . handle_request ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Tuple , Set , Any , Type , Dict , List [EOL] import typing [EOL] import vendored [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import filecmp [EOL] import os [EOL] import re [EOL] import sys [EOL] import subprocess [EOL] import traceback [EOL] [EOL] from mozpack import path as mozpath [EOL] [EOL] [EOL] MOZ_MYCONFIG_ERROR = [string] . strip ( ) [EOL] [EOL] MOZCONFIG_LEGACY_PATH = [string] . strip ( ) [EOL] [EOL] MOZCONFIG_BAD_EXIT_CODE = [string] . strip ( ) [EOL] [EOL] MOZCONFIG_BAD_OUTPUT = [string] . strip ( ) [EOL] [EOL] [EOL] class MozconfigFindException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class MozconfigLoadException ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , message , output = None ) : [EOL] self . path = path [EOL] self . output = output [EOL] Exception . __init__ ( self , message ) [EOL] [EOL] [EOL] class MozconfigLoader ( object ) : [EOL] [docstring] [EOL] [EOL] RE_MAKE_VARIABLE = re . compile ( [string] , re . VERBOSE ) [EOL] [EOL] [comment] [EOL] DEFAULT_TOPSRCDIR_PATHS = ( [string] , [string] ) [EOL] [EOL] DEPRECATED_TOPSRCDIR_PATHS = ( [string] , [string] ) [EOL] DEPRECATED_HOME_PATHS = ( [string] , [string] , [string] ) [EOL] [EOL] IGNORE_SHELL_VARIABLES = { [string] } [EOL] [EOL] ENVIRONMENT_VARIABLES = { [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] AUTODETECT = object ( ) [EOL] [EOL] def __init__ ( self , topsrcdir ) : [EOL] self . topsrcdir = topsrcdir [EOL] [EOL] @ property def _loader_script ( self ) : [EOL] our_dir = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] return os . path . join ( our_dir , [string] ) [EOL] [EOL] def find_mozconfig ( self , env = os . environ ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] if [string] in env : [EOL] raise MozconfigFindException ( MOZ_MYCONFIG_ERROR ) [EOL] [EOL] env_path = env . get ( [string] , None ) or None [EOL] if env_path is not None : [EOL] if not os . path . isabs ( env_path ) : [EOL] potential_roots = [ self . topsrcdir , os . getcwd ( ) ] [EOL] [comment] [EOL] [comment] [EOL] potential_roots = set ( os . path . abspath ( p ) for p in potential_roots ) [EOL] existing = [ root for root in potential_roots if os . path . exists ( os . path . join ( root , env_path ) ) ] [EOL] if len ( existing ) > [number] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mozconfigs = [ os . path . join ( root , env_path ) for root in existing ] [EOL] if not all ( map ( lambda p1 , p2 : filecmp . cmp ( p1 , p2 , shallow = False ) , mozconfigs [ : - [number] ] , mozconfigs [ [number] : ] ) ) : [EOL] raise MozconfigFindException ( [string] + [string] + [string] . join ( potential_roots ) + [string] ) [EOL] elif not existing : [EOL] raise MozconfigFindException ( [string] + [string] + [string] . join ( potential_roots ) ) [EOL] [EOL] env_path = os . path . join ( existing [ [number] ] , env_path ) [EOL] elif not os . path . exists ( env_path ) : [comment] [EOL] raise MozconfigFindException ( [string] [string] + env_path ) [EOL] [EOL] if not os . path . isfile ( env_path ) : [EOL] raise MozconfigFindException ( [string] [string] + env_path ) [EOL] [EOL] srcdir_paths = [ os . path . join ( self . topsrcdir , p ) for p in self . DEFAULT_TOPSRCDIR_PATHS ] [EOL] existing = [ p for p in srcdir_paths if os . path . isfile ( p ) ] [EOL] [EOL] if env_path is None and len ( existing ) > [number] : [EOL] raise MozconfigFindException ( [string] [string] + [string] . join ( existing ) ) [EOL] [EOL] path = None [EOL] [EOL] if env_path is not None : [EOL] path = env_path [EOL] elif len ( existing ) : [EOL] assert len ( existing ) == [number] [EOL] path = existing [ [number] ] [EOL] [EOL] if path is not None : [EOL] return os . path . abspath ( path ) [EOL] [EOL] deprecated_paths = [ os . path . join ( self . topsrcdir , s ) for s in self . DEPRECATED_TOPSRCDIR_PATHS ] [EOL] [EOL] home = env . get ( [string] , None ) [EOL] if home is not None : [EOL] deprecated_paths . extend ( [ os . path . join ( home , s ) for s in self . DEPRECATED_HOME_PATHS ] ) [EOL] [EOL] for path in deprecated_paths : [EOL] if os . path . exists ( path ) : [EOL] raise MozconfigFindException ( MOZCONFIG_LEGACY_PATH % ( path , self . topsrcdir ) ) [EOL] [EOL] return None [EOL] [EOL] def read_mozconfig ( self , path = None ) : [EOL] [docstring] [EOL] if path is self . AUTODETECT : [EOL] path = self . find_mozconfig ( ) [EOL] [EOL] result = { [string] : path , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , } [EOL] [EOL] if path is None : [EOL] return result [EOL] [EOL] path = mozpath . normsep ( path ) [EOL] [EOL] result [ [string] ] = [ ] [EOL] result [ [string] ] = [ ] [EOL] result [ [string] ] = [ ] [EOL] [EOL] env = dict ( os . environ ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] shell = [string] [EOL] if [string] in os . environ : [EOL] shell = os . environ [ [string] ] + [string] [EOL] if sys . platform == [string] : [EOL] shell = shell + [string] [EOL] [EOL] command = [ shell , mozpath . normsep ( self . _loader_script ) , mozpath . normsep ( self . topsrcdir ) , path , sys . executable , mozpath . join ( mozpath . dirname ( self . _loader_script ) , [string] , [string] ) ] [EOL] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] output = subprocess . check_output ( command , stderr = subprocess . STDOUT , cwd = self . topsrcdir , env = env ) [EOL] except subprocess . CalledProcessError as e : [EOL] lines = e . output . splitlines ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] index = lines . index ( [string] ) [EOL] lines = lines [ index + [number] : ] [EOL] except ValueError : [EOL] pass [EOL] [EOL] raise MozconfigLoadException ( path , MOZCONFIG_BAD_EXIT_CODE , lines ) [EOL] [EOL] try : [EOL] parsed = self . _parse_loader_output ( output ) [EOL] except AssertionError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] print ( [string] ) [EOL] traceback . print_exc ( ) [EOL] raise MozconfigLoadException ( path , MOZCONFIG_BAD_OUTPUT , output . splitlines ( ) ) [EOL] [EOL] def diff_vars ( vars_before , vars_after ) : [EOL] set1 = set ( vars_before . keys ( ) ) - self . IGNORE_SHELL_VARIABLES [EOL] set2 = set ( vars_after . keys ( ) ) - self . IGNORE_SHELL_VARIABLES [EOL] added = set2 - set1 [EOL] removed = set1 - set2 [EOL] maybe_modified = set1 & set2 [EOL] changed = { [string] : { } , [string] : { } , [string] : { } , [string] : { } , } [EOL] [EOL] for key in added : [EOL] changed [ [string] ] [ key ] = vars_after [ key ] [EOL] [EOL] for key in removed : [EOL] changed [ [string] ] [ key ] = vars_before [ key ] [EOL] [EOL] for key in maybe_modified : [EOL] if vars_before [ key ] != vars_after [ key ] : [EOL] changed [ [string] ] [ key ] = ( vars_before [ key ] , vars_after [ key ] ) [EOL] elif key in self . ENVIRONMENT_VARIABLES : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] changed [ [string] ] [ key ] = vars_after [ key ] [EOL] [EOL] return changed [EOL] [EOL] result [ [string] ] = diff_vars ( parsed [ [string] ] , parsed [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def filt ( x , y ) : return { k : v for k , v in x . items ( ) if k not in y } [EOL] result [ [string] ] = diff_vars ( filt ( parsed [ [string] ] , parsed [ [string] ] ) , filt ( parsed [ [string] ] , parsed [ [string] ] ) ) [EOL] [EOL] result [ [string] ] = [ self . _expand ( o ) for o in parsed [ [string] ] ] [EOL] [EOL] if [string] in parsed [ [string] ] : [EOL] result [ [string] ] = parsed [ [string] ] [ [string] ] [EOL] [EOL] mk = [ self . _expand ( o ) for o in parsed [ [string] ] ] [EOL] [EOL] for o in mk : [EOL] match = self . RE_MAKE_VARIABLE . match ( o ) [EOL] [EOL] if match is None : [EOL] result [ [string] ] . append ( o ) [EOL] continue [EOL] [EOL] name , value = match . group ( [string] ) , match . group ( [string] ) [EOL] [EOL] if name == [string] : [EOL] result [ [string] ] = value . split ( ) [EOL] continue [EOL] [EOL] if name == [string] : [EOL] result [ [string] ] = value [EOL] continue [EOL] [EOL] result [ [string] ] . append ( o ) [EOL] [EOL] return result [EOL] [EOL] def _parse_loader_output ( self , output ) : [EOL] mk_options = [ ] [EOL] ac_options = [ ] [EOL] before_source = { } [EOL] after_source = { } [EOL] env_before_source = { } [EOL] env_after_source = { } [EOL] [EOL] current = None [EOL] current_type = None [EOL] in_variable = None [EOL] [EOL] for line in output . splitlines ( ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] line = line . decode ( [string] if sys . platform == [string] else [string] , [string] ) [EOL] [EOL] if not line : [EOL] continue [EOL] [EOL] if line . startswith ( [string] ) : [EOL] assert current_type is None [EOL] assert current is None [EOL] assert not in_variable [EOL] current_type = line [ len ( [string] ) : ] [EOL] current = [ ] [EOL] continue [EOL] [EOL] if line . startswith ( [string] ) : [EOL] assert not in_variable [EOL] section = line [ len ( [string] ) : ] [EOL] assert current_type == section [EOL] [EOL] if current_type == [string] : [EOL] ac_options . append ( [string] . join ( current ) ) [EOL] elif current_type == [string] : [EOL] mk_options . append ( [string] . join ( current ) ) [EOL] [EOL] current = None [EOL] current_type = None [EOL] continue [EOL] [EOL] assert current_type is not None [EOL] [EOL] vars_mapping = { [string] : before_source , [string] : after_source , [string] : env_before_source , [string] : env_after_source , } [EOL] [EOL] if current_type in vars_mapping : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] name = in_variable [EOL] value = None [EOL] if in_variable : [EOL] [comment] [EOL] if line . endswith ( [string] ) and not line . endswith ( [string] ) : [EOL] current . append ( line [ : - [number] ] ) [EOL] value = [string] . join ( current ) [EOL] in_variable = None [EOL] else : [EOL] current . append ( line ) [EOL] continue [EOL] else : [EOL] equal_pos = line . find ( [string] ) [EOL] [EOL] if equal_pos < [number] : [EOL] [comment] [EOL] continue [EOL] [EOL] name = line [ [number] : equal_pos ] [EOL] value = line [ equal_pos + [number] : ] [EOL] [EOL] if len ( value ) : [EOL] has_quote = value [ [number] ] == [string] [EOL] [EOL] if has_quote : [EOL] value = value [ [number] : ] [EOL] [EOL] [comment] [EOL] if has_quote and not value . endswith ( [string] ) : [EOL] in_variable = name [EOL] current . append ( value ) [EOL] continue [EOL] else : [EOL] value = value [ : - [number] ] if has_quote else value [EOL] [EOL] assert name is not None [EOL] [EOL] vars_mapping [ current_type ] [ name ] = value [EOL] [EOL] current = [ ] [EOL] [EOL] continue [EOL] [EOL] current . append ( line ) [EOL] [EOL] return { [string] : mk_options , [string] : ac_options , [string] : before_source , [string] : after_source , [string] : env_before_source , [string] : env_after_source , } [EOL] [EOL] def _expand ( self , s ) : [EOL] return s . replace ( [string] , self . topsrcdir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $None$ 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 $None$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] import argparse [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import argparse [EOL] import math [EOL] import sys [EOL] import time [EOL] [EOL] [comment] [EOL] [comment] [EOL] V1_CUTOFF = [number] [comment] [EOL] [EOL] [EOL] def android_version_code_v0 ( buildid , cpu_arch = None , min_sdk = [number] , max_sdk = [number] ) : [EOL] base = int ( str ( buildid ) [ : [number] ] ) [EOL] [comment] [EOL] if not cpu_arch or cpu_arch == [string] : [EOL] [comment] [EOL] [comment] [EOL] return base + min_sdk + [number] [EOL] elif cpu_arch in [ [string] ] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return base + min_sdk + [number] [EOL] else : [EOL] raise ValueError ( [string] [string] % cpu_arch ) [EOL] [EOL] [EOL] def android_version_code_v1 ( buildid , cpu_arch = None , min_sdk = [number] , max_sdk = [number] ) : [EOL] [docstring] [EOL] def hours_since_cutoff ( buildid ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] fmt = [string] [EOL] build = time . strptime ( str ( buildid ) , fmt ) [EOL] cutoff = time . strptime ( str ( V1_CUTOFF ) , fmt ) [EOL] return int ( math . floor ( ( time . mktime ( build ) - time . mktime ( cutoff ) ) / ( [number] * [number] ) ) ) [EOL] [EOL] [comment] [EOL] base = hours_since_cutoff ( buildid ) [EOL] if base < [number] : [EOL] raise ValueError ( [string] [string] [string] % buildid ) [EOL] if base > [number] ** [number] : [EOL] raise ValueError ( [string] [string] [string] % buildid ) [EOL] if base > [number] ** [number] - [number] * [number] : [EOL] raise ValueError ( [string] [string] [string] % buildid ) [EOL] [EOL] version = [number] [EOL] [comment] [EOL] [comment] [EOL] version |= base << [number] [EOL] [EOL] [comment] [EOL] if cpu_arch in [ [string] , [string] ] : [EOL] version |= [number] << [number] [EOL] elif not cpu_arch or cpu_arch in [ [string] , [string] ] : [EOL] pass [EOL] else : [EOL] raise ValueError ( [string] [string] % cpu_arch ) [EOL] [EOL] [comment] [EOL] if cpu_arch in [ [string] , [string] ] : [EOL] version |= [number] << [number] [EOL] elif cpu_arch in [ [string] , [string] ] : [EOL] pass [EOL] else : [EOL] raise ValueError ( [string] [string] % cpu_arch ) [EOL] [EOL] [comment] [EOL] version |= [number] << [number] [EOL] [EOL] return version [EOL] [EOL] [EOL] def android_version_code ( buildid , * args , ** kwargs ) : [EOL] base = int ( str ( buildid ) ) [EOL] if base < V1_CUTOFF : [EOL] return android_version_code_v0 ( buildid , * args , ** kwargs ) [EOL] else : [EOL] return android_version_code_v1 ( buildid , * args , ** kwargs ) [EOL] [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( [string] , add_help = False ) [EOL] parser . add_argument ( [string] , action = [string] , default = False , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , choices = [ [string] , [string] , [string] , [string] , [string] ] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , help = [string] ) [EOL] [EOL] args = parser . parse_args ( argv ) [EOL] code = android_version_code ( args . buildid , cpu_arch = args . cpu_arch , min_sdk = args . min_sdk , max_sdk = args . max_sdk ) [EOL] print ( code ) [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Any , Iterator , Tuple [EOL] import typing [EOL] import requests [EOL] import tarfile [EOL] import typing_extensions [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import logging [EOL] from mozbuild . base import ( MozbuildObject , ) [EOL] import mozfile [EOL] import mozpack . path as mozpath [EOL] import os [EOL] import requests [EOL] import re [EOL] import sys [EOL] import tarfile [EOL] from urlparse import urlparse [EOL] [EOL] [EOL] class VendorAOM ( MozbuildObject ) : [EOL] def upstream_snapshot ( self , revision ) : [EOL] [docstring] [EOL] if [string] in self . repo_url : [EOL] return mozpath . join ( self . repo_url , [string] , revision + [string] ) [EOL] elif [string] in self . repo_url : [EOL] return mozpath . join ( self . repo_url , [string] , revision + [string] ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def upstream_commit ( self , revision ) : [EOL] [docstring] [EOL] if [string] in self . repo_url : [EOL] return self . upstream_googlesource_commit ( revision ) [EOL] elif [string] in self . repo_url : [EOL] return self . upstream_github_commit ( revision ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def upstream_validate ( self , url ) : [EOL] [docstring] [EOL] host = urlparse ( url ) . netloc [EOL] valid_domains = ( [string] , [string] ) [EOL] if not any ( filter ( lambda domain : domain in host , valid_domains ) ) : [EOL] self . log ( logging . ERROR , [string] , { } , [string] % host ) [EOL] sys . exit ( [number] ) [EOL] [EOL] def upstream_googlesource_commit ( self , revision ) : [EOL] [docstring] [EOL] url = mozpath . join ( self . repo_url , [string] , revision + [string] ) [EOL] self . log ( logging . INFO , [string] , { [string] : url } , [string] ) [EOL] req = requests . get ( url ) [EOL] req . raise_for_status ( ) [EOL] try : [EOL] info = req . json ( ) [EOL] except ValueError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import json [EOL] info = json . loads ( req . text [ [number] : ] ) [EOL] return ( info [ [string] ] , info [ [string] ] [ [string] ] ) [EOL] [EOL] def upstream_github_commit ( self , revision ) : [EOL] [docstring] [EOL] github_api = [string] [EOL] repo = urlparse ( self . repo_url ) . path [ [number] : ] [EOL] url = mozpath . join ( github_api , [string] , repo , [string] , revision ) [EOL] self . log ( logging . INFO , [string] , { [string] : url } , [string] ) [EOL] req = requests . get ( url ) [EOL] req . raise_for_status ( ) [EOL] info = req . json ( ) [EOL] return ( info [ [string] ] , info [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] def fetch_and_unpack ( self , revision , target ) : [EOL] [docstring] [EOL] url = self . upstream_snapshot ( revision ) [EOL] self . log ( logging . INFO , [string] , { [string] : url } , [string] ) [EOL] prefix = [string] + revision [EOL] filename = prefix + [string] [EOL] with open ( filename , [string] ) as f : [EOL] req = requests . get ( url , stream = True ) [EOL] for data in req . iter_content ( [number] ) : [EOL] f . write ( data ) [EOL] tar = tarfile . open ( filename ) [EOL] bad_paths = filter ( lambda name : name . startswith ( [string] ) or [string] in name , tar . getnames ( ) ) [EOL] if any ( bad_paths ) : [EOL] raise Exception ( [string] [string] % bad_paths [ [number] ] ) [EOL] self . log ( logging . INFO , [string] , { } , [string] % target ) [EOL] mozfile . remove ( target ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] tar . extractall ( target ) [EOL] [comment] [EOL] if all ( map ( lambda name : name . startswith ( prefix ) , tar . getnames ( ) ) ) : [EOL] tardir = mozpath . join ( target , prefix ) [EOL] os . system ( [string] % ( tardir , tardir , target ) ) [EOL] os . rmdir ( tardir ) [EOL] [comment] [EOL] mozfile . remove ( filename ) [EOL] [EOL] def update_readme ( self , revision , timestamp , target ) : [EOL] filename = mozpath . join ( target , [string] ) [EOL] with open ( filename ) as f : [EOL] readme = f . read ( ) [EOL] [EOL] prefix = [string] [EOL] if prefix in readme : [EOL] new_readme = re . sub ( prefix + [string] , prefix + [string] % ( revision , timestamp ) , readme ) [EOL] else : [EOL] new_readme = [string] % ( readme , prefix , revision ) [EOL] [EOL] prefix = [string] [EOL] new_readme = re . sub ( prefix + [string] , prefix + [string] % self . repo_url , new_readme ) [EOL] [EOL] if readme != new_readme : [EOL] with open ( filename , [string] ) as f : [EOL] f . write ( new_readme ) [EOL] [EOL] def clean_upstream ( self , target ) : [EOL] [docstring] [EOL] mozfile . remove ( mozpath . join ( target , [string] ) ) [EOL] mozfile . remove ( mozpath . join ( target , [string] ) ) [EOL] mozfile . remove ( mozpath . join ( target , [string] , [string] ) ) [EOL] mozfile . remove ( mozpath . join ( target , [string] , [string] ) ) [EOL] [EOL] def generate_sources ( self , target ) : [EOL] [docstring] [EOL] config_dir = mozpath . join ( target , [string] ) [EOL] self . log ( logging . INFO , [string] , { } , [string] % config_dir ) [EOL] mozfile . remove ( config_dir ) [EOL] self . run_process ( args = [ [string] ] , cwd = target , log_name = [string] ) [EOL] [EOL] def check_modified_files ( self ) : [EOL] [docstring] [EOL] modified = self . repository . get_changed_files ( [string] ) [EOL] if modified : [EOL] self . log ( logging . ERROR , [string] , { } , [string] . format ( files = [string] . join ( sorted ( modified ) ) ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] def vendor ( self , revision , repo , ignore_modified = False ) : [EOL] self . populate_logger ( ) [EOL] self . log_manager . enable_unstructured ( ) [EOL] [EOL] if not ignore_modified : [EOL] self . check_modified_files ( ) [EOL] if not revision : [EOL] revision = [string] [EOL] if repo : [EOL] self . repo_url = repo [EOL] else : [EOL] self . repo_url = [string] [EOL] self . upstream_validate ( self . repo_url ) [EOL] [EOL] commit , timestamp = self . upstream_commit ( revision ) [EOL] [EOL] vendor_dir = mozpath . join ( self . topsrcdir , [string] ) [EOL] self . fetch_and_unpack ( commit , vendor_dir ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] self . clean_upstream ( vendor_dir ) [EOL] glue_dir = mozpath . join ( self . topsrcdir , [string] ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] self . generate_sources ( glue_dir ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] self . update_readme ( commit , timestamp , glue_dir ) [EOL] self . repository . add_remove_files ( vendor_dir ) [EOL] self . log ( logging . INFO , [string] , { } , [string] ) [EOL] self . repository . add_remove_files ( vendor_dir ) [EOL] self . repository . add_remove_files ( glue_dir ) [EOL] self . log ( logging . INFO , [string] , { [string] : revision } , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import io [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import tempfile [EOL] import shutil [EOL] import mozpack . path as mozpath [EOL] import sys [EOL] import subprocess [EOL] from xml . dom import minidom [EOL] from mozbuild . util import ensureParentDir [EOL] [EOL] _MSI_ARCH = { [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def update_wsx ( wfile , pvalues ) : [EOL] [EOL] parsed = minidom . parse ( wfile ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for k , v in pvalues . items ( ) : [EOL] entry = parsed . createProcessingInstruction ( [string] , k + [string] + v + [string] ) [EOL] root = parsed . firstChild [EOL] parsed . insertBefore ( entry , root ) [EOL] [comment] [EOL] new_w_file = wfile + [string] [EOL] fh = open ( new_w_file , [string] ) [EOL] parsed . writexml ( fh ) [EOL] fh . close ( ) [EOL] shutil . move ( new_w_file , wfile ) [EOL] return wfile [EOL] [EOL] [EOL] def repackage_msi ( topsrcdir , wsx , version , locale , arch , setupexe , candle , light , output ) : [EOL] if sys . platform != [string] : [EOL] raise Exception ( [string] ) [EOL] if not os . path . isdir ( topsrcdir ) : [EOL] raise Exception ( [string] % topsrcdir ) [EOL] if not os . path . isfile ( wsx ) : [EOL] raise Exception ( [string] % wsx ) [EOL] if version is None : [EOL] raise Exception ( [string] ) [EOL] if locale is None : [EOL] raise Exception ( [string] ) [EOL] if arch is None or arch not in _MSI_ARCH . keys ( ) : [EOL] raise Exception ( [string] . format ( _MSI_ARCH . keys ( ) ) ) [EOL] if not os . path . isfile ( setupexe ) : [EOL] raise Exception ( [string] % setupexe ) [EOL] if candle is not None and not os . path . isfile ( candle ) : [EOL] raise Exception ( [string] % candle ) [EOL] if light is not None and not os . path . isfile ( light ) : [EOL] raise Exception ( [string] % light ) [EOL] embeddedVersion = [string] [EOL] [comment] [EOL] if [string] not in version and [string] not in version : [EOL] if version . endswith ( [string] ) : [EOL] parts = version [ : - [number] ] . split ( [string] ) [EOL] else : [EOL] parts = version . split ( [string] ) [EOL] while len ( parts ) < [number] : [EOL] parts . append ( [string] ) [EOL] embeddedVersion = [string] . join ( parts ) [EOL] [EOL] wsx = mozpath . realpath ( wsx ) [EOL] setupexe = mozpath . realpath ( setupexe ) [EOL] output = mozpath . realpath ( output ) [EOL] ensureParentDir ( output ) [EOL] [EOL] if sys . platform == [string] : [EOL] tmpdir = tempfile . mkdtemp ( ) [EOL] old_cwd = os . getcwd ( ) [EOL] try : [EOL] wsx_file = os . path . split ( wsx ) [ [number] ] [EOL] shutil . copy ( wsx , tmpdir ) [EOL] temp_wsx_file = os . path . join ( tmpdir , wsx_file ) [EOL] temp_wsx_file = mozpath . realpath ( temp_wsx_file ) [EOL] pre_values = { [string] : [string] , [string] : [string] , [string] : version , [string] : locale , [string] : _MSI_ARCH [ arch ] , [string] : setupexe , [string] : embeddedVersion } [EOL] [comment] [EOL] newfile = update_wsx ( temp_wsx_file , pre_values ) [EOL] wix_object_file = os . path . join ( tmpdir , [string] ) [EOL] env = os . environ . copy ( ) [EOL] if candle is None : [EOL] candle = [string] [EOL] cmd = [ candle , [string] , wix_object_file , newfile ] [EOL] subprocess . check_call ( cmd , env = env ) [EOL] wix_installer = wix_object_file . replace ( [string] , [string] ) [EOL] if light is None : [EOL] light = [string] [EOL] light_cmd = [ light , [string] , [string] , [string] , [string] , wix_installer , wix_object_file ] [EOL] subprocess . check_call ( light_cmd , env = env ) [EOL] os . remove ( wix_object_file ) [EOL] [comment] [EOL] shutil . move ( wix_installer , output ) [EOL] finally : [EOL] os . chdir ( old_cwd ) [EOL] shutil . rmtree ( tmpdir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import zipfile [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import tempfile [EOL] import shutil [EOL] import zipfile [EOL] import mozpack . path as mozpath [EOL] from mozbuild . action . exe_7z_archive import archive_exe [EOL] from mozbuild . util import ensureParentDir [EOL] [EOL] [EOL] def repackage_installer ( topsrcdir , tag , setupexe , package , output , package_name , sfx_stub , use_upx ) : [EOL] if package and not zipfile . is_zipfile ( package ) : [EOL] raise Exception ( [string] % package ) [EOL] if package is not None and package_name is None : [EOL] raise Exception ( [string] ) [EOL] if package is None and package_name is not None : [EOL] raise Exception ( [string] ) [EOL] [EOL] [comment] [EOL] tag = mozpath . realpath ( tag ) [EOL] output = mozpath . realpath ( output ) [EOL] ensureParentDir ( output ) [EOL] [EOL] tmpdir = tempfile . mkdtemp ( ) [EOL] old_cwd = os . getcwd ( ) [EOL] try : [EOL] if package : [EOL] z = zipfile . ZipFile ( package ) [EOL] z . extractall ( tmpdir ) [EOL] z . close ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] shutil . copyfile ( setupexe , mozpath . join ( tmpdir , mozpath . basename ( setupexe ) ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] os . chdir ( tmpdir ) [EOL] [EOL] sfx_package = mozpath . join ( topsrcdir , sfx_stub ) [EOL] [EOL] archive_exe ( package_name , tag , sfx_package , output , use_upx ) [EOL] [EOL] finally : [EOL] os . chdir ( old_cwd ) [EOL] shutil . rmtree ( tmpdir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] [EOL] [EOL] def check_top_objdir ( topobjdir ) : [EOL] top_make = os . path . join ( topobjdir , [string] ) [EOL] if not os . path . exists ( top_make ) : [EOL] print ( [string] [string] ) [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def get_build_vars ( directory , cmd ) : [EOL] build_vars = { } [EOL] [EOL] def on_line ( line ) : [EOL] elements = [ s . strip ( ) for s in line . split ( [string] , [number] ) ] [EOL] [EOL] if len ( elements ) != [number] : [EOL] return [EOL] [EOL] build_vars [ elements [ [number] ] ] = elements [ [number] ] [EOL] [EOL] try : [EOL] old_logger = cmd . log_manager . replace_terminal_handler ( None ) [EOL] cmd . _run_make ( directory = directory , target = [string] , log = False , print_directory = False , allow_parallel = False , silent = True , line_handler = on_line ) [EOL] finally : [EOL] cmd . log_manager . replace_terminal_handler ( old_logger ) [EOL] [EOL] return build_vars [EOL] [EOL] [EOL] def sanitize_cflags ( flags ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sanitized = [ ] [EOL] saw_xclang = False [EOL] for flag in flags : [EOL] if flag == [string] : [EOL] saw_xclang = True [EOL] elif saw_xclang : [EOL] saw_xclang = False [EOL] else : [EOL] sanitized . append ( flag ) [EOL] return sanitized [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Set , Pattern , Any , Dict , List [EOL] import typing [EOL] import vendored [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import errno [EOL] import json [EOL] import os [EOL] import re [EOL] [EOL] from mozbuild . util import hash_file [EOL] import mozpack . path as mozpath [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] RE_STRIP_COLORS = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] RE_CLANG_WARNING = re . compile ( [string] , re . X ) [EOL] [EOL] [comment] [EOL] RE_CLANG_CL_WARNING = re . compile ( [string] , re . X ) [EOL] [EOL] [comment] [EOL] RE_MSVC_WARNING = re . compile ( [string] , re . X ) [EOL] [EOL] IN_FILE_INCLUDED_FROM = [string] [EOL] [EOL] [EOL] class CompilerWarning ( dict ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] dict . __init__ ( self ) [EOL] [EOL] self [ [string] ] = None [EOL] self [ [string] ] = None [EOL] self [ [string] ] = None [EOL] self [ [string] ] = None [EOL] self [ [string] ] = None [EOL] [EOL] def copy ( self ) : [EOL] [docstring] [EOL] w = CompilerWarning ( ) [EOL] w . update ( self ) [EOL] return w [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def _cmpkey ( self ) : [EOL] return ( self [ [string] ] , self [ [string] ] , self [ [string] ] ) [EOL] [EOL] def _compare ( self , other , func ) : [EOL] if not isinstance ( other , CompilerWarning ) : [EOL] return NotImplemented [EOL] [EOL] return func ( self . _cmpkey ( ) , other . _cmpkey ( ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . _compare ( other , lambda s , o : s == o ) [EOL] [EOL] def __neq__ ( self , other ) : [EOL] return self . _compare ( other , lambda s , o : s != o ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . _compare ( other , lambda s , o : s < o ) [EOL] [EOL] def __le__ ( self , other ) : [EOL] return self . _compare ( other , lambda s , o : s <= o ) [EOL] [EOL] def __gt__ ( self , other ) : [EOL] return self . _compare ( other , lambda s , o : s > o ) [EOL] [EOL] def __ge__ ( self , other ) : [EOL] return self . _compare ( other , lambda s , o : s >= o ) [EOL] [EOL] def __hash__ ( self ) : [EOL] [docstring] [EOL] return hash ( tuple ( sorted ( self . items ( ) ) ) ) [EOL] [EOL] [EOL] class WarningsDatabase ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _files = { } [EOL] [EOL] def __len__ ( self ) : [EOL] i = [number] [EOL] for value in self . _files . values ( ) : [EOL] i += len ( value [ [string] ] ) [EOL] [EOL] return i [EOL] [EOL] def __iter__ ( self ) : [EOL] for value in self . _files . values ( ) : [EOL] for warning in value [ [string] ] : [EOL] yield warning [EOL] [EOL] def __contains__ ( self , item ) : [EOL] for value in self . _files . values ( ) : [EOL] for warning in value [ [string] ] : [EOL] if warning == item : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] @ property def warnings ( self ) : [EOL] [docstring] [EOL] for value in self . _files . values ( ) : [EOL] for w in value [ [string] ] : [EOL] yield w [EOL] [EOL] def type_counts ( self , dirpath = None ) : [EOL] [docstring] [EOL] [EOL] types = { } [EOL] for value in self . _files . values ( ) : [EOL] for warning in value [ [string] ] : [EOL] if dirpath and not mozpath . normsep ( warning [ [string] ] ) . startswith ( dirpath ) : [EOL] continue [EOL] flag = warning [ [string] ] [EOL] count = types . get ( flag , [number] ) [EOL] count += [number] [EOL] [EOL] types [ flag ] = count [EOL] [EOL] return types [EOL] [EOL] def has_file ( self , filename ) : [EOL] [docstring] [EOL] return filename in self . _files [EOL] [EOL] def warnings_for_file ( self , filename ) : [EOL] [docstring] [EOL] f = self . _files . get ( filename , { [string] : [ ] } ) [EOL] [EOL] for warning in f [ [string] ] : [EOL] yield warning [EOL] [EOL] def insert ( self , warning , compute_hash = True ) : [EOL] assert isinstance ( warning , CompilerWarning ) [EOL] [EOL] filename = warning [ [string] ] [EOL] [EOL] new_hash = None [EOL] [EOL] if compute_hash : [EOL] new_hash = hash_file ( filename ) [EOL] [EOL] if filename in self . _files : [EOL] if new_hash != self . _files [ filename ] [ [string] ] : [EOL] del self . _files [ filename ] [EOL] [EOL] value = self . _files . get ( filename , { [string] : new_hash , [string] : set ( ) , } ) [EOL] [EOL] value [ [string] ] . add ( warning ) [EOL] [EOL] self . _files [ filename ] = value [EOL] [EOL] def prune ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] filenames = self . _files . keys ( ) [EOL] for filename in filenames : [EOL] if not os . path . exists ( filename ) : [EOL] del self . _files [ filename ] [EOL] continue [EOL] [EOL] if self . _files [ filename ] [ [string] ] is None : [EOL] continue [EOL] [EOL] current_hash = hash_file ( filename ) [EOL] if current_hash != self . _files [ filename ] [ [string] ] : [EOL] del self . _files [ filename ] [EOL] continue [EOL] [EOL] def serialize ( self , fh ) : [EOL] [docstring] [EOL] obj = { [string] : { } } [EOL] [EOL] [comment] [EOL] for k , v in self . _files . iteritems ( ) : [EOL] obj [ [string] ] [ k ] = { } [EOL] [EOL] for k2 , v2 in v . iteritems ( ) : [EOL] normalized = v2 [EOL] [EOL] if k2 == [string] : [EOL] normalized = [ w for w in v2 ] [EOL] [EOL] obj [ [string] ] [ k ] [ k2 ] = normalized [EOL] [EOL] json . dump ( obj , fh , indent = [number] ) [EOL] [EOL] def deserialize ( self , fh ) : [EOL] [docstring] [EOL] obj = json . load ( fh ) [EOL] [EOL] self . _files = obj [ [string] ] [EOL] [EOL] [comment] [EOL] for filename , value in self . _files . iteritems ( ) : [EOL] for k , v in value . iteritems ( ) : [EOL] if k != [string] : [EOL] continue [EOL] [EOL] normalized = set ( ) [EOL] for d in v : [EOL] w = CompilerWarning ( ) [EOL] w . update ( d ) [EOL] normalized . add ( w ) [EOL] [EOL] self . _files [ filename ] [ [string] ] = normalized [EOL] [EOL] def load_from_file ( self , filename ) : [EOL] [docstring] [EOL] with open ( filename , [string] ) as fh : [EOL] self . deserialize ( fh ) [EOL] [EOL] def save_to_file ( self , filename ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] os . makedirs ( os . path . dirname ( filename ) ) [EOL] except OSError as e : [EOL] if e . errno != errno . EEXIST : [EOL] raise [EOL] with open ( filename , [string] ) as fh : [EOL] self . serialize ( fh ) [EOL] [EOL] [EOL] class WarningsCollector ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cb , objdir = None ) : [EOL] [docstring] [EOL] self . cb = cb [EOL] self . objdir = objdir [EOL] self . included_from = [ ] [EOL] [EOL] def process_line ( self , line ) : [EOL] [docstring] [EOL] [EOL] filtered = RE_STRIP_COLORS . sub ( [string] , line ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if filtered . startswith ( IN_FILE_INCLUDED_FROM ) : [EOL] included_from = filtered [ len ( IN_FILE_INCLUDED_FROM ) : ] [EOL] [EOL] parts = included_from . split ( [string] ) [EOL] [EOL] self . included_from . append ( parts [ [number] ] ) [EOL] [EOL] return [EOL] [EOL] warning = CompilerWarning ( ) [EOL] filename = None [EOL] [EOL] [comment] [EOL] match_clang = RE_CLANG_WARNING . match ( filtered ) [EOL] match_clang_cl = RE_CLANG_CL_WARNING . match ( filtered ) [EOL] match_msvc = RE_MSVC_WARNING . match ( filtered ) [EOL] if match_clang : [EOL] d = match_clang . groupdict ( ) [EOL] [EOL] filename = d [ [string] ] [EOL] warning [ [string] ] = int ( d [ [string] ] ) [EOL] warning [ [string] ] = int ( d [ [string] ] ) [EOL] warning [ [string] ] = d [ [string] ] [EOL] warning [ [string] ] = d [ [string] ] . rstrip ( ) [EOL] [EOL] elif match_clang_cl : [EOL] d = match_clang_cl . groupdict ( ) [EOL] [EOL] filename = d [ [string] ] [EOL] warning [ [string] ] = int ( d [ [string] ] ) [EOL] warning [ [string] ] = int ( d [ [string] ] ) [EOL] warning [ [string] ] = d [ [string] ] [EOL] warning [ [string] ] = d [ [string] ] . rstrip ( ) [EOL] [EOL] elif match_msvc : [EOL] d = match_msvc . groupdict ( ) [EOL] [EOL] filename = d [ [string] ] [EOL] warning [ [string] ] = int ( d [ [string] ] ) [EOL] warning [ [string] ] = d [ [string] ] [EOL] warning [ [string] ] = d [ [string] ] . rstrip ( ) [EOL] else : [EOL] self . included_from = [ ] [EOL] return None [EOL] [EOL] filename = os . path . normpath ( filename ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not os . path . isabs ( filename ) : [EOL] filename = self . _normalize_relative_path ( filename ) [EOL] [EOL] warning [ [string] ] = filename [EOL] [EOL] self . cb ( warning ) [EOL] [EOL] return warning [EOL] [EOL] def _normalize_relative_path ( self , filename ) : [EOL] [comment] [EOL] idx = filename . find ( [string] ) [EOL] if idx != - [number] : [EOL] return self . objdir + filename [ idx : ] [EOL] [EOL] for included_from in self . included_from : [EOL] source_dir = os . path . dirname ( included_from ) [EOL] [EOL] candidate = os . path . normpath ( os . path . join ( source_dir , filename ) ) [EOL] [EOL] if os . path . exists ( candidate ) : [EOL] return candidate [EOL] [EOL] return filename [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 $typing.Any$ 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 $typing.Any$ 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 $typing.Any$ 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 $vendored.mozbuild.mozbuild.compilation.warnings.CompilerWarning$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] cargo_extra_outputs = { [string] : [ [string] , [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , [string] , [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , [string] , ] , [string] : [ [string] , [string] , [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , [string] , ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [ [string] , [string] , ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , ] , [string] : [ [string] , [string] , ] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import argparse [EOL] import os [EOL] import subprocess [EOL] import which [EOL] [EOL] from mozbuild . base import ( MachCommandBase , ) [EOL] [EOL] from mach . decorators import ( CommandArgument , CommandProvider , Command , ) [EOL] [EOL] [EOL] @ CommandProvider class MachCommands ( MachCommandBase ) : [EOL] @ Command ( [string] , category = [string] , description = [string] ) @ CommandArgument ( [string] , choices = [ [string] , [string] ] ) @ CommandArgument ( [string] , nargs = argparse . REMAINDER ) def eclipse ( self , ide , args ) : [EOL] if ide == [string] : [EOL] backend = [string] [EOL] elif ide == [string] : [EOL] backend = [string] [EOL] [EOL] if ide == [string] : [EOL] try : [EOL] which . which ( [string] ) [EOL] except which . WhichError : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] return [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] res = self . _mach_context . commands . dispatch ( [string] , self . _mach_context ) [EOL] if res != [number] : [EOL] return [number] [EOL] [EOL] [comment] [EOL] python = self . virtualenv_manager . python_path [EOL] config_status = os . path . join ( self . topobjdir , [string] ) [EOL] args = [ python , config_status , [string] % backend ] [EOL] res = self . _run_command_in_objdir ( args = args , pass_thru = True , ensure_exit_code = False ) [EOL] if res != [number] : [EOL] return [number] [EOL] [EOL] if ide == [string] : [EOL] eclipse_workspace_dir = self . get_eclipse_workspace_path ( ) [EOL] subprocess . check_call ( [ [string] , [string] , eclipse_workspace_dir ] ) [EOL] elif ide == [string] : [EOL] visual_studio_workspace_dir = self . get_visualstudio_workspace_path ( ) [EOL] subprocess . check_call ( [ [string] , visual_studio_workspace_dir ] ) [EOL] [EOL] def get_eclipse_workspace_path ( self ) : [EOL] from mozbuild . backend . cpp_eclipse import CppEclipseBackend [EOL] return CppEclipseBackend . get_workspace_path ( self . topsrcdir , self . topobjdir ) [EOL] [EOL] def get_visualstudio_workspace_path ( self ) : [EOL] return os . path . join ( self . topobjdir , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.list$ 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Set , OrderedDict , Any , Type , Literal , Union , Dict , List [EOL] import _importlib_modulespec [EOL] import typing [EOL] import collections [EOL] import vendored [EOL] import typing_extensions [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import six [EOL] import sys [EOL] import json [EOL] [EOL] from collections import Iterable , OrderedDict [EOL] from types import ModuleType [EOL] [EOL] import mozpack . path as mozpath [EOL] [EOL] from mozbuild . util import ( FileAvoidWrite , memoized_property , ReadOnlyDict , ) [EOL] from mozbuild . shellutil import quote as shell_quote [EOL] [EOL] [EOL] class BuildConfig ( object ) : [EOL] [docstring] [EOL] [EOL] _CODE_CACHE = { } [EOL] [EOL] def __init__ ( self ) : [EOL] self . topsrcdir = None [EOL] self . topobjdir = None [EOL] self . defines = { } [EOL] self . non_global_defines = [ ] [EOL] self . substs = { } [EOL] self . files = [ ] [EOL] self . mozconfig = None [EOL] [EOL] @ classmethod def from_config_status ( cls , path ) : [EOL] [docstring] [EOL] code_cache = cls . _CODE_CACHE [EOL] mtime = os . path . getmtime ( path ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if path not in code_cache or code_cache [ path ] [ [number] ] != mtime : [EOL] [comment] [EOL] [comment] [EOL] mod = ModuleType ( [string] ) [EOL] mod . __file__ = path [EOL] sys . modules [ [string] ] = mod [EOL] [EOL] with open ( path , [string] ) as fh : [EOL] source = fh . read ( ) [EOL] code_cache [ path ] = ( mtime , compile ( source , path , [string] , dont_inherit = [number] ) ) [EOL] [EOL] g = { [string] : __builtins__ , [string] : path , } [EOL] l = { } [EOL] exec ( code_cache [ path ] [ [number] ] , g , l ) [EOL] [EOL] config = BuildConfig ( ) [EOL] [EOL] for name in l [ [string] ] : [EOL] setattr ( config , name , l [ name ] ) [EOL] [EOL] return config [EOL] [EOL] [EOL] class ConfigEnvironment ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , topsrcdir , topobjdir , defines = None , non_global_defines = None , substs = None , source = None , mozconfig = None ) : [EOL] [EOL] if not source : [EOL] source = mozpath . join ( topobjdir , [string] ) [EOL] self . source = source [EOL] self . defines = ReadOnlyDict ( defines or { } ) [EOL] self . non_global_defines = non_global_defines or [ ] [EOL] self . substs = dict ( substs or { } ) [EOL] self . topsrcdir = mozpath . abspath ( topsrcdir ) [EOL] self . topobjdir = mozpath . abspath ( topobjdir ) [EOL] self . mozconfig = mozpath . abspath ( mozconfig ) if mozconfig else None [EOL] self . lib_prefix = self . substs . get ( [string] , [string] ) [EOL] self . rust_lib_prefix = self . substs . get ( [string] , [string] ) [EOL] if [string] in self . substs : [EOL] self . lib_suffix = [string] % self . substs [ [string] ] [EOL] if [string] in self . substs : [EOL] self . rust_lib_suffix = [string] % self . substs [ [string] ] [EOL] self . dll_prefix = self . substs . get ( [string] , [string] ) [EOL] self . dll_suffix = self . substs . get ( [string] , [string] ) [EOL] self . host_dll_prefix = self . substs . get ( [string] , [string] ) [EOL] self . host_dll_suffix = self . substs . get ( [string] , [string] ) [EOL] if self . substs . get ( [string] ) : [EOL] self . import_prefix = self . lib_prefix [EOL] self . import_suffix = [string] % self . substs [ [string] ] [EOL] else : [EOL] self . import_prefix = self . dll_prefix [EOL] self . import_suffix = self . dll_suffix [EOL] self . bin_suffix = self . substs . get ( [string] , [string] ) [EOL] [EOL] global_defines = [ name for name in self . defines if name not in self . non_global_defines ] [EOL] self . substs [ [string] ] = [string] . join ( [ [string] % ( name , shell_quote ( self . defines [ name ] ) . replace ( [string] , [string] ) ) for name in sorted ( global_defines ) ] ) [EOL] [EOL] def serialize ( name , obj ) : [EOL] if isinstance ( obj , six . string_types ) : [EOL] return obj [EOL] if isinstance ( obj , Iterable ) : [EOL] return [string] . join ( obj ) [EOL] raise Exception ( [string] , type ( obj ) , str ( name ) ) [EOL] self . substs [ [string] ] = [string] . join ( sorted ( [ [string] % ( name , serialize ( name , self . substs [ name ] ) ) for name in self . substs if self . substs [ name ] ] ) ) [EOL] self . substs [ [string] ] = [string] . join ( sorted ( [ [string] % name for name in self . substs if not self . substs [ name ] ] ) ) [EOL] [EOL] self . substs = ReadOnlyDict ( self . substs ) [EOL] [EOL] self . external_source_dir = None [EOL] external = self . substs . get ( [string] , [string] ) [EOL] if external : [EOL] external = mozpath . normpath ( external ) [EOL] if not os . path . isabs ( external ) : [EOL] external = mozpath . join ( self . topsrcdir , external ) [EOL] self . external_source_dir = mozpath . normpath ( external ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . substs_unicode = { } [EOL] [EOL] def decode ( v ) : [EOL] if not isinstance ( v , six . text_type ) : [EOL] try : [EOL] return v . decode ( [string] ) [EOL] except UnicodeDecodeError : [EOL] return v . decode ( [string] , [string] ) [EOL] [EOL] for k , v in self . substs . items ( ) : [EOL] if not isinstance ( v , six . string_types ) : [EOL] if isinstance ( v , Iterable ) : [EOL] type ( v ) ( decode ( i ) for i in v ) [EOL] elif not isinstance ( v , six . text_type ) : [EOL] v = decode ( v ) [EOL] [EOL] self . substs_unicode [ k ] = v [EOL] [EOL] self . substs_unicode = ReadOnlyDict ( self . substs_unicode ) [EOL] [EOL] @ property def is_artifact_build ( self ) : [EOL] return self . substs . get ( [string] , False ) [EOL] [EOL] @ memoized_property def acdefines ( self ) : [EOL] acdefines = dict ( ( name , self . defines [ name ] ) for name in self . defines if name not in self . non_global_defines ) [EOL] return ReadOnlyDict ( acdefines ) [EOL] [EOL] @ staticmethod def from_config_status ( path ) : [EOL] config = BuildConfig . from_config_status ( path ) [EOL] [EOL] return ConfigEnvironment ( config . topsrcdir , config . topobjdir , config . defines , config . non_global_defines , config . substs , path ) [EOL] [EOL] [EOL] class PartialConfigDict ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config_statusd , typ , environ_override = False ) : [EOL] self . _dict = { } [EOL] self . _datadir = mozpath . join ( config_statusd , typ ) [EOL] self . _config_track = mozpath . join ( self . _datadir , [string] ) [EOL] self . _files = set ( ) [EOL] self . _environ_override = environ_override [EOL] [EOL] def _load_config_track ( self ) : [EOL] existing_files = set ( ) [EOL] try : [EOL] with open ( self . _config_track ) as fh : [EOL] existing_files . update ( fh . read ( ) . splitlines ( ) ) [EOL] except IOError : [EOL] pass [EOL] return existing_files [EOL] [EOL] def _write_file ( self , key , value ) : [EOL] encoding = [string] if sys . platform == [string] else [string] [EOL] filename = mozpath . join ( self . _datadir , key ) [EOL] with FileAvoidWrite ( filename ) as fh : [EOL] json . dump ( value , fh , indent = [number] , encoding = encoding ) [EOL] return filename [EOL] [EOL] def _fill_group ( self , values ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _dict = { } [EOL] [EOL] existing_files = self . _load_config_track ( ) [EOL] [EOL] new_files = set ( ) [EOL] for k , v in values . iteritems ( ) : [EOL] new_files . add ( self . _write_file ( k , v ) ) [EOL] [EOL] for filename in existing_files - new_files : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with FileAvoidWrite ( filename ) as fh : [EOL] json . dump ( None , fh ) [EOL] [EOL] with FileAvoidWrite ( self . _config_track ) as fh : [EOL] for f in sorted ( new_files ) : [EOL] fh . write ( [string] % f ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] if self . _environ_override : [EOL] if ( key not in ( [string] , [string] , [string] ) ) and ( key in os . environ ) : [EOL] return os . environ [ key ] [EOL] [EOL] if key not in self . _dict : [EOL] data = None [EOL] try : [EOL] filename = mozpath . join ( self . _datadir , key ) [EOL] self . _files . add ( filename ) [EOL] with open ( filename ) as f : [EOL] data = json . load ( f ) [EOL] except IOError : [EOL] pass [EOL] self . _dict [ key ] = data [EOL] [EOL] if self . _dict [ key ] is None : [EOL] raise KeyError ( [string] % key ) [EOL] return self . _dict [ key ] [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] self . _dict [ key ] = value [EOL] [EOL] def get ( self , key , default = None ) : [EOL] return self [ key ] if key in self else default [EOL] [EOL] def __contains__ ( self , key ) : [EOL] try : [EOL] return self [ key ] is not None [EOL] except KeyError : [EOL] return False [EOL] [EOL] def iteritems ( self ) : [EOL] existing_files = self . _load_config_track ( ) [EOL] for f in existing_files : [EOL] [comment] [EOL] [comment] [EOL] var = mozpath . basename ( f ) [EOL] yield var , self [ var ] [EOL] [EOL] [EOL] class PartialConfigEnvironment ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , topobjdir ) : [EOL] config_statusd = mozpath . join ( topobjdir , [string] ) [EOL] self . substs = PartialConfigDict ( config_statusd , [string] , environ_override = True ) [EOL] self . defines = PartialConfigDict ( config_statusd , [string] ) [EOL] self . topobjdir = topobjdir [EOL] [EOL] def write_vars ( self , config ) : [EOL] substs = config [ [string] ] . copy ( ) [EOL] defines = config [ [string] ] . copy ( ) [EOL] [EOL] global_defines = [ name for name in config [ [string] ] if name not in config [ [string] ] ] [EOL] acdefines = [string] . join ( [ [string] % ( name , shell_quote ( config [ [string] ] [ name ] ) . replace ( [string] , [string] ) ) for name in sorted ( global_defines ) ] ) [EOL] substs [ [string] ] = acdefines [EOL] [EOL] all_defines = OrderedDict ( ) [EOL] for k in global_defines : [EOL] all_defines [ k ] = config [ [string] ] [ k ] [EOL] defines [ [string] ] = all_defines [EOL] [EOL] self . substs . _fill_group ( substs ) [EOL] self . defines . _fill_group ( defines ) [EOL] [EOL] def get_dependencies ( self ) : [EOL] return [ [string] % f for f in self . substs . _files | self . defines . _files ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $vendored.mozbuild.mozbuild.backend.configenvironment.BuildConfig$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.backend.configenvironment.BuildConfig$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.backend.configenvironment.BuildConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.backend.configenvironment.PartialConfigDict$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.backend.configenvironment.PartialConfigDict$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Tuple [EOL] import vendored [EOL] import typing [EOL] import requests [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import bisect [EOL] import gzip [EOL] import json [EOL] import math [EOL] import requests [EOL] [EOL] from datetime import datetime , timedelta [EOL] from collections import Counter [EOL] [EOL] import mozpack . path as mozpath [EOL] [EOL] PUSHLOG_CHUNK_SIZE = [number] [EOL] [EOL] URL = [string] [EOL] [EOL] [EOL] def unix_epoch ( date ) : [EOL] return ( date - datetime ( [number] , [number] , [number] ) ) . total_seconds ( ) [EOL] [EOL] [EOL] def unix_from_date ( n , today ) : [EOL] return unix_epoch ( today - timedelta ( days = n ) ) [EOL] [EOL] [EOL] def get_lastpid ( session ) : [EOL] return session . get ( URL + [string] ) . json ( ) [ [string] ] [EOL] [EOL] [EOL] def get_pushlog_chunk ( session , start , end ) : [EOL] [comment] [EOL] res = session . get ( URL + [string] . format ( start , end ) ) . json ( ) [EOL] return sorted ( res . items ( ) , key = lambda x : x [ [number] ] [ [string] ] ) [EOL] [EOL] [EOL] def collect_data ( session , date ) : [EOL] if date < [number] : [comment] [EOL] raise Exception ( [string] ) [EOL] lastpushid = get_lastpid ( session ) [EOL] data = [ ] [EOL] start_id = lastpushid - PUSHLOG_CHUNK_SIZE [EOL] end_id = lastpushid + [number] [EOL] while True : [EOL] res = get_pushlog_chunk ( session , start_id , end_id ) [EOL] starting_date = res [ [number] ] [ [number] ] [ [string] ] [comment] [EOL] dates = [ x [ [number] ] [ [string] ] for x in res ] [EOL] if starting_date < date : [EOL] i = bisect . bisect_left ( dates , date ) [EOL] data . append ( res [ i : ] ) [EOL] return data [EOL] else : [EOL] data . append ( res ) [EOL] end_id = start_id + [number] [EOL] start_id = start_id - PUSHLOG_CHUNK_SIZE [EOL] [EOL] [EOL] def get_data ( epoch ) : [EOL] session = requests . Session ( ) [EOL] data = collect_data ( session , epoch ) [EOL] return { k : v for sublist in data for ( k , v ) in sublist } [EOL] [EOL] [EOL] class Pushlog ( object ) : [EOL] [EOL] def __init__ ( self , days ) : [EOL] info = get_data ( unix_from_date ( days , datetime . today ( ) ) ) [EOL] self . pushlog = info [EOL] self . pids = self . get_pids ( ) [EOL] self . pushes = self . make_pushes ( ) [EOL] self . files = [ l for p in self . pushes for l in set ( p . files ) ] [EOL] self . file_set = set ( self . files ) [EOL] self . file_count = Counter ( self . files ) [EOL] [EOL] def make_pushes ( self ) : [EOL] pids = self . pids [EOL] all_pushes = self . pushlog [EOL] return [ Push ( pid , all_pushes [ str ( pid ) ] ) for pid in pids ] [EOL] [EOL] def get_pids ( self ) : [EOL] keys = self . pushlog . keys ( ) [EOL] keys . sort ( ) [EOL] return keys [EOL] [EOL] [EOL] class Push ( object ) : [EOL] [EOL] def __init__ ( self , pid , p_dict ) : [EOL] self . id = pid [EOL] self . date = p_dict [ [string] ] [EOL] self . files = [ f for x in p_dict [ [string] ] for f in x [ [string] ] ] [EOL] [EOL] [EOL] class Report ( object ) : [EOL] [EOL] def __init__ ( self , days , path = None , cost_dict = None ) : [EOL] obj = Pushlog ( days ) [EOL] self . file_set = obj . file_set [EOL] self . file_count = obj . file_count [EOL] self . name = str ( days ) + [string] [EOL] self . cost_dict = self . get_cost_dict ( path , cost_dict ) [EOL] [EOL] def get_cost_dict ( self , path , cost_dict ) : [EOL] if path is not None : [EOL] with gzip . open ( path ) as file : [EOL] return json . loads ( file . read ( ) ) [EOL] else : [EOL] if cost_dict is not None : [EOL] return cost_dict [EOL] else : [EOL] raise Exception [EOL] [EOL] def organize_data ( self ) : [EOL] costs = self . cost_dict [EOL] counts = self . file_count [EOL] res = [ ] [EOL] for f in self . file_set : [EOL] cost = costs . get ( f ) [EOL] count = counts . get ( f ) [EOL] if cost is not None : [EOL] res . append ( ( f , cost , count , round ( cost * count , [number] ) ) ) [EOL] return res [EOL] [EOL] def get_sorted_report ( self , format ) : [EOL] res = self . organize_data ( ) [EOL] res . sort ( key = ( lambda x : x [ [number] ] ) , reverse = True ) [EOL] [EOL] def ms_to_mins_secs ( ms ) : [EOL] secs = ms / [number] [EOL] mins = secs / [number] [EOL] secs = secs % [number] [EOL] return [string] % ( math . trunc ( mins ) , int ( round ( secs ) ) ) [EOL] [EOL] if format in ( [string] , [string] ) : [EOL] res = [ ( f , ms_to_mins_secs ( cost ) , count , ms_to_mins_secs ( total ) ) for ( f , cost , count , total ) in res ] [EOL] [EOL] return res [EOL] [EOL] def cut ( self , size , lst ) : [EOL] if len ( lst ) <= size : [EOL] return lst [EOL] else : [EOL] return lst [ : size ] [EOL] [EOL] def generate_output ( self , format , limit , dst ) : [EOL] import tablib [EOL] data = tablib . Dataset ( headers = [ [string] , [string] , [string] , [string] ] ) [EOL] res = self . get_sorted_report ( format ) [EOL] if limit is not None : [EOL] res = self . cut ( limit , res ) [EOL] for x in res : [EOL] data . append ( x ) [EOL] if format == [string] : [EOL] print ( data ) [EOL] else : [EOL] file_name = self . name + [string] + format [EOL] content = None [EOL] data . export ( format ) [EOL] if format == [string] : [EOL] content = data . csv [EOL] elif format == [string] : [EOL] content = data . json [EOL] else : [EOL] content = data . html [EOL] file_path = mozpath . join ( dst , file_name ) [EOL] with open ( file_path , [string] ) as f : [EOL] f . write ( content ) [EOL] print ( [string] % file_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.analyze.hg.Pushlog$ 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.analyze.hg.Pushlog$ 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.analyze.hg.Pushlog$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any,typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import sqlite3 as lite [EOL] [EOL] [EOL] class Node ( object ) : [EOL] [EOL] def __init__ ( self , graph , node_id ) : [EOL] sql_result = graph . query_arg ( [string] , ( node_id , ) ) . fetchone ( ) [EOL] self . id , self . dir , self . type , self . mtime , self . name = sql_result [EOL] children = graph . query_arg ( [string] , ( self . id , ) ) . fetchall ( ) [EOL] self . children = [ graph . get_node ( x ) for ( x , ) in children ] [EOL] self . cmds = list ( set ( self . get_cmd_nodes ( ) ) ) [EOL] self . path = self . get_path ( graph ) if self . type == [number] else [string] [EOL] self . cost = self . calculate_mtime ( ) [EOL] graph . add_node ( self . id , self ) [EOL] [EOL] @ property def num_cmds ( self ) : [EOL] return len ( self . cmds ) [EOL] [EOL] def get_cmd_nodes ( self ) : [EOL] res = [ ] [EOL] if self . type == [number] : [EOL] res += [ self ] [EOL] return res + [ c for x in self . children for c in x . cmds ] [EOL] [EOL] def get_cmd_ids ( self ) : [EOL] return [ x . id for x in self . cmds ] [EOL] [EOL] def get_path ( self , graph ) : [EOL] if self . dir == [number] : [EOL] return self . name [EOL] parent = graph . get_node ( self . dir ) [EOL] return os . path . join ( parent . get_path ( graph ) , self . name ) [EOL] [EOL] def calculate_mtime ( self ) : [EOL] if self . type == [number] : [comment] [EOL] return sum ( x . mtime for x in self . cmds ) [EOL] else : [EOL] return None [EOL] [EOL] [EOL] class Graph ( object ) : [EOL] [EOL] def __init__ ( self , path = None , connect = None ) : [EOL] self . connect = connect [EOL] if path is not None : [EOL] self . connect = lite . connect ( path ) [EOL] elif self . connect is None : [EOL] raise Exception [EOL] if not self . table_check ( ) : [EOL] print ( [string] ) [EOL] raise Exception [EOL] self . node_dict = { } [EOL] self . results = None [EOL] [EOL] def table_check ( self ) : [EOL] tables = [ x [ [number] ] for x in self . query_arg ( [string] , ( [string] , ) ) . fetchall ( ) ] [EOL] return ( [string] in tables and [string] in tables ) [EOL] [EOL] def close ( self ) : [EOL] self . connect . close ( ) [EOL] [EOL] def query_arg ( self , q , arg ) : [EOL] assert isinstance ( arg , tuple ) [comment] [EOL] cursor = self . connect . cursor ( ) [EOL] cursor . execute ( q , arg ) [EOL] return cursor [EOL] [EOL] def query ( self , q ) : [EOL] cursor = self . connect . cursor ( ) [EOL] cursor . execute ( q ) [EOL] return cursor [EOL] [EOL] @ property def nodes ( self ) : [EOL] return self . node_dict [EOL] [EOL] def add_node ( self , k , v ) : [EOL] self . node_dict [ k ] = v [EOL] [EOL] def get_id ( self , filepath ) : [EOL] nodeid = [number] [EOL] for part in filepath . split ( [string] ) : [EOL] ret = self . query_arg ( [string] , ( nodeid , part ) ) . fetchone ( ) [EOL] [comment] [EOL] if ret is None : [EOL] print ( [string] % filepath ) [EOL] return None [EOL] nodeid = ret [ [number] ] [EOL] return nodeid [EOL] [EOL] def get_node ( self , node_id ) : [EOL] if node_id is not None : [EOL] node = self . node_dict . get ( node_id ) [EOL] if node is None : [EOL] return Node ( self , node_id ) [EOL] else : [EOL] return node [EOL] [EOL] def file_summaries ( self , files ) : [EOL] for f in files : [EOL] node = self . get_node ( self . get_id ( f ) ) [EOL] if node is not None : [EOL] sec = node . cost / [number] [EOL] m , s = sec / [number] , sec % [number] [EOL] print ( [string] % ( f , m , s , node . num_cmds ) ) [EOL] [EOL] def populate ( self ) : [EOL] [comment] [EOL] files = self . query ( [string] ) . fetchall ( ) [EOL] res = [ ] [EOL] for ( i , ) in files : [EOL] node = self . get_node ( i ) [EOL] res . append ( ( node . path , node . cost ) ) [EOL] self . results = res [EOL] [EOL] def get_cost_dict ( self ) : [EOL] if self . results is None : [EOL] self . populate ( ) [EOL] return { k : v for k , v in self . results if v > [number] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Set , Any , Dict , List [EOL] import urllib [EOL] import typing [EOL] import argparse [EOL] import vendored [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] from argparse import ArgumentParser [EOL] import json [EOL] import os [EOL] [EOL] try : [EOL] import urlparse [EOL] except ImportError : [EOL] import urllib . parse as urlparse [EOL] [EOL] from six import viewitems [EOL] [EOL] from mozpack . chrome . manifest import parse_manifest [EOL] import mozpack . path as mozpath [EOL] from . manifest_handler import ChromeManifestHandler [EOL] [EOL] [EOL] class LcovRecord ( object ) : [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . functions = { } [EOL] self . function_exec_counts = { } [EOL] self . branches = { } [EOL] self . lines = { } [EOL] [EOL] def __iadd__ ( self , other ) : [EOL] [EOL] [comment] [EOL] self . source_file = other . source_file [EOL] if hasattr ( other , [string] ) : [EOL] self . test_name = other . test_name [EOL] self . functions . update ( other . functions ) [EOL] [EOL] for name , count in viewitems ( other . function_exec_counts ) : [EOL] self . function_exec_counts [ name ] = count + self . function_exec_counts . get ( name , [number] ) [EOL] [EOL] for key , taken in viewitems ( other . branches ) : [EOL] self . branches [ key ] = taken + self . branches . get ( key , [number] ) [EOL] [EOL] for line , ( exec_count , checksum ) in viewitems ( other . lines ) : [EOL] new_exec_count = exec_count [EOL] if line in self . lines : [EOL] old_exec_count , _ = self . lines [ line ] [EOL] new_exec_count += old_exec_count [EOL] self . lines [ line ] = new_exec_count , checksum [EOL] [EOL] self . resummarize ( ) [EOL] return self [EOL] [EOL] def resummarize ( self ) : [EOL] [comment] [EOL] self . function_count = len ( self . functions . keys ( ) ) [EOL] [comment] [EOL] self . function_exec_counts = { fn_name : count for fn_name , count in viewitems ( self . function_exec_counts ) if fn_name in self . functions . values ( ) } [EOL] self . covered_function_count = len ( [ c for c in self . function_exec_counts . values ( ) if c ] ) [EOL] self . line_count = len ( self . lines ) [EOL] self . covered_line_count = len ( [ c for c , _ in self . lines . values ( ) if c ] ) [EOL] self . branch_count = len ( self . branches ) [EOL] self . covered_branch_count = len ( [ c for c in self . branches . values ( ) if c ] ) [EOL] [EOL] [EOL] class RecordRewriter ( object ) : [EOL] [comment] [EOL] [comment] [EOL] def __init__ ( self ) : [EOL] self . _ranges = None [EOL] [EOL] def _get_range ( self , line ) : [EOL] for start , end in self . _ranges : [EOL] if line < start : [EOL] return None [EOL] if line < end : [EOL] return start , end [EOL] return None [EOL] [EOL] def _get_mapped_line ( self , line , r ) : [EOL] inc_source , inc_start = self . _current_pp_info [ r ] [EOL] start , end = r [EOL] offs = line - start [EOL] return inc_start + offs [EOL] [EOL] def _get_record ( self , inc_source ) : [EOL] if inc_source in self . _additions : [EOL] gen_rec = self . _additions [ inc_source ] [EOL] else : [EOL] gen_rec = LcovRecord ( ) [EOL] gen_rec . source_file = inc_source [EOL] self . _additions [ inc_source ] = gen_rec [EOL] return gen_rec [EOL] [EOL] def _rewrite_lines ( self , record ) : [EOL] rewritten_lines = { } [EOL] for ln , line_info in viewitems ( record . lines ) : [EOL] r = self . _get_range ( ln ) [EOL] if r is None : [EOL] rewritten_lines [ ln ] = line_info [EOL] continue [EOL] new_ln = self . _get_mapped_line ( ln , r ) [EOL] inc_source , _ = self . _current_pp_info [ r ] [EOL] [EOL] if inc_source != record . source_file : [EOL] gen_rec = self . _get_record ( inc_source ) [EOL] gen_rec . lines [ new_ln ] = line_info [EOL] continue [EOL] [EOL] [comment] [EOL] rewritten_lines [ new_ln ] = line_info [EOL] [EOL] record . lines = rewritten_lines [EOL] [EOL] def _rewrite_functions ( self , record ) : [EOL] rewritten_fns = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for ln , fn_name in viewitems ( record . functions ) : [EOL] r = self . _get_range ( ln ) [EOL] if r is None : [EOL] rewritten_fns [ ln ] = fn_name [EOL] continue [EOL] new_ln = self . _get_mapped_line ( ln , r ) [EOL] inc_source , _ = self . _current_pp_info [ r ] [EOL] if inc_source != record . source_file : [EOL] gen_rec = self . _get_record ( inc_source ) [EOL] gen_rec . functions [ new_ln ] = fn_name [EOL] if fn_name in record . function_exec_counts : [EOL] gen_rec . function_exec_counts [ fn_name ] = record . function_exec_counts [ fn_name ] [EOL] continue [EOL] rewritten_fns [ new_ln ] = fn_name [EOL] record . functions = rewritten_fns [EOL] [EOL] def _rewrite_branches ( self , record ) : [EOL] rewritten_branches = { } [EOL] for ( ln , block_number , branch_number ) , taken in viewitems ( record . branches ) : [EOL] r = self . _get_range ( ln ) [EOL] if r is None : [EOL] rewritten_branches [ ln , block_number , branch_number ] = taken [EOL] continue [EOL] new_ln = self . _get_mapped_line ( ln , r ) [EOL] inc_source , _ = self . _current_pp_info [ r ] [EOL] if inc_source != record . source_file : [EOL] gen_rec = self . _get_record ( inc_source ) [EOL] gen_rec . branches [ ( new_ln , block_number , branch_number ) ] = taken [EOL] continue [EOL] rewritten_branches [ ( new_ln , block_number , branch_number ) ] = taken [EOL] [EOL] record . branches = rewritten_branches [EOL] [EOL] def rewrite_record ( self , record , pp_info ) : [EOL] [comment] [EOL] [comment] [EOL] self . _current_pp_info = dict ( [ ( tuple ( [ int ( l ) for l in k . split ( [string] ) ] ) , v ) for k , v in pp_info . items ( ) ] ) [EOL] self . _ranges = sorted ( self . _current_pp_info . keys ( ) ) [EOL] self . _additions = { } [EOL] self . _rewrite_lines ( record ) [EOL] self . _rewrite_functions ( record ) [EOL] self . _rewrite_branches ( record ) [EOL] [EOL] record . resummarize ( ) [EOL] [EOL] generated_records = self . _additions . values ( ) [EOL] for r in generated_records : [EOL] r . resummarize ( ) [EOL] return generated_records [EOL] [EOL] [EOL] class LcovFile ( object ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] PREFIX_TYPES = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] def __init__ ( self , lcov_paths ) : [EOL] self . lcov_paths = lcov_paths [EOL] [EOL] def iterate_records ( self , rewrite_source = None ) : [EOL] current_source_file = None [EOL] current_pp_info = None [EOL] current_lines = [ ] [EOL] for lcov_path in self . lcov_paths : [EOL] with open ( lcov_path ) as lcov_fh : [EOL] for line in lcov_fh : [EOL] line = line . rstrip ( ) [EOL] if not line : [EOL] continue [EOL] [EOL] if line == [string] : [EOL] [comment] [EOL] [comment] [EOL] if current_source_file is not None : [EOL] yield ( current_source_file , current_pp_info , current_lines ) [EOL] current_source_file = None [EOL] current_pp_info = None [EOL] current_lines = [ ] [EOL] continue [EOL] [EOL] colon = line . find ( [string] ) [EOL] prefix = line [ : colon ] [EOL] [EOL] if prefix == [string] : [EOL] sf = line [ ( colon + [number] ) : ] [EOL] res = rewrite_source ( sf ) if rewrite_source is not None else ( sf , None ) [EOL] if res is None : [EOL] current_lines . append ( line ) [EOL] else : [EOL] current_source_file , current_pp_info = res [EOL] current_lines . append ( [string] + current_source_file ) [EOL] else : [EOL] current_lines . append ( line ) [EOL] [EOL] def parse_record ( self , record_content ) : [EOL] self . current_record = LcovRecord ( ) [EOL] [EOL] for line in record_content : [EOL] colon = line . find ( [string] ) [EOL] [EOL] prefix = line [ : colon ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if colon < [number] or prefix not in self . PREFIX_TYPES : [EOL] continue [EOL] [EOL] args = line [ ( colon + [number] ) : ] . split ( [string] , self . PREFIX_TYPES [ prefix ] ) [EOL] [EOL] def try_convert ( a ) : [EOL] try : [EOL] return int ( a ) [EOL] except ValueError : [EOL] return a [EOL] args = [ try_convert ( a ) for a in args ] [EOL] [EOL] try : [EOL] LcovFile . __dict__ [ [string] + prefix ] ( self , * args ) [EOL] except ValueError : [EOL] print ( [string] % ( self . lcov_fh . name , line ) ) [EOL] raise [EOL] except KeyError : [EOL] print ( [string] % ( self . lcov_fh . name , line ) ) [EOL] raise [EOL] except TypeError : [EOL] print ( [string] % ( self . lcov_fh . name , line ) ) [EOL] raise [EOL] [EOL] ret = self . current_record [EOL] self . current_record = LcovRecord ( ) [EOL] return ret [EOL] [EOL] def print_file ( self , fh , rewrite_source , rewrite_record ) : [EOL] for source_file , pp_info , record_content in self . iterate_records ( rewrite_source ) : [EOL] if pp_info is not None : [EOL] record = self . parse_record ( record_content ) [EOL] for r in rewrite_record ( record , pp_info ) : [EOL] fh . write ( self . format_record ( r ) ) [EOL] fh . write ( self . format_record ( record ) ) [EOL] else : [EOL] fh . write ( [string] . join ( record_content ) + [string] ) [EOL] [EOL] def format_record ( self , record ) : [EOL] out_lines = [ ] [EOL] for name in LcovRecord . __slots__ : [EOL] if hasattr ( record , name ) : [EOL] out_lines . append ( LcovFile . __dict__ [ [string] + name ] ( self , record ) ) [EOL] return [string] . join ( out_lines ) + [string] [EOL] [EOL] def format_test_name ( self , record ) : [EOL] return [string] % record . test_name [EOL] [EOL] def format_source_file ( self , record ) : [EOL] return [string] % record . source_file [EOL] [EOL] def format_functions ( self , record ) : [EOL] [comment] [EOL] [comment] [EOL] fns = [ ] [EOL] for start_lineno , fn_name in sorted ( viewitems ( record . functions ) ) : [EOL] fns . append ( [string] % ( start_lineno , fn_name ) ) [EOL] return [string] . join ( fns ) [EOL] [EOL] def format_function_exec_counts ( self , record ) : [EOL] fndas = [ ] [EOL] for name , exec_count in sorted ( viewitems ( record . function_exec_counts ) ) : [EOL] fndas . append ( [string] % ( exec_count , name ) ) [EOL] return [string] . join ( fndas ) [EOL] [EOL] def format_function_count ( self , record ) : [EOL] return [string] % record . function_count [EOL] [EOL] def format_covered_function_count ( self , record ) : [EOL] return [string] % record . covered_function_count [EOL] [EOL] def format_branches ( self , record ) : [EOL] brdas = [ ] [EOL] for key in sorted ( record . branches ) : [EOL] taken = record . branches [ key ] [EOL] taken = [string] if taken == [number] else taken [EOL] brdas . append ( [string] % [string] . join ( map ( str , list ( key ) + [ taken ] ) ) ) [EOL] return [string] . join ( brdas ) [EOL] [EOL] def format_branch_count ( self , record ) : [EOL] return [string] % record . branch_count [EOL] [EOL] def format_covered_branch_count ( self , record ) : [EOL] return [string] % record . covered_branch_count [EOL] [EOL] def format_lines ( self , record ) : [EOL] das = [ ] [EOL] for line_no , ( exec_count , checksum ) in sorted ( viewitems ( record . lines ) ) : [EOL] s = [string] % ( line_no , exec_count ) [EOL] if checksum : [EOL] s += [string] % checksum [EOL] das . append ( s ) [EOL] return [string] . join ( das ) [EOL] [EOL] def format_line_count ( self , record ) : [EOL] return [string] % record . line_count [EOL] [EOL] def format_covered_line_count ( self , record ) : [EOL] return [string] % record . covered_line_count [EOL] [EOL] def parse_TN ( self , test_name ) : [EOL] self . current_record . test_name = test_name [EOL] [EOL] def parse_SF ( self , source_file ) : [EOL] self . current_record . source_file = source_file [EOL] [EOL] def parse_FN ( self , start_lineno , fn_name ) : [EOL] self . current_record . functions [ start_lineno ] = fn_name [EOL] [EOL] def parse_FNDA ( self , exec_count , fn_name ) : [EOL] self . current_record . function_exec_counts [ fn_name ] = exec_count [EOL] [EOL] def parse_FNF ( self , function_count ) : [EOL] self . current_record . function_count = function_count [EOL] [EOL] def parse_FNH ( self , covered_function_count ) : [EOL] self . current_record . covered_function_count = covered_function_count [EOL] [EOL] def parse_BRDA ( self , line_number , block_number , branch_number , taken ) : [EOL] taken = [number] if taken == [string] else taken [EOL] self . current_record . branches [ ( line_number , block_number , branch_number ) ] = taken [EOL] [EOL] def parse_BRF ( self , branch_count ) : [EOL] self . current_record . branch_count = branch_count [EOL] [EOL] def parse_BRH ( self , covered_branch_count ) : [EOL] self . current_record . covered_branch_count = covered_branch_count [EOL] [EOL] def parse_DA ( self , line_number , execution_count , checksum = None ) : [EOL] self . current_record . lines [ line_number ] = ( execution_count , checksum ) [EOL] [EOL] def parse_LH ( self , covered_line_count ) : [EOL] self . current_record . covered_line_count = covered_line_count [EOL] [EOL] def parse_LF ( self , line_count ) : [EOL] self . current_record . line_count = line_count [EOL] [EOL] [EOL] class UrlFinderError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class UrlFinder ( object ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def __init__ ( self , chrome_map_path , appdir , gredir , extra_chrome_manifests ) : [EOL] [comment] [EOL] self . _final_mapping = { } [EOL] [EOL] try : [EOL] with open ( chrome_map_path ) as fh : [EOL] url_prefixes , overrides , install_info , buildconfig = json . load ( fh ) [EOL] except IOError : [EOL] print ( [string] [string] % chrome_map_path ) [EOL] raise [EOL] [EOL] self . topobjdir = buildconfig [ [string] ] [EOL] self . MOZ_APP_NAME = buildconfig [ [string] ] [EOL] self . OMNIJAR_NAME = buildconfig [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] not in url_prefixes : [EOL] url_prefixes [ [string] ] = [ appdir ] [EOL] if [string] not in url_prefixes : [EOL] url_prefixes [ [string] ] = [ gredir ] [EOL] [EOL] self . _url_prefixes = url_prefixes [EOL] self . _url_overrides = overrides [EOL] [EOL] self . _respath = None [EOL] [EOL] mac_bundle_name = buildconfig [ [string] ] [EOL] if mac_bundle_name : [EOL] self . _respath = mozpath . join ( [string] , mac_bundle_name , [string] , [string] ) [EOL] [EOL] if not extra_chrome_manifests : [EOL] extra_path = os . path . join ( self . topobjdir , [string] , [string] ) [EOL] if os . path . isfile ( extra_path ) : [EOL] extra_chrome_manifests = [ extra_path ] [EOL] [EOL] if extra_chrome_manifests : [EOL] self . _populate_chrome ( extra_chrome_manifests ) [EOL] [EOL] self . _install_mapping = install_info [EOL] [EOL] def _populate_chrome ( self , manifests ) : [EOL] handler = ChromeManifestHandler ( ) [EOL] for m in manifests : [EOL] path = os . path . abspath ( m ) [EOL] for e in parse_manifest ( None , path ) : [EOL] handler . handle_manifest_entry ( e ) [EOL] self . _url_overrides . update ( handler . overrides ) [EOL] self . _url_prefixes . update ( handler . chrome_mapping ) [EOL] [EOL] def _find_install_prefix ( self , objdir_path ) : [EOL] [EOL] def _prefix ( s ) : [EOL] for p in mozpath . split ( s ) : [EOL] if [string] not in p : [EOL] yield p + [string] [EOL] [EOL] offset = [number] [EOL] for leaf in reversed ( mozpath . split ( objdir_path ) ) : [EOL] offset += len ( leaf ) [EOL] if objdir_path [ : - offset ] in self . _install_mapping : [EOL] pattern_prefix , is_pp = self . _install_mapping [ objdir_path [ : - offset ] ] [EOL] full_leaf = objdir_path [ len ( objdir_path ) - offset : ] [EOL] src_prefix = [string] . join ( _prefix ( pattern_prefix ) ) [EOL] self . _install_mapping [ objdir_path ] = ( mozpath . join ( src_prefix , full_leaf ) , is_pp ) [EOL] break [EOL] offset += [number] [EOL] [EOL] def _install_info ( self , objdir_path ) : [EOL] if objdir_path not in self . _install_mapping : [EOL] [comment] [EOL] [comment] [EOL] self . _find_install_prefix ( objdir_path ) [EOL] if objdir_path not in self . _install_mapping : [EOL] raise UrlFinderError ( [string] % objdir_path ) [EOL] return self . _install_mapping [ objdir_path ] [EOL] [EOL] def _abs_objdir_install_info ( self , term ) : [EOL] obj_relpath = term [ len ( self . topobjdir ) + [number] : ] [EOL] res = self . _install_info ( obj_relpath ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( not res and self . _respath and obj_relpath . startswith ( self . _respath ) ) : [EOL] obj_relpath = obj_relpath . replace ( self . _respath , [string] ) [EOL] res = self . _install_info ( obj_relpath ) [EOL] [EOL] if not res : [EOL] raise UrlFinderError ( [string] % obj_relpath ) [EOL] return res [EOL] [EOL] def find_files ( self , url ) : [EOL] [comment] [EOL] [comment] [EOL] term = url [EOL] if term in self . _url_overrides : [EOL] term = self . _url_overrides [ term ] [EOL] [EOL] if os . path . isabs ( term ) and term . startswith ( self . topobjdir ) : [EOL] source_path , pp_info = self . _abs_objdir_install_info ( term ) [EOL] return source_path , pp_info [EOL] [EOL] for prefix , dests in viewitems ( self . _url_prefixes ) : [EOL] if term . startswith ( prefix ) : [EOL] for dest in dests : [EOL] if not dest . endswith ( [string] ) : [EOL] dest += [string] [EOL] objdir_path = term . replace ( prefix , dest ) [EOL] [EOL] while objdir_path . startswith ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] objdir_path = objdir_path [ [number] : ] [EOL] [EOL] try : [EOL] if os . path . isabs ( objdir_path ) and objdir_path . startswith ( self . topobjdir ) : [EOL] return self . _abs_objdir_install_info ( objdir_path ) [EOL] else : [EOL] src_path , pp_info = self . _install_info ( objdir_path ) [EOL] return mozpath . normpath ( src_path ) , pp_info [EOL] except UrlFinderError : [EOL] pass [EOL] [EOL] if ( dest . startswith ( [string] ) or dest . startswith ( [string] ) ) : [EOL] result = self . find_files ( term . replace ( prefix , dest ) ) [EOL] if result : [EOL] return result [EOL] [EOL] raise UrlFinderError ( [string] % term ) [EOL] [EOL] def rewrite_url ( self , url ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if url in self . _final_mapping : [EOL] return self . _final_mapping [ url ] [EOL] if url . endswith ( [string] ) : [EOL] return None [EOL] if url . endswith ( [string] ) : [EOL] return None [EOL] if [string] in url : [EOL] url = url . split ( [string] ) [ [number] ] . rstrip ( ) [EOL] if [string] in url : [EOL] url = url . split ( [string] ) [ [number] ] [EOL] [EOL] url_obj = urlparse . urlparse ( url ) [EOL] if url_obj . scheme == [string] : [EOL] app_name = self . MOZ_APP_NAME [EOL] omnijar_name = self . OMNIJAR_NAME [EOL] [EOL] if app_name in url : [EOL] if omnijar_name in url : [EOL] [comment] [EOL] parts = url_obj . path . split ( omnijar_name + [string] , [number] ) [EOL] elif [string] in url : [EOL] [comment] [EOL] parts = url_obj . path . split ( [string] , [number] ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] return url_obj . path , None [EOL] [EOL] dir_parts = parts [ [number] ] . rsplit ( app_name + [string] , [number] ) [EOL] url = mozpath . normpath ( mozpath . join ( self . topobjdir , [string] , [string] , dir_parts [ [number] ] . lstrip ( [string] ) , parts [ [number] ] . lstrip ( [string] ) ) ) [EOL] elif [string] in url : [EOL] [comment] [EOL] [comment] [EOL] parts = url_obj . path . split ( [string] , [number] ) [EOL] addon_name = os . path . basename ( parts [ [number] ] ) [EOL] if [string] in addon_name : [EOL] addon_name = addon_name [ : - len ( [string] ) ] [EOL] elif addon_name . endswith ( [string] ) : [EOL] addon_name = addon_name [ : - len ( [string] ) ] [EOL] url = mozpath . normpath ( mozpath . join ( self . topobjdir , [string] , [string] , addon_name , parts [ [number] ] . lstrip ( [string] ) ) ) [EOL] elif url_obj . scheme == [string] and os . path . isabs ( url_obj . path ) : [EOL] path = url_obj . path [EOL] if not os . path . isfile ( path ) : [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] if not path . startswith ( self . topobjdir ) : [EOL] return path , None [EOL] url = url_obj . path [EOL] elif url_obj . scheme in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] return None [EOL] [EOL] result = self . find_files ( url ) [EOL] self . _final_mapping [ url ] = result [EOL] return result [EOL] [EOL] [EOL] class LcovFileRewriter ( object ) : [EOL] [comment] [EOL] [comment] [EOL] def __init__ ( self , chrome_map_path , appdir = [string] , gredir = [string] , extra_chrome_manifests = [ ] ) : [EOL] self . url_finder = UrlFinder ( chrome_map_path , appdir , gredir , extra_chrome_manifests ) [EOL] self . pp_rewriter = RecordRewriter ( ) [EOL] [EOL] def rewrite_files ( self , in_paths , output_file , output_suffix ) : [EOL] unknowns = set ( ) [EOL] found_valid = [ False ] [EOL] [EOL] def rewrite_source ( url ) : [EOL] try : [EOL] res = self . url_finder . rewrite_url ( url ) [EOL] if res is None : [EOL] return None [EOL] except Exception as e : [EOL] if url not in unknowns : [EOL] print ( [string] % ( e , url ) ) [EOL] unknowns . add ( url ) [EOL] return None [EOL] [EOL] source_file , pp_info = res [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] found_valid [ [number] ] = True [EOL] [EOL] return res [EOL] [EOL] in_paths = [ os . path . abspath ( in_path ) for in_path in in_paths ] [EOL] [EOL] if output_file : [EOL] lcov_file = LcovFile ( in_paths ) [EOL] with open ( output_file , [string] ) as out_fh : [EOL] lcov_file . print_file ( out_fh , rewrite_source , self . pp_rewriter . rewrite_record ) [EOL] else : [EOL] for in_path in in_paths : [EOL] lcov_file = LcovFile ( [ in_path ] ) [EOL] with open ( in_path + output_suffix , [string] ) as out_fh : [EOL] lcov_file . print_file ( out_fh , rewrite_source , self . pp_rewriter . rewrite_record ) [EOL] [EOL] if not found_valid [ [number] ] : [EOL] print ( [string] % in_paths ) [EOL] return [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = ArgumentParser ( description = [string] [string] [string] [string] ) [EOL] parser . add_argument ( [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , default = [string] , help = [string] [string] [string] , ) [EOL] parser . add_argument ( [string] , default = [string] , help = [string] [string] [string] , ) [EOL] parser . add_argument ( [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , default = [string] , help = [string] [string] , ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] rewriter = LcovFileRewriter ( args . chrome_map_path , args . app_dir , args . gre_dir , args . extra_chrome_manifests ) [EOL] [EOL] files = [ ] [EOL] for f in args . files : [EOL] if os . path . isdir ( f ) : [EOL] files += [ os . path . join ( f , e ) for e in os . listdir ( f ) ] [EOL] else : [EOL] files . append ( f ) [EOL] [EOL] rewriter . rewrite_files ( files , args . output_file , args . output_suffix ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.LcovRecord$ 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.LcovRecord$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.LcovRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.LcovRecord$ 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.LcovRecord$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $builtins.str$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.UrlFinder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.RecordRewriter$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.LcovFile$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.LcovFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.LcovFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.codecoverage.lcov_rewriter.LcovFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] from mozbuild . makeutil import ( Makefile , read_dep_makefile , Rule , write_dep_makefile , ) [EOL] from mozunit import main [EOL] import os [EOL] import unittest [EOL] from StringIO import StringIO [EOL] [EOL] [EOL] class TestMakefile ( unittest . TestCase ) : [EOL] def test_rule ( self ) : [EOL] out = StringIO ( ) [EOL] rule = Rule ( ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule . add_targets ( [ [string] , [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule . add_targets ( [ [string] ] ) [EOL] rule . add_dependencies ( [ [string] , [string] , [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule = Rule ( [ [string] , [string] ] ) [EOL] rule . add_dependencies ( [ [string] ] ) [EOL] rule . add_commands ( [ [string] ] ) [EOL] rule . add_commands ( [ [string] , [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] + [string] + [string] + [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule = Rule ( [ [string] ] ) [EOL] rule . add_dependencies ( [ [string] , [string] , [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule . add_targets ( [ [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule . add_targets ( [ [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule . add_dependencies ( [ [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule . add_dependencies ( [ [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule . add_dependencies ( [ [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule . add_dependencies ( [ [string] , [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] rule . add_targets ( [ [string] , [string] ] ) [EOL] rule . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] [EOL] def test_makefile ( self ) : [EOL] out = StringIO ( ) [EOL] mk = Makefile ( ) [EOL] rule = mk . create_rule ( [ [string] ] ) [EOL] rule . add_dependencies ( [ [string] , [string] , [string] ] ) [EOL] rule . add_commands ( [ [string] ] ) [EOL] rule = mk . create_rule ( ) . add_targets ( [ [string] , [string] ] ) [EOL] rule . add_dependencies ( [ [string] ] ) [EOL] rule . add_commands ( [ [string] ] ) [EOL] mk . dump ( out , removal_guard = False ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] + [string] + [string] + [string] ) [EOL] out . truncate ( [number] ) [EOL] [EOL] mk . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] + [string] + [string] + [string] + [string] ) [EOL] [EOL] def test_statement ( self ) : [EOL] out = StringIO ( ) [EOL] mk = Makefile ( ) [EOL] mk . create_rule ( [ [string] ] ) . add_dependencies ( [ [string] ] ) . add_commands ( [ [string] ] ) [EOL] mk . add_statement ( [string] ) [EOL] mk . create_rule ( [ [string] ] ) . add_commands ( [ [string] ] ) [EOL] mk . dump ( out , removal_guard = False ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] + [string] + [string] + [string] + [string] ) [EOL] [EOL] @ unittest . skipIf ( os . name != [string] , [string] ) def test_path_normalization ( self ) : [EOL] out = StringIO ( ) [EOL] mk = Makefile ( ) [EOL] rule = mk . create_rule ( [ [string] ] ) [EOL] rule . add_dependencies ( [ [string] , [string] ] ) [EOL] rule . add_commands ( [ [string] ] ) [EOL] mk . dump ( out ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] + [string] + [string] ) [EOL] [EOL] def test_read_dep_makefile ( self ) : [EOL] input = StringIO ( os . path . abspath ( [string] ) + [string] + [string] + [string] + [string] + [string] + [string] ) [EOL] result = list ( read_dep_makefile ( input ) ) [EOL] self . assertEqual ( len ( result ) , [number] ) [EOL] self . assertEqual ( list ( result [ [number] ] . targets ( ) ) , [ os . path . abspath ( [string] ) . replace ( os . sep , [string] ) ] ) [EOL] self . assertEqual ( list ( result [ [number] ] . dependencies ( ) ) , [ [string] ] ) [EOL] self . assertEqual ( list ( result [ [number] ] . targets ( ) ) , [ [string] , [string] ] ) [EOL] self . assertEqual ( list ( result [ [number] ] . dependencies ( ) ) , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_write_dep_makefile ( self ) : [EOL] out = StringIO ( ) [EOL] write_dep_makefile ( out , [string] , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] + [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import unittest [EOL] [EOL] import mozfile [EOL] from mozbuild . moz_yaml import load_moz_yaml , VerifyError [EOL] from nose . tools import raises [EOL] [EOL] [EOL] class TestManifest ( unittest . TestCase ) : [EOL] def test_simple ( self ) : [EOL] simple_dict = { [string] : [number] , [string] : { [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , } [EOL] with mozfile . NamedTemporaryFile ( ) as tf : [EOL] tf . write ( [string] . strip ( ) ) [EOL] tf . flush ( ) [EOL] self . assertDictEqual ( load_moz_yaml ( tf . name , require_license_file = False ) , simple_dict ) [EOL] [EOL] [comment] [EOL] with mozfile . NamedTemporaryFile ( ) as tf : [EOL] tf . write ( [string] . strip ( ) ) [EOL] tf . flush ( ) [EOL] self . assertDictEqual ( load_moz_yaml ( tf . name , require_license_file = False ) , simple_dict ) [EOL] [EOL] @ raises ( VerifyError ) def test_malformed ( self ) : [EOL] with mozfile . NamedTemporaryFile ( ) as tf : [EOL] tf . write ( [string] ) [EOL] tf . flush ( ) [EOL] load_moz_yaml ( tf . name , require_license_file = False ) [EOL] [EOL] @ raises ( VerifyError ) def test_bad_schema ( self ) : [EOL] with mozfile . NamedTemporaryFile ( ) as tf : [EOL] tf . write ( [string] ) [EOL] tf . flush ( ) [EOL] load_moz_yaml ( tf . name , require_license_file = False ) [EOL] [EOL] @ raises ( VerifyError ) def test_json ( self ) : [EOL] with mozfile . NamedTemporaryFile ( ) as tf : [EOL] tf . write ( [string] [string] [string] [string] [string] ) [EOL] tf . flush ( ) [EOL] load_moz_yaml ( tf . name , require_license_file = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import os [EOL] import unittest [EOL] [EOL] from shutil import rmtree [EOL] [EOL] from tempfile import ( gettempdir , mkdtemp , ) [EOL] [EOL] from mozfile . mozfile import NamedTemporaryFile [EOL] [EOL] from mozunit import main [EOL] [EOL] from mozbuild . mozconfig import ( MozconfigFindException , MozconfigLoadException , MozconfigLoader , ) [EOL] [EOL] [EOL] class TestMozconfigLoader ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . _old_env = dict ( os . environ ) [EOL] os . environ . pop ( [string] , None ) [EOL] os . environ . pop ( [string] , None ) [EOL] os . environ . pop ( [string] , None ) [EOL] os . environ . pop ( [string] , None ) [EOL] self . _temp_dirs = set ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . environ . clear ( ) [EOL] os . environ . update ( self . _old_env ) [EOL] [EOL] for d in self . _temp_dirs : [EOL] rmtree ( d ) [EOL] [EOL] def get_loader ( self ) : [EOL] return MozconfigLoader ( self . get_temp_dir ( ) ) [EOL] [EOL] def get_temp_dir ( self ) : [EOL] d = mkdtemp ( ) [EOL] self . _temp_dirs . add ( d ) [EOL] [EOL] return d [EOL] [EOL] def test_find_legacy_env ( self ) : [EOL] [docstring] [EOL] [EOL] os . environ [ [string] ] = [string] [EOL] [EOL] with self . assertRaises ( MozconfigFindException ) as e : [EOL] self . get_loader ( ) . find_mozconfig ( ) [EOL] [EOL] self . assertTrue ( e . exception . message . startswith ( [string] ) ) [EOL] [EOL] def test_find_multiple_configs ( self ) : [EOL] [docstring] [EOL] relative_mozconfig = [string] [EOL] os . environ [ [string] ] = relative_mozconfig [EOL] [EOL] srcdir = self . get_temp_dir ( ) [EOL] curdir = self . get_temp_dir ( ) [EOL] dirs = [ srcdir , curdir ] [EOL] loader = MozconfigLoader ( srcdir ) [EOL] for d in dirs : [EOL] path = os . path . join ( d , relative_mozconfig ) [EOL] with open ( path , [string] ) as f : [EOL] f . write ( path ) [EOL] [EOL] orig_dir = os . getcwd ( ) [EOL] try : [EOL] os . chdir ( curdir ) [EOL] with self . assertRaises ( MozconfigFindException ) as e : [EOL] loader . find_mozconfig ( ) [EOL] finally : [EOL] os . chdir ( orig_dir ) [EOL] [EOL] self . assertIn ( [string] , e . exception . message ) [EOL] for d in dirs : [EOL] self . assertIn ( d , e . exception . message ) [EOL] [EOL] def test_find_multiple_but_identical_configs ( self ) : [EOL] [docstring] [EOL] relative_mozconfig = [string] [EOL] os . environ [ [string] ] = relative_mozconfig [EOL] [EOL] topdir = self . get_temp_dir ( ) [EOL] srcdir = os . path . join ( topdir , [string] ) [EOL] os . mkdir ( srcdir ) [EOL] curdir = os . path . join ( topdir , [string] ) [EOL] os . mkdir ( curdir ) [EOL] [EOL] loader = MozconfigLoader ( srcdir ) [EOL] path = os . path . join ( srcdir , relative_mozconfig ) [EOL] with open ( path , [string] ) : [EOL] pass [EOL] [EOL] orig_dir = os . getcwd ( ) [EOL] try : [EOL] os . chdir ( curdir ) [EOL] self . assertEqual ( os . path . realpath ( loader . find_mozconfig ( ) ) , os . path . realpath ( path ) ) [EOL] finally : [EOL] os . chdir ( orig_dir ) [EOL] [EOL] def test_find_no_relative_configs ( self ) : [EOL] [docstring] [EOL] relative_mozconfig = [string] [EOL] os . environ [ [string] ] = relative_mozconfig [EOL] [EOL] srcdir = self . get_temp_dir ( ) [EOL] curdir = self . get_temp_dir ( ) [EOL] dirs = [ srcdir , curdir ] [EOL] loader = MozconfigLoader ( srcdir ) [EOL] [EOL] orig_dir = os . getcwd ( ) [EOL] try : [EOL] os . chdir ( curdir ) [EOL] with self . assertRaises ( MozconfigFindException ) as e : [EOL] loader . find_mozconfig ( ) [EOL] finally : [EOL] os . chdir ( orig_dir ) [EOL] [EOL] self . assertIn ( [string] , e . exception . message ) [EOL] for d in dirs : [EOL] self . assertIn ( d , e . exception . message ) [EOL] [EOL] def test_find_relative_mozconfig ( self ) : [EOL] [docstring] [EOL] relative_mozconfig = [string] [EOL] os . environ [ [string] ] = relative_mozconfig [EOL] [EOL] srcdir = self . get_temp_dir ( ) [EOL] curdir = self . get_temp_dir ( ) [EOL] loader = MozconfigLoader ( srcdir ) [EOL] [EOL] path = os . path . join ( srcdir , relative_mozconfig ) [EOL] with open ( path , [string] ) : [EOL] pass [EOL] [EOL] orig_dir = os . getcwd ( ) [EOL] try : [EOL] os . chdir ( curdir ) [EOL] self . assertEqual ( os . path . normpath ( loader . find_mozconfig ( ) ) , os . path . normpath ( path ) ) [EOL] finally : [EOL] os . chdir ( orig_dir ) [EOL] [EOL] def test_find_abs_path_not_exist ( self ) : [EOL] [docstring] [EOL] os . environ [ [string] ] = [string] [EOL] [EOL] with self . assertRaises ( MozconfigFindException ) as e : [EOL] self . get_loader ( ) . find_mozconfig ( ) [EOL] [EOL] self . assertIn ( [string] , e . exception . message ) [EOL] self . assertTrue ( e . exception . message . endswith ( [string] ) ) [EOL] [EOL] def test_find_path_not_file ( self ) : [EOL] [docstring] [EOL] [EOL] os . environ [ [string] ] = gettempdir ( ) [EOL] [EOL] with self . assertRaises ( MozconfigFindException ) as e : [EOL] self . get_loader ( ) . find_mozconfig ( ) [EOL] [EOL] self . assertIn ( [string] , e . exception . message ) [EOL] self . assertTrue ( e . exception . message . endswith ( gettempdir ( ) ) ) [EOL] [EOL] def test_find_default_files ( self ) : [EOL] [docstring] [EOL] for p in MozconfigLoader . DEFAULT_TOPSRCDIR_PATHS : [EOL] d = self . get_temp_dir ( ) [EOL] path = os . path . join ( d , p ) [EOL] [EOL] with open ( path , [string] ) : [EOL] pass [EOL] [EOL] self . assertEqual ( MozconfigLoader ( d ) . find_mozconfig ( ) , path ) [EOL] [EOL] def test_find_multiple_defaults ( self ) : [EOL] [docstring] [EOL] self . assertGreater ( len ( MozconfigLoader . DEFAULT_TOPSRCDIR_PATHS ) , [number] ) [EOL] [EOL] d = self . get_temp_dir ( ) [EOL] for p in MozconfigLoader . DEFAULT_TOPSRCDIR_PATHS : [EOL] with open ( os . path . join ( d , p ) , [string] ) : [EOL] pass [EOL] [EOL] with self . assertRaises ( MozconfigFindException ) as e : [EOL] MozconfigLoader ( d ) . find_mozconfig ( ) [EOL] [EOL] self . assertIn ( [string] , e . exception . message ) [EOL] [EOL] def test_find_deprecated_path_srcdir ( self ) : [EOL] [docstring] [EOL] for p in MozconfigLoader . DEPRECATED_TOPSRCDIR_PATHS : [EOL] d = self . get_temp_dir ( ) [EOL] with open ( os . path . join ( d , p ) , [string] ) : [EOL] pass [EOL] [EOL] with self . assertRaises ( MozconfigFindException ) as e : [EOL] MozconfigLoader ( d ) . find_mozconfig ( ) [EOL] [EOL] self . assertIn ( [string] , e . exception . message ) [EOL] self . assertIn ( d , e . exception . message ) [EOL] [EOL] def test_find_deprecated_home_paths ( self ) : [EOL] [docstring] [EOL] [EOL] for p in MozconfigLoader . DEPRECATED_HOME_PATHS : [EOL] home = self . get_temp_dir ( ) [EOL] os . environ [ [string] ] = home [EOL] path = os . path . join ( home , p ) [EOL] [EOL] with open ( path , [string] ) : [EOL] pass [EOL] [EOL] with self . assertRaises ( MozconfigFindException ) as e : [EOL] self . get_loader ( ) . find_mozconfig ( ) [EOL] [EOL] self . assertIn ( [string] , e . exception . message ) [EOL] self . assertIn ( path , e . exception . message ) [EOL] [EOL] def test_read_no_mozconfig ( self ) : [EOL] [comment] [EOL] result = self . get_loader ( ) . read_mozconfig ( ) [EOL] [EOL] self . assertEqual ( result , { [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , } ) [EOL] [EOL] def test_read_empty_mozconfig ( self ) : [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] , mozconfig . name ) [EOL] self . assertIsNone ( result [ [string] ] ) [EOL] self . assertEqual ( result [ [string] ] , [ ] ) [EOL] self . assertEqual ( result [ [string] ] , [ ] ) [EOL] self . assertEqual ( result [ [string] ] , [ ] ) [EOL] [EOL] for f in ( [string] , [string] , [string] ) : [EOL] self . assertEqual ( len ( result [ [string] ] [ f ] ) , [number] ) [EOL] self . assertEqual ( len ( result [ [string] ] [ f ] ) , [number] ) [EOL] [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { } ) [EOL] [EOL] def test_read_capture_ac_options ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] self . assertEqual ( result [ [string] ] , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_read_ac_options_substitution ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] loader = self . get_loader ( ) [EOL] result = loader . read_mozconfig ( mozconfig . name ) [EOL] self . assertEqual ( result [ [string] ] , [ [string] % loader . topsrcdir ] ) [EOL] [EOL] def test_read_capture_mk_options ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] self . assertEqual ( result [ [string] ] , [string] ) [EOL] self . assertEqual ( result [ [string] ] , [ [string] , [string] ] ) [EOL] self . assertEqual ( result [ [string] ] , [ [string] , [string] ] ) [EOL] [EOL] def test_read_empty_mozconfig_objdir_environ ( self ) : [EOL] os . environ [ [string] ] = [string] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] self . assertEqual ( result [ [string] ] , [string] ) [EOL] [EOL] def test_read_capture_mk_options_objdir_environ ( self ) : [EOL] [docstring] [EOL] os . environ [ [string] ] = [string] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] self . assertEqual ( result [ [string] ] , [string] ) [EOL] [EOL] def test_read_moz_objdir_substitution ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] loader = self . get_loader ( ) [EOL] result = loader . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] , [string] % loader . topsrcdir ) [EOL] [EOL] def test_read_new_variables ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { [string] : [string] , [string] : [string] } ) [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { } ) [EOL] [EOL] def test_read_exported_variables ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { } ) [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { [string] : [string] } ) [EOL] [EOL] def test_read_modify_variables ( self ) : [EOL] [docstring] [EOL] old_path = os . path . realpath ( [string] ) [EOL] new_path = os . path . realpath ( [string] ) [EOL] os . environ [ [string] ] = old_path [EOL] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] % new_path ) [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { } ) [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { [string] : ( old_path , new_path ) } ) [EOL] [EOL] def test_read_unmodified_variables ( self ) : [EOL] [docstring] [EOL] cc_path = os . path . realpath ( [string] ) [EOL] os . environ [ [string] ] = cc_path [EOL] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { } ) [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { [string] : cc_path } ) [EOL] [EOL] def test_read_removed_variables ( self ) : [EOL] [docstring] [EOL] cc_path = os . path . realpath ( [string] ) [EOL] os . environ [ [string] ] = cc_path [EOL] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { } ) [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { [string] : cc_path } ) [EOL] [EOL] def test_read_multiline_variables ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { [string] : [string] , [string] : [string] } ) [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { } ) [EOL] [EOL] def test_read_topsrcdir_defined ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] loader = self . get_loader ( ) [EOL] result = loader . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] [ [string] ] [ [string] ] , loader . topsrcdir . replace ( os . sep , [string] ) ) [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { } ) [EOL] [EOL] def test_read_empty_variable_value ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] result = self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { [string] : [string] , } ) [EOL] self . assertEqual ( result [ [string] ] [ [string] ] , { [string] : [string] } ) [EOL] [EOL] def test_read_load_exception ( self ) : [EOL] [docstring] [EOL] with NamedTemporaryFile ( mode = [string] ) as mozconfig : [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . write ( [string] ) [EOL] mozconfig . flush ( ) [EOL] [EOL] with self . assertRaises ( MozconfigLoadException ) as e : [EOL] self . get_loader ( ) . read_mozconfig ( mozconfig . name ) [EOL] [EOL] self . assertTrue ( e . exception . message . startswith ( [string] ) ) [EOL] self . assertEquals ( e . exception . path , mozconfig . name . replace ( os . sep , [string] ) ) [EOL] self . assertEquals ( e . exception . output , [ [string] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] [EOL] import mozunit [EOL] [EOL] from mozpack . manifests import ( InstallManifest , ) [EOL] from mozpack . test . test_files import TestWithTmpDir [EOL] [EOL] import mozbuild . action . process_install_manifest as process_install_manifest [EOL] [EOL] [EOL] class TestGenerateManifest ( TestWithTmpDir ) : [EOL] [docstring] [EOL] [EOL] def test_process_manifest ( self ) : [EOL] source = self . tmppath ( [string] ) [EOL] os . mkdir ( source ) [EOL] os . mkdir ( [string] % source ) [EOL] os . mkdir ( [string] % source ) [EOL] os . mkdir ( [string] % source ) [EOL] [EOL] with open ( [string] % source , [string] ) : [EOL] pass [EOL] [EOL] with open ( [string] % source , [string] ) : [EOL] pass [EOL] [EOL] with open ( [string] % source , [string] ) : [EOL] pass [EOL] [EOL] m = InstallManifest ( ) [EOL] m . add_pattern_link ( [string] % source , [string] , [string] ) [EOL] m . add_link ( [string] % source , [string] ) [EOL] [EOL] p = self . tmppath ( [string] ) [EOL] m . write ( path = p ) [EOL] [EOL] dest = self . tmppath ( [string] ) [EOL] track = self . tmppath ( [string] ) [EOL] [EOL] for i in range ( [number] ) : [EOL] process_install_manifest . process_manifest ( dest , [ p ] , track ) [EOL] [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] [EOL] m = InstallManifest ( ) [EOL] m . write ( path = p ) [EOL] [EOL] for i in range ( [number] ) : [EOL] process_install_manifest . process_manifest ( dest , [ p ] , track ) [EOL] [EOL] self . assertFalse ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertFalse ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertFalse ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Any , Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import buildconfig [EOL] import os [EOL] import unittest [EOL] from mozunit import main [EOL] from tempfile import mkdtemp [EOL] from shutil import rmtree [EOL] [EOL] import mozpack . path as mozpath [EOL] from mozbuild . backend . configenvironment import PartialConfigEnvironment [EOL] [EOL] config = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : [ [string] , ] , } [EOL] [EOL] [EOL] class TestPartial ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . _old_env = dict ( os . environ ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . environ . clear ( ) [EOL] os . environ . update ( self . _old_env ) [EOL] [EOL] def _objdir ( self ) : [EOL] objdir = mkdtemp ( dir = buildconfig . topsrcdir ) [EOL] self . addCleanup ( rmtree , objdir ) [EOL] return objdir [EOL] [EOL] def test_auto_substs ( self ) : [EOL] [docstring] [EOL] env = PartialConfigEnvironment ( self . _objdir ( ) ) [EOL] env . write_vars ( config ) [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] self . assertEqual ( env . defines [ [string] ] , { [string] : [string] , [string] : [string] , } ) [EOL] [EOL] def test_remove_subst ( self ) : [EOL] [docstring] [EOL] env = PartialConfigEnvironment ( self . _objdir ( ) ) [EOL] path = mozpath . join ( env . topobjdir , [string] , [string] , [string] ) [EOL] myconfig = config . copy ( ) [EOL] env . write_vars ( myconfig ) [EOL] with self . assertRaises ( KeyError ) : [EOL] _ = env . substs [ [string] ] [EOL] self . assertFalse ( os . path . exists ( path ) ) [EOL] [EOL] myconfig [ [string] ] [ [string] ] = [string] [EOL] env . write_vars ( myconfig ) [EOL] [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] self . assertTrue ( os . path . exists ( path ) ) [EOL] [EOL] del myconfig [ [string] ] [ [string] ] [EOL] env . write_vars ( myconfig ) [EOL] with self . assertRaises ( KeyError ) : [EOL] _ = env . substs [ [string] ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertTrue ( os . path . exists ( path ) ) [EOL] [EOL] def _assert_deps ( self , env , deps ) : [EOL] deps = sorted ( [ [string] % ( mozpath . join ( env . topobjdir , [string] , d ) ) for d in deps ] ) [EOL] self . assertEqual ( sorted ( env . get_dependencies ( ) ) , deps ) [EOL] [EOL] def test_dependencies ( self ) : [EOL] [docstring] [EOL] env = PartialConfigEnvironment ( self . _objdir ( ) ) [EOL] env . write_vars ( config ) [EOL] self . _assert_deps ( env , [ ] ) [EOL] [EOL] self . assertEqual ( env . defines [ [string] ] , [string] ) [EOL] self . _assert_deps ( env , [ [string] ] ) [EOL] [EOL] self . assertEqual ( env . defines [ [string] ] , [string] ) [EOL] self . _assert_deps ( env , [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( env . defines [ [string] ] , [string] ) [EOL] self . _assert_deps ( env , [ [string] , [string] ] ) [EOL] [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] self . _assert_deps ( env , [ [string] , [string] , [string] ] ) [EOL] [EOL] with self . assertRaises ( KeyError ) : [EOL] _ = env . substs [ [string] ] [EOL] self . _assert_deps ( env , [ [string] , [string] , [string] , [string] ] ) [EOL] self . assertEqual ( env . substs . get ( [string] ) , None ) [EOL] [EOL] def test_set_subst ( self ) : [EOL] [docstring] [EOL] env = PartialConfigEnvironment ( self . _objdir ( ) ) [EOL] env . write_vars ( config ) [EOL] [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] env . substs [ [string] ] = [string] [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] [EOL] [comment] [EOL] newenv = PartialConfigEnvironment ( env . topobjdir ) [EOL] self . assertEqual ( newenv . substs [ [string] ] , [string] ) [EOL] [EOL] def test_env_override ( self ) : [EOL] [docstring] [EOL] env = PartialConfigEnvironment ( self . _objdir ( ) ) [EOL] env . write_vars ( config ) [EOL] [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] [EOL] [comment] [EOL] env = PartialConfigEnvironment ( env . topobjdir ) [EOL] os . environ [ [string] ] = [string] [EOL] os . environ [ [string] ] = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] self . assertEqual ( env . substs [ [string] ] , [string] ) [EOL] [EOL] def test_update ( self ) : [EOL] [docstring] [EOL] env = PartialConfigEnvironment ( self . _objdir ( ) ) [EOL] env . write_vars ( config ) [EOL] [EOL] mysubsts = { [string] : [string] } [EOL] mysubsts . update ( env . substs . iteritems ( ) ) [EOL] self . assertEqual ( mysubsts [ [string] ] , [string] ) [EOL] self . assertEqual ( mysubsts [ [string] ] , [string] ) [EOL] [EOL] mydefines = { [string] : [string] } [EOL] mydefines . update ( env . defines . iteritems ( ) ) [EOL] self . assertEqual ( mydefines [ [string] ] , [string] ) [EOL] self . assertEqual ( mydefines [ [string] ] , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Tuple [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import unittest [EOL] import sqlite3 as lite [EOL] import mozunit [EOL] [EOL] from mozbuild . analyze . graph import Graph [EOL] [EOL] CREATE_NODE = [string] [EOL] [EOL] CREATE_NORMAL_LINK = [string] [EOL] [EOL] NODE_DATA = [ ( [number] , [number] , [number] , - [number] , [string] ) , ( [number] , [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , - [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , [number] , [string] ) , ( [number] , [number] , [number] , - [number] , [string] ) , ( [number] , [number] , [number] , - [number] , [string] ) , ( [number] , [number] , [number] , - [number] , [string] ) ] [EOL] [EOL] NORMAL_LINK_DATA = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] [EOL] PATH_TO_TEST_DB = [string] [EOL] [EOL] [EOL] class TestGraph ( unittest . TestCase ) : [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . connect = lite . connect ( PATH_TO_TEST_DB ) [EOL] cls . connect . text_factory = str [EOL] cls . cursor = cls . connect . cursor ( ) [EOL] [comment] [EOL] cls . cursor . execute ( CREATE_NODE ) [EOL] cls . cursor . execute ( CREATE_NORMAL_LINK ) [EOL] [comment] [EOL] for d in NODE_DATA : [EOL] cls . cursor . execute ( [string] , d ) [EOL] for d in NORMAL_LINK_DATA : [EOL] cls . cursor . execute ( [string] , d ) [EOL] cls . connect . commit ( ) [EOL] [EOL] @ classmethod def tearDownClass ( cls ) : [EOL] cls . connect . close ( ) [EOL] [EOL] def test_graph_cmds ( self ) : [EOL] g = Graph ( connect = self . connect ) [EOL] libxul = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [comment] [EOL] self . assertEqual ( len ( g . get_node ( [number] ) . cmds ) , [number] ) [EOL] self . assertEqual ( len ( g . get_node ( [number] ) . cmds ) , [number] ) [EOL] self . assertEqual ( len ( g . get_node ( [number] ) . cmds ) , [number] ) [EOL] [comment] [EOL] self . assertItemsEqual ( g . get_node ( [number] ) . get_cmd_ids ( ) , [ [number] ] + libxul ) [EOL] self . assertItemsEqual ( g . get_node ( [number] ) . get_cmd_ids ( ) , [ [number] ] + libxul ) [EOL] [comment] [EOL] self . assertItemsEqual ( g . get_node ( [number] ) . get_cmd_ids ( ) , [ [number] , [number] , [number] ] + libxul ) [EOL] [comment] [EOL] self . assertItemsEqual ( g . get_node ( [number] ) . get_cmd_ids ( ) , libxul [ [number] : ] ) [EOL] self . assertItemsEqual ( g . get_node ( [number] ) . get_cmd_ids ( ) , libxul ) [EOL] [comment] [EOL] self . assertItemsEqual ( g . get_node ( [number] ) . get_cmd_ids ( ) , [ [number] ] ) [EOL] self . assertItemsEqual ( g . get_node ( [number] ) . get_cmd_ids ( ) , [ [number] ] + libxul ) [EOL] self . assertItemsEqual ( g . get_node ( [number] ) . get_cmd_ids ( ) , libxul ) [EOL] [EOL] def test_mtime_calc ( self ) : [EOL] g = Graph ( connect = self . connect ) [EOL] [comment] [EOL] self . assertEqual ( g . get_node ( [number] ) . cost , [number] ) [EOL] self . assertEqual ( g . get_node ( [number] ) . cost , [number] ) [EOL] [comment] [EOL] self . assertEqual ( g . get_node ( [number] ) . cost , [number] ) [EOL] [comment] [EOL] self . assertEqual ( g . get_node ( [number] ) . cost , None ) [EOL] [comment] [EOL] self . assertEqual ( g . get_node ( [number] ) . cost , None ) [EOL] [comment] [EOL] self . assertEqual ( g . get_node ( [number] ) . cost , [number] ) [EOL] [EOL] def test_path ( self ) : [EOL] g = Graph ( connect = self . connect ) [EOL] [comment] [EOL] self . assertEqual ( g . get_node ( [number] ) . path , [string] ) [EOL] self . assertEqual ( g . get_node ( [number] ) . path , [string] ) [EOL] self . assertEqual ( g . get_node ( [number] ) . path , [string] ) [EOL] [comment] [EOL] self . assertEqual ( g . get_node ( [number] ) . path , [string] ) [EOL] self . assertEqual ( g . get_node ( [number] ) . path , [string] ) [EOL] self . assertEqual ( g . get_node ( [number] ) . path , [string] ) [EOL] self . assertEqual ( g . get_node ( [number] ) . path , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import logging [EOL] import os [EOL] import tempfile [EOL] import textwrap [EOL] import unittest [EOL] import sys [EOL] [EOL] from StringIO import StringIO [EOL] [EOL] from mozunit import main [EOL] from mozpack import path as mozpath [EOL] [EOL] from mozbuild . configure . util import ( ConfigureOutputHandler , getpreferredencoding , LineIO , Version , ) [EOL] [EOL] from mozbuild . configure import ( ConfigureSandbox , ) [EOL] [EOL] from mozbuild . util import exec_ [EOL] [EOL] from buildconfig import topsrcdir [EOL] from common import ConfigureTestSandbox [EOL] [EOL] [EOL] class TestConfigureOutputHandler ( unittest . TestCase ) : [EOL] def test_separation ( self ) : [EOL] out = StringIO ( ) [EOL] err = StringIO ( ) [EOL] name = [string] % self . __class__ . __name__ [EOL] logger = logging . getLogger ( name ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] logger . addHandler ( ConfigureOutputHandler ( out , err ) ) [EOL] [EOL] logger . error ( [string] ) [EOL] logger . warning ( [string] ) [EOL] logger . info ( [string] ) [EOL] [comment] [EOL] logger . debug ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] self . assertEqual ( err . getvalue ( ) , [string] ) [EOL] [EOL] def test_format ( self ) : [EOL] out = StringIO ( ) [EOL] err = StringIO ( ) [EOL] name = [string] % self . __class__ . __name__ [EOL] logger = logging . getLogger ( name ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] handler = ConfigureOutputHandler ( out , err ) [EOL] handler . setFormatter ( logging . Formatter ( [string] ) ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] logger . error ( [string] ) [EOL] logger . warning ( [string] ) [EOL] logger . info ( [string] ) [EOL] [comment] [EOL] logger . debug ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] self . assertEqual ( err . getvalue ( ) , [string] [string] ) [EOL] [EOL] def test_continuation ( self ) : [EOL] out = StringIO ( ) [EOL] name = [string] % self . __class__ . __name__ [EOL] logger = logging . getLogger ( name ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] handler = ConfigureOutputHandler ( out , out ) [EOL] handler . setFormatter ( logging . Formatter ( [string] ) ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . warning ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . warning ( [string] ) [EOL] logger . warning ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] err = StringIO ( ) [EOL] [EOL] logger . removeHandler ( handler ) [EOL] handler = ConfigureOutputHandler ( out , err ) [EOL] handler . setFormatter ( logging . Formatter ( [string] ) ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . warning ( [string] ) [EOL] logger . warning ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] ) [EOL] [EOL] self . assertEqual ( err . getvalue ( ) , [string] [string] ) [EOL] [EOL] def test_queue_debug ( self ) : [EOL] out = StringIO ( ) [EOL] name = [string] % self . __class__ . __name__ [EOL] logger = logging . getLogger ( name ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] handler = ConfigureOutputHandler ( out , out , maxlen = [number] ) [EOL] handler . setFormatter ( logging . Formatter ( [string] ) ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . error ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . error ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . info ( [string] ) [EOL] logger . error ( [string] ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] [EOL] try : [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . info ( [string] ) [EOL] e = Exception ( [string] ) [EOL] raise e [EOL] except Exception as caught : [EOL] self . assertIs ( caught , e ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] ) [EOL] [EOL] def test_queue_debug_reentrant ( self ) : [EOL] out = StringIO ( ) [EOL] name = [string] % self . __class__ . __name__ [EOL] logger = logging . getLogger ( name ) [EOL] logger . setLevel ( logging . DEBUG ) [EOL] handler = ConfigureOutputHandler ( out , out , maxlen = [number] ) [EOL] handler . setFormatter ( logging . Formatter ( [string] ) ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] try : [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] e = Exception ( [string] ) [EOL] raise e [EOL] except Exception as caught : [EOL] self . assertIs ( caught , e ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] [EOL] try : [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] e = Exception ( [string] ) [EOL] raise e [EOL] except Exception as caught : [EOL] self . assertIs ( caught , e ) [EOL] [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . error ( [string] ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] [string] [string] ) [EOL] [EOL] out . seek ( [number] ) [EOL] out . truncate ( ) [EOL] [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] with handler . queue_debug ( ) : [EOL] logger . info ( [string] ) [EOL] logger . debug ( [string] ) [EOL] logger . error ( [string] ) [EOL] self . assertEqual ( out . getvalue ( ) , [string] [string] [string] [string] [string] ) [EOL] [EOL] def test_is_same_output ( self ) : [EOL] fd1 = sys . stderr . fileno ( ) [EOL] fd2 = os . dup ( fd1 ) [EOL] try : [EOL] self . assertTrue ( ConfigureOutputHandler . _is_same_output ( fd1 , fd2 ) ) [EOL] finally : [EOL] os . close ( fd2 ) [EOL] [EOL] fd2 , path = tempfile . mkstemp ( ) [EOL] try : [EOL] self . assertFalse ( ConfigureOutputHandler . _is_same_output ( fd1 , fd2 ) ) [EOL] [EOL] fd3 = os . dup ( fd2 ) [EOL] try : [EOL] self . assertTrue ( ConfigureOutputHandler . _is_same_output ( fd2 , fd3 ) ) [EOL] finally : [EOL] os . close ( fd3 ) [EOL] [EOL] with open ( path , [string] ) as fh : [EOL] fd3 = fh . fileno ( ) [EOL] self . assertTrue ( ConfigureOutputHandler . _is_same_output ( fd2 , fd3 ) ) [EOL] [EOL] finally : [EOL] os . close ( fd2 ) [EOL] os . remove ( path ) [EOL] [EOL] [EOL] class TestLineIO ( unittest . TestCase ) : [EOL] def test_lineio ( self ) : [EOL] lines = [ ] [EOL] l = LineIO ( lambda l : lines . append ( l ) ) [EOL] [EOL] l . write ( [string] ) [EOL] self . assertEqual ( lines , [ ] ) [EOL] [EOL] l . write ( [string] ) [EOL] self . assertEqual ( lines , [ ] ) [EOL] [EOL] l . write ( [string] ) [EOL] self . assertEqual ( lines , [ [string] ] ) [EOL] [EOL] l . write ( [string] ) [EOL] self . assertEqual ( lines , [ [string] ] ) [EOL] [EOL] l . write ( [string] ) [EOL] self . assertEqual ( lines , [ [string] , [string] ] ) [EOL] [EOL] l . write ( [string] ) [EOL] self . assertEqual ( lines , [ [string] , [string] , [string] ] ) [EOL] [EOL] l . write ( [string] ) [EOL] self . assertEqual ( lines , [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] l . write ( [string] ) [EOL] self . assertEqual ( lines , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] l . close ( ) [EOL] self . assertEqual ( lines , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_lineio_contextmanager ( self ) : [EOL] lines = [ ] [EOL] with LineIO ( lambda l : lines . append ( l ) ) as l : [EOL] l . write ( [string] ) [EOL] [EOL] self . assertEqual ( lines , [ [string] , [string] ] ) [EOL] [EOL] self . assertEqual ( lines , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class TestLogSubprocessOutput ( unittest . TestCase ) : [EOL] [EOL] def test_non_ascii_subprocess_output ( self ) : [EOL] out = StringIO ( ) [EOL] sandbox = ConfigureSandbox ( { } , { } , [ [string] ] , out , out ) [EOL] [EOL] sandbox . include_file ( mozpath . join ( topsrcdir , [string] , [string] , [string] ) ) [EOL] sandbox . include_file ( mozpath . join ( topsrcdir , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) ) [EOL] status = [number] [EOL] try : [EOL] sandbox . run ( ) [EOL] except SystemExit as e : [EOL] status = e . code [EOL] [EOL] self . assertEquals ( status , [number] ) [EOL] quote_char = [string] [EOL] if getpreferredencoding ( ) . lower ( ) == [string] : [EOL] quote_char = [string] . encode ( [string] ) [EOL] self . assertEquals ( out . getvalue ( ) . strip ( ) , quote_char ) [EOL] [EOL] [EOL] class TestVersion ( unittest . TestCase ) : [EOL] def test_version_simple ( self ) : [EOL] v = Version ( [string] ) [EOL] self . assertEqual ( v , [string] ) [EOL] self . assertLess ( v , [string] ) [EOL] self . assertGreater ( v , [string] ) [EOL] self . assertEqual ( v . major , [number] ) [EOL] self . assertEqual ( v . minor , [number] ) [EOL] self . assertEqual ( v . patch , [number] ) [EOL] [EOL] def test_version_more ( self ) : [EOL] v = Version ( [string] ) [EOL] self . assertLess ( v , [string] ) [EOL] self . assertEqual ( v . major , [number] ) [EOL] self . assertEqual ( v . minor , [number] ) [EOL] self . assertEqual ( v . patch , [number] ) [EOL] [EOL] def test_version_bad ( self ) : [EOL] [comment] [EOL] [comment] [EOL] v = Version ( [string] ) [EOL] self . assertLess ( v , [string] ) [EOL] self . assertEqual ( v . major , [number] ) [EOL] self . assertEqual ( v . minor , [number] ) [EOL] self . assertEqual ( v . patch , [number] ) [EOL] [EOL] def test_version_badder ( self ) : [EOL] v = Version ( [string] ) [EOL] self . assertLess ( v , [string] ) [EOL] self . assertEqual ( v . major , [number] ) [EOL] self . assertEqual ( v . minor , [number] ) [EOL] self . assertEqual ( v . patch , [number] ) [EOL] [EOL] [EOL] class TestCheckCmdOutput ( unittest . TestCase ) : [EOL] [EOL] def get_result ( self , command = [string] , paths = None ) : [EOL] paths = paths or { } [EOL] config = { } [EOL] out = StringIO ( ) [EOL] sandbox = ConfigureTestSandbox ( paths , config , { } , [ [string] ] , out , out ) [EOL] sandbox . include_file ( mozpath . join ( topsrcdir , [string] , [string] , [string] ) ) [EOL] status = [number] [EOL] try : [EOL] exec_ ( command , sandbox ) [EOL] sandbox . run ( ) [EOL] except SystemExit as e : [EOL] status = e . code [EOL] return config , out . getvalue ( ) , status [EOL] [EOL] def test_simple_program ( self ) : [EOL] def mock_simple_prog ( _ , args ) : [EOL] if len ( args ) == [number] and args [ [number] ] == [string] : [EOL] return [number] , [string] , [string] [EOL] self . fail ( [string] % args ) [EOL] prog_path = mozpath . abspath ( [string] ) [EOL] cmd = [string] % prog_path [EOL] config , out , status = self . get_result ( cmd , paths = { prog_path : mock_simple_prog } ) [EOL] self . assertEqual ( config , { } ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( out , [string] ) [EOL] [EOL] def test_failing_program ( self ) : [EOL] def mock_error_prog ( _ , args ) : [EOL] if len ( args ) == [number] and args [ [number] ] == [string] : [EOL] return ( [number] , [string] , [string] ) [EOL] self . fail ( [string] % args ) [EOL] prog_path = mozpath . abspath ( [string] ) [EOL] cmd = [string] % prog_path [EOL] config , out , status = self . get_result ( cmd , paths = { prog_path : mock_error_prog } ) [EOL] self . assertEqual ( config , { } ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] % ( prog_path , prog_path ) ) ) [EOL] [EOL] def test_error_callback ( self ) : [EOL] def mock_error_prog ( _ , args ) : [EOL] if len ( args ) == [number] and args [ [number] ] == [string] : [EOL] return [number] , [string] , [string] [EOL] self . fail ( [string] % args ) [EOL] [EOL] prog_path = mozpath . abspath ( [string] ) [EOL] cmd = textwrap . dedent ( [string] % prog_path ) [EOL] config , out , status = self . get_result ( cmd , paths = { prog_path : mock_error_prog } ) [EOL] self . assertEqual ( config , { } ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] % prog_path ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import os [EOL] import textwrap [EOL] import unittest [EOL] import mozpack . path as mozpath [EOL] [EOL] from StringIO import StringIO [EOL] [EOL] from buildconfig import topsrcdir [EOL] from common import ConfigureTestSandbox [EOL] from mozbuild . util import exec_ [EOL] from mozunit import main [EOL] from test_toolchain_helpers import FakeCompiler [EOL] [EOL] [EOL] class BaseCompileChecks ( unittest . TestCase ) : [EOL] def get_mock_compiler ( self , expected_test_content = None , expected_flags = None ) : [EOL] expected_flags = expected_flags or [ ] [EOL] [EOL] def mock_compiler ( stdin , args ) : [EOL] args , test_file = args [ : - [number] ] , args [ - [number] ] [EOL] self . assertIn ( [string] , args ) [EOL] for flag in expected_flags : [EOL] self . assertIn ( flag , args ) [EOL] [EOL] if expected_test_content : [EOL] with open ( test_file ) as fh : [EOL] test_content = fh . read ( ) [EOL] self . assertEqual ( test_content , expected_test_content ) [EOL] [EOL] return FakeCompiler ( ) ( None , args ) [EOL] return mock_compiler [EOL] [EOL] def do_compile_test ( self , command , expected_test_content = None , expected_flags = None ) : [EOL] [EOL] paths = { os . path . abspath ( [string] ) : self . get_mock_compiler ( expected_test_content = expected_test_content , expected_flags = expected_flags ) , } [EOL] [EOL] base_dir = os . path . join ( topsrcdir , [string] , [string] ) [EOL] [EOL] mock_compiler_defs = textwrap . dedent ( [string] % mozpath . normsep ( base_dir ) ) [EOL] [EOL] config = { } [EOL] out = StringIO ( ) [EOL] sandbox = ConfigureTestSandbox ( paths , config , { } , [ [string] ] , out , out ) [EOL] sandbox . include_file ( os . path . join ( base_dir , [string] ) ) [EOL] sandbox . include_file ( os . path . join ( base_dir , [string] ) ) [EOL] exec_ ( mock_compiler_defs , sandbox ) [EOL] sandbox . include_file ( os . path . join ( base_dir , [string] ) ) [EOL] [EOL] status = [number] [EOL] try : [EOL] exec_ ( command , sandbox ) [EOL] sandbox . run ( ) [EOL] except SystemExit as e : [EOL] status = e . code [EOL] [EOL] return config , out . getvalue ( ) , status [EOL] [EOL] [EOL] class TestHeaderChecks ( BaseCompileChecks ) : [EOL] def test_try_compile_include ( self ) : [EOL] expected_test_content = textwrap . dedent ( [string] ) [EOL] [EOL] cmd = textwrap . dedent ( [string] ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd , expected_test_content ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { } ) [EOL] [EOL] def test_try_compile_flags ( self ) : [EOL] expected_flags = [ [string] , [string] ] [EOL] [EOL] cmd = textwrap . dedent ( [string] ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd , expected_flags = expected_flags ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { } ) [EOL] [EOL] def test_try_compile_failure ( self ) : [EOL] cmd = textwrap . dedent ( [string] ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : True , } ) [EOL] [EOL] def test_try_compile_msg ( self ) : [EOL] cmd = textwrap . dedent ( [string] ) [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : True } ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] ) ) [EOL] [EOL] def test_check_header ( self ) : [EOL] expected_test_content = textwrap . dedent ( [string] ) [EOL] [EOL] cmd = textwrap . dedent ( [string] ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd , expected_test_content = expected_test_content ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : { [string] : True } } ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] ) ) [EOL] [EOL] def test_check_header_conditional ( self ) : [EOL] cmd = textwrap . dedent ( [string] ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( out , [string] ) [EOL] self . assertEqual ( config , { [string] : { } } ) [EOL] [EOL] def test_check_header_include ( self ) : [EOL] expected_test_content = textwrap . dedent ( [string] ) [EOL] [EOL] cmd = textwrap . dedent ( [string] ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd , expected_test_content = expected_test_content ) [EOL] [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : True , [string] : { [string] : True , } } ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] ) ) [EOL] [EOL] def test_check_headers_multiple ( self ) : [EOL] cmd = textwrap . dedent ( [string] ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : True , [string] : True , [string] : { [string] : True , [string] : True , } } ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] ) ) [EOL] [EOL] def test_check_headers_not_found ( self ) : [EOL] [EOL] cmd = textwrap . dedent ( [string] ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : { } } ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] ) ) [EOL] [EOL] [EOL] class TestWarningChecks ( BaseCompileChecks ) : [EOL] def get_warnings ( self ) : [EOL] return textwrap . dedent ( [string] ) [EOL] [EOL] def test_check_and_add_gcc_warning ( self ) : [EOL] for flag , expected_flags in ( ( [string] , [ [string] , [string] ] ) , ( [string] , [ [string] , [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ) : [EOL] cmd = textwrap . dedent ( [string] % flag ) + self . get_warnings ( ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd , expected_flags = expected_flags ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : [ flag ] , [string] : [ flag ] , } ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] . format ( flag = flag ) ) ) [EOL] [EOL] def test_check_and_add_gcc_warning_one ( self ) : [EOL] cmd = textwrap . dedent ( [string] ) + self . get_warnings ( ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : [ ] , [string] : [ [string] ] , } ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] ) ) [EOL] [EOL] def test_check_and_add_gcc_warning_when ( self ) : [EOL] cmd = textwrap . dedent ( [string] ) + self . get_warnings ( ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : [ ] , [string] : [ ] , } ) [EOL] self . assertEqual ( out , [string] ) [EOL] [EOL] cmd = textwrap . dedent ( [string] ) + self . get_warnings ( ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : [ ] , [string] : [ [string] ] , } ) [EOL] self . assertEqual ( out , textwrap . dedent ( [string] ) ) [EOL] [EOL] def test_add_gcc_warning ( self ) : [EOL] cmd = textwrap . dedent ( [string] ) + self . get_warnings ( ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : [ [string] ] , [string] : [ [string] ] , } ) [EOL] self . assertEqual ( out , [string] ) [EOL] [EOL] def test_add_gcc_warning_one ( self ) : [EOL] cmd = textwrap . dedent ( [string] ) + self . get_warnings ( ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : [ [string] ] , [string] : [ ] , } ) [EOL] self . assertEqual ( out , [string] ) [EOL] [EOL] def test_add_gcc_warning_when ( self ) : [EOL] cmd = textwrap . dedent ( [string] ) + self . get_warnings ( ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : [ ] , [string] : [ ] , } ) [EOL] self . assertEqual ( out , [string] ) [EOL] [EOL] cmd = textwrap . dedent ( [string] ) + self . get_warnings ( ) [EOL] [EOL] config , out , status = self . do_compile_test ( cmd ) [EOL] self . assertEqual ( status , [number] ) [EOL] self . assertEqual ( config , { [string] : [ [string] ] , [string] : [ ] , } ) [EOL] self . assertEqual ( out , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , List , Dict [EOL] import typing [EOL] import vendored [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import copy [EOL] import re [EOL] import types [EOL] import unittest [EOL] [EOL] from fnmatch import fnmatch [EOL] from StringIO import StringIO [EOL] from textwrap import dedent [EOL] [EOL] from mozunit import ( main , MockedOpen , ) [EOL] [EOL] from mozbuild . preprocessor import Preprocessor [EOL] from mozbuild . util import ReadOnlyNamespace [EOL] from mozpack import path as mozpath [EOL] [EOL] [EOL] class CompilerPreprocessor ( Preprocessor ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] VARSUBST = re . compile ( [string] , re . U ) [EOL] NON_WHITESPACE = re . compile ( [string] ) [EOL] HAS_FEATURE_OR_BUILTIN = re . compile ( [string] ) [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] Preprocessor . __init__ ( self , * args , ** kwargs ) [EOL] self . do_filter ( [string] ) [EOL] self . setMarker ( [string] ) [EOL] [EOL] def do_if ( self , expression , ** kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] context = self . context [EOL] [EOL] def normalize_numbers ( value ) : [EOL] if isinstance ( value , types . StringTypes ) : [EOL] if value [ - [number] : ] == [string] and value [ : - [number] ] . isdigit ( ) : [EOL] value = int ( value [ : - [number] ] ) [EOL] return value [EOL] [comment] [EOL] [comment] [EOL] [EOL] def normalize_has_feature_or_builtin ( expr ) : [EOL] return self . HAS_FEATURE_OR_BUILTIN . sub ( [string] , expr ) [EOL] self . context = self . Context ( ( normalize_has_feature_or_builtin ( k ) , normalize_numbers ( v ) ) for k , v in context . iteritems ( ) ) [EOL] try : [EOL] return Preprocessor . do_if ( self , normalize_has_feature_or_builtin ( expression ) , ** kwargs ) [EOL] finally : [EOL] self . context = context [EOL] [EOL] class Context ( dict ) : [EOL] def __missing__ ( self , key ) : [EOL] return None [EOL] [EOL] def filter_c_substitution ( self , line ) : [EOL] def repl ( matchobj ) : [EOL] varname = matchobj . group ( [string] ) [EOL] if varname in self . context : [EOL] result = str ( self . context [ varname ] ) [EOL] [comment] [EOL] [comment] [EOL] start , end = matchobj . span ( [string] ) [EOL] if self . NON_WHITESPACE . match ( line [ start - [number] : start ] ) : [EOL] result = [string] + result [EOL] if self . NON_WHITESPACE . match ( line [ end : end + [number] ] ) : [EOL] result = result + [string] [EOL] return result [EOL] return matchobj . group ( [number] ) [EOL] return self . VARSUBST . sub ( repl , line ) [EOL] [EOL] [EOL] class TestCompilerPreprocessor ( unittest . TestCase ) : [EOL] def test_expansion ( self ) : [EOL] pp = CompilerPreprocessor ( { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] pp . out = StringIO ( ) [EOL] input = StringIO ( [string] ) [EOL] input . name = [string] [EOL] pp . do_include ( input ) [EOL] [EOL] self . assertEquals ( pp . out . getvalue ( ) , [string] ) [EOL] [EOL] def test_condition ( self ) : [EOL] pp = CompilerPreprocessor ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] pp . out = StringIO ( ) [EOL] input = StringIO ( dedent ( [string] ) ) [EOL] input . name = [string] [EOL] pp . do_include ( input ) [EOL] [EOL] self . assertEquals ( [string] , pp . out . getvalue ( ) ) [EOL] [EOL] [EOL] class FakeCompiler ( dict ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * definitions ) : [EOL] for definition in definitions : [EOL] if all ( not isinstance ( d , dict ) for d in definition . itervalues ( ) ) : [EOL] definition = { None : definition } [EOL] for key , value in definition . iteritems ( ) : [EOL] self . setdefault ( key , { } ) . update ( value ) [EOL] [EOL] def __call__ ( self , stdin , args ) : [EOL] files = [ arg for arg in args if not arg . startswith ( [string] ) ] [EOL] flags = [ arg for arg in args if arg . startswith ( [string] ) ] [EOL] if [string] in flags : [EOL] assert len ( files ) == [number] [EOL] file = files [ [number] ] [EOL] pp = CompilerPreprocessor ( self [ None ] ) [EOL] [EOL] def apply_defn ( defn ) : [EOL] for k , v in defn . iteritems ( ) : [EOL] if v is False : [EOL] if k in pp . context : [EOL] del pp . context [ k ] [EOL] else : [EOL] pp . context [ k ] = v [EOL] [EOL] for glob , defn in self . iteritems ( ) : [EOL] if glob and not glob . startswith ( [string] ) and fnmatch ( file , glob ) : [EOL] apply_defn ( defn ) [EOL] [EOL] for flag in flags : [EOL] apply_defn ( self . get ( flag , { } ) ) [EOL] [EOL] pp . out = StringIO ( ) [EOL] pp . do_include ( file ) [EOL] return [number] , pp . out . getvalue ( ) , [string] [EOL] elif [string] in flags : [EOL] if [string] in flags : [EOL] return [number] , [string] , [string] [EOL] return [number] , [string] , [string] [EOL] [EOL] return [number] , [string] , [string] [EOL] [EOL] def __add__ ( self , other ) : [EOL] return FakeCompiler ( self , other ) [EOL] [EOL] [EOL] class TestFakeCompiler ( unittest . TestCase ) : [EOL] def test_fake_compiler ( self ) : [EOL] with MockedOpen ( { [string] : [string] , [string] : [string] , } ) : [EOL] compiler = FakeCompiler ( { [string] : [string] , [string] : [string] , } ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] [EOL] compiler = FakeCompiler ( { None : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : False , } , [string] : { [string] : [string] , } , } ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] , [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] , [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] , [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] , [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] self . assertEquals ( compiler ( None , [ [string] , [string] , [string] ] ) , ( [number] , [string] , [string] ) ) [EOL] [EOL] def test_multiple_definitions ( self ) : [EOL] compiler = FakeCompiler ( { [string] : [number] , [string] : [number] , } , { [string] : [number] , } ) [EOL] [EOL] self . assertEquals ( compiler , { None : { [string] : [number] , [string] : [number] , [string] : [number] , } , } ) [EOL] compiler = FakeCompiler ( { [string] : [number] , [string] : [number] , } , { [string] : [number] , [string] : [number] , } ) [EOL] [EOL] self . assertEquals ( compiler , { None : { [string] : [number] , [string] : [number] , [string] : [number] , } , } ) [EOL] compiler = FakeCompiler ( { [string] : [number] , [string] : [number] , } , { None : { [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , } , } ) [EOL] [EOL] self . assertEquals ( compiler , { None : { [string] : [number] , [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , } , } ) [EOL] [EOL] compiler = FakeCompiler ( { None : { [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , } , } , { [string] : { [string] : [number] , } , [string] : { [string] : [number] , } , } ) [EOL] [EOL] self . assertEquals ( compiler , { None : { [string] : [number] , [string] : [number] , } , [string] : { [string] : [number] , } , [string] : { [string] : [number] , } , } ) [EOL] [EOL] [EOL] class CompilerResult ( ReadOnlyNamespace ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , wrapper = None , compiler = [string] , version = [string] , type = [string] , language = [string] , flags = None ) : [EOL] if flags is None : [EOL] flags = [ ] [EOL] if wrapper is None : [EOL] wrapper = [ ] [EOL] super ( CompilerResult , self ) . __init__ ( flags = flags , version = version , type = type , compiler = mozpath . abspath ( compiler ) , wrapper = wrapper , language = language , ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] assert isinstance ( other , dict ) [EOL] result = copy . deepcopy ( self . __dict__ ) [EOL] for k , v in other . iteritems ( ) : [EOL] if k == [string] : [EOL] result . setdefault ( k , [ ] ) . extend ( v ) [EOL] else : [EOL] result [ k ] = v [EOL] return CompilerResult ( ** result ) [EOL] [EOL] [EOL] class TestCompilerResult ( unittest . TestCase ) : [EOL] def test_compiler_result ( self ) : [EOL] result = CompilerResult ( ) [EOL] self . assertEquals ( result . __dict__ , { [string] : [ ] , [string] : mozpath . abspath ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , } ) [EOL] [EOL] result = CompilerResult ( compiler = [string] , version = [string] , type = [string] , language = [string] , flags = [ [string] ] , ) [EOL] self . assertEquals ( result . __dict__ , { [string] : [ ] , [string] : mozpath . abspath ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } ) [EOL] [EOL] result2 = result + { [string] : [ [string] ] } [EOL] self . assertEquals ( result2 . __dict__ , { [string] : [ ] , [string] : mozpath . abspath ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , } ) [EOL] [comment] [EOL] self . assertEquals ( result . flags , [ [string] ] ) [EOL] [EOL] result3 = result + { [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] self . assertEquals ( result3 . __dict__ , { [string] : [ ] , [string] : mozpath . abspath ( [string] ) , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , } ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[None,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[None,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[None,typing.Any]$ 0 0 0 0 $typing.Dict[None,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[None,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 $typing.Any$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.CompilerPreprocessor$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.test.configure.test_toolchain_helpers.FakeCompiler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Any , List , Tuple [EOL] import typing [EOL] import vendored [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import os [EOL] import six [EOL] import sys [EOL] from collections import OrderedDict [EOL] [EOL] [EOL] def istupleofstrings ( obj ) : [EOL] return isinstance ( obj , tuple ) and len ( obj ) and all ( isinstance ( o , six . string_types ) for o in obj ) [EOL] [EOL] [EOL] class OptionValue ( tuple ) : [EOL] [docstring] [EOL] def __new__ ( cls , values = ( ) , origin = [string] ) : [EOL] return super ( OptionValue , cls ) . __new__ ( cls , values ) [EOL] [EOL] def __init__ ( self , values = ( ) , origin = [string] ) : [EOL] self . origin = origin [EOL] [EOL] def format ( self , option ) : [EOL] if option . startswith ( [string] ) : [EOL] prefix , name , values = Option . split_option ( option ) [EOL] assert values == ( ) [EOL] for prefix_set in ( ( [string] , [string] ) , ( [string] , [string] ) , ) : [EOL] if prefix in prefix_set : [EOL] prefix = prefix_set [ int ( bool ( self ) ) ] [EOL] break [EOL] if prefix : [EOL] option = [string] % ( prefix , name ) [EOL] elif self : [EOL] option = [string] % name [EOL] else : [EOL] return [string] [EOL] if len ( self ) : [EOL] return [string] % ( option , [string] . join ( self ) ) [EOL] return option [EOL] elif self and not len ( self ) : [EOL] return [string] % option [EOL] return [string] % ( option , [string] . join ( self ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not isinstance ( other , tuple ) and len ( self ) : [EOL] raise TypeError ( [string] [string] [string] % ( type ( other ) . __name__ , type ( self ) . __name__ ) ) [EOL] [EOL] [comment] [EOL] if type ( other ) == tuple : [EOL] return tuple . __eq__ ( self , other ) [EOL] elif isinstance ( other , bool ) : [EOL] return bool ( self ) == other [EOL] [comment] [EOL] elif type ( other ) != type ( self ) : [EOL] return False [EOL] else : [EOL] return super ( OptionValue , self ) . __eq__ ( other ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , super ( OptionValue , self ) . __repr__ ( ) ) [EOL] [EOL] @ staticmethod def from_ ( value ) : [EOL] if isinstance ( value , OptionValue ) : [EOL] return value [EOL] elif value is True : [EOL] return PositiveOptionValue ( ) [EOL] elif value is False or value == ( ) : [EOL] return NegativeOptionValue ( ) [EOL] elif isinstance ( value , six . string_types ) : [EOL] return PositiveOptionValue ( ( value , ) ) [EOL] elif isinstance ( value , tuple ) : [EOL] return PositiveOptionValue ( value ) [EOL] else : [EOL] raise TypeError ( [string] % type ( value ) . __name__ ) [EOL] [EOL] [EOL] class PositiveOptionValue ( OptionValue ) : [EOL] [docstring] [EOL] [EOL] def __nonzero__ ( self ) : [EOL] return True [EOL] [EOL] [EOL] class NegativeOptionValue ( OptionValue ) : [EOL] [docstring] [EOL] def __new__ ( cls , origin = [string] ) : [EOL] return super ( NegativeOptionValue , cls ) . __new__ ( cls , origin = origin ) [EOL] [EOL] def __init__ ( self , origin = [string] ) : [EOL] return super ( NegativeOptionValue , self ) . __init__ ( origin = origin ) [EOL] [EOL] [EOL] class InvalidOptionError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class ConflictingOptionError ( InvalidOptionError ) : [EOL] def __init__ ( self , message , ** format_data ) : [EOL] if format_data : [EOL] message = message . format ( ** format_data ) [EOL] super ( ConflictingOptionError , self ) . __init__ ( message ) [EOL] for k , v in six . iteritems ( format_data ) : [EOL] setattr ( self , k , v ) [EOL] [EOL] [EOL] class Option ( object ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , name = None , env = None , nargs = None , default = None , possible_origins = None , choices = None , help = None ) : [EOL] if not name and not env : [EOL] raise InvalidOptionError ( [string] [string] ) [EOL] if name : [EOL] if not isinstance ( name , six . string_types ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if not name . startswith ( [string] ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if [string] in name : [EOL] raise InvalidOptionError ( [string] ) [EOL] if not name . islower ( ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if env : [EOL] if not isinstance ( env , six . string_types ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if not env . isupper ( ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if nargs not in ( None , [string] , [string] , [string] ) and not ( isinstance ( nargs , int ) and nargs >= [number] ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if ( not isinstance ( default , six . string_types ) and not isinstance ( default , ( bool , type ( None ) ) ) and not istupleofstrings ( default ) ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if choices and not istupleofstrings ( choices ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if not help : [EOL] raise InvalidOptionError ( [string] ) [EOL] if possible_origins and not istupleofstrings ( possible_origins ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] self . possible_origins = possible_origins [EOL] [EOL] if name : [EOL] prefix , name , values = self . split_option ( name ) [EOL] assert values == ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if prefix : [EOL] if default is None : [EOL] default = prefix in ( [string] , [string] ) [EOL] elif default is False : [EOL] prefix = { [string] : [string] , [string] : [string] , } . get ( prefix , prefix ) [EOL] elif default is True : [EOL] prefix = { [string] : [string] , [string] : [string] , } . get ( prefix , prefix ) [EOL] else : [EOL] prefix = [string] [EOL] [EOL] self . prefix = prefix [EOL] self . name = name [EOL] self . env = env [EOL] if default in ( None , False ) : [EOL] self . default = NegativeOptionValue ( origin = [string] ) [EOL] elif isinstance ( default , tuple ) : [EOL] self . default = PositiveOptionValue ( default , origin = [string] ) [EOL] elif default is True : [EOL] self . default = PositiveOptionValue ( origin = [string] ) [EOL] else : [EOL] self . default = PositiveOptionValue ( ( default , ) , origin = [string] ) [EOL] if nargs is None : [EOL] nargs = [number] [EOL] if len ( self . default ) == [number] : [EOL] nargs = [string] [EOL] elif len ( self . default ) > [number] : [EOL] nargs = [string] [EOL] elif choices : [EOL] nargs = [number] [EOL] self . nargs = nargs [EOL] has_choices = choices is not None [EOL] if isinstance ( self . default , PositiveOptionValue ) : [EOL] if has_choices and len ( self . default ) == [number] : [EOL] raise InvalidOptionError ( [string] ) [EOL] if not self . _validate_nargs ( len ( self . default ) ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if has_choices and not all ( d in choices for d in self . default ) : [EOL] raise InvalidOptionError ( [string] % [string] . join ( [string] % c for c in choices ) ) [EOL] elif has_choices : [EOL] maxargs = self . maxargs [EOL] if len ( choices ) < maxargs and maxargs != sys . maxint : [EOL] raise InvalidOptionError ( [string] ) [EOL] self . choices = choices [EOL] self . help = help [EOL] [EOL] @ staticmethod def split_option ( option ) : [EOL] [docstring] [EOL] if not isinstance ( option , six . string_types ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] [EOL] elements = option . split ( [string] , [number] ) [EOL] name = elements [ [number] ] [EOL] values = tuple ( elements [ [number] ] . split ( [string] ) ) if len ( elements ) == [number] else ( ) [EOL] if name . startswith ( [string] ) : [EOL] name = name [ [number] : ] [EOL] if not name . islower ( ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] elements = name . split ( [string] , [number] ) [EOL] prefix = elements [ [number] ] [EOL] if len ( elements ) == [number] and prefix in ( [string] , [string] , [string] , [string] ) : [EOL] return prefix , elements [ [number] ] , values [EOL] else : [EOL] if name . startswith ( [string] ) : [EOL] raise InvalidOptionError ( [string] ) [EOL] if name . islower ( ) : [EOL] raise InvalidOptionError ( [string] % name ) [EOL] return [string] , name , values [EOL] [EOL] @ staticmethod def _join_option ( prefix , name ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if name . isupper ( ) : [EOL] assert not prefix [EOL] return name [EOL] elif prefix : [EOL] return [string] % ( prefix , name ) [EOL] return [string] % name [EOL] [EOL] @ property def option ( self ) : [EOL] if self . prefix or self . name : [EOL] return self . _join_option ( self . prefix , self . name ) [EOL] else : [EOL] return self . env [EOL] [EOL] @ property def minargs ( self ) : [EOL] if isinstance ( self . nargs , int ) : [EOL] return self . nargs [EOL] return [number] if self . nargs == [string] else [number] [EOL] [EOL] @ property def maxargs ( self ) : [EOL] if isinstance ( self . nargs , int ) : [EOL] return self . nargs [EOL] return [number] if self . nargs == [string] else sys . maxint [EOL] [EOL] def _validate_nargs ( self , num ) : [EOL] minargs , maxargs = self . minargs , self . maxargs [EOL] return num >= minargs and num <= maxargs [EOL] [EOL] def get_value ( self , option = None , origin = [string] ) : [EOL] [docstring] [EOL] if not option : [EOL] return self . default [EOL] [EOL] if self . possible_origins and origin not in self . possible_origins : [EOL] raise InvalidOptionError ( [string] % ( option , origin , [string] . join ( self . possible_origins ) ) ) [EOL] [EOL] prefix , name , values = self . split_option ( option ) [EOL] option = self . _join_option ( prefix , name ) [EOL] [EOL] assert name in ( self . name , self . env ) [EOL] [EOL] if prefix in ( [string] , [string] ) : [EOL] if values != ( ) : [EOL] raise InvalidOptionError ( [string] % option ) [EOL] return NegativeOptionValue ( origin = origin ) [EOL] [EOL] if name == self . env : [EOL] if values == ( [string] , ) : [EOL] return NegativeOptionValue ( origin = origin ) [EOL] if self . nargs in ( [number] , [string] , [string] ) and values == ( [string] , ) : [EOL] return PositiveOptionValue ( origin = origin ) [EOL] [EOL] values = PositiveOptionValue ( values , origin = origin ) [EOL] [EOL] if not self . _validate_nargs ( len ( values ) ) : [EOL] raise InvalidOptionError ( [string] % ( option , { [string] : [string] , [string] : [string] , [string] : [string] , } . get ( self . nargs , str ( self . nargs ) ) , [string] if ( not isinstance ( self . nargs , int ) or self . nargs != [number] ) else [string] ) ) [EOL] [EOL] if len ( values ) and self . choices : [EOL] relative_result = None [EOL] for val in values : [EOL] if self . nargs in ( [string] , [string] ) : [EOL] if val . startswith ( ( [string] , [string] ) ) : [EOL] if relative_result is None : [EOL] relative_result = list ( self . default ) [EOL] sign = val [ [number] ] [EOL] val = val [ [number] : ] [EOL] if sign == [string] : [EOL] if val not in relative_result : [EOL] relative_result . append ( val ) [EOL] else : [EOL] try : [EOL] relative_result . remove ( val ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] if val not in self . choices : [EOL] raise InvalidOptionError ( [string] % ( val , [string] . join ( [string] % c for c in self . choices ) ) ) [EOL] [EOL] if relative_result is not None : [EOL] values = PositiveOptionValue ( relative_result , origin = origin ) [EOL] [EOL] return values [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . option ) [EOL] [EOL] [EOL] class CommandLineHelper ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , environ = os . environ , argv = sys . argv ) : [EOL] self . _environ = dict ( environ ) [EOL] self . _args = OrderedDict ( ) [EOL] self . _extra_args = OrderedDict ( ) [EOL] self . _origins = { } [EOL] self . _last = [number] [EOL] [EOL] assert ( argv and not argv [ [number] ] . startswith ( [string] ) ) [EOL] for arg in argv [ [number] : ] : [EOL] self . add ( arg , [string] , self . _args ) [EOL] [EOL] def add ( self , arg , origin = [string] , args = None ) : [EOL] assert origin != [string] [EOL] prefix , name , values = Option . split_option ( arg ) [EOL] if args is None : [EOL] args = self . _extra_args [EOL] if args is self . _extra_args and name in self . _extra_args : [EOL] old_arg = self . _extra_args [ name ] [ [number] ] [EOL] old_prefix , _ , old_values = Option . split_option ( old_arg ) [EOL] if prefix != old_prefix or values != old_values : [EOL] raise ConflictingOptionError ( [string] [string] , arg = arg , origin = origin , old_arg = old_arg , old_origin = self . _origins [ old_arg ] ) [EOL] self . _last += [number] [EOL] args [ name ] = arg , self . _last [EOL] self . _origins [ arg ] = origin [EOL] [EOL] def _prepare ( self , option , args ) : [EOL] arg = None [EOL] origin = [string] [EOL] from_name = args . get ( option . name ) [EOL] from_env = args . get ( option . env ) [EOL] if from_name and from_env : [EOL] arg1 , pos1 = from_name [EOL] arg2 , pos2 = from_env [EOL] arg , pos = ( arg1 , pos1 ) if abs ( pos1 ) > abs ( pos2 ) else ( arg2 , pos2 ) [EOL] if args is self . _extra_args and ( option . get_value ( arg1 ) != option . get_value ( arg2 ) ) : [EOL] origin = self . _origins [ arg ] [EOL] old_arg = arg2 if abs ( pos1 ) > abs ( pos2 ) else arg1 [EOL] raise ConflictingOptionError ( [string] [string] , arg = arg , origin = origin , old_arg = old_arg , old_origin = self . _origins [ old_arg ] ) [EOL] elif from_name or from_env : [EOL] arg , pos = from_name if from_name else from_env [EOL] elif option . env and args is self . _args : [EOL] env = self . _environ . get ( option . env ) [EOL] if env is not None : [EOL] arg = [string] % ( option . env , env ) [EOL] origin = [string] [EOL] [EOL] origin = self . _origins . get ( arg , origin ) [EOL] [EOL] for k in ( option . name , option . env ) : [EOL] try : [EOL] del args [ k ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] return arg , origin [EOL] [EOL] def handle ( self , option ) : [EOL] [docstring] [EOL] assert isinstance ( option , Option ) [EOL] [EOL] arg , origin = self . _prepare ( option , self . _args ) [EOL] ret = option . get_value ( arg , origin ) [EOL] [EOL] extra_arg , extra_origin = self . _prepare ( option , self . _extra_args ) [EOL] extra_ret = option . get_value ( extra_arg , extra_origin ) [EOL] [EOL] if extra_ret . origin == [string] : [EOL] return ret , arg [EOL] [EOL] if ret . origin != [string] and extra_ret != ret : [EOL] raise ConflictingOptionError ( [string] [string] , arg = extra_arg , origin = extra_ret . origin , old_arg = arg , old_origin = ret . origin ) [EOL] [EOL] return extra_ret , extra_arg [EOL] [EOL] def __iter__ ( self ) : [EOL] for d in ( self . _args , self . _extra_args ) : [EOL] for arg , pos in six . itervalues ( d ) : [EOL] yield arg [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Union[typing.tuple,typing.Tuple[builtins.str,...]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Union[typing.tuple,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Union[typing.tuple,typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozbuild.configure.options.PositiveOptionValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import itertools [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import dis [EOL] import inspect [EOL] import itertools [EOL] [EOL] [EOL] [comment] [EOL] def accumulate ( iterable ) : [EOL] t = [number] [EOL] for i in iterable : [EOL] t += i [EOL] yield t [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def disassemble_as_iter ( co ) : [EOL] if inspect . ismethod ( co ) : [EOL] co = co . im_func [EOL] if inspect . isfunction ( co ) : [EOL] co = co . func_code [EOL] code = co . co_code [EOL] n = len ( code ) [EOL] i = [number] [EOL] extended_arg = [number] [EOL] free = None [EOL] line = [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] lnotab = itertools . chain ( itertools . izip ( accumulate ( ord ( c ) for c in co . co_lnotab [ [number] : : [number] ] ) , accumulate ( ord ( c ) for c in co . co_lnotab [ [number] : : [number] ] ) ) , ( None , ) ) [EOL] next_byte_line = lnotab . next ( ) [EOL] while i < n : [EOL] while next_byte_line and i >= next_byte_line [ [number] ] : [EOL] line = next_byte_line [ [number] ] [EOL] next_byte_line = lnotab . next ( ) [EOL] c = code [ i ] [EOL] op = ord ( c ) [EOL] opname = dis . opname [ op ] [EOL] i += [number] [EOL] if op >= dis . HAVE_ARGUMENT : [EOL] arg = ord ( code [ i ] ) + ord ( code [ i + [number] ] ) * [number] + extended_arg [EOL] extended_arg = [number] [EOL] i += [number] [EOL] if op == dis . EXTENDED_ARG : [EOL] extended_arg = arg * [number] [EOL] continue [EOL] if op in dis . hasconst : [EOL] yield opname , co . co_consts [ arg ] , line [EOL] elif op in dis . hasname : [EOL] yield opname , co . co_names [ arg ] , line [EOL] elif op in dis . hasjrel : [EOL] yield opname , i + arg , line [EOL] elif op in dis . haslocal : [EOL] yield opname , co . co_varnames [ arg ] , line [EOL] elif op in dis . hascompare : [EOL] yield opname , dis . cmp_op [ arg ] , line [EOL] elif op in dis . hasfree : [EOL] if free is None : [EOL] free = co . co_cellvars + co . co_freevars [EOL] yield opname , free [ arg ] , line [EOL] else : [EOL] yield opname , None , line [EOL] else : [EOL] yield opname , None , line [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Pattern [EOL] import subprocess [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import os [EOL] import subprocess [EOL] import re [EOL] [EOL] re_for_ld = re . compile ( [string] ) [EOL] [EOL] [EOL] def parse_readelf_line ( x ) : [EOL] [docstring] [EOL] return x . split ( [string] ) [ - [number] ] . split ( [string] ) [ - [number] ] . strip ( ) [EOL] [EOL] [EOL] def parse_ld_line ( x ) : [EOL] [docstring] [EOL] t = re_for_ld . match ( x ) [EOL] if t : [EOL] return t . groups ( ) [ [number] ] . strip ( ) [EOL] return x . strip ( ) [EOL] [EOL] [EOL] def split_ver ( v ) : [EOL] [docstring] [EOL] return [ int ( x ) for x in v . split ( [string] ) ] [EOL] [EOL] [EOL] def cmp_ver ( a , b ) : [EOL] [docstring] [EOL] for ( i , j ) in zip ( split_ver ( a ) , split_ver ( b ) ) : [EOL] if i != j : [EOL] return i - j [EOL] return [number] [EOL] [EOL] [EOL] def encode_ver ( v ) : [EOL] [docstring] [EOL] t = split_ver ( v ) [EOL] return t [ [number] ] << [number] | t [ [number] ] << [number] | t [ [number] ] [EOL] [EOL] [EOL] def find_version ( args ) : [EOL] [docstring] [EOL] args += [ [string] , [string] ] [EOL] p = subprocess . Popen ( args , stderr = subprocess . STDOUT , stdout = subprocess . PIPE ) [EOL] candidates = [ x for x in p . stdout if [string] in x ] [EOL] candidates = [ x for x in candidates if [string] not in x ] [EOL] if not candidates : [EOL] raise Exception ( [string] % args ) [EOL] if len ( candidates ) != [number] : [EOL] raise Exception ( [string] % ( args , [string] . join ( candidates ) ) ) [EOL] [EOL] libstdcxx = parse_ld_line ( candidates [ - [number] ] ) [EOL] [EOL] p = subprocess . Popen ( [ [string] , [string] , libstdcxx ] , stdout = subprocess . PIPE ) [EOL] versions = [ parse_readelf_line ( x ) for x in p . stdout . readlines ( ) if [string] in x ] [EOL] last_version = sorted ( versions , cmp = cmp_ver ) [ - [number] ] [EOL] return ( last_version , encode_ver ( last_version ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [docstring] [EOL] cxx_env = os . environ [ [string] ] [EOL] print ( [string] % find_version ( cxx_env . split ( ) ) [ [number] ] ) [EOL] host_cxx_env = os . environ . get ( [string] , cxx_env ) [EOL] print ( [string] % find_version ( host_cxx_env . split ( ) ) [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import sys [EOL] [EOL] import buildconfig [EOL] [EOL] [EOL] def main ( ) : [EOL] print ( [string] ) [EOL] sys . path . insert ( [number] , buildconfig . topsrcdir ) [EOL] import manifestupdate [EOL] return [number] if manifestupdate . run ( buildconfig . topsrcdir , buildconfig . topobjdir ) else [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import argparse [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import argparse [EOL] import shutil [EOL] import sys [EOL] import os [EOL] [EOL] from mozbuild . util import ( ensureParentDir , ) [EOL] [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( argv ) [EOL] [EOL] from compare_locales . compare import ( ContentComparer , Observer , ) [EOL] from compare_locales . paths import ( File , ) [EOL] cc = ContentComparer ( [ Observer ( ) ] ) [EOL] cc . compare ( File ( args . ref_file , args . ref_file , [string] ) , File ( args . l10n_file , args . l10n_file , [string] ) , args . output ) [EOL] [EOL] ensureParentDir ( args . output ) [EOL] if not os . path . exists ( args . output ) : [EOL] src = args . l10n_file [EOL] if not os . path . exists ( args . l10n_file ) : [EOL] src = args . ref_file [EOL] shutil . copy ( src , args . output ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import sys [EOL] [EOL] import mozbuild . jar [EOL] [EOL] [EOL] def main ( args ) : [EOL] return mozbuild . jar . main ( args ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Set , Any , Union , Dict , List [EOL] import typing [EOL] import argparse [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import argparse [EOL] import itertools [EOL] import os [EOL] import sys [EOL] import time [EOL] [EOL] from manifestparser import TestManifest [EOL] from reftest import ReftestManifest [EOL] [EOL] from mozbuild . util import ensureParentDir [EOL] from mozpack . archive import create_tar_gz_from_files [EOL] from mozpack . copier import FileRegistry [EOL] from mozpack . files import ExistingFile , FileFinder [EOL] from mozpack . manifests import InstallManifest [EOL] from mozpack . mozjar import JarWriter [EOL] import mozpack . path as mozpath [EOL] [EOL] import buildconfig [EOL] [EOL] STAGE = mozpath . join ( buildconfig . topobjdir , [string] , [string] ) [EOL] [EOL] TEST_HARNESS_BINS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] TEST_HARNESS_DLLS = [ [string] , [string] ] [EOL] [EOL] TEST_PLUGIN_DLLS = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] TEST_PLUGIN_DIRS = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] GMP_TEST_PLUGIN_DIRS = [ [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] OBJDIR_TEST_FILES = { [string] : { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , } , } [EOL] [EOL] [EOL] ARCHIVE_FILES = { [string] : [ { [string] : STAGE , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , ] , [string] : [string] , [string] : [ [string] , [string] , [string] , ] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [ [string] , [string] , [string] ] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [ [string] , ] } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [ [string] % ( f , buildconfig . substs [ [string] ] ) for f in TEST_HARNESS_BINS ] + [ [string] % ( buildconfig . substs [ [string] ] , f , buildconfig . substs [ [string] ] ) for f in TEST_HARNESS_DLLS ] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [ [string] % ( buildconfig . substs [ [string] ] , f , buildconfig . substs [ [string] ] ) for f in TEST_PLUGIN_DLLS ] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : TEST_PLUGIN_DIRS , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : GMP_TEST_PLUGIN_DIRS , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , ] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [ [string] , [string] , [string] , ] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [ [string] % buildconfig . substs [ [string] ] , ] , [string] : [string] , } , ] , [string] : [ { [string] : STAGE , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , [string] : [ { [string] : STAGE , [string] : [string] , [string] : [string] , } , ] , [string] : [ OBJDIR_TEST_FILES [ [string] ] , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , } , { [string] : STAGE , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] } , ] , [string] : [ { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , [string] : [ { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [ [string] , [string] , ] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] } , ] , [string] : [ { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , [string] : [ { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , [string] : [ { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , } , ] , [string] : [ { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , [string] : [ OBJDIR_TEST_FILES [ [string] ] , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [string] , } , { [string] : STAGE , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , [string] : [ { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [string] , [string] : [string] , } , ] , } [EOL] [EOL] if buildconfig . substs . get ( [string] ) : [EOL] ARCHIVE_FILES [ [string] ] . append ( { [string] : buildconfig . topsrcdir , [string] : [string] , [string] : [ [string] , [string] , ] , } ) [EOL] [EOL] [EOL] if buildconfig . substs . get ( [string] ) and buildconfig . substs . get ( [string] ) : [EOL] asan_dll = { [string] : buildconfig . topobjdir , [string] : [string] , [string] : os . path . basename ( buildconfig . substs [ [string] ] ) , [string] : [string] } [EOL] ARCHIVE_FILES [ [string] ] . append ( asan_dll ) [EOL] [EOL] [EOL] if buildconfig . substs . get ( [string] ) : [EOL] commtopsrcdir = buildconfig . substs . get ( [string] ) [EOL] mozharness_comm = { [string] : commtopsrcdir , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] ARCHIVE_FILES [ [string] ] . append ( mozharness_comm ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for k , v in ARCHIVE_FILES . items ( ) : [EOL] [comment] [EOL] if k in ( [string] , [string] ) : [EOL] continue [EOL] [EOL] ignores = set ( itertools . chain ( * ( e . get ( [string] , [ ] ) for e in ARCHIVE_FILES [ [string] ] ) ) ) [EOL] [EOL] if not any ( p . startswith ( [string] % k ) for p in ignores ) : [EOL] raise Exception ( [string] % k ) [EOL] [EOL] [EOL] def find_generated_harness_files ( ) : [EOL] [comment] [EOL] [comment] [EOL] manifest = InstallManifest ( mozpath . join ( buildconfig . topobjdir , [string] , [string] , [string] ) ) [EOL] registry = FileRegistry ( ) [EOL] manifest . populate_registry ( registry ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [ mozpath . join ( [string] , p ) for p in registry . paths ( ) if isinstance ( registry [ p ] , ExistingFile ) ] [EOL] [EOL] [EOL] def find_files ( archive ) : [EOL] extra_entries = [ ] [EOL] generated_harness_files = find_generated_harness_files ( ) [EOL] [EOL] if archive == [string] : [EOL] [comment] [EOL] [comment] [EOL] packaged_paths = set ( ) [EOL] for entry in OBJDIR_TEST_FILES . values ( ) : [EOL] pat = mozpath . join ( entry [ [string] ] , entry [ [string] ] ) [EOL] del entry [ [string] ] [EOL] patterns = [ ] [EOL] for path in generated_harness_files : [EOL] if mozpath . match ( path , pat ) : [EOL] patterns . append ( path [ len ( entry [ [string] ] ) + [number] : ] ) [EOL] packaged_paths . add ( path ) [EOL] if patterns : [EOL] entry [ [string] ] = patterns [EOL] extra_entries . append ( entry ) [EOL] entry = { [string] : buildconfig . topobjdir , [string] : [string] , [string] : [ ] , } [EOL] for path in set ( generated_harness_files ) - packaged_paths : [EOL] entry [ [string] ] . append ( path [ len ( [string] ) + [number] : ] ) [EOL] extra_entries . append ( entry ) [EOL] [EOL] for entry in ARCHIVE_FILES [ archive ] + extra_entries : [EOL] source = entry [ [string] ] [EOL] dest = entry . get ( [string] ) [EOL] base = entry . get ( [string] , [string] ) [EOL] [EOL] pattern = entry . get ( [string] ) [EOL] patterns = entry . get ( [string] , [ ] ) [EOL] if pattern : [EOL] patterns . append ( pattern ) [EOL] [EOL] manifest = entry . get ( [string] ) [EOL] manifests = entry . get ( [string] , [ ] ) [EOL] if manifest : [EOL] manifests . append ( manifest ) [EOL] if manifests : [EOL] dirs = find_manifest_dirs ( buildconfig . topsrcdir , manifests ) [EOL] patterns . extend ( { [string] . format ( d ) for d in dirs } ) [EOL] [EOL] ignore = list ( entry . get ( [string] , [ ] ) ) [EOL] ignore . extend ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] if archive not in ( [string] , [string] ) and base . startswith ( [string] ) : [EOL] [comment] [EOL] for path in generated_harness_files : [EOL] if path . startswith ( base ) : [EOL] ignore . append ( path [ len ( base ) + [number] : ] ) [EOL] [EOL] common_kwargs = { [string] : True , [string] : ignore , } [EOL] [EOL] finder = FileFinder ( os . path . join ( source , base ) , ** common_kwargs ) [EOL] [EOL] for pattern in patterns : [EOL] for p , f in finder . find ( pattern ) : [EOL] if dest : [EOL] p = mozpath . join ( dest , p ) [EOL] yield p , f [EOL] [EOL] [EOL] def find_manifest_dirs ( topsrcdir , manifests ) : [EOL] [docstring] [EOL] dirs = set ( ) [EOL] [EOL] for p in manifests : [EOL] p = os . path . join ( topsrcdir , p ) [EOL] [EOL] if p . endswith ( [string] ) : [EOL] test_manifest = TestManifest ( ) [EOL] test_manifest . read ( p ) [EOL] dirs |= set ( [ os . path . dirname ( m ) for m in test_manifest . manifests ( ) ] ) [EOL] [EOL] elif p . endswith ( [string] ) : [EOL] m = ReftestManifest ( ) [EOL] m . load ( p ) [EOL] dirs |= m . dirs [EOL] [EOL] else : [EOL] raise Exception ( [string] . format ( os . path . splitext ( p ) [ [number] ] ) ) [EOL] [EOL] dirs = { mozpath . normpath ( d [ len ( topsrcdir ) : ] ) . lstrip ( [string] ) for d in dirs } [EOL] [EOL] [comment] [EOL] [comment] [EOL] def parents ( p ) : [EOL] while True : [EOL] p = mozpath . dirname ( p ) [EOL] if not p : [EOL] break [EOL] yield p [EOL] [EOL] seen = set ( ) [EOL] for d in sorted ( dirs , key = len ) : [EOL] if not any ( p in seen for p in parents ( d ) ) : [EOL] seen . add ( d ) [EOL] [EOL] return sorted ( seen ) [EOL] [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( argv ) [EOL] [EOL] out_file = args . outputfile [EOL] if not out_file . endswith ( ( [string] , [string] ) ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] file_count = [number] [EOL] t_start = time . time ( ) [EOL] ensureParentDir ( out_file ) [EOL] res = find_files ( args . archive ) [EOL] with open ( out_file , [string] ) as fh : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if out_file . endswith ( [string] ) : [EOL] files = dict ( res ) [EOL] create_tar_gz_from_files ( fh , files , compresslevel = [number] ) [EOL] file_count = len ( files ) [EOL] elif out_file . endswith ( [string] ) : [EOL] with JarWriter ( fileobj = fh , compress_level = [number] ) as writer : [EOL] for p , f in res : [EOL] writer . add ( p . encode ( [string] ) , f . read ( ) , mode = f . mode , skip_duplicates = True ) [EOL] file_count += [number] [EOL] else : [EOL] raise Exception ( [string] % out_file ) [EOL] [EOL] duration = time . time ( ) - t_start [EOL] zip_size = os . path . getsize ( args . outputfile ) [EOL] basename = os . path . basename ( args . outputfile ) [EOL] print ( [string] % ( file_count , zip_size , basename , duration ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Any , Union , Dict , List [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import argparse [EOL] import copy [EOL] import errno [EOL] import json [EOL] import sys [EOL] import os [EOL] [EOL] from mozbuild . dotproperties import ( DotProperties , ) [EOL] from mozpack . files import ( FileFinder , ) [EOL] [EOL] [EOL] def merge_properties ( paths ) : [EOL] [docstring] [EOL] properties = DotProperties ( ) [EOL] for path in paths : [EOL] try : [EOL] properties . update ( path ) [EOL] except IOError as e : [EOL] if e . errno == errno . ENOENT : [EOL] [comment] [EOL] continue [EOL] return properties [EOL] [EOL] [EOL] def main ( output , * args , ** kwargs ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , default = False , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , default = False , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , nargs = [string] , help = [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parser . add_argument ( [string] , required = True , help = [string] ) [EOL] opts = parser . parse_args ( args ) [EOL] [EOL] [comment] [EOL] if not os . path . isfile ( opts . fallback ) : [EOL] print ( [string] . format ( fallback = opts . fallback ) ) [EOL] return [number] [EOL] [EOL] [comment] [EOL] sources = [ opts . fallback ] + list ( reversed ( opts . inputs ) ) [EOL] properties = merge_properties ( sources ) [EOL] [EOL] [comment] [EOL] image_url_template = [string] % opts . android_package_name [EOL] drawables_template = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] sites = [ ] [EOL] [EOL] def add_names ( names , defaults = { } ) : [EOL] for name in names : [EOL] site = copy . deepcopy ( defaults ) [EOL] site . update ( properties . get_dict ( [string] . format ( name = name ) , required_keys = ( [string] , [string] , [string] ) ) ) [EOL] site [ [string] ] = image_url_template . format ( name = name ) [EOL] sites . append ( site ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not opts . resources : [EOL] continue [EOL] resources = os . path . abspath ( opts . resources ) [EOL] finder = FileFinder ( resources ) [EOL] matches = [ p for p , _ in finder . find ( drawables_template . format ( name = name ) ) ] [EOL] if not matches : [EOL] raise Exception ( [string] . format ( resources = resources , name = name ) ) [EOL] else : [EOL] if opts . verbose : [EOL] print ( [string] . format ( len = len ( matches ) , resources = resources , name = name , matches = matches ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] lists = [ ( [string] , { } ) , ( [string] , { [string] : True } ) , ] [EOL] if opts . verbose : [EOL] print ( [string] . format ( len = len ( lists ) , lists = [ list_name for list_name , _ in lists ] ) ) [EOL] [EOL] for ( list_name , list_item_defaults ) in lists : [EOL] names = properties . get_list ( list_name ) [EOL] if opts . verbose : [EOL] print ( [string] . format ( len = len ( names ) , list = list_name , names = names ) ) [EOL] add_names ( names , list_item_defaults ) [EOL] [EOL] [comment] [EOL] if not sites : [EOL] print ( [string] . format ( sources ) ) [EOL] return [number] [EOL] [EOL] json . dump ( sites , output ) [EOL] existed , updated = output . close ( ) [comment] [EOL] [EOL] if not opts . silent : [EOL] if updated : [EOL] print ( [string] . format ( output = os . path . abspath ( output . name ) ) ) [EOL] else : [EOL] print ( [string] . format ( output = os . path . abspath ( output . name ) ) ) [EOL] [EOL] return set ( [ opts . fallback ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Any , Union [EOL] import typing [EOL] import argparse [EOL] import typing_extensions [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import argparse [EOL] import os [EOL] import sys [EOL] import time [EOL] [EOL] from mozpack . copier import ( FileCopier , FileRegistry , ) [EOL] from mozpack . files import ( BaseFile , FileFinder , ) [EOL] from mozpack . manifests import ( InstallManifest , ) [EOL] from mozbuild . util import DefinesAction [EOL] [EOL] [EOL] COMPLETE = [string] [string] [string] [EOL] [EOL] [EOL] def process_manifest ( destdir , paths , track , no_symlinks = False , defines = { } ) : [EOL] [EOL] if os . path . exists ( track ) : [EOL] [comment] [EOL] [comment] [EOL] manifest = InstallManifest ( path = track ) [EOL] remove_unaccounted = FileRegistry ( ) [EOL] dummy_file = BaseFile ( ) [EOL] [EOL] finder = FileFinder ( destdir , find_dotfiles = True ) [EOL] for dest in manifest . _dests : [EOL] for p , f in finder . find ( dest ) : [EOL] remove_unaccounted . add ( p , dummy_file ) [EOL] [EOL] remove_empty_directories = True [EOL] remove_all_directory_symlinks = True [EOL] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] remove_unaccounted = False [EOL] remove_empty_directories = False [EOL] remove_all_directory_symlinks = False [EOL] [EOL] manifest = InstallManifest ( ) [EOL] for path in paths : [EOL] manifest |= InstallManifest ( path = path ) [EOL] [EOL] copier = FileCopier ( ) [EOL] link_policy = [string] if no_symlinks else [string] [EOL] manifest . populate_registry ( copier , defines_override = defines , link_policy = link_policy ) [EOL] result = copier . copy ( destdir , remove_unaccounted = remove_unaccounted , remove_all_directory_symlinks = remove_all_directory_symlinks , remove_empty_directories = remove_empty_directories ) [EOL] [EOL] if track : [EOL] [comment] [EOL] [comment] [EOL] manifest . write ( path = track , expand_pattern = True ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , action = DefinesAction , dest = [string] , metavar = [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( argv ) [EOL] [EOL] start = time . time ( ) [EOL] [EOL] result = process_manifest ( args . destdir , args . manifests , track = args . track , no_symlinks = args . no_symlinks , defines = args . defines ) [EOL] [EOL] elapsed = time . time ( ) - start [EOL] [EOL] print ( COMPLETE . format ( elapsed = elapsed , dest = args . destdir , existing = result . existing_files_count , updated = result . updated_files_count , rm_files = result . removed_files_count , rm_dirs = result . removed_directories_count ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] import sys [EOL] import subprocess [EOL] [EOL] [EOL] def make_unzip ( package ) : [EOL] subprocess . check_call ( [ [string] , package ] ) [EOL] [EOL] [EOL] def main ( args ) : [EOL] if len ( args ) != [number] : [EOL] print ( [string] , file = sys . stderr ) [EOL] return [number] [EOL] else : [EOL] make_unzip ( args [ [number] ] ) [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Match , Set , Pattern , Optional , Any [EOL] import typing [EOL] import argparse [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import argparse [EOL] import os [EOL] import re [EOL] import sys [EOL] from buildconfig import topsrcdir , topobjdir [EOL] from mozbuild . backend . configenvironment import PartialConfigEnvironment [EOL] import mozpack . path as mozpath [EOL] [EOL] [EOL] def process_define_file ( output , input ) : [EOL] [docstring] [EOL] [EOL] path = os . path . abspath ( input ) [EOL] [EOL] config = PartialConfigEnvironment ( topobjdir ) [EOL] [EOL] if mozpath . basedir ( path , [ mozpath . join ( topsrcdir , [string] ) ] ) and not config . substs . get ( [string] ) : [EOL] config = PartialConfigEnvironment ( mozpath . join ( topobjdir , [string] , [string] ) ) [EOL] [EOL] with open ( path , [string] ) as input : [EOL] r = re . compile ( [string] , re . U ) [EOL] for l in input : [EOL] m = r . match ( l ) [EOL] if m : [EOL] cmd = m . group ( [string] ) [EOL] name = m . group ( [string] ) [EOL] value = m . group ( [string] ) [EOL] if name : [EOL] if name == [string] : [EOL] if cmd == [string] : [EOL] raise Exception ( [string] [string] ) [EOL] [EOL] def define_for_name ( name , val ) : [EOL] [docstring] [EOL] define = [string] . format ( name = name , val = val ) [EOL] if name in ( [string] , [string] ) : [EOL] return [string] . format ( name = name , define = define ) [EOL] return define [EOL] defines = [string] . join ( sorted ( define_for_name ( name , val ) for name , val in config . defines [ [string] ] . iteritems ( ) ) ) [EOL] l = l [ : m . start ( [string] ) - [number] ] + defines + l [ m . end ( [string] ) : ] [EOL] elif cmd == [string] : [EOL] if value and name in config . defines : [EOL] l = l [ : m . start ( [string] ) ] + str ( config . defines [ name ] ) + l [ m . end ( [string] ) : ] [EOL] elif cmd == [string] : [EOL] if name in config . defines : [EOL] l = l [ : m . start ( [string] ) ] + [string] + l [ m . end ( [string] ) : m . end ( [string] ) ] + [string] + str ( config . defines [ name ] ) + l [ m . end ( [string] ) : ] [EOL] else : [EOL] l = [string] + l [ : m . end ( [string] ) ] + [string] + l [ m . end ( [string] ) : ] [EOL] [EOL] output . write ( l ) [EOL] [EOL] deps = { path } [EOL] deps . update ( config . get_dependencies ( ) ) [EOL] return deps [EOL] [EOL] [EOL] def main ( argv ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( argv ) [EOL] [EOL] return process_define_file ( sys . stdout , args . input ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv [ [number] : ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set , List [EOL] import subprocess [EOL] import typing [EOL] from __future__ import absolute_import , print_function [EOL] [EOL] [docstring] [EOL] [EOL] import errno [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] [EOL] from mozfile . mozfile import remove as mozfileremove [EOL] from textwrap import TextWrapper [EOL] [EOL] [EOL] CLOBBER_MESSAGE = [string] . join ( [ TextWrapper ( ) . fill ( line ) + [string] for line in [string] . splitlines ( ) ] ) [EOL] [EOL] [EOL] class Clobberer ( object ) : [EOL] def __init__ ( self , topsrcdir , topobjdir ) : [EOL] [docstring] [EOL] assert os . path . isabs ( topsrcdir ) [EOL] assert os . path . isabs ( topobjdir ) [EOL] [EOL] self . topsrcdir = os . path . normpath ( topsrcdir ) [EOL] self . topobjdir = os . path . normpath ( topobjdir ) [EOL] self . src_clobber = os . path . join ( topsrcdir , [string] ) [EOL] self . obj_clobber = os . path . join ( topobjdir , [string] ) [EOL] [EOL] [comment] [EOL] if not os . path . isfile ( self . src_clobber ) : [EOL] self . src_clobber = os . path . join ( topsrcdir , [string] , [string] ) [EOL] [EOL] assert os . path . isfile ( self . src_clobber ) [EOL] [EOL] def clobber_needed ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if not os . path . exists ( self . obj_clobber ) : [EOL] return False [EOL] [EOL] [comment] [EOL] if os . path . getmtime ( self . src_clobber ) <= os . path . getmtime ( self . obj_clobber ) : [EOL] [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def clobber_cause ( self ) : [EOL] [docstring] [EOL] with open ( self . src_clobber , [string] ) as fh : [EOL] lines = [ l . strip ( ) for l in fh . readlines ( ) ] [EOL] return [ l for l in lines if l and not l . startswith ( [string] ) ] [EOL] [EOL] def have_winrm ( self ) : [EOL] [comment] [EOL] try : [EOL] p = subprocess . Popen ( [ [string] , [string] ] , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) [EOL] return p . wait ( ) == [number] and p . stdout . read ( ) . startswith ( [string] ) [EOL] except Exception : [EOL] return False [EOL] [EOL] def remove_objdir ( self , full = True ) : [EOL] [docstring] [EOL] [comment] [EOL] no_clobber = { [string] , [string] , } [EOL] [EOL] if full : [EOL] [comment] [EOL] paths = [ self . topobjdir . encode ( [string] ) ] [EOL] else : [EOL] try : [EOL] paths = [ ] [EOL] for p in os . listdir ( self . topobjdir ) : [EOL] if p not in no_clobber : [EOL] paths . append ( os . path . join ( self . topobjdir , p ) . encode ( [string] ) ) [EOL] except OSError as e : [EOL] if e . errno != errno . ENOENT : [EOL] raise [EOL] return [EOL] [EOL] procs = [ ] [EOL] for p in sorted ( paths ) : [EOL] path = os . path . join ( self . topobjdir , p ) [EOL] if sys . platform . startswith ( [string] ) and self . have_winrm ( ) and os . path . isdir ( path ) : [EOL] procs . append ( subprocess . Popen ( [ [string] , [string] , path ] ) ) [EOL] else : [EOL] [comment] [EOL] mozfileremove ( path ) [EOL] [EOL] for p in procs : [EOL] p . wait ( ) [EOL] [EOL] def ensure_objdir_state ( self ) : [EOL] [docstring] [EOL] if not os . path . exists ( self . topobjdir ) : [EOL] os . makedirs ( self . topobjdir ) [EOL] [EOL] if not os . path . exists ( self . obj_clobber ) : [EOL] [comment] [EOL] with open ( self . obj_clobber , [string] ) : [EOL] pass [EOL] [EOL] def maybe_do_clobber ( self , cwd , allow_auto = False , fh = sys . stderr ) : [EOL] [docstring] [EOL] assert cwd [EOL] cwd = os . path . normpath ( cwd ) [EOL] [EOL] if not self . clobber_needed ( ) : [EOL] print ( [string] , file = fh ) [EOL] self . ensure_objdir_state ( ) [EOL] return False , False , None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not allow_auto : [EOL] return True , False , self . _message ( [string] [string] [string] ) [EOL] [EOL] if cwd . startswith ( self . topobjdir ) and cwd != self . topobjdir : [EOL] return True , False , self . _message ( [string] ) [EOL] [EOL] objdir = self . topobjdir . encode ( [string] , [string] ) [EOL] print ( [string] % objdir , file = fh ) [EOL] try : [EOL] self . remove_objdir ( False ) [EOL] self . ensure_objdir_state ( ) [EOL] print ( [string] , file = fh ) [EOL] return True , True , None [EOL] except (IOError) as error : [EOL] return True , False , self . _message ( [string] + str ( error ) ) [EOL] [EOL] def _message ( self , reason ) : [EOL] lines = [ [string] + line for line in self . clobber_cause ( ) ] [EOL] [EOL] return CLOBBER_MESSAGE . format ( clobber_reason = [string] . join ( lines ) , no_reason = [string] + reason , clobber_file = self . obj_clobber ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import mercurial . error as error [EOL] import mercurial . hg as hg [EOL] import mercurial . ui as hgui [EOL] import six [EOL] [EOL] from . files import ( BaseFinder , MercurialFile , ) [EOL] import mozpack . path as mozpath [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class MercurialNativeFile ( MercurialFile ) : [EOL] def __init__ ( self , data ) : [EOL] self . data = data [EOL] [EOL] def read ( self ) : [EOL] return self . data [EOL] [EOL] [EOL] class MercurialNativeRevisionFinder ( BaseFinder ) : [EOL] def __init__ ( self , repo , rev = [string] , recognize_repo_paths = False ) : [EOL] [docstring] [EOL] if isinstance ( repo , six . string_types ) : [EOL] path = repo [EOL] repo = hg . repository ( hgui . ui ( ) , repo ) [EOL] else : [EOL] path = repo . root [EOL] [EOL] super ( MercurialNativeRevisionFinder , self ) . __init__ ( base = repo . root ) [EOL] [EOL] self . _repo = repo [EOL] self . _rev = rev [EOL] self . _root = mozpath . normpath ( path ) [EOL] self . _recognize_repo_paths = recognize_repo_paths [EOL] [EOL] def _find ( self , pattern ) : [EOL] if self . _recognize_repo_paths : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] return self . _find_helper ( pattern , self . _repo [ self . _rev ] , self . _get ) [EOL] [EOL] def get ( self , path ) : [EOL] if self . _recognize_repo_paths : [EOL] if not path . startswith ( self . _root ) : [EOL] raise ValueError ( [string] [string] % path ) [EOL] path = path [ len ( self . _root ) + [number] : ] [EOL] [EOL] return self . _get ( path ) [EOL] [EOL] def _get ( self , path ) : [EOL] if isinstance ( path , six . text_type ) : [EOL] path = path . encode ( [string] , [string] ) [EOL] [EOL] try : [EOL] fctx = self . _repo . filectx ( path , self . _rev ) [EOL] return MercurialNativeFile ( fctx . data ( ) ) [EOL] except error . LookupError : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type [EOL] import typing [EOL] import vendored [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import sys [EOL] from contextlib import contextmanager [EOL] [EOL] [EOL] class ErrorMessage ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AccumulatedErrors ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ErrorCollector ( object ) : [EOL] [docstring] [EOL] out = sys . stderr [EOL] WARN = [number] [EOL] ERROR = [number] [EOL] FATAL = [number] [EOL] _level = ERROR [EOL] _context = [ ] [EOL] _count = None [EOL] [EOL] def ignore_errors ( self , ignore = True ) : [EOL] if ignore : [EOL] self . _level = self . FATAL [EOL] else : [EOL] self . _level = self . ERROR [EOL] [EOL] def _full_message ( self , level , msg ) : [EOL] if level >= self . _level : [EOL] level = [string] [EOL] else : [EOL] level = [string] [EOL] if self . _context : [EOL] file , line = self . _context [ - [number] ] [EOL] return [string] % ( level , file , line , msg ) [EOL] return [string] % ( level , msg ) [EOL] [EOL] def _handle ( self , level , msg ) : [EOL] msg = self . _full_message ( level , msg ) [EOL] if level >= self . _level : [EOL] if self . _count is None : [EOL] raise ErrorMessage ( msg ) [EOL] self . _count += [number] [EOL] print ( msg , file = self . out ) [EOL] [EOL] def fatal ( self , msg ) : [EOL] self . _handle ( self . FATAL , msg ) [EOL] [EOL] def error ( self , msg ) : [EOL] self . _handle ( self . ERROR , msg ) [EOL] [EOL] def warn ( self , msg ) : [EOL] self . _handle ( self . WARN , msg ) [EOL] [EOL] def get_context ( self ) : [EOL] if self . _context : [EOL] return self . _context [ - [number] ] [EOL] [EOL] @ contextmanager def context ( self , file , line ) : [EOL] if file and line : [EOL] self . _context . append ( ( file , line ) ) [EOL] yield [EOL] if file and line : [EOL] self . _context . pop ( ) [EOL] [EOL] @ contextmanager def accumulate ( self ) : [EOL] assert self . _count is None [EOL] self . _count = [number] [EOL] yield [EOL] count = self . _count [EOL] self . _count = None [EOL] if count : [EOL] raise AccumulatedErrors ( ) [EOL] [EOL] @ property def count ( self ) : [EOL] [comment] [EOL] return self . _count if self . _count else [number] [EOL] [EOL] [EOL] errors = ErrorCollector ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Tuple [EOL] import io [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] from contextlib import contextmanager [EOL] import json [EOL] [EOL] from . files import ( AbsoluteSymlinkFile , ExistingFile , File , FileFinder , GeneratedFile , HardlinkFile , PreprocessedFile , ) [EOL] import mozpack . path as mozpath [EOL] [EOL] [EOL] [comment] [EOL] @ contextmanager def _auto_fileobj ( path , fileobj , mode = [string] ) : [EOL] if path and fileobj : [EOL] raise AssertionError ( [string] ) [EOL] [EOL] if not path and not fileobj : [EOL] raise AssertionError ( [string] ) [EOL] [EOL] if path : [EOL] fileobj = open ( path , mode ) [EOL] [EOL] try : [EOL] yield fileobj [EOL] finally : [EOL] if path : [EOL] fileobj . close ( ) [EOL] [EOL] [EOL] class UnreadableInstallManifest ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InstallManifest ( object ) : [EOL] [docstring] [EOL] [EOL] CURRENT_VERSION = [number] [EOL] [EOL] FIELD_SEPARATOR = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] LINK = [number] [EOL] COPY = [number] [EOL] REQUIRED_EXISTS = [number] [EOL] OPTIONAL_EXISTS = [number] [EOL] PATTERN_LINK = [number] [EOL] PATTERN_COPY = [number] [EOL] PREPROCESS = [number] [EOL] CONTENT = [number] [EOL] [EOL] def __init__ ( self , path = None , fileobj = None ) : [EOL] [docstring] [EOL] self . _dests = { } [EOL] self . _source_files = set ( ) [EOL] [EOL] if path or fileobj : [EOL] with _auto_fileobj ( path , fileobj , [string] ) as fh : [EOL] self . _source_files . add ( fh . name ) [EOL] self . _load_from_fileobj ( fh ) [EOL] [EOL] def _load_from_fileobj ( self , fileobj ) : [EOL] version = fileobj . readline ( ) . rstrip ( ) [EOL] if version not in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] raise UnreadableInstallManifest ( [string] % version ) [EOL] [EOL] for line in fileobj : [EOL] line = line . rstrip ( ) [EOL] [EOL] fields = line . split ( self . FIELD_SEPARATOR ) [EOL] [EOL] record_type = int ( fields [ [number] ] ) [EOL] [EOL] if record_type == self . LINK : [EOL] dest , source = fields [ [number] : ] [EOL] self . add_link ( source , dest ) [EOL] continue [EOL] [EOL] if record_type == self . COPY : [EOL] dest , source = fields [ [number] : ] [EOL] self . add_copy ( source , dest ) [EOL] continue [EOL] [EOL] if record_type == self . REQUIRED_EXISTS : [EOL] _ , path = fields [EOL] self . add_required_exists ( path ) [EOL] continue [EOL] [EOL] if record_type == self . OPTIONAL_EXISTS : [EOL] _ , path = fields [EOL] self . add_optional_exists ( path ) [EOL] continue [EOL] [EOL] if record_type == self . PATTERN_LINK : [EOL] _ , base , pattern , dest = fields [ [number] : ] [EOL] self . add_pattern_link ( base , pattern , dest ) [EOL] continue [EOL] [EOL] if record_type == self . PATTERN_COPY : [EOL] _ , base , pattern , dest = fields [ [number] : ] [EOL] self . add_pattern_copy ( base , pattern , dest ) [EOL] continue [EOL] [EOL] if record_type == self . PREPROCESS : [EOL] dest , source , deps , marker , defines , warnings = fields [ [number] : ] [EOL] [EOL] self . add_preprocess ( source , dest , deps , marker , self . _decode_field_entry ( defines ) , silence_missing_directive_warnings = bool ( int ( warnings ) ) ) [EOL] continue [EOL] [EOL] if record_type == self . CONTENT : [EOL] dest , content = fields [ [number] : ] [EOL] [EOL] self . add_content ( self . _decode_field_entry ( content ) . encode ( [string] ) , dest ) [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if record_type >= [number] : [EOL] raise UnreadableInstallManifest ( [string] % record_type ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _dests ) [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return item in self . _dests [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , InstallManifest ) and self . _dests == other . _dests [EOL] [EOL] def __neq__ ( self , other ) : [EOL] return not self . __eq__ ( other ) [EOL] [EOL] def __ior__ ( self , other ) : [EOL] if not isinstance ( other , InstallManifest ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . add_entries_from ( other ) [EOL] [EOL] return self [EOL] [EOL] def _encode_field_entry ( self , data ) : [EOL] [docstring] [EOL] return json . dumps ( data , sort_keys = True ) [EOL] [EOL] def _decode_field_entry ( self , data ) : [EOL] [docstring] [EOL] return json . loads ( data ) [EOL] [EOL] def write ( self , path = None , fileobj = None , expand_pattern = False ) : [EOL] [docstring] [EOL] with _auto_fileobj ( path , fileobj , [string] ) as fh : [EOL] fh . write ( [string] % self . CURRENT_VERSION ) [EOL] [EOL] for dest in sorted ( self . _dests ) : [EOL] entry = self . _dests [ dest ] [EOL] [EOL] if expand_pattern and entry [ [number] ] in ( self . PATTERN_LINK , self . PATTERN_COPY ) : [EOL] type , base , pattern , dest = entry [EOL] type = self . LINK if type == self . PATTERN_LINK else self . COPY [EOL] finder = FileFinder ( base ) [EOL] paths = [ f [ [number] ] for f in finder . find ( pattern ) ] [EOL] for path in paths : [EOL] source = mozpath . join ( base , path ) [EOL] parts = [ [string] % type , mozpath . join ( dest , path ) , source ] [EOL] fh . write ( [string] % self . FIELD_SEPARATOR . join ( p . encode ( [string] ) for p in parts ) ) [EOL] else : [EOL] parts = [ [string] % entry [ [number] ] , dest ] [EOL] parts . extend ( entry [ [number] : ] ) [EOL] fh . write ( [string] % self . FIELD_SEPARATOR . join ( p . encode ( [string] ) for p in parts ) ) [EOL] [EOL] def add_link ( self , source , dest ) : [EOL] [docstring] [EOL] self . _add_entry ( dest , ( self . LINK , source ) ) [EOL] [EOL] def add_copy ( self , source , dest ) : [EOL] [docstring] [EOL] self . _add_entry ( dest , ( self . COPY , source ) ) [EOL] [EOL] def add_required_exists ( self , dest ) : [EOL] [docstring] [EOL] self . _add_entry ( dest , ( self . REQUIRED_EXISTS , ) ) [EOL] [EOL] def add_optional_exists ( self , dest ) : [EOL] [docstring] [EOL] self . _add_entry ( dest , ( self . OPTIONAL_EXISTS , ) ) [EOL] [EOL] def add_pattern_link ( self , base , pattern , dest ) : [EOL] [docstring] [EOL] self . _add_entry ( mozpath . join ( dest , pattern ) , ( self . PATTERN_LINK , base , pattern , dest ) ) [EOL] [EOL] def add_pattern_copy ( self , base , pattern , dest ) : [EOL] [docstring] [EOL] self . _add_entry ( mozpath . join ( dest , pattern ) , ( self . PATTERN_COPY , base , pattern , dest ) ) [EOL] [EOL] def add_preprocess ( self , source , dest , deps , marker = [string] , defines = { } , silence_missing_directive_warnings = False ) : [EOL] [docstring] [EOL] self . _add_entry ( dest , ( self . PREPROCESS , source , deps , marker , self . _encode_field_entry ( defines ) , [string] if silence_missing_directive_warnings else [string] , ) ) [EOL] [EOL] def add_content ( self , content , dest ) : [EOL] [docstring] [EOL] self . _add_entry ( dest , ( self . CONTENT , self . _encode_field_entry ( content ) , ) ) [EOL] [EOL] def _add_entry ( self , dest , entry ) : [EOL] if dest in self . _dests : [EOL] raise ValueError ( [string] % dest ) [EOL] [EOL] self . _dests [ dest ] = entry [EOL] [EOL] def add_entries_from ( self , other , base = [string] ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _source_files |= other . _source_files [EOL] [EOL] for dest in sorted ( other . _dests ) : [EOL] new_dest = mozpath . join ( base , dest ) if base else dest [EOL] entry = other . _dests [ dest ] [EOL] if entry [ [number] ] in ( self . PATTERN_LINK , self . PATTERN_COPY ) : [EOL] entry_type , entry_base , entry_pattern , entry_dest = entry [EOL] new_entry_dest = mozpath . join ( base , entry_dest ) if base else entry_dest [EOL] new_entry = ( entry_type , entry_base , entry_pattern , new_entry_dest ) [EOL] else : [EOL] new_entry = tuple ( entry ) [EOL] [EOL] self . _add_entry ( new_dest , new_entry ) [EOL] [EOL] def populate_registry ( self , registry , defines_override = { } , link_policy = [string] ) : [EOL] [docstring] [EOL] assert link_policy in ( [string] , [string] , [string] ) [EOL] for dest in sorted ( self . _dests ) : [EOL] entry = self . _dests [ dest ] [EOL] install_type = entry [ [number] ] [EOL] [EOL] if install_type == self . LINK : [EOL] if link_policy == [string] : [EOL] cls = AbsoluteSymlinkFile [EOL] elif link_policy == [string] : [EOL] cls = HardlinkFile [EOL] else : [EOL] cls = File [EOL] registry . add ( dest , cls ( entry [ [number] ] ) ) [EOL] continue [EOL] [EOL] if install_type == self . COPY : [EOL] registry . add ( dest , File ( entry [ [number] ] ) ) [EOL] continue [EOL] [EOL] if install_type == self . REQUIRED_EXISTS : [EOL] registry . add ( dest , ExistingFile ( required = True ) ) [EOL] continue [EOL] [EOL] if install_type == self . OPTIONAL_EXISTS : [EOL] registry . add ( dest , ExistingFile ( required = False ) ) [EOL] continue [EOL] [EOL] if install_type in ( self . PATTERN_LINK , self . PATTERN_COPY ) : [EOL] _ , base , pattern , dest = entry [EOL] finder = FileFinder ( base ) [EOL] paths = [ f [ [number] ] for f in finder . find ( pattern ) ] [EOL] [EOL] if install_type == self . PATTERN_LINK : [EOL] if link_policy == [string] : [EOL] cls = AbsoluteSymlinkFile [EOL] elif link_policy == [string] : [EOL] cls = HardlinkFile [EOL] else : [EOL] cls = File [EOL] else : [EOL] cls = File [EOL] [EOL] for path in paths : [EOL] source = mozpath . join ( base , path ) [EOL] registry . add ( mozpath . join ( dest , path ) , cls ( source ) ) [EOL] [EOL] continue [EOL] [EOL] if install_type == self . PREPROCESS : [EOL] defines = self . _decode_field_entry ( entry [ [number] ] ) [EOL] if defines_override : [EOL] defines . update ( defines_override ) [EOL] registry . add ( dest , PreprocessedFile ( entry [ [number] ] , depfile_path = entry [ [number] ] , marker = entry [ [number] ] , defines = defines , extra_depends = self . _source_files , silence_missing_directive_warnings = bool ( int ( entry [ [number] ] ) ) , ) ) [EOL] [EOL] continue [EOL] [EOL] if install_type == self . CONTENT : [EOL] [comment] [EOL] [comment] [EOL] content = self . _decode_field_entry ( entry [ [number] ] ) . encode ( [string] ) [EOL] registry . add ( dest , GeneratedFile ( content ) ) [EOL] continue [EOL] [EOL] raise Exception ( [string] % install_type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import ctypes [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import ctypes [EOL] import posixpath [EOL] import os [EOL] import re [EOL] import sys [EOL] [EOL] [EOL] def normsep ( path ) : [EOL] [docstring] [EOL] if os . sep != [string] : [EOL] path = path . replace ( os . sep , [string] ) [EOL] if os . altsep and os . altsep != [string] : [EOL] path = path . replace ( os . altsep , [string] ) [EOL] return path [EOL] [EOL] [EOL] def relpath ( path , start ) : [EOL] rel = normsep ( os . path . relpath ( path , start ) ) [EOL] return [string] if rel == [string] else rel [EOL] [EOL] [EOL] def realpath ( path ) : [EOL] return normsep ( os . path . realpath ( path ) ) [EOL] [EOL] [EOL] def abspath ( path ) : [EOL] return normsep ( os . path . abspath ( path ) ) [EOL] [EOL] [EOL] def join ( * paths ) : [EOL] return normsep ( os . path . join ( * paths ) ) [EOL] [EOL] [EOL] def normpath ( path ) : [EOL] return posixpath . normpath ( normsep ( path ) ) [EOL] [EOL] [EOL] def dirname ( path ) : [EOL] return posixpath . dirname ( normsep ( path ) ) [EOL] [EOL] [EOL] def commonprefix ( paths ) : [EOL] return posixpath . commonprefix ( [ normsep ( path ) for path in paths ] ) [EOL] [EOL] [EOL] def basename ( path ) : [EOL] return os . path . basename ( path ) [EOL] [EOL] [EOL] def splitext ( path ) : [EOL] return posixpath . splitext ( normsep ( path ) ) [EOL] [EOL] [EOL] def split ( path ) : [EOL] [docstring] [EOL] return normsep ( path ) . split ( [string] ) [EOL] [EOL] [EOL] def basedir ( path , bases ) : [EOL] [docstring] [EOL] path = normsep ( path ) [EOL] bases = [ normsep ( b ) for b in bases ] [EOL] if path in bases : [EOL] return path [EOL] for b in sorted ( bases , reverse = True ) : [EOL] if b == [string] or path . startswith ( b + [string] ) : [EOL] return b [EOL] [EOL] [EOL] re_cache = { } [EOL] [EOL] [EOL] def match ( path , pattern ) : [EOL] [docstring] [EOL] if not pattern : [EOL] return True [EOL] if pattern not in re_cache : [EOL] p = re . escape ( pattern ) [EOL] p = re . sub ( [string] , [string] , p ) [EOL] p = re . sub ( [string] , [string] , p ) [EOL] p = p . replace ( [string] , [string] ) + [string] [EOL] re_cache [ pattern ] = re . compile ( p ) [EOL] return re_cache [ pattern ] . match ( path ) is not None [EOL] [EOL] [EOL] def rebase ( oldbase , base , relativepath ) : [EOL] [docstring] [EOL] if base == oldbase : [EOL] return relativepath [EOL] if len ( base ) < len ( oldbase ) : [EOL] assert basedir ( oldbase , [ base ] ) == base [EOL] relbase = relpath ( oldbase , base ) [EOL] result = join ( relbase , relativepath ) [EOL] else : [EOL] assert basedir ( base , [ oldbase ] ) == oldbase [EOL] relbase = relpath ( base , oldbase ) [EOL] result = relpath ( relativepath , relbase ) [EOL] result = normpath ( result ) [EOL] if relativepath . endswith ( [string] ) and not result . endswith ( [string] ) : [EOL] result += [string] [EOL] return result [EOL] [EOL] [EOL] def readlink ( path ) : [EOL] if hasattr ( os , [string] ) : [EOL] return normsep ( os . readlink ( path ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] assert sys . platform == [string] [EOL] [EOL] CreateFileW = ctypes . windll . kernel32 . CreateFileW [EOL] CreateFileW . argtypes = [ ctypes . wintypes . LPCWSTR , ctypes . wintypes . DWORD , ctypes . wintypes . DWORD , ctypes . wintypes . LPVOID , ctypes . wintypes . DWORD , ctypes . wintypes . DWORD , ctypes . wintypes . HANDLE , ] [EOL] CreateFileW . restype = ctypes . wintypes . HANDLE [EOL] [EOL] GENERIC_READ = [number] [EOL] FILE_SHARE_READ = [number] [EOL] OPEN_EXISTING = [number] [EOL] FILE_FLAG_BACKUP_SEMANTICS = [number] [EOL] [EOL] handle = CreateFileW ( path , GENERIC_READ , FILE_SHARE_READ , [number] , OPEN_EXISTING , FILE_FLAG_BACKUP_SEMANTICS , [number] ) [EOL] assert handle != [number] , [string] . format ( path ) [EOL] [EOL] MAX_PATH = [number] [EOL] [EOL] buf = ctypes . create_unicode_buffer ( MAX_PATH ) [EOL] GetFinalPathNameByHandleW = ctypes . windll . kernel32 . GetFinalPathNameByHandleW [EOL] GetFinalPathNameByHandleW . argtypes = [ ctypes . wintypes . HANDLE , ctypes . wintypes . LPWSTR , ctypes . wintypes . DWORD , ctypes . wintypes . DWORD , ] [EOL] GetFinalPathNameByHandleW . restype = ctypes . wintypes . DWORD [EOL] [EOL] FILE_NAME_NORMALIZED = [number] [EOL] [EOL] rv = GetFinalPathNameByHandleW ( handle , buf , MAX_PATH , FILE_NAME_NORMALIZED ) [EOL] assert rv != [number] and rv <= MAX_PATH , [string] . format ( path ) [EOL] [EOL] CloseHandle = ctypes . windll . kernel32 . CloseHandle [EOL] CloseHandle . argtypes = [ ctypes . wintypes . HANDLE ] [EOL] CloseHandle . restype = ctypes . wintypes . BOOL [EOL] [EOL] rv = CloseHandle ( handle ) [EOL] assert rv != [number] , [string] [EOL] [EOL] [comment] [EOL] return normsep ( buf . value [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Type , List [EOL] import io [EOL] import typing [EOL] import vendored [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] from mozpack . files import FileFinder [EOL] from mozpack . mozjar import ( JarReaderError , JarWriterError , JarStruct , JarReader , JarWriter , Deflater , JarLog , ) [EOL] from collections import OrderedDict [EOL] from mozpack . test . test_files import MockDest [EOL] import unittest [EOL] import mozunit [EOL] import six [EOL] import mozpack . path as mozpath [EOL] import os [EOL] [EOL] [EOL] test_data_path = mozpath . abspath ( mozpath . dirname ( __file__ ) ) [EOL] test_data_path = mozpath . join ( test_data_path , [string] ) [EOL] [EOL] [EOL] class TestJarStruct ( unittest . TestCase ) : [EOL] class Foo ( JarStruct ) : [EOL] MAGIC = [number] [EOL] STRUCT = OrderedDict ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) [EOL] [EOL] def test_jar_struct ( self ) : [EOL] foo = TestJarStruct . Foo ( ) [EOL] self . assertEqual ( foo . signature , TestJarStruct . Foo . MAGIC ) [EOL] self . assertEqual ( foo [ [string] ] , [number] ) [EOL] self . assertEqual ( foo [ [string] ] , [number] ) [EOL] self . assertEqual ( foo [ [string] ] , [number] ) [EOL] self . assertFalse ( [string] in foo ) [EOL] self . assertFalse ( [string] in foo ) [EOL] self . assertEqual ( foo [ [string] ] , [string] ) [EOL] self . assertEqual ( foo [ [string] ] , [string] ) [EOL] [EOL] self . assertEqual ( foo . size , [number] ) [EOL] [EOL] foo [ [string] ] = [number] [EOL] foo [ [string] ] = [number] [EOL] foo [ [string] ] = [number] [EOL] foo [ [string] ] = [string] [EOL] foo [ [string] ] = [string] [EOL] [EOL] serialized = [string] + [string] [EOL] self . assertEqual ( foo . size , len ( serialized ) ) [EOL] foo_serialized = foo . serialize ( ) [EOL] self . assertEqual ( foo_serialized , serialized ) [EOL] [EOL] def do_test_read_jar_struct ( self , data ) : [EOL] self . assertRaises ( JarReaderError , TestJarStruct . Foo , data ) [EOL] self . assertRaises ( JarReaderError , TestJarStruct . Foo , data [ [number] : ] ) [EOL] [EOL] foo = TestJarStruct . Foo ( data [ [number] : ] ) [EOL] self . assertEqual ( foo [ [string] ] , [number] ) [EOL] self . assertEqual ( foo [ [string] ] , [number] ) [EOL] self . assertEqual ( foo [ [string] ] , [number] ) [EOL] self . assertFalse ( [string] in foo ) [EOL] self . assertFalse ( [string] in foo ) [EOL] self . assertEqual ( foo [ [string] ] , [string] ) [EOL] self . assertEqual ( foo [ [string] ] , [string] ) [EOL] [EOL] def test_read_jar_struct ( self ) : [EOL] data = [string] + [string] [EOL] self . do_test_read_jar_struct ( data ) [EOL] [EOL] def test_read_jar_struct_memoryview ( self ) : [EOL] data = [string] + [string] [EOL] self . do_test_read_jar_struct ( memoryview ( data ) ) [EOL] [EOL] [EOL] class TestDeflater ( unittest . TestCase ) : [EOL] def wrap ( self , data ) : [EOL] return data [EOL] [EOL] def test_deflater_no_compress ( self ) : [EOL] deflater = Deflater ( False ) [EOL] deflater . write ( self . wrap ( [string] ) ) [EOL] self . assertFalse ( deflater . compressed ) [EOL] self . assertEqual ( deflater . uncompressed_size , [number] ) [EOL] self . assertEqual ( deflater . compressed_size , deflater . uncompressed_size ) [EOL] self . assertEqual ( deflater . compressed_data , [string] ) [EOL] self . assertEqual ( deflater . crc32 , [number] ) [EOL] [EOL] def test_deflater_compress_no_gain ( self ) : [EOL] deflater = Deflater ( True ) [EOL] deflater . write ( self . wrap ( [string] ) ) [EOL] self . assertFalse ( deflater . compressed ) [EOL] self . assertEqual ( deflater . uncompressed_size , [number] ) [EOL] self . assertEqual ( deflater . compressed_size , deflater . uncompressed_size ) [EOL] self . assertEqual ( deflater . compressed_data , [string] ) [EOL] self . assertEqual ( deflater . crc32 , [number] ) [EOL] [EOL] def test_deflater_compress ( self ) : [EOL] deflater = Deflater ( True ) [EOL] deflater . write ( self . wrap ( [string] ) ) [EOL] self . assertTrue ( deflater . compressed ) [EOL] self . assertEqual ( deflater . uncompressed_size , [number] ) [EOL] self . assertNotEqual ( deflater . compressed_size , deflater . uncompressed_size ) [EOL] self . assertEqual ( deflater . crc32 , [number] ) [EOL] [comment] [EOL] deflater = Deflater ( False ) [EOL] self . assertFalse ( deflater . compressed ) [EOL] deflater . write ( self . wrap ( [string] ) ) [EOL] self . assertEqual ( deflater . crc32 , [number] ) [EOL] [EOL] def test_deflater_empty ( self ) : [EOL] deflater = Deflater ( False ) [EOL] self . assertFalse ( deflater . compressed ) [EOL] self . assertEqual ( deflater . uncompressed_size , [number] ) [EOL] self . assertEqual ( deflater . compressed_size , deflater . uncompressed_size ) [EOL] self . assertEqual ( deflater . compressed_data , [string] ) [EOL] self . assertEqual ( deflater . crc32 , [number] ) [EOL] [EOL] [EOL] class TestDeflaterMemoryView ( TestDeflater ) : [EOL] def wrap ( self , data ) : [EOL] return memoryview ( data ) [EOL] [EOL] [EOL] class TestJar ( unittest . TestCase ) : [EOL] def test_jar ( self ) : [EOL] s = MockDest ( ) [EOL] with JarWriter ( fileobj = s ) as jar : [EOL] jar . add ( [string] , [string] ) [EOL] self . assertRaises ( JarWriterError , jar . add , [string] , [string] ) [EOL] jar . add ( [string] , [string] ) [EOL] jar . add ( [string] , [string] , False ) [EOL] jar . add ( [string] , [string] ) [EOL] [EOL] files = [ j for j in JarReader ( fileobj = s ) ] [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertFalse ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertTrue ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertFalse ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] if os . sep == [string] : [EOL] self . assertEqual ( files [ [number] ] . filename , [string] , [string] ) [EOL] else : [EOL] self . assertEqual ( files [ [number] ] . filename , [string] , [string] ) [EOL] [EOL] s = MockDest ( ) [EOL] with JarWriter ( fileobj = s , compress = False ) as jar : [EOL] jar . add ( [string] , [string] ) [EOL] jar . add ( [string] , [string] ) [EOL] jar . add ( [string] , [string] , True ) [EOL] [EOL] jar = JarReader ( fileobj = s ) [EOL] files = [ j for j in jar ] [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertFalse ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertFalse ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertTrue ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] self . assertTrue ( [string] in jar ) [EOL] self . assertTrue ( [string] in jar ) [EOL] self . assertFalse ( [string] in jar ) [EOL] self . assertTrue ( [string] in jar ) [EOL] self . assertTrue ( jar [ [string] ] , files [ [number] ] ) [EOL] self . assertTrue ( jar [ [string] ] , files [ [number] ] ) [EOL] self . assertTrue ( jar [ [string] ] , files [ [number] ] ) [EOL] [EOL] s . seek ( [number] ) [EOL] jar = JarReader ( fileobj = s ) [EOL] self . assertTrue ( [string] in jar ) [EOL] self . assertTrue ( [string] in jar ) [EOL] self . assertFalse ( [string] in jar ) [EOL] self . assertTrue ( [string] in jar ) [EOL] [EOL] files [ [number] ] . seek ( [number] ) [EOL] self . assertEqual ( jar [ [string] ] . filename , files [ [number] ] . filename ) [EOL] self . assertEqual ( jar [ [string] ] . compressed , files [ [number] ] . compressed ) [EOL] self . assertEqual ( jar [ [string] ] . read ( ) , files [ [number] ] . read ( ) ) [EOL] [EOL] files [ [number] ] . seek ( [number] ) [EOL] self . assertEqual ( jar [ [string] ] . filename , files [ [number] ] . filename ) [EOL] self . assertEqual ( jar [ [string] ] . compressed , files [ [number] ] . compressed ) [EOL] self . assertEqual ( jar [ [string] ] . read ( ) , files [ [number] ] . read ( ) ) [EOL] [EOL] files [ [number] ] . seek ( [number] ) [EOL] self . assertEqual ( jar [ [string] ] . filename , files [ [number] ] . filename ) [EOL] self . assertEqual ( jar [ [string] ] . compressed , files [ [number] ] . compressed ) [EOL] self . assertEqual ( jar [ [string] ] . read ( ) , files [ [number] ] . read ( ) ) [EOL] [EOL] def test_rejar ( self ) : [EOL] s = MockDest ( ) [EOL] with JarWriter ( fileobj = s ) as jar : [EOL] jar . add ( [string] , [string] ) [EOL] jar . add ( [string] , [string] ) [EOL] jar . add ( [string] , [string] , False ) [EOL] [EOL] new = MockDest ( ) [EOL] with JarWriter ( fileobj = new ) as jar : [EOL] for j in JarReader ( fileobj = s ) : [EOL] jar . add ( j . filename , j ) [EOL] [EOL] jar = JarReader ( fileobj = new ) [EOL] files = [ j for j in jar ] [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertFalse ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertTrue ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertTrue ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] def test_add_from_finder ( self ) : [EOL] s = MockDest ( ) [EOL] with JarWriter ( fileobj = s ) as jar : [EOL] finder = FileFinder ( test_data_path ) [EOL] for p , f in finder . find ( [string] ) : [EOL] jar . add ( [string] , f ) [EOL] [EOL] jar = JarReader ( fileobj = s ) [EOL] files = [ j for j in jar ] [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertFalse ( files [ [number] ] . compressed ) [EOL] self . assertEqual ( files [ [number] ] . read ( ) , [string] ) [EOL] [EOL] [EOL] class TestPreload ( unittest . TestCase ) : [EOL] def test_preload ( self ) : [EOL] s = MockDest ( ) [EOL] with JarWriter ( fileobj = s ) as jar : [EOL] jar . add ( [string] , [string] ) [EOL] jar . add ( [string] , [string] ) [EOL] jar . add ( [string] , [string] ) [EOL] [EOL] jar = JarReader ( fileobj = s ) [EOL] self . assertEqual ( jar . last_preloaded , None ) [EOL] [EOL] with JarWriter ( fileobj = s ) as jar : [EOL] jar . add ( [string] , [string] ) [EOL] jar . add ( [string] , [string] ) [EOL] jar . add ( [string] , [string] ) [EOL] jar . preload ( [ [string] , [string] ] ) [EOL] [EOL] jar = JarReader ( fileobj = s ) [EOL] self . assertEqual ( jar . last_preloaded , [string] ) [EOL] files = [ j for j in jar ] [EOL] [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] self . assertEqual ( files [ [number] ] . filename , [string] ) [EOL] [EOL] [EOL] class TestJarLog ( unittest . TestCase ) : [EOL] def test_jarlog ( self ) : [EOL] s = six . moves . cStringIO ( [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) ) [EOL] log = JarLog ( fileobj = s ) [EOL] self . assertEqual ( set ( log . keys ( ) ) , set ( [ [string] , [string] , ] ) ) [EOL] self . assertEqual ( log [ [string] ] , [ [string] , [string] , [string] , ] ) [EOL] self . assertEqual ( log [ [string] ] , [ [string] , [string] , ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 $vendored.mozbuild.mozpack.test.test_mozjar.TestJarStruct.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] from mozpack . errors import ( errors , ErrorMessage , AccumulatedErrors , ) [EOL] import unittest [EOL] import mozunit [EOL] import six [EOL] import sys [EOL] [EOL] [EOL] class TestErrors ( object ) : [EOL] def setUp ( self ) : [EOL] errors . out = six . moves . cStringIO ( ) [EOL] errors . ignore_errors ( False ) [EOL] [EOL] def tearDown ( self ) : [EOL] errors . out = sys . stderr [EOL] [EOL] def get_output ( self ) : [EOL] return [ l . strip ( ) for l in errors . out . getvalue ( ) . splitlines ( ) ] [EOL] [EOL] [EOL] class TestErrorsImpl ( TestErrors , unittest . TestCase ) : [EOL] def test_plain_error ( self ) : [EOL] errors . warn ( [string] ) [EOL] self . assertRaises ( ErrorMessage , errors . error , [string] ) [EOL] self . assertRaises ( ErrorMessage , errors . fatal , [string] ) [EOL] self . assertEquals ( self . get_output ( ) , [ [string] ] ) [EOL] [EOL] def test_ignore_errors ( self ) : [EOL] errors . ignore_errors ( ) [EOL] errors . warn ( [string] ) [EOL] errors . error ( [string] ) [EOL] self . assertRaises ( ErrorMessage , errors . fatal , [string] ) [EOL] self . assertEquals ( self . get_output ( ) , [ [string] , [string] ] ) [EOL] [EOL] def test_no_error ( self ) : [EOL] with errors . accumulate ( ) : [EOL] errors . warn ( [string] ) [EOL] [EOL] def test_simple_error ( self ) : [EOL] with self . assertRaises ( AccumulatedErrors ) : [EOL] with errors . accumulate ( ) : [EOL] errors . error ( [string] ) [EOL] self . assertEquals ( self . get_output ( ) , [ [string] ] ) [EOL] [EOL] def test_error_loop ( self ) : [EOL] with self . assertRaises ( AccumulatedErrors ) : [EOL] with errors . accumulate ( ) : [EOL] for i in range ( [number] ) : [EOL] errors . error ( [string] % i ) [EOL] self . assertEquals ( self . get_output ( ) , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_multiple_errors ( self ) : [EOL] with self . assertRaises ( AccumulatedErrors ) : [EOL] with errors . accumulate ( ) : [EOL] errors . error ( [string] ) [EOL] for i in range ( [number] ) : [EOL] if i == [number] : [EOL] errors . warn ( [string] % i ) [EOL] else : [EOL] errors . error ( [string] % i ) [EOL] errors . error ( [string] ) [EOL] self . assertEquals ( self . get_output ( ) , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_errors_context ( self ) : [EOL] with self . assertRaises ( AccumulatedErrors ) : [EOL] with errors . accumulate ( ) : [EOL] self . assertEqual ( errors . get_context ( ) , None ) [EOL] with errors . context ( [string] , [number] ) : [EOL] self . assertEqual ( errors . get_context ( ) , ( [string] , [number] ) ) [EOL] errors . error ( [string] ) [EOL] with errors . context ( [string] , [number] ) : [EOL] self . assertEqual ( errors . get_context ( ) , ( [string] , [number] ) ) [EOL] errors . error ( [string] ) [EOL] self . assertEqual ( errors . get_context ( ) , ( [string] , [number] ) ) [EOL] errors . error ( [string] ) [EOL] self . assertEqual ( self . get_output ( ) , [ [string] , [string] , [string] , ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , Union , Dict , List [EOL] import os [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] from mozpack . copier import ( FileCopier , FileRegistry , FileRegistrySubtree , Jarrer , ) [EOL] from mozpack . files import ( GeneratedFile , ExistingFile , ) [EOL] from mozpack . mozjar import JarReader [EOL] import mozpack . path as mozpath [EOL] import unittest [EOL] import mozunit [EOL] import os [EOL] import six [EOL] import stat [EOL] from mozpack . errors import ErrorMessage [EOL] from mozpack . test . test_files import ( MockDest , MatchTestTemplate , TestWithTmpDir , ) [EOL] [EOL] [EOL] class BaseTestFileRegistry ( MatchTestTemplate ) : [EOL] def add ( self , path ) : [EOL] self . registry . add ( path , GeneratedFile ( path ) ) [EOL] [EOL] def do_check ( self , pattern , result ) : [EOL] self . checked = True [EOL] if result : [EOL] self . assertTrue ( self . registry . contains ( pattern ) ) [EOL] else : [EOL] self . assertFalse ( self . registry . contains ( pattern ) ) [EOL] self . assertEqual ( self . registry . match ( pattern ) , result ) [EOL] [EOL] def do_test_file_registry ( self , registry ) : [EOL] self . registry = registry [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] bar = GeneratedFile ( [string] ) [EOL] self . registry . add ( [string] , bar ) [EOL] self . assertEqual ( self . registry . paths ( ) , [ [string] , [string] ] ) [EOL] self . assertEqual ( self . registry [ [string] ] , bar ) [EOL] [EOL] self . assertRaises ( ErrorMessage , self . registry . add , [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] self . assertRaises ( ErrorMessage , self . registry . remove , [string] ) [EOL] [EOL] self . assertRaises ( ErrorMessage , self . registry . add , [string] , GeneratedFile ( [string] ) ) [EOL] self . assertRaises ( ErrorMessage , self . registry . add , [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] self . assertEqual ( self . registry . paths ( ) , [ [string] , [string] ] ) [EOL] [EOL] self . registry . remove ( [string] ) [EOL] self . assertEqual ( self . registry . paths ( ) , [ [string] ] ) [EOL] self . registry . remove ( [string] ) [EOL] self . assertEqual ( self . registry . paths ( ) , [ ] ) [EOL] [EOL] self . prepare_match_test ( ) [EOL] self . do_match_test ( ) [EOL] self . assertTrue ( self . checked ) [EOL] self . assertEqual ( self . registry . paths ( ) , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] self . registry . remove ( [string] ) [EOL] self . assertEqual ( self . registry . paths ( ) , [ [string] , [string] , [string] ] ) [EOL] [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] self . assertEqual ( self . registry . paths ( ) , [ [string] , [string] , [string] , [string] ] ) [EOL] self . registry . remove ( [string] ) [EOL] self . assertEqual ( self . registry . paths ( ) , [ [string] , [string] ] ) [EOL] [EOL] self . assertEqual ( [ f for f , c in self . registry ] , [ [string] , [string] ] ) [EOL] self . assertEqual ( len ( self . registry ) , [number] ) [EOL] [EOL] self . add ( [string] ) [EOL] self . assertTrue ( self . registry . contains ( [string] ) ) [EOL] [EOL] def do_test_registry_paths ( self , registry ) : [EOL] self . registry = registry [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] self . assertRaises ( ErrorMessage , self . registry . add , [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] [comment] [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] self . assertRaises ( ErrorMessage , self . registry . add , [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] [comment] [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] self . assertRaises ( ErrorMessage , self . registry . add , [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] [comment] [EOL] self . registry . remove ( [string] ) [EOL] self . assertRaises ( ErrorMessage , self . registry . add , [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] [comment] [EOL] self . registry . remove ( [string] ) [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] [EOL] class TestFileRegistry ( BaseTestFileRegistry , unittest . TestCase ) : [EOL] def test_partial_paths ( self ) : [EOL] cases = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] ] , [string] : [ ] , } [EOL] reg = FileRegistry ( ) [EOL] for path , parts in six . iteritems ( cases ) : [EOL] self . assertEqual ( reg . _partial_paths ( path ) , parts ) [EOL] [EOL] def test_file_registry ( self ) : [EOL] self . do_test_file_registry ( FileRegistry ( ) ) [EOL] [EOL] def test_registry_paths ( self ) : [EOL] self . do_test_registry_paths ( FileRegistry ( ) ) [EOL] [EOL] def test_required_directories ( self ) : [EOL] self . registry = FileRegistry ( ) [EOL] [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] self . assertEqual ( self . registry . required_directories ( ) , set ( ) ) [EOL] [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] self . assertEqual ( self . registry . required_directories ( ) , { [string] } ) [EOL] [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] self . assertEqual ( self . registry . required_directories ( ) , { [string] } ) [EOL] [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] self . assertEqual ( self . registry . required_directories ( ) , { [string] , [string] } ) [EOL] [EOL] self . registry . remove ( [string] ) [EOL] self . assertEqual ( self . registry . required_directories ( ) , { [string] } ) [EOL] [EOL] self . registry . remove ( [string] ) [EOL] self . assertEqual ( self . registry . required_directories ( ) , { [string] } ) [EOL] [EOL] self . registry . remove ( [string] ) [EOL] self . assertEqual ( self . registry . required_directories ( ) , set ( ) ) [EOL] [EOL] self . registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] self . assertEqual ( self . registry . required_directories ( ) , { [string] , [string] } ) [EOL] [EOL] [EOL] class TestFileRegistrySubtree ( BaseTestFileRegistry , unittest . TestCase ) : [EOL] def test_file_registry_subtree_base ( self ) : [EOL] registry = FileRegistry ( ) [EOL] self . assertEqual ( registry , FileRegistrySubtree ( [string] , registry ) ) [EOL] self . assertNotEqual ( registry , FileRegistrySubtree ( [string] , registry ) ) [EOL] [EOL] def create_registry ( self ) : [EOL] registry = FileRegistry ( ) [EOL] registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] registry . add ( [string] , GeneratedFile ( [string] ) ) [EOL] return FileRegistrySubtree ( [string] , registry ) [EOL] [EOL] def test_file_registry_subtree ( self ) : [EOL] self . do_test_file_registry ( self . create_registry ( ) ) [EOL] [EOL] def test_registry_paths_subtree ( self ) : [EOL] FileRegistry ( ) [EOL] self . do_test_registry_paths ( self . create_registry ( ) ) [EOL] [EOL] [EOL] class TestFileCopier ( TestWithTmpDir ) : [EOL] def all_dirs ( self , base ) : [EOL] all_dirs = set ( ) [EOL] for root , dirs , files in os . walk ( base ) : [EOL] if not dirs : [EOL] all_dirs . add ( mozpath . relpath ( root , base ) ) [EOL] return all_dirs [EOL] [EOL] def all_files ( self , base ) : [EOL] all_files = set ( ) [EOL] for root , dirs , files in os . walk ( base ) : [EOL] for f in files : [EOL] all_files . add ( mozpath . join ( mozpath . relpath ( root , base ) , f ) ) [EOL] return all_files [EOL] [EOL] def test_file_copier ( self ) : [EOL] copier = FileCopier ( ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] result = copier . copy ( self . tmpdir ) [EOL] self . assertEqual ( self . all_files ( self . tmpdir ) , set ( copier . paths ( ) ) ) [EOL] self . assertEqual ( self . all_dirs ( self . tmpdir ) , set ( [ [string] , [string] ] ) ) [EOL] [EOL] self . assertEqual ( result . updated_files , set ( self . tmppath ( p ) for p in self . all_files ( self . tmpdir ) ) ) [EOL] self . assertEqual ( result . existing_files , set ( ) ) [EOL] self . assertEqual ( result . removed_files , set ( ) ) [EOL] self . assertEqual ( result . removed_directories , set ( ) ) [EOL] [EOL] copier . remove ( [string] ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] result = copier . copy ( self . tmpdir ) [EOL] self . assertEqual ( self . all_files ( self . tmpdir ) , set ( copier . paths ( ) ) ) [EOL] self . assertEqual ( self . all_dirs ( self . tmpdir ) , set ( [ [string] ] ) ) [EOL] self . assertEqual ( result . removed_files , set ( self . tmppath ( p ) for p in ( [string] , [string] , [string] ) ) ) [EOL] [EOL] def test_symlink_directory_replaced ( self ) : [EOL] [docstring] [EOL] if not self . symlink_supported : [EOL] return [EOL] [EOL] dest = self . tmppath ( [string] ) [EOL] [EOL] copier = FileCopier ( ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] os . makedirs ( self . tmppath ( [string] ) ) [EOL] dummy = self . tmppath ( [string] ) [EOL] os . mkdir ( dummy ) [EOL] link = self . tmppath ( [string] ) [EOL] os . symlink ( dummy , link ) [EOL] [EOL] result = copier . copy ( dest ) [EOL] [EOL] st = os . lstat ( link ) [EOL] self . assertFalse ( stat . S_ISLNK ( st . st_mode ) ) [EOL] self . assertTrue ( stat . S_ISDIR ( st . st_mode ) ) [EOL] [EOL] self . assertEqual ( self . all_files ( dest ) , set ( copier . paths ( ) ) ) [EOL] [EOL] self . assertEqual ( result . removed_directories , set ( ) ) [EOL] self . assertEqual ( len ( result . updated_files ) , [number] ) [EOL] [EOL] def test_remove_unaccounted_directory_symlinks ( self ) : [EOL] [docstring] [EOL] if not self . symlink_supported : [EOL] return [EOL] [EOL] dest = self . tmppath ( [string] ) [EOL] [EOL] copier = FileCopier ( ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] os . makedirs ( self . tmppath ( [string] ) ) [EOL] dummy = self . tmppath ( [string] ) [EOL] os . mkdir ( dummy ) [EOL] [EOL] os . mkdir ( self . tmppath ( [string] ) ) [EOL] link = self . tmppath ( [string] ) [EOL] os . symlink ( dummy , link ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] result = copier . copy ( dest , remove_unaccounted = False , remove_empty_directories = True , remove_all_directory_symlinks = False ) [EOL] [EOL] st = os . lstat ( link ) [EOL] self . assertTrue ( stat . S_ISLNK ( st . st_mode ) ) [EOL] self . assertFalse ( stat . S_ISDIR ( st . st_mode ) ) [EOL] [EOL] self . assertEqual ( self . all_files ( dest ) , set ( copier . paths ( ) ) ) [EOL] self . assertEqual ( self . all_dirs ( dest ) , set ( [ [string] ] ) ) [EOL] [EOL] self . assertEqual ( result . removed_directories , set ( ) ) [EOL] self . assertEqual ( len ( result . updated_files ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] result = copier . copy ( dest , remove_unaccounted = True , remove_empty_directories = False , remove_all_directory_symlinks = False ) [EOL] [EOL] st = os . lstat ( self . tmppath ( [string] ) ) [EOL] self . assertFalse ( stat . S_ISLNK ( st . st_mode ) ) [EOL] self . assertTrue ( stat . S_ISDIR ( st . st_mode ) ) [EOL] [EOL] self . assertEqual ( result . removed_files , set ( [ link ] ) ) [EOL] self . assertEqual ( result . removed_directories , set ( ) ) [EOL] [EOL] self . assertEqual ( self . all_files ( dest ) , set ( copier . paths ( ) ) ) [EOL] self . assertEqual ( self . all_dirs ( dest ) , set ( [ [string] , [string] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] link = self . tmppath ( [string] ) [EOL] os . symlink ( dummy , link ) [EOL] [EOL] result = copier . copy ( dest , remove_unaccounted = True , remove_empty_directories = True , remove_all_directory_symlinks = False ) [EOL] [EOL] self . assertEqual ( result . removed_files , set ( [ link ] ) ) [EOL] self . assertEqual ( result . removed_directories , set ( [ self . tmppath ( [string] ) ] ) ) [EOL] [EOL] self . assertEqual ( self . all_files ( dest ) , set ( copier . paths ( ) ) ) [EOL] self . assertEqual ( self . all_dirs ( dest ) , set ( [ [string] ] ) ) [EOL] [EOL] def test_permissions ( self ) : [EOL] [docstring] [EOL] with open ( self . tmppath ( [string] ) , [string] ) : [EOL] pass [EOL] [EOL] p = self . tmppath ( [string] ) [EOL] with open ( p , [string] ) : [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] os . chmod ( p , [number] ) [EOL] os . chmod ( self . tmpdir , [number] ) [EOL] [EOL] copier = FileCopier ( ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] result = copier . copy ( self . tmpdir ) [EOL] self . assertEqual ( result . removed_files_count , [number] ) [EOL] self . assertFalse ( os . path . exists ( p ) ) [EOL] [EOL] def test_no_remove ( self ) : [EOL] copier = FileCopier ( ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) : [EOL] pass [EOL] [EOL] os . mkdir ( self . tmppath ( [string] ) ) [EOL] d = self . tmppath ( [string] ) [EOL] os . mkdir ( d ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) : [EOL] pass [EOL] [EOL] result = copier . copy ( self . tmpdir , remove_unaccounted = False ) [EOL] [EOL] self . assertEqual ( self . all_files ( self . tmpdir ) , set ( [ [string] , [string] , [string] ] ) ) [EOL] self . assertEqual ( self . all_dirs ( self . tmpdir ) , set ( [ [string] ] ) ) [EOL] self . assertEqual ( result . removed_files , set ( ) ) [EOL] self . assertEqual ( result . removed_directories , set ( [ self . tmppath ( [string] ) ] ) ) [EOL] [EOL] def test_no_remove_empty_directories ( self ) : [EOL] copier = FileCopier ( ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) : [EOL] pass [EOL] [EOL] os . mkdir ( self . tmppath ( [string] ) ) [EOL] d = self . tmppath ( [string] ) [EOL] os . mkdir ( d ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) : [EOL] pass [EOL] [EOL] result = copier . copy ( self . tmpdir , remove_unaccounted = False , remove_empty_directories = False ) [EOL] [EOL] self . assertEqual ( self . all_files ( self . tmpdir ) , set ( [ [string] , [string] , [string] ] ) ) [EOL] self . assertEqual ( self . all_dirs ( self . tmpdir ) , set ( [ [string] , [string] ] ) ) [EOL] self . assertEqual ( result . removed_files , set ( ) ) [EOL] self . assertEqual ( result . removed_directories , set ( ) ) [EOL] [EOL] def test_optional_exists_creates_unneeded_directory ( self ) : [EOL] [docstring] [EOL] [EOL] dest = self . tmppath ( [string] ) [EOL] [EOL] copier = FileCopier ( ) [EOL] copier . add ( [string] , ExistingFile ( required = False ) ) [EOL] [EOL] result = copier . copy ( dest ) [EOL] [EOL] st = os . lstat ( self . tmppath ( [string] ) ) [EOL] self . assertFalse ( stat . S_ISLNK ( st . st_mode ) ) [EOL] self . assertTrue ( stat . S_ISDIR ( st . st_mode ) ) [EOL] [EOL] [comment] [EOL] self . assertEquals ( len ( result . updated_files ) , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . assertIn ( self . tmppath ( [string] ) , result . existing_files ) [EOL] [EOL] def test_remove_unaccounted_file_registry ( self ) : [EOL] [docstring] [EOL] [EOL] dest = self . tmppath ( [string] ) [EOL] [EOL] copier = FileCopier ( ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] os . makedirs ( os . path . join ( dest , [string] ) ) [EOL] with open ( os . path . join ( dest , [string] , [string] ) , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] os . makedirs ( os . path . join ( dest , [string] , [string] ) ) [EOL] with open ( os . path . join ( dest , [string] , [string] , [string] ) , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] [EOL] result = copier . copy ( dest , remove_unaccounted = False ) [EOL] [EOL] self . assertEqual ( self . all_files ( dest ) , set ( copier . paths ( ) ) | { [string] , [string] } ) [EOL] self . assertEqual ( self . all_dirs ( dest ) , { [string] , [string] , [string] , [string] } ) [EOL] [EOL] copier2 = FileCopier ( ) [EOL] copier2 . add ( [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] result = copier2 . copy ( dest , remove_unaccounted = copier ) [EOL] [EOL] self . assertEqual ( self . all_files ( dest ) , set ( copier2 . paths ( ) ) | { [string] , [string] } ) [EOL] self . assertEqual ( self . all_dirs ( dest ) , { [string] , [string] , [string] } ) [EOL] self . assertEqual ( result . updated_files , { self . tmppath ( [string] ) } ) [EOL] self . assertEqual ( result . existing_files , set ( ) ) [EOL] self . assertEqual ( result . removed_files , { self . tmppath ( p ) for p in ( [string] , [string] , [string] ) } ) [EOL] self . assertEqual ( result . removed_directories , { self . tmppath ( [string] ) } ) [EOL] [EOL] [EOL] class TestJarrer ( unittest . TestCase ) : [EOL] def check_jar ( self , dest , copier ) : [EOL] jar = JarReader ( fileobj = dest ) [EOL] self . assertEqual ( [ f . filename for f in jar ] , copier . paths ( ) ) [EOL] for f in jar : [EOL] self . assertEqual ( f . uncompressed_data . read ( ) , copier [ f . filename ] . content ) [EOL] [EOL] def test_jarrer ( self ) : [EOL] copier = Jarrer ( ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] [EOL] dest = MockDest ( ) [EOL] copier . copy ( dest ) [EOL] self . check_jar ( dest , copier ) [EOL] [EOL] copier . remove ( [string] ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . copy ( dest ) [EOL] self . check_jar ( dest , copier ) [EOL] [EOL] copier . remove ( [string] ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . copy ( dest ) [EOL] self . check_jar ( dest , copier ) [EOL] [EOL] copier . copy ( dest ) [EOL] self . check_jar ( dest , copier ) [EOL] [EOL] preloaded = [ [string] , [string] ] [EOL] copier . preload ( preloaded ) [EOL] copier . copy ( dest ) [EOL] [EOL] dest . seek ( [number] ) [EOL] jar = JarReader ( fileobj = dest ) [EOL] self . assertEqual ( [ f . filename for f in jar ] , preloaded + [ p for p in copier . paths ( ) if p not in preloaded ] ) [EOL] self . assertEqual ( jar . last_preloaded , preloaded [ - [number] ] ) [EOL] [EOL] def test_jarrer_compress ( self ) : [EOL] copier = Jarrer ( ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) ) [EOL] copier . add ( [string] , GeneratedFile ( [string] ) , compress = False ) [EOL] [EOL] dest = MockDest ( ) [EOL] copier . copy ( dest ) [EOL] self . check_jar ( dest , copier ) [EOL] [EOL] dest . seek ( [number] ) [EOL] jar = JarReader ( fileobj = dest ) [EOL] self . assertTrue ( jar [ [string] ] . compressed ) [EOL] self . assertFalse ( jar [ [string] ] . compressed ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $os.stat_result$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import typing [EOL] import vendored [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import mozunit [EOL] from mozpack . packager . formats import ( FlatFormatter , JarFormatter , OmniJarFormatter , ) [EOL] from mozpack . packager . unpack import unpack_to_registry [EOL] from mozpack . copier import ( FileCopier , FileRegistry , ) [EOL] from mozpack . test . test_packager_formats import ( CONTENTS , fill_formatter , get_contents , ) [EOL] from mozpack . test . test_files import TestWithTmpDir [EOL] [EOL] [EOL] class TestUnpack ( TestWithTmpDir ) : [EOL] maxDiff = None [EOL] [EOL] @ staticmethod def _get_copier ( cls ) : [EOL] copier = FileCopier ( ) [EOL] formatter = cls ( copier ) [EOL] fill_formatter ( formatter , CONTENTS ) [EOL] return copier [EOL] [EOL] @ classmethod def setUpClass ( cls ) : [EOL] cls . contents = get_contents ( cls . _get_copier ( FlatFormatter ) , read_all = True ) [EOL] [EOL] def _unpack_test ( self , cls ) : [EOL] [comment] [EOL] copier = self . _get_copier ( cls ) [EOL] copier . copy ( self . tmpdir ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] registry = FileRegistry ( ) [EOL] unpack_to_registry ( self . tmpdir , registry , getattr ( cls , [string] , None ) ) [EOL] self . assertEqual ( get_contents ( registry , read_all = True ) , self . contents ) [EOL] [EOL] def test_flat_unpack ( self ) : [EOL] self . _unpack_test ( FlatFormatter ) [EOL] [EOL] def test_jar_unpack ( self ) : [EOL] self . _unpack_test ( JarFormatter ) [EOL] [EOL] @ staticmethod def _omni_foo_formatter ( name ) : [EOL] class OmniFooFormatter ( OmniJarFormatter ) : [EOL] OMNIJAR_NAME = name [EOL] [EOL] def __init__ ( self , registry ) : [EOL] super ( OmniFooFormatter , self ) . __init__ ( registry , name ) [EOL] return OmniFooFormatter [EOL] [EOL] def test_omnijar_unpack ( self ) : [EOL] self . _unpack_test ( self . _omni_foo_formatter ( [string] ) ) [EOL] [EOL] def test_omnijar_subpath_unpack ( self ) : [EOL] self . _unpack_test ( self . _omni_foo_formatter ( [string] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[vendored.mozbuild.mozpack.test.test_packager_unpack.TestUnpack._omni_foo_formatter.OmniFooFormatter]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import os [EOL] [EOL] import mozunit [EOL] [EOL] from mozpack . copier import ( FileCopier , FileRegistry , ) [EOL] from mozpack . manifests import ( InstallManifest , UnreadableInstallManifest , ) [EOL] from mozpack . test . test_files import TestWithTmpDir [EOL] [EOL] [EOL] class TestInstallManifest ( TestWithTmpDir ) : [EOL] def test_construct ( self ) : [EOL] m = InstallManifest ( ) [EOL] self . assertEqual ( len ( m ) , [number] ) [EOL] [EOL] def test_malformed ( self ) : [EOL] f = self . tmppath ( [string] ) [EOL] open ( f , [string] ) . write ( [string] ) [EOL] with self . assertRaises ( UnreadableInstallManifest ) : [EOL] InstallManifest ( f ) [EOL] [EOL] def test_adds ( self ) : [EOL] m = InstallManifest ( ) [EOL] m . add_link ( [string] , [string] ) [EOL] m . add_copy ( [string] , [string] ) [EOL] m . add_required_exists ( [string] ) [EOL] m . add_optional_exists ( [string] ) [EOL] m . add_pattern_link ( [string] , [string] , [string] ) [EOL] m . add_pattern_copy ( [string] , [string] , [string] ) [EOL] m . add_preprocess ( [string] , [string] , [string] ) [EOL] m . add_content ( [string] , [string] ) [EOL] [EOL] self . assertEqual ( len ( m ) , [number] ) [EOL] self . assertIn ( [string] , m ) [EOL] self . assertIn ( [string] , m ) [EOL] self . assertIn ( [string] , m ) [EOL] self . assertIn ( [string] , m ) [EOL] self . assertIn ( [string] , m ) [EOL] self . assertIn ( [string] , m ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] m . add_link ( [string] , [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] m . add_copy ( [string] , [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] m . add_preprocess ( [string] , [string] , [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] m . add_required_exists ( [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] m . add_optional_exists ( [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] m . add_pattern_link ( [string] , [string] , [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] m . add_pattern_copy ( [string] , [string] , [string] ) [EOL] [EOL] with self . assertRaises ( ValueError ) : [EOL] m . add_content ( [string] , [string] ) [EOL] [EOL] def _get_test_manifest ( self ) : [EOL] m = InstallManifest ( ) [EOL] m . add_link ( self . tmppath ( [string] ) , [string] ) [EOL] m . add_copy ( self . tmppath ( [string] ) , [string] ) [EOL] m . add_preprocess ( self . tmppath ( [string] ) , [string] , self . tmppath ( [string] ) , [string] , { [string] : [string] , [string] : [string] } ) [EOL] m . add_required_exists ( [string] ) [EOL] m . add_optional_exists ( [string] ) [EOL] m . add_pattern_link ( [string] , [string] , [string] ) [EOL] m . add_pattern_copy ( [string] , [string] , [string] ) [EOL] m . add_content ( [string] , [string] ) [EOL] [EOL] return m [EOL] [EOL] def test_serialization ( self ) : [EOL] m = self . _get_test_manifest ( ) [EOL] [EOL] p = self . tmppath ( [string] ) [EOL] m . write ( path = p ) [EOL] self . assertTrue ( os . path . isfile ( p ) ) [EOL] [EOL] with open ( p , [string] ) as fh : [EOL] c = fh . read ( ) [EOL] [EOL] self . assertEqual ( c . count ( [string] ) , [number] ) [EOL] [EOL] lines = c . splitlines ( ) [EOL] self . assertEqual ( len ( lines ) , [number] ) [EOL] [EOL] self . assertEqual ( lines [ [number] ] , [string] ) [EOL] [EOL] m2 = InstallManifest ( path = p ) [EOL] self . assertEqual ( m , m2 ) [EOL] p2 = self . tmppath ( [string] ) [EOL] m2 . write ( path = p2 ) [EOL] [EOL] with open ( p2 , [string] ) as fh : [EOL] c2 = fh . read ( ) [EOL] [EOL] self . assertEqual ( c , c2 ) [EOL] [EOL] def test_populate_registry ( self ) : [EOL] m = self . _get_test_manifest ( ) [EOL] r = FileRegistry ( ) [EOL] m . populate_registry ( r ) [EOL] [EOL] self . assertEqual ( len ( r ) , [number] ) [EOL] self . assertEqual ( r . paths ( ) , [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_pattern_expansion ( self ) : [EOL] source = self . tmppath ( [string] ) [EOL] os . mkdir ( source ) [EOL] os . mkdir ( [string] % source ) [EOL] os . mkdir ( [string] % source ) [EOL] [EOL] with open ( [string] % source , [string] ) : [EOL] pass [EOL] [EOL] with open ( [string] % source , [string] ) : [EOL] pass [EOL] [EOL] m = InstallManifest ( ) [EOL] m . add_pattern_link ( [string] % source , [string] , [string] ) [EOL] [EOL] c = FileCopier ( ) [EOL] m . populate_registry ( c ) [EOL] self . assertEqual ( c . paths ( ) , [ [string] , [string] ] ) [EOL] [EOL] def test_write_expand_pattern ( self ) : [EOL] source = self . tmppath ( [string] ) [EOL] os . mkdir ( source ) [EOL] os . mkdir ( [string] % source ) [EOL] os . mkdir ( [string] % source ) [EOL] [EOL] with open ( [string] % source , [string] ) : [EOL] pass [EOL] [EOL] with open ( [string] % source , [string] ) : [EOL] pass [EOL] [EOL] m = InstallManifest ( ) [EOL] m . add_pattern_link ( [string] % source , [string] , [string] ) [EOL] [EOL] track = self . tmppath ( [string] ) [EOL] m . write ( path = track , expand_pattern = True ) [EOL] [EOL] m = InstallManifest ( path = track ) [EOL] self . assertEqual ( [ dest for dest in m . _dests ] , [ [string] , [string] ] ) [EOL] [EOL] def test_or ( self ) : [EOL] m1 = self . _get_test_manifest ( ) [EOL] orig_length = len ( m1 ) [EOL] m2 = InstallManifest ( ) [EOL] m2 . add_link ( [string] , [string] ) [EOL] m2 . add_copy ( [string] , [string] ) [EOL] [EOL] m1 |= m2 [EOL] [EOL] self . assertEqual ( len ( m2 ) , [number] ) [EOL] self . assertEqual ( len ( m1 ) , orig_length + [number] ) [EOL] [EOL] self . assertIn ( [string] , m1 ) [EOL] self . assertIn ( [string] , m1 ) [EOL] [EOL] def test_copier_application ( self ) : [EOL] dest = self . tmppath ( [string] ) [EOL] os . mkdir ( dest ) [EOL] [EOL] to_delete = self . tmppath ( [string] ) [EOL] with open ( to_delete , [string] ) : [EOL] pass [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) : [EOL] pass [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) : [EOL] pass [EOL] [EOL] m = self . _get_test_manifest ( ) [EOL] c = FileCopier ( ) [EOL] m . populate_registry ( c ) [EOL] result = c . copy ( dest ) [EOL] [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] self . assertFalse ( os . path . exists ( to_delete ) ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] self . assertEqual ( fh . read ( ) , [string] ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] self . assertEqual ( fh . read ( ) , [string] ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] self . assertEqual ( fh . read ( ) , [string] ) [EOL] [EOL] self . assertEqual ( result . updated_files , set ( self . tmppath ( p ) for p in ( [string] , [string] , [string] , [string] ) ) ) [EOL] self . assertEqual ( result . existing_files , set ( [ self . tmppath ( [string] ) , self . tmppath ( [string] ) ] ) ) [EOL] self . assertEqual ( result . removed_files , { to_delete } ) [EOL] self . assertEqual ( result . removed_directories , set ( ) ) [EOL] [EOL] def test_preprocessor ( self ) : [EOL] manifest = self . tmppath ( [string] ) [EOL] deps = self . tmppath ( [string] ) [EOL] dest = self . tmppath ( [string] ) [EOL] include = self . tmppath ( [string] ) [EOL] [EOL] with open ( include , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] time = os . path . getmtime ( include ) - [number] [EOL] os . utime ( include , ( time , time ) ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] fh . write ( [string] ) [EOL] time = os . path . getmtime ( self . tmppath ( [string] ) ) - [number] [EOL] os . utime ( self . tmppath ( [string] ) , ( time , time ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] m = InstallManifest ( ) [EOL] m . add_preprocess ( self . tmppath ( [string] ) , [string] , deps , [string] , { [string] : [string] , [string] : [string] } ) [EOL] m . write ( path = manifest ) [EOL] [EOL] m = InstallManifest ( path = manifest ) [EOL] c = FileCopier ( ) [EOL] m . populate_registry ( c ) [EOL] c . copy ( dest ) [EOL] [EOL] self . assertTrue ( os . path . exists ( self . tmppath ( [string] ) ) ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] self . assertEqual ( fh . read ( ) , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] m2 = InstallManifest ( ) [EOL] m2 . add_preprocess ( self . tmppath ( [string] ) , [string] , deps , [string] , { [string] : True } ) [EOL] c = FileCopier ( ) [EOL] m2 . populate_registry ( c ) [EOL] result = c . copy ( dest ) [EOL] [EOL] self . assertFalse ( self . tmppath ( [string] ) in result . updated_files ) [EOL] self . assertTrue ( self . tmppath ( [string] ) in result . existing_files ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] m2 . write ( path = manifest ) [EOL] time = os . path . getmtime ( manifest ) - [number] [EOL] os . utime ( self . tmppath ( [string] ) , ( time , time ) ) [EOL] m2 = InstallManifest ( path = manifest ) [EOL] c = FileCopier ( ) [EOL] m2 . populate_registry ( c ) [EOL] self . assertTrue ( c . copy ( dest ) ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] self . assertEqual ( fh . read ( ) , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] time = os . path . getmtime ( manifest ) - [number] [EOL] os . utime ( manifest , ( time , time ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with open ( include , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] [EOL] time = os . path . getmtime ( include ) - [number] [EOL] os . utime ( self . tmppath ( [string] ) , ( time , time ) ) [EOL] c = FileCopier ( ) [EOL] m2 . populate_registry ( c ) [EOL] self . assertTrue ( c . copy ( dest ) ) [EOL] [EOL] with open ( self . tmppath ( [string] ) , [string] ) as fh : [EOL] self . assertEqual ( fh . read ( ) , [string] ) [EOL] [EOL] def test_preprocessor_dependencies ( self ) : [EOL] manifest = self . tmppath ( [string] ) [EOL] deps = self . tmppath ( [string] ) [EOL] dest = self . tmppath ( [string] ) [EOL] source = self . tmppath ( [string] ) [EOL] destfile = self . tmppath ( [string] ) [EOL] include = self . tmppath ( [string] ) [EOL] os . mkdir ( dest ) [EOL] [EOL] with open ( source , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] time = os . path . getmtime ( source ) - [number] [EOL] os . utime ( source , ( time , time ) ) [EOL] [EOL] with open ( include , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] time = os . path . getmtime ( source ) - [number] [EOL] os . utime ( include , ( time , time ) ) [EOL] [EOL] [comment] [EOL] m = InstallManifest ( ) [EOL] m . add_preprocess ( source , [string] , deps , [string] , { [string] : [string] , [string] : [string] } ) [EOL] m . write ( path = manifest ) [EOL] [EOL] time = os . path . getmtime ( source ) - [number] [EOL] os . utime ( manifest , ( time , time ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] m = InstallManifest ( path = manifest ) [EOL] c = FileCopier ( ) [EOL] m . populate_registry ( c ) [EOL] self . assertTrue ( c . copy ( dest ) ) [EOL] [EOL] with open ( destfile , [string] ) as fh : [EOL] self . assertEqual ( fh . read ( ) , [string] ) [EOL] [EOL] [comment] [EOL] with open ( source , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] time = os . path . getmtime ( source ) - [number] [EOL] os . utime ( destfile , ( time , time ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] m = InstallManifest ( path = manifest ) [EOL] c = FileCopier ( ) [EOL] m . populate_registry ( c ) [EOL] c . copy ( dest ) [EOL] [EOL] with open ( destfile , [string] ) as fh : [EOL] self . assertEqual ( fh . read ( ) , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] time = os . path . getmtime ( source ) - [number] [EOL] os . utime ( source , ( time , time ) ) [EOL] [EOL] [comment] [EOL] with open ( include , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] time = os . path . getmtime ( include ) - [number] [EOL] os . utime ( destfile , ( time , time ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] m = InstallManifest ( path = manifest ) [EOL] c = FileCopier ( ) [EOL] m . populate_registry ( c ) [EOL] c . copy ( dest ) [EOL] [EOL] with open ( destfile , [string] ) as fh : [EOL] self . assertEqual ( fh . read ( ) , [string] ) [EOL] [EOL] [comment] [EOL] m = InstallManifest ( ) [EOL] m |= InstallManifest ( path = manifest ) [EOL] c = FileCopier ( ) [EOL] m . populate_registry ( c ) [EOL] e = c . _files [ [string] ] [EOL] self . assertEqual ( e . extra_depends , [ manifest ] ) [EOL] [EOL] def test_add_entries_from ( self ) : [EOL] source = self . tmppath ( [string] ) [EOL] os . mkdir ( source ) [EOL] os . mkdir ( [string] % source ) [EOL] os . mkdir ( [string] % source ) [EOL] [EOL] with open ( [string] % source , [string] ) : [EOL] pass [EOL] [EOL] with open ( [string] % source , [string] ) : [EOL] pass [EOL] [EOL] m = InstallManifest ( ) [EOL] m . add_pattern_link ( [string] % source , [string] , [string] ) [EOL] [EOL] p = InstallManifest ( ) [EOL] p . add_entries_from ( m ) [EOL] self . assertEqual ( len ( p ) , [number] ) [EOL] [EOL] c = FileCopier ( ) [EOL] p . populate_registry ( c ) [EOL] self . assertEqual ( c . paths ( ) , [ [string] , [string] ] ) [EOL] [EOL] q = InstallManifest ( ) [EOL] q . add_entries_from ( m , base = [string] ) [EOL] self . assertEqual ( len ( q ) , [number] ) [EOL] [EOL] d = FileCopier ( ) [EOL] q . populate_registry ( d ) [EOL] self . assertEqual ( d . paths ( ) , [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] r = InstallManifest ( ) [EOL] r . add_entries_from ( m ) [EOL] r . add_entries_from ( m , base = [string] ) [EOL] self . assertEqual ( len ( r ) , [number] ) [EOL] [EOL] temp_path = self . tmppath ( [string] ) [EOL] r . write ( path = temp_path ) [EOL] [EOL] s = InstallManifest ( path = temp_path ) [EOL] e = FileCopier ( ) [EOL] s . populate_registry ( e ) [EOL] [EOL] self . assertEqual ( e . paths ( ) , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] mozunit . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import os [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] project_dir = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] with open ( os . path . join ( project_dir , [string] ) ) as f : [EOL] version = f . read ( ) . rstrip ( ) [EOL] [EOL] [comment] [EOL] with open ( os . path . join ( project_dir , [string] ) ) as f : [EOL] requirements = [ line . rstrip ( [string] ) for line in f if not line . startswith ( [string] ) ] [EOL] [EOL] with open ( os . path . join ( project_dir , [string] ) ) as f : [EOL] long_description = f . read ( ) [EOL] [EOL] [EOL] setup ( name = [string] , version = version , description = [string] , long_description = long_description , long_description_content_type = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( [string] ) , package_data = { [string] : [ [string] ] } , package_dir = { [string] : [string] } , include_package_data = True , zip_safe = False , entry_points = { [string] : [ [string] ] } , license = [string] , install_requires = requirements , classifiers = ( [string] , [string] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
def filter_out_identical_values ( list_ ) : [EOL] return list ( set ( list_ ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import io [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import contextlib [EOL] import logging [EOL] import os [EOL] [EOL] from scriptworker import artifacts , client [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] from pushapkscript import jarsigner , manifest , publish , task [EOL] from pushapkscript . exceptions import ConfigValidationError [EOL] from pushapkscript . publish_config import get_publish_config [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_main ( context ) : [EOL] android_product = task . extract_android_product_from_scopes ( context ) [EOL] product_config = _get_product_config ( context , android_product ) [EOL] publish_config = get_publish_config ( product_config , context . task [ [string] ] , android_product ) [EOL] contact_server = not bool ( context . config . get ( [string] ) ) [EOL] [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] _log_warning_forewords ( contact_server , publish_config [ [string] ] , publish_config [ [string] ] ) [EOL] [EOL] log . info ( [string] ) [EOL] artifacts_per_task_id , failed_artifacts_per_task_id = artifacts . get_upstream_artifacts_full_paths_per_task_id ( context ) [EOL] [EOL] all_apks_paths = [ artifact for artifacts_list in artifacts_per_task_id . values ( ) for artifact in artifacts_list if artifact . endswith ( [string] ) ] [EOL] [EOL] if not publish_config . get ( [string] , True ) : [EOL] log . info ( [string] ) [EOL] for apk_path in all_apks_paths : [EOL] jarsigner . verify ( context , publish_config , apk_path ) [EOL] manifest . verify ( product_config , apk_path ) [EOL] else : [EOL] log . info ( [string] [string] ) [EOL] [EOL] log . info ( [string] ) [EOL] with contextlib . ExitStack ( ) as stack : [EOL] files = [ stack . enter_context ( open ( apk_file_name ) ) for apk_file_name in all_apks_paths ] [EOL] publish . publish ( product_config , publish_config , files , contact_server ) [EOL] [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] def _get_product_config ( context , android_product ) : [EOL] try : [EOL] products = context . config [ [string] ] [EOL] except KeyError : [EOL] raise ConfigValidationError ( [string] ) [EOL] [EOL] matching_products = [ product for product in products if android_product in product [ [string] ] ] [EOL] [EOL] if len ( matching_products ) == [number] : [EOL] raise TaskVerificationError ( [string] [string] [string] . format ( android_product ) ) [EOL] [EOL] if len ( matching_products ) > [number] : [EOL] raise TaskVerificationError ( [string] [string] . format ( android_product ) ) [EOL] [EOL] return matching_products [ [number] ] [EOL] [EOL] [EOL] def _log_warning_forewords ( contact_server , dry_run , target_store ) : [EOL] if contact_server : [EOL] if target_store == [string] : [EOL] log . warning ( [string] [string] [string] ) [EOL] elif target_store == [string] : [EOL] if not dry_run : [EOL] log . warning ( [string] ) [EOL] else : [EOL] log . warning ( [string] ) [EOL] else : [EOL] log . warning ( [string] ) [EOL] [EOL] [EOL] def get_default_config ( ) : [EOL] cwd = os . getcwd ( ) [EOL] parent_dir = os . path . dirname ( cwd ) [EOL] [EOL] return { [string] : os . path . join ( parent_dir , [string] ) , [string] : os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) , [string] : False , } [EOL] [EOL] [EOL] def main ( config_path = None ) : [EOL] client . sync_main ( async_main , config_path = config_path , default_config = get_default_config ( ) ) [EOL] [EOL] [EOL] __name__ == [string] and main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import subprocess [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import subprocess [EOL] [EOL] from pushapkscript . exceptions import SignatureError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def verify ( context , publish_config , apk_path ) : [EOL] binary_path , keystore_path , certificate_alias = _pluck_configuration ( context , publish_config ) [EOL] [EOL] completed_process = subprocess . run ( [ binary_path , [string] , [string] , [string] , [string] , keystore_path , apk_path , certificate_alias ] , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = True , ) [EOL] [EOL] command_output = completed_process . stdout [EOL] _check_certificate_via_return_code ( completed_process . returncode , command_output , binary_path , apk_path , certificate_alias , keystore_path ) [EOL] [EOL] [EOL] def _check_certificate_via_return_code ( return_code , command_output , binary_path , apk_path , certificate_alias , keystore_path ) : [EOL] if return_code != [number] : [EOL] log . critical ( command_output ) [EOL] raise SignatureError ( [string] . format ( binary_path , apk_path , certificate_alias , keystore_path ) ) [EOL] [EOL] log . info ( [string] . format ( apk_path , certificate_alias ) ) [EOL] [EOL] [EOL] def _pluck_configuration ( context , publish_config ) : [EOL] keystore_path = context . config [ [string] ] [EOL] [comment] [EOL] binary_path = context . config . get ( [string] , [string] ) [EOL] [EOL] return binary_path , keystore_path , publish_config [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def _google_should_do_dry_run ( task ) : [EOL] [comment] [EOL] [comment] [EOL] return not task . get ( [string] , False ) [EOL] [EOL] [EOL] def _handle_legacy_google_track ( google_track ) : [EOL] if google_track == [string] : [EOL] log . warn ( [string] [string] [string] ) [EOL] return [string] [EOL] return google_track [EOL] [EOL] [EOL] def _get_single_google_app_publish_config ( product_config , task ) : [EOL] publish_config = product_config [ [string] ] [EOL] rollout_percentage = task . get ( [string] ) [EOL] google_track = task [ [string] ] [EOL] google_track = _handle_legacy_google_track ( google_track ) [EOL] return { [string] : [string] , [string] : _google_should_do_dry_run ( task ) , [string] : publish_config . get ( [string] ) , [string] : publish_config [ [string] ] , [string] : publish_config [ [string] ] , [string] : publish_config [ [string] ] , [string] : google_track , [string] : rollout_percentage , } [EOL] [EOL] [EOL] def _get_google_app_by_scope_publish_config ( product_config , task , scope_product ) : [EOL] publish_config = product_config [ [string] ] [ scope_product ] [EOL] rollout_percentage = task . get ( [string] ) [EOL] google_track = task . get ( [string] , publish_config [ [string] ] ) [EOL] google_track = _handle_legacy_google_track ( google_track ) [EOL] return { [string] : [string] , [string] : _google_should_do_dry_run ( task ) , [string] : publish_config . get ( [string] ) , [string] : publish_config [ [string] ] , [string] : publish_config [ [string] ] , [string] : publish_config [ [string] ] , [string] : google_track , [string] : rollout_percentage , } [EOL] [EOL] [EOL] def _get_channel_publish_config ( product_config , task ) : [EOL] publish_config = product_config [ [string] ] [ task [ [string] ] ] [EOL] target_store = task . get ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if target_store : [EOL] if not publish_config . get ( target_store ) : [EOL] raise ValueError ( [string] [string] . format ( target_store , task [ [string] ] ) ) [EOL] elif publish_config . get ( [string] ) and not publish_config . get ( [string] ) : [EOL] target_store = [string] [EOL] elif publish_config . get ( [string] ) and not publish_config . get ( [string] ) : [EOL] target_store = [string] [EOL] else : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] store_config = publish_config [ target_store ] [EOL] if target_store == [string] : [EOL] if task . get ( [string] ) or task . get ( [string] ) or task . get ( [string] ) : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] return { [string] : [string] , [string] : False , [string] : publish_config . get ( [string] ) , [string] : store_config [ [string] ] , [string] : store_config [ [string] ] , [string] : publish_config [ [string] ] , } [EOL] else : [EOL] rollout_percentage = task . get ( [string] ) [EOL] google_track = task . get ( [string] , store_config [ [string] ] ) [EOL] google_track = _handle_legacy_google_track ( google_track ) [EOL] [EOL] return { [string] : [string] , [string] : _google_should_do_dry_run ( task ) , [string] : publish_config . get ( [string] ) , [string] : store_config [ [string] ] , [string] : store_config [ [string] ] , [string] : publish_config [ [string] ] , [string] : google_track , [string] : rollout_percentage , } [EOL] [EOL] [EOL] def get_publish_config ( product_config , task , scope_product ) : [EOL] override_channel_model = product_config . get ( [string] ) [EOL] if override_channel_model == [string] : [EOL] [comment] [EOL] [comment] [EOL] return _get_single_google_app_publish_config ( product_config , task ) [EOL] [EOL] elif override_channel_model == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return _get_google_app_by_scope_publish_config ( product_config , task , scope_product ) [EOL] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] return _get_channel_publish_config ( product_config , task ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from scriptworker . constants import STATUSES [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] [EOL] class SignatureError ( ScriptWorkerTaskException ) : [EOL] def __init__ ( self , msg ) : [EOL] super ( ) . __init__ ( msg , exit_code = STATUSES [ [string] ] ) [EOL] [EOL] [EOL] class ConfigValidationError ( ScriptWorkerTaskException ) : [EOL] def __init__ ( self , msg ) : [EOL] super ( ) . __init__ ( msg , exit_code = STATUSES [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] from scriptworker . utils import get_single_item_from_sequence [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def extract_android_product_from_scopes ( context ) : [EOL] prefixes = _get_scope_prefixes ( context ) [EOL] scopes = context . task [ [string] ] [EOL] [EOL] scope , prefix = get_single_item_from_sequence ( sequence = [ ( scope , prefix ) for scope in scopes for prefix in prefixes ] , condition = lambda scope_then_prefix : scope_then_prefix [ [number] ] . startswith ( scope_then_prefix [ [number] ] ) , ErrorClass = TaskVerificationError , no_item_error_message = [string] . format ( prefixes ) , too_many_item_error_message = [string] . format ( prefixes ) , ) [EOL] [EOL] android_product = scope . split ( [string] ) [ prefix . count ( [string] ) ] [comment] [EOL] [EOL] return android_product [EOL] [EOL] [EOL] def _get_scope_prefixes ( context ) : [EOL] prefixes = context . config [ [string] ] [EOL] return [ prefix if prefix . endswith ( [string] ) else [string] . format ( prefix ) for prefix in prefixes ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List , Pattern [EOL] import typing [EOL] import logging [EOL] import io [EOL] import logging [EOL] import re [EOL] from zipfile import ZipFile [EOL] [EOL] from pushapkscript . exceptions import SignatureError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] _NAME_MARKER = [string] [EOL] _DIGEST_MARKER_PATTERN = re . compile ( [string] ) [EOL] [EOL] [EOL] def verify ( product_config , apk_path ) : [EOL] [comment] [EOL] expected_digest_algorithm = product_config [ [string] ] [EOL] if not _does_apk_have_expected_digest ( apk_path , expected_digest_algorithm ) : [EOL] raise SignatureError ( [string] . format ( expected_digest_algorithm ) ) [EOL] [EOL] log . info ( [string] . format ( apk_path , expected_digest_algorithm ) ) [EOL] [EOL] [EOL] def _does_apk_have_expected_digest ( apk_path , expected_digest ) : [EOL] with ZipFile ( apk_path ) as zip : [EOL] with zip . open ( [string] ) as f : [EOL] [comment] [EOL] manifest_lines = [ line for line in io . TextIOWrapper ( f , [string] ) ] [EOL] [EOL] manifest = _parse_manifest_lines ( manifest_lines ) [EOL] return _is_digest_present ( expected_digest , manifest ) [EOL] [EOL] [EOL] def _parse_manifest_lines ( manifest_lines ) : [EOL] manifest = { } [EOL] current_file = None [EOL] for line in manifest_lines : [EOL] line = line . rstrip ( [string] ) [comment] [EOL] [comment] [EOL] if line . startswith ( _NAME_MARKER ) : [EOL] current_file = line [ len ( _NAME_MARKER ) : ] [EOL] elif current_file : [EOL] if line . startswith ( [string] ) : [EOL] current_file = current_file + line . lstrip ( ) [EOL] elif _DIGEST_MARKER_PATTERN . match ( line ) : [EOL] digest , hash = line . split ( [string] ) [EOL] manifest . setdefault ( current_file , { } ) [ digest ] = hash [EOL] [EOL] return manifest [EOL] [EOL] [EOL] def _is_digest_present ( expected_digest , parsed_manifest ) : [EOL] if not parsed_manifest : [EOL] return False [EOL] [EOL] expected_digest = [string] . format ( expected_digest ) [EOL] return all ( expected_digest in entry for entry in parsed_manifest . values ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import logging [EOL] [EOL] from mozapkpublisher . push_apk import push_apk [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def publish ( product_config , publish_config , apk_files , contact_server ) : [EOL] push_apk ( apks = apk_files , target_store = publish_config [ [string] ] , username = publish_config [ [string] ] , secret = publish_config [ [string] ] , expected_package_names = publish_config [ [string] ] , track = publish_config . get ( [string] ) , rollout_percentage = publish_config . get ( [string] ) , dry_run = publish_config [ [string] ] , contact_server = contact_server , skip_check_ordered_version_codes = bool ( product_config . get ( [string] ) ) , skip_check_multiple_locales = bool ( product_config . get ( [string] ) ) , skip_check_same_locales = bool ( product_config . get ( [string] ) ) , skip_checks_fennec = bool ( product_config . get ( [string] ) ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Union , Any , Dict , List [EOL] import typing [EOL] import pytest [EOL] [EOL] from pushapkscript . publish_config import _google_should_do_dry_run , get_publish_config [EOL] [EOL] AURORA_CONFIG = { [string] : [string] , [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } } , } [EOL] [EOL] FOCUS_CONFIG = { [string] : [string] , [string] : { [string] : [string] , [string] : [ [string] ] , [string] : [string] , [string] : [string] , } , } [EOL] [EOL] FENIX_CONFIG = { [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , } } } [EOL] [EOL] ANY_STORE_CONFIG = { [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } } } [EOL] [EOL] [EOL] def test_get_publish_config_fennec ( ) : [EOL] assert get_publish_config ( AURORA_CONFIG , { } , [string] ) == { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def test_get_publish_config_fennec_track_override ( ) : [EOL] assert get_publish_config ( AURORA_CONFIG , { [string] : [string] } , [string] ) == { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def test_get_publish_config_fennec_rollout ( ) : [EOL] assert get_publish_config ( AURORA_CONFIG , { [string] : [number] } , [string] ) == { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def test_get_publish_config_focus ( ) : [EOL] payload = { [string] : [string] } [EOL] assert get_publish_config ( FOCUS_CONFIG , payload , [string] ) == { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def test_get_publish_config_focus_rollout ( ) : [EOL] payload = { [string] : [string] , [string] : [number] } [EOL] assert get_publish_config ( FOCUS_CONFIG , payload , [string] ) == { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def test_get_publish_config_fenix ( ) : [EOL] payload = { [string] : [string] } [EOL] assert get_publish_config ( FENIX_CONFIG , payload , [string] ) == { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def test_get_publish_config_fenix_rollout ( ) : [EOL] payload = { [string] : [string] , [string] : [number] } [EOL] assert get_publish_config ( FENIX_CONFIG , payload , [string] ) == { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def test_ambiguous_target ( ) : [EOL] payload = { [string] : [string] } [EOL] with pytest . raises ( ValueError ) : [EOL] get_publish_config ( ANY_STORE_CONFIG , payload , [string] ) [EOL] [EOL] [EOL] def test_target_google ( ) : [EOL] payload = { [string] : [string] , [string] : [string] } [EOL] assert get_publish_config ( ANY_STORE_CONFIG , payload , [string] ) == { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def test_target_amazon ( ) : [EOL] payload = { [string] : [string] , [string] : [string] } [EOL] assert get_publish_config ( ANY_STORE_CONFIG , payload , [string] ) == { [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] [EOL] [EOL] def test_google_params_for_amazon ( ) : [EOL] payload = { [string] : [string] , [string] : [string] , [string] : [number] } [EOL] with pytest . raises ( ValueError ) : [EOL] assert get_publish_config ( ANY_STORE_CONFIG , payload , [string] ) [EOL] [EOL] [EOL] def test_incorrect_target ( ) : [EOL] google_only_config = { [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , } } } [EOL] payload = { [string] : [string] , [string] : [string] } [EOL] with pytest . raises ( ValueError ) : [EOL] get_publish_config ( google_only_config , payload , [string] ) [EOL] [EOL] amazon_only_config = { [string] : { [string] : { [string] : [ [string] ] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , } } } [EOL] payload = { [string] : [string] , [string] : [string] } [EOL] with pytest . raises ( ValueError ) : [EOL] get_publish_config ( amazon_only_config , payload , [string] ) [EOL] [EOL] [EOL] def test_google_should_do_dry_run ( ) : [EOL] task_payload = { [string] : True } [EOL] assert _google_should_do_dry_run ( task_payload ) is False [EOL] [EOL] task_payload = { [string] : False } [EOL] assert _google_should_do_dry_run ( task_payload ) is True [EOL] [EOL] task_payload = { } [EOL] assert _google_should_do_dry_run ( task_payload ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import os [EOL] from zipfile import ZipFile [EOL] [EOL] import pytest [EOL] [EOL] from pushapkscript import manifest [EOL] from pushapkscript . exceptions import SignatureError [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( True , False ) , ( False , True ) ) ) def test_verify ( monkeypatch , does_apk_have_expected_digest , raises ) : [EOL] monkeypatch . setattr ( manifest , [string] , lambda _ , __ : does_apk_have_expected_digest ) [EOL] product_config = { [string] : [string] } [EOL] [EOL] if raises : [EOL] with pytest . raises ( SignatureError ) : [EOL] manifest . verify ( product_config , [string] ) [EOL] else : [EOL] manifest . verify ( product_config , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , False ) , ( [string] , [string] , True , ) , ( [string] , [string] , True , ) , ( [string] , [string] , False , ) , ( [string] , [string] , False , ) , ) , ) def test_does_apk_have_expected_digest ( tmpdir , manifest_data , digest , expected ) : [EOL] apk_path = os . path . join ( tmpdir , [string] ) [EOL] with ZipFile ( apk_path , mode = [string] ) as zip : [EOL] zip . writestr ( [string] , manifest_data ) [EOL] [EOL] assert manifest . _does_apk_have_expected_digest ( apk_path , digest ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ ] , { } ) , ( [ [string] , [string] , [string] , [string] ] , { } ) , ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , { [string] : { [string] : [string] } , [string] : { [string] : [string] } } , ) , ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } , ) , ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , { [string] : { [string] : [string] } , [string] : { [string] : [string] } } , ) , ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , { [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , ) , ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , { [string] : { [string] : [string] } , [string] : { [string] : [string] } } , ) , ) , ) def test_parse_manifest_lines ( lines , expected ) : [EOL] assert manifest . _parse_manifest_lines ( lines ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , { } , False ) , ( [string] , { [string] : { [string] : [string] } , [string] : { [string] : [string] } } , True ) , ( [string] , { [string] : { [string] : [string] } , [string] : { [string] : [string] } } , True ) , ( [string] , { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } , True , ) , ( [string] , { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } , True , ) , ( [string] , { [string] : { [string] : [string] } , [string] : { [string] : [string] } } , False ) , ( [string] , { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , } , False , ) , ) , ) def test_is_digest_present ( digest , manifest_data , expected ) : [EOL] assert manifest . _is_digest_present ( digest , manifest_data ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] import os [EOL] from unittest . mock import MagicMock , patch [EOL] [EOL] import pytest [EOL] from scriptworker import artifacts , client [EOL] from scriptworker . context import Context [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] import pushapkscript [EOL] from pushapkscript import jarsigner , manifest , publish , task [EOL] from pushapkscript . exceptions import ConfigValidationError [EOL] from pushapkscript . script import _get_product_config , _log_warning_forewords , async_main , get_default_config , main [EOL] [EOL] from . helpers . mock_file import mock_open [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] , [string] ) ) async def test_async_main ( monkeypatch , android_product ) : [EOL] monkeypatch . setattr ( artifacts , [string] , lambda _ : ( { [string] : [ [string] , [string] ] , [string] : [ [string] ] } , { } ) , ) [EOL] monkeypatch . setattr ( jarsigner , [string] , lambda _ , __ , ___ : None ) [EOL] monkeypatch . setattr ( manifest , [string] , lambda _ , __ : None ) [EOL] monkeypatch . setattr ( task , [string] , lambda _ : android_product ) [EOL] monkeypatch . setattr ( pushapkscript . script , [string] , lambda _ , __ : { [string] : { android_product : { [string] : [ android_product ] , [string] : android_product , [string] : { [string] : [string] , [string] : android_product , [string] : [string] . format ( android_product ) } , } } } , ) [EOL] [EOL] context = MagicMock ( ) [EOL] context . config = { [string] : True } [EOL] context . task = { [string] : { [string] : android_product } } [EOL] [EOL] def assert_google_play_call ( _ , __ , all_apks_files , ___ ) : [EOL] assert sorted ( [ file . name for file in all_apks_files ] ) == [ [string] , [string] , [string] ] [EOL] [EOL] monkeypatch . setattr ( publish , [string] , assert_google_play_call ) [EOL] [EOL] with patch ( [string] , new = mock_open ) : [EOL] await async_main ( context ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_main_no_signature_verify ( monkeypatch ) : [EOL] context = MagicMock ( ) [EOL] context . task [ [string] ] = [string] [EOL] [EOL] [comment] [EOL] monkeypatch . setattr ( pushapkscript . script . task , [string] , lambda _ : [string] ) [EOL] monkeypatch . setattr ( pushapkscript . script , [string] , lambda _ , __ , ___ : { [string] : True , [string] : [string] } ) [EOL] monkeypatch . setattr ( pushapkscript . script . publish , [string] , lambda _ , __ , ___ , ____ : None ) [EOL] [EOL] [comment] [EOL] monkeypatch . setattr ( pushapkscript . script , [string] , lambda _ , __ : { [string] : True } ) [EOL] [EOL] with patch . object ( pushapkscript . script , [string] ) as mock_jarsigner : [EOL] with patch ( [string] , new = mock_open ) : [EOL] await async_main ( context ) [EOL] mock_jarsigner . assert_not_called ( ) [EOL] [EOL] [EOL] def test_get_product_config_validation ( ) : [EOL] context = Context ( ) [EOL] context . config = { } [EOL] [EOL] with pytest . raises ( ConfigValidationError ) : [EOL] _get_product_config ( context , [string] ) [EOL] [EOL] [EOL] def test_get_product_config_unknown_product ( ) : [EOL] context = Context ( ) [EOL] context . config = { [string] : [ { [string] : [ [string] ] } ] } [EOL] [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] _get_product_config ( context , [string] ) [EOL] [EOL] [EOL] def test_get_product_config ( ) : [EOL] context = Context ( ) [EOL] context . config = { [string] : [ { [string] : [ [string] ] , [string] : [string] } ] } [EOL] [EOL] assert _get_product_config ( context , [string] ) == { [string] : [ [string] ] , [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( True , False , [string] , [string] , ) , ( True , True , [string] , [string] ) , ( False , True , [string] , [string] ) , ( False , False , [string] , [string] ) , ( True , False , [string] , [string] [string] , ) , ) , ) def test_log_warning_forewords ( caplog , monkeypatch , is_allowed_to_push , dry_run , target_store , expected ) : [EOL] _log_warning_forewords ( is_allowed_to_push , dry_run , target_store ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert expected in caplog . text [EOL] [EOL] [EOL] def test_get_default_config ( ) : [EOL] parent_dir = os . path . dirname ( os . getcwd ( ) ) [EOL] assert get_default_config ( ) == { [string] : os . path . join ( parent_dir , [string] ) , [string] : os . path . join ( os . path . dirname ( pushapkscript . __file__ ) , [string] ) , [string] : False , } [EOL] [EOL] [EOL] def test_main ( monkeypatch ) : [EOL] sync_main_mock = MagicMock ( ) [EOL] monkeypatch . setattr ( client , [string] , sync_main_mock ) [EOL] main ( ) [EOL] sync_main_mock . asset_called_once_with ( async_main , default_config = get_default_config ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] import pytest [EOL] from scriptworker . client import validate_task_schema [EOL] from scriptworker . context import Context [EOL] from scriptworker . exceptions import TaskVerificationError [EOL] [EOL] import pushapkscript [EOL] from pushapkscript . task import extract_android_product_from_scopes [EOL] [EOL] from . helpers . task_generator import TaskGenerator [EOL] [EOL] [EOL] @ pytest . fixture def context ( ) : [EOL] context_ = Context ( ) [EOL] context_ . config = { [string] : os . path . join ( os . path . dirname ( pushapkscript . __file__ ) , [string] ) } [EOL] return context_ [EOL] [EOL] [EOL] def test_validate_task ( context ) : [EOL] context . task = TaskGenerator ( ) . generate_task ( [string] ) [EOL] validate_task_schema ( context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] ] , [string] : [string] , [string] : [ [string] , [string] , ] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : { [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [string] } , { [string] : [ [string] ] , [string] : [string] , [string] : [string] } , ] , [string] : [string] , [string] : True , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] } , [string] : { [string] : [ [string] , [string] ] , [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : { [string] : [string] } , [string] : [string] , [string] : [number] , [string] : [string] , } , } , } , ) , ) def test_validate_real_life_tasks ( context , task ) : [EOL] context . task = task [EOL] validate_task_schema ( context ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] ] , [ [string] ] , False , [string] ) , ( [ [string] ] , [ [string] ] , False , [string] ) , ( [ [string] ] , [ [string] ] , False , [string] ) , ( [ [string] ] , [ [string] ] , False , [string] ) , ( [ [string] ] , [ [string] ] , False , [string] , ) , ( [ [string] ] , [ [string] ] , False , [string] , ) , ( [ [string] ] , [ ] , True , None ) , ( [ ] , [ [string] ] , True , None ) , ( [ [string] ] , [ [string] , [string] ] , True , None ) , ( [ [string] , [string] ] , [ [string] , [string] ] , True , None , ) , ( [ [string] ] , [ [string] , [string] , ] , True , None , ) , ( [ [string] , [string] ] , [ [string] , [string] ] , True , None , ) , ) , ) def test_extract_supported_android_products ( context , prefixes , scopes , raises , expected ) : [EOL] context . task = { [string] : scopes } [EOL] context . config = { [string] : prefixes } [EOL] [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] extract_android_product_from_scopes ( context ) [EOL] else : [EOL] assert extract_android_product_from_scopes ( context ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List [EOL] import typing [EOL] import pushapkscript [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] from pushapkscript . publish import publish [EOL] [EOL] from . helpers . mock_file import MockFile , mock_open [EOL] [EOL] [EOL] [comment] [EOL] @ patch ( [string] , new = mock_open ) @ patch ( [string] ) class PublishTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . publish_config = { [string] : [string] , [string] : True , [string] : [string] , [string] : [ [string] ] , [string] : [string] , [string] : [string] , } [EOL] self . apks = [ MockFile ( [string] ) , MockFile ( [string] ) ] [EOL] [EOL] def test_publish_config ( self , mock_push_apk ) : [EOL] publish ( { } , self . publish_config , self . apks , contact_server = True ) [EOL] [EOL] mock_push_apk . assert_called_with ( apks = [ MockFile ( [string] ) , MockFile ( [string] ) ] , target_store = [string] , username = [string] , secret = [string] , track = [string] , expected_package_names = [ [string] ] , rollout_percentage = None , dry_run = True , contact_server = True , skip_check_multiple_locales = False , skip_check_ordered_version_codes = False , skip_check_same_locales = False , skip_checks_fennec = False , ) [EOL] [EOL] def test_publish_allows_rollout_percentage ( self , mock_push_apk ) : [EOL] publish_config = { [string] : [string] , [string] : True , [string] : [string] , [string] : [number] , [string] : [ [string] ] , [string] : [string] , [string] : [string] , } [EOL] publish ( { } , publish_config , self . apks , contact_server = True ) [EOL] _ , args = mock_push_apk . call_args [EOL] assert args [ [string] ] == [string] [EOL] assert args [ [string] ] == [number] [EOL] [EOL] def test_craft_push_config_allows_to_contact_google_play_or_not ( self , mock_push_apk ) : [EOL] publish ( { } , self . publish_config , self . apks , contact_server = True ) [EOL] _ , args = mock_push_apk . call_args [EOL] assert args [ [string] ] is True [EOL] [EOL] publish ( { } , self . publish_config , self . apks , False ) [EOL] _ , args = mock_push_apk . call_args [EOL] assert args [ [string] ] is False [EOL] [EOL] def test_craft_push_config_skip_checking_multiple_locales ( self , mock_push_apk ) : [EOL] product_config = { [string] : True } [EOL] publish ( product_config , self . publish_config , self . apks , contact_server = True ) [EOL] _ , args = mock_push_apk . call_args [EOL] assert args [ [string] ] is True [EOL] [EOL] def test_craft_push_config_skip_checking_same_locales ( self , mock_push_apk ) : [EOL] product_config = { [string] : True } [EOL] publish ( product_config , self . publish_config , self . apks , contact_server = True ) [EOL] _ , args = mock_push_apk . call_args [EOL] assert args [ [string] ] is True [EOL] [EOL] def test_craft_push_config_expect_package_names ( self , mock_push_apk ) : [EOL] publish_config = { [string] : [string] , [string] : True , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , } [EOL] publish ( { } , publish_config , self . apks , contact_server = True ) [EOL] _ , args = mock_push_apk . call_args [EOL] assert args [ [string] ] == [ [string] , [string] ] [EOL] [EOL] def test_craft_push_config_allows_committing_apks ( self , mock_push_apk ) : [EOL] publish_config = { [string] : [string] , [string] : False , [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : [string] , } [EOL] publish ( { } , publish_config , self . apks , contact_server = True ) [EOL] _ , args = mock_push_apk . call_args [EOL] assert args [ [string] ] is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pushapkscript.tests.helpers.mock_file.MockFile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] import subprocess [EOL] import unittest [EOL] from unittest . mock import MagicMock , patch [EOL] [EOL] from pushapkscript import jarsigner [EOL] from pushapkscript . exceptions import SignatureError [EOL] [EOL] [EOL] class JarSignerTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . context = MagicMock ( ) [EOL] self . context . config = { [string] : [string] , [string] : [string] , [string] : [ [string] ] , } [EOL] self . context . task = { [string] : [ [string] ] , [string] : { } } [EOL] [EOL] self . minimal_context = MagicMock ( ) [EOL] self . minimal_context . config = { [string] : [string] , [string] : [ [string] ] } [EOL] self . minimal_context . task = { [string] : [ [string] ] , [string] : { } } [EOL] [EOL] def test_verify_should_call_executable_with_right_arguments ( self ) : [EOL] for android_product , alias in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ) : [EOL] self . context . task [ [string] ] = [ [string] . format ( android_product ) ] [EOL] with patch ( [string] ) as run : [EOL] run . return_value = MagicMock ( ) [EOL] run . return_value . returncode = [number] [EOL] run . return_value . stdout = [string] [EOL] jarsigner . verify ( self . context , { [string] : alias } , [string] ) [EOL] [EOL] run . assert_called_with ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , alias ] , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = True , ) [EOL] [EOL] def test_verify_should_call_executable_with_defaults_arguments ( self ) : [EOL] with patch ( [string] ) as run : [EOL] run . return_value = MagicMock ( ) [EOL] run . return_value . returncode = [number] [EOL] run . return_value . stdout = [string] [EOL] jarsigner . verify ( self . minimal_context , { [string] : [string] } , [string] ) [EOL] [EOL] run . assert_called_with ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = True , ) [EOL] [EOL] def test_raises_error_when_return_code_is_not_0 ( self ) : [EOL] with patch ( [string] ) as run : [EOL] run . return_value = MagicMock ( ) [EOL] run . return_value . returncode = [number] [EOL] [EOL] with self . assertRaises ( SignatureError ) : [EOL] jarsigner . verify ( self . context , { [string] : [string] } , [string] ) [EOL] [EOL] def test_pluck_configuration_sets_every_argument ( self ) : [EOL] self . assertEqual ( jarsigner . _pluck_configuration ( self . context , { [string] : [string] } ) , ( [string] , [string] , [string] ) ) [EOL] [EOL] def test_pluck_configuration_uses_defaults ( self ) : [EOL] self . assertEqual ( jarsigner . _pluck_configuration ( self . minimal_context , { [string] : [string] } ) , ( [string] , [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from pushapkscript . utils import filter_out_identical_values [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] ] , [ [string] ] ) , ( [ [string] , [string] ] , [ [string] , [string] ] ) , ( [ [string] , [string] , [string] ] , [ [string] , [string] ] ) , ( [ [string] , [string] , [string] ] , [ [string] , [string] ] ) , ( [ [string] , [string] , [string] , [string] ] , [ [string] , [string] ] ) , ( [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] ] ) , ) , ) def test_filter_out_identical_values ( list_ , expected ) : [EOL] assert sorted ( filter_out_identical_values ( list_ ) ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class MockFile : [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , _ , __ , ___ ) : [EOL] pass [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , MockFile ) and self . name == other . name [EOL] [EOL] [EOL] def mock_open ( filename , _ = None ) : [EOL] return MockFile ( filename ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Union , Any , Dict , List [EOL] import typing [EOL] class TaskGenerator ( object ) : [EOL] def __init__ ( self , rollout_percentage = None , should_commit_transaction = False ) : [EOL] self . arm_task_id = [string] [EOL] self . x86_task_id = [string] [EOL] self . should_commit_transaction = should_commit_transaction [EOL] self . rollout_percentage = rollout_percentage [EOL] [EOL] def generate_task ( self , product_name , channel = None ) : [EOL] arm_task_id = self . arm_task_id [EOL] x86_task_id = self . x86_task_id [EOL] task = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ arm_task_id , x86_task_id ] , [string] : [ [string] . format ( product_name ) ] , [string] : { [string] : [ { [string] : [ [string] ] , [string] : arm_task_id , [string] : [string] } , { [string] : [ [string] ] , [string] : x86_task_id , [string] : [string] } , ] } , } [EOL] [EOL] if channel : [EOL] task [ [string] ] [ [string] ] = channel [EOL] [EOL] if self . rollout_percentage : [EOL] task [ [string] ] [ [string] ] = self . rollout_percentage [EOL] [EOL] if self . should_commit_transaction : [EOL] task [ [string] ] [ [string] ] = True [EOL] [EOL] return task [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]],typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]],typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]],typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]],typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]]],typing.List[typing.Any],typing.List[builtins.str],builtins.int,builtins.str]]$ 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] from importlib import import_module [EOL] [EOL] [EOL] def register ( graph_config ) : [EOL] [docstring] [EOL] _import_modules ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] [EOL] def _import_modules ( modules ) : [EOL] for module in modules : [EOL] import_module ( [string] . format ( module ) , package = __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import six [EOL] [EOL] from taskgraph . target_tasks import _target_task , filter_for_tasks_for [EOL] [EOL] [EOL] def filter_for_script ( task , parameters ) : [EOL] return ( parameters . get ( [string] ) is None or task . attributes . get ( [string] ) == parameters . get ( [string] ) ) [EOL] [EOL] [EOL] @ _target_task ( [string] ) def target_tasks_default ( full_task_graph , parameters , graph_config ) : [EOL] [docstring] [EOL] return [ l for l , t in six . iteritems ( full_task_graph . tasks ) if filter_for_tasks_for ( t , parameters ) [EOL] and filter_for_script ( t , parameters ) ] [EOL] [EOL] [EOL] @ _target_task ( [string] ) def target_tasks_default ( full_task_graph , parameters , graph_config ) : [EOL] [docstring] [EOL] return [ l for l , t in six . iteritems ( full_task_graph . tasks ) if t . kind == [string] [EOL] and filter_for_script ( t , parameters ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] from copy import deepcopy [EOL] import time [EOL] [EOL] from taskgraph . transforms . base import TransformSequence [EOL] [EOL] [EOL] transforms = TransformSequence ( ) [EOL] [EOL] [EOL] @ transforms . add def add_dependencies ( config , jobs ) : [EOL] [docstring] [EOL] for job in jobs : [EOL] attributes = job [ [string] ] [EOL] dependencies = job . setdefault ( [string] , { } ) [EOL] resources = None [EOL] for dep_task in config . kind_dependencies_tasks : [EOL] dep_attrs = dep_task . attributes [EOL] dep_kind = dep_task . kind [EOL] if dep_attrs [ [string] ] == attributes [ [string] ] and dep_attrs [ [string] ] == attributes [ [string] ] : [EOL] if dependencies . get ( dep_kind ) : [EOL] raise Exception ( [string] . format ( kind = dep_kind , existing_label = dependencies [ dep_kind ] [ [string] ] , new_label = dep_task . label , ) ) [EOL] dependencies [ dep_kind ] = dep_task . label [EOL] if dep_attrs . get ( [string] ) : [EOL] if resources and resources != dep_attrs [ [string] ] : [EOL] raise Exception ( [string] . format ( existing_digest = resources , new_digest = dep_attrs [ [string] ] , ) ) [EOL] resources = dep_attrs [ [string] ] [EOL] if resources : [EOL] attributes [ [string] ] = resources [EOL] yield job [EOL] [EOL] [EOL] @ transforms . add def set_environment ( config , jobs ) : [EOL] [docstring] [EOL] for job in jobs : [EOL] project_name = job [ [string] ] [ [string] ] [EOL] secret_url = job . pop ( [string] ) [EOL] tasks_for = config . params [ [string] ] [EOL] scopes = job . setdefault ( [string] , [ ] ) [EOL] attributes = job [ [string] ] [EOL] env = job [ [string] ] . setdefault ( [string] , { } ) [EOL] env . update ( { [string] : config . params [ [string] ] , [string] : job . pop ( [string] ) , [string] : config . params . get ( [string] , [string] ) , [string] : project_name , [string] : config . params [ [string] ] , [string] : [string] , } ) [EOL] push_docker_image = config . params . get ( [string] ) [EOL] if push_docker_image : [EOL] env . update ( { [string] : secret_url , [string] : [string] , [string] : config . graph_config [ [string] ] [ [string] ] , [string] : config . graph_config [ [string] ] [ [string] ] , } ) [EOL] scopes . append ( [string] ) [EOL] else : [EOL] env [ [string] ] = [string] [EOL] yield job [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] from copy import deepcopy [EOL] import time [EOL] [EOL] from taskgraph . transforms . base import TransformSequence [EOL] [EOL] [EOL] transforms = TransformSequence ( ) [EOL] [EOL] [EOL] @ transforms . add def add_dependencies ( config , jobs ) : [EOL] [docstring] [EOL] for job in jobs : [EOL] image = job [ [string] ] [ [string] ] [EOL] if isinstance ( image , dict ) : [EOL] if [string] in image : [EOL] name = image [ [string] ] [EOL] docker_image_task = [string] + image [ [string] ] [EOL] job . setdefault ( [string] , { } ) [ [string] ] = docker_image_task [EOL] yield job [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import hashlib [EOL] import json [EOL] import os [EOL] import subprocess [EOL] [EOL] import taskgraph [EOL] from taskgraph . transforms . base import TransformSequence [EOL] from taskgraph . util . hash import hash_paths [EOL] from taskgraph . util . memoize import memoize [EOL] [EOL] transforms = TransformSequence ( ) [EOL] [EOL] BASE_DIR = os . getcwd ( ) [EOL] [EOL] @ transforms . add def add_resources ( config , tasks ) : [EOL] for task in tasks : [EOL] resources = task . pop ( [string] , [ ] ) [EOL] attributes = task . setdefault ( [string] , { } ) [EOL] if attributes . get ( [string] ) is not None : [EOL] if resources and attributes [ [string] ] != resources : [EOL] raise Exception ( [string] . format ( config . kind , task . get ( [string] ) , resources , attributes [ [string] ] , ) ) [EOL] attributes [ [string] ] = resources [EOL] yield task [EOL] [EOL] [EOL] @ transforms . add def build_cache ( config , tasks ) : [EOL] for task in tasks : [EOL] if task . get ( [string] , True ) and not taskgraph . fast : [EOL] digest_data = [ ] [EOL] resources = task [ [string] ] [ [string] ] [EOL] for resource in resources : [EOL] digest_data . append ( hash_paths ( os . path . join ( BASE_DIR , resource ) , [ [string] ] ) ) [EOL] cache_name = task [ [string] ] . replace ( [string] , [string] ) [EOL] task [ [string] ] = { [string] : [string] . format ( config . kind ) , [string] : cache_name , [string] : digest_data , } [EOL] [EOL] yield task [EOL] [EOL] [EOL] @ transforms . add def set_label ( config , jobs ) : [EOL] [docstring] [EOL] for job in jobs : [EOL] job [ [string] ] = [string] . format ( config . kind , job . pop ( [string] ) ) [EOL] yield job [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] from copy import deepcopy [EOL] [EOL] from taskgraph . transforms . base import TransformSequence [EOL] [EOL] [EOL] transforms = TransformSequence ( ) [EOL] [EOL] def _replace_string ( obj , subs ) : [EOL] if isinstance ( obj , dict ) : [EOL] return { k : v . format ( ** subs ) for k , v in obj . items ( ) } [EOL] elif isinstance ( obj , list ) : [EOL] for c in range ( [number] , len ( obj ) ) : [EOL] obj [ c ] = obj [ c ] . format ( ** subs ) [EOL] else : [EOL] obj = obj . format ( ** subs ) [EOL] return obj [EOL] [EOL] [EOL] def _resolve_replace_string ( item , field , subs ) : [EOL] [comment] [EOL] container , subfield = item , field [EOL] while [string] in subfield : [EOL] f , subfield = subfield . split ( [string] , [number] ) [EOL] if f not in container : [EOL] return item [EOL] container = container [ f ] [EOL] if not isinstance ( container , dict ) : [EOL] return item [EOL] [EOL] if subfield not in container : [EOL] return item [EOL] [EOL] container [ subfield ] = _replace_string ( container [ subfield ] , subs ) [EOL] return item [EOL] [EOL] [EOL] [EOL] @ transforms . add def set_script_name ( config , jobs ) : [EOL] for job in jobs : [EOL] job . setdefault ( [string] , { } ) . update ( { [string] : job [ [string] ] , } ) [EOL] yield job [EOL] [EOL] [EOL] @ transforms . add def tasks_per_python_version ( config , jobs ) : [EOL] fields = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] for job in jobs : [EOL] for python_version in job . pop ( [string] ) : [EOL] task = deepcopy ( job ) [EOL] subs = { [string] : job [ [string] ] , [string] : python_version } [EOL] for field in fields : [EOL] _resolve_replace_string ( task , field , subs ) [EOL] task [ [string] ] [ [string] ] = python_version [EOL] yield task [EOL] [EOL] [EOL] @ transforms . add def update_name_with_python_version ( config , jobs ) : [EOL] for job in jobs : [EOL] job [ [string] ] = [string] . format ( job [ [string] ] , job [ [string] ] [ [string] ] ) [EOL] yield job [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [ [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] html_show_copyright = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import base64 [EOL] import os [EOL] import os . path [EOL] import shutil [EOL] from contextlib import contextmanager [EOL] from hashlib import sha256 [EOL] [EOL] import pytest [EOL] from scriptworker_client . utils import makedirs [EOL] [EOL] import iscript . autograph as autograph [EOL] from iscript . exceptions import IScriptError [EOL] from iscript . mac import App [EOL] [EOL] [comment] [EOL] TEST_DATA_DIR = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] [EOL] @ contextmanager def does_not_raise ( ) : [EOL] yield [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def key_config ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] async def noop_async ( * args , ** kwargs ) : [EOL] ... [EOL] [EOL] [EOL] def noop_sync ( * args , ** kwargs ) : [EOL] ... [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( None , [string] , [string] , None ) , ( [string] , [string] , [string] , None ) ) ) async def test_sign_file_with_autograph ( key_config , mocker , to , expected , format , options ) : [EOL] open_mock = mocker . mock_open ( read_data = [string] ) [EOL] mocker . patch ( [string] , open_mock , create = True ) [EOL] [EOL] session_mock = mocker . MagicMock ( ) [EOL] session_mock . post . return_value . json . return_value = [ { [string] : [string] } ] [EOL] [EOL] Session_mock = mocker . Mock ( ) [EOL] Session_mock . return_value . __enter__ = mocker . Mock ( return_value = session_mock ) [EOL] Session_mock . return_value . __exit__ = mocker . Mock ( ) [EOL] mocker . patch ( [string] , Session_mock , create = True ) [EOL] [EOL] assert await autograph . sign_file_with_autograph ( key_config , [string] , format , to = to ) == expected [EOL] open_mock . assert_called ( ) [EOL] kwargs = { [string] : [string] } [EOL] if options : [EOL] kwargs [ [string] ] = options [EOL] session_mock . post . assert_called_with ( [string] , auth = mocker . ANY , json = [ kwargs ] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( None , [string] ) , ( [string] , [string] ) ) ) async def test_sign_file_with_autograph_raises_http_error ( key_config , mocker , to , expected ) : [EOL] open_mock = mocker . mock_open ( read_data = [string] ) [EOL] mocker . patch ( [string] , open_mock , create = True ) [EOL] [EOL] session_mock = mocker . MagicMock ( ) [EOL] post_mock_response = session_mock . post . return_value [EOL] post_mock_response . raise_for_status . side_effect = autograph . requests . exceptions . RequestException [EOL] post_mock_response . json . return_value = [ { [string] : [string] } ] [EOL] [EOL] @ contextmanager def session_context ( ) : [EOL] yield session_mock [EOL] [EOL] mocker . patch ( [string] , session_context ) [EOL] [EOL] async def fake_retry_async ( func , args = ( ) , attempts = [number] , sleeptime_kwargs = None ) : [EOL] await func ( * args ) [EOL] [EOL] mocker . patch . object ( autograph , [string] , new = fake_retry_async ) [EOL] [EOL] with pytest . raises ( autograph . requests . exceptions . RequestException ) : [EOL] await autograph . sign_file_with_autograph ( key_config , [string] , [string] , to = to ) [EOL] open_mock . assert_called ( ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , True , None ) , ( [string] , [string] , True , None ) , ( [string] , [string] , True , [ [string] , [string] , [string] ] ) , ( [string] , [string] , False , None ) , ( [string] , [string] , False , None ) , ( [string] , [string] , False , None ) , ( [string] , [string] , True , None ) , ( [string] , [string] , True , None ) , ( [string] , [string] , True , None ) , ) , ) async def test_sign_widevine_dir ( key_config , mocker , filename , fmt , should_sign , orig_files , tmp_path ) : [EOL] if should_sign : [EOL] files = orig_files or [ [string] , [string] , [string] , [string] , [string] ] [EOL] else : [EOL] files = orig_files or [ [string] , [string] ] [EOL] [EOL] def fake_walk ( _ ) : [EOL] yield ( [string] , [ ] , files ) [EOL] [EOL] config = { [string] : tmp_path / [string] } [EOL] [EOL] async def fake_filelist ( * args , ** kwargs ) : [EOL] return files [EOL] [EOL] async def fake_sign ( _ , f , fmt , ** kwargs ) : [EOL] if f . endswith ( [string] ) : [EOL] assert fmt == [string] [EOL] elif f . endswith ( [string] ) : [EOL] assert fmt == [string] [EOL] else : [EOL] assert False , [string] . format ( f , fmt ) [EOL] if [string] in f : [EOL] assert f not in files , [string] [EOL] [EOL] def fake_isfile ( path ) : [EOL] return [string] not in path [EOL] [EOL] mocker . patch . object ( autograph , [string] , new = noop_async ) [EOL] mocker . patch . object ( autograph , [string] , new = noop_sync ) [EOL] mocker . patch . object ( autograph , [string] , new = noop_sync ) [EOL] mocker . patch . object ( autograph , [string] , new = noop_sync ) [EOL] mocker . patch . object ( os . path , [string] , new = fake_isfile ) [EOL] mocker . patch . object ( os , [string] , new = fake_walk ) [EOL] [EOL] await autograph . sign_widevine_dir ( config , key_config , filename ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] , [string] , [string] ] , { } ) , ( ( [string] , [string] , [string] , [string] , [string] ) , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , ) , ( ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) , { [string] : [string] } , ) , ) , ) def test_get_widevine_signing_files ( filenames , expected ) : [EOL] assert autograph . _get_widevine_signing_files ( filenames ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [number] , False ) , ( [number] , True ) , ( [number] , True ) ) ) def test_run_generate_precomplete ( tmp_path , num_precomplete , raises , mocker ) : [EOL] mocker . patch . object ( autograph , [string] , new = noop_sync ) [EOL] work_dir = tmp_path / [string] [EOL] config = { [string] : tmp_path / [string] } [EOL] for i in range ( [number] , num_precomplete ) : [EOL] path = os . path . join ( work_dir , [string] , str ( i ) ) [EOL] makedirs ( path ) [EOL] with open ( os . path . join ( path , [string] ) , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] autograph . _run_generate_precomplete ( config , work_dir ) [EOL] else : [EOL] autograph . _run_generate_precomplete ( config , work_dir ) [EOL] [EOL] [EOL] [comment] [EOL] def test_remove_extra_files ( tmp_path ) : [EOL] extra = [ [string] , [string] ] [EOL] good = [ [string] , [string] ] [EOL] work_dir = tmp_path [EOL] all_files = [ ] [EOL] for f in extra + good : [EOL] path = os . path . join ( work_dir , f ) [EOL] makedirs ( os . path . dirname ( path ) ) [EOL] with open ( path , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] if f in good : [EOL] all_files . append ( path ) [EOL] for f in good : [EOL] assert os . path . exists ( os . path . join ( work_dir , f ) ) [EOL] output = autograph . remove_extra_files ( work_dir , all_files ) [EOL] for f in extra : [EOL] path = os . path . realpath ( os . path . join ( work_dir , f ) ) [EOL] assert path in output [EOL] assert not os . path . exists ( path ) [EOL] for f in good : [EOL] assert os . path . exists ( os . path . join ( work_dir , f ) ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , None , None , [ { [string] : [string] } ] ) , ( [string] , [string] , None , [string] , [ { [string] : [string] , [string] : [string] } ] ) , ( [string] , [string] , [string] , None , [ { [string] : [string] , [string] : { [string] : [string] , [string] : [ [string] ] , [string] : [string] } } ] , ) , ) , ) def test_make_signing_req ( input_bytes , fmt , extension_id , keyid , expected ) : [EOL] assert autograph . make_signing_req ( input_bytes , fmt , keyid = keyid , extension_id = extension_id ) == expected [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_bad_autograph_method ( ) : [EOL] with pytest . raises ( IScriptError ) : [EOL] await autograph . sign_with_autograph ( None , None , None , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( True , False ) ) async def test_widevine_autograph ( mocker , tmp_path , blessed , key_config ) : [EOL] wv = mocker . patch ( [string] ) [EOL] wv . generate_widevine_hash . return_value = [string] [EOL] wv . generate_widevine_signature . return_value = [string] [EOL] [EOL] async def fake_call ( * args , ** kwargs ) : [EOL] return [ { [string] : base64 . b64encode ( [string] ) } ] [EOL] [EOL] mocker . patch . object ( autograph , [string] , fake_call ) [EOL] [EOL] cert = tmp_path / [string] [EOL] cert . write_bytes ( [string] ) [EOL] key_config [ [string] ] = cert [EOL] [EOL] to = tmp_path / [string] [EOL] to = await autograph . sign_widevine_with_autograph ( key_config , [string] , blessed , to = to ) [EOL] [EOL] assert [string] == to . read_bytes ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_no_widevine ( mocker , tmp_path ) : [EOL] async def fake_call ( * args , ** kwargs ) : [EOL] return [ { [string] : [string] } ] [EOL] [EOL] mocker . patch . object ( autograph , [string] , fake_call ) [EOL] [EOL] with pytest . raises ( ImportError ) : [EOL] to = tmp_path / [string] [EOL] to = await autograph . sign_widevine_with_autograph ( { } , [string] , True , to = to ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] , [string] , [string] ] , { } ) , ( ( [string] , [string] , [string] , [string] , [string] ) , { [string] : [string] , [string] : [string] } , ) , ) , ) def test_get_omnija_signing_files ( filenames , expected ) : [EOL] assert autograph . _get_omnija_signing_files ( filenames ) == expected [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) async def test_omnija_same ( mocker , tmpdir , orig ) : [EOL] copy_from = os . path . join ( tmpdir , [string] ) [EOL] shutil . copyfile ( os . path . join ( TEST_DATA_DIR , orig ) , copy_from ) [EOL] copy_to = os . path . join ( tmpdir , [string] ) [EOL] [EOL] class mockedZipFile ( object ) : [EOL] def __init__ ( self , name , mode , * args , ** kwargs ) : [EOL] assert name == [string] [EOL] assert mode == [string] [EOL] [EOL] def namelist ( self ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] mocker . patch . object ( autograph . zipfile , [string] , mockedZipFile ) [EOL] await autograph . merge_omnija_files ( copy_from , [string] , copy_to ) [EOL] assert open ( copy_from , [string] ) . read ( ) == open ( copy_to , [string] ) . read ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ) , ) async def test_omnija_sign ( tmpdir , mocker , orig , signed , sha256_expected ) : [EOL] copy_from = os . path . join ( tmpdir , [string] ) [EOL] shutil . copyfile ( os . path . join ( TEST_DATA_DIR , orig ) , copy_from ) [EOL] config = { [string] : tmpdir } [EOL] key_config = { } [EOL] [EOL] async def mocked_autograph ( key_config , from_ , fmt , to , extension_id ) : [EOL] assert fmt == [string] [EOL] assert extension_id == [string] [EOL] shutil . copyfile ( os . path . join ( TEST_DATA_DIR , signed ) , to ) [EOL] [EOL] mocker . patch . object ( autograph , [string] , mocked_autograph ) [EOL] await autograph . sign_omnija_with_autograph ( config , key_config , tmpdir ) [EOL] sha256_actual = sha256 ( open ( copy_from , [string] ) . read ( ) ) . hexdigest ( ) [EOL] assert sha256_actual == sha256_expected [EOL] [EOL] [EOL] def test_langpack_id_regex ( ) : [EOL] assert autograph . LANGPACK_RE . match ( [string] ) is not None [EOL] assert autograph . LANGPACK_RE . match ( [string] ) is not None [EOL] assert autograph . LANGPACK_RE . match ( [string] ) is None [EOL] [EOL] [EOL] def test_langpack_id ( ) : [EOL] filename = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] langpack_app = App ( orig_path = filename , formats = [ [string] ] , artifact_prefix = [string] ) [EOL] assert autograph . langpack_id ( langpack_app ) == [string] [EOL] [EOL] [EOL] def test_langpack_id ( ) : [EOL] filename = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] langpack_app = App ( orig_path = filename , formats = [ [string] ] , artifact_prefix = [string] ) [EOL] with pytest . raises ( IScriptError ) : [EOL] assert autograph . langpack_id ( langpack_app ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { } , pytest . raises ( IScriptError ) ) , ( { [string] : { } } , pytest . raises ( IScriptError ) ) , ( { [string] : { } , [string] : [string] } , pytest . raises ( IScriptError ) ) , ( { [string] : { } , [string] : [string] , [string] : { } } , pytest . raises ( IScriptError ) ) , ( { [string] : { } , [string] : [string] , [string] : { [string] : { } } } , pytest . raises ( IScriptError ) ) , ( { [string] : { } , [string] : [string] , [string] : { [string] : { } } } , pytest . raises ( IScriptError ) ) , ( { [string] : { } , [string] : [string] , [string] : { [string] : { [string] : [string] } } } , pytest . raises ( IScriptError ) ) , ( { [string] : { } , [string] : [string] , [string] : { [string] : { [string] : [string] } } } , pytest . raises ( IScriptError ) ) , ( { [string] : { } , [string] : [string] , [string] : { [string] : { [string] : [string] } } } , does_not_raise ( ) ) , ( { [string] : { } , [string] : [string] , [string] : { [string] : { [string] : [string] } } } , does_not_raise ( ) ) , ( { [string] : { } , [string] : [string] , [string] : { [string] : { [string] : [string] } } } , does_not_raise ( ) ) , ( { [string] : [string] , [string] : { [string] : { [string] : [string] } } } , pytest . raises ( IScriptError ) ) , ) , ) def test_langpack_id_raises ( json_ , raises , mocker ) : [EOL] filename = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] langpack_app = App ( orig_path = filename , formats = [ [string] ] , artifact_prefix = [string] ) [EOL] [EOL] def load_manifest ( * args , ** kwargs ) : [EOL] return json_ [EOL] [EOL] [comment] [EOL] mocker . patch . object ( autograph . zipfile , [string] , autospec = True ) [EOL] [EOL] mocker . patch . object ( autograph . json , [string] , load_manifest ) [EOL] with raises : [EOL] id = autograph . langpack_id ( langpack_app ) [EOL] assert id == json_ [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_langpack_sign ( key_config , mocker , tmp_path ) : [EOL] mock_ever_called = [ False ] [EOL] filename = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] langpack_app = App ( orig_path = filename , formats = [ [string] ] , artifact_prefix = TEST_DATA_DIR ) [EOL] config = { [string] : tmp_path / [string] } [EOL] [EOL] async def mocked_call_autograph ( url , user , password , request_json ) : [EOL] mock_ever_called [ [number] ] = True [EOL] [comment] [EOL] assert url . startswith ( [string] ) [EOL] assert user == [string] [EOL] assert password == [string] [EOL] assert len ( request_json ) == [number] [EOL] assert request_json [ [number] ] [ [string] ] [ [string] ] == [string] [EOL] return [ { [string] : base64 . b64encode ( open ( filename , [string] ) . read ( ) ) } ] [EOL] [EOL] mock_obj = mocker . patch . object ( autograph , [string] , new = mocked_call_autograph ) [EOL] [EOL] await autograph . sign_langpacks ( config , key_config , [ langpack_app ] ) [EOL] expected_hash = [string] [EOL] assert sha256 ( open ( langpack_app . target_tar_path , [string] ) . read ( ) ) . hexdigest ( ) == expected_hash [EOL] assert mock_ever_called [ [number] ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_langpack_sign_wrong_format ( key_config , mocker , tmp_path ) : [EOL] mock_ever_called = [ False ] [EOL] filename = os . path . join ( TEST_DATA_DIR , [string] ) [EOL] langpack_app = App ( orig_path = filename , formats = [ [string] ] , artifact_prefix = TEST_DATA_DIR ) [EOL] config = { [string] : tmp_path / [string] } [EOL] [EOL] async def mocked_call_autograph ( url , user , password , request_json ) : [EOL] mock_ever_called [ [number] ] = True [EOL] return [ { [string] : base64 . b64encode ( open ( filename , [string] ) . read ( ) ) } ] [EOL] [EOL] mock_obj = mocker . patch . object ( autograph , [string] , new = mocked_call_autograph ) [EOL] [EOL] with pytest . raises ( IScriptError ) : [EOL] await autograph . sign_langpacks ( config , key_config , [ langpack_app ] ) [EOL] assert not mock_ever_called [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Union , Any , Dict [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] import iscript . util as util [EOL] from iscript . exceptions import IScriptError [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( [string] , ) , [string] , [string] , False ) , ( ( [string] , ) , [string] , [string] , False ) , ( ( [string] ) , [string] , None , True ) , ( [ [string] , [string] ] , [string] , [string] , True ) , ( ( [string] , ) , [string] , [string] , True ) , ) , ) def test_get_config_key ( scopes , base_key , key , raises ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } } } [EOL] task = { [string] : scopes } [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] util . get_key_config ( config , task , base_key = base_key ) [EOL] else : [EOL] assert util . get_key_config ( config , task , base_key = base_key ) == config [ base_key ] [ key ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Union , Any , Dict , List [EOL] import mock [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import os [EOL] import plistlib [EOL] from functools import partial [EOL] [EOL] import arrow [EOL] import mock [EOL] import pexpect [EOL] import pytest [EOL] from scriptworker_client . utils import makedirs [EOL] [EOL] import iscript . mac as mac [EOL] from iscript . exceptions import InvalidNotarization , IScriptError , ThrottledNotarization , TimeoutError , UnknownAppDir , UnknownNotarizationError [EOL] [EOL] [EOL] [comment] [EOL] async def noop_async ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] async def fail_async ( * args , ** kwargs ) : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] [EOL] def touch ( path ) : [EOL] parent_dir = os . path . dirname ( path ) [EOL] makedirs ( parent_dir ) [EOL] with open ( path , [string] ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] def test_app ( ) : [EOL] [docstring] [EOL] a = mac . App ( ) [EOL] assert a . orig_path == [string] [EOL] a . orig_path = [string] [EOL] assert a . orig_path == [string] [EOL] a . check_required_attrs ( [ [string] ] ) [EOL] with pytest . raises ( IScriptError ) : [EOL] a . check_required_attrs ( [ [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , None , True ) ) ) def test_get_tar_create_options ( path , expected , raises ) : [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] mac . _get_tar_create_options ( path ) [EOL] else : [EOL] assert mac . _get_tar_create_options ( path ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , None , True ) ) , ) def test_get_pkg_name_from_tarball ( path , expected , raises ) : [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] mac . _get_pkg_name_from_tarball ( path ) [EOL] else : [EOL] assert mac . _get_pkg_name_from_tarball ( path ) == expected [EOL] [EOL] [EOL] [comment] [EOL] def test_app_path_and_name ( mocker ) : [EOL] [docstring] [EOL] [EOL] def fake_get_app_dir ( parent_dir ) : [EOL] x = os . path . basename ( parent_dir ) [EOL] return os . path . join ( parent_dir , [string] . format ( x ) ) [EOL] [EOL] all_paths = [ mac . App ( parent_dir = [string] ) , mac . App ( parent_dir = [string] , app_path = [string] ) , mac . App ( parent_dir = [string] , app_path = [string] , app_name = [string] ) , ] [EOL] mocker . patch . object ( mac , [string] , new = fake_get_app_dir ) [EOL] expected = [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] [EOL] for app in all_paths : [EOL] mac . set_app_path_and_name ( app ) [EOL] assert [ app . app_path , app . app_name ] == expected . pop ( [number] ) [EOL] [EOL] [EOL] [comment] [EOL] def test_get_bundle_executable ( mocker ) : [EOL] [docstring] [EOL] mocker . patch . object ( plistlib , [string] , return_value = { [string] : [string] } ) [EOL] assert mac . get_bundle_executable ( [string] ) == [string] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) @ pytest . mark . asyncio async def test_sign_geckodriver ( exists , mocker , tmpdir ) : [EOL] [docstring] [EOL] key_config = { [string] : [string] , [string] : [string] } [EOL] config = { [string] : os . path . join ( tmpdir , [string] ) } [EOL] app = mac . App ( orig_path = os . path . join ( tmpdir , [string] ) , parent_dir = os . path . join ( tmpdir , [string] ) , artifact_prefix = os . path . join ( [string] ) , ) [EOL] [EOL] makedirs ( app . parent_dir ) [EOL] if exists : [EOL] touch ( os . path . join ( app . parent_dir , [string] ) ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] if exists : [EOL] await mac . sign_geckodriver ( config , key_config , [ app ] ) [EOL] else : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . sign_geckodriver ( config , key_config , [ app ] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( True , True ) , ( False , False ) ) ) @ pytest . mark . asyncio async def test_sign_app ( mocker , tmpdir , sign_with_entitlements , has_clearkey ) : [EOL] [docstring] [EOL] key_config = { [string] : [string] , [string] : [string] , [string] : sign_with_entitlements } [EOL] entitlements_path = os . path . join ( tmpdir , [string] ) [EOL] app_path = os . path . join ( tmpdir , [string] ) [EOL] [EOL] contents_dir = os . path . join ( app_path , [string] ) [EOL] dir1 = os . path . join ( contents_dir , [string] ) [EOL] dir2 = os . path . join ( dir1 , [string] , [string] , [string] ) [EOL] ignore_dir = os . path . join ( contents_dir , [string] ) [EOL] for dir_ in ( dir1 , dir2 , ignore_dir ) : [EOL] makedirs ( dir_ ) [EOL] for dir_ in ( dir1 , dir2 ) : [EOL] touch ( os . path . join ( dir_ , [string] ) ) [EOL] touch ( os . path . join ( dir_ , [string] ) ) [EOL] touch ( os . path . join ( contents_dir , [string] ) ) [EOL] if has_clearkey : [EOL] dir_ = os . path . join ( contents_dir , [string] ) [EOL] file_ = [string] [EOL] makedirs ( dir_ ) [EOL] touch ( os . path . join ( dir_ , file_ ) ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = [string] ) [EOL] await mac . sign_app ( key_config , app_path , entitlements_path ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_verify_app_signature_noop ( mocker ) : [EOL] [docstring] [EOL] [EOL] key_config = { [string] : False } [EOL] [comment] [EOL] mocker . patch . object ( mac , [string] , new = fail_async ) [EOL] await mac . verify_app_signature ( key_config , mac . App ( ) ) [EOL] [EOL] [EOL] [comment] [EOL] def fake_spawn ( val , * args , ** kwargs ) : [EOL] return val [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [ [number] , [number] ] , [ [number] ] ) ) @ pytest . mark . asyncio async def test_unlock_keychain_successful ( results , mocker ) : [EOL] [docstring] [EOL] [EOL] async def fake_expect ( * args , ** kwargs ) : [EOL] return results . pop ( [number] ) [EOL] [EOL] child = mocker . Mock ( ) [EOL] child . expect = fake_expect [EOL] child . exitstatus = [number] [EOL] child . signalstatus = None [EOL] mocker . patch . object ( pexpect , [string] , new = partial ( fake_spawn , child ) ) [EOL] await mac . unlock_keychain ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_unlock_keychain_timeout ( mocker ) : [EOL] [docstring] [EOL] [EOL] async def fake_expect ( * args , ** kwargs ) : [EOL] raise pexpect . exceptions . TIMEOUT ( [string] ) [EOL] [EOL] child = mocker . Mock ( ) [EOL] child . expect = fake_expect [EOL] child . exitstatus = [number] [EOL] child . signalstatus = None [EOL] mocker . patch . object ( pexpect , [string] , new = partial ( fake_spawn , child ) ) [EOL] with pytest . raises ( TimeoutError ) : [EOL] await mac . unlock_keychain ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_unlock_keychain_failure ( mocker ) : [EOL] [docstring] [EOL] results = [ [number] ] [EOL] [EOL] async def fake_expect ( * args , ** kwargs ) : [EOL] return results . pop ( [number] ) [EOL] [EOL] child = mocker . Mock ( ) [EOL] child . expect = fake_expect [EOL] child . exitstatus = [number] [EOL] child . signalstatus = None [EOL] mocker . patch . object ( pexpect , [string] , new = partial ( fake_spawn , child ) ) [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . unlock_keychain ( [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ ] , True ) , ( [ [string] ] , False ) , ( [ [string] ] , True ) , ( [ [string] , [string] ] , True ) ) ) def test_get_app_dir ( tmpdir , apps , raises ) : [EOL] [docstring] [EOL] for app in apps : [EOL] os . makedirs ( os . path . join ( tmpdir , app ) ) [EOL] [EOL] if raises : [EOL] with pytest . raises ( UnknownAppDir ) : [EOL] mac . get_app_dir ( tmpdir ) [EOL] else : [EOL] assert mac . get_app_dir ( tmpdir ) == os . path . join ( tmpdir , apps [ [number] ] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , None , True ) ) ) def test_get_artifact_prefix ( path , expected , raises ) : [EOL] [docstring] [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] mac . _get_artifact_prefix ( path ) [EOL] else : [EOL] assert mac . _get_artifact_prefix ( path ) == expected [EOL] [EOL] [EOL] def test_get_app_paths ( ) : [EOL] [docstring] [EOL] config = { [string] : [string] } [EOL] task = { [string] : { [string] : [ { [string] : [ [string] ] , [string] : [string] , [string] : [ [string] ] } , { [string] : [ [string] , [string] ] , [string] : [string] , [string] : [ [string] ] } , ] } } [EOL] paths = [ ] [EOL] apps = mac . get_app_paths ( config , task ) [EOL] for app in apps : [EOL] assert isinstance ( app , mac . App ) [EOL] paths . append ( app . orig_path ) [EOL] assert paths == [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) , [string] , [string] , [string] , [string] ) , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , None , True ) , ) , ) @ pytest . mark . asyncio async def test_extract_all_apps ( mocker , tmpdir , suffix , command , raises ) : [EOL] [docstring] [EOL] [EOL] async def fake_run_command ( * args , ** kwargs ) : [EOL] assert args [ [number] ] [ [number] ] == command [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] mocker . patch . object ( mac , [string] , new = fake_run_command ) [EOL] work_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] config = { [string] : work_dir , [string] : [string] } [EOL] all_paths = [ mac . App ( orig_path = os . path . join ( work_dir , f" [string] { suffix }" ) ) , mac . App ( orig_path = os . path . join ( work_dir , f" [string] { suffix }" ) ) , mac . App ( orig_path = os . path . join ( work_dir , f" [string] { suffix }" ) ) , ] [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . extract_all_apps ( config , all_paths ) [EOL] else : [EOL] await mac . extract_all_apps ( config , all_paths ) [EOL] for i in ( [string] , [string] , [string] ) : [EOL] assert os . path . isdir ( os . path . join ( work_dir , i ) ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) @ pytest . mark . asyncio async def test_create_all_notarization_zipfiles ( mocker , tmpdir , raises ) : [EOL] [docstring] [EOL] [EOL] async def fake_run_command ( * args , ** kwargs ) : [EOL] assert args [ [number] ] [ [number] : [number] ] == [ [string] , [string] ] [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] mocker . patch . object ( mac , [string] , new = fake_run_command ) [EOL] all_paths = [ ] [EOL] work_dir = str ( tmpdir ) [EOL] for i in range ( [number] ) : [EOL] parent_dir = os . path . join ( work_dir , str ( i ) ) [EOL] app_name = [string] . format ( str ( i ) ) [EOL] app_path = os . path . join ( parent_dir , app_name ) [EOL] all_paths . append ( mac . App ( parent_dir = parent_dir , app_name = app_name , app_path = app_path ) ) [EOL] [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . create_all_notarization_zipfiles ( all_paths , [ [string] ] ) [EOL] else : [EOL] await mac . create_all_notarization_zipfiles ( all_paths , [ [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) @ pytest . mark . asyncio async def test_create_one_notarization_zipfile ( mocker , tmpdir , raises ) : [EOL] [docstring] [EOL] work_dir = str ( tmpdir ) [EOL] [EOL] async def fake_run_command ( * args , ** kwargs ) : [EOL] assert args [ [number] ] == [ [string] , [string] , os . path . join ( work_dir , [string] ) , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] mocker . patch . object ( mac , [string] , new = fake_run_command ) [EOL] all_paths = [ ] [EOL] for i in range ( [number] ) : [EOL] all_paths . append ( mac . App ( app_path = os . path . join ( work_dir , str ( i ) , [string] . format ( i ) ) , pkg_path = os . path . join ( work_dir , str ( i ) , [string] . format ( i ) ) ) ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . create_one_notarization_zipfile ( work_dir , all_paths ) [EOL] else : [EOL] await mac . create_one_notarization_zipfile ( work_dir , all_paths ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) @ pytest . mark . asyncio async def test_sign_all_apps ( mocker , tmpdir , raises ) : [EOL] [docstring] [EOL] key_config = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] config = { } [EOL] entitlements_path = [string] [EOL] work_dir = str ( tmpdir ) [EOL] all_paths = [ ] [EOL] app_paths = [ ] [EOL] for i in range ( [number] ) : [EOL] app_path = [string] . format ( str ( i ) ) [EOL] app_paths . append ( app_path ) [EOL] all_paths . append ( mac . App ( parent_dir = os . path . join ( work_dir , str ( i ) ) , app_path = app_path ) ) [EOL] [EOL] async def fake_sign ( arg1 , arg2 , arg3 ) : [EOL] assert arg1 == key_config [EOL] assert arg2 in app_paths [EOL] assert arg3 == entitlements_path [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] mocker . patch . object ( mac , [string] , return_value = None ) [EOL] mocker . patch . object ( mac , [string] , new = fake_sign ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . sign_all_apps ( config , key_config , entitlements_path , all_paths ) [EOL] else : [EOL] await mac . sign_all_apps ( config , key_config , entitlements_path , all_paths ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( None , [number] ) ) def test_get_bundle_id ( mocker , counter ) : [EOL] [docstring] [EOL] now = mock . MagicMock ( ) [EOL] now . timestamp = [number] [EOL] now . microsecond = [number] [EOL] mocker . patch . object ( arrow , [string] , return_value = now ) [EOL] base = [string] [EOL] expected = base [EOL] expected = [string] . format ( expected , now . timestamp , now . microsecond ) [EOL] if counter : [EOL] expected = [string] . format ( expected , counter ) [EOL] assert mac . get_bundle_id ( base , counter = counter ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , False , [string] ) , ( [string] , False , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , ThrottledNotarization , [string] , ) , ( [string] , UnknownNotarizationError , [string] ) , ) , ) def test_get_uuid_from_log ( tmpdir , uuid , raises , extra ) : [EOL] [docstring] [EOL] log_path = os . path . join ( str ( tmpdir ) , [string] ) [EOL] if raises != [string] : [EOL] with open ( log_path , [string] ) as fh : [EOL] fh . write ( f" [string] { uuid } [string] { extra } [string] " ) [EOL] if raises : [EOL] exception = raises [EOL] if not isinstance ( raises , IScriptError ) : [EOL] exception = IScriptError [EOL] with pytest . raises ( exception ) : [EOL] mac . get_uuid_from_log ( log_path ) [EOL] else : [EOL] assert mac . get_uuid_from_log ( log_path ) == uuid [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( True , [string] , [string] ) , ( True , [string] , [string] ) , ( True , [string] , None ) , ( False , None , None ) ) ) def test_get_notarization_status_from_log ( tmpdir , has_log , status , expected ) : [EOL] [docstring] [EOL] log_path = os . path . join ( str ( tmpdir ) , [string] ) [EOL] if has_log : [EOL] with open ( log_path , [string] ) as fh : [EOL] fh . write ( [string] . format ( status ) ) [EOL] assert mac . get_notarization_status_from_log ( log_path ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) @ pytest . mark . asyncio async def test_wrap_notarization_with_sudo ( mocker , tmpdir , raises ) : [EOL] [docstring] [EOL] futures_len = [ [number] , [number] , [number] ] [EOL] pw = [string] [EOL] [EOL] async def fake_retry_async ( _ , args , kwargs , ** kw ) : [EOL] cmd = args [ [number] ] [EOL] end = len ( cmd ) - [number] [EOL] assert cmd [ [number] ] == [string] [EOL] log_cmd = kwargs [ [string] ] [EOL] assert cmd [ [number] : end ] == log_cmd [ [number] : end ] [EOL] assert cmd [ end ] != log_cmd [ end ] [EOL] assert cmd [ end ] == pw [EOL] assert log_cmd [ end ] . replace ( [string] , [string] ) == [string] [EOL] [EOL] async def fake_raise_future_exceptions ( futures , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] await asyncio . wait ( futures ) [EOL] assert len ( futures ) == futures_len . pop ( [number] ) [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] def fake_get_uuid_from_log ( path ) : [EOL] return path [EOL] [EOL] work_dir = str ( tmpdir ) [EOL] config = { [string] : [ [string] , [string] , [string] ] } [EOL] key_config = { [string] : [string] , [string] : [string] , [string] : pw , [string] : [string] , } [EOL] all_paths = [ ] [EOL] expected = { } [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] parent_dir = os . path . join ( work_dir , str ( i ) ) [EOL] notarization_log_path = f"{ parent_dir } [string] " [EOL] all_paths . append ( mac . App ( parent_dir = parent_dir , zip_path = os . path . join ( parent_dir , [string] . format ( i ) ) ) ) [EOL] expected [ notarization_log_path ] = notarization_log_path [EOL] [EOL] mocker . patch . object ( mac , [string] , new = fake_retry_async ) [EOL] mocker . patch . object ( mac , [string] , new = fake_raise_future_exceptions ) [EOL] mocker . patch . object ( mac , [string] , new = fake_get_uuid_from_log ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . wrap_notarization_with_sudo ( config , key_config , all_paths ) [EOL] else : [EOL] assert await mac . wrap_notarization_with_sudo ( config , key_config , all_paths ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) @ pytest . mark . asyncio async def test_notarize_no_sudo ( mocker , tmpdir , raises ) : [EOL] [docstring] [EOL] pw = [string] [EOL] [EOL] async def fake_retry_async ( _ , args , kwargs , ** kw ) : [EOL] cmd = args [ [number] ] [EOL] end = len ( cmd ) - [number] [EOL] assert cmd [ [number] ] == [string] [EOL] log_cmd = kwargs [ [string] ] [EOL] assert cmd [ [number] : end ] == log_cmd [ [number] : end ] [EOL] assert cmd [ end ] != log_cmd [ end ] [EOL] assert cmd [ end ] == pw [EOL] assert log_cmd [ end ] . replace ( [string] , [string] ) == [string] [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] def fake_get_uuid_from_log ( path ) : [EOL] return path [EOL] [EOL] work_dir = str ( tmpdir ) [EOL] zip_path = os . path . join ( work_dir , [string] ) [EOL] log_path = os . path . join ( work_dir , [string] ) [EOL] key_config = { [string] : [string] , [string] : [string] , [string] : pw , [string] : [string] , } [EOL] expected = { log_path : log_path } [EOL] [EOL] mocker . patch . object ( mac , [string] , new = fake_retry_async ) [EOL] mocker . patch . object ( mac , [string] , new = fake_get_uuid_from_log ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . notarize_no_sudo ( work_dir , key_config , zip_path ) [EOL] else : [EOL] assert await mac . notarize_no_sudo ( work_dir , key_config , zip_path ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] ] , None ) , ( [ None , [string] ] , None ) , ( [ None ] , IScriptError ) , ( [ [string] ] , InvalidNotarization ) , ( [ None , None , None , None , None , None , None , None , None , None , None ] , TimeoutError ) , ) , ) @ pytest . mark . asyncio async def test_poll_notarization_uuid ( mocker , tmpdir , statuses , exception ) : [EOL] [docstring] [EOL] pw = [string] [EOL] [EOL] async def fake_retry_async ( _ , args , kwargs , ** kw ) : [EOL] cmd = args [ [number] ] [EOL] end = len ( cmd ) - [number] [EOL] assert cmd [ [number] ] == [string] [EOL] log_cmd = kwargs [ [string] ] [EOL] assert cmd [ [number] : end ] == log_cmd [ [number] : end ] [EOL] assert cmd [ end ] != log_cmd [ end ] [EOL] assert cmd [ end ] == pw [EOL] assert log_cmd [ end ] . replace ( [string] , [string] ) == [string] [EOL] if exception is IScriptError : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] def fake_get_notarization_status_from_log ( path ) : [EOL] status = statuses . pop ( [number] ) [EOL] return status [EOL] [EOL] mocker . patch . object ( mac , [string] , new = fake_retry_async ) [EOL] mocker . patch . object ( mac , [string] , new = fake_get_notarization_status_from_log ) [EOL] if exception : [EOL] with pytest . raises ( exception ) : [EOL] await mac . poll_notarization_uuid ( [string] , [string] , pw , [number] , [string] , sleep_time = [number] ) [EOL] else : [EOL] assert await mac . poll_notarization_uuid ( [string] , [string] , pw , [number] , [string] , sleep_time = [number] ) is None [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [string] } , True ) , ( { [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] } , False ) ) ) @ pytest . mark . asyncio async def test_poll_all_notarization_status ( mocker , tmpdir , poll_uuids , raises ) : [EOL] [docstring] [EOL] [EOL] async def fake_raise_future_exceptions ( futures ) : [EOL] await asyncio . wait ( futures ) [EOL] assert len ( futures ) == len ( poll_uuids ) [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] key_config = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } [EOL] [EOL] mocker . patch . object ( mac , [string] , new = fake_raise_future_exceptions ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . poll_all_notarization_status ( key_config , poll_uuids ) [EOL] [EOL] else : [EOL] assert await mac . poll_all_notarization_status ( key_config , poll_uuids ) is None [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False ) ) @ pytest . mark . asyncio async def test_staple_notarization ( mocker , raises ) : [EOL] [docstring] [EOL] [EOL] async def fake_retry_async ( * args , ** kwargs ) : [EOL] assert kwargs [ [string] ] [ [number] ] [ [number] ] == [string] [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] all_paths = [ ] [EOL] for i in range ( [number] ) : [EOL] parent_dir = str ( i ) [EOL] app_name = f"{ i } [string] " [EOL] app_path = os . path . join ( parent_dir , app_name ) [EOL] all_paths . append ( mac . App ( parent_dir = parent_dir , app_name = app_name , app_path = app_path ) ) [EOL] mocker . patch . object ( mac , [string] , new = fake_retry_async ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . staple_notarization ( all_paths ) [EOL] else : [EOL] assert await mac . staple_notarization ( all_paths ) is None [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( True , [string] ) , ( False , [string] ) , ( False , [string] ) ) ) @ pytest . mark . asyncio async def test_tar_apps ( mocker , tmpdir , raises , artifact_prefix ) : [EOL] [docstring] [EOL] [EOL] async def fake_raise_future_exceptions ( futures ) : [EOL] await asyncio . wait ( futures ) [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] work_dir = os . path . join ( tmpdir , [string] ) [EOL] config = { [string] : os . path . join ( tmpdir , [string] ) } [EOL] all_paths = [ ] [EOL] expected = [ ] [EOL] for i in range ( [number] ) : [EOL] parent_dir = os . path . join ( work_dir , str ( i ) ) [EOL] app_name = [string] . format ( i ) [EOL] makedirs ( parent_dir ) [EOL] [comment] [EOL] with open ( os . path . join ( parent_dir , app_name ) , [string] ) as fh : [EOL] fh . write ( [string] ) [EOL] orig_path = os . path . join ( work_dir , [string] , [string] , artifact_prefix , [string] , str ( i ) , f"{ i } [string] " ) [EOL] [comment] [EOL] all_paths . append ( mac . App ( parent_dir = parent_dir , app_name = app_name , app_path = os . path . join ( parent_dir , app_name ) , artifact_prefix = artifact_prefix , orig_path = orig_path , pkg_path = str ( i ) , ) ) [EOL] expected . append ( os . path . join ( config [ [string] ] , artifact_prefix , [string] , [string] . format ( i , i ) ) ) [EOL] [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = fake_raise_future_exceptions ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . tar_apps ( config , all_paths ) [EOL] else : [EOL] assert await mac . tar_apps ( config , all_paths ) is None [EOL] assert [ x . target_tar_path for x in all_paths ] == expected [EOL] for path in expected : [EOL] assert os . path . isdir ( os . path . dirname ( path ) ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( None , True ) , ( None , False ) , ( [string] , False ) ) ) @ pytest . mark . asyncio async def test_create_pkg_files ( mocker , pkg_cert_id , raises ) : [EOL] [docstring] [EOL] [EOL] async def fake_run_command ( cmd , ** kwargs ) : [EOL] assert cmd [ [number] : [number] ] == [ [string] ] [EOL] if raises : [EOL] raise IScriptError ( [string] ) [EOL] [EOL] key_config = { [string] : pkg_cert_id , [string] : [string] } [EOL] config = { [string] : [number] } [EOL] all_paths = [ ] [EOL] for i in range ( [number] ) : [EOL] all_paths . append ( mac . App ( app_path = [string] . format ( i , i ) , parent_dir = [string] . format ( i ) ) ) [EOL] mocker . patch . object ( mac , [string] , new = fake_run_command ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await mac . create_pkg_files ( config , key_config , all_paths ) [EOL] else : [EOL] assert await mac . create_pkg_files ( config , key_config , all_paths ) is None [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) @ pytest . mark . asyncio async def test_copy_pkgs_to_artifact_dir ( tmpdir , artifact_prefix ) : [EOL] [docstring] [EOL] num_pkgs = [number] [EOL] work_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] artifact_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] config = { [string] : artifact_dir , [string] : work_dir } [EOL] all_paths = [ ] [EOL] expected_paths = [ ] [EOL] for i in range ( num_pkgs ) : [EOL] app = mac . App ( pkg_path = os . path . join ( work_dir , str ( i ) , [string] . format ( i ) ) , artifact_prefix = artifact_prefix , orig_path = os . path . join ( work_dir , f" [string] { artifact_prefix } [string] { i } [string] { i } [string] " ) , ) [EOL] expected_path = os . path . join ( artifact_dir , f"{ artifact_prefix } [string] { i } [string] { i } [string] " ) [EOL] expected_paths . append ( expected_path ) [EOL] makedirs ( os . path . dirname ( app . pkg_path ) ) [EOL] with open ( app . pkg_path , [string] ) as fh : [EOL] fh . write ( expected_path ) [EOL] all_paths . append ( app ) [EOL] [EOL] await mac . copy_pkgs_to_artifact_dir ( config , all_paths ) [EOL] for i in range ( num_pkgs ) : [EOL] expected_path = expected_paths [ i ] [EOL] assert os . path . exists ( expected_path ) [EOL] assert expected_path == all_paths [ i ] . target_pkg_path [EOL] with open ( expected_path ) as fh : [EOL] assert fh . read ( ) == expected_path [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) ) @ pytest . mark . asyncio async def test_copy_xpis_to_artifact_dir ( tmpdir , artifact_prefix ) : [EOL] [docstring] [EOL] num_xpis = [number] [EOL] work_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] artifact_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] config = { [string] : artifact_dir , [string] : work_dir } [EOL] all_paths = [ ] [EOL] expected_paths = [ ] [EOL] for i in range ( num_xpis ) : [EOL] app = mac . App ( artifact_prefix = artifact_prefix , orig_path = os . path . join ( work_dir , f" [string] { artifact_prefix } [string] { i } [string] { i } [string] " ) ) [EOL] expected_path = os . path . join ( artifact_dir , f"{ artifact_prefix } [string] { i } [string] { i } [string] " ) [EOL] expected_paths . append ( expected_path ) [EOL] makedirs ( os . path . dirname ( app . orig_path ) ) [EOL] with open ( app . orig_path , [string] ) as fh : [EOL] fh . write ( expected_path ) [EOL] all_paths . append ( app ) [EOL] [EOL] await mac . copy_xpis_to_artifact_dir ( config , all_paths ) [EOL] for i in range ( num_xpis ) : [EOL] expected_path = expected_paths [ i ] [EOL] assert os . path . exists ( expected_path ) [EOL] with open ( expected_path ) as fh : [EOL] assert fh . read ( ) == expected_path [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , True , False , [string] ) , ( [string] , False , False , None ) , ( None , True , KeyError , None ) ) , ) @ pytest . mark . asyncio async def test_download_entitlements_file ( url , use_entitlements , raises , expected , mocker ) : [EOL] [docstring] [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] config = { [string] : [string] } [EOL] task = { [string] : { } } [EOL] key_config = { [string] : use_entitlements } [EOL] if url : [EOL] task [ [string] ] [ [string] ] = url [EOL] if raises : [EOL] with pytest . raises ( raises ) : [EOL] await mac . download_entitlements_file ( config , key_config , task ) [EOL] else : [EOL] assert await mac . download_entitlements_file ( config , key_config , task ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( False , True ) ) async def test_sign_behavior ( mocker , tmpdir , use_langpack ) : [EOL] [docstring] [EOL] [EOL] artifact_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] work_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] config = { [string] : artifact_dir , [string] : work_dir , [string] : [ [string] , [string] , [string] ] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } , } [EOL] [EOL] task = { [string] : { [string] : [ { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] , [string] ] } , { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] } , ] } } [EOL] if use_langpack : [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] task [ [string] ] [ [string] ] . append ( { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] } ) [EOL] [EOL] mocker . patch . object ( os , [string] , return_value = [ ] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = [string] ) [EOL] mocker . patch . object ( mac , [string] , return_value = os . path . join ( work_dir , [string] ) ) [EOL] mocker . patch . object ( mac , [string] , return_value = config [ [string] ] [ [string] ] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] await mac . sign_behavior ( config , task ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( False , True ) ) async def test_sign_and_pkg_behavior ( mocker , tmpdir , use_langpack ) : [EOL] [docstring] [EOL] [EOL] artifact_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] work_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] config = { [string] : artifact_dir , [string] : work_dir , [string] : [ [string] , [string] , [string] ] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } , } [EOL] [EOL] task = { [string] : { [string] : [ { [string] : [string] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] ] , } , { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] , [string] , [string] ] } , ] } } [EOL] if use_langpack : [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] task [ [string] ] [ [string] ] . append ( { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] } ) [EOL] [EOL] mocker . patch . object ( os , [string] , return_value = [ ] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = [string] ) [EOL] mocker . patch . object ( mac , [string] , return_value = os . path . join ( work_dir , [string] ) ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = config [ [string] ] [ [string] ] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] await mac . sign_and_pkg_behavior ( config , task ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , zip ( ( [string] , [string] , [string] ) , ( False , True ) ) ) @ pytest . mark . asyncio async def test_notarize_behavior ( mocker , tmpdir , notarize_type , use_langpack ) : [EOL] [docstring] [EOL] [EOL] artifact_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] work_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] config = { [string] : artifact_dir , [string] : work_dir , [string] : [ [string] , [string] , [string] ] , [string] : { [string] : { [string] : notarize_type , [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } , } [EOL] [EOL] task = { [string] : { [string] : [ { [string] : [string] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } , { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] , [string] ] } , ] } } [EOL] if use_langpack : [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] task [ [string] ] [ [string] ] . append ( { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] } ) [EOL] [EOL] mocker . patch . object ( os , [string] , return_value = [ ] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = [string] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = os . path . join ( work_dir , [string] ) ) [EOL] mocker . patch . object ( mac , [string] , return_value = None ) [EOL] mocker . patch . object ( mac , [string] , return_value = [string] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = config [ [string] ] [ [string] ] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] await mac . notarize_behavior ( config , task ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , zip ( ( [string] , [string] , [string] ) , ( False , True , False ) ) ) @ pytest . mark . asyncio async def test_notarize_1_behavior ( mocker , tmpdir , notarize_type , use_langpack ) : [EOL] [docstring] [EOL] [EOL] artifact_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] work_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] config = { [string] : artifact_dir , [string] : work_dir , [string] : [ [string] , [string] , [string] ] , [string] : { [string] : { [string] : notarize_type , [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } , } [EOL] [EOL] task = { [string] : { [string] : [ { [string] : [string] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } , { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] , [string] ] } , ] } } [EOL] if use_langpack : [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] task [ [string] ] [ [string] ] . append ( { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] } ) [EOL] [EOL] mocker . patch . object ( os , [string] , return_value = [ ] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = [string] ) [EOL] mocker . patch . object ( mac , [string] , return_value = os . path . join ( work_dir , [string] ) ) [EOL] mocker . patch . object ( mac , [string] , return_value = [string] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = config [ [string] ] [ [string] ] ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] await mac . notarize_1_behavior ( config , task ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_notarize_3_behavior ( mocker , tmpdir ) : [EOL] [docstring] [EOL] [EOL] artifact_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] work_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] config = { [string] : artifact_dir , [string] : work_dir , [string] : { [string] : { [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } , } [EOL] [EOL] task = { [string] : { [string] : [ { [string] : [string] , [string] : [ ] , [string] : [ [string] , [string] , [string] , [string] ] , } , { [string] : [string] , [string] : [ [string] , [string] ] , [string] : [ ] } , ] } } [EOL] [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = os . path . join ( work_dir , [string] ) ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] await mac . notarize_3_behavior ( config , task ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , ( False , True ) ) async def test_geckodriver_behavior ( mocker , tmpdir , use_langpack ) : [EOL] [docstring] [EOL] [EOL] artifact_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] work_dir = os . path . join ( str ( tmpdir ) , [string] ) [EOL] config = { [string] : artifact_dir , [string] : work_dir , [string] : [ [string] , [string] , [string] ] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } , } [EOL] [EOL] task = { [string] : { [string] : [ { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] } ] } } [EOL] if use_langpack : [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] task [ [string] ] [ [string] ] . append ( { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] } ) [EOL] [EOL] async def fake_extract ( _ , all_paths ) : [EOL] for app in all_paths : [EOL] assert [string] not in app . formats [EOL] app . parent_dir = f"{ work_dir } [string] " [EOL] makedirs ( app . parent_dir ) [EOL] touch ( f"{ app . parent_dir } [string] " ) [EOL] [EOL] mocker . patch . object ( mac , [string] , new = fake_extract ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , new = noop_async ) [EOL] mocker . patch . object ( mac , [string] , return_value = config [ [string] ] [ [string] ] ) [EOL] await mac . geckodriver_behavior ( config , task ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Tuple , Any , Union , Dict , List [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] [EOL] import pytest [EOL] [EOL] import iscript . script as script [EOL] from iscript . exceptions import IScriptError [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [ [string] , [string] ] , [string] , False ) , ( [string] , [ [string] , [string] ] , [string] , False ) , ( [string] , [ [string] , [string] ] , [string] , False ) , ( [string] , [ [string] ] , [string] , False ) , ( [string] , [ [string] ] , [string] , False ) , ( [string] , [ [string] , [string] ] , [string] , False ) , ( None , [ [string] ] , [string] , False ) , ( [string] , [ [string] , [string] ] , None , True ) , ( [string] , [ [string] , [string] ] , None , True ) , ( [string] , [ [string] , [string] ] , [string] , False ) , ( [string] , [ [string] , [string] ] , [string] , False ) , ) , ) @ pytest . mark . asyncio async def test_async_main ( mocker , behavior , supported_behaviors , expected_behavior , raises ) : [EOL] [docstring] [EOL] [EOL] calls = { } [EOL] config = { [string] : [string] } [EOL] task = { [string] : [string] , [string] : { } , [string] : [ ] } [EOL] if behavior : [EOL] task [ [string] ] [ [string] ] = behavior [EOL] expected = [ [ ( config , task ) , { } ] ] [EOL] key_config = { [string] : supported_behaviors } [EOL] [EOL] async def test_notarize ( * args , ** kwargs ) : [EOL] calls . setdefault ( [string] , [ ] ) . append ( [ args , kwargs ] ) [EOL] [EOL] async def test_notarize_1 ( * args , ** kwargs ) : [EOL] calls . setdefault ( [string] , [ ] ) . append ( [ args , kwargs ] ) [EOL] [EOL] async def test_notarize_3 ( * args , ** kwargs ) : [EOL] calls . setdefault ( [string] , [ ] ) . append ( [ args , kwargs ] ) [EOL] [EOL] async def test_geckodriver ( * args , ** kwargs ) : [EOL] calls . setdefault ( [string] , [ ] ) . append ( [ args , kwargs ] ) [EOL] [EOL] async def test_sign ( * args , ** kwargs ) : [EOL] calls . setdefault ( [string] , [ ] ) . append ( [ args , kwargs ] ) [EOL] [EOL] async def test_sign_and_pkg ( * args , ** kwargs ) : [EOL] calls . setdefault ( [string] , [ ] ) . append ( [ args , kwargs ] ) [EOL] [EOL] mocker . patch . object ( script , [string] , new = test_notarize ) [EOL] mocker . patch . object ( script , [string] , new = test_notarize_1 ) [EOL] mocker . patch . object ( script , [string] , new = test_notarize_3 ) [EOL] mocker . patch . object ( script , [string] , new = test_geckodriver ) [EOL] mocker . patch . object ( script , [string] , new = test_sign ) [EOL] mocker . patch . object ( script , [string] , new = test_sign_and_pkg ) [EOL] mocker . patch . object ( script , [string] , return_value = key_config ) [EOL] if raises : [EOL] with pytest . raises ( IScriptError ) : [EOL] await script . async_main ( config , task ) [EOL] else : [EOL] await script . async_main ( config , task ) [EOL] assert calls . get ( expected_behavior ) == expected [EOL] [EOL] [EOL] [comment] [EOL] def test_get_default_config ( tmpdir ) : [EOL] [docstring] [EOL] config = script . get_default_config ( base_dir = tmpdir ) [EOL] assert config [ [string] ] == os . path . join ( tmpdir , [string] ) [EOL] for k in ( [string] , [string] ) : [EOL] assert k in config [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_main ( mocker ) : [EOL] [docstring] [EOL] [EOL] calls = [ ] [EOL] config = { [string] : [string] } [EOL] [EOL] def fake_main ( * args , ** kwargs ) : [EOL] calls . append ( [ args , kwargs ] ) [EOL] [EOL] def fake_config ( ) : [EOL] return config [EOL] [EOL] async def fake_async_main ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] mocker . patch . object ( script , [string] , new = fake_main ) [EOL] mocker . patch . object ( script , [string] , new = fake_async_main ) [EOL] mocker . patch . object ( script , [string] , new = fake_config ) [EOL] script . main ( ) [EOL] assert calls == [ [ ( fake_async_main , ) , { [string] : config } ] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[comment] [EOL] from typing import Union , Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] [EOL] from scriptworker_client . client import sync_main [EOL] from scriptworker_client . utils import run_command [EOL] [EOL] from iscript . exceptions import IScriptError [EOL] from iscript . mac import geckodriver_behavior , notarize_1_behavior , notarize_3_behavior , notarize_behavior , sign_and_pkg_behavior , sign_behavior [EOL] from iscript . util import get_key_config [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_main ( config , task ) : [EOL] [docstring] [EOL] await run_command ( [ [string] ] ) [EOL] base_key = [string] [comment] [EOL] key_config = get_key_config ( config , task , base_key = base_key ) [EOL] behavior = task [ [string] ] . get ( [string] , [string] ) [EOL] if behavior == [string] and [string] not in key_config [ [string] ] and [string] in key_config [ [string] ] : [EOL] behavior = [string] [EOL] if behavior not in key_config [ [string] ] : [EOL] raise IScriptError ( [string] . format ( behavior , task [ [string] ] ) ) [EOL] if behavior == [string] : [EOL] await geckodriver_behavior ( config , task ) [EOL] return [EOL] elif behavior == [string] : [EOL] await notarize_behavior ( config , task ) [EOL] return [EOL] elif behavior == [string] : [EOL] await notarize_1_behavior ( config , task ) [EOL] return [EOL] elif behavior == [string] : [EOL] await notarize_3_behavior ( config , task ) [EOL] return [EOL] elif behavior == [string] : [EOL] await sign_behavior ( config , task ) [EOL] return [EOL] elif behavior == [string] : [EOL] [comment] [EOL] [comment] [EOL] await sign_and_pkg_behavior ( config , task ) [EOL] return [EOL] raise IScriptError ( [string] . format ( behavior ) ) [EOL] [EOL] [EOL] def get_default_config ( base_dir = None ) : [EOL] [docstring] [EOL] base_dir = base_dir or os . path . dirname ( os . getcwd ( ) ) [EOL] default_config = { [string] : os . path . join ( base_dir , [string] ) , [string] : os . path . join ( base_dir , [string] ) , [string] : os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) , [string] : [ ] , } [EOL] return default_config [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] return sync_main ( async_main , default_config = get_default_config ( ) ) [EOL] [EOL] [EOL] __name__ == [string] and main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from scriptworker_client . exceptions import TaskError [EOL] [EOL] [EOL] class IScriptError ( TaskError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class FailedSubprocess ( IScriptError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UnknownAppDir ( IScriptError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InvalidNotarization ( IScriptError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ThrottledNotarization ( IScriptError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UnknownNotarizationError ( IScriptError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class TimeoutError ( IScriptError ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Pattern , Any , Literal , Union , Dict , List [EOL] import typing [EOL] import requests [EOL] import logging [EOL] import typing_extensions [EOL] import zipfile [EOL] [docstring] [EOL] import asyncio [EOL] import base64 [EOL] import difflib [EOL] import glob [EOL] import json [EOL] import logging [EOL] import os [EOL] import re [EOL] import tempfile [EOL] import zipfile [EOL] [EOL] import requests [EOL] from mozpack import mozjar [EOL] from requests_hawk import HawkAuth [EOL] from scriptworker_client . aio import raise_future_exceptions , retry_async [EOL] from scriptworker_client . utils import makedirs , rm [EOL] [EOL] from iscript . createprecomplete import generate_precomplete [EOL] from iscript . exceptions import IScriptError [EOL] [EOL] try : [EOL] [comment] [EOL] import widevine [EOL] except ImportError : [EOL] widevine = None [EOL] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] _WIDEVINE_BLESSED_FILENAMES = ( [string] , [string] , ) [EOL] [comment] [EOL] _WIDEVINE_NONBLESSED_FILENAMES = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [comment] [EOL] LANGPACK_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] async def sign_widevine_dir ( config , key_config , app_dir ) : [EOL] [docstring] [EOL] log . info ( f" [string] { app_dir } [string] " ) [EOL] all_files = [ ] [EOL] for top_dir , dirs , files in os . walk ( app_dir ) : [EOL] for file_ in files : [EOL] all_files . append ( os . path . join ( top_dir , file_ ) ) [EOL] files_to_sign = _get_widevine_signing_files ( all_files ) [EOL] log . debug ( [string] , files_to_sign ) [EOL] if files_to_sign : [EOL] tasks = [ ] [EOL] for from_ , fmt in files_to_sign . items ( ) : [EOL] to = _get_mac_sigpath ( from_ ) [EOL] log . debug ( [string] , to ) [EOL] makedirs ( os . path . dirname ( to ) ) [EOL] tasks . append ( asyncio . ensure_future ( sign_widevine_with_autograph ( key_config , from_ , [string] in fmt , to = to ) ) ) [EOL] all_files . append ( to ) [EOL] await raise_future_exceptions ( tasks ) [EOL] remove_extra_files ( app_dir , all_files ) [EOL] [comment] [EOL] [comment] [EOL] _run_generate_precomplete ( config , app_dir ) [EOL] return app_dir [EOL] [EOL] [EOL] [comment] [EOL] def _get_mac_sigpath ( from_ ) : [EOL] [docstring] [EOL] to = from_ [EOL] if [string] in from_ : [EOL] parts = from_ . split ( [string] ) [EOL] parts . reverse ( ) [EOL] i = parts . index ( [string] ) [EOL] parts [ i ] = [string] [EOL] parts . reverse ( ) [EOL] to = [string] . join ( parts ) [EOL] log . debug ( [string] . format ( from_ , to ) ) [EOL] return [string] . format ( to ) [EOL] [EOL] [EOL] [comment] [EOL] def _get_widevine_signing_files ( file_list ) : [EOL] [docstring] [EOL] files = { } [EOL] for filename in file_list : [EOL] fmt = None [EOL] base_filename = os . path . basename ( filename ) [EOL] if base_filename in _WIDEVINE_BLESSED_FILENAMES : [EOL] fmt = [string] [EOL] elif base_filename in _WIDEVINE_NONBLESSED_FILENAMES : [EOL] fmt = [string] [EOL] if fmt : [EOL] log . debug ( [string] . format ( filename , fmt ) ) [EOL] sigpath = _get_mac_sigpath ( filename ) [EOL] if sigpath not in file_list : [EOL] files [ filename ] = fmt [EOL] else : [EOL] log . debug ( [string] . format ( filename ) ) [EOL] return files [EOL] [EOL] [EOL] [comment] [EOL] def _run_generate_precomplete ( config , app_dir ) : [EOL] [docstring] [EOL] log . info ( [string] ) [EOL] path = _ensure_one_precomplete ( app_dir , [string] ) [EOL] with open ( path , [string] ) as fh : [EOL] before = fh . readlines ( ) [EOL] generate_precomplete ( os . path . dirname ( path ) ) [EOL] path = _ensure_one_precomplete ( app_dir , [string] ) [EOL] with open ( path , [string] ) as fh : [EOL] after = fh . readlines ( ) [EOL] [comment] [EOL] makedirs ( os . path . join ( config [ [string] ] , [string] , [string] ) ) [EOL] diff_path = os . path . join ( config [ [string] ] , [string] , [string] , [string] ) [EOL] with open ( diff_path , [string] ) as fh : [EOL] for line in difflib . ndiff ( before , after ) : [EOL] fh . write ( line ) [EOL] [EOL] [EOL] [comment] [EOL] def _ensure_one_precomplete ( tmp_dir , adj ) : [EOL] [docstring] [EOL] precompletes = glob . glob ( os . path . join ( tmp_dir , [string] , [string] ) , recursive = True ) [EOL] if len ( precompletes ) < [number] : [EOL] raise IScriptError ( [string] , tmp_dir ) [EOL] if len ( precompletes ) > [number] : [EOL] raise IScriptError ( [string] , adj , tmp_dir ) [EOL] return precompletes [ [number] ] [EOL] [EOL] [EOL] [comment] [EOL] def remove_extra_files ( top_dir , file_list ) : [EOL] [docstring] [EOL] all_files = [ os . path . realpath ( f ) for f in glob . glob ( os . path . join ( top_dir , [string] , [string] ) , recursive = True ) ] [EOL] good_files = [ os . path . realpath ( f ) for f in file_list ] [EOL] extra_files = list ( set ( all_files ) - set ( good_files ) ) [EOL] for f in extra_files : [EOL] if os . path . isfile ( f ) : [EOL] log . warning ( [string] . format ( f ) ) [EOL] rm ( f ) [EOL] return extra_files [EOL] [EOL] [EOL] [comment] [EOL] async def call_autograph ( url , user , password , request_json ) : [EOL] [docstring] [EOL] auth = HawkAuth ( id = user , key = password ) [EOL] with requests . Session ( ) as session : [EOL] r = session . post ( url , json = request_json , auth = auth ) [EOL] log . debug ( [string] , r . text [ : [number] ] if len ( r . text ) >= [number] else r . text ) [EOL] r . raise_for_status ( ) [EOL] return r . json ( ) [EOL] [EOL] [EOL] def make_signing_req ( input_bytes , fmt , keyid = None , extension_id = None ) : [EOL] [docstring] [EOL] base64_input = base64 . b64encode ( input_bytes ) . decode ( [string] ) [EOL] sign_req = { [string] : base64_input } [EOL] [EOL] if keyid : [EOL] sign_req [ [string] ] = keyid [EOL] [EOL] if [string] in fmt or [string] in fmt : [EOL] sign_req . setdefault ( [string] , { } ) [EOL] [comment] [EOL] sign_req [ [string] ] [ [string] ] = extension_id [EOL] sign_req [ [string] ] [ [string] ] = [ [string] ] [EOL] sign_req [ [string] ] [ [string] ] = [string] [EOL] log . debug ( f"{ fmt } [string] { sign_req [ [string] ] }" ) [EOL] [EOL] return [ sign_req ] [EOL] [EOL] [EOL] async def sign_with_autograph ( key_config , input_bytes , fmt , autograph_method , keyid = None , extension_id = None ) : [EOL] [docstring] [EOL] if autograph_method not in { [string] , [string] , [string] } : [EOL] raise IScriptError ( f" [string] { autograph_method }" ) [EOL] [EOL] sign_req = make_signing_req ( input_bytes , fmt , keyid = keyid , extension_id = extension_id ) [EOL] short_fmt = fmt . replace ( [string] , [string] ) [EOL] url = key_config [ f"{ short_fmt } [string] " ] [EOL] user = key_config [ f"{ short_fmt } [string] " ] [EOL] pw = key_config [ f"{ short_fmt } [string] " ] [EOL] [EOL] log . debug ( [string] , fmt , autograph_method ) [EOL] [EOL] url = f"{ url } [string] { autograph_method }" [EOL] [EOL] sign_resp = await retry_async ( call_autograph , args = ( url , user , pw , sign_req ) , attempts = [number] , sleeptime_kwargs = { [string] : [number] } ) [EOL] [EOL] if autograph_method == [string] : [EOL] return sign_resp [ [number] ] [ [string] ] [EOL] else : [EOL] return sign_resp [ [number] ] [ [string] ] [EOL] [EOL] [EOL] async def sign_file_with_autograph ( key_config , from_ , fmt , to = None , extension_id = None ) : [EOL] [docstring] [EOL] to = to or from_ [EOL] input_bytes = open ( from_ , [string] ) . read ( ) [EOL] signed_bytes = base64 . b64decode ( await sign_with_autograph ( key_config , input_bytes , fmt , [string] , extension_id = extension_id ) ) [EOL] with open ( to , [string] ) as fout : [EOL] fout . write ( signed_bytes ) [EOL] return to [EOL] [EOL] [EOL] async def sign_hash_with_autograph ( key_config , hash_ , fmt , keyid = None ) : [EOL] [docstring] [EOL] signature = base64 . b64decode ( await sign_with_autograph ( key_config , hash_ , fmt , [string] , keyid ) ) [EOL] return signature [EOL] [EOL] [EOL] [comment] [EOL] def _get_omnija_signing_files ( file_list ) : [EOL] [docstring] [EOL] files = { } [EOL] for filename in file_list : [EOL] fmt = None [EOL] base_filename = os . path . basename ( filename ) [EOL] if base_filename in { [string] } : [EOL] fmt = [string] [EOL] if fmt : [EOL] log . debug ( [string] . format ( filename , fmt ) ) [EOL] files [ filename ] = fmt [EOL] return files [EOL] [EOL] [EOL] async def sign_omnija_with_autograph ( config , key_config , app_path ) : [EOL] [docstring] [EOL] log . info ( f" [string] { app_path } [string] " ) [EOL] all_files = [ ] [EOL] for top_dir , dirs , files in os . walk ( app_path ) : [EOL] for file_ in files : [EOL] all_files . append ( os . path . join ( top_dir , file_ ) ) [EOL] files_to_sign = _get_omnija_signing_files ( all_files ) [EOL] for from_ in files_to_sign : [EOL] signed_out = tempfile . mkstemp ( prefix = [string] , suffix = [string] , dir = config [ [string] ] ) [ [number] ] [EOL] merged_out = tempfile . mkstemp ( prefix = [string] , suffix = [string] , dir = config [ [string] ] ) [ [number] ] [EOL] [EOL] await sign_file_with_autograph ( key_config , from_ , [string] , to = signed_out , extension_id = [string] ) [EOL] await merge_omnija_files ( orig = from_ , signed = signed_out , to = merged_out ) [EOL] with open ( from_ , [string] ) as fout : [EOL] with open ( merged_out , [string] ) as fin : [EOL] fout . write ( fin . read ( ) ) [EOL] return files_to_sign [EOL] [EOL] [EOL] async def merge_omnija_files ( orig , signed , to ) : [EOL] [docstring] [EOL] orig_jarreader = mozjar . JarReader ( orig ) [EOL] with mozjar . JarWriter ( to , compress = orig_jarreader . compression ) as to_writer : [EOL] for origjarfile in orig_jarreader : [EOL] to_writer . add ( origjarfile . filename , origjarfile , compress = origjarfile . compress ) [EOL] [comment] [EOL] signed_zip = zipfile . ZipFile ( signed , [string] ) [EOL] for fname in signed_zip . namelist ( ) : [EOL] if fname . startswith ( [string] ) : [EOL] to_writer . add ( fname , signed_zip . open ( fname , [string] ) ) [EOL] if orig_jarreader . last_preloaded : [EOL] jarlog = list ( orig_jarreader . entries . keys ( ) ) [EOL] preloads = jarlog [ : jarlog . index ( orig_jarreader . last_preloaded ) + [number] ] [EOL] to_writer . preload ( preloads ) [EOL] return True [EOL] [EOL] [EOL] [comment] [EOL] async def sign_widevine_with_autograph ( key_config , from_ , blessed , to = None ) : [EOL] [docstring] [EOL] if not widevine : [EOL] raise ImportError ( [string] ) [EOL] [EOL] to = to or f"{ from_ } [string] " [EOL] flags = [number] if blessed else [number] [EOL] fmt = [string] [EOL] [EOL] h = widevine . generate_widevine_hash ( from_ , flags ) [EOL] [EOL] signature = await sign_hash_with_autograph ( key_config , h , fmt ) [EOL] [EOL] with open ( to , [string] ) as fout : [EOL] certificate = open ( key_config [ [string] ] , [string] ) . read ( ) [EOL] sig = widevine . generate_widevine_signature ( signature , certificate , flags ) [EOL] fout . write ( sig ) [EOL] return to [EOL] [EOL] [EOL] def langpack_id ( app ) : [EOL] [docstring] [EOL] _ , file_extension = os . path . splitext ( app . orig_path ) [EOL] if not file_extension == [string] : [EOL] raise IScriptError ( f" [string] { app . orig_path }" ) [EOL] [EOL] langpack = zipfile . ZipFile ( app . orig_path , [string] ) [EOL] id = None [EOL] with langpack . open ( [string] , [string] ) as f : [EOL] manifest = json . load ( f ) [EOL] if not ( [string] in manifest [EOL] and [string] in manifest [EOL] and [string] in manifest [EOL] and [string] in manifest [ [string] ] [EOL] and [string] in manifest [ [string] ] [ [string] ] [EOL] and LANGPACK_RE . match ( manifest [ [string] ] [ [string] ] [ [string] ] ) ) : [EOL] raise IScriptError ( f"{ app . orig_path } [string] " ) [EOL] id = manifest [ [string] ] [ [string] ] [ [string] ] [EOL] return id [EOL] [EOL] [EOL] async def sign_langpacks ( config , key_config , all_paths ) : [EOL] [docstring] [EOL] for app in all_paths : [EOL] app . check_required_attrs ( [ [string] , [string] , [string] ] ) [EOL] if not { [string] } & set ( app . formats ) : [EOL] raise IScriptError ( f"{ app . formats } [string] " ) [EOL] app . target_tar_path = [string] . format ( config [ [string] ] , app . artifact_prefix , app . orig_path . split ( app . artifact_prefix ) [ [number] ] ) [EOL] [EOL] id = langpack_id ( app ) [EOL] log . info ( [string] . format ( app . orig_path , id ) ) [EOL] makedirs ( os . path . dirname ( app . target_tar_path ) ) [EOL] await sign_file_with_autograph ( key_config , app . orig_path , [string] , to = app . target_tar_path , extension_id = id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from iscript . exceptions import IScriptError [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] _CERT_TYPE_TO_KEY_CONFIG = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def task_cert_type ( config , task ) : [EOL] [docstring] [EOL] cert_prefix = [string] . format ( config [ [string] ] ) [EOL] cert_scopes = [ i for i in task [ [string] ] if i . startswith ( cert_prefix ) ] [EOL] if len ( cert_scopes ) > [number] : [EOL] raise IScriptError ( [string] . format ( cert_scopes ) ) [EOL] if len ( cert_scopes ) < [number] : [EOL] raise IScriptError ( [string] . format ( task [ [string] ] ) ) [EOL] return cert_scopes [ [number] ] . replace ( cert_prefix , [string] ) [EOL] [EOL] [EOL] def get_key_config ( config , task , base_key = [string] ) : [EOL] [docstring] [EOL] try : [EOL] cert_type = task_cert_type ( config , task ) [EOL] return config [ base_key ] [ _CERT_TYPE_TO_KEY_CONFIG [ cert_type ] ] [EOL] except KeyError as exc : [EOL] raise IScriptError ( [string] . format ( str ( exc ) ) ) from exc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import click [EOL] import json [EOL] [EOL] import pytest [EOL] import slugid [EOL] from click . testing import CliRunner [EOL] [EOL] from configloader . script import main [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , { [string] : [string] } , { } , [number] , { [string] : [string] } ) , ( [string] , { [string] : [string] , [string] : [string] } , { } , [number] , { [string] : [string] , [string] : [string] } , ) , ( [string] , { [string] : [string] , [string] : [string] } , { } , [number] , { [string] : [string] , [string] : [string] } ) , ( [string] , { [string] : [string] , [string] : [string] } , { } , [number] , { [string] : [string] , [string] : [string] } , ) , ( [string] , { [string] : [string] , [string] : [string] } , { [string] : [string] } , [number] , { [string] : [string] , [string] : [string] } , ) , ( [string] , { [string] : [string] , [string] : [string] } , { } , [number] , { } ) , ) , ) def test_main ( monkeypatch , worker_id_prefix , input , env , exit_code , expected ) : [EOL] runner = CliRunner ( ) [EOL] for envvar , envvalue in env . items ( ) : [EOL] monkeypatch . setenv ( envvar , envvalue ) [EOL] with runner . isolated_filesystem ( ) : [EOL] with open ( [string] , [string] ) as input_file : [EOL] json . dump ( input , input_file ) [EOL] [EOL] with monkeypatch . context ( ) as m : [EOL] m . setattr ( slugid , [string] , lambda : [string] ) [EOL] result = runner . invoke ( main , [ [string] , worker_id_prefix , [string] , [string] ] ) [EOL] assert result . exit_code == exit_code [EOL] if exit_code == [number] : [EOL] output = json . load ( open ( [string] ) ) [EOL] assert output == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] import click [EOL] import jsone [EOL] import slugid [EOL] import yaml [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , default = [string] , help = [string] ) @ click . argument ( [string] , type = click . File ( [string] ) ) @ click . argument ( [string] , type = click . File ( [string] ) ) def main ( worker_id_prefix , input , output ) : [EOL] [docstring] [EOL] config_template = yaml . safe_load ( input ) [EOL] context = os . environ . copy ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] worker_id = worker_id_prefix + slugid . nice ( ) . lower ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] context [ [string] ] = worker_id [ : [number] ] [EOL] config = jsone . render ( config_template , context ) [EOL] json . dump ( config , output , indent = [number] , sort_keys = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import os [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] project_dir = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] with open ( os . path . join ( project_dir , [string] ) ) as f : [EOL] version = f . read ( ) . rstrip ( ) [EOL] [EOL] [comment] [EOL] with open ( os . path . join ( project_dir , [string] ) ) as f : [EOL] requirements = [ line . rstrip ( [string] ) for line in f if not line . startswith ( [string] ) ] [EOL] [EOL] [EOL] setup ( name = [string] , version = version , description = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( [string] ) , package_data = { [string] : [ [string] ] } , package_dir = { [string] : [string] } , include_package_data = True , zip_safe = False , entry_points = { [string] : [ [string] ] } , license = [string] , install_requires = requirements , classifiers = ( [string] , [string] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import json [EOL] import os [EOL] import tempfile [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] import scriptworker . utils as sutils [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] import bouncerscript . utils as butils [EOL] from bouncerscript . task import get_task_action , get_task_server [EOL] from bouncerscript . utils import ( _do_api_call , api_add_location , api_add_product , api_call , api_modify_location , api_show_location , api_show_product , api_update_alias , does_product_exist , get_locations_info , get_nightly_version , get_version_bumped_path , ) [EOL] [EOL] from . import load_json , noop_async [EOL] [EOL] [EOL] def test_load_json_from_file ( ) : [EOL] json_object = { [string] : [string] } [EOL] [EOL] with tempfile . TemporaryDirectory ( ) as output_dir : [EOL] output_file = os . path . join ( output_dir , [string] ) [EOL] with open ( output_file , [string] ) as f : [EOL] json . dump ( json_object , f ) [EOL] [EOL] assert load_json ( output_file ) == json_object [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( (None) , ( { [string] : aiohttp . ClientError } ) ) ) @ pytest . mark . asyncio async def test_api_call ( submission_context , mocker , retry_config ) : [EOL] mocker . patch . object ( butils , [string] , new = noop_async ) [EOL] mocker . patch . object ( sutils , [string] , new = noop_async ) [EOL] await api_call ( submission_context , [string] , { } , retry_config ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { } , False ) , ( { [string] : [string] } , True ) ) ) def test_do_successful_api_call ( submission_context , mocker , event_loop , fake_session , data , credentials ) : [EOL] context = submission_context [EOL] context . server = get_task_server ( context . task , context . config ) [EOL] context . action = get_task_action ( context . task , context . config ) [EOL] context . session = fake_session [EOL] [EOL] if not credentials : [EOL] del context . config [ [string] ] [ context . server ] [ [string] ] [EOL] del context . config [ [string] ] [ context . server ] [ [string] ] [EOL] [EOL] with pytest . raises ( KeyError ) : [EOL] response = event_loop . run_until_complete ( _do_api_call ( context , [string] , data ) ) [EOL] [EOL] return [EOL] [EOL] response = event_loop . run_until_complete ( _do_api_call ( context , [string] , data ) ) [EOL] [EOL] assert response == [string] [EOL] [EOL] [EOL] [comment] [EOL] def test_do_failed_api_call ( submission_context , mocker , event_loop , fake_session_500 ) : [EOL] context = submission_context [EOL] context . server = get_task_server ( context . task , context . config ) [EOL] context . action = get_task_action ( context . task , context . config ) [EOL] context . session = fake_session_500 [EOL] [EOL] response = event_loop . run_until_complete ( _do_api_call ( context , [string] , { } ) ) [EOL] [EOL] assert response == [string] [EOL] [EOL] [EOL] [comment] [EOL] def test_do_failed_with_ClientError_api_call ( submission_context , mocker , event_loop , fake_ClientError_throwing_session ) : [EOL] context = submission_context [EOL] context . server = get_task_server ( context . task , context . config ) [EOL] context . action = get_task_action ( context . task , context . config ) [EOL] context . session = fake_ClientError_throwing_session [EOL] [EOL] with pytest . raises ( aiohttp . ClientError ) : [EOL] event_loop . run_until_complete ( _do_api_call ( context , [string] , { } ) ) [EOL] [EOL] [EOL] [comment] [EOL] def test_do_failed_with_TimeoutError_api_call ( submission_context , mocker , event_loop , fake_TimeoutError_throwing_session ) : [EOL] context = submission_context [EOL] context . server = get_task_server ( context . task , context . config ) [EOL] context . action = get_task_action ( context . task , context . config ) [EOL] context . session = fake_TimeoutError_throwing_session [EOL] [EOL] with pytest . raises ( aiohttp . ServerTimeoutError ) : [EOL] event_loop . run_until_complete ( _do_api_call ( context , [string] , { } ) ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) ) , ) @ pytest . mark . asyncio async def test_does_product_exist ( submission_context , mocker , product , response , expected ) : [EOL] context = submission_context [EOL] [EOL] async def fake_api_call ( context , product_name ) : [EOL] return response [EOL] [EOL] mocker . patch . object ( butils , [string] , new = fake_api_call ) [EOL] assert await does_product_exist ( context , product ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , False , False , ( [string] , { [string] : [string] } ) ) , ( [string] , True , False , ( [string] , { [string] : [string] , [string] : [ [string] , [string] ] } ) ) , ( [string] , False , True , ( [string] , { [string] : [string] , [string] : [string] } ) ) , ( [string] , True , True , ( [string] , { [string] : [string] , [string] : [ [string] , [string] ] , [string] : [string] } ) ) , ) , ) @ pytest . mark . asyncio async def test_api_add_product ( submission_context , mocker , product , add_locales , ssl_only , expected ) : [EOL] context = submission_context [EOL] [EOL] async def fake_api_call ( context , route , data ) : [EOL] return route , data [EOL] [EOL] mocker . patch . object ( butils , [string] , new = fake_api_call ) [EOL] assert await api_add_product ( context , product , add_locales , ssl_only ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] , ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] } ) ) , ) ) @ pytest . mark . asyncio async def test_api_add_location ( submission_context , mocker , product , os , path , expected ) : [EOL] context = submission_context [EOL] [EOL] async def fake_api_call ( context , route , data ) : [EOL] return route , data [EOL] [EOL] mocker . patch . object ( butils , [string] , new = fake_api_call ) [EOL] assert await api_add_location ( context , product , os , path ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] , ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] } ) ) , ) ) @ pytest . mark . asyncio async def test_api_modify_location ( submission_context , mocker , product , os , path , expected ) : [EOL] context = submission_context [EOL] [EOL] async def fake_api_call ( context , route , data ) : [EOL] return route , data [EOL] [EOL] mocker . patch . object ( butils , [string] , new = fake_api_call ) [EOL] assert await api_modify_location ( context , product , os , path ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ) , ) @ pytest . mark . asyncio async def test_api_show_product ( submission_context , mocker , product , provided , expected ) : [EOL] context = submission_context [EOL] [EOL] async def fake_api_call ( context , location , data ) : [EOL] return provided [EOL] [EOL] mocker . patch . object ( butils , [string] , new = fake_api_call ) [EOL] assert await api_show_product ( context , product ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , ( [string] [string] [string] [string] [string] ) , ) , ( [string] , ( [string] [string] [string] [string] [string] ) , ) , ) , ) @ pytest . mark . asyncio async def test_api_show_location ( submission_context , mocker , product , expected ) : [EOL] context = submission_context [EOL] [EOL] async def fake_api_call ( context , location , data ) : [EOL] return expected [EOL] [EOL] mocker . patch . object ( butils , [string] , new = fake_api_call ) [EOL] assert await api_show_location ( context , product ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , ( [string] , { [string] : [string] , [string] : [string] } ) ) , ) ) @ pytest . mark . asyncio async def test_api_update_alias ( submission_context , mocker , alias , product , expected ) : [EOL] context = submission_context [EOL] [EOL] async def fake_api_call ( context , route , data ) : [EOL] return route , data [EOL] [EOL] mocker . patch . object ( butils , [string] , new = fake_api_call ) [EOL] assert await api_update_alias ( context , alias , product ) == expected [EOL] [EOL] [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , True , ) , ( [string] , [string] , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , False , ) , ( [string] , [string] , [ { [string] : [string] , [string] : [string] , [string] : [string] } ] , False , ) , ( [string] , [string] , [ ] , False ) , ) , ) @ pytest . mark . asyncio async def test_does_location_path_exist ( submission_context , mocker , platform , path , returned_locations , expected ) : [EOL] context = submission_context [EOL] [EOL] async def patch_get_locations_paths ( * args , ** kwargs ) : [EOL] return returned_locations [EOL] [EOL] mocker . patch . object ( butils , [string] , new = patch_get_locations_paths ) [EOL] assert await butils . does_location_path_exist ( context , [string] , platform , path ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [ ] , False ) , ( [string] , [string] , None , True , ) , ( [string] , [string] , None , True , ) , ( [string] , [string] , None , True , ) , ( [string] , ( [string] [string] [string] [string] [string] ) , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , False , ) , ( [string] , ( [string] [string] [string] [string] [string] [string] ) , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , False , ) , ( [string] , ( [string] [string] [string] [string] [string] ) , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , False , ) , ( [string] , ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , False , ) , ( [string] , ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , False , ) , ( [string] , ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , False , ) , ( [string] , ( [string] [string] [string] [string] [string] [string] ) , [ ] , True , ) , ) , ) @ pytest . mark . asyncio async def test_get_locations_info ( submission_context , mocker , product , response , expected , raises ) : [EOL] context = submission_context [EOL] [EOL] async def fake_api_call ( context , product ) : [EOL] return response [EOL] [EOL] mocker . patch . object ( butils , [string] , new = fake_api_call ) [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await get_locations_info ( context , product ) [EOL] else : [EOL] assert await get_locations_info ( context , product ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , True ) , ) , ) def test_get_nightly_version ( product , path , expected , raises ) : [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] get_nightly_version ( product , path ) [EOL] else : [EOL] get_nightly_version ( product , path ) == expected [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , [string] , [string] , ) , ( [string] , [string] , [string] , [string] , ) , ( [string] , [string] , [string] , [string] , ) , ( [string] , [string] , [string] , [string] , ) , ) , ) def test_get_version_bumped_path ( path , current_version , next_version , expected ) : [EOL] assert get_version_bumped_path ( path , current_version , next_version ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterator [EOL] import typing [EOL] import itertools [EOL] [EOL] import mock [EOL] import pytest [EOL] from scriptworker . exceptions import ScriptWorkerTaskException , TaskVerificationError [EOL] [EOL] import bouncerscript . script as bscript [EOL] from bouncerscript . script import async_main , bouncer_aliases , bouncer_locations , bouncer_submission , main [EOL] [EOL] from . import counted , noop_async , noop_sync , raise_sync , return_empty_list_async , return_false_async , return_true_async , return_true_sync , toggled_boolean_async [EOL] [EOL] [EOL] [comment] [EOL] def test_main ( submission_context ) : [EOL] async def fake_async_main_with_exception ( context ) : [EOL] raise ScriptWorkerTaskException ( [string] ) [EOL] [EOL] with mock . patch ( [string] , new = noop_async ) : [EOL] main ( config_path = [string] ) [EOL] [EOL] with mock . patch ( [string] , new = fake_async_main_with_exception ) : [EOL] try : [EOL] main ( config_path = [string] ) [EOL] except SystemExit as exc : [EOL] assert exc . code == [number] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_bouncer_submission ( submission_context , mocker ) : [EOL] mocker . patch . object ( bscript , [string] , new = toggled_boolean_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = return_empty_list_async ) [EOL] mocker . patch . object ( bscript , [string] , new = toggled_boolean_async ) [EOL] mocker . patch . object ( bscript , [string] , new = raise_sync ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_sync ) [EOL] [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await bouncer_submission ( submission_context ) [EOL] [EOL] mocker . patch . object ( bscript , [string] , new = noop_sync ) [EOL] await bouncer_submission ( submission_context ) [EOL] [EOL] mocker . patch . object ( bscript , [string] , new = raise_sync ) [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await bouncer_submission ( submission_context ) [EOL] [EOL] mocker . patch . object ( bscript , [string] , new = return_false_async ) [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await bouncer_submission ( submission_context ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_bouncer_submission_creates_locations_even_when_product_already_exists ( submission_context , mocker ) : [EOL] api_add_location_call_counter = itertools . count ( ) [EOL] [EOL] async def mock_api_add_location ( * args , ** kwargs ) : [EOL] next ( api_add_location_call_counter ) [EOL] [EOL] mocker . patch . object ( bscript , [string] , new = mock_api_add_location ) [EOL] mocker . patch . object ( bscript , [string] , new = return_true_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = return_empty_list_async ) [EOL] mocker . patch . object ( bscript , [string] , new = return_false_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_sync ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_sync ) [EOL] await bouncer_submission ( submission_context ) [EOL] assert next ( api_add_location_call_counter ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_bouncer_submission_creates_locations_even_some_exists ( submission_context , mocker ) : [EOL] api_add_location_call_counter = itertools . count ( ) [EOL] [EOL] async def mock_api_add_location ( * args , ** kwargs ) : [EOL] next ( api_add_location_call_counter ) [EOL] [EOL] mocker . patch . object ( bscript , [string] , new = mock_api_add_location ) [EOL] mocker . patch . object ( bscript , [string] , new = return_true_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = return_empty_list_async ) [EOL] mocker . patch . object ( bscript , [string] , new = toggled_boolean_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_sync ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_sync ) [EOL] await bouncer_submission ( submission_context ) [EOL] assert next ( api_add_location_call_counter ) == [number] [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_bouncer_aliases ( aliases_context , mocker ) : [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] [EOL] await bouncer_aliases ( aliases_context ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , [ ] , False , ) , ( [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , [ ] , True , ) , ( [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , [ ] , True , ) , ( [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , [ ] , True , ) , ( [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , False , ) , ) , ) [comment] [EOL] @ pytest . mark . asyncio async def test_bouncer_locations ( locations_context , mocker , info , updated_info , raises ) : [EOL] async def fake_get_locations_info ( * args , ** kwargs ) : [EOL] return info [EOL] [EOL] @ counted async def toggled_get_locations_info ( * args , ** kwargs ) : [EOL] if toggled_get_locations_info . calls & [number] : [EOL] return info [EOL] else : [EOL] return updated_info [EOL] [EOL] locations_context . task [ [string] ] [ [string] ] = [ [string] ] [EOL] locations_context . task [ [string] ] [ [string] ] = [string] [EOL] mocker . patch . object ( bscript , [string] , new = noop_sync ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_sync ) [EOL] mocker . patch . object ( bscript , [string] , new = return_false_async ) [EOL] [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await bouncer_locations ( locations_context ) [EOL] [EOL] mocker . patch . object ( bscript , [string] , new = return_true_async ) [EOL] mocker . patch . object ( bscript , [string] , new = fake_get_locations_info ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_sync ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await bouncer_locations ( locations_context ) [EOL] else : [EOL] if updated_info != [ ] : [EOL] mock = mocker . MagicMock ( ) [EOL] mock . side_effect = toggled_get_locations_info [EOL] mocker . patch . object ( bscript , [string] , new = mock ) [EOL] await bouncer_locations ( locations_context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . asyncio async def test_async_main ( submission_context , mocker ) : [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = noop_async ) [EOL] mocker . patch . object ( bscript , [string] , new = return_true_sync ) [EOL] [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await async_main ( submission_context ) [EOL] [EOL] mocker . patch . object ( bscript , [string] , new = { } ) [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] await async_main ( submission_context ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Dict [EOL] import typing [EOL] import pytest [EOL] from mozilla_version . errors import PatternNotMatchedError [EOL] from scriptworker . exceptions import ScriptWorkerTaskException , TaskVerificationError [EOL] [EOL] import bouncerscript . task as btask [EOL] from bouncerscript . task import ( check_aliases_match , check_location_path_matches_destination , check_locations_match , check_path_matches_destination , check_product_names_match_aliases , check_product_names_match_nightly_locations , check_version_matches_nightly_regex , check_versions_are_successive , get_supported_actions , get_task_action , get_task_server , validate_task_schema , ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] ] , None , True ) , ( [ [string] ] , None , True ) , ( [ [string] , [string] ] , [string] , False ) , ) , ) def test_get_task_server ( scopes , expected , raises ) : [EOL] task = { [string] : scopes } [EOL] config = { [string] : [string] , [string] : { [string] : [string] } } [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] get_task_server ( task , config ) [EOL] else : [EOL] assert expected == get_task_server ( task , config ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] ] , None , True ) , ( [ [string] ] , None , True ) , ( [ [string] ] , [string] , False ) , ( [ [string] ] , [string] , False ) , ) , ) def test_get_task_action ( scopes , expected , raises ) : [EOL] task = { [string] : scopes } [EOL] config = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } } [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] get_task_action ( task , config ) [EOL] else : [EOL] assert expected == get_task_action ( task , config ) [EOL] [EOL] [EOL] [comment] [EOL] def test_get_supported_actions ( ) : [EOL] config = { [string] : { [string] : [string] , [string] : [string] } } [EOL] assert sorted ( get_supported_actions ( config ) ) == sorted ( ( [string] , [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL] def test_validate_task_schema ( submission_context , schema = [string] ) : [EOL] validate_task_schema ( submission_context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , False , ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , False ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] } , False ) , ( { [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] , [string] : [string] } , True ) , ( { [string] : [string] } , True ) , ) , ) def test_check_product_names_match_aliases ( aliases_context , entries , raises ) : [EOL] context = aliases_context [EOL] context . task [ [string] ] [ [string] ] = entries [EOL] if raises : [EOL] with pytest . raises ( TaskVerificationError ) : [EOL] check_product_names_match_aliases ( context ) [EOL] else : [EOL] check_product_names_match_aliases ( context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [ [string] , [string] ] , { [string] : [string] , [string] : [string] } , False ) , ( [ [string] , [string] ] , { [string] : [string] , [string] : [string] } , False ) , ( [ ] , { } , False ) , ( [ [string] , [string] , ] , { [string] : [string] , [string] : [string] , } , False , ) , ( [ [string] ] , { [string] : [string] } , True ) , ( [ ] , { [string] : [string] } , True ) , ) , ) def test_check_locations_match ( locations , product_config , raises ) : [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] check_locations_match ( locations , product_config ) [EOL] else : [EOL] check_locations_match ( locations , product_config ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ) ) , ) def test_check_path_matches_destination ( product_name , path , raises ) : [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] check_path_matches_destination ( product_name , path ) [EOL] else : [EOL] check_path_matches_destination ( product_name , path ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( { [string] : [string] , [string] : [string] } , { ( [string] [string] ) : [string] , ( [string] [string] ) : [string] , ( [string] [string] ) : [string] , ( [string] [string] ) : [string] , ( [string] [string] ) : [string] , } , False , ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , { ( [string] [string] ) : ( [string] [string] [string] [string] ) , ( [string] [string] ) : ( [string] [string] [string] [string] ) , ( [string] [string] ) : ( [string] [string] [string] ) , ( [string] [string] ) : ( [string] [string] [string] ) , ( [string] [string] ) : ( [string] [string] [string] [string] ) , ( [string] [string] ) : ( [string] [string] [string] ) , } , False , ) , ( { [string] : [string] , [string] : [string] , [string] : [string] } , { ( [string] [string] ) : [string] , ( [string] [string] ) : [string] , ( [string] [string] ) : [string] , } , False , ) , ( { [string] : [string] } , { ( [string] [string] ) : ( [string] [string] [string] [string] ) , ( [string] [string] ) : ( [string] [string] [string] ) , } , True , ) , ) ) , ) @ pytest . mark . asyncio async def test_check_aliases_match ( aliases_context , mocker , entries , provided , raises ) : [EOL] async def fake_retry_request ( context , url , good = ( [number] , ) ) : [EOL] return provided [ url ] [EOL] [EOL] aliases_context . task [ [string] ] [ [string] ] = entries [EOL] mocker . patch . object ( btask , [string] , new = fake_retry_request ) [EOL] [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] await check_aliases_match ( aliases_context ) [EOL] else : [EOL] await check_aliases_match ( aliases_context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( [ [string] , [string] , [string] , [string] ] , False ) , ( [ [string] , [string] ] , True ) , ( [ [string] , [string] ] , True ) , ( [ [string] , [string] , [string] ] , True ) , ( [ [string] , [string] , [string] ] , True ) , ( [ [string] , [string] ] , True ) , ( [ [string] , [string] ] , True ) , ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , False , ) , ( [ [string] , [string] , [string] ] , True ) , ( [ [string] , [string] ] , True ) , ( [ [string] , [string] ] , True ) , ( [ [string] ] , True ) , ( [ [string] ] , False ) , ( [ [string] , [string] ] , True ) , ( [ [string] , [string] , [string] , [string] , [string] ] , True ) , ) ) , ) def test_check_product_names_match_nightly_locations ( locations_context , products , raises ) : [EOL] locations_context . task [ [string] ] [ [string] ] = products [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] check_product_names_match_nightly_locations ( locations_context ) [EOL] else : [EOL] check_product_names_match_nightly_locations ( locations_context ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( [string] , [string] , ( False , None ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( False , None ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( False , None ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , ScriptWorkerTaskException ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ( [string] , [string] , ( True , PatternNotMatchedError ) ) , ) ) , ) def test_check_version_matches_nightly_regex ( version , product , raises ) : [EOL] if raises [ [number] ] : [EOL] with pytest . raises ( raises [ [number] ] ) : [EOL] check_version_matches_nightly_regex ( version , product ) [EOL] else : [EOL] check_version_matches_nightly_regex ( version , product ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ( [string] , [string] , True ) , ) ) , ) def test_check_location_path_matches_destination ( product_name , path , raises ) : [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] check_location_path_matches_destination ( product_name , path ) [EOL] else : [EOL] check_location_path_matches_destination ( product_name , path ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , False ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , True ) , ( [string] , [string] , [string] , True ) , ) ) , ) def test_check_versions_are_successive ( current_version , payload_version , product , raises ) : [EOL] if raises : [EOL] with pytest . raises ( ScriptWorkerTaskException ) : [EOL] check_versions_are_successive ( current_version , payload_version , product ) [EOL] else : [EOL] check_versions_are_successive ( current_version , payload_version , product ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] [EOL] import bouncerscript [EOL] [EOL] [EOL] def noop_sync ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] async def noop_async ( * args , ** kwargs ) : [EOL] pass [EOL] [EOL] [EOL] async def return_empty_list_async ( * args , ** kwargs ) : [EOL] return [ ] [EOL] [EOL] [EOL] async def return_true_async ( * args ) : [EOL] return True [EOL] [EOL] [EOL] async def return_false_async ( * args ) : [EOL] return False [EOL] [EOL] [EOL] def raise_sync ( * args , ** kwargs ) : [EOL] raise ScriptWorkerTaskException ( ) [EOL] [EOL] [EOL] def counted ( f ) : [EOL] def wrapped ( * args , ** kwargs ) : [EOL] wrapped . calls += [number] [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] wrapped . calls = [number] [EOL] return wrapped [EOL] [EOL] [EOL] @ counted async def toggled_boolean_async ( * args , ** kwargs ) : [EOL] if toggled_boolean_async . calls & [number] : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] [EOL] def return_true_sync ( * args ) : [EOL] return True [EOL] [EOL] [EOL] def return_false_sync ( * args ) : [EOL] return False [EOL] [EOL] [EOL] def get_fake_valid_config ( ) : [EOL] data_dir = os . path . join ( os . path . dirname ( bouncerscript . __file__ ) , [string] ) [EOL] config = { [string] : { [string] : os . path . join ( data_dir , [string] ) , [string] : os . path . join ( data_dir , [string] ) , [string] : os . path . join ( data_dir , [string] ) , } } [EOL] config . update ( load_json ( path = [string] ) ) [EOL] return config [EOL] [EOL] [EOL] def get_fake_valid_task ( jobtype ) : [EOL] return load_json ( path = [string] . format ( jobtype ) ) [EOL] [EOL] [EOL] def load_json ( path ) : [EOL] with open ( path , [string] ) as fh : [EOL] return json . load ( fh ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import mock [EOL] import typing [EOL] import asyncio [EOL] import bouncerscript [EOL] import asyncio [EOL] import functools [EOL] import json [EOL] [EOL] import aiohttp [EOL] import mock [EOL] import pytest [EOL] from scriptworker . context import Context [EOL] [EOL] from . import get_fake_valid_config , get_fake_valid_task [EOL] [EOL] try : [EOL] import yarl [EOL] [EOL] YARL = True [EOL] except ImportError : [EOL] YARL = False [EOL] [EOL] [EOL] class FakeResponse ( aiohttp . client_reqrep . ClientResponse ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , status = [number] , payload = None , ** kwargs ) : [EOL] self . _connection = mock . MagicMock ( ) [EOL] self . _payload = payload or { } [EOL] self . status = status [EOL] self . _headers = { [string] : [string] } [EOL] self . _cache = { } [EOL] self . _loop = mock . MagicMock ( ) [EOL] self . content = self [EOL] self . resp = [ [string] , [string] ] [EOL] self . _url = args [ [number] ] [EOL] self . _history = ( ) [EOL] if YARL : [EOL] [comment] [EOL] self . _url_obj = yarl . URL ( args [ [number] ] ) [EOL] [EOL] @ asyncio . coroutine def text ( self , * args , ** kwargs ) : [EOL] return json . dumps ( self . _payload ) [EOL] [EOL] @ asyncio . coroutine def json ( self , * args , ** kwargs ) : [EOL] return self . _payload [EOL] [EOL] @ asyncio . coroutine def release ( self ) : [EOL] return [EOL] [EOL] async def read ( self , * args ) : [EOL] if self . resp : [EOL] return self . resp . pop ( [number] ) [EOL] [EOL] [EOL] @ asyncio . coroutine def _fake_request ( resp_status , method , url , * args , ** kwargs ) : [EOL] resp = FakeResponse ( method , url , status = resp_status ) [EOL] resp . _history = ( FakeResponse ( method , url , status = [number] ) , ) [EOL] return resp [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . fixture ( scope = [string] ) async def fake_session ( ) : [EOL] session = aiohttp . ClientSession ( ) [EOL] session . _request = functools . partial ( _fake_request , [number] ) [EOL] yield session [EOL] await session . close ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . fixture ( scope = [string] ) async def fake_session_500 ( ) : [EOL] session = aiohttp . ClientSession ( ) [EOL] session . _request = functools . partial ( _fake_request , [number] ) [EOL] yield session [EOL] await session . close ( ) [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def submission_context ( ) : [EOL] context = Context ( ) [EOL] context . task = get_fake_valid_task ( [string] ) [EOL] context . config = get_fake_valid_config ( ) [EOL] [EOL] yield context [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def aliases_context ( ) : [EOL] context = Context ( ) [EOL] context . task = get_fake_valid_task ( [string] ) [EOL] context . config = get_fake_valid_config ( ) [EOL] context . server = [string] [EOL] [EOL] yield context [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def locations_context ( ) : [EOL] context = Context ( ) [EOL] context . task = get_fake_valid_task ( [string] ) [EOL] context . config = get_fake_valid_config ( ) [EOL] [EOL] yield context [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def fake_ClientError_throwing_session ( ) : [EOL] @ asyncio . coroutine def _fake_request ( method , url , * args , ** kwargs ) : [EOL] raise aiohttp . ClientError [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] session = aiohttp . ClientSession ( loop = loop ) [EOL] session . _request = _fake_request [EOL] return session [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def fake_TimeoutError_throwing_session ( ) : [EOL] @ asyncio . coroutine def _fake_request ( method , url , * args , ** kwargs ) : [EOL] raise aiohttp . ServerTimeoutError [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] session = aiohttp . ClientSession ( loop = loop ) [EOL] session . _request = _fake_request [EOL] return session [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.tuple$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] from typing import Match , Optional , Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import re [EOL] [EOL] from mozilla_version . gecko import FennecVersion , FirefoxVersion [EOL] from scriptworker import client [EOL] from scriptworker . exceptions import ScriptWorkerTaskException , TaskVerificationError [EOL] from scriptworker . utils import retry_request [EOL] [EOL] from bouncerscript . constants import ( ALIASES_REGEXES , BOUNCER_PATH_REGEXES_PER_PRODUCT , GO_BOUNCER_URL_TMPL , PARTNER_ALIASES_REGEX , PRODUCT_TO_DESTINATIONS_REGEXES , PRODUCT_TO_PRODUCT_ENTRY , ) [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] version_map = { [string] : FirefoxVersion , [string] : FennecVersion } [EOL] [EOL] [EOL] def get_task_server ( task , script_config ) : [EOL] [docstring] [EOL] server_scopes = [ s for s in task [ [string] ] if s . startswith ( script_config [ [string] ] + [string] ) ] [EOL] log . info ( [string] , server_scopes ) [EOL] messages = [ ] [EOL] [EOL] if len ( server_scopes ) != [number] : [EOL] messages . append ( [string] ) [EOL] server_scope = server_scopes [ [number] ] [EOL] server = server_scope . split ( [string] ) [ - [number] ] [EOL] if re . search ( [string] , server ) is None : [EOL] messages . append ( [string] . format ( server ) ) [EOL] [EOL] if server_scope not in script_config [ [string] ] : [EOL] messages . append ( [string] ) [EOL] [EOL] if messages : [EOL] raise ScriptWorkerTaskException ( [string] . join ( messages ) ) [EOL] [EOL] return server_scope [EOL] [EOL] [EOL] def get_task_action ( task , script_config ) : [EOL] [docstring] [EOL] actions = [ s . split ( [string] ) [ - [number] ] for s in task [ [string] ] if s . startswith ( script_config [ [string] ] + [string] ) ] [EOL] [EOL] log . info ( [string] , actions ) [EOL] messages = [ ] [EOL] if len ( actions ) != [number] : [EOL] messages . append ( [string] ) [EOL] [EOL] action = actions [ [number] ] [EOL] if action not in get_supported_actions ( script_config ) : [EOL] messages . append ( [string] ) [EOL] [EOL] if messages : [EOL] raise ScriptWorkerTaskException ( [string] . join ( messages ) ) [EOL] [EOL] return action [EOL] [EOL] [EOL] def matches ( name , pattern , fullmatch = False ) : [EOL] if fullmatch : [EOL] return re . fullmatch ( pattern , name ) [EOL] return re . match ( pattern , name ) [EOL] [EOL] [EOL] def matches_partner_regex ( alias , product_name ) : [EOL] for alias_pattern , product_pattern in PARTNER_ALIASES_REGEX . items ( ) : [EOL] alias_match = re . match ( alias_pattern , alias ) [EOL] product_match = re . match ( product_pattern , product_name ) [EOL] if alias_match and product_match and alias_match . groups ( ) [ [number] ] == product_match . groups ( ) [ [number] ] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def get_supported_actions ( script_config ) : [EOL] return tuple ( script_config [ [string] ] . keys ( ) ) [EOL] [EOL] [EOL] def validate_task_schema ( context ) : [EOL] [docstring] [EOL] action = get_task_action ( context . task , context . config ) [EOL] schema_key = [string] . format ( action ) [EOL] client . validate_task_schema ( context , schema_key = schema_key ) [EOL] [EOL] [EOL] def check_product_names_match_aliases ( context ) : [EOL] [docstring] [EOL] aliases = context . task [ [string] ] [ [string] ] [EOL] all_partner_aliases = [string] . join ( PARTNER_ALIASES_REGEX . keys ( ) ) [EOL] [EOL] validations = [ ] [EOL] for alias , product_name in aliases . items ( ) : [EOL] if alias in ALIASES_REGEXES . keys ( ) : [EOL] validations . append ( matches ( product_name , ALIASES_REGEXES [ alias ] ) ) [EOL] elif re . match ( all_partner_aliases , alias ) : [EOL] validations . append ( matches_partner_regex ( alias , product_name ) ) [EOL] else : [EOL] raise TaskVerificationError ( [string] . format ( alias ) ) [EOL] [EOL] if not all ( validations ) : [EOL] raise TaskVerificationError ( [string] . format ( aliases ) ) [EOL] [EOL] [EOL] def check_product_names_match_nightly_locations ( context ) : [EOL] [docstring] [EOL] products = context . task [ [string] ] [ [string] ] [EOL] valid_sets = [ ] [EOL] for product_set in BOUNCER_PATH_REGEXES_PER_PRODUCT : [EOL] valid_sets . append ( sorted ( product_set . keys ( ) ) ) [EOL] if sorted ( products ) not in valid_sets : [EOL] raise TaskVerificationError ( [string] . format ( products ) ) [EOL] [EOL] [EOL] def check_locations_match ( locations , product_config ) : [EOL] [docstring] [EOL] if not sorted ( locations ) == sorted ( product_config . values ( ) ) : [EOL] raise ScriptWorkerTaskException ( [string] ) [EOL] [EOL] [EOL] def check_location_path_matches_destination ( product_name , path ) : [EOL] match = None [EOL] for product_regex in BOUNCER_PATH_REGEXES_PER_PRODUCT : [EOL] if product_name not in product_regex : [EOL] continue [EOL] match = matches ( path , product_regex [ product_name ] , fullmatch = True ) [EOL] if match : [EOL] break [comment] [EOL] if match is None : [EOL] err_msg = [string] [string] . format ( product_name , path ) [EOL] raise ScriptWorkerTaskException ( err_msg ) [EOL] [EOL] [EOL] def check_versions_are_successive ( current_version , payload_version , product ) : [EOL] [docstring] [EOL] [EOL] def _successive_sanity ( current_identifier , candidate_identifier ) : [EOL] if current_identifier == candidate_identifier : [EOL] err_msg = [string] . format ( payload_version , current_version ) [EOL] raise ScriptWorkerTaskException ( err_msg ) [EOL] elif current_identifier > candidate_identifier : [EOL] err_msg = [string] . format ( payload_version , current_version ) [EOL] raise ScriptWorkerTaskException ( err_msg ) [EOL] elif ( candidate_identifier - current_identifier ) > [number] : [EOL] err_msg = [string] . format ( payload_version , current_version ) [EOL] raise ScriptWorkerTaskException ( err_msg ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if product == [string] : [EOL] current_bouncer_version = FirefoxVersion . parse ( current_version ) [EOL] candidate_version = FirefoxVersion . parse ( payload_version ) [EOL] [EOL] _successive_sanity ( current_bouncer_version . major_number , candidate_version . major_number ) [EOL] elif product == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] current_bouncer_version = FennecVersion . parse ( current_version ) [EOL] candidate_version = FennecVersion . parse ( payload_version ) [EOL] [EOL] _successive_sanity ( current_bouncer_version . minor_number , candidate_version . minor_number ) [EOL] else : [EOL] err_msg = [string] . format ( product ) [EOL] raise ScriptWorkerTaskException ( err_msg ) [EOL] [EOL] log . info ( [string] ) [EOL] [EOL] [EOL] def check_path_matches_destination ( product_name , path ) : [EOL] [docstring] [EOL] possible_products = [ p for p , pattern in PRODUCT_TO_PRODUCT_ENTRY if matches ( product_name , pattern ) ] [EOL] product = possible_products [ [number] ] [EOL] regex_for_product = PRODUCT_TO_DESTINATIONS_REGEXES [ product ] [EOL] if matches ( path , regex_for_product , fullmatch = True ) is None : [EOL] raise ScriptWorkerTaskException ( [string] . format ( product_name , path , regex_for_product ) ) [EOL] [EOL] [EOL] async def check_aliases_match ( context ) : [EOL] [docstring] [EOL] aliases = context . task [ [string] ] [ [string] ] [EOL] url_template = GO_BOUNCER_URL_TMPL [ context . server ] [EOL] [EOL] for alias , product_name in aliases . items ( ) : [EOL] log . info ( [string] . format ( alias ) ) [EOL] alias_url = url_template . format ( alias ) [EOL] alias_resp = await retry_request ( context , alias_url , good = ( [number] , [number] ) ) [EOL] if alias_resp == [string] : [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] log . info ( [string] . format ( alias , alias_resp ) ) [EOL] [EOL] log . info ( [string] . format ( product_name ) ) [EOL] product_url = url_template . format ( product_name ) [EOL] product_resp = await retry_request ( context , product_url ) [EOL] log . info ( [string] . format ( product_name , product_resp ) ) [EOL] [EOL] if alias_resp != product_resp : [EOL] raise ScriptWorkerTaskException ( [string] . format ( alias , product_name ) ) [EOL] [EOL] [EOL] def check_version_matches_nightly_regex ( version , product ) : [EOL] version = version_map [ product ] . parse ( version ) [EOL] if not version . is_nightly : [EOL] raise ScriptWorkerTaskException ( [string] . format ( version ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple [EOL] import typing [EOL] ALIASES_REGEXES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] PARTNER_ALIASES_REGEX = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] PRODUCT_TO_DESTINATIONS_REGEXES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : ( [string] [string] ) , } [EOL] [EOL] _BOUNCER_PATH_REGEXES_PER_PRODUCT_DEFAULT = { [string] : ( [string] [string] ) , [string] : ( [string] [string] ) , [string] : ( [string] [string] ) , [string] : ( [string] [string] ) , } [EOL] [EOL] _BOUNCER_PATH_REGEXES_PER_ALTERNATIVE_PACKAGE_FORMAT = { ** _BOUNCER_PATH_REGEXES_PER_PRODUCT_DEFAULT , [string] : ( [string] [string] ) , [string] : ( [string] [string] ) , [string] : ( [string] [string] ) , [string] : ( [string] [string] ) , } [EOL] [EOL] _BOUNCER_PATH_REGEXES_PER_PRODUCT_FENNEC = { [string] : ( [string] ) } [EOL] [EOL] [EOL] BOUNCER_PATH_REGEXES_PER_PRODUCT = [ _BOUNCER_PATH_REGEXES_PER_PRODUCT_DEFAULT , _BOUNCER_PATH_REGEXES_PER_ALTERNATIVE_PACKAGE_FORMAT , _BOUNCER_PATH_REGEXES_PER_PRODUCT_FENNEC , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] PRODUCT_TO_PRODUCT_ENTRY = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] BOUNCER_LOCATION_PLATFORMS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] GO_BOUNCER_URL_TMPL = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] NIGHTLY_VERSION_REGEX = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Tuple , Match , Optional , Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import re [EOL] import xml [EOL] from urllib . parse import quote [EOL] from xml . dom . minidom import parseString [EOL] [EOL] import aiohttp [EOL] from scriptworker . exceptions import ScriptWorkerTaskException [EOL] from scriptworker . utils import retry_async [EOL] [EOL] from bouncerscript . constants import BOUNCER_LOCATION_PLATFORMS , NIGHTLY_VERSION_REGEX [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def api_call ( context , route , data , retry_config = None ) : [EOL] [docstring] [EOL] retry_async_kwargs = dict ( retry_exceptions = ( aiohttp . ClientError , aiohttp . ServerTimeoutError ) ) [EOL] [EOL] if retry_config : [EOL] retry_async_kwargs . update ( retry_config ) [EOL] [EOL] log . info ( [string] . format ( route , data ) ) [EOL] return await retry_async ( _do_api_call , args = ( context , route , data ) , ** retry_async_kwargs ) [EOL] [EOL] [EOL] async def _do_api_call ( context , route , data , method = [string] , session = None ) : [EOL] [docstring] [EOL] session = session or context . session [EOL] bouncer_config = context . config [ [string] ] [ context . server ] [EOL] credentials = ( bouncer_config [ [string] ] , bouncer_config [ [string] ] ) [EOL] api_root = bouncer_config [ [string] ] [EOL] api_url = [string] % ( api_root , route ) [EOL] auth = aiohttp . BasicAuth ( * credentials ) [EOL] [EOL] kwargs = { [string] : [number] } [EOL] if data : [EOL] kwargs [ [string] ] = data [EOL] method = [string] [EOL] [EOL] try : [EOL] log . info ( [string] . format ( method , api_url , kwargs ) ) [EOL] async with session . request ( method , api_url , auth = auth , ** kwargs ) as resp : [EOL] result = await resp . text ( ) [EOL] log . info ( [string] . format ( result ) ) [EOL] return result [EOL] except aiohttp . ServerTimeoutError as e : [EOL] log . warning ( [string] % ( api_url , e ) ) [EOL] raise [EOL] except aiohttp . ClientError as e : [EOL] log . warning ( [string] % ( api_url , e ) ) [EOL] raise [EOL] [EOL] [EOL] async def api_show_product ( context , product_name ) : [EOL] [docstring] [EOL] data = { } [EOL] return await api_call ( context , [string] % quote ( product_name ) , data = data ) [EOL] [EOL] [EOL] async def api_add_product ( context , product_name , add_locales , ssl_only = False ) : [EOL] [docstring] [EOL] data = { [string] : product_name } [EOL] if add_locales : [EOL] data [ [string] ] = context . task [ [string] ] [ [string] ] [EOL] if ssl_only : [EOL] [comment] [EOL] data [ [string] ] = [string] [EOL] [EOL] return await api_call ( context , [string] , data ) [EOL] [EOL] [EOL] async def api_add_location ( context , product_name , bouncer_platform , path ) : [EOL] [docstring] [EOL] data = { [string] : product_name , [string] : bouncer_platform , [string] : path } [EOL] [EOL] return await api_call ( context , [string] , data ) [EOL] [EOL] [EOL] async def api_modify_location ( context , product_name , bouncer_platform , path ) : [EOL] [docstring] [EOL] data = { [string] : product_name , [string] : bouncer_platform , [string] : path } [EOL] [EOL] return await api_call ( context , [string] , data ) [EOL] [EOL] [EOL] async def api_show_location ( context , product_name ) : [EOL] [docstring] [EOL] data = { } [EOL] return await api_call ( context , [string] % quote ( product_name ) , data = data ) [EOL] [EOL] [EOL] async def api_update_alias ( context , alias , product_name ) : [EOL] [docstring] [EOL] data = { [string] : alias , [string] : product_name } [EOL] [EOL] return await api_call ( context , [string] , data ) [EOL] [EOL] [EOL] async def does_product_exist ( context , product_name ) : [EOL] [docstring] [EOL] res = await api_show_product ( context , product_name ) [EOL] [EOL] try : [EOL] xml_doc = parseString ( res ) [EOL] [comment] [EOL] products_found = len ( xml_doc . getElementsByTagName ( [string] ) ) [EOL] log . info ( [string] . format ( products_found ) ) [EOL] return bool ( products_found ) [EOL] except ( xml . parsers . expat . ExpatError , UnicodeDecodeError , ValueError ) as e : [EOL] log . warning ( [string] . format ( e ) ) [EOL] log . warning ( [string] . format ( product_name ) ) [EOL] [comment] [EOL] return False [EOL] [EOL] [EOL] async def does_location_path_exist ( context , product_name , platform , path ) : [EOL] existing_info = await get_locations_info ( context , product_name ) [EOL] for info in existing_info : [EOL] if path == info [ [string] ] and platform == info [ [string] ] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] async def get_locations_info ( context , product_name ) : [EOL] [docstring] [EOL] res = await api_show_location ( context , product_name ) [EOL] [EOL] try : [EOL] xml_doc = parseString ( res ) [EOL] [comment] [EOL] locations_info = process_locations_from_xml ( xml_doc . getElementsByTagName ( [string] ) ) [EOL] log . debug ( [string] . format ( locations_info ) ) [EOL] return locations_info [EOL] except ( xml . parsers . expat . ExpatError , UnicodeDecodeError , ValueError ) as e : [EOL] log . warning ( [string] . format ( e ) ) [EOL] raise ScriptWorkerTaskException ( [string] ) [EOL] [EOL] [EOL] def process_locations_from_xml ( locations_found ) : [EOL] [docstring] [EOL] info = [ ] [EOL] for location in locations_found : [EOL] os = location . getAttribute ( [string] ) [EOL] if os not in BOUNCER_LOCATION_PLATFORMS : [EOL] err_msg = [string] [string] . format ( os , BOUNCER_LOCATION_PLATFORMS ) [EOL] raise ScriptWorkerTaskException ( err_msg ) [EOL] id_ = location . getAttribute ( [string] ) [EOL] path = location . firstChild . data [EOL] info . append ( { [string] : os , [string] : id_ , [string] : path } ) [EOL] [EOL] return info [EOL] [EOL] [EOL] def get_nightly_version ( product_name , path ) : [EOL] [docstring] [EOL] match = re . search ( NIGHTLY_VERSION_REGEX , path ) [EOL] if not match : [EOL] err_msg = [string] . format ( path ) [EOL] raise ScriptWorkerTaskException ( err_msg ) [EOL] [EOL] return match . group ( [number] ) [EOL] [EOL] [EOL] def get_version_bumped_path ( path , current_version , bumped_version ) : [EOL] [docstring] [EOL] return path . replace ( current_version , bumped_version ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0