from typing import Iterable , List , DefaultDict , Any [EOL] import typing [EOL] import builtins [EOL] import flask [EOL] import models [EOL] import muhblog [EOL] from typing import Iterable , DefaultDict , List [EOL] from collections import defaultdict [EOL] [EOL] from flask import Blueprint , Response , abort [EOL] [EOL] from . models import Entry , Tag , EntryTag , AboutPage [EOL] from . utils import Paginator , template_response [EOL] [EOL] [EOL] blueprint = Blueprint ( name = [string] , import_name = __name__ , static_folder = [string] , template_folder = [string] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , defaults = { [string] : [number] } ) @ blueprint . route ( [string] ) def front ( page ) : [EOL] entries = Entry . select ( ) . order_by ( Entry . date . desc ( ) ) [EOL] if not entries . count ( ) : [EOL] abort ( [number] ) [EOL] return template_response ( [string] , title = None , paginator = Paginator ( query = entries , current_page = page ) ) [EOL] [EOL] [EOL] def _archive_response ( entries , title ) : [EOL] groups = defaultdict ( lambda : defaultdict ( lambda : defaultdict ( list ) ) ) [EOL] for entry in entries : [EOL] groups [ entry . date . year ] [ entry . date . month ] [ entry . date . day ] . append ( entry ) [EOL] if not groups : [EOL] abort ( [number] ) [EOL] return template_response ( [string] , title = title , entries = groups ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] ) def archive ( ) : [EOL] entries = Entry . select ( ) . iterator ( ) [EOL] return _archive_response ( entries , title = [string] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] ) def archive_by_year ( year ) : [EOL] entries = ... [EOL] try : [EOL] entries = Entry . select ( ) . where ( Entry . date . year == int ( year ) ) . iterator ( ) [EOL] except ValueError : [EOL] abort ( [number] ) [EOL] return _archive_response ( entries , title = year ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] ) def archive_by_month ( year , month ) : [EOL] entries = ... [EOL] try : [EOL] entries = Entry . select ( ) . where ( Entry . date . year == int ( year ) ) . where ( Entry . date . month == int ( month ) ) . iterator ( ) [EOL] except ValueError : [EOL] abort ( [number] ) [EOL] return _archive_response ( entries , title = f'{ month } [string] { year }' ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] ) def archive_by_day ( year , month , day ) : [EOL] entries = ... [EOL] try : [EOL] entries = Entry . select ( ) . where ( Entry . date . year == int ( year ) ) . where ( Entry . date . month == int ( month ) ) . where ( Entry . date . day == int ( day ) ) . iterator ( ) [EOL] except ValueError : [EOL] abort ( [number] ) [EOL] return _archive_response ( entries , title = f'{ day } [string] { month } [string] { year }' ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] ) def archive_by_tag ( slug ) : [EOL] tag_name = ... [EOL] try : [EOL] tag_name = Tag . get ( slug = slug ) . name [EOL] except Tag . DoesNotExist : [EOL] abort ( [number] ) [EOL] entries = Entry . select ( ) . join ( EntryTag , on = Entry . id == EntryTag . entry_id ) . join ( Tag , on = EntryTag . definition_id == Tag . id ) . where ( Tag . slug == slug ) . iterator ( ) [EOL] return _archive_response ( entries , title = tag_name ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] ) def entry ( year , month , day , slug ) : [EOL] entry = ... [EOL] try : [EOL] entry = Entry . select ( ) . where ( Entry . date . year == int ( year ) ) . where ( Entry . date . month == int ( month ) ) . where ( Entry . date . day == int ( day ) ) . where ( Entry . slug == slug ) . get ( ) [EOL] except ( ValueError , Entry . DoesNotExist ) : [EOL] abort ( [number] ) [EOL] return template_response ( [string] , title = entry . title , entry = entry ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] ) def about ( ) : [EOL] return template_response ( [string] , title = [string] , entry = AboutPage . get ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import muhblog [EOL] import typing [EOL] from peewee import SqliteDatabase , Model [EOL] [EOL] [EOL] database = SqliteDatabase ( database = [string] , uri = True , pragmas = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] [EOL] [EOL] class BaseModel ( Model ) : [EOL] class Meta : [EOL] database = database [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[muhblog.database.BaseModel.Meta]$ 0 $typing.Type[muhblog.database.BaseModel.Meta]$ 0
from typing import Dict , List , Union , Any [EOL] import pathlib [EOL] import typing [EOL] import flask [EOL] from pathlib import Path [EOL] [EOL] from flask import Flask [EOL] from flask_frozen import Freezer [EOL] [EOL] from . import controllers [EOL] from . models import Entry , Tag , EntryTag , AboutPage [EOL] from . database import database [EOL] [EOL] [EOL] DEFAULT_CONFIG = { [string] : [string] , [string] : str ( Path . cwd ( ) . joinpath ( [string] ) ) , [string] : str ( Path . cwd ( ) . joinpath ( [string] ) ) , [string] : str ( Path . cwd ( ) . joinpath ( [string] ) ) , [string] : [ [string] ] } [EOL] CONFIG_FILE_PATH = str ( Path . cwd ( ) . joinpath ( [string] ) ) [EOL] [EOL] [EOL] @ database . atomic ( ) def initialise_database ( app ) : [EOL] entries_directory = Path ( app . config [ [string] ] ) [EOL] if not entries_directory . exists ( ) : [EOL] app . logger . error ( [string] , entries_directory ) [EOL] return [EOL] if not entries_directory . is_dir ( ) : [EOL] app . logger . error ( [string] , entries_directory ) [EOL] return [EOL] [EOL] about_path = Path ( app . config [ [string] ] ) [EOL] if not about_path . exists ( ) : [EOL] app . logger . error ( [string] , about_path ) [EOL] return [EOL] if not about_path . is_file ( ) : [EOL] app . logger . error ( [string] , about_path ) [EOL] return [EOL] [EOL] app . logger . debug ( [string] ) [EOL] database . create_tables ( [ Entry , Tag , EntryTag , AboutPage ] ) [EOL] [EOL] app . logger . info ( [string] ) [EOL] entry_paths = [ path for path in entries_directory . glob ( [string] ) if path . is_file ( ) ] [EOL] for index , path in enumerate ( entry_paths , start = [number] ) : [EOL] app . logger . info ( [string] , index , len ( entry_paths ) , path ) [EOL] text = path . read_text ( encoding = [string] ) [EOL] Entry . create ( text = text ) [EOL] [EOL] app . logger . info ( [string] , about_path ) [EOL] about_text = about_path . read_text ( encoding = [string] ) [EOL] AboutPage . create ( text = about_text ) [EOL] [EOL] [EOL] def create ( ) : [EOL] app = Flask ( [string] ) [EOL] [EOL] app . register_blueprint ( controllers . blueprint ) [EOL] [EOL] app . config . from_mapping ( DEFAULT_CONFIG ) [EOL] app . config . from_json ( CONFIG_FILE_PATH ) [EOL] app . config [ [string] ] = app . config [ [string] ] [EOL] app . config [ [string] ] = app . config [ [string] ] [EOL] app . logger . setLevel ( [string] if app . debug else [string] ) [EOL] [EOL] initialise_database ( app ) [EOL] [EOL] @ app . cli . command ( ) def freeze ( ) : [EOL] freezer = Freezer ( app ) [EOL] app . logger . info ( [string] , app . config [ [string] ] ) [EOL] freezer . freeze ( ) [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterable , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import peewee [EOL] import flask [EOL] import models [EOL] import re [EOL] import math as maths [EOL] from typing import Iterable , Dict [EOL] from base64 import b64encode [EOL] [EOL] from flask import Response , render_template , make_response , current_app [EOL] from peewee import SelectQuery [EOL] from htmlmin . minify import html_minify [EOL] [EOL] from . models import Entry [EOL] [EOL] PAGE_GROUP_SIZE = [number] [EOL] ENTRIES_PER_PAGE = [number] [EOL] [EOL] [EOL] class Paginator : [EOL] query = ... [EOL] current_page = ... [EOL] [EOL] def __init__ ( self , query , current_page ) : [EOL] self . query = query [EOL] self . current_page = current_page [EOL] [EOL] def get_entries ( self ) : [EOL] return self . query . paginate ( self . current_page , ENTRIES_PER_PAGE ) . iterator ( ) [EOL] [EOL] def get_total_pages ( self ) : [EOL] return maths . ceil ( self . query . count ( ) / ENTRIES_PER_PAGE ) [EOL] [EOL] def has_previous_page ( self ) : [EOL] return self . current_page != [number] [EOL] [EOL] def has_next_page ( self ) : [EOL] return self . current_page != self . get_total_pages ( ) [EOL] [EOL] def page_number_group ( self ) : [EOL] padding = PAGE_GROUP_SIZE // [number] [EOL] start_page = self . current_page - padding [EOL] end_page = self . current_page + padding [EOL] [EOL] total_pages = self . get_total_pages ( ) [EOL] [EOL] if start_page < [number] and end_page > total_pages : [EOL] start_page = [number] [EOL] end_page = total_pages [EOL] else : [EOL] if start_page < [number] : [EOL] difference = [number] - start_page [EOL] start_page += difference [EOL] end_page += difference [EOL] if end_page > total_pages : [EOL] difference = end_page - total_pages [EOL] end_page -= difference [EOL] start_page -= difference [EOL] if start_page < [number] : [EOL] start_page = [number] [EOL] [EOL] return range ( start_page , end_page + [number] ) [EOL] [EOL] [EOL] _template_cache = { } [EOL] [EOL] [EOL] def _get_js ( ) : [EOL] if [string] not in _template_cache : [EOL] with current_app . open_resource ( [string] ) as file : [EOL] _template_cache [ [string] ] = file . read ( ) . decode ( [string] ) [EOL] return _template_cache [ [string] ] [EOL] [EOL] [EOL] def _get_css ( ) : [EOL] if [string] not in _template_cache : [EOL] with current_app . open_resource ( [string] ) as file : [EOL] _template_cache [ [string] ] = re . sub ( pattern = [string] , repl = [string] , string = file . read ( ) . decode ( [string] ) , count = [number] , flags = re . DOTALL ) [EOL] return _template_cache [ [string] ] [EOL] [EOL] [EOL] def _get_favicon_url ( ) : [EOL] if [string] not in _template_cache : [EOL] with current_app . open_resource ( [string] ) as file : [EOL] favicon_bytes = file . read ( ) [EOL] encoded = b64encode ( favicon_bytes ) . decode ( [string] ) [EOL] _template_cache [ [string] ] = f' [string] { encoded }' [EOL] return _template_cache [ [string] ] [EOL] [EOL] [EOL] def template_response ( * args , status_code = [number] , ** kwargs ) : [EOL] html = render_template ( * args , ** kwargs , js = _get_js ( ) , css = _get_css ( ) , favicon_url = _get_favicon_url ( ) ) [EOL] html = html_minify ( html ) [EOL] return make_response ( html , status_code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $peewee.SelectQuery$ 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Iterable[models.Entry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import flask [EOL] import builtins [EOL] import re [EOL] [EOL] from flask import Markup [EOL] from mistune import Markdown , Renderer , escape , escape_link [EOL] from pygments import highlight [EOL] from pygments . lexers import get_lexer_by_name [EOL] from pygments . formatters . html import HtmlFormatter [EOL] [EOL] [EOL] class SpoilerRenderer ( Renderer ) : [EOL] def image ( self , src , title , text ) : [EOL] src = escape_link ( src ) [EOL] html = f' [string] { src } [string] ' [EOL] if title : [EOL] title = escape ( title , quote = True ) [EOL] html = f'{ html } [string] { title } [string] ' [EOL] if text : [EOL] text = escape ( text , quote = True ) [EOL] html = f'{ html } [string] { text } [string] ' [EOL] return f'{ html } [string] ' [EOL] [EOL] def paragraph ( self , text ) : [EOL] replaced = re . sub ( pattern = [string] , repl = [string] , string = text , flags = re . DOTALL ) [EOL] return super ( ) . paragraph ( replaced ) [EOL] [EOL] def block_code ( self , code , lang ) : [EOL] if not lang : [EOL] return f' [string] { escape ( code ) } [string] ' [EOL] return highlight ( code = code , lexer = get_lexer_by_name ( lang , stripall = True ) , formatter = HtmlFormatter ( noclasses = True , style = [string] ) ) [EOL] [EOL] [EOL] def render ( text ) : [EOL] parser = Markdown ( renderer = SpoilerRenderer ( ) ) [EOL] html = parser ( text ) [EOL] return Markup ( html ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Markup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Type , Match [EOL] import muhblog [EOL] import typing [EOL] import flask [EOL] import builtins [EOL] import re [EOL] from datetime import datetime [EOL] from typing import Optional [EOL] [EOL] from flask import Markup [EOL] from slugify import slugify [EOL] from peewee import TextField , DateTimeField , ForeignKeyField , CharField [EOL] from markdown_metadata import parse_metadata [EOL] [EOL] from . import markdown [EOL] from . database import BaseModel [EOL] [EOL] SLUG_LENGTH = [number] [EOL] STUB_LENGTH = [number] [EOL] DATE_FORMAT = [string] [EOL] [EOL] [EOL] class MarkdownModel ( BaseModel ) : [EOL] text = TextField ( ) [EOL] [EOL] def render_markdown ( self ) : [EOL] return markdown . render ( self . text ) [EOL] [EOL] [EOL] class Entry ( MarkdownModel ) : [EOL] slug = CharField ( unique = True , max_length = SLUG_LENGTH ) [EOL] title = CharField ( ) [EOL] date = DateTimeField ( ) [EOL] [EOL] @ classmethod def create ( cls , text ) : [EOL] metadata , text = parse_metadata ( text ) [EOL] [EOL] instance = cls ( slug = slugify ( metadata [ [string] ] [ [number] ] , max_length = SLUG_LENGTH ) , title = metadata [ [string] ] [ [number] ] , date = datetime . strptime ( metadata [ [string] ] [ [number] ] , DATE_FORMAT ) , text = text ) [EOL] instance . save ( ) [EOL] for tag in metadata [ [string] ] : [EOL] EntryTag . create ( entry = instance , name = tag ) [EOL] [EOL] return instance [EOL] [EOL] def render_stub ( self ) : [EOL] match = re . search ( rf' [string] { STUB_LENGTH } [string] ' , self . text ) [EOL] if match is None : [EOL] return [string] [EOL] return markdown . render ( match . group ( [number] ) ) [EOL] [EOL] def next_entry ( self ) : [EOL] try : [EOL] return self . __class__ . get_by_id ( self . id + [number] ) [EOL] except self . __class__ . DoesNotExist : [EOL] return None [EOL] [EOL] def previous_entry ( self ) : [EOL] try : [EOL] return self . __class__ . get_by_id ( self . id - [number] ) [EOL] except self . __class__ . DoesNotExist : [EOL] return None [EOL] [EOL] [EOL] class AboutPage ( MarkdownModel ) : [EOL] pass [EOL] [EOL] [EOL] class Tag ( BaseModel ) : [EOL] slug = CharField ( unique = True , max_length = SLUG_LENGTH ) [EOL] name = TextField ( ) [EOL] [EOL] @ classmethod def create ( cls , name ) : [EOL] return super ( ) . create ( name = name , slug = slugify ( name , max_length = SLUG_LENGTH ) ) [EOL] [EOL] [EOL] class EntryTag ( BaseModel ) : [EOL] definition = ForeignKeyField ( Tag , backref = [string] ) [EOL] entry = ForeignKeyField ( Entry , backref = [string] ) [EOL] [EOL] @ classmethod def create ( cls , entry , name ) : [EOL] return super ( ) . create ( entry = entry , definition = Tag . get_or_create ( name = name ) [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Markup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[muhblog.models.Entry]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[muhblog.models.Entry]$ 0 0 0 0 0 $typing.Type[muhblog.models.Entry]$ 0 0 0 0 0 0 0 0 0 $'Entry'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $muhblog.models.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $muhblog.models.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $muhblog.models.Entry$ 0 0 0 0 0 0 0 0 $muhblog.models.Entry$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional['Entry']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['Entry']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[muhblog.models.Tag]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[muhblog.models.Tag]$ 0 0 0 0 0 0 0 0 0 $'Tag'$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[muhblog.models.EntryTag]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[muhblog.models.EntryTag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'EntryTag'$ 0 0 0 $Entry$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $Entry$ 0 $Entry$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0