import builtins [EOL] class Base ( ) : [EOL] def __init__ ( self , x , y ) : [EOL] self . x = x [EOL] self . y = y [EOL] [EOL] [EOL] class Point ( Base ) : [EOL] def __init__ ( self , x , y ) : [EOL] super ( ) . __init__ ( x , y ) [EOL] [EOL] [EOL] def add ( a , b ) : [EOL] return a . x + a . y + b . x + b . y [EOL]	0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from math2 import add , Point [EOL] [EOL] [EOL] def test_add ( ) : [EOL] a = Point ( [number] , [number] ) [EOL] b = Point ( [number] , [number] ) [EOL] assert add ( a , b ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] import requests [EOL] import requests [EOL] import datetime [EOL] [EOL] PERSONAL_ACCESS_TOKEN = [string] [EOL] [EOL] url = [string] [EOL] token = [string] . format ( PERSONAL_ACCESS_TOKEN ) [EOL] r = requests . get ( url , headers = { [string] : token } ) [EOL] body = r . json ( ) [EOL] limit = body [ [string] ] [ [string] ] [ [string] ] [EOL] remaining = body [ [string] ] [ [string] ] [ [string] ] [EOL] reset_unixtime = body [ [string] ] [ [string] ] [ [string] ] [EOL] reset = datetime . datetime . fromtimestamp ( reset_unixtime ) [EOL] [EOL] print ( [string] . format ( remaining , reset ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $datetime.datetime$ 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from concurrent import futures [EOL] import time [EOL] [EOL] import grpc [EOL] [EOL] import route_guide_pb2 [EOL] import route_guide_pb2_grpc [EOL] [EOL] class RouteGuideServicer ( route_guide_pb2_grpc . RouteGuideServicer ) : [EOL] def GetFeature ( self , request , context ) : [EOL] return route_guide_pb2 . Feature ( name = [string] , location = request ) [EOL] [EOL] def server ( ) : [EOL] server = grpc . server ( futures . ThreadPoolExecutor ( max_workers = [number] ) ) [EOL] route_guide_pb2_grpc . add_RouteGuideServicer_to_server ( RouteGuideServicer ( ) , server ) [EOL] server . add_insecure_port ( [string] ) [EOL] server . start ( ) [EOL] try : [EOL] while True : [EOL] time . sleep ( [number] * [number] * [number] ) [EOL] except KeyboardInterrupt : [EOL] server . stop ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] server ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Tuple , Dict , List [EOL] import typing [EOL] import json [EOL] import re [EOL] from functools import reduce [EOL] [EOL] import click [EOL] [EOL] [EOL] def unique ( list_ ) : [EOL] return list ( sorted ( list ( set ( list_ ) ) ) ) [EOL] [EOL] [EOL] def merge_str ( a , b ) : [EOL] merged = merge ( json . loads ( a ) , json . loads ( b ) ) [EOL] return json . dumps ( merged ) [EOL] [EOL] [EOL] def merge ( a , b ) : [EOL] if type ( a ) == type ( b ) : [EOL] if isinstance ( a , dict ) : [EOL] keys = unique ( list ( a . keys ( ) ) + list ( b . keys ( ) ) ) [EOL] return { key : merge ( a . get ( key ) , b . get ( key ) ) for key in keys } [EOL] if isinstance ( a , list ) : [EOL] return a + b [EOL] return a [EOL] else : [EOL] for type_ in [ dict , list ] : [EOL] if isinstance ( a , type_ ) : [EOL] return a [EOL] if isinstance ( b , type_ ) : [EOL] return b [EOL] if a is None : [EOL] return b [EOL] if b is None : [EOL] return a [EOL] assert False [EOL] [EOL] [EOL] def get_schema ( key , value , mode = [string] ) : [EOL] if isinstance ( value , dict ) : [EOL] if not value : [EOL] value = { [string] : [string] } [EOL] fields = [ get_schema ( k , v ) for k , v in value . items ( ) ] [EOL] return { [string] : mode , [string] : key , [string] : [string] , [string] : fields } [EOL] elif isinstance ( value , list ) : [EOL] if value : [EOL] type_ = type ( value [ [number] ] ) [EOL] assert all ( [ isinstance ( x , type_ ) for x in value ] ) [EOL] return get_schema ( key , value [ [number] ] , [string] ) [EOL] else : [EOL] return get_schema ( key , None , [string] ) [EOL] else : [EOL] return { [string] : mode , [string] : key , [string] : get_type ( value ) } [EOL] [EOL] [EOL] def get_type ( value ) : [EOL] if isinstance ( value , str ) : [EOL] patterns = [ ( [string] , [string] ) , ] [EOL] for ( pattern , type_ ) in patterns : [EOL] if re . match ( pattern , value ) : [EOL] return type_ [EOL] return [string] [EOL] elif isinstance ( value , bool ) : [EOL] return [string] [EOL] elif isinstance ( value , int ) : [EOL] return [string] [EOL] elif isinstance ( value , float ) : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] def get_template ( schema ) : [EOL] template = { } [EOL] for elem in schema : [EOL] if elem [ [string] ] == [string] : [EOL] value = get_template ( elem [ [string] ] ) [EOL] else : [EOL] value = None [EOL] if elem [ [string] ] == [string] : [EOL] value = [ value ] if value else [ ] [EOL] template [ elem [ [string] ] ] = value [EOL] return template [EOL] [EOL] [EOL] def trim ( schema , data ) : [EOL] template = get_template ( schema ) [EOL] return merge ( template , data ) [EOL] [EOL] [EOL] def print_json ( data ) : [EOL] print ( json . dumps ( data , indent = [number] ) ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . argument ( [string] ) @ click . argument ( [string] ) @ click . argument ( [string] ) def main ( in_data_file , out_schema_file , out_data_file ) : [EOL] with open ( in_data_file ) as f : [EOL] merged = json . loads ( reduce ( merge_str , f ) ) [EOL] schema = get_schema ( [string] , merged ) [ [string] ] [EOL] with open ( out_schema_file , [string] ) as f : [EOL] f . write ( json . dumps ( schema , indent = [number] ) ) [EOL] with open ( in_data_file ) as fin , open ( out_data_file , [string] ) as fout : [EOL] for row in fin : [EOL] trimmed = trim ( schema , json . loads ( row ) ) [EOL] fout . write ( json . dumps ( trimmed ) ) [EOL] fout . write ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import json [EOL] [EOL] import boto3 [EOL] [EOL] [EOL] def issue_updated ( event , context ) : [EOL] body = json . loads ( event [ [string] ] ) [EOL] client = boto3 . client ( [string] ) [EOL] queue_url = os . environ [ [string] ] [EOL] issue_key = body [ [string] ] [ [string] ] [EOL] message_body = issue_key [EOL] client . send_message ( QueueUrl = queue_url , MessageBody = message_body ) [EOL] return { [string] : [number] , [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import json [EOL] import datetime [EOL] [EOL] import boto3 [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def raise_exception ( event , context ) : [EOL] [number] / [number] [EOL] [EOL] [EOL] def catch_alarm ( event , context ) : [EOL] print ( [string] . format ( event [ [string] ] [ [number] ] [ [string] ] [ [string] ] ) ) [EOL] print ( [string] . format ( event [ [string] ] [ [number] ] [ [string] ] [ [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import json [EOL] [EOL] import boto3 [EOL] [EOL] [EOL] def get_services ( ) : [EOL] time_period_start = [string] [EOL] time_period_end = [string] [EOL] [EOL] client = boto3 . client ( [string] , region_name = [string] ) [EOL] [EOL] r = client . get_cost_and_usage ( TimePeriod = { [string] : time_period_start , [string] : time_period_end } , Granularity = [string] , Metrics = [ [string] ] , GroupBy = [ { [string] : [string] , [string] : [string] } ] ) [EOL] results_by_time = r [ [string] ] [EOL] [EOL] services = [ ] [EOL] for data_monthly in results_by_time : [EOL] services += [ item [ [string] ] [ [number] ] for item in data_monthly [ [string] ] ] [EOL] services = list ( sorted ( list ( set ( services ) ) ) ) [EOL] [EOL] return services [EOL] [EOL] [EOL] def get_cost ( year , month , services , tags = [ ] ) : [EOL] def get_period ( year , month ) : [EOL] if month <= [number] : [EOL] return get_period ( year - [number] , month + [number] ) [EOL] elif month >= [number] : [EOL] return get_period ( year + [number] , month - [number] ) [EOL] else : [EOL] return [string] . format ( year , month ) [EOL] [EOL] def get_services_filter ( service ) : [EOL] return { [string] : { [string] : [string] , [string] : services } } [EOL] [EOL] def get_tag_filter ( tag ) : [EOL] return { [string] : { [string] : tag [ [number] ] , [string] : tag [ [number] ] } } [EOL] [EOL] def get_tags_filter ( tags ) : [EOL] if len ( tags ) == [number] : [EOL] return get_tag_filter ( tags [ [number] ] ) [EOL] else : [EOL] return { [string] : [ get_tag_filter ( tag ) for tag in tags ] } [EOL] [EOL] def get_filter ( services , tags ) : [EOL] if tags : [EOL] return { [string] : [ get_services_filter ( services ) , get_tags_filter ( tags ) ] } [EOL] else : [EOL] return get_services_filter ( services ) [EOL] [EOL] time_period_start = get_period ( year , month ) [EOL] time_period_end = get_period ( year , month + [number] ) [EOL] _filter = get_filter ( services , tags ) [EOL] [EOL] client = boto3 . client ( [string] , region_name = [string] ) [EOL] [EOL] r = client . get_cost_and_usage ( TimePeriod = { [string] : time_period_start , [string] : time_period_end } , Granularity = [string] , Metrics = [ [string] ] , Filter = _filter , GroupBy = [ { [string] : [string] , [string] : [string] } ] ) [EOL] results_by_time = r [ [string] ] [EOL] groups = results_by_time [ [number] ] [ [string] ] [EOL] [EOL] costs = { service : [number] for service in services } [EOL] for x in groups : [EOL] service = x [ [string] ] [ [number] ] [EOL] cost = float ( x [ [string] ] [ [string] ] [ [string] ] ) [EOL] costs [ service ] = cost [EOL] [EOL] return costs [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] services = get_services ( ) [EOL] print ( [string] ) [EOL] print ( json . dumps ( services , indent = [number] ) ) [EOL] [EOL] print ( [string] ) [EOL] costs = get_cost ( [number] , [number] , services ) [EOL] print ( json . dumps ( costs , indent = [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import datetime [EOL] import requests [EOL] import requests [EOL] import json [EOL] import subprocess [EOL] import datetime [EOL] import time [EOL] [EOL] import boto3 [EOL] [EOL] CLOUDFRONT_KEY_PATH = [string] [EOL] CLOUDFRONT_KEY_PAIR_ID = [string] [EOL] CLOUDFRONT_URL = [string] [EOL] [EOL] [EOL] def get_cloudfront_policy ( url , expires ) : [EOL] policy = { [string] : [ { [string] : url , [string] : { [string] : { [string] : expires } } , } ] } [EOL] return json . dumps ( policy ) . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def get_cloudfront_policy_base64 ( url , expires ) : [EOL] policy = get_cloudfront_policy ( url , expires ) [EOL] cmd = ( [string] [string] ) . format ( policy ) [EOL] output = subprocess . check_output ( cmd , shell = True ) [EOL] return [string] . join ( output . split ( [string] ) ) [EOL] [EOL] [EOL] def get_cloudfront_signature ( url , expires , key_path = CLOUDFRONT_KEY_PATH ) : [EOL] policy = get_cloudfront_policy ( url , expires ) [EOL] cmd = ( [string] [string] ) . format ( policy , key_path ) [EOL] output = subprocess . check_output ( cmd , shell = True ) [EOL] return [string] . join ( output . split ( [string] ) ) [EOL] [EOL] [EOL] def get_cloudfront_signed_cookie ( url , expires ) : [EOL] cloudfront_policy = get_cloudfront_policy_base64 ( url , expires ) [EOL] cloudfront_signature = get_cloudfront_signature ( url , expires ) [EOL] [EOL] return ( [string] [string] [string] ) . format ( cloudfront_signature , cloudfront_policy , CLOUDFRONT_KEY_PAIR_ID ) [EOL] [EOL] [EOL] def setup ( ) : [EOL] s3 = boto3 . client ( [string] ) [EOL] s3 . upload_file ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] def test_flag_cannot_be_gotten_without_signed_cookie ( ) : [EOL] url = [string] . format ( CLOUDFRONT_URL ) [EOL] r = requests . get ( url ) [EOL] assert r . status_code == [number] [EOL] [EOL] [EOL] def test_flag_can_be_gotten_with_signed_cookie ( ) : [EOL] url = [string] . format ( CLOUDFRONT_URL ) [EOL] now = datetime . datetime . now ( ) [EOL] expires = now + datetime . timedelta ( days = [number] ) [EOL] expires_unixtime = int ( time . mktime ( expires . timetuple ( ) ) ) [EOL] cookie = get_cloudfront_signed_cookie ( url , expires_unixtime ) [EOL] headers = { [string] : cookie } [EOL] r = requests . get ( url , headers = headers ) [EOL] assert r . status_code == [number] [EOL] assert r . text . strip ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import boto3 [EOL] [EOL] key_id = [string] [EOL] [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] plaintext = [string] [EOL] encrypted_data = client . encrypt ( KeyId = key_id , Plaintext = plaintext ) [EOL] [EOL] ciphertext = encrypted_data [ [string] ] [EOL] decrepted_data = client . decrypt ( CiphertextBlob = ciphertext ) [EOL] decrepted_plaintext = decrepted_data [ [string] ] [EOL] [EOL] print ( [string] . format ( plaintext ) ) [EOL] print ( [string] . format ( decrepted_plaintext ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import boto3 [EOL] [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] image_id = [string] [EOL] instance_type = [string] [EOL] keypair_name = [string] [EOL] secgroup_id = [string] [EOL] stop_after = [number] [EOL] userdata = [string] . format ( stop_after ) [EOL] [EOL] resp = client . run_instances ( ImageId = image_id , MinCount = [number] , MaxCount = [number] , InstanceType = instance_type , KeyName = keypair_name , UserData = userdata , InstanceInitiatedShutdownBehavior = [string] , SecurityGroupIds = [ secgroup_id ] ) [EOL] [EOL] instance_id = resp [ [string] ] [ [number] ] [ [string] ] [EOL] print ( [string] . format ( instance_id ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import boto3 [EOL] [EOL] if __name__ == [string] : [EOL] url = ( [string] ) [EOL] sqs = boto3 . resource ( [string] ) [EOL] queue = sqs . Queue ( url ) [EOL] queue . load ( ) [EOL] for key in queue . attributes : [EOL] print ( key , queue . attributes [ key ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import boto3 [EOL] [EOL] MAX_COUNT = [number] [EOL] [EOL] [EOL] def publish_to_sqs ( ) : [EOL] sqs = boto3 . resource ( [string] ) [EOL] queue = sqs . get_queue_by_name ( QueueName = [string] ) [EOL] for i in range ( MAX_COUNT ) : [EOL] queue . send_message ( MessageBody = str ( i ) ) [EOL] _lambda = boto3 . client ( [string] ) [EOL] _lambda . invoke ( FunctionName = [string] , InvocationType = [string] ) [EOL] [EOL] [EOL] def publish_to_sns ( ) : [EOL] sns = boto3 . client ( [string] ) [EOL] for i in range ( MAX_COUNT ) : [EOL] sns . publish ( TopicArn = [string] , Message = str ( i ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] publish_to_sns ( ) [EOL] publish_to_sqs ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import json [EOL] [EOL] import boto3 [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def subscribe_sqs ( event , context ) : [EOL] sqs = boto3 . resource ( [string] ) [EOL] queue = sqs . get_queue_by_name ( QueueName = [string] ) [EOL] print ( [string] ) [EOL] for message in queue . receive_messages ( ) : [EOL] print ( message . body ) [EOL] message . delete ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def subscribe_sns ( event , context ) : [EOL] message = json . loads ( event [ [string] ] [ [number] ] [ [string] ] [ [string] ] ) [EOL] message = json . dumps ( message , indent = [number] ) [EOL] print ( message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import subprocess [EOL] from __future__ import print_function [EOL] [EOL] import os [EOL] import subprocess [EOL] import shutil [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def run ( event , context ) : [EOL] root = os . path . abspath ( os . path . join ( __file__ , [string] ) ) [EOL] [EOL] os . environ [ [string] ] = [string] [EOL] os . environ [ [string] ] = os . path . join ( root , [string] ) [EOL] os . environ [ [string] ] = os . path . join ( root , [string] ) [EOL] [EOL] shutil . copy ( os . path . join ( root , [string] ) , [string] ) [EOL] shutil . copy ( os . path . join ( root , [string] ) , [string] ) [EOL] [EOL] path_to_git = os . path . join ( root , [string] ) [EOL] url = [string] [EOL] path = [string] [EOL] [EOL] cmd = [string] . format ( path_to_git , url , path ) [EOL] [EOL] p = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] p . wait ( ) [EOL] print ( [string] , p . stdout . readlines ( ) ) [EOL] print ( [string] , p . stderr . readlines ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run ( None , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import json [EOL] [EOL] [EOL] def decorator1 ( value ) : [EOL] def receive_func ( func ) : [EOL] def wrapper ( * args , ** kwargs ) : [EOL] print ( [string] . format ( value ) ) [EOL] ( event , context ) = args [EOL] if event is None : [EOL] event = { } [EOL] event . update ( { [string] : value } ) [EOL] return func ( event , context ) [EOL] return wrapper [EOL] return receive_func [EOL] [EOL] [EOL] def decorator2 ( value ) : [EOL] def receive_func ( func ) : [EOL] def wrapper ( * args , ** kwargs ) : [EOL] print ( [string] . format ( value ) ) [EOL] return func ( * args , ** kwargs ) [EOL] return wrapper [EOL] return receive_func [EOL] [EOL] [EOL] @ decorator1 ( [string] ) @ decorator2 ( [string] ) def run ( event , context ) : [EOL] print ( [string] . format ( json . dumps ( event ) ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run ( None , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import json [EOL] import subprocess [EOL] [EOL] import boto3 [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def run ( event , context ) : [EOL] output = subprocess . check_output ( [string] , shell = True ) [EOL] print ( output ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import argparse [EOL] import typing [EOL] import argparse [EOL] import base64 [EOL] [EOL] import boto3 [EOL] [EOL] key_id = [string] [EOL] [EOL] [EOL] def encrypt ( plaintext ) : [EOL] client = boto3 . client ( [string] ) [EOL] encrypted_data = client . encrypt ( KeyId = key_id , Plaintext = plaintext ) [EOL] ciphertext = encrypted_data [ [string] ] [EOL] ciphertext = base64 . b64encode ( ciphertext ) [EOL] return ciphertext [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] ciphertext = encrypt ( args . plaintext ) [EOL] print ( ciphertext ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import boto3 [EOL] import os [EOL] import base64 [EOL] [EOL] [EOL] def run ( event , context ) : [EOL] client = boto3 . client ( [string] ) [EOL] ciphertext = os . environ [ [string] ] [EOL] ciphertext = base64 . b64decode ( ciphertext ) [EOL] plaintext = client . decrypt ( CiphertextBlob = ciphertext ) [ [string] ] [EOL] print ( [string] . format ( plaintext ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import datetime [EOL] from __future__ import print_function [EOL] [EOL] import json [EOL] import datetime [EOL] [EOL] import boto3 [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def receive ( event , context ) : [EOL] now = datetime . datetime . now ( ) [EOL] tmpfile = [string] [EOL] with open ( tmpfile , [string] ) as fout : [EOL] fout . write ( json . dumps ( event , indent = [number] ) ) [EOL] s3 = boto3 . client ( [string] ) [EOL] key = now . strftime ( [string] ) [EOL] s3 . upload_file ( tmpfile , [string] , key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import json [EOL] [EOL] import dulwich [EOL] from dulwich import server [EOL] from dulwich import porcelain [EOL] from dulwich . repo import Repo [EOL] [EOL] import git [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def run ( event , context ) : [EOL] dulwich . client . get_ssh_vendor = git . KeyParamikoSSHVendor [EOL] repo = porcelain . clone ( [string] , [string] ) [EOL] server . update_server_info ( repo ) [EOL] with open ( [string] ) as r : [EOL] print ( r . read ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import paramiko [EOL] from __future__ import print_function [EOL] import os [EOL] import sys [EOL] import subprocess [EOL] import boto3 [EOL] [EOL] from botocore . client import Config [EOL] [EOL] from dulwich . errors import ( SendPackError , UpdateRefsError , ) [EOL] from dulwich . objectspec import ( parse_object , parse_reftuples , ) [EOL] from contextlib import closing [EOL] from dulwich import porcelain [EOL] from dulwich . contrib . paramiko_vendor import ParamikoSSHVendor [EOL] [EOL] import dulwich [EOL] import dulwich . repo [EOL] import paramiko [EOL] import paramiko . client [EOL] [EOL] [EOL] s3 = boto3 . client ( [string] , config = Config ( signature_version = [string] ) ) [EOL] [EOL] [EOL] class KeyParamikoSSHVendor ( object ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . ssh_kwargs = { [string] : [string] } [EOL] [EOL] def run_command ( self , host , command , username = None , port = None , progress_stderr = None ) : [EOL] if not isinstance ( command , bytes ) : [EOL] raise TypeError ( command ) [EOL] if port is None : [EOL] port = [number] [EOL] [EOL] client = paramiko . SSHClient ( ) [EOL] [EOL] policy = paramiko . client . MissingHostKeyPolicy ( ) [EOL] client . set_missing_host_key_policy ( policy ) [EOL] client . set_missing_host_key_policy ( paramiko . AutoAddPolicy ( ) ) [EOL] client . connect ( host , username = username , port = port , ** self . ssh_kwargs ) [EOL] [EOL] [comment] [EOL] channel = client . get_transport ( ) . open_session ( ) [EOL] [EOL] [comment] [EOL] channel . exec_command ( command ) [EOL] [EOL] from dulwich . contrib . paramiko_vendor import ( _ParamikoWrapper as ParamikoWrapper ) [EOL] return ParamikoWrapper ( client , channel , progress_stderr = progress_stderr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 $paramiko.client.MissingHostKeyPolicy$ 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 $paramiko.client.MissingHostKeyPolicy$ 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $paramiko.client.SSHClient$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $paramiko.client.SSHClient$ 0 $typing.Any$ 0 0 0 0 0 0
import os [EOL] import sys [EOL] from samplemodule . sample import greet [EOL] [EOL] [EOL] def find_all_files ( directory ) : [EOL] for root , dirs , files in os . walk ( directory ) : [EOL] yield root [EOL] for file in files : [EOL] yield os . path . join ( root , file ) [EOL] [EOL] [EOL] def lambda_handler ( event , context ) : [EOL] greet ( ) [EOL] print ( sys . path ) [EOL] for file_ in find_all_files ( [string] ) : [EOL] print ( file_ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def greet ( ) : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] import datetime [EOL] from __future__ import print_function [EOL] [EOL] import json [EOL] import datetime [EOL] [EOL] import boto3 [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def run ( event , context ) : [EOL] now = datetime . datetime . now ( ) [EOL] now_str = now . strftime ( [string] ) [EOL] print ( now_str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import json [EOL] import time [EOL] [EOL] import boto3 [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def send ( event , context ) : [EOL] sqs = boto3 . resource ( [string] ) [EOL] queue = sqs . get_queue_by_name ( QueueName = [string] ) [EOL] for i in range ( [number] ) : [EOL] queue . send_message ( MessageBody = str ( i ) ) [EOL] _lambda = boto3 . client ( [string] ) [EOL] _lambda . invoke ( FunctionName = [string] , InvocationType = [string] ) [EOL] [EOL] [EOL] def receive ( event , context ) : [EOL] sqs = boto3 . resource ( [string] ) [EOL] queue = sqs . get_queue_by_name ( QueueName = [string] ) [EOL] print ( [string] ) [EOL] for message in queue . receive_messages ( ) : [EOL] print ( message . body ) [EOL] time . sleep ( [number] ) [EOL] message . delete ( ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0