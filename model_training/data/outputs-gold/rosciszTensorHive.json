from setuptools import setup , find_packages [EOL] import tensorhive [EOL] [EOL] [EOL] [comment] [EOL] setup ( name = [string] , version = tensorhive . __version__ , license = [string] , packages = find_packages ( ) , include_package_data = True , entry_points = { [string] : [ [string] ] , } , description = [string] , author = [string] , author_email = [string] , url = [string] , download_url = [string] . format ( tensorhive . __version__ ) , keywords = [string] , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , zip_safe = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] from fixtures . models import new_reservation , new_reservation_2 , new_user , new_admin [EOL] from fixtures . database import tables [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] [EOL] @ pytest . yield_fixture ( scope = [string] ) def tables ( ) : [EOL] from tensorhive . database import Base , engine [EOL] from tensorhive . models . User import User [EOL] from tensorhive . models . Reservation import Reservation [EOL] from tensorhive . models . Role import Role [EOL] from tensorhive . models . RevokedToken import RevokedToken [EOL] Base . metadata . create_all ( engine ) [EOL] yield [EOL] Base . metadata . drop_all ( engine ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] import pytest [EOL] from tensorhive . models . Reservation import Reservation [EOL] from tensorhive . models . User import User [EOL] from tensorhive . models . Role import Role [EOL] from datetime import datetime , timedelta [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def new_user ( ) : [EOL] return User ( username = [string] , password = [string] , roles = [ Role ( name = [string] ) ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def new_admin ( ) : [EOL] return User ( username = [string] , password = [string] , roles = [ Role ( name = [string] ) , Role ( name = [string] ) ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def new_reservation ( new_user ) : [EOL] now = datetime . utcnow ( ) [EOL] duration = timedelta ( minutes = [number] ) [EOL] [EOL] return Reservation ( user_id = [number] , title = [string] , description = [string] , protected_resource_id = [string] , starts_at = now , ends_at = now + duration , ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def new_reservation_2 ( new_user ) : [EOL] now = datetime . utcnow ( ) [EOL] duration = timedelta ( minutes = [number] ) [EOL] [EOL] return Reservation ( user_id = [number] , title = [string] , description = [string] , protected_resource_id = [string] , starts_at = now , ends_at = now + duration , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import smtplib [EOL] import tensorhive [EOL] from tensorhive . core . violation_handlers . EmailSendingBehaviour import EmailSendingBehaviour [EOL] from tensorhive . models . User import User [EOL] from tensorhive . config import MAILBOT [EOL] from tensorhive . core . utils . mailer import MessageBodyTemplater , Message , Mailer [EOL] from datetime import datetime [EOL] from unittest . mock import patch [EOL] from typing import Any [EOL] import pytest [EOL] import email [EOL] [EOL] [EOL] @ pytest . yield_fixture ( ) def violation_data ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] * [number] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def test_mailer_when_try_to_send_before_connect ( ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] Mailer ( [string] , [number] ) . send ( [string] ) [EOL] [EOL] [EOL] def test_mailer_sending_with_invalid_message ( ) : [EOL] with patch ( [string] ) : [EOL] mailer = Mailer ( [string] , [number] ) [EOL] mailer . connect ( login = Any , password = Any ) [EOL] with pytest . raises ( AssertionError ) : [EOL] message = Message ( None , None , None , None ) [EOL] mailer . send ( message ) [EOL] [EOL] [EOL] def test_message_properly_processes_init_arguments ( ) : [EOL] [comment] [EOL] message = Message ( author = [string] , to = [string] , subject = [string] , body = [string] ) [EOL] assert message . author == [string] [EOL] assert message . recipients == [string] [EOL] assert message . subject == [string] [EOL] assert isinstance ( message . msg , email . mime . multipart . MIMEMultipart ) [EOL] assert isinstance ( message . body , str ) [EOL] [EOL] [comment] [EOL] message = Message ( author = [string] , to = [ [string] , [string] , [string] ] , subject = [string] , body = [string] ) [EOL] assert message . recipients == [string] [EOL] [EOL] [EOL] def test_sendmail_is_reached_with_mock_smtp_server ( ) : [EOL] with patch ( [string] ) as mock_smtp : [EOL] mailer = Mailer ( [string] , [number] ) [EOL] message = Message ( author = [string] , to = [string] , subject = [string] , body = [string] ) [EOL] [EOL] mailer . server = mock_smtp . return_value [EOL] mailer . send ( message ) [EOL] assert mailer . server . sendmail . call_count == [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from tensorhive . core . utils . decorators import memoize [EOL] from unittest . mock import patch [EOL] import time [EOL] [EOL] [EOL] def test_memoize_for_correct_func_call_count ( ) : [EOL] @ memoize def add ( x , y ) : [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] return x + y [EOL] [EOL] @ memoize def foo ( a , b , c ) : [EOL] time . sleep ( [number] ) [EOL] return a and b and c [EOL] [EOL] with patch . object ( time , [string] ) as mocked_sleep : [EOL] [ add ( [number] , [number] ) for _ in range ( [number] ) ] [EOL] assert mocked_sleep . call_count == [number] [EOL] [EOL] mocked_sleep . call_count = [number] [EOL] foo ( { [string] : [number] } , { [string] : [number] } , True ) [EOL] foo ( { [string] : [number] } , { [string] : [number] } , [string] ) [EOL] assert mocked_sleep . call_count == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] import os [EOL] import stat [EOL] import tensorhive . core . ssh as sut [EOL] from tensorhive . config import SSH [EOL] from paramiko . rsakey import RSAKey [EOL] [EOL] [EOL] def test_config_builder_with_good_arguments ( ) : [EOL] config , _ = sut . build_dedicated_config_for ( [string] , [string] ) [EOL] assert config == { [string] : { [string] : [string] , [string] : SSH . KEY_FILE } } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , None ) , ( [string] , None ) , ( None , [string] ) , ] ) def test_config_builder_failure_with_invalid_arguments ( host , user ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] sut . build_dedicated_config_for ( host , user ) [EOL] [EOL] [EOL] @ pytest . fixture def key_path ( tmp_path ) : [EOL] return tmp_path / [string] [EOL] [EOL] [EOL] @ pytest . fixture def saved_key ( key_path ) : [EOL] return sut . generate_cert ( key_path ) [EOL] [EOL] [EOL] def test_generate_cert_generated_cert_is_loadable ( saved_key , key_path ) : [EOL] RSAKey . from_private_key_file ( str ( key_path ) ) [EOL] [EOL] [EOL] def test_generate_cert_generating_twice_throws_exception ( saved_key , key_path ) : [EOL] with pytest . raises ( FileExistsError ) : [EOL] sut . generate_cert ( key_path ) [EOL] [EOL] [EOL] def test_generate_cert_generated_cert_has_proper_permissions ( saved_key , key_path ) : [EOL] mode = os . stat ( str ( key_path ) ) . st_mode [EOL] assert stat . S_IMODE ( mode ) == [number] [EOL] [EOL] [EOL] def test_generate_cert_with_replace_generates_different_key ( saved_key , key_path ) : [EOL] new_key = sut . generate_cert ( key_path , replace = True ) [EOL] assert saved_key != new_key [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import datetime [EOL] import typing [EOL] import pytest [EOL] from datetime import timedelta , datetime [EOL] [EOL] [EOL] def test_reservation_creation ( tables , new_reservation ) : [EOL] new_reservation . save ( ) [EOL] [EOL] [EOL] def test_interfering_reservation_cannot_be_saved ( tables , new_reservation , new_reservation_2 ) : [EOL] [comment] [EOL] new_reservation . save ( ) [EOL] offset = timedelta ( minutes = [number] ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] new_reservation_2 . starts_at = new_reservation . starts_at + offset [EOL] new_reservation_2 . ends_at = new_reservation . ends_at - offset [EOL] new_reservation_2 . save ( ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] new_reservation_2 . starts_at = new_reservation . starts_at - offset [EOL] new_reservation_2 . ends_at = new_reservation . ends_at - offset [EOL] new_reservation_2 . save ( ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] new_reservation_2 . starts_at = new_reservation . starts_at + offset [EOL] new_reservation_2 . ends_at = new_reservation . starts_at + offset [EOL] new_reservation_2 . save ( ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] new_reservation_2 . starts_at = new_reservation . starts_at - offset [EOL] new_reservation_2 . ends_at = new_reservation . ends_at + offset [EOL] new_reservation_2 . save ( ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_string_time_format_conversion ( tables , new_reservation , faker ) : [EOL] [comment] [EOL] starts_at_datetime = faker . future_datetime ( end_date = [string] ) [EOL] ends_at_datetime = starts_at_datetime + timedelta ( minutes = [number] ) [EOL] [EOL] def cast_dt_to_str ( format ) : [EOL] return starts_at_datetime . strftime ( format ) , ends_at_datetime . strftime ( format ) [EOL] [EOL] [comment] [EOL] invalid_format = [string] [EOL] starts_at , ends_at = cast_dt_to_str ( invalid_format ) [EOL] with pytest . raises ( ValueError ) : [EOL] new_reservation . starts_at = starts_at [EOL] new_reservation . ends_at = ends_at [EOL] new_reservation . save ( ) [EOL] [EOL] [comment] [EOL] valid_format = [string] [EOL] starts_at , ends_at = cast_dt_to_str ( valid_format ) [EOL] new_reservation . starts_at = starts_at [EOL] new_reservation . ends_at = ends_at [EOL] new_reservation . save ( ) [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_invalid_reservation_time_range ( tables , new_reservation , faker ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] new_reservation . starts_at = faker . future_datetime ( end_date = [string] ) [EOL] new_reservation . ends_at = faker . past_datetime ( start_date = [string] ) [EOL] new_reservation . save ( ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] new_reservation . starts_at = faker . future_datetime ( ) [EOL] new_reservation . ends_at = new_reservation . starts_at + timedelta ( minutes = [number] , seconds = [number] ) [EOL] new_reservation . save ( ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] [comment] [EOL] new_reservation . starts_at = faker . future_datetime ( ) [EOL] new_reservation . ends_at = new_reservation . starts_at + timedelta ( days = [number] , seconds = [number] ) [EOL] new_reservation . save ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import click [EOL] from tensorhive . cli import prompt_to_create_first_account [EOL] from click . testing import CliRunner [EOL] import click [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) ] ) def test_prompts ( tables , test_name , test_input ) : [EOL] mocked_input = [string] . join ( test_input ) [EOL] [EOL] @ click . command ( ) def click_wrapper ( ) : [EOL] prompt_to_create_first_account ( ) [EOL] assert True [EOL] [EOL] result = CliRunner ( ) . invoke ( click_wrapper , input = mocked_input ) [EOL] assert result . exception is None , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tensorhive [EOL] import pytest [EOL] from sqlalchemy . exc import OperationalError , IntegrityError [EOL] from tensorhive . models . User import User [EOL] [EOL] [EOL] def test_user_creation ( tables , new_user , new_admin ) : [EOL] new_user . save ( ) [EOL] assert set ( new_user . role_names ) == set ( [ [string] ] ) [EOL] assert new_user . id [EOL] [EOL] new_admin . save ( ) [EOL] assert new_admin . id [EOL] assert set ( new_admin . role_names ) == set ( [ [string] , [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] * [number] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) def test_exception_on_creating_user_with_invalid_username ( tables , test_name , test_username ) : [EOL] with pytest . raises ( AssertionError ) : [EOL] User ( username = test_username , password = [string] ) . save ( ) [EOL] [EOL] [EOL] def test_exception_on_creating_user_with_no_password ( tables ) : [EOL] with pytest . raises ( IntegrityError ) : [EOL] User ( username = [string] ) . save ( ) [EOL] [EOL] [EOL] def test_exception_on_creating_user_with_not_unique_username ( tables ) : [EOL] with pytest . raises ( IntegrityError ) : [EOL] duplicated_username = [string] [EOL] password = [string] [EOL] [EOL] existing_user = User ( username = duplicated_username , password = password ) [EOL] duplicated_user = User ( username = duplicated_username , password = password ) [EOL] [EOL] existing_user . save ( ) [EOL] duplicated_user . save ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] from alembic import op [EOL] import sqlalchemy as sa [EOL] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = ( [string] , [string] ) [EOL] branch_labels = None [EOL] depends_on = None [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] pass [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Dict , Any , Type [EOL] import configparser [EOL] import pathlib [EOL] import typing [EOL] import tensorhive [EOL] import logging [EOL] import builtins [EOL] from pathlib import PosixPath [EOL] import configparser [EOL] from typing import Dict , Optional , Any , List [EOL] from inspect import cleandoc [EOL] import shutil [EOL] import tensorhive [EOL] import os [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class CONFIG_FILES : [EOL] [comment] [EOL] [comment] [EOL] config_dir = PosixPath . home ( ) / [string] [EOL] MAIN_CONFIG_PATH = str ( config_dir / [string] ) [EOL] HOSTS_CONFIG_PATH = str ( config_dir / [string] ) [EOL] MAILBOT_CONFIG_PATH = str ( config_dir / [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] tensorhive_package_dir = PosixPath ( __file__ ) . parent [EOL] MAIN_CONFIG_TEMPLATE_PATH = str ( tensorhive_package_dir / [string] ) [EOL] HOSTS_CONFIG_TEMPLATE_PATH = str ( tensorhive_package_dir / [string] ) [EOL] MAILBOT_TEMPLATE_CONFIG_PATH = str ( tensorhive_package_dir / [string] ) [EOL] [EOL] [EOL] class ConfigInitilizer : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] all_exist = PosixPath ( CONFIG_FILES . MAIN_CONFIG_PATH ) . exists ( ) and PosixPath ( CONFIG_FILES . HOSTS_CONFIG_PATH ) . exists ( ) and PosixPath ( CONFIG_FILES . MAILBOT_CONFIG_PATH ) . exists ( ) [EOL] [EOL] if not all_exist : [EOL] log . warning ( [string] ) [EOL] self . recreate_default_configuration_files ( ) [EOL] log . info ( [string] ) [EOL] [EOL] def recreate_default_configuration_files ( self ) : [EOL] try : [EOL] [comment] [EOL] CONFIG_FILES . config_dir . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] [comment] [EOL] self . safe_copy ( src = CONFIG_FILES . MAIN_CONFIG_TEMPLATE_PATH , dst = CONFIG_FILES . MAIN_CONFIG_PATH ) [EOL] self . safe_copy ( src = CONFIG_FILES . HOSTS_CONFIG_TEMPLATE_PATH , dst = CONFIG_FILES . HOSTS_CONFIG_PATH ) [EOL] self . safe_copy ( src = CONFIG_FILES . MAILBOT_TEMPLATE_CONFIG_PATH , dst = CONFIG_FILES . MAILBOT_CONFIG_PATH ) [EOL] [EOL] [comment] [EOL] rw_owner_only = [number] [EOL] os . chmod ( CONFIG_FILES . MAIN_CONFIG_PATH , rw_owner_only ) [EOL] os . chmod ( CONFIG_FILES . HOSTS_CONFIG_PATH , rw_owner_only ) [EOL] os . chmod ( CONFIG_FILES . MAILBOT_CONFIG_PATH , rw_owner_only ) [EOL] except Exception : [EOL] log . error ( [string] ) [EOL] [EOL] def safe_copy ( self , src , dst ) : [EOL] [docstring] [EOL] if PosixPath ( dst ) . exists ( ) : [EOL] log . info ( [string] . format ( dst ) ) [EOL] else : [EOL] shutil . copy ( src , dst ) [EOL] log . info ( [string] . format ( src , dst ) ) [EOL] [EOL] [EOL] class ConfigLoader : [EOL] @ staticmethod def load ( path , displayed_title = [string] ) : [EOL] import configparser [EOL] config = configparser . ConfigParser ( strict = False ) [EOL] full_path = PosixPath ( path ) . expanduser ( ) [EOL] if config . read ( str ( full_path ) ) : [EOL] log . info ( [string] . format ( displayed_title , full_path ) ) [EOL] else : [EOL] log . warning ( [string] . format ( full_path ) ) [EOL] log . info ( [string] . format ( displayed_title ) ) [EOL] return config [EOL] [EOL] [EOL] ConfigInitilizer ( ) [EOL] config = ConfigLoader . load ( CONFIG_FILES . MAIN_CONFIG_PATH , displayed_title = [string] ) [EOL] [EOL] [EOL] def display_config ( cls ) : [EOL] [docstring] [EOL] print ( [string] . format ( class_name = cls . __name__ ) ) [EOL] for key , value in cls . __dict__ . items ( ) : [EOL] if key . isupper ( ) : [EOL] print ( [string] . format ( key , value ) ) [EOL] [EOL] [EOL] def check_env_var ( name ) : [EOL] [docstring] [EOL] if not os . getenv ( name ) : [EOL] msg = cleandoc ( [string] ) . format ( env = name ) . split ( [string] ) [EOL] log . warning ( msg [ [number] ] ) [EOL] log . warning ( msg [ [number] ] ) [EOL] [EOL] [EOL] class SSH : [EOL] section = [string] [EOL] HOSTS_CONFIG_FILE = config . get ( section , [string] , fallback = CONFIG_FILES . HOSTS_CONFIG_PATH ) [EOL] TEST_ON_STARTUP = config . getboolean ( section , [string] , fallback = True ) [EOL] TIMEOUT = config . getfloat ( section , [string] , fallback = [number] ) [EOL] NUM_RETRIES = config . getint ( section , [string] , fallback = [number] ) [EOL] KEY_FILE = config . get ( section , [string] , fallback = [string] ) [EOL] [EOL] def hosts_config_to_dict ( path ) : [comment] [EOL] [docstring] [EOL] hosts_config = ConfigLoader . load ( path , displayed_title = [string] ) [EOL] result = { } [EOL] for section in hosts_config . sections ( ) : [EOL] [comment] [EOL] if section == [string] : [EOL] continue [EOL] [EOL] hostname = section [EOL] result [ hostname ] = { [string] : hosts_config . get ( hostname , [string] ) , [string] : hosts_config . getint ( hostname , [string] , fallback = [number] ) } [EOL] return result [EOL] [EOL] def proxy_config_to_dict ( path ) : [comment] [EOL] [docstring] [EOL] config = ConfigLoader . load ( path , displayed_title = [string] ) [EOL] section = [string] [EOL] [EOL] [comment] [EOL] if config . has_section ( section ) and config . getboolean ( section , [string] , fallback = False ) : [EOL] return { [string] : config . get ( section , [string] ) , [string] : config . get ( section , [string] ) , [string] : config . getint ( section , [string] , fallback = [number] ) } [EOL] else : [EOL] return None [EOL] [EOL] AVAILABLE_NODES = hosts_config_to_dict ( HOSTS_CONFIG_FILE ) [EOL] PROXY = proxy_config_to_dict ( HOSTS_CONFIG_FILE ) [EOL] [EOL] [EOL] class DB : [EOL] section = [string] [EOL] default_path = [string] [EOL] [EOL] def uri_for_path ( path ) : [comment] [EOL] return [string] . format ( PosixPath ( path ) . expanduser ( ) ) [EOL] [EOL] SQLALCHEMY_DATABASE_URI = uri_for_path ( config . get ( section , [string] , fallback = default_path ) ) [EOL] TEST_DATABASE_URI = [string] [comment] [EOL] [EOL] [EOL] class API : [EOL] section = [string] [EOL] TITLE = config . get ( section , [string] , fallback = [string] ) [EOL] VERSION = config . get ( section , [string] , fallback = [string] . format ( tensorhive . __version__ ) ) [EOL] URL_HOSTNAME = config . get ( section , [string] , fallback = [string] ) [EOL] URL_PREFIX = config . get ( section , [string] , fallback = [string] . format ( VERSION ) ) [EOL] SPEC_FILE = config . get ( section , [string] , fallback = [string] ) [EOL] IMPL_LOCATION = config . get ( section , [string] , fallback = [string] ) [EOL] [EOL] import yaml [EOL] respones_file_path = str ( PosixPath ( __file__ ) . parent / [string] ) [EOL] with open ( respones_file_path , [string] ) as file : [EOL] RESPONSES = yaml . safe_load ( file ) [EOL] [EOL] [EOL] class APP_SERVER : [EOL] section = [string] [EOL] BACKEND = config . get ( section , [string] , fallback = [string] ) [EOL] HOST = config . get ( section , [string] , fallback = [string] ) [EOL] PORT = config . getint ( section , [string] , fallback = [number] ) [EOL] WORKERS = config . getint ( section , [string] , fallback = [number] ) [EOL] LOG_LEVEL = config . get ( section , [string] , fallback = [string] ) [EOL] [EOL] [EOL] class API_SERVER : [EOL] section = [string] [EOL] BACKEND = config . get ( section , [string] , fallback = [string] ) [EOL] HOST = config . get ( section , [string] , fallback = [string] ) [EOL] PORT = config . getint ( section , [string] , fallback = [number] ) [EOL] DEBUG = config . getboolean ( section , [string] , fallback = False ) [EOL] [EOL] [EOL] class MONITORING_SERVICE : [EOL] section = [string] [EOL] ENABLED = config . getboolean ( section , [string] , fallback = True ) [EOL] ENABLE_GPU_MONITOR = config . getboolean ( section , [string] , fallback = True ) [EOL] UPDATE_INTERVAL = config . getfloat ( section , [string] , fallback = [number] ) [EOL] [EOL] [EOL] class PROTECTION_SERVICE : [EOL] section = [string] [EOL] ENABLED = config . getboolean ( section , [string] , fallback = True ) [EOL] UPDATE_INTERVAL = config . getfloat ( section , [string] , fallback = [number] ) [EOL] NOTIFY_ON_PTY = config . getboolean ( section , [string] , fallback = True ) [EOL] NOTIFY_VIA_EMAIL = config . getboolean ( section , [string] , fallback = False ) [EOL] [EOL] [EOL] class MAILBOT : [EOL] mailbot_config = ConfigLoader . load ( CONFIG_FILES . MAILBOT_CONFIG_PATH , displayed_title = [string] ) [EOL] section = [string] [EOL] INTERVAL = mailbot_config . getfloat ( section , [string] , fallback = [number] ) [EOL] NOTIFY_INTRUDER = mailbot_config . getboolean ( section , [string] , fallback = True ) [EOL] NOTIFY_ADMIN = mailbot_config . getboolean ( section , [string] , fallback = False ) [EOL] ADMIN_EMAIL = mailbot_config . get ( section , [string] , fallback = None ) [EOL] [EOL] section = [string] [EOL] SMTP_LOGIN = mailbot_config . get ( section , [string] , fallback = None ) [EOL] SMTP_PASSWORD = mailbot_config . get ( section , [string] , fallback = None ) [EOL] SMTP_SERVER = mailbot_config . get ( section , [string] , fallback = None ) [EOL] SMTP_PORT = mailbot_config . getint ( section , [string] , fallback = [number] ) [EOL] [EOL] section = [string] [EOL] INTRUDER_SUBJECT = mailbot_config . get ( section , [string] ) [EOL] INTRUDER_BODY_TEMPLATE = mailbot_config . get ( section , [string] ) [EOL] [EOL] section = [string] [EOL] ADMIN_SUBJECT = mailbot_config . get ( section , [string] ) [EOL] ADMIN_BODY_TEMPLATE = mailbot_config . get ( section , [string] ) [EOL] [EOL] [EOL] class USAGE_LOGGING_SERVICE : [EOL] section = [string] [EOL] default_path = [string] [EOL] [EOL] def full_path ( path ) : [comment] [EOL] return str ( PosixPath ( path ) . expanduser ( ) ) [EOL] [EOL] ENABLED = config . getboolean ( section , [string] , fallback = True ) [EOL] UPDATE_INTERVAL = config . getfloat ( section , [string] , fallback = [number] ) [EOL] LOG_DIR = full_path ( config . get ( section , [string] , fallback = default_path ) ) [EOL] LOG_CLEANUP_ACTION = config . getint ( section , [string] , fallback = [number] ) [EOL] [EOL] [EOL] class TASK_SCHEDULING_SERVICE : [EOL] section = [string] [EOL] ENABLED = config . getboolean ( section , [string] , fallback = True ) [EOL] UPDATE_INTERVAL = config . getfloat ( section , [string] , fallback = [number] ) [EOL] STOP_TERMINATION_ATTEMPTS_AFTER = config . getfloat ( section , [string] , fallback = [number] ) [EOL] [EOL] [EOL] class AUTH : [EOL] from datetime import timedelta [EOL] section = [string] [EOL] [EOL] def config_get_parsed ( option , fallback ) : [comment] [EOL] [docstring] [EOL] import ast [EOL] try : [EOL] raw_arguments = config . get ( [string] , option ) [EOL] parsed_arguments = ast . literal_eval ( raw_arguments ) [EOL] return parsed_arguments [EOL] except ( configparser . Error , ValueError ) : [EOL] log . warning ( [string] . format ( option , fallback ) ) [EOL] return fallback [EOL] [EOL] FLASK_JWT = { [string] : config . get ( section , [string] , fallback = [string] ) , [string] : config . getboolean ( section , [string] , fallback = True ) , [string] : config_get_parsed ( [string] , fallback = [ [string] , [string] ] ) , [string] : config . getboolean ( section , [string] , fallback = True ) , [string] : timedelta ( minutes = config . getint ( section , [string] , fallback = [number] ) ) , [string] : timedelta ( days = config . getint ( section , [string] , fallback = [number] ) ) , [string] : config_get_parsed ( [string] , fallback = [ [string] ] ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] from flask_jwt_extended import JWTManager , verify_jwt_in_request , get_jwt_claims [EOL] from tensorhive . models . RevokedToken import RevokedToken [EOL] from tensorhive . config import AUTH [EOL] from functools import wraps [EOL] from tensorhive . models . User import User [EOL] from tensorhive . database import db_session [EOL] from tensorhive . config import API [EOL] G = API . RESPONSES [ [string] ] [EOL] [EOL] [EOL] def init_jwt ( app ) : [EOL] for key , value in AUTH . FLASK_JWT . items ( ) : [EOL] app . config [ key ] = value [EOL] global jwt [EOL] jwt = JWTManager ( app ) [EOL] [EOL] @ jwt . token_in_blacklist_loader def is_token_on_blacklist ( decrypted_token ) : [EOL] jti = decrypted_token [ [string] ] [EOL] return RevokedToken . is_jti_blacklisted ( jti ) [EOL] [EOL] @ jwt . user_claims_loader def add_claims_to_access_token ( current_user_id ) : [EOL] try : [EOL] current_user = User . get ( current_user_id ) [EOL] roles = current_user . role_names [EOL] except Exception : [EOL] roles = [ ] [EOL] finally : [EOL] return { [string] : roles } [EOL] [EOL] [EOL] def admin_required ( fn ) : [EOL] @ wraps ( fn ) def wrapper ( * args , ** kwargs ) : [EOL] verify_jwt_in_request ( ) [EOL] claims = get_jwt_claims ( ) [EOL] if [string] in claims [ [string] ] : [EOL] return fn ( * args , ** kwargs ) [EOL] return { [string] : G [ [string] ] } , [number] [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type [EOL] import typing [EOL] import tensorhive [EOL] class ProtectionHandler ( ) : [EOL] _protection_behaviour = None [EOL] [EOL] def __init__ ( self , behaviour ) : [EOL] self . _protection_behaviour = behaviour [EOL] [EOL] def trigger_action ( self , * args , ** kwargs ) : [EOL] self . _protection_behaviour . trigger_action ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from abc import ABC , abstractmethod [EOL] from typing import Dict [EOL] [EOL] [EOL] class Monitor ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def update ( self , connection , infrastructure_manager ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0
	0
import datetime [EOL] from datetime import datetime [EOL] import time [EOL] [EOL] [EOL] def utc2local ( utc ) : [EOL] [docstring] [EOL] epoch = time . mktime ( utc . timetuple ( ) ) [EOL] offset = datetime . fromtimestamp ( epoch ) - datetime . utcfromtimestamp ( epoch ) [EOL] return utc + offset [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
class ConfigurationException ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Any [EOL] import logging [EOL] import typing [EOL] from flask_jwt_extended import jwt_required [EOL] from tensorhive . models . User import User [EOL] from sqlalchemy . orm . exc import NoResultFound [EOL] from connexion import NoContent [EOL] from tensorhive . config import API [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] G = API . RESPONSES [ [string] ] [EOL] U = API . RESPONSES [ [string] ] [EOL] [EOL] [EOL] @ jwt_required def get ( ) : [EOL] return [ user . as_dict for user in User . all ( ) ] , [number] [EOL] [EOL] [EOL] @ jwt_required def get_by_id ( id ) : [EOL] [comment] [EOL] try : [EOL] user = User . get ( id ) [EOL] except NoResultFound as e : [EOL] log . warning ( e ) [EOL] content , status = { [string] : U [ [string] ] } , [number] [EOL] except Exception as e : [EOL] log . critical ( e ) [EOL] content , status = { [string] : G [ [string] ] } , [number] [EOL] else : [EOL] content , status = { [string] : U [ [string] ] [ [string] ] , [string] : user . as_dict } , [number] [EOL] finally : [EOL] return content , status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import logging [EOL] import typing [EOL] from sqlalchemy . orm . exc import NoResultFound [EOL] from tensorhive . models . User import User [EOL] from tensorhive . database import db_session [EOL] from flask_jwt_extended import get_jwt_identity [EOL] from tensorhive . authorization import admin_required [EOL] from tensorhive . config import API [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] R = API . RESPONSES [ [string] ] [EOL] G = API . RESPONSES [ [string] ] [EOL] [EOL] [EOL] @ admin_required def delete ( id ) : [EOL] try : [EOL] current_user_id = get_jwt_identity ( ) [EOL] [EOL] [comment] [EOL] assert id != current_user_id , R [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] user_to_destroy = User . get ( id ) [EOL] user_to_destroy . destroy ( ) [EOL] except AssertionError as error_message : [EOL] content , status = { [string] : str ( error_message ) } , [number] [EOL] except NoResultFound : [EOL] content , status = { [string] : R [ [string] ] } , [number] [EOL] except Exception as e : [EOL] content , status = { [string] : G [ [string] ] + str ( e ) } , [number] [EOL] else : [EOL] content , status = { [string] : R [ [string] ] [ [string] ] } , [number] [EOL] finally : [EOL] return content , status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import logging [EOL] import typing [EOL] from flask_jwt_extended import get_raw_jwt [EOL] from tensorhive . models . RevokedToken import RevokedToken [EOL] from flask_jwt_extended import jwt_required , jwt_refresh_token_required [EOL] from tensorhive . config import API [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] R = API . RESPONSES [ [string] ] [EOL] G = API . RESPONSES [ [string] ] [EOL] T = API . RESPONSES [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def logout ( token_type ) : [EOL] jti = get_raw_jwt ( ) [ [string] ] [EOL] try : [EOL] RevokedToken ( jti = jti ) . save ( ) [EOL] except Exception : [EOL] log . critical ( G [ [string] ] ) [EOL] log . critical ( T [ [string] ] . format ( token_type = token_type ) ) [EOL] content = { [string] : G [ [string] ] } [EOL] status = [number] [EOL] else : [EOL] content = { [string] : R [ [string] ] [ [string] ] } [EOL] status = [number] [EOL] finally : [EOL] return content , status [EOL] [EOL] [EOL] @ jwt_required def logout_with_access_token ( ) : [EOL] return logout ( [string] ) [EOL] [EOL] [EOL] @ jwt_refresh_token_required def logout_with_refresh_token ( ) : [EOL] return logout ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] from tensorhive . models . User import User [EOL] from tensorhive . config import API [EOL] from tensorhive . authorization import admin_required [EOL] from tensorhive . models . Role import Role [EOL] from flask_jwt_extended import jwt_required [EOL] [EOL] R = API . RESPONSES [ [string] ] [EOL] G = API . RESPONSES [ [string] ] [EOL] [EOL] [EOL] @ admin_required @ jwt_required def update ( user ) : [EOL] print ( [string] , user ) [EOL] if user . get ( [string] ) is not None : [EOL] try : [EOL] found_user = User . get ( user [ [string] ] ) [EOL] updateable_field_names = [ [string] , [string] , [string] ] [EOL] [EOL] for field_name in updateable_field_names : [EOL] if user . get ( field_name ) is not None : [EOL] if field_name == [string] : [EOL] new_value = [ Role ( name = role_name ) for role_name in user [ [string] ] ] [EOL] else : [EOL] new_value = user [ field_name ] [EOL] setattr ( found_user , field_name , new_value ) [EOL] [EOL] found_user . save ( ) [EOL] except AssertionError as e : [EOL] content = { [string] : R [ [string] ] [ [string] ] [ [string] ] . format ( reason = e ) } [EOL] status = [number] [EOL] except Exception : [EOL] content = { [string] : G [ [string] ] } [EOL] status = [number] [EOL] else : [EOL] content = { [string] : R [ [string] ] [ [string] ] , [string] : found_user . as_dict } [EOL] status = [number] [EOL] else : [EOL] content = { [string] : G [ [string] ] } [EOL] status = [number] [EOL] [EOL] return content , status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import logging [EOL] import typing [EOL] from flask_jwt_extended import create_access_token , get_jwt_identity , jwt_refresh_token_required [EOL] from tensorhive . models . User import User [EOL] from sqlalchemy . orm . exc import NoResultFound [EOL] from tensorhive . config import API [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] R = API . RESPONSES [ [string] ] [EOL] G = API . RESPONSES [ [string] ] [EOL] [EOL] [EOL] @ jwt_refresh_token_required def generate ( ) : [EOL] new_access_token = create_access_token ( identity = get_jwt_identity ( ) , fresh = False ) [EOL] content = { [string] : R [ [string] ] [ [string] ] , [string] : new_access_token } [EOL] return content , [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from tensorhive . models . User import User [EOL] from flask_jwt_extended import create_access_token , create_refresh_token [EOL] from sqlalchemy . orm . exc import NoResultFound [EOL] from tensorhive . config import API [EOL] R = API . RESPONSES [ [string] ] [EOL] G = API . RESPONSES [ [string] ] [EOL] [EOL] [EOL] def login ( user ) : [EOL] try : [EOL] current_user = User . find_by_username ( user [ [string] ] ) [EOL] assert User . verify_hash ( user [ [string] ] , current_user . password ) , R [ [string] ] [ [string] ] [ [string] ] [EOL] except NoResultFound : [EOL] content = { [string] : R [ [string] ] } [EOL] status = [number] [EOL] except AssertionError as error_message : [EOL] content = { [string] : str ( error_message ) } [EOL] status = [number] [EOL] except Exception : [EOL] content = { [string] : G [ [string] ] } [EOL] status = [number] [EOL] else : [EOL] content = { [string] : R [ [string] ] [ [string] ] . format ( username = current_user . username ) , [string] : create_access_token ( identity = current_user . id , fresh = True ) , [string] : create_refresh_token ( identity = current_user . id ) } [EOL] status = [number] [EOL] finally : [EOL] return content , status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Optional , Dict , Union , List , Any [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] from flask_jwt_extended import jwt_required [EOL] from tensorhive . models . Reservation import Reservation [EOL] from typing import List [EOL] from tensorhive . config import API [EOL] G = API . RESPONSES [ [string] ] [EOL] [EOL] [EOL] @ jwt_required def get_all ( ) : [EOL] return [ reservation . as_dict for reservation in Reservation . all ( ) ] , [number] [EOL] [EOL] [EOL] @ jwt_required def get_selected ( resources_ids , start , end ) : [EOL] [comment] [EOL] [comment] [EOL] all_not_none = resources_ids and start and end [EOL] if all_not_none : [EOL] try : [EOL] start_as_datetime = Reservation . parsed_input_datetime ( start ) [EOL] ends_as_datetime = Reservation . parsed_input_datetime ( end ) [EOL] matches = list ( Reservation . filter_by_uuids_and_time_range ( resources_ids , start_as_datetime , ends_as_datetime ) ) [EOL] matches = [ match . as_dict for match in matches ] [EOL] except ( ValueError , AssertionError ) as reason : [EOL] content = { [string] : [string] . format ( G [ [string] ] , reason ) } [EOL] status = [number] [EOL] except Exception : [EOL] content = { [string] : G [ [string] ] } [EOL] status = [number] [EOL] else : [EOL] content = matches [comment] [EOL] status = [number] [EOL] else : [EOL] content = { [string] : G [ [string] ] } [EOL] status = [number] [EOL] return content , status [EOL] [EOL] [EOL] @ jwt_required def get ( resources_ids = None , start = None , end = None ) : [EOL] args = [ resources_ids , start , end ] [EOL] all_args_none = all ( a is None for a in args ) [EOL] [EOL] if all_args_none : [EOL] return get_all ( ) [EOL] else : [EOL] [comment] [EOL] return get_selected ( resources_ids , start , end ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Set , Any , Type [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] from flask_jwt_extended import jwt_required [EOL] from tensorhive . models . Reservation import Reservation [EOL] from sqlalchemy . orm . exc import NoResultFound [EOL] from typing import List , Optional , Any , Dict , Tuple [EOL] from tensorhive . config import API [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] R = API . RESPONSES [ [string] ] [EOL] G = API . RESPONSES [ [string] ] [EOL] [EOL] [comment] [EOL] Content = Dict [ str , Any ] [EOL] HttpStatusCode = int [EOL] ReservationId = int [EOL] [EOL] [EOL] @ jwt_required def update ( id , newValues ) : [EOL] new_values = newValues [EOL] allowed_fields = { [string] , [string] , [string] , [string] , [string] } [EOL] try : [EOL] assert set ( new_values . keys ( ) ) . issubset ( allowed_fields ) , [string] [EOL] reservation = Reservation . get ( id ) [EOL] [EOL] for field_name , new_value in new_values . items ( ) : [EOL] [comment] [EOL] if field_name in [ [string] , [string] ] : [EOL] [comment] [EOL] field_name += [string] [EOL] if field_name == [string] : [EOL] field_name = [string] [EOL] assert hasattr ( reservation , field_name ) , [string] . format ( field_name ) [EOL] setattr ( reservation , field_name , new_value ) [EOL] reservation . save ( ) [EOL] except NoResultFound : [EOL] content , status = { [string] : R [ [string] ] } , [number] [EOL] except AssertionError as e : [EOL] content , status = { [string] : R [ [string] ] [ [string] ] [ [string] ] . format ( reason = e ) } , [number] [EOL] except Exception as e : [EOL] log . critical ( e ) [EOL] content , status = { [string] : G [ [string] ] } , [number] [EOL] else : [EOL] content , status = { [string] : R [ [string] ] [ [string] ] , [string] : reservation . as_dict } , [number] [EOL] finally : [EOL] return content , status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[Content,HttpStatusCode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import tensorhive [EOL] from tensorhive . models . Reservation import Reservation [EOL] from flask_jwt_extended import jwt_required [EOL] [comment] [EOL] from tensorhive . config import API [EOL] R = API . RESPONSES [ [string] ] [EOL] G = API . RESPONSES [ [string] ] [EOL] [EOL] [EOL] @ jwt_required def create ( reservation ) : [EOL] try : [EOL] new_reservation = Reservation ( title = reservation [ [string] ] , description = reservation [ [string] ] , protected_resource_id = reservation [ [string] ] , user_id = reservation [ [string] ] , starts_at = reservation [ [string] ] , ends_at = reservation [ [string] ] ) [EOL] new_reservation . save ( ) [EOL] except AssertionError as e : [EOL] content = { [string] : R [ [string] ] [ [string] ] [ [string] ] . format ( reason = e ) } [EOL] status = [number] [EOL] except Exception : [EOL] content = { [string] : G [ [string] ] } [EOL] status = [number] [EOL] else : [EOL] content = { [string] : R [ [string] ] [ [string] ] , [string] : new_reservation . as_dict } [EOL] status = [number] [EOL] finally : [EOL] return content , status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import List , Any , Type [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] import tensorhive [EOL] from passlib . hash import pbkdf2_sha256 as sha256 [EOL] import datetime [EOL] [EOL] from sqlalchemy import Column , Integer , String , DateTime [EOL] from sqlalchemy . orm import relationship , backref [EOL] from tensorhive . database import db_session , Base [EOL] from tensorhive . models . CRUDModel import CRUDModel [EOL] from sqlalchemy . orm . exc import MultipleResultsFound , NoResultFound [EOL] from sqlalchemy . orm import validates [EOL] from usernames import is_safe_username [EOL] from sqlalchemy . ext . hybrid import hybrid_property [EOL] import safe [EOL] import logging [EOL] import re [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PASS_COMPLEXITY : [EOL] TERRIBLE = [number] [EOL] SIMPLE = [number] [EOL] MEDIUM = [number] [EOL] STRONG = [number] [EOL] [EOL] [EOL] USERNAME_WHITELIST = [ [string] ] [EOL] [EOL] [EOL] class User ( CRUDModel , Base ) : [comment] [EOL] __tablename__ = [string] [EOL] id = Column ( Integer , primary_key = True , autoincrement = True ) [EOL] username = Column ( String ( [number] ) , unique = True , nullable = False ) [EOL] email = Column ( String ( [number] ) , unique = False , nullable = False , server_default = [string] ) [EOL] created_at = Column ( DateTime , default = datetime . datetime . utcnow ) [EOL] [EOL] [comment] [EOL] _hashed_password = Column ( String ( [number] ) , nullable = False ) [EOL] _roles = relationship ( [string] , cascade = [string] , backref = backref ( [string] ) ) [EOL] [EOL] min_password_length = [number] [EOL] [EOL] def check_assertions ( self ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( id = self . id , username = self . username , email = self . email ) [EOL] [EOL] @ hybrid_property def roles ( self ) : [EOL] return self . _roles [EOL] [EOL] @ roles . setter def roles ( self , new_roles ) : [EOL] self . _roles = new_roles [EOL] [EOL] @ hybrid_property def role_names ( self ) : [EOL] return [ role . name for role in self . _roles ] [EOL] [EOL] def has_role ( self , role_name ) : [EOL] return bool ( role_name in self . role_names ) [EOL] [EOL] @ hybrid_property def password ( self ) : [EOL] return self . _hashed_password [EOL] [EOL] @ password . setter def password ( self , raw ) : [EOL] result = safe . check ( raw , length = self . min_password_length , freq = [number] , min_types = [number] , level = PASS_COMPLEXITY . TERRIBLE ) [EOL] assert result , [string] . format ( result . message ) [EOL] self . _hashed_password = sha256 . hash ( raw ) [EOL] [EOL] @ validates ( [string] ) def validate_username ( self , key , username ) : [EOL] assert is_safe_username ( username , whitelist = set ( USERNAME_WHITELIST ) ) , [string] [EOL] assert [number] < len ( username ) < [number] , [string] [EOL] return username [EOL] [EOL] @ validates ( [string] ) def validate_email ( self , key , email ) : [EOL] assert re . search ( [string] , email ) , [string] [EOL] assert [number] < len ( email ) < [number] , [string] [EOL] return email [EOL] [EOL] @ classmethod def find_by_username ( cls , username ) : [EOL] try : [EOL] result = db_session . query ( cls ) . filter_by ( username = username ) . one ( ) [EOL] except MultipleResultsFound : [EOL] [comment] [EOL] msg = [string] [EOL] log . critical ( msg ) [EOL] raise MultipleResultsFound ( msg ) [EOL] except NoResultFound : [EOL] msg = [string] . format ( username ) [EOL] log . warning ( msg ) [EOL] raise NoResultFound ( msg ) [EOL] else : [EOL] return result [EOL] [EOL] @ property def as_dict ( self ) : [EOL] [docstring] [EOL] try : [EOL] roles = self . role_names [EOL] except Exception : [EOL] roles = [ ] [EOL] finally : [EOL] return { [string] : self . id , [string] : self . username , [string] : self . created_at . isoformat ( ) , [string] : roles , [string] : self . email } [EOL] [EOL] @ staticmethod def verify_hash ( password , hash ) : [EOL] return sha256 . verify ( password , hash ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tensorhive.models.User.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tensorhive.models.User.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tensorhive.models.User.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tensorhive.models.User.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tensorhive.models.User.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tensorhive.models.User.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] from sqlalchemy . exc import SQLAlchemyError , IntegrityError [EOL] from sqlalchemy . orm . exc import MultipleResultsFound , NoResultFound [EOL] from tensorhive . database import db_session , Base [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class CRUDModel : [EOL] def check_assertions ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def save ( self ) : [EOL] try : [EOL] self . check_assertions ( ) [EOL] db_session . add ( self ) [EOL] db_session . commit ( ) [EOL] except SQLAlchemyError as e : [EOL] db_session . rollback ( ) [EOL] log . error ( [string] . format ( cause = e . __cause__ , data = self ) ) [EOL] raise [EOL] except AssertionError as e : [EOL] log . error ( e ) [EOL] raise [EOL] except Exception as e : [EOL] log . critical ( type ( e ) ) [EOL] raise [EOL] else : [EOL] log . debug ( [string] . format ( self ) ) [EOL] return self [EOL] [EOL] def destroy ( self ) : [EOL] try : [EOL] db_session . delete ( self ) [EOL] db_session . commit ( ) [EOL] except SQLAlchemyError as e : [EOL] db_session . rollback ( ) [EOL] log . error ( [string] . format ( cause = e . __cause__ , data = self ) ) [EOL] raise e [EOL] else : [EOL] log . debug ( [string] . format ( self ) ) [EOL] return self [EOL] [EOL] @ classmethod def get ( cls , id ) : [EOL] try : [EOL] result = db_session . query ( cls ) . filter_by ( id = id ) . one ( ) [EOL] except MultipleResultsFound : [EOL] msg = [string] . format ( cls . __name__ , id ) [EOL] log . critical ( msg ) [EOL] raise MultipleResultsFound ( msg ) [EOL] except NoResultFound : [EOL] msg = [string] . format ( cls . __name__ , id ) [EOL] log . debug ( msg ) [EOL] raise NoResultFound ( msg ) [EOL] else : [EOL] return result [EOL] [EOL] @ classmethod def all ( cls ) : [EOL] return db_session . query ( cls ) . all ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import logging [EOL] import typing [EOL] import tensorhive [EOL] from sqlalchemy import Column , Integer , String , ForeignKey [EOL] from sqlalchemy . exc import SQLAlchemyError [EOL] from tensorhive . database import db_session , Base [EOL] from tensorhive . models . CRUDModel import CRUDModel [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Role ( CRUDModel , Base ) : [comment] [EOL] __tablename__ = [string] [EOL] id = Column ( Integer , primary_key = True , autoincrement = True ) [EOL] name = Column ( String ( [number] ) , nullable = False ) [EOL] user_id = Column ( Integer , ForeignKey ( [string] ) ) [EOL] [EOL] def check_assertions ( self ) : [EOL] pass [EOL] [EOL] @ classmethod def find_by_name ( cls , name ) : [EOL] return cls . query . filter_by ( name = name ) . first ( ) [EOL] [EOL] @ classmethod def find_by_user_id ( cls , user_id ) : [EOL] return cls . query . filter_by ( user_id = user_id ) . all ( ) [EOL] [EOL] @ classmethod def delete_all ( cls ) : [EOL] try : [EOL] num_rows_deleted = cls . query ( cls ) . delete ( ) [EOL] cls . commit ( ) [EOL] return { [string] : [string] . format ( num_rows_deleted ) } [EOL] except Exception : [EOL] return { [string] : [string] } [EOL] [EOL] @ property def as_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . name , [string] : self . user_id } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tensorhive.models.Role.Role]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tensorhive.models.Role.Role]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tensorhive.models.Role.Role]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Optional , Union [EOL] import typing [EOL] import tensorhive [EOL] import datetime [EOL] import logging [EOL] import builtins [EOL] from sqlalchemy import Column , Integer , String , ForeignKey , Enum , DateTime [EOL] from datetime import datetime [EOL] from tensorhive . database import Base [EOL] from sqlalchemy . orm import relationship , backref [EOL] from sqlalchemy . ext . hybrid import hybrid_property [EOL] from tensorhive . models . CRUDModel import CRUDModel [EOL] from typing import Optional , Union [EOL] import enum [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] def parsed_input_datetime ( value ) : [EOL] [docstring] [EOL] client_datetime_format = [string] [EOL] try : [EOL] result = datetime . strptime ( value , client_datetime_format ) [EOL] except ValueError : [EOL] log . warning ( [string] ) [EOL] raise [EOL] else : [EOL] return result [EOL] [EOL] [EOL] [comment] [EOL] def try_parse_input_datetime ( value ) : [EOL] [docstring] [EOL] if isinstance ( value , str ) : [EOL] return parsed_input_datetime ( value ) [EOL] elif isinstance ( value , datetime ) : [EOL] return value [EOL] else : [EOL] return None [EOL] [EOL] [EOL] class TaskStatus ( enum . Enum ) : [EOL] not_running = [number] [EOL] running = [number] [EOL] terminated = [number] [EOL] unsynchronized = [number] [EOL] [EOL] [EOL] class Task ( CRUDModel , Base ) : [comment] [EOL] __tablename__ = [string] [EOL] id = Column ( Integer , primary_key = True , autoincrement = True ) [EOL] user_id = Column ( Integer , ForeignKey ( [string] , ondelete = [string] ) ) [EOL] user = relationship ( [string] , backref = backref ( [string] , passive_deletes = True , cascade = [string] ) , lazy = [string] ) [EOL] host = Column ( String ( [number] ) , nullable = False ) [EOL] pid = Column ( Integer , nullable = True ) [EOL] status = Column ( Enum ( TaskStatus ) , default = TaskStatus . not_running , nullable = False ) [EOL] command = Column ( String ( [number] ) , nullable = False ) [EOL] spawn_at = Column ( DateTime , nullable = True ) [EOL] terminate_at = Column ( DateTime , nullable = True ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] [string] . format ( id = self . id , user = self . user , host = self . host , command = self . command , pid = self . pid , status = self . status . name , spawn_at = self . spawn_at , terminate_at = self . terminate_at ) [EOL] [EOL] def check_assertions ( self ) : [EOL] pass [EOL] [EOL] [comment] [EOL] @ classmethod def try_parse_output_datetime ( cls , value ) : [EOL] [docstring] [EOL] if not value : [EOL] return None [EOL] display_datetime_format = [string] [EOL] server_timezone = [string] [EOL] return value . strftime ( display_datetime_format ) + server_timezone [EOL] [EOL] @ property def as_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . user_id , [string] : self . host , [string] : self . pid , [string] : self . status . name , [string] : self . command , [string] : self . try_parse_output_datetime ( self . spawn_at ) , [string] : self . try_parse_output_datetime ( self . terminate_at ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type [EOL] import logging [EOL] import typing [EOL] import tensorhive [EOL] from sqlalchemy import Column , Integer , String , DateTime [EOL] from sqlalchemy . orm import relationship [EOL] from sqlalchemy . exc import SQLAlchemyError , IntegrityError [EOL] from tensorhive . database import db_session , Base [EOL] from tensorhive . models . CRUDModel import CRUDModel [EOL] import logging [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class RevokedToken ( CRUDModel , Base ) : [comment] [EOL] __tablename__ = [string] [EOL] id = Column ( Integer , primary_key = True , autoincrement = True ) [EOL] jti = Column ( String ( [number] ) , unique = True , nullable = False ) [EOL] [EOL] def check_assertions ( self ) : [EOL] pass [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( id = self . id , jti = self . jti ) [EOL] [EOL] @ classmethod def is_jti_blacklisted ( cls , jti ) : [EOL] [comment] [EOL] return bool ( cls . query . filter_by ( jti = jti ) . first ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tensorhive.models.RevokedToken.RevokedToken]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tensorhive.models.RevokedToken.RevokedToken]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0