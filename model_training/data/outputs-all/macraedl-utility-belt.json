from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import glob [EOL] [EOL] [EOL] def append_files_from_path ( path ) : [EOL] [docstring] [EOL] paths = glob . glob ( path + [string] ) [EOL] text = [string] [EOL] for path in paths : [EOL] with open ( path , [string] ) as f : [EOL] read_text = f . read ( ) [EOL] text += read_text [EOL] return text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import argparse [EOL] import argparse [EOL] import sys [EOL] [EOL] from fastai . vision import ImageDataBunch , cnn_learner [EOL] [EOL] [EOL] def train_model ( hyperparams ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] path = hyperparams [ [string] ] [EOL] train = hyperparams [ [string] ] [EOL] valid_pct = hyperparams [ [string] ] [EOL] size = hyperparams [ [string] ] [EOL] num_workers = hyperparams [ [string] ] [EOL] [EOL] [comment] [EOL] data = ImageDataBunch . from_folder ( path = path , train = train , valid_pct = valid_pct , ds_tfms = get_transforms ( ) , size = size , num_workers = num_workers , ) . normalize ( imagenet_stats ) [EOL] [EOL] [comment] [EOL] learn = cnn_learner ( data , models . resnet34 , metrics = error_rate ) [EOL] [EOL] [comment] [EOL] learn . fit_one_cycle ( [number] ) [EOL] [EOL] return learn [EOL] [EOL] [EOL] def main ( main_args ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , required = False , default = False , help = [string] , ) [EOL] [EOL] [comment] [EOL] args = parser . parse_args ( main_args ) [EOL] hyperparams = { i : args . __getattribute__ ( i ) for i in args . __dir__ ( ) if i [ [number] ] != [string] } [EOL] [EOL] [comment] [EOL] learn = train_model ( hyperparams ) [EOL] [EOL] [comment] [EOL] learn . save ( args . save_to ) [EOL] [EOL] if args . overwrite : [EOL] learn . save ( args . save_to ) [comment] [EOL] else : [EOL] learn . save ( args . save_to ) [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import byhand [EOL] import random [EOL] import math [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class NeuralNetwork : [EOL] LEARNING_RATE = [number] [EOL] [EOL] def __init__ ( self , num_inputs , num_hidden , num_outputs , hidden_layer_weights = None , hidden_layer_bias = None , output_layer_weights = None , output_layer_bias = None ) : [EOL] self . num_inputs = num_inputs [EOL] [EOL] self . hidden_layer = NeuronLayer ( num_hidden , hidden_layer_bias ) [EOL] self . output_layer = NeuronLayer ( num_outputs , output_layer_bias ) [EOL] [EOL] self . init_weights_from_inputs_to_hidden_layer_neurons ( hidden_layer_weights ) [EOL] self . init_weights_from_hidden_layer_neurons_to_output_layer_neurons ( output_layer_weights ) [EOL] [EOL] def init_weights_from_inputs_to_hidden_layer_neurons ( self , hidden_layer_weights ) : [EOL] weight_num = [number] [EOL] for h in range ( len ( self . hidden_layer . neurons ) ) : [EOL] for i in range ( self . num_inputs ) : [EOL] if not hidden_layer_weights : [EOL] self . hidden_layer . neurons [ h ] . weights . append ( random . random ( ) ) [EOL] else : [EOL] self . hidden_layer . neurons [ h ] . weights . append ( hidden_layer_weights [ weight_num ] ) [EOL] weight_num += [number] [EOL] [EOL] def init_weights_from_hidden_layer_neurons_to_output_layer_neurons ( self , output_layer_weights ) : [EOL] weight_num = [number] [EOL] for o in range ( len ( self . output_layer . neurons ) ) : [EOL] for h in range ( len ( self . hidden_layer . neurons ) ) : [EOL] if not output_layer_weights : [EOL] self . output_layer . neurons [ o ] . weights . append ( random . random ( ) ) [EOL] else : [EOL] self . output_layer . neurons [ o ] . weights . append ( output_layer_weights [ weight_num ] ) [EOL] weight_num += [number] [EOL] [EOL] def inspect ( self ) : [EOL] print ( [string] ) [EOL] print ( [string] . format ( self . num_inputs ) ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] self . hidden_layer . inspect ( ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] self . output_layer . inspect ( ) [EOL] print ( [string] ) [EOL] [EOL] def feed_forward ( self , inputs ) : [EOL] hidden_layer_outputs = self . hidden_layer . feed_forward ( inputs ) [EOL] return self . output_layer . feed_forward ( hidden_layer_outputs ) [EOL] [EOL] [comment] [EOL] def train ( self , training_inputs , training_outputs ) : [EOL] self . feed_forward ( training_inputs ) [EOL] [EOL] [comment] [EOL] pd_errors_wrt_output_neuron_total_net_input = [ [number] ] * len ( self . output_layer . neurons ) [EOL] for o in range ( len ( self . output_layer . neurons ) ) : [EOL] [EOL] [comment] [EOL] pd_errors_wrt_output_neuron_total_net_input [ o ] = self . output_layer . neurons [ o ] . calculate_pd_error_wrt_total_net_input ( training_outputs [ o ] ) [EOL] [EOL] [comment] [EOL] pd_errors_wrt_hidden_neuron_total_net_input = [ [number] ] * len ( self . hidden_layer . neurons ) [EOL] for h in range ( len ( self . hidden_layer . neurons ) ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] d_error_wrt_hidden_neuron_output = [number] [EOL] for o in range ( len ( self . output_layer . neurons ) ) : [EOL] d_error_wrt_hidden_neuron_output += pd_errors_wrt_output_neuron_total_net_input [ o ] * self . output_layer . neurons [ o ] . weights [ h ] [EOL] [EOL] [comment] [EOL] pd_errors_wrt_hidden_neuron_total_net_input [ h ] = d_error_wrt_hidden_neuron_output * self . hidden_layer . neurons [ h ] . calculate_pd_total_net_input_wrt_input ( ) [EOL] [EOL] [comment] [EOL] for o in range ( len ( self . output_layer . neurons ) ) : [EOL] for w_ho in range ( len ( self . output_layer . neurons [ o ] . weights ) ) : [EOL] [EOL] [comment] [EOL] pd_error_wrt_weight = pd_errors_wrt_output_neuron_total_net_input [ o ] * self . output_layer . neurons [ o ] . calculate_pd_total_net_input_wrt_weight ( w_ho ) [EOL] [EOL] [comment] [EOL] self . output_layer . neurons [ o ] . weights [ w_ho ] -= self . LEARNING_RATE * pd_error_wrt_weight [EOL] [EOL] [comment] [EOL] for h in range ( len ( self . hidden_layer . neurons ) ) : [EOL] for w_ih in range ( len ( self . hidden_layer . neurons [ h ] . weights ) ) : [EOL] [EOL] [comment] [EOL] pd_error_wrt_weight = pd_errors_wrt_hidden_neuron_total_net_input [ h ] * self . hidden_layer . neurons [ h ] . calculate_pd_total_net_input_wrt_weight ( w_ih ) [EOL] [EOL] [comment] [EOL] self . hidden_layer . neurons [ h ] . weights [ w_ih ] -= self . LEARNING_RATE * pd_error_wrt_weight [EOL] [EOL] def calculate_total_error ( self , training_sets ) : [EOL] total_error = [number] [EOL] for t in range ( len ( training_sets ) ) : [EOL] training_inputs , training_outputs = training_sets [ t ] [EOL] self . feed_forward ( training_inputs ) [EOL] for o in range ( len ( training_outputs ) ) : [EOL] total_error += self . output_layer . neurons [ o ] . calculate_error ( training_outputs [ o ] ) [EOL] return total_error [EOL] [EOL] class NeuronLayer : [EOL] def __init__ ( self , num_neurons , bias ) : [EOL] [EOL] [comment] [EOL] self . bias = bias if bias else random . random ( ) [EOL] [EOL] self . neurons = [ ] [EOL] for i in range ( num_neurons ) : [EOL] self . neurons . append ( Neuron ( self . bias ) ) [EOL] [EOL] def inspect ( self ) : [EOL] print ( [string] , len ( self . neurons ) ) [EOL] for n in range ( len ( self . neurons ) ) : [EOL] print ( [string] , n ) [EOL] for w in range ( len ( self . neurons [ n ] . weights ) ) : [EOL] print ( [string] , self . neurons [ n ] . weights [ w ] ) [EOL] print ( [string] , self . bias ) [EOL] [EOL] def feed_forward ( self , inputs ) : [EOL] outputs = [ ] [EOL] for neuron in self . neurons : [EOL] outputs . append ( neuron . calculate_output ( inputs ) ) [EOL] return outputs [EOL] [EOL] def get_outputs ( self ) : [EOL] outputs = [ ] [EOL] for neuron in self . neurons : [EOL] outputs . append ( neuron . output ) [EOL] return outputs [EOL] [EOL] class Neuron : [EOL] def __init__ ( self , bias ) : [EOL] self . bias = bias [EOL] self . weights = [ ] [EOL] [EOL] def calculate_output ( self , inputs ) : [EOL] self . inputs = inputs [EOL] self . output = self . squash ( self . calculate_total_net_input ( ) ) [EOL] return self . output [EOL] [EOL] def calculate_total_net_input ( self ) : [EOL] total = [number] [EOL] for i in range ( len ( self . inputs ) ) : [EOL] total += self . inputs [ i ] * self . weights [ i ] [EOL] return total + self . bias [EOL] [EOL] [comment] [EOL] [comment] [EOL] def squash ( self , total_net_input ) : [EOL] return [number] / ( [number] + math . exp ( - total_net_input ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def calculate_pd_error_wrt_total_net_input ( self , target_output ) : [EOL] return self . calculate_pd_error_wrt_output ( target_output ) * self . calculate_pd_total_net_input_wrt_input ( ) ; [EOL] [EOL] [comment] [EOL] def calculate_error ( self , target_output ) : [EOL] return [number] * ( target_output - self . output ) ** [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def calculate_pd_error_wrt_output ( self , target_output ) : [EOL] return - ( target_output - self . output ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def calculate_pd_total_net_input_wrt_input ( self ) : [EOL] return self . output * ( [number] - self . output ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def calculate_pd_total_net_input_wrt_weight ( self , index ) : [EOL] return self . inputs [ index ] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] nn = NeuralNetwork ( [number] , [number] , [number] , hidden_layer_weights = [ [number] , [number] , [number] , [number] ] , hidden_layer_bias = [number] , output_layer_weights = [ [number] , [number] , [number] , [number] ] , output_layer_bias = [number] ) [EOL] for i in range ( [number] ) : [EOL] nn . train ( [ [number] , [number] ] , [ [number] , [number] ] ) [EOL] print ( i , round ( nn . calculate_total_error ( [ [ [ [number] , [number] ] , [ [number] , [number] ] ] ] ) , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $byhand.nn.NeuronLayer$ 0 0 0 0 0 0 0 0 0 0 $byhand.nn.NeuronLayer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $byhand.nn.NeuralNetwork$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $byhand.nn.NeuralNetwork$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $byhand.nn.NeuralNetwork$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0