from setuptools import setup , find_packages [EOL] [EOL] setup ( name = [string] , version = [string] , license = [string] , author = [string] , author_email = [string] , packages = find_packages ( ) , include_package_data = True , entry_points = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Any , List [EOL] import typing [EOL] import xdrlib [EOL] [EOL] import enum [EOL] [EOL] NVAREA = [number] << [number] [EOL] [EOL] [EOL] class NVTypes ( enum . IntEnum ) : [EOL] UNKNOWN = [number] [EOL] BOOLEAN = [number] [EOL] BYTE = [number] [EOL] INT16 = [number] [EOL] UINT16 = [number] [EOL] INT32 = [number] [EOL] UINT32 = [number] [EOL] INT64 = [number] [EOL] UINT64 = [number] [EOL] STRING = [number] [EOL] BYTE_ARRAY = [number] [EOL] INT16_ARRAY = [number] [EOL] UINT16_ARRAY = [number] [EOL] INT32_ARRAY = [number] [EOL] UINT32_ARRAY = [number] [EOL] INT64_ARRAY = [number] [EOL] UINT64_ARRAY = [number] [EOL] STRING_ARRAY = [number] [EOL] HRTIME = [number] [EOL] NVLIST = [number] [EOL] NVLIST_ARRAY = [number] [EOL] BOOLEAN_VALUE = [number] [EOL] INT8 = [number] [EOL] UINT8 = [number] [EOL] BOOLEAN_ARRAY = [number] [EOL] INT8_ARRAY = [number] [EOL] [EOL] [EOL] class NVList ( xdrlib . Unpacker ) : [EOL] def unpack_nvlist ( self ) : [EOL] if self . unpack_uint ( ) != [number] : [EOL] self . set_position ( self . get_position ( ) - [number] ) [EOL] if self . unpack_uhyper ( ) != [number] : [EOL] raise Exception ( [string] ) [EOL] values = { } [EOL] while len ( self . get_buffer ( ) ) - self . get_position ( ) >= [number] : [EOL] name , v = self . unpack_value ( ) [EOL] if name : [EOL] values [ name ] = v [EOL] else : [EOL] return values [EOL] [EOL] def unpack_value ( self ) : [EOL] name , v = None , None [EOL] decoded_length = self . unpack_uint ( ) [EOL] l = self . unpack_uint ( ) [EOL] [EOL] if decoded_length > [number] : [EOL] name = self . unpack_string ( ) [EOL] value_type = self . unpack_uint ( ) [EOL] value_count = self . unpack_uint ( ) [EOL] if value_type == NVTypes . UINT64 : [EOL] v = self . unpack_uhyper ( ) [EOL] elif value_type == NVTypes . STRING : [EOL] v = self . unpack_string ( ) [EOL] elif value_type == NVTypes . BOOLEAN : [EOL] v = True [EOL] elif value_type == NVTypes . NVLIST : [EOL] v = self . unpack_nvlist ( ) [EOL] elif value_type == NVTypes . NVLIST_ARRAY : [EOL] v = [ ] [EOL] for x in range ( value_count ) : [EOL] sub = self . unpack_nvlist ( ) [EOL] v . append ( sub ) [EOL] else : [EOL] raise Exception ( [string] . format ( value_type , name ) ) [EOL] return name , v [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 $typing.List[typing.Any]$ 0
from typing import ByteString [EOL] import builtins [EOL] import typing [EOL] from typing import ByteString [EOL] [EOL] [EOL] def decompress ( bs , size ) : [EOL] bs = bytearray ( bs ) [EOL] out = bytearray ( ) [EOL] blen = len ( bs ) [EOL] pos = [number] [EOL] while pos < blen and len ( out ) < size : [EOL] control = bs [ pos ] [EOL] pos += [number] [EOL] for i in range ( [number] ) : [EOL] b = control & ( [number] << i ) > [number] [EOL] if not pos < blen : [EOL] break [EOL] if not b : [EOL] out . append ( bs [ pos ] ) [EOL] pos += [number] [EOL] else : [EOL] length = ( bs [ pos ] >> [number] ) + [number] [EOL] distance = ( bs [ pos ] & [number] ) << [number] | bs [ pos + [number] ] [EOL] pos += [number] [EOL] backref = out [ - distance : ] [EOL] lookup = backref * int ( length / distance ) + backref [ : ( length % distance ) ] [EOL] out += lookup [EOL] return out [ : size ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ByteString$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . import vdevs [EOL] [EOL] [EOL] class FileDev ( vdevs . VDev ) : [EOL] def __init__ ( self , path , label = None , txg = None ) : [EOL] self . f = open ( path , [string] ) [EOL] super ( FileDev , self ) . __init__ ( label , txg ) [EOL] [EOL] def read ( self , offset , size ) : [EOL] self . seek ( * offset ) [EOL] return self . f . read ( size ) [EOL] [EOL] def write ( self , offset , data ) : [EOL] self . seek ( * offset ) [EOL] return self . f . write ( data ) [EOL] [EOL] def flush ( self ) : [EOL] return self . f . flush ( ) [EOL] [EOL] def seek ( self , offset , whence ) : [EOL] return self . f . seek ( offset , whence ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Tuple , Any , List [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] import struct [EOL] import itertools [EOL] import logging [EOL] import operator [EOL] import struct [EOL] from typing import Union , Tuple [EOL] [EOL] from zfs import ondisk , vdevs [EOL] from functools import reduce [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def convert ( k , base , disks , parity ) : [EOL] off = ( disks + parity + [number] ) / base [EOL] k -= base [EOL] if k >= [number] : [EOL] off -= [number] [EOL] return ( k + off ) % disks [EOL] [EOL] [EOL] def should_resize ( offset , size , disks , parity ) : [EOL] base = ( size % [number] ) [EOL] if size >= [number] and base in ( [number] , [number] ) : [EOL] return convert ( size , base , disks , parity ) == offset % disks [EOL] else : [EOL] return False [EOL] [EOL] [EOL] [comment] [EOL] def locate_data ( disks , parity , offset , size ) : [EOL] first_col = parity [EOL] ret = [ disks , first_col ] [EOL] vdevs = [ ] [EOL] bit_12 = ( offset >> [number] ) & [number] [EOL] vdev_ids = list ( range ( disks ) ) [EOL] order = list ( range ( disks ) ) [EOL] if bit_12 : [EOL] order [ [number] : [number] ] = reversed ( order [ [number] : [number] ] ) [EOL] for i in order : [EOL] dva = ondisk . dva ( ) [EOL] dva . vdev = vdev_ids [ ( offset + i ) % disks ] [EOL] dva . offset = int ( ( offset + i ) / disks ) [EOL] vdevs . append ( dva ) [EOL] vdev_order = [ d . vdev for d in vdevs ] [EOL] if size > [number] : [EOL] logger . debug ( [string] * [number] , size ) [EOL] if disks == [number] and should_resize ( offset , size , disks , parity ) : [EOL] logger . debug ( [string] . format ( offset % disks , offset , size , list ( map ( int , vdev_order ) ) , size , bit_12 ) ) [EOL] size -= [number] [EOL] for _ , next_vdev in zip ( range ( size ) , itertools . cycle ( vdevs ) ) : [EOL] next_vdev . asize += [number] [EOL] ret . append ( tuple ( vdevs ) ) [EOL] return ret [EOL] [EOL] [EOL] def xor_blocks ( * args ) : [EOL] args = [ x for x in args if len ( x ) ] [EOL] if len ( args ) == [number] : [EOL] return [string] [EOL] size = min ( len ( x ) for x in args ) [EOL] args = [ x [ : size ] for x in args ] [EOL] format_str = [string] [EOL] if size >= [number] : [EOL] format_str += [string] . format ( int ( size / [number] ) ) [EOL] if size % [number] : [EOL] format_str += [string] . format ( size % [number] ) [EOL] structure = struct . Struct ( format_str ) [EOL] out = [ reduce ( operator . xor , t ) for t in zip ( * ( structure . unpack ( x ) for x in args ) ) ] [EOL] return structure . pack ( * out ) [EOL] [EOL] [EOL] class RaidZDev ( vdevs . VDev ) : [EOL] def __init__ ( self , parity , devs ) : [EOL] self . devs = devs [EOL] self . parity = parity [EOL] self . label = devs [ [number] ] . label [EOL] self . best_label = devs [ [number] ] . best_label [EOL] self . id = self . label [ [string] ] [ [string] ] [EOL] self . active_uberblock = devs [ [number] ] . active_uberblock [EOL] [EOL] def _read_resolved ( self , dva ) : [EOL] return self . devs [ dva . vdev ] . read_dva ( dva ) [EOL] [EOL] def read_dva ( self , dva ) : [EOL] offset = dva . offset [EOL] num_disks = len ( self . devs ) [EOL] parity = self . parity [EOL] columns , first , addrs = locate_data ( num_disks , parity , offset , dva . asize ) [EOL] if columns == num_disks : [EOL] blocks = [ self . _read_resolved ( addr ) for addr in addrs ] [EOL] data = [string] . join ( blocks [ first : ] ) [EOL] else : [EOL] raise Exception ( [string] . format ( addrs ) ) [EOL] computed = xor_blocks ( * blocks [ first : ] ) [EOL] self . blocks = blocks [ : ] + [ computed ] [EOL] self . last_dva = dva , addrs [EOL] return data [EOL] [EOL] def read ( self , offset , size ) : [EOL] raise Exception [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.Union[builtins.int,typing.Tuple[builtins.int,builtins.int]]$ 0 $builtins.int$ 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import logging [EOL] import ondisk [EOL] import constants [EOL] import builtins [EOL] import typing [EOL] import codecs [EOL] import logging [EOL] [EOL] from typing import Tuple [EOL] [EOL] from . import ondisk [EOL] from . import util [EOL] [EOL] from . constants import Compression , Checksum , TryConfig [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ReadContext ( object ) : [EOL] def __init__ ( self , vdevs , compression , checksum , ashift , try_config ) : [EOL] self . vdevs = vdevs [EOL] self . default_compression = compression [EOL] self . default_checksum = checksum [EOL] self . blocksize = [number] << ashift [EOL] self . try_config = try_config [EOL] [EOL] def checksum ( self , data , valid , checksum ) : [EOL] return util . checksum ( data , valid , checksum , self . default_checksum ) [EOL] [EOL] def decompress ( self , data , compression , actual_size ) : [EOL] return util . decompress ( data , compression , actual_size , self . default_compression ) [EOL] [EOL] def update_inherit ( self , compression , checksum ) : [EOL] if compression != Compression . INHERIT : [EOL] self . default_compression = compression [EOL] if checksum != Checksum . INHERIT : [EOL] self . default_checksum = checksum [EOL] [EOL] def read_block ( self , blkptr , dva_offset = [number] ) : [EOL] if TryConfig . read_all_dvas in self . try_config : [EOL] block = self . read_block_thorough ( blkptr ) [EOL] return block [EOL] elif blkptr . embedded : [EOL] block = self . _read_block_embedded ( blkptr ) [EOL] return block [EOL] else : [EOL] block , valid = self . _read_block ( blkptr , blkptr . dvas [ dva_offset ] ) [EOL] if not valid : [EOL] logger . error ( [string] . format ( blkptr ) ) [EOL] return block [EOL] [EOL] def read_block_thorough ( self , blkptr ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if blkptr . embedded : [EOL] return self . _read_block_embedded ( blkptr ) [EOL] if all ( dva . asize == [number] for dva in blkptr . dvas ) : [EOL] logger . debug ( [string] . format ( blkptr ) ) [EOL] return [string] [EOL] first_log = True [EOL] blocks = [ ] [EOL] bad = [ ] [EOL] for dva in blkptr . dvas : [EOL] if dva . asize != [number] : [EOL] try : [EOL] block , valid = self . _read_block ( blkptr , dva ) [EOL] if valid : [EOL] blocks . append ( block ) [EOL] else : [EOL] logger . error ( [string] ) [EOL] bad . append ( block ) [EOL] except Exception : [EOL] if first_log : [EOL] logger . info ( [string] . format ( blkptr ) ) [EOL] first_log = False [EOL] logger . exception ( [string] . format ( dva ) ) [EOL] pass [EOL] if len ( blocks ) == [number] : [EOL] return blocks [ [number] ] [EOL] elif len ( blocks ) > [number] : [EOL] if not all ( x == y for x , y in zip ( blocks , blocks [ [number] : ] ) ) : [EOL] logger . error ( [string] . format ( blkptr ) ) [EOL] logger . info ( [string] . format ( list ( map ( len , blocks ) ) ) ) [EOL] logger . debug ( [string] . format ( [ codecs . encode ( b , [string] ) for b in blocks ] ) ) [EOL] return blocks [ [number] ] [EOL] else : [comment] [EOL] logger . error ( [string] . format ( blkptr ) ) [EOL] return [string] [EOL] [EOL] def _read_block_embedded ( self , blkptr ) : [EOL] embedded_blkptr = blkptr . to_embedded ( ) [EOL] raw_data = embedded_blkptr . data [EOL] data = self . decompress ( raw_data , embedded_blkptr . compression , embedded_blkptr . logical_size + [number] ) [EOL] return data [EOL] [EOL] def _read_block ( self , blkptr , dva ) : [EOL] vdev = self . vdevs [ dva . vdev ] [EOL] data = vdev . read_dva ( dva ) [EOL] physical_size = ( blkptr . physical_size + [number] ) * [number] [EOL] data = data [ : physical_size ] [EOL] valid_chk = self . checksum ( data , blkptr . checksum , blkptr . checksum_type ) [EOL] logical_size = ( blkptr . logical_size + [number] ) * [number] [EOL] if valid_chk : [EOL] logger . debug ( [string] . format ( blkptr , physical_size , logical_size ) ) [EOL] data = self . decompress ( data , blkptr . compression , logical_size ) [EOL] return data , valid_chk [EOL] [EOL] def read_indirect ( self , blkptr ) : [EOL] resolved = [ ] [EOL] if blkptr . level > [number] : [EOL] data = self . read_block ( blkptr ) [EOL] indirect = ondisk . indirect ( size = blkptr . logical_size + [number] ) [EOL] ind = indirect ( data ) [EOL] for ptr in ind . blocks : [EOL] resolved . append ( self . read_indirect ( ptr ) ) [EOL] else : [EOL] return self . read_block ( blkptr ) [EOL] return [string] . join ( resolved ) [EOL] [EOL] def read_dnode ( self , dnode ) : [EOL] return [string] . join ( self . read_indirect ( bp ) for bp in dnode . blkptr ) [EOL] [EOL] def context ( self ) : [EOL] return ReadContext ( self . vdevs , self . default_compression , self . checksum , self . blocksize , self . try_config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $constants.Compression$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $constants.Compression$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $constants.Compression$ 0 $constants.Checksum$ 0 0 0 0 $constants.Compression$ 0 0 0 0 0 0 0 0 0 0 $constants.Compression$ 0 0 $constants.Checksum$ 0 0 0 0 0 0 0 0 0 0 $constants.Checksum$ 0 0 0 $builtins.bytes$ 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $ondisk.Blockptr$ 0 0 0 $typing.Any$ 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Tuple[builtins.bytes,builtins.bool]$ 0 0 0 $ondisk.Blockptr$ 0 $ondisk.dva$ 0 0 0 $typing.Any$ 0 0 0 0 0 $ondisk.dva$ 0 $typing.Any$ 0 0 $builtins.bytes$ 0 $typing.Any$ 0 0 0 $ondisk.dva$ 0 0 $typing.Any$ 0 0 $ondisk.Blockptr$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bytes$ 0 $ondisk.Blockptr$ 0 0 0 $ondisk.Blockptr$ 0 0 0 0 $typing.Any$ 0 0 $ondisk.Blockptr$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $ondisk.Blockptr$ 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 $builtins.bool$ 0 0 0 $builtins.bytes$ 0 0 0 $ondisk.Blockptr$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $ondisk.Blockptr$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.Blockptr$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.bytes$ 0 0 0 $ondisk.DNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ondisk.DNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import enum [EOL] [EOL] POOL_VERSION = [number] [EOL] [EOL] [EOL] class Compression ( enum . IntEnum ) : [EOL] INHERIT = [number] [EOL] ON = [number] [EOL] OFF = [number] [EOL] LZJB = [number] [EOL] EMPTY = [number] [EOL] GZIP_1 = [number] [EOL] GZIP_2 = [number] [EOL] GZIP_3 = [number] [EOL] GZIP_4 = [number] [EOL] GZIP_5 = [number] [EOL] GZIP_6 = [number] [EOL] GZIP_7 = [number] [EOL] GZIP_8 = [number] [EOL] GZIP_9 = [number] [EOL] ZLE = [number] [EOL] LZ4 = [number] [EOL] [EOL] [EOL] class Checksum ( enum . IntEnum ) : [EOL] INHERIT = [number] [EOL] ON = [number] [EOL] OFF = [number] [EOL] LABEL = [number] [EOL] GANG_HEADER = [number] [EOL] ZILOG = [number] [EOL] FLETCHER_2 = [number] [EOL] FLETCHER_4 = [number] [EOL] SHA256 = [number] [EOL] ZILOG2 = [number] [EOL] NOPARITY = [number] [EOL] [EOL] [EOL] class ObjectSetType ( enum . IntEnum ) : [EOL] NONE = [number] [EOL] META = [number] [EOL] ZFS = [number] [EOL] ZVOL = [number] [EOL] [EOL] [EOL] class TryConfig ( enum . Enum ) : [EOL] read_all_dvas = True [EOL] [EOL] [EOL] class ObjectType ( enum . IntEnum ) : [EOL] NONE = [number] [EOL] OBJECT_DIRECTORY = [number] [comment] [EOL] OBJECT_ARRAY = [number] [comment] [EOL] PACKED_NVLIST = [number] [comment] [EOL] PACKED_NVLIST_SIZE = [number] [comment] [EOL] BPOBJ = [number] [comment] [EOL] BPOBJ_HDR = [number] [comment] [EOL] SPACE_MAP_HEADER = [number] [comment] [EOL] SPACE_MAP = [number] [comment] [EOL] INTENT_LOG = [number] [comment] [EOL] DNODE = [number] [comment] [EOL] OBJSET = [number] [comment] [EOL] DSL_DIR = [number] [comment] [EOL] DSL_DIR_CHILD_MAP = [number] [comment] [EOL] DSL_DS_SNAP_MAP = [number] [comment] [EOL] DSL_PROPS = [number] [comment] [EOL] DSL_DATASET = [number] [comment] [EOL] ZNODE = [number] [comment] [EOL] OLDACL = [number] [comment] [EOL] PLAIN_FILE_CONTENTS = [number] [comment] [EOL] DIRECTORY_CONTENTS = [number] [comment] [EOL] MASTER_NODE = [number] [comment] [EOL] UNLINKED_SET = [number] [comment] [EOL] ZVOL = [number] [comment] [EOL] ZVOL_PROP = [number] [comment] [EOL] PLAIN_OTHER = [number] [comment] [EOL] UINT64_OTHER = [number] [comment] [EOL] ZAP_OTHER = [number] [comment] [EOL] ERROR_LOG = [number] [comment] [EOL] SPA_HISTORY = [number] [comment] [EOL] SPA_HISTORY_OFFSETS = [number] [comment] [EOL] POOL_PROPS = [number] [comment] [EOL] DSL_PERMS = [number] [comment] [EOL] ACL = [number] [comment] [EOL] SYSACL = [number] [comment] [EOL] FUID = [number] [comment] [EOL] FUID_SIZE = [number] [comment] [EOL] NEXT_CLONES = [number] [comment] [EOL] SCAN_QUEUE = [number] [comment] [EOL] USERGROUP_USED = [number] [comment] [EOL] USERGROUP_QUOTA = [number] [comment] [EOL] USERREFS = [number] [comment] [EOL] DDT_ZAP = [number] [comment] [EOL] DDT_STATS = [number] [comment] [EOL] SA = [number] [comment] [EOL] SA_MASTER_NODE = [number] [comment] [EOL] SA_ATTR_REGISTRATION = [number] [comment] [EOL] SA_ATTR_LAYOUTS = [number] [comment] [EOL] SCAN_XLATE = [number] [comment] [EOL] DEDUP = [number] [comment] [EOL] DEADLIST = [number] [comment] [EOL] DEADLIST_HDR = [number] [comment] [EOL] DSL_CLONES = [number] [comment] [EOL] BPOBJ_SUBOBJ = [number] [comment] [EOL] FEATURE_DESCRIPTION = [number] [comment] [EOL] [EOL] [EOL] class ZILTypes ( enum . IntEnum ) : [EOL] CREATE = [number] [comment] [EOL] MKDIR = [number] [comment] [EOL] MKXATTR = [number] [comment] [EOL] SYMLINK = [number] [comment] [EOL] REMOVE = [number] [comment] [EOL] RMDIR = [number] [comment] [EOL] LINK = [number] [comment] [EOL] RENAME = [number] [comment] [EOL] WRITE = [number] [comment] [EOL] TRUNCATE = [number] [comment] [EOL] SETATTR = [number] [comment] [EOL] ACL = [number] [comment] [EOL] [EOL] [EOL] class ZapType ( enum . Enum ) : [EOL] ZAPHeader = ( [number] << [number] ) + [number] [EOL] ZAPLeaf = [number] << [number] [EOL] MicroZAP = ( [number] << [number] ) + [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Type , Union , List [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] import zfs [EOL] import logging [EOL] import os [EOL] [EOL] from typing import Dict [EOL] from typing import Tuple [EOL] from typing import Union [EOL] from typing import List [EOL] [EOL] import nvlist [EOL] from zfs import ondisk [EOL] [EOL] LABEL_PAD = [number] [EOL] UBER_AREA = [number] * [number] [comment] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class VDev ( object ) : [EOL] LABELS = ( ( [number] , os . SEEK_SET ) , ( [number] , os . SEEK_SET ) , ( - [number] , os . SEEK_END ) , ( - [number] , os . SEEK_END ) , ) [EOL] [EOL] def __init__ ( self , label_index = None , txg = None ) : [EOL] self . labels = [ self . read_label ( l ) for l in self . LABELS ] [EOL] self . label = self . best_label = self . _best_label ( label_index ) [EOL] self . id = self . label [ [string] ] [ [string] ] [EOL] self . raw_uberblocks = [ u for _ , ubers in self . labels for u in ubers ] [EOL] self . uberblocks = self . parse_uberblocks ( self . raw_uberblocks ) [EOL] self . active_uberblock = self . select_uberblock ( txg ) [EOL] [EOL] def parse_uberblocks ( self , raw_uberblocks ) : [EOL] uber_list = list ( filter ( ondisk . Uberblock . valid , raw_uberblocks ) ) [EOL] uber_list . sort ( key = lambda x : x . txg , reverse = True ) [EOL] return uber_list [EOL] [EOL] def select_uberblock ( self , txg ) : [EOL] txgs_available = sorted ( list ( set ( x . txg for x in self . uberblocks ) ) ) [EOL] if txg in txgs_available : [EOL] logger . info ( [string] . format ( txgs_available ) ) [EOL] candidates = [ x for x in self . uberblocks if x . txg == txg ] [EOL] active_uberblock = candidates [ [number] ] [EOL] else : [EOL] if txg : [EOL] logger . error ( [string] . format ( txg , self ) ) [EOL] logger . info ( [string] . format ( txgs_available ) ) [EOL] active_uberblock = self . uberblocks [ [number] ] [EOL] return active_uberblock [EOL] [EOL] def _best_label ( self , label_index = None ) : [EOL] retprops = { [string] : [number] } [EOL] for label in self . labels : [EOL] props = label [ [number] ] [EOL] if props [ [string] ] > retprops [ [string] ] : [EOL] retprops = props [EOL] if label_index : [EOL] best_label = self . labels [ label_index ] [EOL] else : [EOL] best_label = retprops [EOL] return best_label [EOL] [EOL] def read_label ( self , label ) : [EOL] try : [EOL] data = self . read ( label , [number] ) [EOL] [comment] [EOL] data = data [ LABEL_PAD : ] [EOL] [comment] [EOL] nvdata = data [ : nvlist . NVAREA ] [EOL] data = data [ nvlist . NVAREA : ] [EOL] [comment] [EOL] properties = nvlist . NVList ( nvdata ) . unpack_nvlist ( ) [EOL] [comment] [EOL] uberblock_array = data [ : UBER_AREA ] [EOL] uberblocks = [ ] [EOL] for elem in range ( [number] ) : [EOL] elem *= [number] [EOL] this_block = uberblock_array [ elem : elem + [number] ] [EOL] b = ondisk . Uberblock ( this_block ) [EOL] [comment] [EOL] b . unpack ( this_block ) [EOL] uberblocks . append ( b ) [EOL] except Exception : [EOL] raise [EOL] return properties , uberblocks [EOL] [EOL] def read_dva ( self , dva ) : [EOL] offset = ( dva . offset * [number] ) + [number] [EOL] data = self . read ( ( offset , [number] ) , dva . asize * [number] ) [EOL] return data [EOL] [EOL] def read ( self , offset , size ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[zfs.ondisk.Uberblock]$ 0 0 0 $typing.List[zfs.ondisk.Uberblock]$ 0 0 0 $typing.List[zfs.ondisk.Uberblock]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[zfs.ondisk.Uberblock]$ 0 0 0 $typing.List[zfs.ondisk.Uberblock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[zfs.ondisk.Uberblock]$ 0 0 0 $zfs.ondisk.Uberblock$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bytes$ 0 0 0 $zfs.ondisk.dva$ 0 0 0 $typing.Any$ 0 0 $zfs.ondisk.dva$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $zfs.ondisk.dva$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.Union[builtins.int,typing.Tuple[builtins.int,builtins.int]]$ 0 $builtins.int$ 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import nvlist [EOL] import logging [EOL] import io [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import struct [EOL] [EOL] from io import BytesIO [EOL] [EOL] from typing import Union [EOL] [EOL] from nvlist import NVTypes [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def next_break_offset ( x ) : [EOL] [comment] [EOL] return ( x + [number] ) & ~ [number] [EOL] [EOL] [EOL] class HistoryParser ( object ) : [EOL] def __init__ ( self , buffer ) : [EOL] if isinstance ( buffer , bytes ) : [EOL] self . buf = BytesIO ( buffer ) [EOL] else : [EOL] self . buf = buffer [EOL] [EOL] def unpack_int ( self ) : [EOL] return struct . unpack ( [string] , self . buf . read ( [number] ) ) [ [number] ] [EOL] [EOL] def unpack_uint ( self ) : [EOL] return struct . unpack ( [string] , self . buf . read ( [number] ) ) [ [number] ] [EOL] [EOL] def unpack_hyper ( self ) : [EOL] return struct . unpack ( [string] , self . buf . read ( [number] ) ) [ [number] ] [EOL] [EOL] def unpack_uhyper ( self ) : [EOL] return struct . unpack ( [string] , self . buf . read ( [number] ) ) [ [number] ] [EOL] [EOL] def unpack_fstring ( self , length ) : [EOL] total_length = next_break_offset ( length ) [EOL] return self . buf . read ( total_length ) [ : length ] [EOL] [EOL] def unpack_string ( self ) : [EOL] length = self . unpack_uint ( ) [EOL] return self . unpack_fstring ( length ) [EOL] [EOL] def unpack_value ( self ) : [EOL] pos = self . buf . tell ( ) [EOL] total_length = self . unpack_uint ( ) [EOL] if total_length == [number] : [EOL] return [string] , [string] [EOL] length = self . unpack_uint ( ) [EOL] value_count = self . unpack_uint ( ) [EOL] value_type = NVTypes ( self . unpack_uint ( ) ) [EOL] key = self . unpack_fstring ( length ) [EOL] key = key . rstrip ( [string] ) [EOL] [EOL] remaining = total_length - ( self . buf . tell ( ) - pos ) [EOL] [EOL] values = [ ] [EOL] for v in range ( value_count ) : [EOL] if value_type == NVTypes . UINT64 : [EOL] value = self . unpack_uhyper ( ) [EOL] elif value_type == NVTypes . INT32 : [EOL] value = self . unpack_uhyper ( ) [EOL] elif value_type == NVTypes . STRING : [EOL] value = self . buf . read ( remaining ) [EOL] value = value . rstrip ( [string] ) [EOL] elif value_type == NVTypes . NVLIST : [EOL] [comment] [EOL] value = self . unpack_nvlist ( extra = True ) [EOL] elif value_type == NVTypes . BOOLEAN : [EOL] value = self . unpack_uhyper ( ) [EOL] else : [EOL] logger . debug ( [string] , value_type , value_count , remaining ) [EOL] value = self . buf . read ( remaining ) [EOL] values . append ( value ) [EOL] remaining = total_length - ( self . buf . tell ( ) - pos ) [EOL] if remaining > [number] : [EOL] logger . debug ( [string] , remaining , value_count , value_type ) [EOL] values . append ( self . buf . read ( remaining ) ) [EOL] if len ( values ) == [number] : [EOL] values = values [ [number] ] [EOL] return key , values [EOL] [EOL] def unpack_nvlist ( self , extra = False ) : [EOL] values = { } [EOL] this_length = self . unpack_uhyper ( ) [EOL] unknown2 = self . unpack_uhyper ( ) [EOL] unknown3 = self . unpack_uint ( ) [EOL] start = self . buf . tell ( ) [EOL] if extra : [EOL] self . unpack_uint ( ) [EOL] end_offset = start + this_length [EOL] while self . buf . tell ( ) <= end_offset : [EOL] name , v = self . unpack_value ( ) [EOL] if name : [EOL] values [ name ] = v [EOL] else : [EOL] break [EOL] return values [EOL] [EOL] def unpack_history ( self ) : [EOL] total_length = len ( self . buf . getvalue ( ) ) - [number] [EOL] history = [ True ] [EOL] while self . buf . tell ( ) < total_length and history [ - [number] ] : [EOL] history . append ( self . unpack_nvlist ( ) ) [EOL] return history [ [number] : - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[io.BytesIO,builtins.bytes]$ 0 0 0 0 0 0 $typing.Union[io.BytesIO,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[io.BytesIO,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 $typing.Union[io.BytesIO,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $nvlist.NVTypes$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $nvlist.NVTypes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $nvlist.NVTypes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $nvlist.NVTypes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $nvlist.NVTypes$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $nvlist.NVTypes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $nvlist.NVTypes$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $nvlist.NVTypes$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import zfs [EOL] import typing [EOL] import logging [EOL] import functools [EOL] import logging [EOL] [EOL] from errno import ENOENT , EINVAL [EOL] from stat import S_IFDIR , S_IFLNK , S_IFREG [EOL] import _thread [EOL] [EOL] from fuse import FUSE , FuseOSError , Operations [EOL] [EOL] from zfs import datasets [EOL] from zfs import posix [EOL] from zfs . posix . attributes import PosixType [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def locked ( f ) : [EOL] @ functools . wraps ( f ) def inner ( self , * a , ** kw ) : [EOL] with self . pool_lock : [EOL] return f ( self , * a , ** kw ) [EOL] [EOL] return inner [EOL] [EOL] [EOL] class ZFSFuse ( Operations ) : [EOL] [EOL] def __init__ ( self , pool = None ) : [EOL] self . pool = pool [EOL] self . fd = [number] [EOL] self . pool_lock = _thread . allocate_lock ( ) [EOL] logger . critical ( [string] ) [EOL] [EOL] @ locked def getattr ( self , path , fh = None ) : [EOL] try : [EOL] obj = self . pool . open ( path ) [EOL] if path . endswith ( [string] ) : [EOL] logger . debug ( f' [string] { obj } [string] { obj . attrs } [string] { obj . dnode . index }' ) [EOL] if isinstance ( obj , datasets . Dataset ) : [EOL] obj = obj . root_directory [EOL] if isinstance ( obj , posix . PosixObject ) : [EOL] attrs = obj . attrs [EOL] mode = attrs [ [string] ] . perms [EOL] logger . debug ( f'{ path } [string] { attrs . keys ( ) }' ) [EOL] logger . debug ( mode ) [EOL] if isinstance ( obj , posix . Directory ) : [EOL] mode |= S_IFDIR [EOL] elif [string] in attrs or attrs [ [string] ] . file_type == PosixType . SYMLINK : [EOL] mode |= S_IFLNK [EOL] elif isinstance ( obj , posix . File ) : [EOL] mode |= S_IFREG [EOL] return { [string] : mode , [string] : attrs [ [string] ] , [string] : attrs [ [string] ] , [string] : attrs [ [string] ] , [string] : attrs [ [string] ] . seconds , [string] : attrs [ [string] ] . seconds , [string] : attrs [ [string] ] . seconds , } [EOL] else : [EOL] return { } [EOL] except Exception as e : [EOL] logger . exception ( [string] ) [EOL] raise FuseOSError ( ENOENT ) [EOL] [EOL] def getxattr ( self , path , name , position = [number] ) : [EOL] return [string] [EOL] [EOL] def listxattr ( self , path ) : [EOL] return [ ] [EOL] [EOL] def open ( self , path , flags ) : [EOL] self . fd += [number] [EOL] return self . fd [EOL] [EOL] @ locked def readlink ( self , path ) : [EOL] try : [EOL] logger . debug ( f' [string] { path }' ) [EOL] obj = self . pool . open ( path ) [EOL] return obj . attrs [ [string] ] [EOL] except Exception as e : [EOL] logger . exception ( f' [string] { path }' ) [EOL] raise FuseOSError ( ENOENT ) [EOL] [EOL] @ locked def read ( self , path , size , offset , fh ) : [EOL] try : [EOL] return self . pool . read_file ( path ) [ offset : offset + size ] [EOL] except Exception as e : [EOL] logger . exception ( [string] ) [EOL] raise FuseOSError ( EINVAL ) [EOL] [EOL] @ locked def readdir ( self , path , fh ) : [EOL] try : [EOL] names = [ [string] , [string] ] [EOL] for name in self . pool . open ( path ) . keys ( ) : [EOL] if isinstance ( name , bytes ) : [EOL] name = name . decode ( [string] ) [EOL] names . append ( name ) [EOL] logger . info ( [string] . join ( names ) ) [EOL] return names [EOL] except Exception as e : [EOL] logger . exception ( [string] ) [EOL] raise FuseOSError ( EINVAL ) [EOL] [EOL] def statfs ( self , path ) : [EOL] return dict ( f_bsize = [number] , f_blocks = [number] , f_bavail = [number] ) [EOL] [EOL] [EOL] def mount ( pool , mountpoint ) : [EOL] zf = ZFSFuse ( pool ) [EOL] fuse = FUSE ( zf , mountpoint , foreground = True , rdonly = True , nobrowse = True , jail_symlinks = True , nolocalcaches = True , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zfs.posix.directory.Directory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $zfs.posix.directory.Directory$ 0 0 0 $zfs.posix.directory.Directory$ 0 0 0 0 0 $zfs.posix.directory.Directory$ 0 0 0 0 0 0 0 0 0 0 $zfs.posix.directory.Directory$ 0 0 0 0 0 0 0 $zfs.posix.directory.Directory$ 0 $zfs.posix.directory.Directory$ 0 0 0 0 0 0 $zfs.posix.directory.Directory$ 0 0 0 0 0 0 0 0 0 $zfs.posix.directory.Directory$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $zfs.posix.directory.Directory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zfs.posix.directory.Directory$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Any , Iterator , Sequence [EOL] import pyndata [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import os [EOL] [EOL] from typing import Iterator [EOL] from typing import Tuple [EOL] from typing import Any [EOL] from typing import Sequence [EOL] [EOL] [EOL] import pyndata [EOL] [EOL] import zfs . posix [EOL] from . import PosixObject [EOL] from . attributes import PosixType [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class DirectoryEntry ( pyndata . Struct ) : [EOL] [comment] [EOL] __ENDIAN__ = [string] [EOL] [EOL] name = pyndata . nullstring ( max_length = [number] ) [EOL] value = pyndata . uint64 ( ) [EOL] value . __SHOW__ = False [EOL] object_type = pyndata . BitField ( value , [number] , [number] , enum = PosixType ) [EOL] number = pyndata . BitField ( value , [number] ) [EOL] [EOL] [EOL] class Directory ( PosixObject ) : [EOL] def __init__ ( self , dnode , entries , dataset , objectset , path = None ) : [EOL] super ( ) . __init__ ( dnode , dataset ) [EOL] self . entries = entries [EOL] self . path = path [EOL] self . objectset = objectset [EOL] [EOL] self . resolved_entries = { } [EOL] [EOL] def __contains__ ( self , name ) : [EOL] return name in self . entries [EOL] [EOL] def __getitem__ ( self , name ) : [EOL] joined_path = os . path . join ( self . path , name ) [EOL] if name not in self . resolved_entries : [EOL] try : [EOL] entry_value = self . entries [ name ] [EOL] entry = DirectoryEntry ( name = name , value = entry_value ) [EOL] obj = self . objectset [ entry . number ] [EOL] if isinstance ( obj , ( Directory , zfs . posix . File ) ) : [EOL] obj . path = joined_path [EOL] self . resolved_entries [ name ] = obj [EOL] except Exception : [EOL] logger . warning ( [string] . format ( joined_path ) ) [EOL] raise FileNotFoundError ( joined_path ) [EOL] return self . resolved_entries [ name ] [EOL] [EOL] def keys ( self ) : [EOL] return self . entries . keys ( ) [EOL] [EOL] def items ( self ) : [EOL] return ( ( k , self [ k ] ) for k in self . keys ( ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( path = self . path , entries = list ( self . keys ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] [EOL] from . import PosixObject [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class File ( PosixObject ) : [EOL] [EOL] def read ( self ) : [EOL] data = self . dataset . pool . read_dnode ( self . dnode ) [EOL] return data [ : self . attrs [ [string] ] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
import ondisk [EOL] import zfs [EOL] import datasets [EOL] import logging [EOL] import logging [EOL] [EOL] from . . import ondisk [EOL] from . . import datasets [EOL] from zfs . posix . attributes import POSIXAttrs_for [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PosixObject ( object ) : [EOL] def __init__ ( self , dnode , dataset ) : [EOL] self . attrs = POSIXAttrs_for ( dataset ) ( dnode . bonus ) [EOL] self . dataset = dataset [EOL] self . dnode = dnode [EOL] [EOL] [EOL] from . posix_file import File [EOL] from . directory import Directory [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $zfs.ondisk.DNode$ 0 $zfs.datasets.Dataset$ 0 0 0 0 0 0 0 0 0 $zfs.datasets.Dataset$ 0 0 $zfs.ondisk.DNode$ 0 0 0 0 0 0 $zfs.datasets.Dataset$ 0 $zfs.datasets.Dataset$ 0 0 0 $zfs.ondisk.DNode$ 0 $zfs.ondisk.DNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pyndata [EOL] import zfs [EOL] import typing [EOL] import logging [EOL] import logging [EOL] [EOL] import enum [EOL] import pyndata [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PosixType ( enum . Enum ) : [EOL] FIFO = [number] [EOL] CHARACTER = [number] [EOL] DIRECTORY = [number] [EOL] BLOCK = [number] [EOL] REGULAR_FILE = [number] [EOL] SYMLINK = [number] [EOL] SOCKET = [number] [EOL] DOOR = [number] [EOL] PORT = [number] [EOL] [EOL] [EOL] class Mode ( pyndata . Struct ) : [EOL] __ENDIAN__ = [string] [EOL] mode = pyndata . uint64 ( ) [EOL] perms = pyndata . BitField ( mode , [number] ) [EOL] unknown = pyndata . BitField ( mode , [number] ) [EOL] file_type = pyndata . BitField ( mode , [number] , enum = PosixType ) [EOL] [EOL] [EOL] class Timestamp ( pyndata . Struct ) : [EOL] __ENDIAN__ = [string] [EOL] seconds = pyndata . uint64 ( ) [EOL] nanoseconds = pyndata . uint64 ( ) [EOL] [EOL] [EOL] class ZNodeACE ( pyndata . Struct ) : [EOL] who = pyndata . uint32 ( ) [EOL] access_mask = pyndata . uint32 ( ) [EOL] flags = pyndata . uint16 ( ) [EOL] type = pyndata . uint16 ( ) [EOL] [EOL] [EOL] class ZNodeACL ( pyndata . Struct ) : [EOL] external_object = pyndata . uint64 ( ) [EOL] count = pyndata . uint32 ( ) [EOL] version = pyndata . uint16 ( ) [EOL] _padding = pyndata . padding ( length = [number] ) [EOL] aces = pyndata . array ( ZNodeACE , length = count ) [EOL] [EOL] [EOL] class DefaultAttrsV1 ( pyndata . Struct ) : [EOL] __ENDIAN__ = [string] [EOL] ZPL_ATIME = Timestamp ( ) [EOL] ZPL_MTIME = Timestamp ( ) [EOL] ZPL_CTIME = Timestamp ( ) [EOL] ZPL_CRTIME = Timestamp ( ) [EOL] ZPL_GEN = pyndata . uint64 ( ) [EOL] ZPL_MODE = Mode ( ) [EOL] ZPL_SIZE = pyndata . uint64 ( ) [EOL] ZPL_PARENT = pyndata . uint64 ( ) [EOL] ZPL_LINKS = pyndata . uint64 ( ) [EOL] ZPL_XATTR = pyndata . uint64 ( ) [EOL] ZPL_RDEV = pyndata . uint64 ( ) [EOL] ZPL_FLAGS = pyndata . uint64 ( ) [EOL] ZPL_UID = pyndata . uint64 ( ) [EOL] ZPL_GID = pyndata . uint64 ( ) [EOL] padding = pyndata . array ( pyndata . uint64 ( ) , length = [number] ) [EOL] acl = ZNodeACL ( ) [EOL] [EOL] [EOL] def FixedAttributes ( data ) : [EOL] attrs = DefaultAttrsV1 ( data ) [EOL] return attrs . field_items [EOL] [EOL] [EOL] def POSIXAttrs_for ( dataset ) : [EOL] if dataset . pool . version >= [number] : [EOL] return SystemAttributes ( dataset ) [EOL] else : [EOL] return FixedAttributes [EOL] [EOL] [EOL] from . systemattributes import SystemAttributes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zfs.posix.attributes.ZNodeACL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import pyndata [EOL] import logging [EOL] import typing [EOL] import io [EOL] import logging [EOL] [EOL] from io import BytesIO [EOL] [EOL] import pyndata [EOL] import struct [EOL] [EOL] from . import Mode , Timestamp [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def simple_attribute ( data , attrs ) : [EOL] return struct . unpack ( [string] , data ) [ [number] ] [EOL] [EOL] [EOL] def debug_simple_attribute ( data , attrs ) : [EOL] attr = simple_attribute ( data , attrs ) [EOL] logger . info ( attr ) [EOL] return attr [EOL] [EOL] [EOL] def eat_remainder ( data , attrs ) : [EOL] d = data . read ( ) [EOL] return d [EOL] [EOL] def symlink ( data , attrs ) : [EOL] return eat_remainder ( data , attrs ) . decode ( [string] ) [EOL] [EOL] def dacl_entries ( data , attrs ) : [EOL] if [string] not in attrs : [EOL] logger . error ( [string] ) [EOL] raise KeyError ( [string] ) [EOL] count = attrs [ [string] ] [EOL] acls = [ ] [EOL] for x in range ( count ) : [EOL] acls . append ( data . read ( [number] ) ) [EOL] logger . debug ( f'{ data . tell ( ) } [string] { len ( data . getvalue ( ) ) }' ) [EOL] return acls [EOL] [EOL] [EOL] def no_attrs ( f ) : [EOL] def inner ( data , attrs ) : [EOL] return f ( data ) [EOL] return inner [EOL] [EOL] [EOL] SYSTEM_ATTRIBUTES = { [string] : no_attrs ( Mode ) , [string] : simple_attribute , [string] : simple_attribute , [string] : simple_attribute , [string] : simple_attribute , [string] : simple_attribute , [string] : simple_attribute , [string] : no_attrs ( Timestamp ) , [string] : no_attrs ( Timestamp ) , [string] : no_attrs ( Timestamp ) , [string] : no_attrs ( Timestamp ) , [string] : simple_attribute , [string] : simple_attribute , [string] : simple_attribute , [string] : dacl_entries , [string] : symlink , } [EOL] [EOL] [EOL] class SystemAttributeMagic ( pyndata . Struct ) : [EOL] magic = pyndata . bytestring ( length = [number] ) [EOL] layout = pyndata . uint8 ( ) [EOL] unknown1 = pyndata . uint8 ( ) [EOL] unknown2 = pyndata . padding ( length = [number] ) [EOL] unknown3 = pyndata . bytestring ( length = lambda s , x = None : [number] if s . unknown1 == [number] else [number] ) [EOL] [EOL] [EOL] class SystemAttributes ( object ) : [EOL] def __init__ ( self , dataset ) : [EOL] self . dataset = dataset [EOL] [EOL] def __call__ ( self , data ) : [EOL] attributes = { } [EOL] logger . debug ( repr ( data [ : [number] ] ) ) [EOL] data = BytesIO ( data ) [EOL] attributes [ [string] ] = hdr = SystemAttributeMagic ( data ) [EOL] logger . debug ( hdr ) [EOL] for attr in self . dataset . attributes ( str ( hdr . layout ) ) : [EOL] name = attr [ [string] ] [EOL] logger . debug ( f' [string] { name }' ) [EOL] if attr [ [string] ] > [number] : [EOL] d = data . read ( attr [ [string] ] ) [EOL] else : [EOL] d = data [EOL] if name not in SYSTEM_ATTRIBUTES : [EOL] logger . debug ( [string] . format ( attr ) ) [EOL] attributes [ name ] = SYSTEM_ATTRIBUTES . get ( name , eat_remainder ) ( d , attrs = attributes ) [EOL] return attributes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 $io.BytesIO$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 $io.BytesIO$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $io.BytesIO$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import Type , Dict , Any [EOL] import pyndata [EOL] import zfs [EOL] import typing [EOL] from typing import Type [EOL] from typing import Union [EOL] [EOL] from pyndata import BitField [EOL] from pyndata import Struct [EOL] from pyndata import array [EOL] from pyndata import bytestring [EOL] from pyndata import padding [EOL] from pyndata import uint16 [EOL] from pyndata import uint64 [EOL] from pyndata import uint8 [EOL] [EOL] from . . import constants [EOL] from . import fatzap [EOL] [EOL] [EOL] class dva ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] _first = uint64 ( ) [EOL] vdev = BitField ( _first , [number] , [number] ) [EOL] grid = BitField ( _first , [number] , [number] ) [EOL] asize = BitField ( _first , [number] , [number] ) [EOL] _offset = uint64 ( ) [EOL] gang = BitField ( _offset , [number] , [number] ) [EOL] offset = BitField ( _offset , [number] , [number] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . vdev , self . offset << [number] , self . asize << [number] ) [EOL] [EOL] [EOL] class Blockptr ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] dvas = array ( dva ( ) , length = [number] ) [EOL] _prop = uint64 ( ) [EOL] logical_size = BitField ( _prop , [number] , [number] ) [EOL] physical_size = BitField ( _prop , [number] , [number] ) [EOL] compression = BitField ( _prop , [number] , [number] , enum = constants . Compression ) [EOL] encryption = BitField ( _prop , [number] , [number] ) [EOL] embedded = BitField ( _prop , [number] , [number] ) [EOL] checksum_type = BitField ( _prop , [number] , [number] , enum = constants . Checksum ) [EOL] object_type = BitField ( _prop , [number] , [number] , enum = constants . ObjectType ) [EOL] level = BitField ( _prop , [number] , [number] ) [EOL] dedup = BitField ( _prop , [number] , [number] ) [EOL] endian = BitField ( _prop , [number] , [number] ) [EOL] [EOL] pad = padding ( length = [number] ) [EOL] phys_birth = uint64 ( ) [EOL] birth = uint64 ( ) [EOL] fill = uint64 ( ) [EOL] checksum = array ( uint64 ( ) , [number] ) [EOL] [EOL] def to_embedded ( self ) : [EOL] raw_blkptr = self . pack ( ) [EOL] return EmbeddedBlockptr ( raw_blkptr ) [EOL] [EOL] [EOL] class EmbeddedBlockptr ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] data1 = bytestring ( length = [number] * [number] ) [EOL] _prop = uint64 ( ) [EOL] logical_size = BitField ( _prop , [number] ) [EOL] physical_size = BitField ( _prop , [number] ) [EOL] compression = BitField ( _prop , [number] ) [EOL] embedded = BitField ( _prop , [number] ) [EOL] embedded_type = BitField ( _prop , [number] ) [EOL] type_ = BitField ( _prop , [number] ) [EOL] level = BitField ( _prop , [number] ) [EOL] encryption = BitField ( _prop , [number] ) [EOL] dedup = BitField ( _prop , [number] ) [EOL] endian = BitField ( _prop , [number] ) [EOL] data2 = bytestring ( length = [number] * [number] ) [EOL] birth = uint64 ( ) [EOL] data3 = bytestring ( length = [number] * [number] ) [EOL] [EOL] @ property def data ( self ) : [EOL] data = self . data1 + self . data2 + self . data3 [EOL] assert len ( data ) == [number] [EOL] return data [EOL] [EOL] [EOL] class GangBlock ( Struct ) : [EOL] MAGIC = [number] [EOL] blocks = array ( Blockptr ( ) , length = [number] ) [EOL] _pad = padding ( length = [number] ) [EOL] magic = uint64 ( ) [EOL] checksum = array ( uint64 ( ) , [number] ) [EOL] [EOL] [EOL] class Uberblock ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] MAGIC = [number] [EOL] [EOL] magic = uint64 ( ) [EOL] version = uint64 ( ) [EOL] txg = uint64 ( ) [EOL] guid_sum = uint64 ( ) [EOL] timestamp = uint64 ( ) [EOL] root = Blockptr ( ) [EOL] software_version = uint64 ( ) [EOL] [EOL] def valid ( self ) : [EOL] if self . magic != self . MAGIC : [EOL] return False [EOL] if self . version > constants . POOL_VERSION : [EOL] return False [EOL] [comment] [EOL] return True [EOL] [EOL] [EOL] class DNode ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] node_type = uint8 ( enum = constants . ObjectType ) [EOL] indirect_blockshift = uint8 ( ) [EOL] indirect_levels = uint8 ( ) [EOL] num_blockptrs = uint8 ( ) [EOL] bonustype = uint8 ( enum = constants . ObjectType ) [EOL] checksum_type = uint8 ( enum = constants . Checksum ) [EOL] compression_type = uint8 ( enum = constants . Compression ) [EOL] _dnode_flags = uint8 ( ) [comment] [EOL] used_bytes = BitField ( _dnode_flags , [number] , [number] ) [EOL] userused = BitField ( _dnode_flags , [number] , [number] ) [EOL] spill_blkptr = BitField ( _dnode_flags , [number] , [number] ) [EOL] data_sectors = uint16 ( ) [EOL] bonuslen = uint16 ( ) [EOL] _pad = padding ( length = [number] ) [EOL] max_block_id = uint64 ( ) [EOL] used = uint64 ( ) [EOL] _pad2 = padding ( length = [number] * [number] ) [EOL] blkptr = array ( Blockptr ( ) , length = num_blockptrs ) [EOL] [EOL] def bonus_length ( self , o = None ) : [EOL] if self . bonuslen != [number] and self . node_type != constants . ObjectType . NONE : [EOL] return self . bonuslen [EOL] elif self . node_type == constants . ObjectType . NONE : [EOL] return [number] [EOL] else : [EOL] return self . bonuslen [EOL] bonus = bytestring ( length = bonus_length ) [comment] [EOL] _final_pad = padding ( length = [number] ) [EOL] [EOL] [EOL] class ZILHeader ( Struct ) : [EOL] claim_txg = uint64 ( ) [EOL] replay_seq = uint64 ( ) [EOL] log = Blockptr ( ) [EOL] claim_seq = uint64 ( ) [EOL] _pad = padding ( length = [number] * [number] ) [EOL] [EOL] [EOL] class ZILRecord ( Struct ) : [EOL] tx_type = uint64 ( enum = constants . ZILTypes ) [EOL] length = uint64 ( ) [EOL] txg = uint64 ( ) [EOL] seq = uint64 ( ) [EOL] [EOL] [EOL] class ObjsetV1 ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] meta_dnode = DNode ( ) [EOL] zil_header = ZILHeader ( ) [EOL] os_type = uint64 ( enum = constants . ObjectSetType ) [EOL] [EOL] [EOL] Objset = ObjsetV1 [EOL] [EOL] [EOL] class ObjsetV15 ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] meta_dnode = DNode ( ) [EOL] zil_header = ZILHeader ( ) [EOL] os_type = uint64 ( enum = constants . ObjectSetType ) [EOL] os_flags = uint64 ( ) [comment] [EOL] _pad = padding ( length = [number] ) [EOL] userused = DNode ( ) [EOL] groupused = DNode ( ) [EOL] [EOL] [EOL] ObjectsetTypes = Union [ Type [ ObjsetV1 ] , Type [ ObjsetV15 ] ] [EOL] Objectsets = Union [ ObjsetV1 , ObjsetV15 ] [EOL] [EOL] [EOL] def Objset_for ( version ) : [EOL] if version in range ( [number] , [number] ) : [EOL] return ObjsetV1 [EOL] else : [EOL] return ObjsetV15 [EOL] [EOL] [EOL] indirect_cache = { } [EOL] [EOL] [EOL] def indirect ( size = None , shift = None ) : [EOL] size = ( size * [number] ) or ( [number] << shift ) [EOL] count = int ( size / [number] ) [EOL] [EOL] if size not in indirect_cache : [EOL] [EOL] class IndirectBlock ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] blocks = array ( Blockptr ( ) , length = count ) [EOL] [EOL] IndirectBlock . __name__ = [string] + str ( size ) [EOL] [EOL] indirect_cache [ size ] = IndirectBlock [EOL] [EOL] return indirect_cache [ size ] [EOL] [EOL] [EOL] class DSLDir ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] creation_time = uint64 ( ) [EOL] head_dataset = uint64 ( ) [EOL] parent = uint64 ( ) [EOL] clone_parent = uint64 ( ) [EOL] child_dir_zap = uint64 ( ) [EOL] used_bytes = uint64 ( ) [EOL] compressed_bytes = uint64 ( ) [EOL] uncompressed_bytes = uint64 ( ) [EOL] quota = uint64 ( ) [EOL] props_zap = uint64 ( ) [EOL] _pad = padding ( length = [number] * [number] ) [EOL] [EOL] [EOL] class DSLDataset ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] dir = uint64 ( ) [EOL] prev_snapshot = uint64 ( ) [EOL] prev_snapshot_txg = uint64 ( ) [EOL] next_snapshot = uint64 ( ) [EOL] snapnames_zap = uint64 ( ) [EOL] num_children = uint64 ( ) [EOL] creation_time = uint64 ( ) [EOL] creation_txg = uint64 ( ) [EOL] deadlist = uint64 ( ) [EOL] used_bytes = uint64 ( ) [EOL] compressed_bytes = uint64 ( ) [EOL] uncompressed_bytes = uint64 ( ) [EOL] unique_bytes = uint64 ( ) [EOL] fsid_guid = uint64 ( ) [EOL] guid = uint64 ( ) [EOL] flags = uint64 ( ) [EOL] bp = Blockptr ( ) [EOL] _pad = padding ( length = [number] * [number] ) [EOL] [EOL] [EOL] class BPObjHeader ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] length = uint64 ( ) [EOL] unknown = array ( uint16 ( ) , length = [number] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pyndata [EOL] import zfs [EOL] import enum [EOL] from pyndata import Struct , uint64 , padding , uint32 , uint16 , nullstring , BitField [EOL] [EOL] [EOL] class ZapType ( enum . Enum ) : [EOL] ZAPLeaf = ( [number] << [number] ) [EOL] ZAPHeader = ( [number] << [number] ) + [number] [EOL] MicroZAP = ( [number] << [number] ) + [number] [EOL] [EOL] [EOL] class MicroZAPHeader ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] block_type = uint64 ( enum = ZapType ) [EOL] salt = uint64 ( ) [EOL] flags = uint64 ( ) [EOL] _pad = padding ( length = [number] * [number] ) [EOL] [EOL] [EOL] class MicroZAPCommon ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] _pad = uint16 ( ) [EOL] collision = uint32 ( ) [EOL] name = nullstring ( padded = True , max_length = [number] ) [EOL] [EOL] [EOL] class MicroZAP ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] value = uint64 ( ) [EOL] hdr = MicroZAPCommon ( ) [EOL] [EOL] [EOL] class SARegistrationMicroZAP ( Struct ) : [EOL] __ENDIAN__ = [string] [EOL] [EOL] _value = uint64 ( ) [EOL] attr_num = BitField ( _value , [number] , [number] ) [EOL] byteswap = BitField ( _value , [number] , [number] ) [EOL] length = BitField ( _value , [number] , [number] ) [EOL] hdr = MicroZAPCommon ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyndata.bitfield.BitField$ 0 0 0 0 0 0 0 0 0 0 $pyndata.bitfield.BitField$ 0 0 0 0 0 0 0 0 0 0 $pyndata.bitfield.BitField$ 0 0 0 0 0 0 0 0 0 0 $zfs.ondisk.zap.MicroZAPCommon$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] import sys [EOL] [EOL] from . error import error [EOL] from . field import Field [EOL] from . variablelength import VariableLength [EOL] [EOL] class bytestring ( VariableLength , Field ) : [EOL] [docstring] [EOL] def __init__ ( self , length ) : [EOL] super ( bytestring , self ) . __init__ ( ) [EOL] self . length = length [EOL] self . default = [string] [EOL] [EOL] if sys . version_info [ [number] ] == [number] : [EOL] def pack ( self , value , struct ) : [EOL] return bytes ( value ) [EOL] else : [EOL] def pack ( self , value , struct ) : [EOL] return value [EOL] [EOL] def unpack ( self , reader , struct ) : [EOL] l = self . get_length ( struct ) [EOL] data = reader . read ( l ) [EOL] if len ( data ) != l : [EOL] raise error ( [string] . format ( self . name , l , repr ( data ) , struct ) ) [EOL] else : [EOL] return data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from __future__ import absolute_import [EOL] [EOL] from . field import Field [EOL] [EOL] class StructField ( Field ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , struct ) : [EOL] self . __DEFAULT__ = struct [EOL] super ( StructField , self ) . __init__ ( ) [EOL] self . __index__ = struct . __index__ [EOL] self . struct = type ( struct ) [EOL] [EOL] def pack ( self , value , struct ) : [EOL] return value . pack ( ) [EOL] [EOL] def unpack ( self , reader , struct ) : [EOL] return self . struct ( reader ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type [EOL] import pyndata [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] import itertools [EOL] import sys [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if sys . version_info [ [number] ] == [number] : [EOL] __nextfield__ = itertools . count ( ) . __next__ [EOL] else : [EOL] __nextfield__ = itertools . count ( ) . next [EOL] [EOL] class Field ( object ) : [EOL] [docstring] [EOL] __DEFAULT__ = None [EOL] __SHOW__ = True [EOL] [EOL] def __init__ ( self , default = None ) : [EOL] self . default = default or self . __DEFAULT__ [EOL] self . __index__ = __nextfield__ ( ) [EOL] self . name = None [EOL] [EOL] def __get__ ( self , obj , kind = None ) : [EOL] return obj . field_items [ self . name ] [EOL] [EOL] def __set__ ( self , obj , value ) : [EOL] obj . field_items [ self . name ] = value [EOL] [EOL] def pack ( self , value , struct ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] def unpack ( self , reader , struct ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , List [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] import struct [EOL] import sys [EOL] [EOL] if sys . version_info [ [number] ] == [number] : [EOL] xrange = range [EOL] [EOL] from . field import Field [EOL] from . error import error [EOL] from . integer import integer [EOL] from . structure import Struct [EOL] from . structure import StructField [EOL] from . variablelength import VariableLength [EOL] [EOL] class array ( VariableLength , Field ) : [EOL] [docstring] [EOL] def __init__ ( self , kind , length ) : [EOL] super ( array , self ) . __init__ ( ) [EOL] [EOL] if issubclass ( type ( kind ) , Struct ) : [EOL] kind = StructField ( kind ) [EOL] self . kind = kind [EOL] [EOL] self . length = length [EOL] [EOL] self . default = [ ] [EOL] [EOL] def pack ( self , values , _struct ) : [EOL] return [string] . join ( self . kind . pack ( item , _struct ) for item in values ) [EOL] [EOL] def unpack ( self , reader , _struct ) : [EOL] out = [ ] [EOL] for x in xrange ( self . get_length ( _struct ) ) : [EOL] out . append ( self . kind . unpack ( reader , _struct ) ) [EOL] return out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import Any , List [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] import sys [EOL] [EOL] from . array import array [EOL] from . bitfield import BitField [EOL] from . bytestring import bytestring [EOL] from . error import error [EOL] from . field import __nextfield__ [EOL] from . field import Field [EOL] from . integer import * [EOL] from . nullstring import nullstring [EOL] from . padding import padding [EOL] from . structfield import StructField [EOL] if sys . version_info [ [number] ] == [number] : [EOL] from . structure3 import Struct [EOL] else : [EOL] from . structure import Struct [EOL] from . variablelength import VariableLength [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] + [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] for name in __all__ : [EOL] o = globals ( ) [ name ] [EOL] if isinstance ( o , type ) : [EOL] o . __module__ = [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] import sys [EOL] [EOL] from . error import error [EOL] from . field import Field [EOL] [EOL] class nullstring ( Field ) : [EOL] [docstring] [EOL] def __init__ ( self , max_length , padded = False , allow_max = False , encoding = [string] ) : [EOL] super ( nullstring , self ) . __init__ ( ) [EOL] self . max_length = max_length [EOL] self . padded = padded [EOL] self . default = [string] [EOL] self . allow_max = allow_max [EOL] self . encoding = encoding [EOL] [EOL] def pack ( self , value , struct ) : [EOL] if isinstance ( value , str ) : [EOL] print ( self . encoding , type ( value ) , value ) [EOL] if self . encoding : [EOL] value = value . encode ( self . encoding ) [EOL] elif sys . version_info [ [number] ] == [number] : [EOL] pass [EOL] else : [EOL] raise error [EOL] if self . allow_max : [EOL] if len ( value ) > self . max_length : [EOL] raise ValueError ( [string] . format ( len ( value ) , self . max_length ) ) [EOL] else : [EOL] if len ( value ) >= self . max_length : [EOL] raise ValueError ( [string] . format ( len ( value ) , self . max_length ) ) [EOL] value = ( value + [string] ) [ : self . max_length ] [EOL] if self . padded : [EOL] pad = self . max_length - len ( value ) [EOL] value += [string] * pad [EOL] return value [EOL] [EOL] def unpack ( self , reader , struct ) : [EOL] if self . padded : [EOL] value = reader . read ( self . max_length ) [EOL] else : [EOL] value = [ [string] ] [EOL] i = [number] [EOL] m = self . max_length + ( [number] if self . allow_max else [number] ) [EOL] while value [ - [number] ] != [string] and i < m : [EOL] value . append ( reader . read ( [number] ) ) [EOL] i += [number] [EOL] value = [string] . join ( value ) [EOL] print ( value ) [EOL] value = value . rstrip ( [string] ) [EOL] if self . encoding : [EOL] value = value . decode ( self . encoding ) [EOL] return value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
import pyndata [EOL] from __future__ import absolute_import [EOL] [EOL] from . field import Field [EOL] from . structure import Struct [EOL] from . structfield import StructField [EOL] [EOL] class ConditionalField ( Field ) : [EOL] def __init__ ( self , func , real_field ) : [EOL] super ( ConditionalField , self ) . __init__ ( ) [EOL] [EOL] if issubclass ( type ( real_field ) , Struct ) : [EOL] real_field = StructField ( real_field ) [EOL] [EOL] self . func = func [EOL] self . real_field = real_field [EOL] self . default = real_field . default [EOL] [EOL] def pack ( self , value , struct ) : [EOL] if self . func ( struct ) : [EOL] return self . real_field . pack ( value , struct ) [EOL] else : [EOL] return [string] [EOL] [EOL] def unpack ( self , reader , struct ) : [EOL] if self . func ( struct ) : [EOL] return self . real_field . unpack ( reader , struct ) [EOL] else : [EOL] return self . default [EOL] [EOL] def conditional ( field ) : [EOL] def wrapper ( f ) : [EOL] cf = ConditionalField ( f , field ) [EOL] return cf [EOL] return wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . structure import Struct , StructMeta [EOL] [EOL] class Struct ( Struct , metaclass = StructMeta ) : [EOL] pass	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import absolute_import [EOL] [EOL] from . field import Field [EOL] from . bitfield import BitField [EOL] [EOL] class VariableLength ( object ) : [EOL] [docstring] [EOL] def get_length ( self , struct ) : [EOL] if isinstance ( self . length , ( Field , BitField ) ) : [EOL] return self . length . __get__ ( struct ) [EOL] elif callable ( self . length ) : [EOL] return self . length ( struct ) [EOL] else : [EOL] return self . length [EOL] [EOL] def __set__ ( self , obj , value ) : [EOL] super ( VariableLength , self ) . __set__ ( obj , value ) [EOL] if isinstance ( self . length , ( Field , BitField ) ) : [EOL] return self . length . __set__ ( obj , len ( value ) ) [EOL] elif callable ( self . length ) : [EOL] return self . length ( obj , len ( value ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import absolute_import [EOL] [EOL] from . field import Field [EOL] [EOL] class padding ( Field ) : [EOL] [docstring] [EOL] def __init__ ( self , length ) : [EOL] super ( padding , self ) . __init__ ( ) [EOL] self . length = length [EOL] self . default = [string] * length [EOL] [EOL] def pack ( self , value , struct ) : [EOL] return value + [string] * ( self . length - len ( value ) ) [EOL] [EOL] def unpack ( self , reader , struct ) : [EOL] return reader . read ( self . length ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , List [EOL] import pyndata [EOL] import io [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] import copy [EOL] import sys [EOL] [EOL] if sys . version_info [ [number] ] == [number] : [EOL] from io import BytesIO as StringIO [EOL] else : [EOL] try : from cStringIO import StringIO [EOL] except : from StringIO import StringIO [EOL] [EOL] from . bitfield import BitField [EOL] from . field import __nextfield__ [EOL] from . field import Field [EOL] from . structfield import StructField [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class Struct ( object ) : [EOL] pass [EOL] [EOL] class StructMeta ( type ) : [EOL] [docstring] [EOL] def __new__ ( cls , cls_name , bases , attrs ) : [EOL] fields = [ ] [EOL] bitfields = [ ] [EOL] field_defaults = { } [EOL] for name , field in attrs . items ( ) : [EOL] if isinstance ( field , Struct ) : [EOL] field = StructField ( field ) [EOL] attrs [ name ] = field [EOL] if isinstance ( field , Field ) : [EOL] field . name = name [EOL] if name [ [number] ] == [string] : [EOL] field . __SHOW__ = False [EOL] field_defaults [ name ] = field . default [EOL] fields . append ( field ) [EOL] elif isinstance ( field , BitField ) : [EOL] field . name = name [EOL] if name [ [number] ] == [string] : [EOL] field . __SHOW__ = False [EOL] bitfields . append ( field ) [EOL] fields . sort ( key = lambda x : x . __index__ ) [EOL] new_cls = type . __new__ ( cls , cls_name , bases , attrs ) [EOL] new_cls . field_defaults = field_defaults [EOL] new_cls . fields = fields [EOL] new_cls . bitfields = bitfields [EOL] return new_cls [EOL] [EOL] class Struct ( Struct ) : [EOL] [docstring] [EOL] __metaclass__ = StructMeta [EOL] __ENDIAN__ = [string] [EOL] [EOL] def __init__ ( self , initial = None , ** kwargs ) : [EOL] self . __index__ = __nextfield__ ( ) [EOL] if initial : [EOL] self . field_items = { } [EOL] else : [EOL] self . field_items = copy . deepcopy ( self . field_defaults ) [EOL] for k , v in kwargs . items ( ) : [EOL] if hasattr ( self , k ) : [EOL] setattr ( self , k , v ) [EOL] else : [EOL] raise AttributeError ( [string] . format ( self . __class__ . __name__ , k ) ) [EOL] if initial : [EOL] self . unpack ( initial ) [EOL] [EOL] def __repr__ ( self ) : [EOL] fields = [ field . name + [string] + repr ( getattr ( self , field . name ) ) for field in self . fields if field . __SHOW__ ] [EOL] fields . extend ( field . name + [string] + repr ( field . __get__ ( self ) ) for field in self . bitfields if field . __SHOW__ ) [EOL] ret = [string] . format ( type ( self ) . __name__ , [string] . join ( fields ) ) [EOL] return ret [EOL] [EOL] def pack ( self ) : [EOL] [docstring] [EOL] out = [ ] [EOL] for field in self . fields : [EOL] out . append ( field . pack ( field . __get__ ( self ) , self ) ) [EOL] return [string] . join ( out ) [EOL] [EOL] def unpack ( self , reader ) : [EOL] [docstring] [EOL] if isinstance ( reader , ( str , bytes ) ) : [EOL] reader = StringIO ( reader ) [EOL] for field in self . fields : [EOL] setattr ( self , field . name , field . unpack ( reader , self ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 0 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyndata.structfield.StructField$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 $pyndata.structfield.StructField$ 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyndata.structfield.StructField$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $pyndata.structfield.StructField$ 0 0 $pyndata.structfield.StructField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 $typing.Type[typing.Any]$ 0 $pyndata.structfield.StructField$ 0 $pyndata.structfield.StructField$ 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[pyndata.structure.StructMeta]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0
class error ( Exception ) : [EOL] pass	0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import absolute_import [EOL] [EOL] from . field import __nextfield__ [EOL] [EOL] class BitField ( object ) : [EOL] [docstring] [EOL] default = [number] [EOL] __SHOW__ = True [EOL] def __init__ ( self , field , size , shift = None , enum = None ) : [EOL] if shift == None : [EOL] shift = field . current_offset [EOL] field . current_offset += size [EOL] self . __index__ = __nextfield__ ( ) [EOL] self . field = field [EOL] self . mask = ( ( [number] << size ) - [number] ) << shift [EOL] self . shift = shift [EOL] self . enum = enum [EOL] [EOL] def __get__ ( self , obj , kind = None ) : [EOL] value = self . field . __get__ ( obj ) [EOL] value = ( value & self . mask ) >> self . shift [EOL] try : [EOL] return self . enum ( value ) [EOL] except : [EOL] return value [EOL] [EOL] def __set__ ( self , obj , value ) : [EOL] value = int ( value ) [EOL] result = self . field . __get__ ( obj ) & ( ( ~ self . mask ) & ( ( [number] << [number] ) - [number] ) ) [EOL] result |= ( ( value << self . shift ) & self . mask ) [EOL] self . field . __set__ ( obj , result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import pyndata [EOL] import typing [EOL] import pytest [EOL] [EOL] import pyndata [EOL] [EOL] class BytestringTests ( pyndata . Struct ) : [EOL] str1 = pyndata . bytestring ( [number] ) [EOL] [EOL] def test_bytestring ( ) : [EOL] t = BytestringTests ( ) [EOL] t . str1 = [string] [EOL] assert t . str1 == [string] [EOL] assert t . pack ( ) == [string] [EOL] [EOL] class VariableBytestring ( pyndata . Struct ) : [EOL] l = pyndata . uint8 ( ) [EOL] s = pyndata . bytestring ( length = l ) [EOL] [EOL] def test_variable_unpack ( ) : [EOL] v = VariableBytestring ( ) [EOL] v . unpack ( [string] ) [EOL] assert v . l == [number] [EOL] assert v . s == [string] [EOL] [EOL] def test_variable_pack ( ) : [EOL] v = VariableBytestring ( ) [EOL] v . s = [string] [EOL] assert v . l == [number] [EOL] assert v . pack ( ) == [string] [EOL] [EOL] def test_bad_unpack_length ( ) : [EOL] v = VariableBytestring ( ) [EOL] with pytest . raises ( pyndata . error ) : [EOL] v . unpack ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pyndata [EOL] import typing [EOL] import pyndata [EOL] [EOL] class BitFieldTests ( pyndata . Struct ) : [EOL] real = pyndata . uint16 ( ) [EOL] bit1 = pyndata . BitField ( real , [number] , shift = [number] ) [EOL] bit2 = pyndata . BitField ( real , [number] , shift = [number] ) [EOL] bit3 = pyndata . BitField ( real , [number] , shift = [number] ) [EOL] bit4 = pyndata . BitField ( real , [number] , shift = [number] ) [EOL] [EOL] def test_bitfield ( ) : [EOL] b = BitFieldTests ( ) [EOL] b . bit1 = [number] [EOL] b . bit2 = [number] [EOL] b . bit3 = [number] [EOL] b . bit4 = [number] [EOL] assert b . bit1 == [number] [EOL] assert b . bit2 == [number] [EOL] assert b . bit3 == [number] [EOL] assert b . bit4 == [number] [EOL] [EOL] class BitField2Tests ( pyndata . Struct ) : [EOL] real = pyndata . uint16 ( ) [EOL] bit1 = pyndata . BitField ( real , [number] ) [EOL] bit2 = pyndata . BitField ( real , [number] ) [EOL] bit3 = pyndata . BitField ( real , [number] ) [EOL] bit4 = pyndata . BitField ( real , [number] ) [EOL] [EOL] def test_bitfield2 ( ) : [EOL] b = BitFieldTests ( ) [EOL] b . bit1 = [number] [EOL] b . bit2 = [number] [EOL] b . bit3 = [number] [EOL] b . bit4 = [number] [EOL] assert b . bit1 == [number] [EOL] assert b . bit2 == [number] [EOL] assert b . bit3 == [number] [EOL] assert b . bit4 == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyndata.bitfield.BitField$ 0 0 0 0 0 0 0 0 0 0 $pyndata.bitfield.BitField$ 0 0 0 0 0 0 0 0 0 0 $pyndata.bitfield.BitField$ 0 0 0 0 0 0 0 0 0 0 $pyndata.bitfield.BitField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pyndata [EOL] import typing [EOL] import pytest [EOL] [EOL] import pyndata [EOL] [EOL] class Header ( pyndata . Struct ) : [EOL] msg_len = pyndata . uint8 ( ) [EOL] [EOL] class Message ( pyndata . Struct ) : [EOL] hdr = Header ( ) [EOL] s = pyndata . bytestring ( length = hdr . msg_len ) [EOL] [EOL] @ pytest . mark . xfail def test_nested_reference ( ) : [EOL] x = Message ( ) [EOL] x . unpack ( [string] ) [EOL] assert x . hdr . msg_len == [number] [EOL] assert x . s == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pyndata [EOL] import typing [EOL] import pyndata [EOL] [EOL] class SubStruct ( pyndata . Struct ) : [EOL] x = pyndata . uint8 ( ) [EOL] [EOL] class StructWithSubStruct ( pyndata . Struct ) : [EOL] s1 = SubStruct ( ) [EOL] s2 = SubStruct ( ) [EOL] _s3 = SubStruct ( ) [EOL] [EOL] def test_sub_struct_unpack ( ) : [EOL] t = StructWithSubStruct ( [string] ) [EOL] assert t . s1 . x == [number] [EOL] assert t . s2 . x == [number] [EOL] assert t . _s3 . x == [number] [EOL] [EOL] def test_sub_struct_pack ( ) : [EOL] t = StructWithSubStruct ( ) [EOL] t . s1 . x = [number] [EOL] t . s2 . x = [number] [EOL] t . _s3 . x = [number] [EOL] packed = t . pack ( ) [EOL] assert packed == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyndata.tests.test_substruct.SubStruct$ 0 0 0 0 0 $pyndata.tests.test_substruct.SubStruct$ 0 0 0 0 0 $pyndata.tests.test_substruct.SubStruct$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import pyndata [EOL] import typing [EOL] import pytest [EOL] [EOL] import pyndata [EOL] [EOL] class S ( pyndata . Struct ) : [EOL] a = pyndata . uint8 ( ) [EOL] b = pyndata . uint8 ( ) [EOL] c = pyndata . uint8 ( ) [EOL] [EOL] def test_keyword_fields ( ) : [EOL] x = S ( a = [number] , b = [number] , c = [number] ) [EOL] assert x . a == [number] [EOL] assert x . b == [number] [EOL] assert x . c == [number] [EOL] [EOL] def test_keyword_failure ( ) : [EOL] with pytest . raises ( AttributeError ) : [EOL] x = S ( z = [number] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pyndata [EOL] import typing [EOL] import sys [EOL] [EOL] import pytest [EOL] [EOL] import pyndata [EOL] [EOL] class NullStringTests ( pyndata . Struct ) : [EOL] str1 = pyndata . nullstring ( max_length = [number] ) [EOL] str2 = pyndata . nullstring ( max_length = [number] , padded = True ) [EOL] str3 = pyndata . nullstring ( max_length = [number] , allow_max = True ) [EOL] [EOL] def test_null_string_pack ( ) : [EOL] x = NullStringTests ( ) [EOL] packed = x . pack ( ) [EOL] assert packed == [string] [EOL] [EOL] def test_null_string_illegal ( ) : [EOL] x = NullStringTests ( ) [EOL] x . str1 = [string] [EOL] with pytest . raises ( ValueError ) : [EOL] x . pack ( ) [EOL] [EOL] def test_null_string_illegal_allow_max ( ) : [EOL] x = NullStringTests ( ) [EOL] x . str3 = [string] [EOL] with pytest . raises ( ValueError ) : [EOL] x . pack ( ) [EOL] [EOL] def test_null_string_unpack ( ) : [EOL] x = NullStringTests ( ) [EOL] x . unpack ( [string] ) [EOL] assert x . str1 == [string] [EOL] assert x . str2 == [string] [EOL] assert x . str3 == [string] [EOL] [EOL] class NullEncodingTests ( pyndata . Struct ) : [EOL] s1 = pyndata . nullstring ( max_length = [number] , encoding = [string] ) [EOL] b1 = pyndata . nullstring ( max_length = [number] , encoding = None ) [EOL] [EOL] def test_null_string_encoding ( ) : [EOL] x = NullEncodingTests ( ) [EOL] x . s1 = [string] [EOL] x . b1 = [string] [EOL] assert x . pack ( ) == [string] [EOL] x2 = NullEncodingTests ( x . pack ( ) ) [EOL] print ( type ( x2 . s1 ) ) [EOL] if sys . version_info [ [number] ] == [number] : [EOL] strtype = str [EOL] bytestype = bytes [EOL] else : [EOL] strtype = unicode [EOL] bytestype = str [EOL] assert isinstance ( x2 . s1 , strtype ) [EOL] assert isinstance ( x2 . b1 , bytestype ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pyndata [EOL] import typing [EOL] import pytest [EOL] [EOL] import pyndata [EOL] [EOL] class S ( pyndata . Struct ) : [EOL] _a = pyndata . uint8 ( ) [EOL] b = pyndata . uint8 ( ) [EOL] c = pyndata . BitField ( b , [number] ) [EOL] _d = pyndata . BitField ( b , [number] ) [EOL] [EOL] def test_default_hidden ( ) : [EOL] x = S ( ) [EOL] a = repr ( x ) [EOL] assert a == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyndata.bitfield.BitField$ 0 0 0 0 0 0 0 0 0 0 $pyndata.bitfield.BitField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pyndata [EOL] import typing [EOL] import pyndata [EOL] [EOL] class padded ( pyndata . Struct ) : [EOL] f = pyndata . uint8 ( default = [number] ) [EOL] pad = pyndata . padding ( [number] ) [EOL] [EOL] def test_padding_unpack ( ) : [EOL] x = padded ( ) [EOL] x . pad = [string] [EOL] assert x . pack ( ) == [string] [EOL] [EOL] def test_padding_pack ( ) : [EOL] x = padded ( ) [EOL] x . unpack ( [string] ) [EOL] assert x . pad == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import zfs [EOL] import typing [EOL] import os . path [EOL] import sys [EOL] [EOL] import pytest [EOL] [EOL] from zfs import pool , filedev , raidzdev [EOL] [EOL] module_path = os . path . dirname ( sys . modules [ __name__ ] . __dict__ . get ( [string] , [string] ) ) [EOL] fixture_path = os . path . join ( module_path , [string] ) [EOL] static_fixture_path = os . path . join ( module_path , [string] ) [EOL] [EOL] def fixture ( path ) : [EOL] return os . path . join ( fixture_path , path ) [EOL] [EOL] def static_fixture ( path ) : [EOL] return os . path . join ( static_fixture_path , path ) [EOL] [EOL] [EOL] def generate_test_name ( param ) : [EOL] if isinstance ( param [ [number] ] , filedev . FileDev ) : [EOL] return param [ [number] ] . f . name . split ( [string] ) [ - [number] ] [EOL] elif isinstance ( param [ [number] ] , raidzdev . RaidZDev ) : [EOL] return generate_test_name ( param [ [number] ] . devs ) [EOL] [EOL] feature_pools = { [string] : [ filedev . FileDev ( fixture ( [string] ) ) ] , [string] : [ filedev . FileDev ( fixture ( [string] ) ) ] , [string] : [ filedev . FileDev ( fixture ( [string] ) ) ] , [string] : [ filedev . FileDev ( fixture ( [string] ) ) ] , } [EOL] [EOL] old_version_pools = [ ] [EOL] for version in range ( [number] , [number] ) : [EOL] old_version_pools . append ( [ filedev . FileDev ( fixture ( [string] . format ( version ) ) ) ] ) [EOL] [EOL] @ pytest . fixture ( params = [ [ filedev . FileDev ( fixture ( [string] ) ) ] , [ filedev . FileDev ( fixture ( [string] ) ) ] , [ filedev . FileDev ( fixture ( [string] ) ) ] , [ filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , ] , [ filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , ] , [ filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , ] , [ filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , ] , [ raidzdev . RaidZDev ( [number] , [ filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , filedev . FileDev ( fixture ( [string] ) ) , ] ) ] , ] + list ( feature_pools . values ( ) ) + old_version_pools , ids = generate_test_name ) def zpool ( request ) : [EOL] zp = pool . Pool ( request . param ) [EOL] return zp [EOL] [EOL] @ pytest . fixture def complex_zpool ( ) : [EOL] return pool . Pool ( [ filedev . FileDev ( fixture ( [string] ) ) ] ) [EOL] [EOL] [EOL] @ pytest . fixture def lz4_zpool ( ) : [EOL] return pool . Pool ( [ filedev . FileDev ( fixture ( [string] ) ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.List[zfs.filedev.FileDev]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.List[zfs.filedev.FileDev]]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from fixtures import zpool [EOL] [EOL] [EOL] def test_ownership ( zpool ) : [EOL] directory = zpool . open ( [string] ) [EOL] c = directory [ [string] ] [EOL] assert c . attrs [ [string] ] == [number] [EOL] assert c . attrs [ [string] ] == [number] [EOL] [EOL] [EOL] def test_permissions ( zpool ) : [EOL] directory = zpool . open ( [string] ) [EOL] d = directory [ [string] ] [EOL] assert d . attrs [ [string] ] . perms == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from fixtures import zpool [EOL] [EOL] [EOL] def test_read_file ( zpool ) : [EOL] file_data = zpool . read_file ( [string] ) [EOL] expected = [string] * [number] [EOL] assert file_data == expected [EOL] file2 = zpool . read_file ( [string] ) [EOL] assert file2 == [string] [EOL] [EOL] [EOL] def test_read_in_directory ( zpool ) : [EOL] path = [string] [EOL] dir_ents = zpool . open ( path ) [EOL] assert all ( name in dir_ents for name in [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def test_read_in_subdirectory ( zpool ) : [EOL] path = [string] [EOL] dir_ents = zpool . open ( path ) [EOL] assert set ( dir_ents . keys ( ) ) == { [string] , [string] } [EOL] [EOL] [EOL] def test_read_in_nested_datasets ( zpool ) : [EOL] path = [string] [EOL] dir_ents = zpool . open ( path ) [EOL] assert set ( dir_ents . keys ( ) ) == { [string] , [string] } [EOL] [EOL] [EOL] def test_read_fatzap_directory ( zpool ) : [EOL] dir_ents = zpool . open ( [string] ) [EOL] assert [string] in dir_ents [EOL] assert [string] in dir_ents [EOL] assert [string] in dir_ents [EOL] assert [string] in dir_ents [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import zfs [EOL] import typing [EOL] import pytest [EOL] from fixtures import complex_zpool , lz4_zpool , fixture , static_fixture [EOL] [EOL] from zfs . constants import Compression [EOL] [EOL] compresion_modes = { [string] : Compression . GZIP_1 , [string] : Compression . GZIP_2 , [string] : Compression . GZIP_3 , [string] : Compression . GZIP_4 , [string] : Compression . GZIP_5 , [string] : Compression . GZIP_6 , [string] : Compression . GZIP_7 , [string] : Compression . GZIP_8 , [string] : Compression . GZIP_9 , [string] : Compression . LZJB , [string] : Compression . ZLE , } [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def file_contents ( ) : [EOL] return open ( static_fixture ( [string] ) , [string] ) . read ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , compresion_modes ) def test_zfs_compression ( mode , complex_zpool , file_contents ) : [EOL] root_dataset = complex_zpool . root_dataset [EOL] zfile = root_dataset [ mode ] [ mode ] [EOL] assert zfile . dnode . blkptr [ [number] ] . compression == compresion_modes [ mode ] [EOL] result = zfile . read ( ) == file_contents [EOL] assert result [EOL] [EOL] [EOL] def test_lz4_compression ( lz4_zpool , file_contents ) : [EOL] root_dataset = lz4_zpool . root_dataset [EOL] mode = [string] [EOL] zfile = root_dataset [ mode ] [ mode ] [EOL] assert zfile . dnode . blkptr [ [number] ] . compression == Compression . LZ4 [EOL] result = zfile . read ( ) == file_contents [EOL] assert result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,zfs.constants.Compression]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,zfs.constants.Compression]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,zfs.constants.Compression]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from zfs import objectset [EOL] [EOL] from fixtures import zpool [EOL] [EOL] [EOL] def test_objset ( zpool ) : [EOL] assert zpool . objset_for_vdev ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import zfs [EOL] import typing [EOL] import pytest [EOL] [EOL] from zfs import pool [EOL] [EOL] from fixtures import feature_pools [EOL] [EOL] @ pytest . mark . parametrize ( [string] , feature_pools ) def test_feature_active ( feature ) : [EOL] zp = pool . Pool ( feature_pools [ feature ] ) [EOL] features = zp . vdevs [ [number] ] . best_label [ [string] ] [EOL] assert feature in features [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import zfs [EOL] import typing [EOL] import pytest [EOL] from fixtures import complex_zpool [EOL] [EOL] from zfs . constants import Checksum [EOL] [EOL] checksums = { [string] : Checksum . FLETCHER_2 , [string] : Checksum . FLETCHER_4 , [string] : Checksum . SHA256 , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , checksums ) def test_checksums ( mode , complex_zpool ) : [EOL] root_dataset = complex_zpool . root_dataset [EOL] zfile = root_dataset [ mode ] [ mode ] [EOL] assert zfile . dnode . blkptr [ [number] ] . checksum_type == checksums [ mode ] [EOL] zfile . read ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,zfs.constants.Checksum]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,zfs.constants.Checksum]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,zfs.constants.Checksum]$ 0 0 0 0 0 0 0 0 0 0