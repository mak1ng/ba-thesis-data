from typing import Union , DefaultDict , Tuple , Dict , Any , List [EOL] import typing [EOL] import heapq [EOL] from collections import Counter [EOL] from collections import defaultdict [EOL] [EOL] [EOL] def huffman_encode ( string ) : [EOL] code_dict = defaultdict ( str ) if len ( set ( string ) ) > [number] else { string [ [number] ] : [string] } [EOL] heap = [ ( count , char ) for char , count in Counter ( string ) . items ( ) ] [EOL] heapq . heapify ( heap ) [EOL] while len ( heap ) > [number] : [EOL] first = heapq . heappop ( heap ) [EOL] second = heapq . heappop ( heap ) [EOL] new = ( first [ [number] ] + second [ [number] ] , first [ [number] ] + second [ [number] ] ) [EOL] for letter in first [ [number] ] : [EOL] code_dict [ letter ] += [string] [EOL] for letter in second [ [number] ] : [EOL] code_dict [ letter ] += [string] [EOL] heapq . heappush ( heap , new ) [EOL] return code_dict [EOL] [EOL] [EOL] def main ( ) : [EOL] string = input ( ) [EOL] code_dict = huffman_encode ( string ) [EOL] encode_string = [string] . join ( [ code_dict [ x ] for x in string ] ) [EOL] print ( len ( code_dict ) , len ( encode_string ) ) [EOL] for char , code in sorted ( code_dict . items ( ) ) : [EOL] print ( [string] . format ( char , code ) ) [EOL] print ( encode_string ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import src [EOL] import typing [EOL] import sys [EOL] from typing import List [EOL] [EOL] [EOL] class Heap : [EOL] def __init__ ( self ) : [EOL] self . data = [ ] [EOL] [EOL] def insert ( self , item ) : [EOL] self . data . append ( item ) [EOL] i = len ( self ) - [number] [EOL] parent = ( i - [number] ) // [number] [EOL] [EOL] while i > [number] and self . data [ parent ] < self . data [ i ] : [EOL] self . data [ i ] , self . data [ parent ] = self . data [ parent ] , self . data [ i ] [EOL] i = parent [EOL] parent = ( i - [number] ) // [number] [EOL] [EOL] def extract_max ( self ) : [EOL] assert len ( self ) > [number] , [string] [EOL] [EOL] result = self . data [ [number] ] [EOL] if len ( self ) == [number] : [EOL] self . data . pop ( ) [EOL] else : [EOL] self . data [ [number] ] = self . data . pop ( ) [EOL] self . heapify ( [number] ) [EOL] return result [EOL] [EOL] def heapify ( self , i ) : [EOL] while True : [EOL] left = [number] * i + [number] [EOL] right = [number] * i + [number] [EOL] largest = i [EOL] [EOL] if left < len ( self ) and self . data [ left ] > self . data [ largest ] : [EOL] largest = left [EOL] [EOL] if right < len ( self ) and self . data [ right ] > self . data [ largest ] : [EOL] largest = right [EOL] [EOL] if largest == i : [EOL] break [EOL] [EOL] self . data [ i ] , self . data [ largest ] = self . data [ largest ] , self . data [ i ] [EOL] i = largest [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . data ) [EOL] [EOL] [EOL] def main ( ) : [EOL] heap = Heap ( ) [EOL] _ = input ( ) [EOL] [EOL] for line in sys . stdin : [EOL] if line . startswith ( [string] ) : [EOL] _ , value = line . split ( ) [EOL] heap . insert ( int ( value ) ) [EOL] elif line . startswith ( [string] ) : [EOL] print ( heap . extract_max ( ) ) [EOL] else : [EOL] raise ValueError ( f" [string] { line }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict , Any , List , Deque [EOL] import builtins [EOL] import src [EOL] import typing [EOL] from collections import deque [EOL] from typing import Deque [EOL] from typing import Dict [EOL] from typing import Optional [EOL] [EOL] [EOL] class Node : [EOL] def __init__ ( self ) : [EOL] self . char = None [EOL] self . left = None [EOL] self . right = None [EOL] [EOL] @ staticmethod def from_codes ( codes ) : [EOL] root = Node ( ) [EOL] [EOL] for char , code in codes . items ( ) : [EOL] root . parse ( char , code ) [EOL] [EOL] return root [EOL] [EOL] def get_left ( self ) : [EOL] if self . left is None : [EOL] left = self . left = Node ( ) [EOL] else : [EOL] left = self . left [EOL] return left [EOL] [EOL] def get_right ( self ) : [EOL] if self . right is None : [EOL] right = self . right = Node ( ) [EOL] else : [EOL] right = self . right [EOL] return right [EOL] [EOL] def parse ( self , char , code ) : [EOL] if not code : [EOL] self . char = char [EOL] else : [EOL] if code . popleft ( ) == [string] : [EOL] child = self . get_left ( ) [EOL] else : [EOL] child = self . get_right ( ) [EOL] child . parse ( char , code ) [EOL] [EOL] def decode ( self , code ) : [EOL] result = [ ] [EOL] current = self [EOL] [EOL] for digit in code : [EOL] if digit == [string] : [EOL] current = current . get_left ( ) [EOL] else : [EOL] current = current . get_right ( ) [EOL] [EOL] if current . char : [EOL] result . append ( current . char ) [EOL] current = self [EOL] [EOL] return [string] . join ( result ) [EOL] [EOL] [EOL] def main ( ) : [EOL] unique_letters , length = [ int ( x ) for x in input ( ) . strip ( ) . split ( ) ] [EOL] codes = { } [EOL] for _ in range ( unique_letters ) : [EOL] char , code = input ( ) . strip ( ) . split ( [string] ) [EOL] codes [ char ] = deque ( code ) [EOL] encoded_string = input ( ) . strip ( ) [EOL] tree = Node . from_codes ( codes ) [EOL] print ( tree . decode ( encoded_string ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[Node]$ 0 0 0 0 0 $typing.Optional[Node]$ 0 0 0 0 0 0 0 $"Node"$ 0 $typing.Dict[builtins.str,typing.Deque[builtins.str]]$ 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Deque[builtins.str]]$ 0 0 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 0 0 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 $"Node"$ 0 0 0 0 0 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 0 0 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 $"Node"$ 0 0 0 0 0 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 0 0 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 $typing.Optional[src.module_4.huffman_decode.Node]$ 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Deque[builtins.str]$ 0 0 0 0 0 $typing.Deque[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Deque[builtins.str]$ 0 0 0 0 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 0 0 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Deque[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 $src.module_4.huffman_decode.Node$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import src [EOL] import typing [EOL] from typing import List [EOL] from typing import NamedTuple [EOL] [EOL] [EOL] class Thing ( NamedTuple ) : [EOL] price = ... [EOL] weight = ... [EOL] [EOL] @ property def unit_cost ( self ) : [EOL] return self . price / self . weight [EOL] [EOL] [EOL] def max_value ( capacity , data ) : [EOL] total_value = [number] [EOL] things = sorted ( data , key = lambda x : x . unit_cost , reverse = True ) [EOL] [EOL] for thing in things : [EOL] weight = min ( thing . weight , capacity ) [EOL] total_value += weight * thing . unit_cost [EOL] capacity -= weight [EOL] [EOL] if capacity == [number] : [EOL] break [EOL] return round ( total_value , [number] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] data = list ( ) [EOL] n , capacity = [ int ( x ) for x in input ( ) . split ( ) ] [EOL] [EOL] for _ in range ( n ) : [EOL] price , weight = [ int ( x ) for x in input ( ) . split ( ) ] [EOL] data . append ( Thing ( price , weight ) ) [EOL] [EOL] print ( max_value ( capacity , data ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import src [EOL] import typing [EOL] from typing import List [EOL] from typing import NamedTuple [EOL] [EOL] [EOL] class Section ( NamedTuple ) : [EOL] start = ... [EOL] end = ... [EOL] [EOL] [EOL] def section_dot_coverage ( sections ) : [EOL] sections = sorted ( sections , key = lambda x : x . end ) [EOL] dots = [ ] [EOL] [EOL] for section in sections : [EOL] if not dots or section . start > dots [ - [number] ] : [EOL] dots . append ( section . end ) [EOL] return dots [EOL] [EOL] [EOL] def main ( ) : [EOL] data = list ( ) [EOL] n = int ( input ( ) ) [EOL] [EOL] for _ in range ( n ) : [EOL] start , end = [ int ( x ) for x in input ( ) . split ( ) ] [EOL] data . append ( Section ( start , end ) ) [EOL] [EOL] dots = section_dot_coverage ( data ) [EOL] print ( len ( dots ) ) [EOL] print ( [string] . join ( str ( dot ) for dot in dots ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import typing [EOL] from typing import List [EOL] [EOL] [EOL] def different_summands ( number ) : [EOL] [docstring] [EOL] summand = [number] [EOL] remaining = number [EOL] summands = [ ] [EOL] [EOL] while remaining : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if remaining - summand <= summand : [EOL] summands . append ( remaining ) [EOL] break [EOL] [EOL] summands . append ( summand ) [EOL] remaining -= summand [EOL] summand += [number] [EOL] return summands [EOL] [EOL] [EOL] def main ( ) : [EOL] number = int ( input ( ) ) [EOL] summands = different_summands ( number ) [EOL] print ( len ( summands ) ) [EOL] print ( [string] . join ( str ( x ) for x in summands ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , List , Iterator [EOL] import builtins [EOL] import typing [EOL] import sys [EOL] from typing import List [EOL] [EOL] [EOL] def bin_find ( item , array ) : [EOL] left = [number] [EOL] right = len ( array ) - [number] [EOL] [EOL] while left <= right : [EOL] middle = ( left + right ) // [number] [EOL] [EOL] if array [ middle ] == item : [EOL] return middle [EOL] elif array [ middle ] > item : [EOL] right = middle - [number] [EOL] else : [EOL] left = middle + [number] [EOL] [EOL] return - [number] [EOL] [EOL] [EOL] def main ( ) : [EOL] scanner = ( map ( int , line . split ( ) ) for line in sys . stdin ) [EOL] [EOL] _ , * array = next ( scanner ) [EOL] _ , * items_to_find = next ( scanner ) [EOL] [EOL] for item in items_to_find : [EOL] index = bin_find ( item , array ) [EOL] print ( index if index == - [number] else index + [number] , end = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def fibonacci ( n ) : [EOL] [docstring] [EOL] a = [number] [EOL] b = [number] [EOL] for i in range ( n ) : [EOL] a , b = b , a + b [EOL] return a [EOL] [EOL] [EOL] def main ( ) : [EOL] n = int ( input ( ) ) [EOL] print ( fibonacci ( n ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def gcd ( a , b ) : [EOL] while b : [EOL] a , b = b , a % b [EOL] return a [EOL] [EOL] [EOL] def main ( ) : [EOL] a , b = map ( int , input ( ) . split ( ) ) [EOL] print ( gcd ( a , b ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] def count_sort ( n , lst ) : [EOL] [docstring] [EOL] b = [ [number] ] * [number] [EOL] k = [number] [EOL] [EOL] for i in range ( [number] , n ) : [EOL] b [ lst [ i ] ] += [number] [EOL] for i in range ( [number] , [number] ) : [EOL] for j in range ( [number] , b [ i ] + [number] ) : [EOL] lst [ k ] = i [EOL] k += [number] [EOL] lst = [ str ( e ) for e in lst ] [EOL] print ( [string] . join ( lst ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import math [EOL] [EOL] [EOL] def f1 ( n ) : [EOL] return [number] ** math . log ( n , [number] ) [EOL] [EOL] [EOL] def f2 ( n ) : [EOL] return n ** math . log ( n , [number] ) [EOL] [EOL] [EOL] def f3 ( n ) : [EOL] return [number] ** n [EOL] [EOL] [EOL] def f4 ( n ) : [EOL] return [number] ** n [EOL] [EOL] [EOL] def f5 ( n ) : [EOL] return math . log ( n , [number] ) [EOL] [EOL] [EOL] def f6 ( n ) : [EOL] return math . sqrt ( n ) [EOL] [EOL] [EOL] def f7 ( n ) : [EOL] return math . log ( math . factorial ( n ) , [number] ) [EOL] [EOL] [EOL] def f8 ( n ) : [EOL] return n ** [number] [EOL] [EOL] [EOL] def f9 ( n ) : [EOL] return [number] ** math . log ( n , [number] ) [EOL] [EOL] [EOL] def f10 ( n ) : [EOL] return [number] ** ( [number] ** n ) [EOL] [EOL] [EOL] def f11 ( n ) : [EOL] return math . log ( math . log ( n , [number] ) , [number] ) [EOL] [EOL] [EOL] def f12 ( n ) : [EOL] return ( math . log ( n , [number] ) ) ** [number] [EOL] [EOL] [EOL] def f13 ( n ) : [EOL] return ( math . log ( n , [number] ) ) ** ( math . log ( n , [number] ) ) [EOL] [EOL] [EOL] def f14 ( n ) : [EOL] return math . sqrt ( math . log ( n , [number] ) ) [EOL] [EOL] [EOL] def f15 ( n ) : [EOL] return n / ( math . log ( n , [number] ) ) [EOL] [EOL] [EOL] def f16 ( n ) : [EOL] return math . factorial ( n ) [EOL] [EOL] [EOL] def f17 ( n ) : [EOL] return n ** ( math . sqrt ( n ) ) [EOL] [EOL] [EOL] def test ( n ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] print ( [string] , int ( f11 ( n ) ) ) [EOL] [comment] [EOL] [comment] [EOL] print ( [string] , int ( f14 ( n ) ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] test ( [number] ** [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] def fib_mod ( n , m ) : [EOL] modules = [ [number] , [number] ] [EOL] i = [number] [EOL] [EOL] while not ( modules [ i - [number] ] == [number] and modules [ i - [number] ] == [number] ) or i <= [number] : [EOL] modules . append ( ( modules [ i - [number] ] + modules [ i - [number] ] ) % m ) [EOL] i += [number] [EOL] [EOL] return modules [ n % ( i - [number] ) ] [EOL] [EOL] [EOL] def main ( ) : [EOL] n , m = map ( int , input ( ) . split ( ) ) [EOL] print ( fib_mod ( n , m ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] from typing import List [EOL] [EOL] import pytest [EOL] [EOL] from src . module_6 . binary_search import bin_find [EOL] [EOL] [EOL] @ pytest . fixture def odd_array ( ) : [EOL] return [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] [EOL] @ pytest . fixture def even_array ( ) : [EOL] return [ [number] , [number] , [number] , [number] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , - [number] ) ] ) def test_bin_find_odd_array ( item , odd_array , index ) : [EOL] assert bin_find ( item , odd_array ) == index [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , - [number] ) ] ) def test_bin_find_even_array ( item , even_array , index ) : [EOL] assert bin_find ( item , even_array ) == index [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from src . module_2 . fibonacci import fibonacci [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] , ) def test_fibonacci ( n , expected ) : [EOL] assert fibonacci ( n ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from src . module_2 . fibonacci_last import fib_digit [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] , ) def test_fib_digit ( n , expected ) : [EOL] assert fib_digit ( n ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from src . module_2 . big_fibonacci import fib_mod [EOL] [EOL] [EOL] def test_fib_mod ( ) : [EOL] assert fib_mod ( [number] , [number] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from src . module_4 . section_dot_coverage import Section [EOL] from src . module_4 . section_dot_coverage import section_dot_coverage [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ Section ( [number] , [number] ) , Section ( [number] , [number] ) , Section ( [number] , [number] ) ] , [ [number] ] ) , ( [ Section ( [number] , [number] ) , Section ( [number] , [number] ) , Section ( [number] , [number] ) , Section ( [number] , [number] ) ] , [ [number] , [number] ] ) , ] , ) def test_section_dot_coverage ( sections , dots ) : [EOL] assert section_dot_coverage ( sections ) == dots [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from src . module_4 . continuous_backpack import max_value [EOL] from src . module_4 . continuous_backpack import Thing [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [ Thing ( [number] , [number] ) , Thing ( [number] , [number] ) , Thing ( [number] , [number] ) ] , [number] ) ] , ) def test_max_value ( capacity , things , expected ) : [EOL] assert max_value ( capacity , things ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from src . module_4 . huffman_code import Tree [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) ] ) def test_encoding ( string , expected ) : [EOL] assert Tree . from_string ( string ) . encoded_string == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import src [EOL] from collections import deque [EOL] [EOL] import pytest [EOL] [EOL] from src . module_4 . huffman_decode import Node [EOL] [EOL] [EOL] @ pytest . fixture def codes ( ) : [EOL] return { [string] : deque ( [string] ) , [string] : deque ( [string] ) , [string] : deque ( [string] ) , [string] : deque ( [string] ) , } [EOL] [EOL] [EOL] def test_from_codes ( codes ) : [EOL] root = Node . from_codes ( codes ) [EOL] assert root . left . char == [string] [EOL] assert root . right . left . char == [string] [EOL] assert root . right . right . left . char == [string] [EOL] assert root . right . right . right . char == [string] [EOL] [EOL] [EOL] def test_decode ( codes ) : [EOL] tree = Node . from_codes ( codes ) [EOL] assert tree . decode ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from src . module_4 . different_summands import different_summands [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [ [number] , [number] ] ) , ( [number] , [ [number] , [number] , [number] ] ) ] ) def test_different_summands ( n , summands ) : [EOL] assert different_summands ( n ) == summands [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import src [EOL] import typing [EOL] import pytest [EOL] [EOL] from src . module_4 . custom_heap import Heap [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [ [number] , [number] ] , ) , ( [string] , [ [number] , [number] , [number] , [number] ] , ) , ] , ) def test_initial_example ( commands , expected ) : [EOL] heap = Heap ( ) [EOL] output = [ ] [EOL] [EOL] for command in commands . strip ( ) . split ( [string] ) : [EOL] command = command . strip ( ) [EOL] if command . startswith ( [string] ) : [EOL] _ , value = command . split ( ) [EOL] heap . insert ( int ( value ) ) [EOL] elif command . startswith ( [string] ) : [EOL] output . append ( heap . extract_max ( ) ) [EOL] else : [EOL] raise ValueError ( f" [string] { command }" ) [EOL] [EOL] assert output == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0