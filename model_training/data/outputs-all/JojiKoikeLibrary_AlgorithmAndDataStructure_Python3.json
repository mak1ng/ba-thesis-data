	0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def power ( x , n , m ) : [EOL] [docstring] [EOL] res = [number] [EOL] if n > [number] : [EOL] res = power ( x , int ( n / [number] ) , m ) [EOL] if n % [number] == [number] : [EOL] res = ( res * res ) % m [EOL] else : [EOL] res = ( ( ( res * res ) % m ) * x ) % m [EOL] return res [EOL] [EOL] [EOL] def is_prime ( n ) : [EOL] [docstring] [EOL] if n <= [number] : [EOL] [comment] [EOL] return False [EOL] if n % [number] == [number] : [EOL] [comment] [EOL] return False [EOL] i = [number] [EOL] while i * i <= n : [EOL] if n % i == [number] : [EOL] return False [EOL] i += [number] [EOL] return True [EOL] [EOL] [EOL] def gcd ( x , y ) : [EOL] [docstring] [EOL] if x < y : [EOL] x , y = y , x [EOL] while y > [number] : [EOL] r = x % y [EOL] x = y [EOL] y = r [EOL] return x [EOL]	0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import heuristicsearch [EOL] import unittest [EOL] from typing import List [EOL] from heuristicsearch . structs import Queen [EOL] from heuristicsearch . methods import eight_queen_solver , eight_puzzle_solver , sixteen_puzzle_solver_ida_star , sixteen_puzzle_solver_a_star [EOL] [EOL] [EOL] class HeuristicSearchMethodTestCase ( unittest . TestCase ) : [EOL] def test_eight_queen_solver_normal ( self ) : [EOL] queens = [ Queen ( [number] , [number] ) , Queen ( [number] , [number] ) ] [EOL] res = eight_queen_solver ( queens ) [EOL] self . assertEqual ( [number] , len ( res ) ) [EOL] self . assertEqual ( [number] , len ( res [ [number] ] ) ) [EOL] [EOL] def test_eight_puzzle_solver_normal ( self ) : [EOL] data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] res = eight_puzzle_solver ( data ) [EOL] self . assertEqual ( [number] , res ) [EOL] [EOL] def test_sixteen_puzzle_solver_ida_star_normal ( self ) : [EOL] data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] res = sixteen_puzzle_solver_ida_star ( data ) [EOL] self . assertEqual ( [number] , res ) [EOL] [EOL] def test_sixteen_puzzle_solver_a_star_normal ( self ) : [EOL] data = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] res = sixteen_puzzle_solver_a_star ( data ) [EOL] self . assertEqual ( [number] , res ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[heuristicsearch.structs.Queen]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 $typing.List[heuristicsearch.structs.Queen]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import unittest [EOL] from number . methods import power , is_prime , gcd [EOL] [EOL] [EOL] class NumberMethodTestCase ( unittest . TestCase ) : [EOL] [EOL] def test_power_normal ( self ) : [EOL] self . assertEqual ( power ( [number] , [number] , [number] ) , [number] ) [EOL] [EOL] def test_is_prime_normal ( self ) : [EOL] [comment] [EOL] self . assertEqual ( False , is_prime ( [number] ) ) [EOL] self . assertEqual ( False , is_prime ( [number] ) ) [EOL] [comment] [EOL] self . assertEqual ( False , is_prime ( [number] ) ) [EOL] [comment] [EOL] self . assertEqual ( False , is_prime ( [number] ) ) [EOL] [comment] [EOL] self . assertEqual ( True , is_prime ( [number] ) ) [EOL] [EOL] def test_gcd_normal ( self ) : [EOL] self . assertEqual ( [number] , gcd ( [number] , [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import graph [EOL] import unittest [EOL] from graph . structs import Edge [EOL] from typing import List [EOL] [EOL] [EOL] class GraphStructsTestCase ( unittest . TestCase ) : [EOL] def test_edge_normal ( self ) : [EOL] edges = [ Edge ( [number] , [number] , [number] ) , Edge ( [number] , [number] , [number] ) , Edge ( [number] , [number] , [number] ) ] [EOL] edges . sort ( ) [EOL] expects = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] for i , edge in enumerate ( edges ) : [EOL] self . assertEqual ( expects [ i ] [ [number] ] , edge . source ) [EOL] self . assertEqual ( expects [ i ] [ [number] ] , edge . destination ) [EOL] self . assertEqual ( expects [ i ] [ [number] ] , edge . weight ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graph.structs.Edge]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graph.structs.Edge]$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graph.structs.Edge]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import graph [EOL] import unittest [EOL] from typing import List [EOL] from graph . common import INFINITY [EOL] from graph . methods import warshall_floyd , topological_sort , articulation_point , calc_tree_diameter , kruskal [EOL] from graph . structs import Edge [EOL] [EOL] [EOL] class GraphMethodsTestCase ( unittest . TestCase ) : [EOL] [EOL] def test_warshall_floyd_normal ( self ) : [EOL] dt = [ [ [number] if j == i else INFINITY for j in range ( [number] ) ] for i in range ( [number] ) ] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] res = warshall_floyd ( dt ) [EOL] expect = [ [ [number] , [number] , [number] , [number] ] , [ INFINITY , [number] , [number] , [number] ] , [ INFINITY , INFINITY , [number] , [number] ] , [ INFINITY , INFINITY , [number] , [number] ] ] [EOL] for i in range ( [number] ) : [EOL] for j in range ( [number] ) : [EOL] self . assertEqual ( expect [ i ] [ j ] , res [ i ] [ j ] ) [EOL] [EOL] def test_warshall_floyd_negative_roop ( self ) : [EOL] dt = [ [ [number] if j == i else INFINITY for j in range ( [number] ) ] for i in range ( [number] ) ] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = [number] [EOL] dt [ [number] ] [ [number] ] = - [number] [EOL] res = warshall_floyd ( dt ) [EOL] self . assertIsNone ( res ) [EOL] [EOL] def test_topological_sort_normal ( self ) : [EOL] adj_table = [ [ [number] ] , [ [number] ] , [ ] , [ [number] , [number] ] , [ [number] ] , [ [number] ] ] [EOL] res = topological_sort ( adj_table ) [EOL] for i , id in enumerate ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) : [EOL] self . assertEqual ( res [ i ] , id ) [EOL] [EOL] def test_articulation_point_normal ( self ) : [EOL] graph = [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] ] ] [EOL] res = articulation_point ( graph ) [EOL] self . assertEqual ( [number] , len ( res ) ) [EOL] self . assertEqual ( [number] , res [ [number] ] ) [EOL] [EOL] def test_calc_tree_diameter_normal ( self ) : [EOL] graph = [ [ Edge ( None , [number] , [number] ) ] , [ Edge ( None , [number] , [number] ) , Edge ( None , [number] , [number] ) , Edge ( None , [number] , [number] ) ] , [ Edge ( None , [number] , [number] ) ] , [ Edge ( None , [number] , [number] ) ] ] [EOL] res = calc_tree_diameter ( graph ) [EOL] self . assertEqual ( [number] , res ) [EOL] [EOL] def test_kruskal_normal ( self ) : [EOL] inputs = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] edges = [ ] [EOL] for inp in inputs : [EOL] edges . append ( Edge ( inp [ [number] ] , inp [ [number] ] , inp [ [number] ] ) ) [EOL] res = kruskal ( len ( inputs ) , edges ) [EOL] self . assertEqual ( [number] , res ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.List]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[Edge]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.List[Edge]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[graph.structs.Edge]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 $typing.List[graph.structs.Edge]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 $typing.List[graph.structs.Edge]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import geometry [EOL] [docstring] [EOL] import unittest [EOL] from geometry . structs import Point , Vector , Segment , Circle [EOL] [EOL] [EOL] class GeometryStructsTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] def test_defined_point_correctly ( self ) : [EOL] [docstring] [EOL] for i in range ( - [number] , [number] ) : [EOL] for j in range ( - [number] , [number] ) : [EOL] point = Point ( i * [number] , j * [number] ) [EOL] self . assertEqual ( point . x , i * [number] ) [EOL] self . assertEqual ( point . y , j * [number] ) [EOL] if i == - [number] : [EOL] self . assertEqual ( point < Point ( [number] , [number] ) , True ) [EOL] elif i == [number] : [EOL] self . assertEqual ( point < Point ( [number] , [number] ) , j == - [number] ) [EOL] else : [EOL] self . assertEqual ( point < Point ( [number] , [number] ) , False ) [EOL] [EOL] def test_defined_vector_correctly ( self ) : [EOL] v_1 = Vector ( [number] , [number] ) [EOL] v_2 = Vector ( [number] , [number] ) [EOL] self . assertEqual ( v_1 . x , [number] ) [EOL] self . assertEqual ( v_1 . y , [number] ) [EOL] self . assertEqual ( v_1 . dot ( v_2 ) , [number] ) [EOL] self . assertEqual ( v_1 . cross ( v_2 ) , - [number] ) [EOL] self . assertEqual ( ( v_1 + v_2 ) . x , [number] ) [EOL] self . assertEqual ( ( v_1 + v_2 ) . y , [number] ) [EOL] self . assertEqual ( ( v_1 - v_2 ) . x , - [number] ) [EOL] self . assertEqual ( ( v_1 - v_2 ) . y , - [number] ) [EOL] self . assertEqual ( ( v_1 * [number] ) . x , [number] ) [EOL] self . assertEqual ( ( v_1 * [number] ) . y , [number] ) [EOL] self . assertEqual ( ( v_1 / [number] ) . x , [number] ) [EOL] self . assertEqual ( ( v_1 / [number] ) . y , [number] ) [EOL] self . assertEqual ( v_1 == v_2 , False ) [EOL] self . assertEqual ( v_1 == Vector ( [number] , [number] ) , True ) [EOL] [EOL] def test_defined_segment_correctly ( self ) : [EOL] [docstring] [EOL] segment = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] self . assertEqual ( segment . p1 . x , [number] ) [EOL] self . assertEqual ( segment . p1 . y , [number] ) [EOL] self . assertEqual ( segment . p2 . x , [number] ) [EOL] self . assertEqual ( segment . p2 . y , [number] ) [EOL] [EOL] def test_defined_circle_correctly ( self ) : [EOL] [docstring] [EOL] circle = Circle ( Point ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( circle . c . x , [number] ) [EOL] self . assertEqual ( circle . c . y , [number] ) [EOL] self . assertEqual ( circle . r , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import geometry [EOL] [docstring] [EOL] import unittest [EOL] import math [EOL] from typing import List [EOL] from geometry . structs import Point , Vector , Segment , Line , Circle , Polygon [EOL] from geometry . methods import is_orthogonal , is_parallel , project , reflect , get_distance , get_distance_lp , get_distance_sp , get_point_relative_position , intersect , get_distance_ss , get_cross_point , get_cross_points_circle_and_line , get_common_points_circle_and_circle , point_contained_in_polygon , get_convex_hull , get_num_of_segment_intersections [EOL] from geometry . common import equals , PointRelativePosition , PointContainsInPolygon [EOL] [EOL] [EOL] class GeometryMethodTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] def test_is_orthogonal_normal ( self ) : [EOL] [comment] [EOL] v_1 = Vector ( [number] , [number] ) [EOL] v_2 = Vector ( [number] , - [number] ) [EOL] self . assertEqual ( is_orthogonal ( v_1 , v_2 ) , True ) [EOL] [comment] [EOL] p_1 = Point ( [number] , [number] ) [EOL] p_2 = Point ( [number] , [number] ) [EOL] p_3 = Point ( [number] , - [number] ) [EOL] p_4 = Point ( [number] , - [number] ) [EOL] self . assertEqual ( is_orthogonal ( p_1 , p_2 , p_3 , p_4 ) , True ) [EOL] [comment] [EOL] s_1 = Segment ( p_1 , p_2 ) [EOL] s_2 = Segment ( p_3 , p_4 ) [EOL] self . assertEqual ( is_orthogonal ( s_1 , s_2 ) , True ) [EOL] [EOL] def test_is_parallel_normal ( self ) : [EOL] [comment] [EOL] v_1 = Vector ( [number] , [number] ) [EOL] v_2 = Vector ( [number] , [number] ) [EOL] self . assertEqual ( is_parallel ( v_1 , v_2 ) , True ) [EOL] [comment] [EOL] p_1 = Point ( [number] , [number] ) [EOL] p_2 = Point ( [number] , [number] ) [EOL] p_3 = Point ( - [number] , - [number] ) [EOL] p_4 = Point ( - [number] , - [number] ) [EOL] self . assertEqual ( is_parallel ( p_1 , p_2 , p_3 , p_4 ) , True ) [EOL] [comment] [EOL] s_1 = Segment ( p_1 , p_2 ) [EOL] s_2 = Segment ( p_3 , p_4 ) [EOL] self . assertEqual ( is_parallel ( s_1 , s_2 ) , True ) [EOL] [EOL] def test_project_normal ( self ) : [EOL] seg = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] p = Point ( [number] , [number] ) [EOL] self . assertEqual ( equals ( project ( seg , p ) . x , [number] ) , True ) [EOL] self . assertEqual ( equals ( project ( seg , p ) . y , [number] ) , True ) [EOL] [EOL] def test_reflect_normal ( self ) : [EOL] seg = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] p = Point ( [number] , [number] ) [EOL] self . assertEqual ( equals ( reflect ( seg , p ) . x , [number] ) , True ) [EOL] self . assertEqual ( equals ( reflect ( seg , p ) . y , [number] ) , True ) [EOL] [EOL] def test_get_distance_normal ( self ) : [EOL] p_1 = Point ( [number] , [number] ) [EOL] p_2 = Point ( [number] , [number] ) [EOL] self . assertEqual ( equals ( get_distance ( p_1 , p_2 ) , math . sqrt ( [number] ) ) , True ) [EOL] [EOL] def test_get_distance_lp_normal ( self ) : [EOL] l = Line ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] p = Point ( [number] , [number] ) [EOL] self . assertEqual ( equals ( get_distance_lp ( l , p ) , [number] / math . sqrt ( [number] ) ) , True ) [EOL] [EOL] def test_get_distance_sp_normal ( self ) : [EOL] p_l = Point ( - [number] , - [number] ) [EOL] p_r = Point ( [number] , [number] ) [EOL] s = Segment ( p_l , p_r ) [EOL] p_1 = Point ( - [number] , - [number] ) [EOL] p_2 = Point ( [number] , [number] ) [EOL] p_3 = Point ( [number] , [number] ) [EOL] self . assertEqual ( equals ( get_distance_sp ( s , p_1 ) , ( p_1 - p_l ) . abs ( ) ) , True ) [EOL] self . assertEqual ( equals ( get_distance_sp ( s , p_2 ) , [number] / math . sqrt ( [number] ) ) , True ) [EOL] self . assertEqual ( equals ( get_distance_sp ( s , p_3 ) , ( p_3 - p_r ) . abs ( ) ) , True ) [EOL] [EOL] def test_get_distance_ss_normal ( self ) : [EOL] s_0 = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] s_1 = Segment ( Point ( - [number] , - [number] ) , Point ( - [number] , - [number] ) ) [EOL] s_2 = Segment ( Point ( [number] , - [number] ) , Point ( [number] , - [number] ) ) [EOL] s_3 = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] self . assertEqual ( equals ( get_distance_ss ( s_0 , s_1 ) , math . sqrt ( [number] ) ) , True ) [EOL] self . assertEqual ( equals ( get_distance_ss ( s_0 , s_2 ) , math . sqrt ( [number] ) ) , True ) [EOL] self . assertEqual ( equals ( get_distance_ss ( s_0 , s_3 ) , [number] ) , True ) [EOL] [EOL] def test_get_point_relative_position_normal ( self ) : [EOL] p_0 = Point ( [number] , [number] ) [EOL] p_1 = Point ( [number] , [number] ) [EOL] self . assertEqual ( get_point_relative_position ( p_0 , p_1 , Point ( - [number] , [number] ) ) , PointRelativePosition . COUNTER_CLOCK_WISE ) [EOL] self . assertEqual ( get_point_relative_position ( p_0 , p_1 , Point ( - [number] , - [number] ) ) , PointRelativePosition . CLOCK_WISE ) [EOL] self . assertEqual ( get_point_relative_position ( p_0 , p_1 , Point ( - [number] , [number] ) ) , PointRelativePosition . ON_LINE_BACK ) [EOL] self . assertEqual ( get_point_relative_position ( p_0 , p_1 , Point ( [number] , [number] ) ) , PointRelativePosition . ON_LINE_FRONT ) [EOL] self . assertEqual ( get_point_relative_position ( p_0 , p_1 , Point ( [number] , [number] ) ) , PointRelativePosition . ON_SEGMENT ) [EOL] [EOL] def test_intersect_normal ( self ) : [EOL] s_1 = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] s_2 = Segment ( Point ( [number] , [number] ) , Point ( [number] , - [number] ) ) [EOL] s_3 = Segment ( Point ( [number] , [number] ) , Point ( [number] , - [number] ) ) [EOL] s_4 = Segment ( Point ( [number] , - [number] ) , Point ( [number] , [number] ) ) [EOL] self . assertEqual ( intersect ( s_1 , s_2 ) , True ) [EOL] self . assertEqual ( intersect ( s_1 , s_3 ) , True ) [EOL] self . assertEqual ( intersect ( s_1 , s_4 ) , False ) [EOL] [EOL] def test_get_cross_point_normal ( self ) : [EOL] s_1 = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] s_2 = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] s_3 = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] s_4 = Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] self . assertEqual ( equals ( get_cross_point ( s_1 , s_2 ) . x , [number] ) , True ) [EOL] self . assertEqual ( equals ( get_cross_point ( s_1 , s_2 ) . y , [number] ) , True ) [EOL] self . assertEqual ( equals ( get_cross_point ( s_1 , s_3 ) . x , [number] ) , True ) [EOL] self . assertEqual ( equals ( get_cross_point ( s_1 , s_3 ) . y , [number] ) , True ) [EOL] self . assertIsNone ( get_cross_point ( s_1 , s_4 ) ) [EOL] [EOL] def test_get_cross_point_line_and_circle ( self ) : [EOL] c_0 = Circle ( Point ( [number] , [number] ) , [number] ) [EOL] l_1 = Line ( Point ( [number] , - [number] ) , Point ( [number] , - [number] ) ) [EOL] l_2 = Line ( Point ( [number] , - [number] ) , Point ( [number] , - [number] ) ) [EOL] l_3 = Line ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) [EOL] self . assertIsNone ( get_cross_points_circle_and_line ( c_0 , l_1 ) ) [EOL] self . assertEqual ( len ( get_cross_points_circle_and_line ( c_0 , l_2 ) ) , [number] ) [EOL] self . assertTrue ( equals ( get_cross_points_circle_and_line ( c_0 , l_2 ) [ [number] ] . x , [number] ) ) [EOL] self . assertTrue ( equals ( get_cross_points_circle_and_line ( c_0 , l_2 ) [ [number] ] . y , - [number] ) ) [EOL] self . assertEqual ( len ( get_cross_points_circle_and_line ( c_0 , l_3 ) ) , [number] ) [EOL] self . assertTrue ( equals ( get_cross_points_circle_and_line ( c_0 , l_3 ) [ [number] ] . x , [number] + math . sqrt ( [number] ) ) ) [EOL] self . assertTrue ( equals ( get_cross_points_circle_and_line ( c_0 , l_3 ) [ [number] ] . x , [number] - math . sqrt ( [number] ) ) ) [EOL] [EOL] def test_get_common_points_circle_and_circle_normal ( self ) : [EOL] c_1 = Circle ( Point ( [number] , [number] ) , [number] ) [EOL] c_2 = Circle ( Point ( [number] , [number] ) , [number] ) [EOL] [comment] [EOL] res = get_common_points_circle_and_circle ( c_1 , c_2 ) [EOL] self . assertEqual ( len ( res ) , [number] ) [EOL] self . assertTrue ( equals ( res [ [number] ] . x , [number] * [number] / [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . y , [number] * math . sqrt ( [number] ) / [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . x , [number] * [number] / [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . y , - [number] * math . sqrt ( [number] ) / [number] ) ) [EOL] c_2_1 = Circle ( Point ( [number] , [number] ) , [number] ) [EOL] res = get_common_points_circle_and_circle ( c_1 , c_2_1 ) [EOL] self . assertEqual ( len ( res ) , [number] ) [EOL] self . assertTrue ( equals ( res [ [number] ] . x , - [number] * math . sqrt ( [number] ) / [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . y , [number] * [number] / [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . x , [number] * math . sqrt ( [number] ) / [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . y , [number] * [number] / [number] ) ) [EOL] c_2_2 = Circle ( Point ( [number] , [number] ) , [number] ) [EOL] res = get_common_points_circle_and_circle ( c_1 , c_2_2 ) [EOL] self . assertEqual ( len ( res ) , [number] ) [EOL] self . assertTrue ( equals ( res [ [number] ] . x , [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . y , [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . x , [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . y , [number] ) ) [EOL] [comment] [EOL] c_3 = Circle ( Point ( [number] , [number] ) , [number] ) [EOL] res = get_common_points_circle_and_circle ( c_1 , c_3 ) [EOL] self . assertEqual ( len ( res ) , [number] ) [EOL] self . assertTrue ( equals ( res [ [number] ] . x , [number] ) ) [EOL] self . assertTrue ( equals ( res [ [number] ] . y , [number] ) ) [EOL] [comment] [EOL] c_4 = Circle ( Point ( [number] , [number] ) , [number] ) [EOL] res = get_common_points_circle_and_circle ( c_1 , c_4 ) [EOL] self . assertIsNone ( res ) [EOL] c_5 = Circle ( Point ( [number] , [number] ) , [number] ) [EOL] res = get_common_points_circle_and_circle ( c_1 , c_5 ) [EOL] self . assertIsNone ( res ) [EOL] [comment] [EOL] res = get_common_points_circle_and_circle ( c_1 , c_1 ) [EOL] self . assertIsNone ( res ) [EOL] [EOL] def test_point_contained_in_polygon ( self ) : [EOL] poly = Polygon ( [ Point ( [number] , [number] ) , Point ( [number] , [number] ) , Point ( [number] , [number] ) , Point ( [number] , [number] ) ] ) [EOL] p_1 = Point ( [number] , [number] ) [EOL] self . assertEqual ( point_contained_in_polygon ( poly , p_1 ) , PointContainsInPolygon . IN ) [EOL] p_2 = Point ( [number] , [number] ) [EOL] self . assertEqual ( point_contained_in_polygon ( poly , p_2 ) , PointContainsInPolygon . ON_EDGE ) [EOL] p_3 = Point ( [number] , [number] ) [EOL] self . assertEqual ( point_contained_in_polygon ( poly , p_3 ) , PointContainsInPolygon . OUT ) [EOL] [EOL] def test_get_convex_hull_normal ( self ) : [EOL] poly = Polygon ( [ Point ( [number] , [number] ) , Point ( [number] , [number] ) , Point ( [number] , [number] ) , Point ( [number] , [number] ) , Point ( [number] , [number] ) , Point ( [number] , [number] ) , Point ( [number] , [number] ) ] ) [EOL] res = get_convex_hull ( poly ) [EOL] self . assertEqual ( [number] , len ( res . p_i ) ) [EOL] x_expected = [ [number] , [number] , [number] , [number] , [number] ] [EOL] y_expected = [ [number] , [number] , [number] , [number] , [number] ] [EOL] for i in range ( [number] ) : [EOL] self . assertTrue ( equals ( res . p_i [ i ] . x , x_expected [ i ] ) ) [EOL] self . assertTrue ( equals ( res . p_i [ i ] . y , y_expected [ i ] ) ) [EOL] [EOL] def test_get_num_of_segment_intersections_normal ( self ) : [EOL] segments = [ Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) , Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) , Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) , Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) , Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) , Segment ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) ] [EOL] self . assertEqual ( [number] , get_num_of_segment_intersections ( segments ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 $geometry.structs.Segment$ 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Vector$ 0 $geometry.structs.Vector$ 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 $geometry.structs.Segment$ 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Line$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Point$ 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Point$ 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Segment$ 0 $geometry.structs.Segment$ 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Line$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Circle$ 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 $geometry.structs.Circle$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Circle$ 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 $geometry.structs.Circle$ 0 $geometry.structs.Circle$ 0 0 0 0 0 0 $typing.List[geometry.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Polygon$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Polygon$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Polygon$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Polygon$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Polygon$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Polygon$ 0 0 0 $geometry.structs.Polygon$ 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Polygon$ 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Polygon$ 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Polygon$ 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Segment]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[geometry.structs.Segment]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import dynamicprogramming [EOL] import unittest [EOL] from typing import List [EOL] from dynamicprogramming . methods import coin_changing_problem , zero_one_knapsack_problem , lis , get_largest_square , get_largest_rectangle [EOL] from dynamicprogramming . structs import Item [EOL] [EOL] [EOL] class DynamicProgrammingTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] def test_coin_changing_problem ( self ) : [EOL] coins = [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] res = coin_changing_problem ( coins , [number] ) [EOL] self . assertEqual ( [number] , res ) [EOL] [EOL] def test_zero_one_knapsack_problem_normal ( self ) : [EOL] weight = [number] [EOL] items = [ Item ( [number] , [number] ) , Item ( [number] , [number] ) , Item ( [number] , [number] ) , Item ( [number] , [number] ) ] [EOL] max_value = ... [EOL] selections = ... [EOL] max_value , selections = zero_one_knapsack_problem ( items , weight ) [EOL] self . assertEqual ( [number] , max_value ) [EOL] selections_expects = [ [number] , [number] ] [EOL] for i , selections_expect in enumerate ( selections_expects ) : [EOL] self . assertEqual ( selections_expect , selections [ i ] ) [EOL] [EOL] def test_lis_normal ( self ) : [EOL] self . assertEqual ( [number] , lis ( [ [number] , [number] , [number] , [number] , [number] ] ) ) [EOL] [EOL] def test_get_largest_square_normal ( self ) : [EOL] g = [ [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] ] [EOL] res = get_largest_square ( g ) [EOL] self . assertEqual ( [number] , res ) [EOL] [EOL] def test_get_largest_rectangle_normal ( self ) : [EOL] g = [ [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] ] [EOL] self . assertEqual ( [number] , get_largest_rectangle ( g ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[dynamicprogramming.structs.Item]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[dynamicprogramming.structs.Item]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import datastructure [EOL] [docstring] [EOL] import unittest [EOL] from typing import List [EOL] from datastructure . structs import DisjointSet , Point [EOL] [EOL] [EOL] class DataStructureStructsTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] def test_disjoint_set_normal ( self ) : [EOL] ds = DisjointSet ( [number] ) [EOL] ds . unite ( [number] , [number] ) [EOL] ds . unite ( [number] , [number] ) [EOL] self . assertFalse ( ds . same ( [number] , [number] ) ) [EOL] self . assertFalse ( ds . same ( [number] , [number] ) ) [EOL] self . assertTrue ( ds . same ( [number] , [number] ) ) [EOL] self . assertTrue ( ds . same ( [number] , [number] ) ) [EOL] ds . unite ( [number] , [number] ) [EOL] self . assertTrue ( ds . same ( [number] , [number] ) ) [EOL] self . assertFalse ( ds . same ( [number] , [number] ) ) [EOL] ds . unite ( [number] , [number] ) [EOL] self . assertTrue ( ds . same ( [number] , [number] ) ) [EOL] self . assertTrue ( ds . same ( [number] , [number] ) ) [EOL] [EOL] def test_point_normal ( self ) : [EOL] points = [ Point ( i , i + [number] , i + [number] ) for i in range ( [number] ) ] [EOL] sorted ( points , reverse = True ) [EOL] for i in range ( [number] , - [number] , - [number] ) : [EOL] self . assertEqual ( points [ i ] . point_id , i ) [EOL] self . assertEqual ( points [ i ] . x , i + [number] ) [EOL] self . assertEqual ( points [ i ] . y , i + [number] ) [EOL] print ( points [ i ] ) [EOL] [EOL] def test_point_sort_by_x_normal ( self ) : [EOL] points = [ Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) ] [EOL] sorted_x_points = sorted ( points , key = lambda point : point . x ) [EOL] self . assertEqual ( [number] , sorted_x_points [ [number] ] . x ) [EOL] self . assertEqual ( [number] , sorted_x_points [ [number] ] . x ) [EOL] sorted_y_points = sorted ( points , key = lambda point : point . y ) [EOL] self . assertEqual ( [number] , sorted_y_points [ [number] ] . y ) [EOL] self . assertEqual ( [number] , sorted_y_points [ [number] ] . y ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datastructure.structs.DisjointSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import datastructure [EOL] import unittest [EOL] from typing import List [EOL] from datastructure . structs import Node , Point [EOL] from datastructure . methods import make_kd_tree , find_range_search [EOL] [EOL] [EOL] class DataStructureMethodsTestCase ( unittest . TestCase ) : [EOL] [EOL] def test_make_kd_tree_normal ( self ) : [EOL] points = [ Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) ] [EOL] tree = [ Node ( None , None , None , None ) for i in range ( [number] ) ] [EOL] t = make_kd_tree ( [number] , [number] , [number] , points , tree ) [EOL] for node in tree : [EOL] print ( [string] . format ( node . location , node . p , node . l , node . r ) ) [EOL] [EOL] self . assertEqual ( [number] , t ) [EOL] [EOL] def test_find_range_search_normal ( self ) : [EOL] points = [ Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) ] [EOL] tree = [ Node ( None , None , None , None ) for i in range ( [number] ) ] [EOL] t = make_kd_tree ( [number] , [number] , [number] , points , tree ) [EOL] ans1 = [ ] [EOL] find_range_search ( t , [number] , [number] , [number] , [number] , [number] , points , tree , ans1 ) [EOL] ans1 . sort ( ) [EOL] for i , id in enumerate ( [ [number] , [number] , [number] , [number] ] ) : [EOL] self . assertEqual ( id , ans1 [ i ] . point_id ) [EOL] ans2 = [ ] [EOL] find_range_search ( t , [number] , [number] , [number] , [number] , [number] , points , tree , ans2 ) [EOL] ans2 . sort ( ) [EOL] for i , id in enumerate ( [ [number] , [number] , [number] ] ) : [EOL] self . assertEqual ( id , ans2 [ i ] . point_id ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Node]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 $typing.List[datastructure.structs.Node]$ 0 0 0 0 0 $typing.List[datastructure.structs.Node]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Node]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 $typing.List[datastructure.structs.Node]$ 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 $typing.List[datastructure.structs.Node]$ 0 $typing.List[datastructure.structs.Point]$ 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 $typing.List[datastructure.structs.Node]$ 0 $typing.List[datastructure.structs.Point]$ 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[datastructure.structs.Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] INFINITY = [number] << [number] [EOL] [EOL]	0 0 0 $builtins.int$ 0 0 0 0 0 0
	0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Optional [EOL] [EOL] [EOL] class Edge ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , source , destination , weight ) : [EOL] self . source = source [EOL] self . destination = destination [EOL] self . weight = weight [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . weight < other . weight [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.int]$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Deque , Optional [EOL] import datastructure [EOL] import typing [EOL] import builtins [EOL] import structs [EOL] import graph [EOL] from typing import List , Optional , Deque [EOL] from collections import deque [EOL] from . common import INFINITY [EOL] from . structs import Edge [EOL] from datastructure . structs import DisjointSet [EOL] [EOL] [EOL] def warshall_floyd ( distance_matrix ) : [EOL] [docstring] [EOL] n = len ( distance_matrix [ [number] ] ) [EOL] for k in range ( n ) : [EOL] for i in range ( n ) : [EOL] if distance_matrix [ i ] [ k ] == INFINITY : [EOL] continue [EOL] for j in range ( n ) : [EOL] if distance_matrix [ k ] [ j ] == INFINITY : [EOL] continue [EOL] distance_matrix [ i ] [ j ] = min ( distance_matrix [ i ] [ j ] , distance_matrix [ i ] [ k ] + distance_matrix [ k ] [ j ] ) [EOL] for l in range ( n ) : [EOL] if distance_matrix [ i ] [ i ] < [number] : [EOL] return None [EOL] return distance_matrix [EOL] [EOL] [EOL] def topological_sort ( adj_matrix ) : [EOL] [docstring] [EOL] n = len ( adj_matrix ) [EOL] indeg = [ [number] for i in range ( n ) ] [EOL] v = [ False for i in range ( n ) ] [EOL] res = [ ] [EOL] for i in range ( n ) : [EOL] for j in adj_matrix [ i ] : [EOL] indeg [ j ] += [number] [EOL] [EOL] for j in range ( n ) : [EOL] if indeg [ j ] == [number] and not v [ j ] : [EOL] __bfs ( j , adj_matrix , indeg , v , res ) [EOL] [EOL] return res [EOL] [EOL] [EOL] def __bfs ( s , adj_matrix , indeg , v , res ) : [EOL] [docstring] [EOL] queue = deque ( ) [EOL] queue . append ( s ) [EOL] v [ s ] = True [EOL] while len ( queue ) > [number] : [EOL] u = queue . popleft ( ) [EOL] res . append ( u ) [EOL] for i in adj_matrix [ u ] : [EOL] indeg [ i ] -= [number] [EOL] if indeg [ i ] == [number] and not v [ i ] : [EOL] v [ i ] = True [EOL] queue . append ( i ) [EOL] [EOL] [EOL] prenum = [ ] [EOL] lowest = [ ] [EOL] parent = [ ] [EOL] visited = [ ] [EOL] timer = [number] [EOL] [EOL] [EOL] def articulation_point ( g ) : [EOL] [docstring] [EOL] n = len ( g ) [EOL] global prenum , lowest , parent , visited , timer [EOL] prenum = [ [number] for i in range ( n ) ] [EOL] lowest = [ [number] for i in range ( n ) ] [EOL] parent = [ - [number] for i in range ( n ) ] [EOL] visited = [ False for i in range ( n ) ] [EOL] timer = [number] [EOL] __dfs ( [number] , - [number] , g ) [EOL] ap = [ ] [EOL] np = [number] [EOL] for i in range ( [number] , n ) : [EOL] p = parent [ i ] [EOL] if p == [number] : [EOL] np += [number] [EOL] elif prenum [ p ] <= lowest [ i ] : [EOL] ap . append ( p ) [EOL] if np > [number] : [EOL] ap . append ( [number] ) [EOL] return ap [EOL] [EOL] [EOL] def __dfs ( current , prev , g ) : [EOL] [docstring] [EOL] global prenum , lowest , parent , visited , timer [EOL] prenum [ current ] = lowest [ current ] = timer [EOL] timer += [number] [EOL] visited [ current ] = True [EOL] [EOL] for next in g [ current ] : [EOL] if not visited [ next ] : [EOL] parent [ next ] = current [EOL] __dfs ( next , current , g ) [EOL] lowest [ current ] = min ( lowest [ current ] , lowest [ next ] ) [EOL] elif next != prev : [EOL] lowest [ current ] = min ( lowest [ current ] , prenum [ next ] ) [EOL] [EOL] [EOL] __visited = [ ] [EOL] __distances = [ ] [EOL] __graph = [ ] [EOL] [EOL] [EOL] def calc_tree_diameter ( graph ) : [EOL] [docstring] [EOL] global __graph [EOL] __graph = graph [EOL] __bfs_for_calc_tree_diameter ( [number] ) [EOL] [EOL] maxv = max ( filter ( lambda d : d != INFINITY , __distances ) ) [EOL] trgt = __distances . index ( maxv ) [EOL] [EOL] __bfs_for_calc_tree_diameter ( trgt ) [EOL] [EOL] return max ( filter ( lambda d : d != INFINITY , __distances ) ) [EOL] [EOL] [EOL] def __bfs_for_calc_tree_diameter ( starting ) : [EOL] [docstring] [EOL] global __distances , __graph [EOL] __distances = [ INFINITY for i in range ( len ( __graph ) ) ] [EOL] queue = deque ( ) [EOL] queue . append ( starting ) [EOL] __distances [ starting ] = [number] [EOL] while len ( queue ) > [number] : [EOL] u = queue . popleft ( ) [EOL] for i in range ( len ( __graph [ u ] ) ) : [EOL] e = __graph [ u ] [ i ] [EOL] if __distances [ e . destination ] == INFINITY : [EOL] __distances [ e . destination ] = __distances [ u ] + e . weight [EOL] queue . append ( e . destination ) [EOL] [EOL] [EOL] def kruskal ( n , edges ) : [EOL] total_cost = [number] [EOL] edges . sort ( ) [EOL] dset = DisjointSet ( n ) [EOL] for edge in edges : [EOL] if not dset . same ( edge . source , edge . destination ) : [EOL] total_cost += edge . weight [EOL] dset . unite ( edge . source , edge . destination ) [EOL] return total_cost [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.bool]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.bool]$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[typing.List[structs.Edge]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[typing.List[structs.Edge]]$ 0 $typing.List[typing.List[structs.Edge]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[typing.List[structs.Edge]]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[structs.Edge]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[structs.Edge]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[structs.Edge]]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Deque , Tuple [EOL] import structs [EOL] import typing [EOL] import builtins [EOL] import dynamicprogramming [EOL] [docstring] [EOL] from typing import List , Tuple , Deque [EOL] from collections import deque [EOL] import bisect [EOL] from . common import INFINITY , DIAGONAL , TOP [EOL] from . structs import Item , Rectangle [EOL] [EOL] [EOL] def coin_changing_problem ( coins , n ) : [EOL] [docstring] [EOL] t = [ INFINITY for i in range ( n + [number] ) ] [EOL] t [ [number] ] = [number] [EOL] for coin in coins : [EOL] j = [number] [EOL] while coin + j <= n : [EOL] t [ coin + j ] = min ( t [ coin + j ] , t [ j ] + [number] ) [EOL] j += [number] [EOL] return t [ n ] [EOL] [EOL] [EOL] def zero_one_knapsack_problem ( items , weight ) : [EOL] [docstring] [EOL] [comment] [EOL] inner_items = [ Item ( [number] , [number] ) ] [EOL] inner_items . extend ( items ) [EOL] n = len ( inner_items ) [EOL] [EOL] [comment] [EOL] value_table = [ [ [number] for j in range ( weight + [number] ) ] for i in range ( n ) ] [EOL] selection_table = [ [ DIAGONAL if i == [number] else TOP for j in range ( weight + [number] ) ] for i in range ( n ) ] [EOL] [EOL] [comment] [EOL] for i in range ( [number] , n ) : [EOL] inner_item = inner_items [ i ] [EOL] for j in range ( [number] , weight + [number] ) : [EOL] value_table [ i ] [ j ] = value_table [ i - [number] ] [ j ] [EOL] selection_table [ i ] [ j ] = TOP [EOL] if inner_item . weight > j : [EOL] continue [EOL] if inner_item . value + value_table [ i - [number] ] [ j - inner_item . weight ] > value_table [ i ] [ j ] : [EOL] value_table [ i ] [ j ] = inner_item . value + value_table [ i - [number] ] [ j - inner_item . weight ] [EOL] selection_table [ i ] [ j ] = DIAGONAL [EOL] [EOL] [comment] [EOL] selection = deque ( ) [EOL] w = weight [EOL] for i in range ( n - [number] , [number] , - [number] ) : [EOL] inner_item = inner_items [ i ] [EOL] if selection_table [ i ] [ w ] == DIAGONAL : [EOL] selection . appendleft ( i ) [EOL] w -= inner_item . weight [EOL] [EOL] return value_table [ n - [number] ] [ weight ] , list ( selection ) [EOL] [EOL] [EOL] def lis ( a ) : [EOL] [docstring] [EOL] n = len ( a ) [EOL] l = [ [number] for i in range ( n ) ] [EOL] l [ [number] ] = a [ [number] ] [EOL] length = [number] [EOL] for i in range ( [number] , n ) : [EOL] if l [ length - [number] ] < a [ i ] : [EOL] l [ length ] = a [ i ] [EOL] length += [number] [EOL] else : [EOL] l [ bisect . bisect_left ( l , a [ i ] , [number] , length - [number] ) ] = a [ i ] [EOL] [EOL] return length [EOL] [EOL] [EOL] def get_largest_square ( g ) : [EOL] h = len ( g ) [EOL] w = len ( g [ [number] ] ) [EOL] dp = [ [ [number] for j in range ( w ) ] for i in range ( h ) ] [EOL] max_width = [number] [EOL] [EOL] for i in range ( h ) : [EOL] for j in range ( w ) : [EOL] if g [ i ] [ j ] == [number] : [EOL] dp [ i ] [ j ] = ( g [ i ] [ j ] + [number] ) % [number] [EOL] max_width |= dp [ i ] [ j ] [EOL] [EOL] for i in range ( [number] , h ) : [EOL] for j in range ( [number] , w ) : [EOL] if g [ i ] [ j ] == [number] : [EOL] dp [ i ] [ j ] = [number] [EOL] else : [EOL] dp [ i ] [ j ] = min ( dp [ i - [number] ] [ j - [number] ] , min ( dp [ i - [number] ] [ j ] , dp [ i ] [ j - [number] ] ) ) + [number] [EOL] max_width = max ( max_width , dp [ i ] [ j ] ) [EOL] [EOL] return max_width * max_width [EOL] [EOL] [EOL] def get_largest_rectangle ( g ) : [EOL] h = len ( g ) [EOL] w = len ( g [ [number] ] ) [EOL] t = [ [ [number] for j in range ( w ) ] for i in range ( h ) ] [EOL] [EOL] for j in range ( w ) : [EOL] for i in range ( h ) : [EOL] if g [ i ] [ j ] == [number] : [EOL] t [ i ] [ j ] = [number] [EOL] else : [EOL] t [ i ] [ j ] = t [ i - [number] ] [ j ] + [number] if i > [number] else [number] [EOL] [EOL] max_reactangle = [number] [EOL] for i in range ( h ) : [EOL] max_reactangle = max ( max_reactangle , _get_largest_rectangle ( t [ i ] ) ) [EOL] [EOL] return max_reactangle [EOL] [EOL] [EOL] def _get_largest_rectangle ( t ) : [EOL] stack = [ ] [EOL] max_v = [number] [EOL] for i in range ( len ( t ) ) : [EOL] rect = Rectangle ( t [ i ] , i ) [EOL] if len ( stack ) == [number] : [EOL] stack . append ( rect ) [EOL] else : [EOL] if stack [ - [number] ] . height < rect . height : [EOL] stack . append ( rect ) [EOL] elif stack [ - [number] ] . height > rect . height : [EOL] target = i [EOL] while len ( stack ) > [number] and stack [ - [number] ] . height >= rect . height : [EOL] pre_rect = stack . pop ( ) [EOL] area = pre_rect . height * ( i - pre_rect . pos ) [EOL] max_v = max ( max_v , area ) [EOL] target = pre_rect . pos [EOL] rect . pos = target [EOL] stack . append ( rect ) [EOL] return max_v [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass class Item : [EOL] [docstring] [EOL] value = ... [EOL] weight = ... [EOL] [EOL] [EOL] @ dataclass class Rectangle : [EOL] [docstring] [EOL] height = ... [EOL] pos = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
import builtins [EOL] [docstring] [EOL] INFINITY = [number] << [number] [EOL] DIAGONAL = [number] [EOL] TOP = [number]	0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0
	0
from typing import List , Optional [EOL] import structs [EOL] import typing [EOL] import builtins [EOL] import datastructure [EOL] [docstring] [EOL] from typing import List , Optional [EOL] from . structs import Node , Point [EOL] np = [number] [EOL] [EOL] [EOL] def make_kd_tree ( l , r , depth , points , tree ) : [EOL] [docstring] [EOL] if not l < r : [EOL] return None [EOL] mid = int ( ( l + r ) / [number] ) [EOL] global np [EOL] t = np [EOL] np += [number] [EOL] if depth % [number] == [number] : [EOL] s_points = sorted ( points [ l : r ] , key = lambda point : point . x ) [EOL] else : [EOL] s_points = sorted ( points [ l : r ] , key = lambda point : point . y ) [EOL] for i , point in enumerate ( s_points ) : [EOL] points [ l + i ] = point [EOL] tree [ t ] . location = mid [EOL] tree [ t ] . l = make_kd_tree ( l , mid , depth + [number] , points , tree ) [EOL] tree [ t ] . r = make_kd_tree ( mid + [number] , r , depth + [number] , points , tree ) [EOL] [EOL] return t [EOL] [EOL] [EOL] def find_range_search ( v , sx , tx , sy , ty , depth , points , tree , ans ) : [EOL] [docstring] [EOL] x = points [ tree [ v ] . location ] . x [EOL] y = points [ tree [ v ] . location ] . y [EOL] [EOL] if sx <= x <= tx and sy <= y <= ty : [EOL] ans . append ( points [ tree [ v ] . location ] ) [EOL] [EOL] if depth % [number] == [number] : [EOL] if tree [ v ] . l is not None and sx <= x : [EOL] find_range_search ( tree [ v ] . l , sx , tx , sy , ty , depth + [number] , points , tree , ans ) [EOL] if tree [ v ] . r is not None and x <= tx : [EOL] find_range_search ( tree [ v ] . r , sx , tx , sy , ty , depth + [number] , points , tree , ans ) [EOL] else : [EOL] if tree [ v ] . l is not None and sy <= y : [EOL] find_range_search ( tree [ v ] . l , sx , tx , sy , ty , depth + [number] , points , tree , ans ) [EOL] if tree [ v ] . r is not None and y <= ty : [EOL] find_range_search ( tree [ v ] . r , sx , tx , sy , ty , depth + [number] , points , tree , ans ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List , Optional [EOL] [EOL] [EOL] class DisjointSet : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , size ) : [EOL] self . rank = [ i for i in range ( size ) ] [EOL] self . p = [ i for i in range ( size ) ] [EOL] for i in range ( size ) : [EOL] self . __make_set ( i ) [EOL] [EOL] def __make_set ( self , x ) : [EOL] [docstring] [EOL] self . p [ x ] = x [EOL] self . rank [ x ] = [number] [EOL] [EOL] def __find_set ( self , x ) : [EOL] [docstring] [EOL] if x != self . p [ x ] : [EOL] self . p [ x ] = self . __find_set ( self . p [ x ] ) [EOL] return self . p [ x ] [EOL] [EOL] def __link ( self , x , y ) : [EOL] if self . rank [ x ] > self . rank [ y ] : [EOL] self . p [ y ] = x [EOL] else : [EOL] self . p [ x ] = y [EOL] if self . rank [ x ] == self . rank [ y ] : [EOL] self . rank [ y ] += [number] [EOL] [EOL] def unite ( self , x , y ) : [EOL] [docstring] [EOL] self . __link ( self . __find_set ( x ) , self . __find_set ( y ) ) [EOL] [EOL] def same ( self , x , y ) : [EOL] [docstring] [EOL] return self . __find_set ( x ) == self . __find_set ( y ) [EOL] [EOL] [EOL] class Node : [EOL] [docstring] [EOL] def __init__ ( self , location , p , l , r ) : [EOL] [docstring] [EOL] self . location = location [EOL] self . p = p [EOL] self . l = l [EOL] self . r = r [EOL] [EOL] [EOL] class Point : [EOL] [docstring] [EOL] def __init__ ( self , point_id , x , y ) : [EOL] self . point_id = point_id [EOL] self . x = x [EOL] self . y = y [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . point_id < other . point_id [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self . point_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
import builtins [EOL] [docstring] [EOL] from enum import Enum , IntEnum [EOL] [EOL] [comment] [EOL] EPS = [number] [EOL] [EOL] [EOL] def equals ( x_0 , x_1 ) : [EOL] [docstring] [EOL] return abs ( x_0 - x_1 ) < EPS [EOL] [EOL] [EOL] class PointRelativePosition ( Enum ) : [EOL] [docstring] [EOL] COUNTER_CLOCK_WISE = [number] [EOL] CLOCK_WISE = - [number] [EOL] ON_LINE_FRONT = [number] [EOL] ON_LINE_BACK = - [number] [EOL] ON_SEGMENT = [number] [EOL] [EOL] [EOL] class PointContainsInPolygon ( Enum ) : [EOL] [docstring] [EOL] IN = [number] [EOL] ON_EDGE = [number] [EOL] OUT = [number] [EOL] [EOL] [EOL] class EndPointType ( IntEnum ) : [EOL] [docstring] [EOL] BOTTOM = [number] [EOL] LEFT = [number] [EOL] RIGHT = [number] [EOL] TOP = [number] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import geometry [EOL] import builtins [EOL] [docstring] [EOL] from dataclasses import dataclass [EOL] from typing import List , Optional [EOL] import math [EOL] import sys [EOL] import traceback [EOL] from geometry . common import EPS , EndPointType [EOL] [EOL] [EOL] class Point ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , x_0 , y_0 ) : [EOL] self . x = x_0 [EOL] self . y = y_0 [EOL] [EOL] def __add__ ( self , other ) : [EOL] [docstring] [EOL] return Point ( self . x + other . x , self . y + other . y ) [EOL] [EOL] def __sub__ ( self , other ) : [EOL] [docstring] [EOL] return Point ( self . x - other . x , self . y - other . y ) [EOL] [EOL] def __mul__ ( self , a_0 ) : [EOL] [docstring] [EOL] return Point ( self . x * a_0 , self . y * a_0 ) [EOL] [EOL] def __truediv__ ( self , a_0 ) : [EOL] [docstring] [EOL] res = None [EOL] try : [EOL] res = Point ( self . x / a_0 , self . y / a_0 ) [EOL] except ZeroDivisionError as e_0 : [EOL] print ( [string] ) [EOL] print ( e_0 ) [EOL] sys . stderr . write ( traceback . format_exc ( ) ) [EOL] return res [EOL] [EOL] def abs ( self ) : [EOL] [docstring] [EOL] return math . sqrt ( math . pow ( self . x , [number] ) + math . pow ( self . y , [number] ) ) [EOL] [EOL] def norm ( self ) : [EOL] [docstring] [EOL] return math . pow ( self . x , [number] ) + math . pow ( self . y , [number] ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] [docstring] [EOL] return self . x < other . x if self . x != other . x else self . y < other . y [EOL] [EOL] def __eq__ ( self , other ) : [EOL] [docstring] [EOL] return abs ( self . x - other . x ) < EPS and abs ( self . y - other . y ) < EPS [EOL] [EOL] [EOL] class Vector ( Point ) : [EOL] [docstring] [EOL] def dot ( self , other ) : [EOL] [docstring] [EOL] return self . x * other . x + self . y * other . y [EOL] [EOL] def cross ( self , other ) : [EOL] [docstring] [EOL] return self . x * other . y - other . x * self . y [EOL] [EOL] [EOL] class Segment ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , p1 , p2 ) : [EOL] self . p1 = p1 [EOL] self . p2 = p2 [EOL] [EOL] [EOL] class Line ( Segment ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ dataclass class Polygon : [EOL] [docstring] [EOL] p_i = ... [EOL] [EOL] [EOL] @ dataclass class Circle : [EOL] [docstring] [EOL] c = ... [EOL] r = ... [EOL] [EOL] [EOL] class EndPoint ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , p , seg_id , end_point_type ) : [EOL] self . p = p [EOL] self . seg = seg_id [EOL] self . st = end_point_type [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if self . p . y == other . p . y : [EOL] return self . st < other . st [EOL] else : [EOL] return self . p . y < other . p . y [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Optional[geometry.structs.Point]$ 0 0 0 0 0 0 $typing.Optional[geometry.structs.Point]$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[geometry.structs.Point]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Point]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Point$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $geometry.structs.Point$ 0 $builtins.int$ 0 $geometry.common.EndPointType$ 0 0 0 0 0 $geometry.structs.Point$ 0 $geometry.structs.Point$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $geometry.common.EndPointType$ 0 $geometry.common.EndPointType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import heuristicsearch [EOL] [docstring] [EOL] from dataclasses import dataclass [EOL] from typing import List [EOL] from . common import N2_EIGHT_PUZZLE , N2_16_PUZZLE [EOL] [EOL] [EOL] @ dataclass class Queen : [EOL] row = ... [EOL] col = ... [EOL] [EOL] [EOL] class Puzzle : [EOL] [EOL] def __init__ ( self , f , space , path ) : [EOL] self . f = f [EOL] self . space = space [EOL] self . path = path [EOL] [EOL] def __lt__ ( self , other ) : [EOL] for i in range ( N2_EIGHT_PUZZLE ) : [EOL] if self . f [ i ] == other . f [ i ] : [EOL] continue [EOL] return self . f [ i ] > other . f [ i ] [EOL] return False [EOL] [EOL] [EOL] @ dataclass class Puzzle2 : [EOL] f = ... [EOL] space = ... [EOL] MD = ... [EOL] [EOL] [EOL] class Puzzle3 : [EOL] def __init__ ( self , f , space , md , cost ) : [EOL] self . f = f [EOL] self . space = space [EOL] self . MD = md [EOL] self . cost = cost [EOL] [EOL] def __lt__ ( self , other ) : [EOL] for i in range ( N2_16_PUZZLE ) : [EOL] if self . f [ i ] == other . f [ i ] : [EOL] continue [EOL] return self . f [ i ] < other . f [ i ] [EOL] return False [EOL] [EOL] [EOL] class State : [EOL] def __init__ ( self , puzzle , estimated ) : [EOL] self . puzzle = puzzle [EOL] self . estimated = estimated [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . estimated < other . estimated [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $heuristicsearch.structs.Puzzle3$ 0 $builtins.int$ 0 0 0 0 0 $heuristicsearch.structs.Puzzle3$ 0 $heuristicsearch.structs.Puzzle3$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] N_EIGHT = [number] [EOL] FREE = - [number] [EOL] NOT_FREE = [number] [EOL] [EOL] N_EIGHT_PUZZLE = [number] [EOL] N2_EIGHT_PUZZLE = [number] [EOL] [EOL] N_16_PUZZLE = [number] [EOL] N2_16_PUZZLE = [number] [EOL] [EOL] LIMIT = [number] [EOL] [EOL] dx = [ - [number] , [number] , [number] , [number] ] [EOL] dy = [ [number] , - [number] , [number] , [number] ] [EOL] dir = [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
	0