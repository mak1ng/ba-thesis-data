from typing import Tuple , Any , List , Optional [EOL] import typing [EOL] import unittest [EOL] import _importlib_modulespec [EOL] [docstring] [EOL] [EOL] import importlib [EOL] import os [EOL] from subprocess import call [EOL] [EOL] from flask_script import Manager , prompt_bool [EOL] [EOL] from sipa import create_app [EOL] [EOL] [EOL] basedir = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] [EOL] manager = Manager ( create_app ) [EOL] [EOL] [EOL] def large_message ( message , title = [string] , width = [number] , fill = [string] ) : [EOL] print ( [string] . format ( title . upper ( ) , message , fill = fill , width = width , ) ) [EOL] [EOL] [EOL] def run_tests_unittest ( ) : [EOL] [docstring] [EOL] import unittest [EOL] tests = unittest . TestLoader ( ) . discover ( os . path . join ( basedir , [string] ) ) [EOL] return unittest . TextTestRunner ( ) . run ( tests ) [EOL] [EOL] [EOL] def run_tests_nose ( ) : [EOL] [docstring] [EOL] if importlib . util . find_spec ( [string] ) is None : [EOL] large_message ( [string] ) [EOL] if not prompt_bool ( [string] , default = True ) : [EOL] print ( [string] ) [EOL] result = [number] [EOL] else : [EOL] result = run_tests_unittest ( ) [EOL] [EOL] return result [EOL] [EOL] return call ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] @ manager . option ( [string] , [string] , dest = [string] , required = False , default = False , action = [string] ) def test ( force_unittest ) : [EOL] [docstring] [EOL] spec = importlib . util . find_spec ( [string] ) [EOL] if spec is None : [EOL] large_message ( [string] [string] [string] ) [EOL] if not prompt_bool ( [string] , default = False ) : [EOL] print ( [string] ) [EOL] exit ( [number] ) [EOL] [EOL] timeout = os . getenv ( [string] ) [EOL] if os . getenv ( [string] ) : [EOL] connections = [ ( [string] , [number] ) ] [EOL] if not wait_until_ready ( connections ) : [EOL] exit ( [number] ) [EOL] [EOL] if not force_unittest : [EOL] result = run_tests_nose ( ) [EOL] else : [EOL] result = run_tests_unittest ( ) [EOL] [EOL] exit ( result ) [EOL] [EOL] [EOL] def wait_until_ready ( connections_to_test , timeout = [number] ) : [EOL] [docstring] [EOL] import socket [EOL] import time [EOL] [EOL] print ( [string] ) [EOL] [EOL] print ( [string] , [string] . join ( [string] . format ( * host_port ) for host_port in connections_to_test ) ) [EOL] [EOL] for conn_tuple in connections_to_test : [EOL] print ( [string] . format ( * conn_tuple ) , end = [string] ) [EOL] old_time = time . time ( ) [EOL] while time . time ( ) - old_time < timeout : [EOL] try : [EOL] socket . setdefaulttimeout ( timeout ) [EOL] socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) . connect ( conn_tuple ) [EOL] except ConnectionRefusedError : [EOL] pass [EOL] else : [EOL] print ( [string] ) [EOL] break [EOL] else : [EOL] print ( [string] ) [EOL] break [EOL] else : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] manager . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] from typing import Set [EOL] import typing [EOL] import sys [EOL] from os . path import join [EOL] import subprocess [EOL] [EOL] DEFAULT_REQUIREMENTS = [string] [EOL] [comment] [EOL] PATH = [string] [EOL] [EOL] [EOL] def main ( ) : [EOL] files_to_install = { DEFAULT_REQUIREMENTS , * sys . argv [ [number] : ] } [EOL] for filename in files_to_install : [EOL] subprocess . check_call ( [ sys . executable , [string] , [string] , [string] , [string] , join ( PATH , filename ) ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from sipa . units import TRAFFIC_FORMAT_STRING , UNIT_LIST , dynamic_unit , format_as_traffic , max_divisions , reduce_by_base , money , format_money , money_style [EOL] [EOL] [EOL] class TrafficFormatStringTestCase ( TestCase ) : [EOL] CORRECT_FORMAT_TUPLE = ( [number] , [string] ) [EOL] [EOL] def test_contains_less_or_equal_two_format_fields ( self ) : [EOL] [docstring] [EOL] try : [EOL] TRAFFIC_FORMAT_STRING . format ( * self . CORRECT_FORMAT_TUPLE ) [EOL] except IndexError : [EOL] self . fail ( [string] ) [EOL] [EOL] def test_contains_more_than_one_format_field ( self ) : [EOL] [docstring] [EOL] with self . assertRaises ( IndexError ) : [EOL] TRAFFIC_FORMAT_STRING . format ( * self . CORRECT_FORMAT_TUPLE [ : - [number] ] ) [EOL] [EOL] [EOL] class ThingsWithBasesTestCase ( TestCase ) : [EOL] BASES = [ [number] , [number] , [number] ] [EOL] [EOL] def test_max_divisions ( self ) : [EOL] [docstring] [EOL] for base in self . BASES : [EOL] with self . subTest ( base = base ) : [EOL] example = [ ( [number] , [number] ) , ( base / [number] , [number] ) , ( base , [number] ) , ( [number] * base , [number] ) , ( base ** [number] , [number] ) , ( [number] , [number] ) , ( base ** - [number] , [number] ) , ( - ( base ** - [number] ) , [number] ) , ( - base / [number] , [number] ) , ( - base , [number] ) , ( - [number] * base , [number] ) , ( - ( base ** [number] ) , [number] ) ] [EOL] for num , expected_division in example : [EOL] with self . subTest ( num = num ) : [EOL] self . assertEqual ( max_divisions ( num , base = base ) , expected_division ) [EOL] [EOL] def test_number_reduced_correctly ( self ) : [EOL] [docstring] [EOL] for base in self . BASES : [EOL] with self . subTest ( base = base ) : [EOL] [comment] [EOL] examples = [ ( [number] , [number] ) , ( base , [number] ) , ( base ** [number] , base ) , ( - base , - [number] ) , ( - ( base ** [number] ) , - base ) ] [EOL] for num , result in examples : [EOL] with self . subTest ( num = num ) : [EOL] self . assertEqual ( reduce_by_base ( number = num , base = base , divisions = [number] ) , result , ) [EOL] [EOL] def test_unit_in_formatted_string ( self ) : [EOL] num , divisions = [number] , [number] [EOL] [EOL] formatted = format_as_traffic ( num , divisions , divide = False ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertIn ( UNIT_LIST [ divisions ] , formatted ) [EOL] [EOL] def test_dynamic_unit_contains_unit ( self ) : [EOL] self . assertIn ( UNIT_LIST [ [number] ] , dynamic_unit ( [number] ) ) [EOL] [EOL] [EOL] class MoneyStyleMixin : [EOL] STYLE_POS = [string] [EOL] STYLE_NEG = [string] [EOL] [EOL] [EOL] class MoneyStylePositiveTestCase ( MoneyStyleMixin , TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . nums = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] def test_positive_style_returned ( self ) : [EOL] for num in self . nums : [EOL] with self . subTest ( num = num ) : [EOL] self . assertEqual ( money_style ( num ) , self . STYLE_POS ) [EOL] [EOL] [EOL] class MoneyStyleNegativeTestCase ( MoneyStyleMixin , TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . nums = [ - [number] , - [number] , - [number] , - [number] , - [number] ] [EOL] [EOL] def test_positive_style_returned ( self ) : [EOL] for num in self . nums : [EOL] with self . subTest ( num = num ) : [EOL] self . assertEqual ( money_style ( num ) , self . STYLE_NEG ) [EOL] [EOL] [EOL] class MoneyDecoratorTestCase ( MoneyStyleMixin , TestCase ) : [EOL] @ money def dummy_func ( self , value ) : [EOL] return value [EOL] [EOL] def prepare_dict ( self , d ) : [EOL] value = d . pop ( [string] ) [EOL] style = d . pop ( [string] ) [EOL] raw_value = d . pop ( [string] ) [EOL] self . assertEqual ( d , { } ) [EOL] return value , style , raw_value [EOL] [EOL] def test_positive_float ( self ) : [EOL] value , style , raw_value = self . prepare_dict ( self . dummy_func ( [number] ) ) [EOL] [EOL] self . assertEqual ( raw_value , + [number] ) [EOL] self . assertTrue ( value . startswith ( [string] ) ) [EOL] self . assertTrue ( value . endswith ( [string] ) ) [EOL] [EOL] self . assertEqual ( style , self . STYLE_POS ) [EOL] [EOL] def test_negative_float ( self ) : [EOL] value , style , raw_value = self . prepare_dict ( self . dummy_func ( - [number] ) ) [EOL] [EOL] self . assertEqual ( raw_value , - [number] ) [EOL] self . assertTrue ( value . startswith ( [string] ) ) [EOL] self . assertTrue ( value . endswith ( [string] ) ) [EOL] [EOL] self . assertEqual ( style , self . STYLE_NEG ) [EOL] [EOL] def test_zero_is_positive ( self ) : [EOL] value , style , raw_value = self . prepare_dict ( self . dummy_func ( [number] ) ) [EOL] [EOL] self . assertEqual ( raw_value , [number] ) [EOL] self . assertTrue ( value . startswith ( [string] ) ) [EOL] self . assertTrue ( style , self . STYLE_POS ) [EOL] [EOL] def test_whole_number_has_cent_digits ( self ) : [EOL] self . assertIn ( [string] , self . dummy_func ( [number] ) [ [string] ] ) [EOL] [EOL] [EOL] class MoneyTestCase ( TestCase ) : [EOL] def test_positive_float ( self ) : [EOL] value = format_money ( + [number] ) [EOL] [EOL] self . assertTrue ( value . startswith ( [string] ) ) [EOL] self . assertTrue ( value . endswith ( [string] ) ) [EOL] [EOL] def test_negative_float ( self ) : [EOL] value = format_money ( - [number] ) [EOL] self . assertTrue ( value . startswith ( [string] ) ) [EOL] self . assertTrue ( value . endswith ( [string] ) ) [EOL] [EOL] def test_zero_is_positive ( self ) : [EOL] value = format_money ( [number] ) [EOL] self . assertTrue ( value . startswith ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
	0
from typing import Tuple , Literal , Type [EOL] import tests [EOL] import typing_extensions [EOL] import typing [EOL] import sipa [EOL] from itertools import permutations [EOL] from unittest import TestCase [EOL] [EOL] from sipa import forms [EOL] from wtforms import Form , PasswordField , ValidationError [EOL] [EOL] [EOL] class PasswordComplexityValidatorTest ( TestCase ) : [EOL] class TestForm ( Form ) : [EOL] password = PasswordField ( ) [EOL] [EOL] def validate ( self , validator , password ) : [EOL] form = self . TestForm ( data = { [string] : password } ) [EOL] field = form . password [EOL] validator ( form , field ) [EOL] [EOL] def test_min_length ( self ) : [EOL] min_length = [number] [EOL] assert min_length > [number] [EOL] validator = forms . PasswordComplexity ( min_length = min_length , min_classes = [number] ) [EOL] for length in range ( min_length ) : [EOL] with self . assertRaises ( ValidationError ) : [EOL] self . validate ( validator , [string] * length ) [EOL] for length in range ( min_length , [number] * min_length ) : [EOL] self . validate ( validator , [string] * length ) [EOL] [EOL] def test_min_classes ( self ) : [EOL] validator = forms . PasswordComplexity ( min_length = [number] , min_classes = [number] ) [EOL] class_representatives = ( [string] , [string] , [string] , [string] ) [EOL] for representative in class_representatives : [EOL] with self . assertRaises ( ValidationError ) : [EOL] self . validate ( validator , representative ) [EOL] for permutation in permutations ( class_representatives , [number] ) : [EOL] self . validate ( validator , [string] . join ( permutation ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_forms.PasswordComplexityValidatorTest.TestForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_forms.PasswordComplexityValidatorTest.TestForm$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_forms.PasswordComplexityValidatorTest.TestForm$ 0 0 0 0 0 $tests.test_forms.PasswordComplexityValidatorTest.TestForm$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $sipa.forms.PasswordComplexity$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.PasswordComplexity$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $sipa.forms.PasswordComplexity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.PasswordComplexity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.PasswordComplexity$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $sipa.forms.PasswordComplexity$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Union , Any , Set , List [EOL] import typing [EOL] import os [EOL] from shutil import rmtree [EOL] from subprocess import call [EOL] from tempfile import mkdtemp , TemporaryDirectory [EOL] from unittest import TestCase [EOL] [EOL] from git import Repo [EOL] [EOL] from sipa . utils . git_utils import init_repo , update_repo [EOL] [EOL] SAMPLE_FILE_NAME = [string] [EOL] OTHER_FILE_NAME = [string] [EOL] [EOL] AUTHOR_NAME = [string] [EOL] AUTHOR_MAIL = [string] [EOL] [EOL] [EOL] def set_author_config_locally ( path = None ) : [EOL] custom_git_options = ( [ [string] . format ( path ) ] [EOL] if path is not None [EOL] else [ ] ) [EOL] git_command_head = [ [string] , * custom_git_options , [string] ] [EOL] [EOL] call ( [ * git_command_head , [string] , AUTHOR_NAME ] ) [EOL] call ( [ * git_command_head , [string] , AUTHOR_MAIL ] ) [EOL] [EOL] [EOL] def init_sample_git_repo ( path , name ) : [EOL] [docstring] [EOL] path = os . path . abspath ( path ) [EOL] old_dir = os . getcwd ( ) [EOL] with TemporaryDirectory ( ) as tmp_git_dir : [EOL] os . chdir ( tmp_git_dir ) [EOL] call ( [ [string] , [string] , [string] ] ) [EOL] set_author_config_locally ( ) [EOL] [EOL] with open ( SAMPLE_FILE_NAME , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] call ( [ [string] , [string] , SAMPLE_FILE_NAME ] ) [EOL] call ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] bare_path = os . path . join ( path , [string] . format ( name ) ) [EOL] [comment] [EOL] [comment] [EOL] call ( [ [string] , [string] , [string] , tmp_git_dir , bare_path , [string] ] ) [EOL] [EOL] os . chdir ( old_dir ) [EOL] [EOL] return bare_path [EOL] [EOL] [EOL] def init_cloned_git_repo ( path , path_to_bare ) : [EOL] [docstring] [EOL] call ( [ [string] , [string] , path_to_bare , path , [string] ] ) [EOL] [EOL] [EOL] class SampleBareRepoInitializedBase ( TestCase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] self . workdir = mkdtemp ( ) [EOL] self . repo_name = [string] [EOL] self . repo_path = init_sample_git_repo ( self . workdir , self . repo_name ) [EOL] self . repo = Repo ( self . repo_path ) [EOL] [EOL] def tearDown ( self ) : [EOL] rmtree ( self . workdir ) [EOL] [EOL] [EOL] class TestSampleGitRepository ( SampleBareRepoInitializedBase ) : [EOL] [docstring] [EOL] def test_repo_path_correctly_joined ( self ) : [EOL] path = [string] . format ( self . workdir , self . repo_name ) [EOL] self . assertEqual ( self . repo_path , path ) [EOL] [EOL] def test_repo_path_exists ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( os . listdir ( self . workdir ) , [ [string] . format ( self . repo_name ) ] ) [EOL] self . assertTrue ( os . path . isdir ( self . repo_path ) ) [EOL] [EOL] def test_cloned_git_repo_correct_files ( self ) : [EOL] [docstring] [EOL] cloned_git_path = os . path . join ( self . workdir , [string] ) [EOL] init_cloned_git_repo ( path = cloned_git_path , path_to_bare = self . repo_path ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] found_files = set ( os . listdir ( cloned_git_path ) ) - { [string] } [EOL] self . assertEqual ( found_files , { [string] , SAMPLE_FILE_NAME } ) [EOL] [EOL] def test_repo_is_bare ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( self . repo . bare ) [EOL] [EOL] def test_repo_only_master ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( len ( self . repo . refs ) , [number] ) [EOL] self . assertEqual ( self . repo . head . ref . name , [string] ) [EOL] [EOL] [EOL] class CorrectlyClonedTesterMixin : [EOL] [docstring] [EOL] [EOL] def test_cloned_repo_not_bare ( self ) : [EOL] self . assertFalse ( self . cloned_repo . bare ) [EOL] [EOL] def test_cloned_repo_one_branch ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( len ( self . cloned_repo . branches ) , [number] ) [EOL] self . assertEqual ( self . cloned_repo . branches [ [number] ] . name , [string] ) [EOL] self . assertEqual ( self . cloned_repo . branches [ [number] ] , self . cloned_repo . head . ref ) [EOL] [EOL] def test_cloned_repo_correct_refs ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . cloned_repo . refs ) , [number] ) [EOL] [EOL] [EOL] class ExplicitlyClonedSampleRepoTestBase ( SampleBareRepoInitializedBase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . cloned_repo_path = os . path . join ( self . workdir , [string] ) [EOL] init_cloned_git_repo ( path = self . cloned_repo_path , path_to_bare = self . repo_path ) [EOL] [EOL] self . cloned_repo = Repo ( self . cloned_repo_path ) [EOL] [EOL] [EOL] class InitRepoTestBase ( SampleBareRepoInitializedBase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . cloned_repo_path = os . path . join ( self . workdir , [string] ) [EOL] os . mkdir ( self . cloned_repo_path ) [EOL] init_repo ( repo_dir = self . cloned_repo_path , repo_url = self . repo_path ) [EOL] [EOL] self . cloned_repo = Repo ( self . cloned_repo_path ) [EOL] [EOL] [EOL] class TestSampleGitRepositoryCloned ( CorrectlyClonedTesterMixin , ExplicitlyClonedSampleRepoTestBase ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class TestInitRepo ( CorrectlyClonedTesterMixin , InitRepoTestBase ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class TestUpdateRepo ( ExplicitlyClonedSampleRepoTestBase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] [EOL] with TemporaryDirectory ( ) as tmp_git_dir : [EOL] result = call ( [ [string] , [string] , [string] , self . repo_path , tmp_git_dir ] ) [EOL] assert result == [number] [EOL] tmp_clone = Repo ( tmp_git_dir ) [EOL] set_author_config_locally ( os . path . join ( tmp_git_dir , [string] ) ) [EOL] [EOL] file_path = os . path . join ( tmp_git_dir , OTHER_FILE_NAME ) [EOL] with open ( file_path , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] tmp_clone . git . add ( file_path ) [EOL] tmp_clone . git . commit ( [string] , [string] ) [EOL] tmp_clone . remote ( [string] ) . push ( ) [EOL] [EOL] def update_repo ( self ) : [EOL] update_repo ( self . cloned_repo_path ) [EOL] [EOL] def test_commitsha_different_before_update ( self ) : [EOL] self . assertNotEqual ( self . repo . commit ( ) . hexsha , self . cloned_repo . commit ( ) . hexsha ) [EOL] [EOL] def test_same_commit_after_update ( self ) : [EOL] self . update_repo ( ) [EOL] self . assertEqual ( self . repo . commit ( ) . hexsha , self . cloned_repo . commit ( ) . hexsha ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import sipa [EOL] import tests [EOL] import typing [EOL] import flask [EOL] from flask import Flask , Blueprint , url_for , session , request [EOL] from flask_login import current_user , login_user [EOL] from flask_testing import TestCase [EOL] [EOL] from sipa . login_manager import SipaLoginManager [EOL] [EOL] [EOL] class AuthenticatedUser : [EOL] def __init__ ( self , uid ) : [EOL] self . uid = uid [EOL] [EOL] def get_id ( self ) : [EOL] return self . uid [EOL] is_authenticated = True [EOL] is_active = True [EOL] is_anonymous = False [EOL] [EOL] [EOL] class SipaLoginManagerTest ( TestCase ) : [EOL] def create_app ( self ) : [EOL] app = Flask ( [string] ) [EOL] app . testing = True [EOL] app . config [ [string] ] = [string] * [number] [EOL] login_manager = SipaLoginManager ( app ) [EOL] [EOL] @ app . route ( [string] ) def login ( ) : [EOL] user = AuthenticatedUser ( uid = [string] ) [EOL] login_user ( user ) [EOL] return [string] [EOL] [EOL] @ app . route ( [string] ) def restricted ( ) : [EOL] return current_user . uid if current_user . is_authenticated else [string] [EOL] [EOL] @ login_manager . user_loader def load_user ( uid ) : [EOL] return AuthenticatedUser ( uid = uid ) [EOL] [EOL] self . mgr = login_manager [EOL] return app [EOL] [EOL] def login ( self ) : [EOL] response = self . client . get ( url_for ( [string] ) ) [EOL] self . assertEqual ( response . data . decode ( [string] ) , [string] ) [EOL] [EOL] [EOL] class SipaLoginManagerAuthenticationTest ( SipaLoginManagerTest ) : [EOL] def test_authentication_works ( self ) : [EOL] self . login ( ) [EOL] response = self . client . get ( url_for ( [string] ) ) [EOL] self . assertEqual ( response . data . decode ( [string] ) , [string] ) [EOL] [EOL] def test_decorator_called_without_parameter ( self ) : [EOL] with self . assertRaises ( TypeError ) : [EOL] @ self . app . route ( [string] ) @ self . mgr . disable_user_loading def view ( ) : [EOL] return False [EOL] [EOL] [EOL] class AppLevelUserLoadingDisabledTest ( SipaLoginManagerTest ) : [EOL] def create_app ( self ) : [EOL] app = super ( ) . create_app ( ) [EOL] [EOL] @ app . route ( [string] ) @ self . mgr . disable_user_loading ( ) def show_images ( ) : [EOL] [comment] [EOL] self . assertFalse ( current_user . is_authenticated ) [EOL] return [string] [EOL] [EOL] return app [EOL] [EOL] def test_login_manager ( self ) : [EOL] self . login ( ) [EOL] response = self . client . get ( url_for ( [string] ) ) [EOL] self . assertEqual ( response . data . decode ( [string] ) , [string] ) [EOL] self . assertIn ( [string] , self . mgr . ignored_endpoints ) [EOL] [EOL] [EOL] class BlueprintLevelUserLoadingDisabledTest ( SipaLoginManagerTest ) : [EOL] def create_app ( self ) : [EOL] app = super ( ) . create_app ( ) [EOL] bp = Blueprint ( name = [string] , import_name = [string] ) [EOL] [EOL] @ bp . route ( [string] ) @ self . mgr . disable_user_loading ( bp ) def show_documents ( ) : [EOL] self . assertFalse ( current_user . is_authenticated ) [EOL] return [string] [EOL] [EOL] @ bp . route ( [string] ) def show_images_as_well ( ) : [EOL] self . assertFalse ( current_user . is_authenticated ) [EOL] return [string] [EOL] self . mgr . ignore_endpoint ( [string] ) [EOL] [EOL] app . register_blueprint ( bp ) [EOL] return app [EOL] [EOL] def test_documents_no_user ( self ) : [EOL] self . login ( ) [EOL] response = self . client . get ( url_for ( [string] ) ) [EOL] self . assertEqual ( response . data . decode ( [string] ) , [string] ) [EOL] self . assertIn ( [string] , self . mgr . ignored_endpoints ) [EOL] [EOL] def test_images_no_user ( self ) : [EOL] self . login ( ) [EOL] response = self . client . get ( url_for ( [string] ) ) [EOL] self . assertEqual ( response . data . decode ( [string] ) , [string] ) [EOL] self . assertIn ( [string] , self . mgr . ignored_endpoints ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 $typing.Any$ 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 $sipa.login_manager.SipaLoginManager$ 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_login_manager.AuthenticatedUser$ 0 0 0 0 0 0 0 0 0 0 $tests.test_login_manager.AuthenticatedUser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.login_manager.SipaLoginManager$ 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type [EOL] import tests [EOL] import typing [EOL] from __future__ import annotations [EOL] from typing import Any , List , Optional [EOL] from unittest import TestCase [EOL] [EOL] from sipa . model . pycroft . unserialize import unserializer , MissingKeysError , ConversionError , UnserializationError [EOL] [EOL] [EOL] class UnserializerTest ( TestCase ) : [EOL] def test_basic_unserializer ( self ) : [EOL] @ unserializer class Foo : [EOL] bar = ... [EOL] [EOL] try : [EOL] f = Foo ( { [string] : [string] } ) [EOL] except TypeError : [EOL] self . fail ( [string] ) [EOL] self . assertEqual ( f . bar , [string] ) [EOL] [EOL] with self . assertRaises ( MissingKeysError ) : [EOL] Foo ( { [string] : [string] } ) [EOL] [EOL] def test_slash_stripping ( self ) : [EOL] @ unserializer class Foo : [EOL] type_ = ... [EOL] [EOL] with self . assertRaises ( MissingKeysError ) : [EOL] Foo ( { [string] : [string] } ) [EOL] [EOL] try : [EOL] f = Foo ( { [string] : [string] } ) [EOL] except TypeError : [EOL] self . fail ( [string] ) [EOL] self . assertEqual ( f . type , [string] ) [EOL] [EOL] def test_type_conversion ( self ) : [EOL] @ unserializer class Foo : [EOL] count = ... [EOL] [EOL] with self . assertRaises ( ConversionError ) : [EOL] Foo ( { [string] : [string] } ) [EOL] [EOL] def test_list_can_convert ( self ) : [EOL] @ unserializer class Foo : [EOL] items = ... [EOL] [EOL] try : [EOL] f = Foo ( { [string] : [ [string] , [string] ] } ) [EOL] except ConversionError : [EOL] self . fail ( ) [EOL] else : [EOL] self . assertEqual ( f . items , [ [string] , [string] ] ) [EOL] [EOL] def test_optional_can_convert ( self ) : [EOL] @ unserializer class Foo : [EOL] opt = ... [EOL] [EOL] try : [EOL] f = Foo ( { [string] : [string] } ) [EOL] self . assertEqual ( f . opt , [string] ) [EOL] except ConversionError : [EOL] self . fail ( ) [EOL] [EOL] try : [EOL] f = Foo ( { [string] : None } ) [EOL] self . assertEqual ( f . opt , None ) [EOL] except ConversionError : [EOL] self . fail ( ) [EOL] [EOL] def test_complex_unserializer ( self ) : [EOL] @ unserializer class Foo : [EOL] name = ... [EOL] id_ = ... [EOL] items = ... [EOL] [EOL] f = Foo ( { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] } ) [EOL] self . assertEqual ( f . name , [string] ) [EOL] self . assertEqual ( f . id , [number] ) [EOL] self . assertEqual ( f . items , [ [string] , [string] ] ) [EOL] [EOL] [EOL] class EmptyArgumentsTest ( TestCase ) : [EOL] @ unserializer class Foo : [EOL] bar = ... [EOL] [EOL] def test_no_argument_throws ( self ) : [EOL] with self . assertRaises ( MissingKeysError ) : [EOL] self . Foo ( ) [EOL] [EOL] def test_argument_none_throws ( self ) : [EOL] with self . assertRaises ( MissingKeysError ) : [EOL] self . Foo ( None ) [EOL] [EOL] [EOL] @ unserializer class Note : [EOL] id_ = ... [EOL] name = ... [EOL] [EOL] [EOL] @ unserializer class Bar : [comment] [EOL] description = ... [EOL] notes = ... [EOL] [EOL] [EOL] @ unserializer class Baz : [EOL] inner = ... [EOL] [EOL] [EOL] class NestedUnserializationTest ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . _bar_cls = Bar [EOL] try : [EOL] self . baz = Baz ( { [string] : { [string] : [string] , [string] : [ { [string] : [number] , [string] : [string] } , { [string] : [number] , [string] : [string] } ] } } ) [EOL] except UnserializationError as e : [EOL] self . fail ( f" [string] { e }" ) [EOL] [EOL] def test ( self ) : [EOL] self . assertIsInstance ( self . baz . inner , self . _bar_cls ) [EOL] self . assertEqual ( self . baz . inner . description , [string] ) [EOL] notes = self . baz . inner . notes [EOL] self . assertEqual ( len ( notes ) , [number] ) [EOL] self . assertEqual ( notes [ [number] ] . name , [string] ) [EOL] self . assertEqual ( notes [ [number] ] . id , [number] ) [EOL] self . assertEqual ( notes [ [number] ] . name , [string] ) [EOL] self . assertEqual ( notes [ [number] ] . id , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_basic_unserializer.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_basic_unserializer.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_slash_stripping.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_slash_stripping.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_list_can_convert.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_list_can_convert.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_optional_can_convert.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_optional_can_convert.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_optional_can_convert.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_optional_can_convert.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_complex_unserializer.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_complex_unserializer.Foo$ 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_complex_unserializer.Foo$ 0 0 0 0 0 0 0 0 0 0 $tests.test_unserialize.UnserializerTest.test_complex_unserializer.Foo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[Note]$ 0 0 0 0 0 0 0 0 0 0 0 $Bar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.test_unserialize.Bar]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Union , Dict , List [EOL] import typing [EOL] from itertools import permutations [EOL] from time import time [EOL] from unittest import TestCase [EOL] [EOL] from sipa . utils import dict_diff , replace_empty_handler_callables , timetag_today [EOL] [EOL] [EOL] class TimetagValidator ( TestCase ) : [EOL] def test_today_timetag ( self ) : [EOL] assert timetag_today ( ) == time ( ) // [number] [EOL] [EOL] [EOL] class TestDictDiff ( TestCase ) : [EOL] def test_diffs_same_dicts ( self ) : [EOL] dicts = [ { } , { [string] : [string] } , { [string] : [string] , [string] : { [string] : [string] } } ] [EOL] for d in dicts : [EOL] self . assertEqual ( set ( dict_diff ( d , d ) ) , set ( ) ) [EOL] [EOL] def test_diffs_one_different ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] dicts = [ { } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] for d1 , d2 in permutations ( dicts , [number] ) : [EOL] merged = d1 . copy ( ) [EOL] merged . update ( d2 ) [EOL] self . assertEqual ( set ( dict_diff ( d1 , merged ) ) , set ( d2 . keys ( ) ) ) [EOL] [EOL] [EOL] class TestHandlerReplacer ( TestCase ) : [EOL] @ staticmethod def do_nothing ( ) : [EOL] pass [EOL] [EOL] def assert_untouched ( self , data ) : [EOL] self . assertEqual ( data , replace_empty_handler_callables ( data , self . do_nothing ) ) [EOL] [EOL] def test_no_handlers_key ( self ) : [EOL] self . assert_untouched ( { } ) [EOL] self . assert_untouched ( { [string] : [string] , [string] : { [string] : [string] } } ) [EOL] [EOL] def test_leave_other_handlers ( self , ) : [EOL] self . assert_untouched ( { [string] : { } } ) [EOL] self . assert_untouched ( { [string] : { [string] : { [string] : None } , [string] : { [string] : [string] } , } } ) [EOL] [EOL] def test_leave_callables_not_None ( self , ) : [EOL] self . assert_untouched ( { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [number] , [string] : [string] } , [string] : { [string] : str } } } ) [EOL] [EOL] def test_callable_replaced_correctly ( self ) : [EOL] original = { [string] : { [string] : { [string] : None , [string] : [string] } } } [EOL] result = replace_empty_handler_callables ( original , self . do_nothing ) [EOL] self . assertEqual ( list ( dict_diff ( result , original ) ) , [ [string] ] , ) [EOL] [EOL] original = original [ [string] ] [EOL] result = result [ [string] ] [EOL] self . assertEqual ( list ( dict_diff ( result , original ) ) , [ [string] ] , ) [EOL] [EOL] original = original [ [string] ] [EOL] result = result [ [string] ] [EOL] self . assertEqual ( list ( dict_diff ( result , original ) ) , [ [string] ] , ) [EOL] self . assertEqual ( result [ [string] ] , self . do_nothing ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from flask import url_for [EOL] from . base import AppInitialized [EOL] [EOL] [EOL] class TestSipaFrontendCase ( AppInitialized ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] pass [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] def login ( self , username , password ) : [EOL] return self . client . post ( [string] , data = dict ( username = username , password = password ) , follow_redirects = True ) [EOL] [EOL] def logout ( self ) : [EOL] return self . client . get ( [string] , follow_redirects = True ) [EOL] [EOL] def test_root_redirect ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] self . assert_redirects ( response , url_for ( [string] ) ) [EOL] [EOL] def test_restricted_area ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] self . assert_redirects ( response , url_for ( [string] , next = [string] ) ) [EOL] [EOL] def test_unrestricted_area ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] self . assert404 ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Type [EOL] import tests [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from sipa . model . finance import BaseFinanceInformation [EOL] [EOL] [EOL] class EverythingMissingTestCase ( TestCase ) : [EOL] class InvalidInfo ( BaseFinanceInformation ) : [comment] [EOL] pass [EOL] [EOL] def test_cannot_inherit_base ( self ) : [EOL] with self . assertRaises ( TypeError ) : [EOL] self . InvalidInfo ( ) [comment] [EOL] [EOL] [EOL] class NoNeedToPayTestCase ( TestCase ) : [EOL] class DisabledFinanceInformation ( BaseFinanceInformation ) : [EOL] has_to_pay = False [EOL] raw_balance = [number] [EOL] history = [ ] [EOL] last_update = None [EOL] [EOL] def test_instanciation_works ( self ) : [EOL] self . DisabledFinanceInformation ( ) [EOL] [EOL] def test_has_correct_balance ( self ) : [EOL] balance = self . DisabledFinanceInformation ( ) . balance [EOL] self . assertTrue ( balance . empty ) [EOL] self . assertIn ( [string] , balance . value . lower ( ) ) [EOL] [EOL] [EOL] class StaticBalanceTestCase ( TestCase ) : [EOL] class StaticFinanceInformation ( BaseFinanceInformation ) : [EOL] has_to_pay = True [EOL] raw_balance = [number] [EOL] history = [ ] [EOL] last_update = None [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . balance = self . StaticFinanceInformation ( ) . balance [EOL] [EOL] def test_has_correct_balance ( self ) : [EOL] self . assertFalse ( self . balance . empty ) [EOL] self . assertIn ( [string] , self . balance . value ) [EOL] self . assertEqual ( self . balance . raw_value , [number] ) [EOL] [EOL] def test_balance_not_editable ( self ) : [EOL] self . assertFalse ( self . balance . capabilities . edit ) [EOL] [EOL] def test_balance_not_deletable ( self ) : [EOL] self . assertFalse ( self . balance . capabilities . delete ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Type [EOL] import tests [EOL] import typing [EOL] import sipa [EOL] import sipa . model . sample [EOL] from sipa . model . fancy_property import ( ActiveProperty , Capabilities , UnsupportedProperty , NO_CAPABILITIES ) [EOL] [EOL] from tests . base import SampleFrontendTestBase [EOL] [EOL] [EOL] class TestSampleUserCase ( SampleFrontendTestBase ) : [EOL] expected_result = { [string] : ( [string] , NO_CAPABILITIES ) , [string] : ( [string] , NO_CAPABILITIES ) , [string] : ( [string] , Capabilities ( edit = True , delete = False ) ) , [string] : ( [string] , Capabilities ( edit = True , delete = True ) ) , [string] : ( [string] , NO_CAPABILITIES ) , [string] : ( [string] , NO_CAPABILITIES ) , [string] : ( [string] , NO_CAPABILITIES ) , [string] : ( [string] , NO_CAPABILITIES ) , [string] : ( [string] , NO_CAPABILITIES ) , [string] : ( [string] , NO_CAPABILITIES ) , } [EOL] [EOL] rows = expected_result . keys ( ) [EOL] [EOL] def setUp ( self ) : [EOL] self . user = self . User ( [string] ) [EOL] self . sample_users = self . app . extensions [ [string] ] [EOL] [EOL] def test_uid_not_accepted ( self ) : [EOL] with self . assertRaises ( KeyError ) : [EOL] self . User ( [number] ) [EOL] [EOL] def test_uid_correct ( self ) : [EOL] self . assertEqual ( self . user . uid , self . sample_users [ [string] ] [ [string] ] ) [EOL] [EOL] def test_row_getters ( self ) : [EOL] [docstring] [EOL] [EOL] for key , val in self . expected_result . items ( ) : [EOL] if val : [EOL] self . assertEqual ( getattr ( self . user , key ) , ActiveProperty ( name = key , value = self . sample_users [ [string] ] [ val [ [number] ] ] , capabilities = val [ [number] ] , ) , ) [EOL] else : [EOL] self . assertEqual ( getattr ( self . user , key ) , UnsupportedProperty ( key ) , ) [EOL] [EOL] self . assertEqual ( self . user . userdb_status , UnsupportedProperty ( [string] ) ) [EOL] [EOL] def test_row_setters ( self ) : [EOL] for attr in self . rows : [EOL] class_attr = getattr ( self . user . __class__ , attr ) [EOL] [EOL] if class_attr . fset : [EOL] value = [string] [EOL] setattr ( self . user , attr , value ) [EOL] self . assertEqual ( getattr ( self . user , attr ) , value ) [EOL] elif not getattr ( self . user , attr ) . capabilities . edit : [EOL] assert not class_attr . fset [EOL] [EOL] def test_row_deleters ( self ) : [EOL] for attr in self . rows : [EOL] class_attr = getattr ( self . user . __class__ , attr ) [EOL] [EOL] if class_attr . fdel : [EOL] delattr ( self . user , attr ) [EOL] assert not getattr ( self . user , attr ) . raw_value [EOL] assert getattr ( self . user , attr ) . empty [EOL] [EOL] elif not getattr ( self . user , attr ) . capabilities . delete : [EOL] assert not class_attr . fdel [EOL] [EOL] def test_correct_password ( self ) : [EOL] user = self . User ( [string] ) [EOL] [comment] [EOL] user . re_authenticate ( self . sample_users [ [string] ] [ [string] ] ) [EOL] [EOL] def test_traffic_history ( self ) : [EOL] for day in self . user . traffic_history : [EOL] assert [number] <= day [ [string] ] <= [number] [EOL] assert [number] <= day [ [string] ] [EOL] assert [number] <= day [ [string] ] [EOL] self . assertEqual ( day [ [string] ] , day [ [string] ] + day [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $sipa.model.sample.user.User$ 0 0 0 0 0 0 0 0 0 0 $sipa.model.sample.user.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Type , Union , Dict , List [EOL] import unittest [EOL] import flask [EOL] import sipa [EOL] import typing [EOL] import ipaddress [EOL] import re [EOL] from base64 import urlsafe_b64encode [EOL] from os import urandom [EOL] from typing import cast [EOL] from unittest import TestCase [EOL] from unittest . mock import MagicMock [EOL] [EOL] from ipaddress import IPv4Network [EOL] from flask import Flask [EOL] [EOL] from sipa . backends import Backends , DataSource , Dormitory , InitContextCallable [EOL] [EOL] [EOL] class TestBackendInitializationCase ( TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . app = Flask ( [string] ) [EOL] self . app . config [ [string] ] = [ [string] ] [EOL] self . app . config [ [string] ] = False [EOL] datasource = DataSource ( name = [string] , user_class = object , mail_server = [string] , webmailer_url = [string] , support_mail = [string] , init_context = lambda app : None ) [EOL] [EOL] Dormitory ( name = [string] , display_name = [string] , datasource = datasource , subnets = [ IPv4Network ( [string] ) ] ) [EOL] [EOL] self . backends = Backends ( ) [EOL] self . backends . register ( datasource ) [EOL] self . backends . init_app ( self . app ) [EOL] self . backends . init_backends ( ) [EOL] [EOL] def test_extension_registrated ( self ) : [EOL] assert [string] in self . app . extensions [EOL] [EOL] def test_datasource_names_unique ( self ) : [EOL] names = [ dsrc . name for dsrc in self . backends . datasources ] [EOL] self . assertEqual ( len ( names ) , len ( set ( names ) ) ) [EOL] [EOL] def test_dormitory_names_unique ( self ) : [EOL] names = [ dorm . name for dorm in self . backends . dormitories ] [EOL] self . assertEqual ( len ( names ) , len ( set ( names ) ) ) [EOL] [EOL] def test_all_dormitories_names_unique ( self ) : [EOL] names = [ dorm . name for dorm in self . backends . all_dormitories ] [EOL] self . assertEqual ( len ( names ) , len ( set ( names ) ) ) [EOL] [EOL] def test_all_dormitories_greater ( self ) : [EOL] assert ( set ( self . backends . all_dormitories ) >= set ( self . backends . dormitories ) ) [EOL] [EOL] def assert_dormitories_namelist ( self , list , base ) : [EOL] [docstring] [EOL] self . assertEqual ( len ( list ) , len ( base ) ) [EOL] for name , display_name in list : [EOL] assert isinstance ( name , str ) [EOL] assert isinstance ( display_name , str ) [EOL] [EOL] def test_all_dormitories_list ( self ) : [EOL] self . assert_dormitories_namelist ( self . backends . dormitories_short , self . backends . all_dormitories , ) [EOL] [EOL] def test_supported_dormitories_list ( self ) : [EOL] self . assert_dormitories_namelist ( self . backends . supported_dormitories_short , self . backends . dormitories , ) [EOL] [EOL] def test_get_dormitory ( self ) : [EOL] for dormitory in self . backends . dormitories : [EOL] self . assertEqual ( self . backends . get_dormitory ( dormitory . name ) , dormitory ) [EOL] [EOL] possible_names = [ dorm . name for dorm in self . backends . dormitories ] [EOL] [EOL] for str_length in range ( [number] ) : [EOL] random_string = None [EOL] while random_string in possible_names : [EOL] random_string = urlsafe_b64encode ( urandom ( str_length ) ) [EOL] [EOL] assert self . backends . get_dormitory ( random_string ) is None [EOL] [EOL] def test_dormitory_from_ip ( self ) : [EOL] for dorm in self . backends . dormitories : [EOL] first_ip = next ( dorm . subnets . subnets [ [number] ] . hosts ( ) ) [EOL] [EOL] self . assertEqual ( self . backends . dormitory_from_ip ( first_ip ) , dorm ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class DatasourceTestCase ( TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . default_args = { [string] : [string] , [string] : object , [string] : [string] , } [EOL] self . app = MagicMock ( ) [EOL] self . app . config = { } [EOL] [EOL] def test_init_context_gets_called_correctly ( self ) : [EOL] init_mock = cast ( InitContextCallable , MagicMock ( ) ) [EOL] datasource = DataSource ( ** self . default_args , init_context = init_mock , ) [EOL] [EOL] datasource . init_context ( self . app ) [EOL] [EOL] self . assertEqual ( init_mock . call_args [ [number] ] , ( self . app , ) ) [EOL] [EOL] def test_init_context_reads_mail ( self ) : [EOL] datasource = DataSource ( ** self . default_args ) [EOL] config = { [string] : [string] } [EOL] self . app . config [ [string] ] = { datasource . name : config } [EOL] [EOL] datasource . init_context ( self . app ) [EOL] [EOL] self . assertEqual ( datasource . support_mail , config [ [string] ] ) [EOL] [EOL] def test_init_context_warns_on_unknown_keys ( self ) : [EOL] bad_keys = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] datasource = DataSource ( ** self . default_args ) [EOL] bad_config = { key : None for key in bad_keys } [EOL] self . app . config [ [string] ] = { datasource . name : bad_config } [EOL] [EOL] with self . assertLogs ( [string] , level = [string] ) as context : [EOL] datasource . init_context ( self . app ) [EOL] [EOL] for log in context . output : [EOL] self . assertRegex ( log , re . compile ( [string] , flags = re . IGNORECASE ) ) [EOL] self . assertTrue ( any ( key in log for key in bad_keys ) , msg = [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.extension.Backends$ 0 0 0 0 0 0 0 $sipa.backends.extension.Backends$ 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 $sipa.backends.extension.Backends$ 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 $sipa.backends.extension.Backends$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 $typing.List[builtins.str]$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ipaddress.IPv4Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ipaddress.IPv4Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Type[builtins.object],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[flask.app.Flask],None]$ 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[flask.app.Flask],None]$ 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[flask.app.Flask],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Union , List , Type [EOL] import tests [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from sipa . utils import compare_all_attributes , xor_hashes [EOL] [EOL] [EOL] class CompareAllAttributesTestCase ( TestCase ) : [EOL] class A : [EOL] a = [string] [EOL] b = [string] [EOL] c = [string] [EOL] [EOL] class B : [EOL] a = [string] [EOL] b = [string] [EOL] c = [string] [EOL] [EOL] class C : [EOL] a = [string] [EOL] b = [string] [EOL] c = [string] [EOL] [EOL] def test_true_comparisons ( self ) : [EOL] arglist = [ ( self . A , self . B , [ [string] , [string] ] ) , ( self . A , self . C , [ [string] , [string] ] ) , ] [EOL] for args in arglist : [EOL] self . assertTrue ( compare_all_attributes ( * args ) ) [EOL] [EOL] def test_false_comparisons ( self ) : [EOL] arglist = [ ( self . A , self . B , [ [string] , [string] ] ) , ( self . A , self . C , [ [string] , [string] ] ) , ( self . A , self . B , [ [string] , [string] , [string] ] ) , ( self . A , self . C , [ [string] , [string] , [string] ] ) , ] [EOL] for args in arglist : [EOL] self . assertFalse ( compare_all_attributes ( * args ) ) [EOL] [EOL] def test_attributes_missing_false ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . assertFalse ( compare_all_attributes ( self . A , [string] , [ [string] ] ) ) [EOL] except AttributeError : [EOL] self . fail ( [string] ) [EOL] [EOL] [EOL] class XorHashesTestCase ( TestCase ) : [EOL] def test_xor_hashes_correct ( self ) : [EOL] a = [string] [EOL] b = [string] [EOL] c = [string] [EOL] d = [number] [EOL] e = True [EOL] f = None [EOL] expected = hash ( a ) ^ hash ( b ) ^ hash ( c ) ^ hash ( d ) ^ hash ( e ) ^ hash ( f ) [EOL] self . assertEqual ( xor_hashes ( a , b , c , d , e , f ) , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Type[tests.model.test_misc.CompareAllAttributesTestCase.A],typing.Type[typing.Union[tests.model.test_misc.CompareAllAttributesTestCase.B,tests.model.test_misc.CompareAllAttributesTestCase.C]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Type[tests.model.test_misc.CompareAllAttributesTestCase.A],typing.Type[typing.Union[tests.model.test_misc.CompareAllAttributesTestCase.B,tests.model.test_misc.CompareAllAttributesTestCase.C]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Type[tests.model.test_misc.CompareAllAttributesTestCase.A],typing.Type[typing.Union[tests.model.test_misc.CompareAllAttributesTestCase.B,tests.model.test_misc.CompareAllAttributesTestCase.C]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Type[tests.model.test_misc.CompareAllAttributesTestCase.A],typing.Type[typing.Union[tests.model.test_misc.CompareAllAttributesTestCase.B,tests.model.test_misc.CompareAllAttributesTestCase.C]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.str$ 0 $None$ 0 0 $builtins.int$ 0 0
	0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] from unittest . mock import patch , MagicMock [EOL] [EOL] from flask import url_for [EOL] [EOL] from tests . base import SampleFrontendTestBase [EOL] [EOL] [EOL] class BpFeaturesTestCase ( SampleFrontendTestBase ) : [EOL] def test_bustimes_reachable ( self ) : [EOL] mock = MagicMock ( ) [EOL] with patch ( [string] , mock ) : [EOL] resp = self . client . get ( url_for ( [string] ) ) [EOL] [EOL] self . assert200 ( resp ) [EOL] self . assertTemplateUsed ( [string] ) [EOL] self . assertTrue ( mock . called ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] from functools import partial [EOL] from urllib . parse import urljoin [EOL] [EOL] from flask import abort , url_for [EOL] from tests . base import SampleFrontendTestBase , FormTemplateTestMixin [EOL] [EOL] [EOL] class TestErrorhandlersCase ( SampleFrontendTestBase ) : [EOL] used_codes = [ [number] , [number] , [number] ] [EOL] [EOL] def create_app ( self ) : [EOL] test_app = super ( ) . create_app ( ) [EOL] [EOL] def failing ( code ) : [EOL] abort ( code ) [EOL] [EOL] for code in self . used_codes : [EOL] test_app . add_url_rule ( rule = [string] . format ( code ) , endpoint = [string] . format ( code ) , view_func = partial ( failing , code = code ) , ) [EOL] [EOL] return test_app [EOL] [EOL] def test_error_handler_redirection ( self ) : [EOL] for code in self . used_codes : [EOL] self . client . get ( [string] . format ( code ) ) [EOL] self . assertTemplateUsed ( [string] ) [EOL] [EOL] [EOL] class GenericEndpointsReachableTestCase ( SampleFrontendTestBase ) : [EOL] def test_index_redirects_correctly ( self ) : [EOL] response = self . client . get ( [string] ) [EOL] self . assertRedirects ( response , [string] ) [EOL] [EOL] def test_index_reachable ( self ) : [EOL] self . assert200 ( self . client . get ( [string] , follow_redirects = True ) ) [EOL] [EOL] def test_usertraffic_permitted ( self ) : [EOL] self . login ( ) [EOL] self . assert200 ( self . client . get ( url_for ( [string] ) ) ) [EOL] self . logout ( ) [EOL] [EOL] def test_api_reachable ( self ) : [EOL] rv = self . client . get ( url_for ( [string] ) ) [EOL] self . assert200 ( rv ) [EOL] [EOL] def test_version_reachable ( self ) : [EOL] self . assert200 ( self . client . get ( url_for ( [string] ) ) ) [EOL] self . assertTemplateUsed ( [string] ) [EOL] [EOL] [EOL] class LoginTestCase ( FormTemplateTestMixin , SampleFrontendTestBase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . url = url_for ( [string] ) [EOL] self . dormitory = [string] [EOL] self . template = [string] [EOL] [EOL] self . valid_data = [ { [string] : self . dormitory , [string] : [string] , [string] : [string] , [string] : [string] , } ] [EOL] self . invalid_data = [ { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] + self . dormitory } , { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] } , ] [EOL] [EOL] [EOL] class ContactFormTestBase ( SampleFrontendTestBase ) : [EOL] [docstring] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] logging . disable ( logging . CRITICAL ) [EOL] [EOL] def tearDown ( self ) : [EOL] logging . disable ( logging . NOTSET ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] [EOL] class AnonymousContactTestCase ( FormTemplateTestMixin , ContactFormTestBase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . url = url_for ( [string] ) [EOL] self . dormitory = [string] [EOL] self . template = [string] [EOL] [EOL] self . valid_data = [ { [string] : [string] , [string] : [string] , [string] : self . dormitory , [string] : [string] , [string] : [string] , } ] [EOL] self . invalid_data = [ { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] + self . dormitory } , { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] } , ] [EOL] [EOL] [EOL] class OfficialContactTestCase ( FormTemplateTestMixin , ContactFormTestBase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . url = url_for ( [string] ) [EOL] self . template = [string] [EOL] [EOL] self . valid_data = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] [EOL] self . invalid_data = [ { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] } , { ** self . valid_data [ [number] ] , [string] : [string] } , ] [EOL] [EOL] [EOL] class InexistentUrlTest ( SampleFrontendTestBase ) : [EOL] def test_nonexistent_url_returns_404 ( self ) : [EOL] fake_url = urljoin ( url_for ( [string] ) , [string] ) [EOL] response = self . client . get ( fake_url ) [EOL] self . assert404 ( response ) [EOL] self . assertIsNone ( response . location ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
[comment] [EOL] from typing import Any , Set [EOL] import typing [EOL] import logging [EOL] from unittest . mock import patch [EOL] [EOL] from tests . base import AppInitialized , disable_logs [EOL] [EOL] [EOL] GIT_HOOK_URL = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] _HTTP_METHODS = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] } [EOL] HTTP_METHODS = _HTTP_METHODS - { [string] } [EOL] [EOL] [EOL] class GitHookTestBase ( AppInitialized ) : [EOL] def assert_hook_status ( self , status , token = None ) : [EOL] url = GIT_HOOK_URL [EOL] if token is not None : [EOL] url = [string] . format ( base = url , token = token ) [EOL] [EOL] self . assertEqual ( self . client . post ( url ) . status_code , status ) [EOL] [EOL] [EOL] class GitHookNoToken ( GitHookTestBase ) : [EOL] def test_git_hook_wrong_method ( self ) : [EOL] [docstring] [EOL] for method in HTTP_METHODS - { [string] } : [EOL] with self . subTest ( method = method ) : [EOL] response = self . client . open ( GIT_HOOK_URL , method = method ) [EOL] self . assertEqual ( response . status_code , [number] ) [EOL] [EOL] def test_git_hook_not_existent ( self ) : [EOL] [docstring] [EOL] self . assert_hook_status ( [number] ) [EOL] [EOL] [EOL] class GitHookExistent ( GitHookTestBase ) : [EOL] token = [string] [EOL] [EOL] @ property def app_config ( self ) : [EOL] return { ** super ( ) . app_config , [string] : self . token , } [EOL] [EOL] def test_no_token_auth_required ( self ) : [EOL] [docstring] [EOL] self . assert_hook_status ( [number] ) [EOL] [EOL] def test_empty_token_auth_required ( self ) : [EOL] self . assert_hook_status ( [number] , token = [string] ) [EOL] [EOL] def test_wrong_token_permission_denied ( self ) : [EOL] [docstring] [EOL] with disable_logs ( logging . WARNING ) : [EOL] self . assert_hook_status ( [number] , token = self . token + [string] ) [EOL] [EOL] def test_correct_token_working ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] with patch ( [string] ) as mock : [EOL] self . assert_hook_status ( [number] , token = self . token ) [EOL] self . assertTrue ( mock . called ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] from unittest . mock import patch [EOL] [EOL] from flask import url_for [EOL] [EOL] from tests . base import SampleFrontendTestBase [EOL] from sipa . blueprints . usersuite import get_attribute_endpoint [EOL] [EOL] [EOL] class SampleAuthenticationTestCase ( SampleFrontendTestBase ) : [EOL] def test_login_successful ( self ) : [EOL] [docstring] [EOL] rv = self . login ( ) [EOL] print ( [string] , rv ) [EOL] from pprint import pprint [EOL] pprint ( rv . data . decode ( [string] ) ) [EOL] self . assertRedirects ( rv , url_for ( [string] ) ) [EOL] [EOL] def test_logout_successful ( self ) : [EOL] self . login ( ) [EOL] rv = self . logout ( ) [EOL] if rv . status_code == [number] : [EOL] self . fail ( [string] ) [EOL] self . assert_redirects ( rv , url_for ( [string] ) ) [EOL] [EOL] [EOL] class SampleAuthenticatedTestBase ( SampleFrontendTestBase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . login ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . logout ( ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] [EOL] class UsersuiteReachableTestCase ( SampleAuthenticatedTestBase ) : [EOL] def test_usersuite_200 ( self ) : [EOL] self . assert200 ( self . client . get ( url_for ( [string] ) ) ) [EOL] [EOL] def test_contact_200 ( self ) : [EOL] self . assert200 ( self . client . get ( url_for ( [string] ) ) ) [EOL] [EOL] def test_mac_edit_200 ( self ) : [EOL] self . assert200 ( self . client . get ( url_for ( [string] ) ) ) [EOL] [EOL] def activate_network_access_200 ( self ) : [EOL] self . assert200 ( self . client . get ( url_for ( [string] ) ) ) [EOL] [EOL] def test_mail_edit_200 ( self ) : [EOL] self . assert200 ( self . client . get ( url_for ( [string] ) ) ) [EOL] [EOL] def test_usersuite_contains_urls ( self ) : [EOL] [docstring] [EOL] usersuite_response = self . client . get ( url_for ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with patch ( [string] ) : [EOL] urls = [ * ( url_for ( get_attribute_endpoint ( attr ) ) for attr in [ [string] , [string] ] ) , * ( url_for ( get_attribute_endpoint ( attr , capability = [string] ) ) for attr in [ [string] ] ) , url_for ( [string] ) , url_for ( [string] ) , ] [EOL] [EOL] for url in urls : [EOL] with self . subTest ( url = url ) : [EOL] self . assertRegex ( usersuite_response . data . decode ( [string] ) , [string] . format ( url ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from flask import request as flask_request [EOL] from flask . sessions import SecureCookieSessionInterface [EOL] [EOL] [EOL] class SeparateLocaleCookieSessionInterface ( SecureCookieSessionInterface ) : [EOL] [docstring] [EOL] def _copy_session ( self , session , data ) : [EOL] [docstring] [EOL] new_session = self . session_class ( data ) [EOL] new_session . new = session . new [EOL] new_session . modified = session . modified [EOL] return new_session [EOL] [EOL] def open_session ( self , app , request ) : [EOL] session = super ( ) . open_session ( app , request ) [EOL] locale = request . cookies . get ( app . config [ [string] ] ) [EOL] if not locale : [EOL] return session [EOL] [EOL] data = dict ( session , locale = locale ) [EOL] new_session = self . _copy_session ( session , data ) [EOL] return new_session [EOL] [EOL] def save_session ( self , app , session , response ) : [EOL] domain = self . get_cookie_domain ( app ) [EOL] path = self . get_cookie_path ( app ) [EOL] missing = object ( ) [EOL] locale = session . get ( [string] , missing ) [EOL] [EOL] if locale is missing and [string] in flask_request . cookies : [EOL] [comment] [EOL] response . delete_cookie ( app . config [ [string] ] , domain = domain , path = path ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] data = dict ( session ) [EOL] data . pop ( [string] , None ) [EOL] new_session = self . _copy_session ( session , data ) [EOL] super ( ) . save_session ( app , new_session , response ) [EOL] [EOL] if locale is missing or not self . should_set_cookie ( app , session ) : [EOL] return [EOL] [EOL] expires = self . get_expiration_time ( app , session ) [EOL] response . set_cookie ( app . config [ [string] ] , locale , expires = expires , httponly = False , secure = False , max_age = app . config [ [string] ] , domain = domain , path = path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 $typing.Any$ 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0
[comment] [EOL] from functools import wraps [EOL] [EOL] from flask import request , Blueprint [EOL] from flask_babel import gettext [EOL] from flask_login import LoginManager [EOL] [EOL] [EOL] class SipaLoginManager ( LoginManager ) : [EOL] def __init__ ( self , * a , ** kw ) : [EOL] super ( ) . __init__ ( * a , ** kw ) [EOL] self . localize_callback = gettext [EOL] self . login_message = [string] [EOL] self . ignored_endpoints = set ( ) [EOL] self . _wrapped_user_callback = None [EOL] [EOL] def ignore_endpoint ( self , endpoint_name ) : [EOL] self . ignored_endpoints . add ( endpoint_name ) [EOL] [EOL] def disable_user_loading ( self , bp = None ) : [EOL] [docstring] [EOL] if bp is None : [EOL] def endpoint_name ( f ) : [EOL] return f . __name__ [EOL] else : [EOL] if not isinstance ( bp , Blueprint ) : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] def endpoint_name ( f ) : [EOL] return [string] . format ( bp . name , f . __name__ ) [EOL] [EOL] def decorate ( f ) : [EOL] self . ignore_endpoint ( endpoint_name ( f ) ) [EOL] return f [EOL] return decorate [EOL] [EOL] @ property def user_callback ( self ) : [EOL] return self . _wrapped_user_callback [EOL] [EOL] @ user_callback . setter def user_callback ( self , f ) : [EOL] @ wraps ( f ) def wrapped_user_callback ( user_id ) : [EOL] if request . endpoint in self . ignored_endpoints : [EOL] return self . anonymous_user ( ) [EOL] return f ( user_id ) [EOL] [EOL] self . _wrapped_user_callback = wrapped_user_callback [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] from functools import wraps [EOL] from math import log , floor [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] UNIT_LIST = [ [string] , [string] , [string] ] [EOL] [comment] [EOL] [comment] [EOL] TRAFFIC_FORMAT_STRING = [string] [EOL] [comment] [EOL] [comment] [EOL] MONEY_FORMAT_STRING = [string] [EOL] [EOL] [EOL] def max_divisions ( number , base = [number] , unit_list = None ) : [EOL] [docstring] [EOL] if unit_list is None : [EOL] unit_list = UNIT_LIST [EOL] [EOL] [comment] [EOL] if number == [number] : [EOL] return [number] [EOL] [EOL] return max ( [number] , min ( floor ( log ( abs ( number ) , base ) ) , len ( unit_list ) - [number] ) ) [EOL] [EOL] [EOL] def reduce_by_base ( number , divisions , base = [number] ) : [EOL] [docstring] [EOL] return number / base ** divisions [EOL] [EOL] [EOL] def format_as_traffic ( number , divisions , divide = True ) : [EOL] [docstring] [EOL] if divide : [EOL] number = reduce_by_base ( number , divisions ) [EOL] return TRAFFIC_FORMAT_STRING . format ( number , UNIT_LIST [ divisions ] ) [EOL] [EOL] [EOL] def dynamic_unit ( number ) : [EOL] [docstring] [EOL] divisions = max_divisions ( number ) [EOL] return format_as_traffic ( number , divisions = divisions , divide = True ) [EOL] [EOL] [EOL] def money ( func ) : [EOL] [docstring] [EOL] @ wraps ( func ) def _wrapped_func ( * args , ** kwargs ) : [EOL] amount = func ( * args , ** kwargs ) [EOL] [EOL] return { [string] : format_money ( amount ) , [string] : amount , [string] : money_style ( amount ) } [EOL] [EOL] return _wrapped_func [EOL] [EOL] [EOL] def money_style ( amount ) : [EOL] [docstring] [EOL] return [string] if amount >= [number] else [string] [EOL] [EOL] [EOL] def format_money ( amount ) : [EOL] [docstring] [EOL] return MONEY_FORMAT_STRING . format ( amount ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Any , Iterator , List , Type [EOL] import typing [EOL] import sipa [EOL] import re [EOL] from datetime import date [EOL] from operator import itemgetter [EOL] [EOL] from flask_babel import gettext , lazy_gettext [EOL] from flask import flash [EOL] from flask_wtf import FlaskForm [EOL] from werkzeug . local import LocalProxy [EOL] from wtforms import ( BooleanField , HiddenField , PasswordField , SelectField , StringField , TextAreaField , RadioField , IntegerField , DateField ) [EOL] from wtforms . validators import ( AnyOf , DataRequired , Email , EqualTo , MacAddress , Regexp , ValidationError , NumberRange , Optional , Length ) [EOL] [EOL] from sipa . backends . extension import backends [EOL] [EOL] [EOL] class PasswordComplexity ( object ) : [EOL] character_classes = ( ( re . compile ( [string] ) , lazy_gettext ( [string] ) ) , ( re . compile ( [string] ) , lazy_gettext ( [string] ) ) , ( re . compile ( [string] ) , lazy_gettext ( [string] ) ) , ( re . compile ( [string] ) , lazy_gettext ( [string] ) ) ) [EOL] default_message = lazy_gettext ( [string] [string] [string] ) [EOL] [EOL] def __init__ ( self , min_length = [number] , min_classes = [number] , message = None ) : [EOL] self . min_length = min_length [EOL] self . min_classes = min_classes [EOL] self . message = message [EOL] [EOL] def __call__ ( self , form , field , message = None ) : [EOL] password = field . data or [string] [EOL] [EOL] if len ( password ) < self . min_length : [EOL] self . raise_error ( message ) [EOL] matched_classes = sum ( [number] for pattern , name in self . character_classes if pattern . search ( password ) ) [EOL] if matched_classes < self . min_classes : [EOL] self . raise_error ( message ) [EOL] [EOL] def raise_error ( self , message ) : [EOL] if message is None : [EOL] if self . message is None : [EOL] message = self . default_message [EOL] else : [EOL] message = self . message [EOL] classes_descriptions = map ( itemgetter ( [number] ) , self . character_classes ) [EOL] classes = [string] . join ( map ( str , classes_descriptions ) ) [EOL] raise ValidationError ( message . format ( min_length = self . min_length , min_classes = self . min_classes , classes = classes ) ) [EOL] [EOL] [EOL] def strip_filter ( string ) : [EOL] return string . strip ( ) if string else None [EOL] [EOL] [EOL] class StrippedStringField ( StringField ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] kwargs [ [string] ] = kwargs . get ( [string] , [ ] ) + [ strip_filter ] [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class ReadonlyStringField ( StrippedStringField ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] return super ( ) . __call__ ( * args , readonly = True , ** kwargs ) [EOL] [EOL] [EOL] class EmailField ( StrippedStringField ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] validators = [ DataRequired ( lazy_gettext ( [string] ) ) , Email ( lazy_gettext ( [string] ) ) ] [EOL] if [string] in kwargs : [EOL] kwargs [ [string] ] . extend ( validators ) [EOL] else : [EOL] kwargs [ [string] ] = validators [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class SpamCheckField ( StringField ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] c = kwargs . pop ( [string] , [string] ) or kwargs . pop ( [string] , [string] ) [EOL] kwargs [ [string] ] = [string] % ( [string] , c ) [EOL] kwargs [ [string] ] = [string] [EOL] return super ( ) . __call__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class SpamProtectedForm ( FlaskForm ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] website = SpamCheckField ( label = [string] , validators = [ Length ( [number] , [number] , [string] ) ] ) [EOL] [EOL] [EOL] class ContactForm ( SpamProtectedForm ) : [EOL] email = EmailField ( label = lazy_gettext ( [string] ) ) [EOL] type = SelectField ( label = lazy_gettext ( [string] ) , choices = [ ( [string] , lazy_gettext ( [string] ) ) , ( [string] , lazy_gettext ( [string] ) ) , ( [string] , lazy_gettext ( [string] ) ) , ( [string] , lazy_gettext ( [string] ) ) ] ) [EOL] subject = StrippedStringField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] message = TextAreaField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] [EOL] class AnonymousContactForm ( SpamProtectedForm ) : [EOL] email = EmailField ( label = lazy_gettext ( [string] ) ) [EOL] name = StringField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] , ) [EOL] dormitory = SelectField ( label = lazy_gettext ( [string] ) , choices = LocalProxy ( lambda : backends . dormitories_short ) , default = LocalProxy ( lambda : backends . preferred_dormitory_name ( ) ) , ) [EOL] subject = StrippedStringField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] message = TextAreaField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] [EOL] class OfficialContactForm ( SpamProtectedForm ) : [EOL] email = EmailField ( label = lazy_gettext ( [string] ) ) [EOL] name = StringField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] , ) [EOL] subject = StrippedStringField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] message = TextAreaField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] [EOL] class ChangePasswordForm ( FlaskForm ) : [EOL] old = PasswordField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] new = PasswordField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) , PasswordComplexity ( ) , ] ) [EOL] confirm = PasswordField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) , EqualTo ( [string] , message = lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] [EOL] class ChangeMailForm ( FlaskForm ) : [EOL] password = PasswordField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] email = EmailField ( label = lazy_gettext ( [string] ) ) [EOL] [EOL] [EOL] class DeleteMailForm ( FlaskForm ) : [EOL] password = PasswordField ( validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] [EOL] def require_unicast_mac ( form , field ) : [EOL] [docstring] [EOL] if int ( field . data [ [number] ] , [number] ) % [number] : [EOL] raise ValidationError ( gettext ( [string] ) ) [EOL] [EOL] [EOL] class ChangeMACForm ( FlaskForm ) : [EOL] password = PasswordField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] mac = StrippedStringField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) , MacAddress ( lazy_gettext ( [string] ) ) , require_unicast_mac ] , description = [string] ) [EOL] host_name = StringField ( label = lazy_gettext ( [string] ) , validators = [ Regexp ( regex = [string] , message = lazy_gettext ( [string] ) ) , Optional ( ) , Length ( - [number] , [number] , lazy_gettext ( [string] ) ) ] , description = lazy_gettext ( [string] ) , ) [EOL] [EOL] [EOL] class ActivateNetworkAccessForm ( FlaskForm ) : [EOL] password = PasswordField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] mac = StrippedStringField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) , MacAddress ( lazy_gettext ( [string] ) ) , require_unicast_mac ] , description = [string] ) [EOL] birthdate = DateField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] , description = lazy_gettext ( [string] ) ) [EOL] host_name = StringField ( label = lazy_gettext ( [string] ) , validators = [ Regexp ( regex = [string] , message = lazy_gettext ( [string] ) ) , Optional ( ) , Length ( - [number] , [number] , lazy_gettext ( [string] ) ) ] , description = lazy_gettext ( [string] ) ) [EOL] [EOL] [EOL] class TerminateMembershipForm ( FlaskForm ) : [EOL] end_date = DateField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] , description = lazy_gettext ( [string] ) ) [EOL] [EOL] def validate_end_date ( form , field ) : [EOL] if field . data < date . today ( ) : [EOL] raise ValidationError ( lazy_gettext ( [string] [string] ) ) [EOL] [EOL] [EOL] class TerminateMembershipConfirmForm ( FlaskForm ) : [EOL] end_date = DateField ( label = lazy_gettext ( [string] ) , render_kw = { [string] : True } , validators = [ DataRequired ( [string] ) ] ) [EOL] [EOL] estimated_balance = StringField ( label = lazy_gettext ( [string] ) , render_kw = { [string] : True } , validators = [ DataRequired ( [string] ) ] ) [EOL] [EOL] confirm_termination = BooleanField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] confirm_settlement = BooleanField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] confirm_donation = BooleanField ( label = lazy_gettext ( [string] [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] [EOL] class ContinueMembershipForm ( FlaskForm ) : [EOL] confirm_continuation = BooleanField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] [EOL] class LoginForm ( FlaskForm ) : [EOL] dormitory = SelectField ( lazy_gettext ( [string] ) , choices = LocalProxy ( lambda : backends . dormitories_short ) , default = LocalProxy ( lambda : backends . preferred_dormitory_name ( ) ) , validators = [ LocalProxy ( lambda : AnyOf ( [ dorm . name for dorm in backends . dormitories ] , message = lazy_gettext ( [string] ) ) ) ] ) [EOL] username = StrippedStringField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) , Regexp ( [string] , message = lazy_gettext ( [string] ) ) , ] , ) [EOL] password = PasswordField ( label = lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) ] ) [EOL] remember = BooleanField ( label = lazy_gettext ( [string] ) ) [EOL] [EOL] [EOL] class HostingForm ( FlaskForm ) : [EOL] password = PasswordField ( lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) , PasswordComplexity ( ) , ] ) [EOL] confirm = PasswordField ( lazy_gettext ( [string] ) , validators = [ DataRequired ( lazy_gettext ( [string] ) ) , EqualTo ( [string] , message = lazy_gettext ( [string] ) ) ] ) [EOL] action = HiddenField ( ) [EOL] [EOL] [EOL] class PaymentForm ( FlaskForm ) : [EOL] months = IntegerField ( lazy_gettext ( [string] ) , default = [number] , validators = [ NumberRange ( min = [number] , message = lazy_gettext ( [string] ) ) ] ) [EOL] [EOL] [EOL] def flash_formerrors ( form ) : [EOL] [docstring] [EOL] for field , errors in list ( form . errors . items ( ) ) : [EOL] for e in errors : [EOL] flash ( e , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.PasswordComplexity]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.SpamCheckField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.EmailField$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ContactForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.StrippedStringField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ContactForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.EmailField$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.AnonymousContactForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.AnonymousContactForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.StrippedStringField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.AnonymousContactForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.EmailField$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.OfficialContactForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.StrippedStringField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.OfficialContactForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ChangePasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ChangePasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ChangePasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ChangeMailForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.EmailField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.DeleteMailForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ChangeMACForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.StrippedStringField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ChangeMACForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ActivateNetworkAccessForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.StrippedStringField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ActivateNetworkAccessForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ActivateNetworkAccessForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.TerminateMembershipForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.TerminateMembershipConfirmForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.TerminateMembershipConfirmForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.TerminateMembershipConfirmForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.TerminateMembershipConfirmForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.TerminateMembershipConfirmForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.ContinueMembershipForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.LoginForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.forms.StrippedStringField$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.LoginForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.LoginForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.HostingForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.HostingForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.HostingForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.forms.PaymentForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional [EOL] import typing [EOL] import sipa [EOL] [docstring] [EOL] from flask import request , session [EOL] from flask_login import AnonymousUserMixin [EOL] from werkzeug . routing import IntegerConverter as BaseIntegerConverter [EOL] [EOL] from sipa . login_manager import SipaLoginManager [EOL] from sipa . backends import backends [EOL] [EOL] login_manager = SipaLoginManager ( ) [EOL] login_manager . login_view = [string] [EOL] [EOL] [EOL] class IntegerConverter ( BaseIntegerConverter ) : [EOL] [docstring] [EOL] regex = [string] [EOL] [EOL] [EOL] @ login_manager . user_loader def load_user ( username ) : [EOL] [docstring] [EOL] dormitory = backends . get_dormitory ( session . get ( [string] , None ) ) [EOL] if dormitory : [EOL] return dormitory . datasource . user_class . get ( username ) [EOL] else : [EOL] return AnonymousUserMixin ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.login_manager.SipaLoginManager$ 0 0 0 0 0 0 0 0 0 0 0 $sipa.login_manager.SipaLoginManager$ 0 0 0 0 0 $sipa.login_manager.SipaLoginManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $sipa.login_manager.SipaLoginManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any [EOL] import logging [EOL] import typing [EOL] import sipa [EOL] import logging [EOL] import logging . config [EOL] import os [EOL] import os . path [EOL] from datetime import datetime [EOL] [EOL] from flask_babel import Babel , get_locale [EOL] from raven import setup_logging [EOL] from raven . contrib . flask import Sentry [EOL] from raven . handlers . logging import SentryHandler [EOL] from werkzeug . contrib . fixers import ProxyFix [EOL] from flask_qrcode import QRcode [EOL] [EOL] from sipa . babel import possible_locales , save_user_locale_setting , select_locale [EOL] from sipa . base import IntegerConverter , login_manager [EOL] from sipa . blueprints . usersuite import get_attribute_endpoint [EOL] from sipa . defaults import DEFAULT_CONFIG [EOL] from sipa . flatpages import CategorizedFlatPages [EOL] from sipa . model import build_backends_ext [EOL] from sipa . model . misc import should_display_traffic_data [EOL] from sipa . session import SeparateLocaleCookieSessionInterface [EOL] from sipa . utils import replace_empty_handler_callables , url_self [EOL] from sipa . utils . babel_utils import get_weekday [EOL] from sipa . utils . git_utils import init_repo , update_repo [EOL] from sipa . utils . graph_utils import generate_traffic_chart , provide_render_function [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . addHandler ( logging . StreamHandler ( ) ) [comment] [EOL] [EOL] [EOL] def init_app ( app , ** kwargs ) : [EOL] [docstring] [EOL] load_config_file ( app , config = kwargs . pop ( [string] , None ) ) [EOL] app . wsgi_app = ProxyFix ( app . wsgi_app , app . config [ [string] ] ) [EOL] init_logging ( app ) [EOL] init_env_and_config ( app ) [EOL] logger . debug ( [string] ) [EOL] login_manager . init_app ( app ) [EOL] babel = Babel ( ) [EOL] babel . init_app ( app ) [EOL] babel . localeselector ( select_locale ) [EOL] app . before_request ( save_user_locale_setting ) [EOL] app . session_interface = SeparateLocaleCookieSessionInterface ( ) [EOL] cf_pages = CategorizedFlatPages ( ) [EOL] cf_pages . init_app ( app ) [EOL] backends = build_backends_ext ( ) [EOL] backends . init_app ( app ) [EOL] QRcode ( app ) [EOL] [EOL] app . url_map . converters [ [string] ] = IntegerConverter [EOL] [EOL] from sipa . blueprints import bp_features , bp_usersuite , bp_pages , bp_documents , bp_news , bp_generic , bp_hooks [EOL] [EOL] logger . debug ( [string] ) [EOL] app . register_blueprint ( bp_generic ) [EOL] app . register_blueprint ( bp_features ) [EOL] app . register_blueprint ( bp_usersuite ) [EOL] app . register_blueprint ( bp_pages ) [EOL] app . register_blueprint ( bp_documents ) [EOL] app . register_blueprint ( bp_news ) [EOL] app . register_blueprint ( bp_hooks ) [EOL] [EOL] logger . debug ( [string] ) [EOL] form_label_width = [number] [EOL] form_input_width = [number] [EOL] app . jinja_env . globals . update ( cf_pages = cf_pages , get_locale = get_locale , get_weekday = get_weekday , possible_locales = possible_locales , get_attribute_endpoint = get_attribute_endpoint , should_display_traffic_data = should_display_traffic_data , traffic_chart = provide_render_function ( generate_traffic_chart ) , current_datasource = backends . current_datasource , form_label_width_class = [string] . format ( form_label_width ) , form_input_width_class = [string] . format ( form_input_width ) , form_input_offset_class = [string] . format ( form_label_width ) , url_self = url_self , now = datetime . utcnow ( ) ) [EOL] logger . debug ( [string] , extra = { [string] : { [string] : app . jinja_env . globals } } ) [EOL] [EOL] backends . init_backends ( ) [EOL] [EOL] [EOL] def load_config_file ( app , config = None ) : [EOL] [docstring] [EOL] [comment] [EOL] app . config . from_pyfile ( os . path . realpath ( [string] ) ) [EOL] [EOL] if config : [EOL] app . config . update ( config ) [EOL] [EOL] [comment] [EOL] if [string] in os . environ : [EOL] try : [EOL] app . config . from_envvar ( [string] ) [EOL] except IOError : [EOL] logger . warning ( [string] , os . environ [ [string] ] ) [EOL] else : [EOL] logger . info ( [string] , os . environ [ [string] ] ) [EOL] else : [EOL] logger . info ( [string] ) [EOL] [EOL] [EOL] def init_env_and_config ( app ) : [EOL] if not app . config [ [string] ] : [EOL] app . config [ [string] ] = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] ) [EOL] if app . config [ [string] ] : [EOL] init_repo ( app . config [ [string] ] , app . config [ [string] ] ) [EOL] else : [EOL] if not os . path . isdir ( app . config [ [string] ] ) : [EOL] try : [EOL] os . mkdir ( app . config [ [string] ] ) [EOL] except PermissionError as e : [EOL] raise RuntimeError ( [string] [string] [string] [string] [string] ) from e [EOL] [EOL] if app . config [ [string] ] : [EOL] try_register_uwsgi_timer ( app = app ) [EOL] [EOL] app . config [ [string] ] = False [EOL] [EOL] if not app . config . get ( [string] ) : [EOL] if not app . debug : [EOL] logger . warning ( [string] ) [EOL] app . config [ [string] ] = [string] [EOL] [EOL] [EOL] def try_register_uwsgi_timer ( app ) : [EOL] [docstring] [EOL] try : [EOL] import uwsgi [EOL] from uwsgidecorators import timer [EOL] except ImportError : [EOL] logger . info ( [string] ) [EOL] else : [EOL] @ timer ( [number] ) def update_uwsgi ( signum ) : [EOL] flatpages_root = app . config [ [string] ] [EOL] logger . debug ( [string] , flatpages_root ) [EOL] hasToReload = update_repo ( flatpages_root ) [EOL] if hasToReload : [EOL] logger . debug ( [string] , extra = { [string] : { [string] : uwsgi . numproc , [string] : uwsgi . opt , [string] : uwsgi . applications , } } ) [EOL] uwsgi . reload ( ) [EOL] [EOL] logger . debug ( [string] ) [EOL] [EOL] [EOL] def init_logging ( app ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if app . config [ [string] ] : [EOL] logger . debug ( [string] , app . config [ [string] ] ) [EOL] sentry = Sentry ( ) [EOL] sentry . init_app ( app , dsn = app . config [ [string] ] ) [EOL] [EOL] def register_sentry_handler ( ) : [EOL] handler = SentryHandler ( ) [EOL] [EOL] handler . client = app . extensions [ [string] ] . client [EOL] setup_logging ( handler ) [EOL] [EOL] return handler [EOL] else : [EOL] logger . debug ( [string] ) [EOL] [EOL] def register_sentry_handler ( ) : [EOL] return logging . NullHandler ( ) [EOL] [EOL] [comment] [EOL] config = replace_empty_handler_callables ( DEFAULT_CONFIG , register_sentry_handler ) [EOL] logging . config . dictConfig ( config ) [EOL] [EOL] if app . config . get ( [string] ) is not None : [EOL] config = replace_empty_handler_callables ( app . config [ [string] ] , register_sentry_handler ) [EOL] logging . config . dictConfig ( config ) [EOL] [EOL] logger . debug ( [string] , extra = { [string] : { [string] : DEFAULT_CONFIG , [string] : app . config . get ( [string] ) } } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , Dict , Any , List [EOL] import logging [EOL] import flask_flatpages [EOL] import babel [EOL] import sipa [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] from operator import attrgetter [EOL] from os . path import basename , dirname , splitext [EOL] from typing import Optional , Dict , Any [EOL] [EOL] from babel . core import Locale , UnknownLocaleError , negotiate_locale [EOL] from flask import abort , request [EOL] from flask_flatpages import FlatPages , Page [EOL] from yaml . scanner import ScannerError [EOL] [EOL] from sipa . babel import get_user_locale_setting , possible_locales [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Node : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , extension , parent , node_id ) : [EOL] [comment] [EOL] self . extension = extension [EOL] [comment] [EOL] self . parent = parent [EOL] [comment] [EOL] self . id = node_id [EOL] [EOL] [EOL] class Article ( Node ) : [EOL] [docstring] [EOL] def __init__ ( self , extension , parent , article_id ) : [EOL] super ( ) . __init__ ( extension , parent , article_id ) [EOL] [comment] [EOL] self . localized_pages = { } [EOL] [comment] [EOL] self . default_page = None [EOL] [EOL] def add_page ( self , page , locale ) : [EOL] [docstring] [EOL] if not ( self . id == [string] or self . validate_page_meta ( page ) ) : [EOL] return [EOL] [EOL] self . localized_pages [ str ( locale ) ] = page [EOL] default_locale = self . extension . app . babel_instance . default_locale [EOL] if self . default_page is None or locale == default_locale : [EOL] self . default_page = page [EOL] [EOL] @ staticmethod def validate_page_meta ( page ) : [EOL] [docstring] [EOL] try : [EOL] return [string] in page . meta [EOL] except ScannerError : [EOL] return False [EOL] [EOL] @ property def rank ( self ) : [EOL] [docstring] [EOL] return self . localized_page . meta . get ( [string] , [number] ) [EOL] [EOL] @ property def html ( self ) : [EOL] [docstring] [EOL] return self . localized_page . html [EOL] [EOL] @ property def link ( self ) : [EOL] [docstring] [EOL] raw_link = self . localized_page . meta . get ( [string] , None ) [EOL] if raw_link and raw_link [ [number] ] == [string] : [EOL] return dirname ( request . url_root ) + raw_link [EOL] [EOL] return None [EOL] [EOL] @ property def hidden ( self ) : [EOL] [docstring] [EOL] return self . localized_page . meta . get ( [string] , False ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] [docstring] [EOL] try : [EOL] return self . localized_page . meta [ attr ] [EOL] except KeyError as e : [EOL] raise AttributeError ( [string] . format ( type ( self ) . __name__ , attr ) ) from e [EOL] [EOL] @ property def localized_page ( self ) : [EOL] [docstring] [EOL] available_locales = list ( self . localized_pages . keys ( ) ) [EOL] [EOL] user_locale = str ( get_user_locale_setting ( ) ) [EOL] if user_locale is None : [EOL] preferred_locales = [ ] [EOL] else : [EOL] preferred_locales = [ user_locale ] [EOL] preferred_locales . extend ( request . accept_languages . values ( ) ) [EOL] [EOL] negotiated_locale = negotiate_locale ( preferred_locales , available_locales , sep = [string] ) [EOL] if negotiated_locale is not None : [EOL] return self . localized_pages [ negotiated_locale ] [EOL] return self . default_page [EOL] [EOL] @ property def file_basename ( self ) : [EOL] [docstring] [EOL] return splitext ( basename ( self . localized_page . path ) ) [ [number] ] [EOL] [EOL] [EOL] class Category ( Node ) : [EOL] [docstring] [EOL] def __init__ ( self , extension , parent , category_id ) : [EOL] super ( ) . __init__ ( extension , parent , category_id ) [EOL] self . categories = { } [EOL] self . _articles = { } [EOL] [EOL] @ property def articles ( self ) : [EOL] [docstring] [EOL] return iter ( sorted ( self . _articles . values ( ) , key = attrgetter ( [string] ) ) ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] [docstring] [EOL] try : [EOL] index = self . _articles [ [string] ] [EOL] except KeyError as e : [EOL] raise AttributeError ( [string] . format ( type ( self ) . __name__ , attr ) ) from e [EOL] return getattr ( index , attr ) [EOL] [EOL] def add_child_category ( self , id ) : [EOL] [docstring] [EOL] category = self . categories . get ( id ) [EOL] if category is not None : [EOL] return category [EOL] [EOL] category = Category ( self . extension , self , id ) [EOL] self . categories [ id ] = category [EOL] return category [EOL] [EOL] def _parse_page_basename ( self , basename ) : [EOL] [docstring] [EOL] default_locale = self . extension . app . babel_instance . default_locale [EOL] article_id , sep , locale_identifier = basename . rpartition ( [string] ) [EOL] [EOL] if sep == [string] : [EOL] return basename , default_locale [EOL] [EOL] try : [EOL] locale = Locale ( locale_identifier ) [EOL] except UnknownLocaleError : [EOL] logger . error ( [string] , locale_identifier , basename ) [EOL] return basename , default_locale [EOL] if locale not in possible_locales ( ) : [EOL] logger . warning ( [string] , locale_identifier , basename ) [EOL] return basename , default_locale [EOL] return article_id , locale [EOL] [EOL] def add_article ( self , prefix , page ) : [EOL] [docstring] [EOL] article_id , locale = self . _parse_page_basename ( prefix ) [EOL] [EOL] article = self . _articles . get ( article_id ) [EOL] if article is None : [EOL] article = Article ( self . extension , self , article_id ) [EOL] self . _articles [ article_id ] = article [EOL] [EOL] article . add_page ( page , locale ) [EOL] [EOL] [EOL] class CategorizedFlatPages : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] self . flat_pages = FlatPages ( ) [EOL] self . root_category = Category ( self , None , [string] ) [EOL] self . app = None [EOL] [EOL] def init_app ( self , app ) : [EOL] assert self . app is None , [string] [EOL] self . app = app [EOL] app . cf_pages = self [EOL] self . flat_pages . init_app ( app ) [EOL] self . _init_categories ( ) [EOL] [EOL] @ property def categories ( self ) : [EOL] [docstring] [EOL] return sorted ( self . root_category . categories . values ( ) , key = attrgetter ( [string] ) ) [EOL] [EOL] def get ( self , category_id , article_id ) : [EOL] category = self . root_category . categories . get ( category_id ) [EOL] if category is None : [EOL] return None [EOL] return category . _articles . get ( article_id ) [EOL] [EOL] def get_category ( self , category_id ) : [EOL] [docstring] [EOL] return self . root_category . categories . get ( category_id ) [EOL] [EOL] def get_articles_of_category ( self , category_id ) : [EOL] [docstring] [EOL] category = self . get_category ( category_id ) [EOL] if category is None : [EOL] return [ ] [EOL] return [ article for article in category . _articles . values ( ) if article . id != [string] ] [EOL] [EOL] def get_or_404 ( self , category_id , article_id ) : [EOL] [docstring] [EOL] page = self . get ( category_id , article_id ) [EOL] if page is None : [EOL] abort ( [number] ) [EOL] return page [EOL] [EOL] def _init_categories ( self ) : [EOL] [comment] [EOL] for page in self . flat_pages : [EOL] [comment] [EOL] [comment] [EOL] components = page . path . split ( [string] ) [EOL] parent = self . root_category [EOL] for category_id in components [ : - [number] ] : [EOL] parent = parent . add_child_category ( category_id ) [EOL] prefix = components [ - [number] ] [EOL] parent . add_article ( prefix , page ) [EOL] [EOL] def reload ( self ) : [EOL] self . flat_pages . reload ( ) [EOL] self . _init_categories ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,flask_flatpages.Page]$ 0 0 0 0 0 0 0 0 $flask_flatpages.Page$ 0 0 0 0 0 0 0 0 0 $flask_flatpages.Page$ 0 $babel.core.Locale$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask_flatpages.Page$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $babel.core.Locale$ 0 0 0 $flask_flatpages.Page$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $babel.core.Locale$ 0 0 0 0 0 0 0 0 $flask_flatpages.Page$ 0 0 0 0 0 $builtins.bool$ 0 $flask_flatpages.Page$ 0 0 0 0 0 0 0 0 0 0 0 $flask_flatpages.Page$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $flask_flatpages.Page$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.flatpages.Category$ 0 0 0 0 0 0 0 0 0 0 0 $sipa.flatpages.Category$ 0 0 0 0 0 0 $sipa.flatpages.Category$ 0 0 $sipa.flatpages.Category$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.flatpages.Category$ 0 0 $sipa.flatpages.Category$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.flatpages.Article$ 0 0 0 0 0 0 0 0 0 0 0 $sipa.flatpages.Article$ 0 0 0 0 $sipa.flatpages.Article$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.flatpages.Article$ 0 0 $sipa.flatpages.Article$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.flatpages.Category$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , Any , List [EOL] import logging [EOL] import babel [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] from typing import List , Optional [EOL] [EOL] from babel import Locale , UnknownLocaleError , negotiate_locale [EOL] from flask import request , session [EOL] from werkzeug . exceptions import BadRequest [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def possible_locales ( ) : [EOL] [docstring] [EOL] return [ Locale ( [string] ) , Locale ( [string] ) ] [EOL] [EOL] [EOL] def get_user_locale_setting ( ) : [EOL] [docstring] [EOL] locale_identifier = session . get ( [string] ) [EOL] if locale_identifier is None : [EOL] return None [EOL] [EOL] try : [EOL] locale = Locale . parse ( locale_identifier ) [EOL] except ( UnknownLocaleError , ValueError ) : [EOL] logger . warning ( [string] . format ( locale_identifier ) ) [EOL] session . pop ( [string] ) [EOL] return None [EOL] [EOL] if locale not in possible_locales ( ) : [EOL] logger . warning ( [string] . format ( locale ) ) [EOL] session . pop ( [string] , None ) [EOL] return None [EOL] [EOL] return locale [EOL] [EOL] [EOL] def save_user_locale_setting ( ) : [EOL] [docstring] [EOL] locale_identifier = request . args . get ( [string] ) [EOL] if locale_identifier is None : [EOL] return [EOL] try : [EOL] locale = Locale . parse ( locale_identifier , sep = [string] ) [EOL] except ( UnknownLocaleError , ValueError ) : [EOL] raise BadRequest ( [string] . format ( locale_identifier ) ) [EOL] if locale not in possible_locales ( ) : [EOL] raise BadRequest ( [string] . format ( locale_identifier ) ) [EOL] session [ [string] ] = str ( locale ) [EOL] [EOL] [EOL] def select_locale ( ) : [EOL] [docstring] [EOL] locale = get_user_locale_setting ( ) [EOL] if locale is not None : [EOL] return str ( locale ) [EOL] return negotiate_locale ( request . accept_languages . values ( ) , list ( map ( str , possible_locales ( ) ) ) , sep = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[babel.Locale]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[babel.Locale]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import Optional , Union , Dict , List [EOL] import typing [EOL] DEFAULT_CONFIG = { [string] : [number] , [string] : False , [string] : { [string] : { [string] : ( [string] [string] ) } , [string] : { [string] : ( [string] [string] ) } , [string] : { [string] : [string] } , } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : None , [string] : [string] , [string] : [string] , } , } , [string] : { [string] : { [string] : [string] , [string] : [ [string] ] , } , [string] : { [string] : [string] , [string] : [ [string] , [string] ] , [string] : True , } , } } [EOL] [EOL] WARNINGS_ONLY_CONFIG = { [string] : [number] , [string] : True , [string] : { [string] : { [string] : [string] , } , [string] : { [string] : [string] , } , } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] from flask import Flask [EOL] [EOL] from sipa . initialization import init_app [EOL] [EOL] [EOL] def create_app ( app = None , prepare_callable = None , ** kwargs ) : [EOL] app = app if app else Flask ( __name__ ) [EOL] if prepare_callable : [EOL] prepare_callable ( app = app ) [EOL] init_app ( app , ** kwargs ) [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , Type [EOL] import typing [EOL] import sipa [EOL] from collections import namedtuple [EOL] from functools import wraps [EOL] [EOL] from flask_babel import gettext [EOL] from abc import ABCMeta , abstractmethod [EOL] from sipa . utils import argstr [EOL] [EOL] [EOL] Capabilities = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] NO_CAPABILITIES = Capabilities ( edit = False , delete = False ) [EOL] [EOL] [EOL] class PropertyBase ( metaclass = ABCMeta ) : [EOL] def __init__ ( self , name , value , raw_value , capabilities = NO_CAPABILITIES , style = None , empty = False ) : [EOL] self . name = name [EOL] self . value = value [EOL] self . raw_value = raw_value [EOL] self . capabilities = capabilities [EOL] self . style = style [EOL] self . empty = empty or not value [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( __name__ , type ( self ) . __name__ , argstr ( name = self . name , value = self . value , raw_value = self . raw_value , capabilities = self . capabilities , style = self . style , empty = self . empty , ) ) [EOL] [EOL] @ property @ abstractmethod def supported ( self ) : [EOL] pass [EOL] [EOL] def __eq__ ( self , other ) : [EOL] [docstring] [EOL] try : [EOL] return all ( ( self . name == other . name , self . value == other . value , self . capabilities == other . capabilities , self . style == other . style , self . empty == other . empty , ) ) [EOL] except AttributeError : [EOL] return self . raw_value == other [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return self . raw_value . __contains__ ( item ) [EOL] [EOL] def __bool__ ( self ) : [EOL] [docstring] [EOL] return not self . empty [EOL] [EOL] [EOL] class UnsupportedProperty ( PropertyBase ) : [EOL] supported = False [EOL] [EOL] def __init__ ( self , name ) : [EOL] super ( ) . __init__ ( name = name , value = gettext ( [string] ) , raw_value = None , style = [string] , empty = True , ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( __name__ , type ( self ) . __name__ , argstr ( name = self . name ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] try : [EOL] return self . name == other . name [EOL] except AttributeError : [EOL] return False [EOL] [EOL] [EOL] class ActiveProperty ( PropertyBase ) : [EOL] supported = True [EOL] [EOL] def __init__ ( self , name , value = None , raw_value = None , capabilities = NO_CAPABILITIES , style = None , empty = False ) : [EOL] [EOL] [comment] [EOL] assert style in { None , [string] , [string] , [string] , [string] , [string] , [string] , [string] } , [string] [EOL] [EOL] super ( ) . __init__ ( name = name , value = ( value if value else gettext ( [string] ) ) , raw_value = raw_value if raw_value is not None else value , capabilities = capabilities , style = ( style if style [comment] [EOL] else [string] if empty or not value [EOL] else None ) , empty = empty or not value , ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( cls = type ( self ) . __name__ , name = self . name , value = self . value , empty = ( [string] if self . empty else [string] ) , ) [EOL] [EOL] [EOL] def unsupported_prop ( func ) : [EOL] return property ( lambda self : UnsupportedProperty ( name = func . __name__ ) ) [EOL] [EOL] [EOL] class active_prop ( property ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , fget , fset = None , fdel = None , doc = None , fake_setter = False ) : [EOL] [docstring] [EOL] self . __raw_getter = fget [EOL] self . __fake_setter = fake_setter [comment] [EOL] [EOL] @ wraps ( fget ) def wrapped_getter ( * args , ** kwargs ) : [EOL] result = fget ( * args , ** kwargs ) [EOL] try : [EOL] value = result [ [string] ] [EOL] except TypeError : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] name = fget . __name__ [EOL] value = result [EOL] raw_value = value [EOL] style = None [EOL] empty = None [EOL] tmp_readonly = False [EOL] else : [EOL] name = result . get ( [string] , fget . __name__ ) [EOL] raw_value = result . get ( [string] , value ) [EOL] style = result . get ( [string] , None ) [EOL] empty = result . get ( [string] , None ) [EOL] tmp_readonly = result . get ( [string] , False ) [EOL] [EOL] return ActiveProperty ( name = name , value = value , raw_value = raw_value , capabilities = Capabilities ( edit = ( fset is not None or fake_setter ) , delete = ( fdel is not None ) , ) if not tmp_readonly else NO_CAPABILITIES , style = style , empty = empty , ) [EOL] [EOL] [comment] [EOL] super ( ) . __init__ ( wrapped_getter , fset , fdel , doc ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( __name__ , type ( self ) . __name__ , argstr ( fget = self . __raw_getter , fset = self . fset , fdel = self . fdel , doc = self . __doc__ , fake_setter = self . __fake_setter , ) ) [EOL] [EOL] def getter ( self , func ) : [EOL] return type ( self ) ( func , self . fset , self . fdel , self . __doc__ ) [EOL] [EOL] def setter ( self , func ) : [EOL] return type ( self ) ( self . __raw_getter , func , self . fdel , self . __doc__ ) [EOL] [EOL] def deleter ( self , func ) : [EOL] return type ( self ) ( self . __raw_getter , self . fset , func , self . __doc__ ) [EOL] [EOL] def fake_setter ( self ) : [EOL] return type ( self ) ( self . __raw_getter , self . fset , self . fdel , self . __doc__ , fake_setter = True ) [EOL] [EOL] [EOL] def connection_dependent ( func ) : [EOL] [docstring] [EOL] [EOL] def _connection_dependent ( self , * args , ** kwargs ) : [EOL] if not self . has_connection : [EOL] return { [string] : func . __name__ , [string] : gettext ( [string] ) , [string] : True , [string] : True , } [EOL] [EOL] ret = func ( self , * args , ** kwargs ) [EOL] try : [EOL] ret . update ( { [string] : func . __name__ } ) [EOL] except AttributeError : [EOL] ret = { [string] : ret , [string] : func . __name__ } [EOL] [EOL] return ret [EOL] [EOL] return _connection_dependent [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.model.fancy_property.Capabilities]$ 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.model.fancy_property.Capabilities$ 0 $typing.Type[sipa.model.fancy_property.Capabilities]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.model.fancy_property.Capabilities$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.model.fancy_property.Capabilities$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Type[sipa.model.fancy_property.Capabilities]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $sipa.model.fancy_property.Capabilities$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from abc import ABCMeta , abstractmethod [EOL] [EOL] from flask_babel import gettext [EOL] [EOL] from sipa . model . fancy_property import ActiveProperty , Capabilities [EOL] from sipa . units import format_money [EOL] from sipa . utils import compare_all_attributes [EOL] [EOL] [EOL] class BaseFinanceInformation ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ property def balance ( self ) : [EOL] [docstring] [EOL] if not self . has_to_pay : [EOL] return ActiveProperty ( [string] , value = gettext ( [string] ) , raw_value = [number] , empty = True ) [EOL] return ActiveProperty ( [string] , value = format_money ( self . raw_balance ) , raw_value = self . raw_balance ) [EOL] [EOL] @ property @ abstractmethod def raw_balance ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property @ abstractmethod def has_to_pay ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property @ abstractmethod def history ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property @ abstractmethod def last_update ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return compare_all_attributes ( self , other , [ [string] , [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class InvalidCredentials ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class UserNotFound ( InvalidCredentials ) : [EOL] pass [EOL] [EOL] [EOL] class PasswordInvalid ( InvalidCredentials ) : [EOL] pass [EOL] [EOL] [EOL] class MacAlreadyExists ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class NetworkAccessAlreadyActive ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class TerminationNotPossible ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class ContinuationNotPossible ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class DBQueryEmpty ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class UnknownError ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import logging [EOL] import typing [EOL] import sipa [EOL] import logging [EOL] [EOL] from sipa . backends import Backends [EOL] from . import sample , pycroft [EOL] from . sqlalchemy import db [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] AVAILABLE_DATASOURCES = [ sample . datasource , pycroft . datasource ] [EOL] [EOL] [EOL] def prepare_sqlalchemy ( app ) : [EOL] app . config [ [string] ] = { } [EOL] db . init_app ( app ) [EOL] [EOL] [EOL] def build_backends_ext ( ) : [EOL] backends = Backends ( ) [EOL] for d in AVAILABLE_DATASOURCES : [EOL] backends . register ( d ) [EOL] [EOL] [comment] [EOL] backends . pre_init_hook ( prepare_sqlalchemy ) [EOL] return backends [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sipa.backends.datasource.DataSource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.Backends$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sipa.backends.datasource.DataSource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] from flask_sqlalchemy import SQLAlchemy [EOL] [EOL] db = SQLAlchemy ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import sipa [EOL] from collections import namedtuple [EOL] [EOL] from flask import request [EOL] from flask_login import current_user [EOL] [EOL] from sipa . backends import backends [EOL] [EOL] TransactionTuple = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] [EOL] PaymentDetails = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] def has_connection ( user ) : [EOL] return user . is_authenticated and user . has_connection [EOL] [EOL] [EOL] def should_display_traffic_data ( ) : [EOL] return has_connection ( current_user ) or has_connection ( backends . user_from_ip ( request . remote_addr ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.model.misc.TransactionTuple]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[sipa.model.misc.PaymentDetails]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import sipa [EOL] from ipaddress import IPv4Network [EOL] [EOL] from sipa . backends import DataSource , Dormitory [EOL] from . import user [EOL] [EOL] [comment] [EOL] datasource = DataSource ( name = [string] , user_class = user . User , mail_server = [string] , init_context = user . init_context , ) [EOL] [EOL] Dormitory ( name = [string] , display_name = [string] , datasource = datasource , subnets = [ IPv4Network ( [string] ) , IPv4Network ( [string] ) , ] ) [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import logging [EOL] from ipaddress import IPv4Address , AddressValueError [EOL] [EOL] from flask import current_app [EOL] from sqlalchemy import create_engine [EOL] from sqlalchemy . exc import OperationalError [EOL] [EOL] from sipa . model . user import BaseUserDB [EOL] from sipa . backends . exceptions import InvalidConfiguration [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class UserDB ( BaseUserDB ) : [EOL] def __init__ ( self , user ) : [EOL] super ( ) . __init__ ( user ) [EOL] [EOL] mask = current_app . config . get ( [string] ) [EOL] self . test_ipmask_validity ( mask ) [EOL] self . ip_mask = mask [EOL] [EOL] @ staticmethod def test_ipmask_validity ( mask ) : [EOL] [docstring] [EOL] try : [EOL] IPv4Address ( mask . replace ( [string] , [string] ) ) [EOL] except AddressValueError : [EOL] raise ValueError ( [string] [string] . format ( mask ) ) [EOL] [EOL] @ staticmethod def sql_query ( query , args = ( ) ) : [EOL] [docstring] [EOL] database = current_app . extensions [ [string] ] [EOL] conn = database . connect ( ) [EOL] result = conn . execute ( query , args ) [EOL] conn . close ( ) [EOL] return result [EOL] [EOL] @ property def has_db ( self ) : [EOL] try : [EOL] userdb = self . sql_query ( [string] [string] [string] , ( self . db_name ( ) , ) , ) . fetchone ( ) [EOL] [EOL] return userdb is not None [EOL] except OperationalError : [EOL] logger . critical ( [string] , self . db_name ( ) ) [EOL] return None [EOL] [EOL] def create ( self , password ) : [EOL] self . sql_query ( [string] [string] % self . db_name ( ) , ) [EOL] self . change_password ( password ) [EOL] [EOL] def drop ( self ) : [EOL] self . sql_query ( [string] [string] % self . db_name ( ) , ) [EOL] [EOL] self . sql_query ( [string] , ( self . db_name ( ) , self . ip_mask ) , ) [EOL] [EOL] def change_password ( self , password ) : [EOL] user = self . sql_query ( [string] [string] [string] , ( self . db_name ( ) , ) , ) . fetchall ( ) [EOL] [EOL] if not user : [EOL] self . sql_query ( [string] [string] , ( self . db_name ( ) , self . ip_mask , password , ) , ) [EOL] else : [EOL] self . sql_query ( [string] [string] , ( self . db_name ( ) , self . ip_mask , password , ) , ) [EOL] [EOL] self . sql_query ( [string] [string] [string] [string] . format ( self . db_name ( ) ) , ( self . db_name ( ) , self . ip_mask ) , ) [EOL] [EOL] def db_name ( self ) : [EOL] return self . user . login . value [EOL] [EOL] [EOL] def register_userdb_extension ( app ) : [EOL] try : [EOL] app . extensions [ [string] ] = create_engine ( app . config [ [string] ] , echo = False , connect_args = { [string] : app . config [ [string] ] } ) [EOL] except KeyError as exception : [EOL] raise InvalidConfiguration ( * exception . args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import sipa [EOL] from ipaddress import IPv4Network [EOL] [EOL] from sipa . backends import DataSource , Dormitory [EOL] from sipa . backends . exceptions import InvalidConfiguration [EOL] from . import user , api , userdb [EOL] [EOL] [EOL] def init_pycroft_api ( app ) : [EOL] try : [EOL] app . extensions [ [string] ] = api . PycroftApi ( endpoint = app . config [ [string] ] , api_key = app . config [ [string] ] , ) [EOL] except KeyError as exception : [EOL] raise InvalidConfiguration ( * exception . args ) [EOL] [EOL] [EOL] def init_userdb ( app ) : [EOL] userdb . register_userdb_extension ( app ) [EOL] [EOL] [EOL] def init_context ( app ) : [EOL] init_pycroft_api ( app ) [EOL] init_userdb ( app ) [EOL] [EOL] [EOL] datasource = DataSource ( name = [string] , user_class = user . User , mail_server = [string] , support_mail = [string] , webmailer_url = [string] , init_context = init_context ) [EOL] [EOL] [ Dormitory ( name = dorm [ [number] ] , display_name = dorm [ [number] ] , datasource = datasource , subnets = dorm [ [number] ] ) for dorm in [ ( [string] , [string] , [ IPv4Network ( [string] ) , IPv4Network ( [string] ) , IPv4Network ( [string] ) , IPv4Network ( [string] ) , IPv4Network ( [string] ) , IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , ] ) , ( [string] , [string] , [ IPv4Network ( [string] ) , IPv4Network ( [string] ) , IPv4Network ( [string] ) , IPv4Network ( [string] ) , IPv4Network ( [string] ) , IPv4Network ( [string] ) , ] ) ] ] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Callable , Any , Tuple [EOL] import logging [EOL] import requests [EOL] import typing [EOL] import builtins [EOL] import functools [EOL] import logging [EOL] [EOL] from functools import partial [EOL] from typing import Callable , Tuple , Any [EOL] [EOL] import requests [EOL] from requests import ConnectionError , HTTPError [EOL] [EOL] from sipa . backends . exceptions import InvalidConfiguration [EOL] from . exc import PycroftBackendError [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PycroftApi ( ) : [EOL] def __init__ ( self , endpoint , api_key ) : [EOL] if not endpoint . endswith ( [string] ) : [EOL] raise InvalidConfiguration ( [string] ) [EOL] self . _endpoint = endpoint [EOL] self . _api_key = api_key [EOL] [EOL] def get_user ( self , username ) : [EOL] return self . get ( [string] . format ( username ) ) [EOL] [EOL] def get_user_from_ip ( self , ip ) : [EOL] return self . get ( [string] , params = { [string] : ip } , no_raise = True ) [EOL] [EOL] def authenticate ( self , username , password ) : [EOL] return self . post ( [string] , data = { [string] : username , [string] : password } ) [EOL] [EOL] def change_password ( self , user_id , old_password , new_password ) : [EOL] return self . post ( [string] . format ( user_id ) , data = { [string] : old_password , [string] : new_password } ) [EOL] [EOL] def change_mail ( self , user_id , password , new_mail ) : [EOL] return self . post ( [string] . format ( user_id ) , data = { [string] : password , [string] : new_mail } ) [EOL] [EOL] def change_mac ( self , user_id , password , interface_id , new_mac , host_name ) : [EOL] return self . post ( [string] . format ( user_id , interface_id ) , data = { [string] : password , [string] : new_mac , [string] : host_name } ) [EOL] [EOL] def activate_network_access ( self , user_id , password , mac , birthdate , host_name ) : [EOL] return self . post ( [string] . format ( user_id ) , data = { [string] : password , [string] : mac , [string] : birthdate , [string] : host_name } ) [EOL] [EOL] def estimate_balance_at_end_of_membership ( self , user_id , end_date ) : [EOL] return self . get ( [string] . format ( user_id ) , params = { [string] : end_date } ) [EOL] [EOL] def terminate_membership ( self , user_id , end_date ) : [EOL] return self . post ( [string] . format ( user_id ) , data = { [string] : end_date , [string] : [string] } ) [EOL] [EOL] def continue_membership ( self , user_id ) : [EOL] return self . delete ( [string] . format ( user_id ) ) [EOL] [EOL] def reset_wifi_password ( self , user_id ) : [EOL] return self . patch ( [string] . format ( user_id ) ) [EOL] [EOL] def get ( self , url , params = None , no_raise = False ) : [EOL] request_function = partial ( requests . get , params = params or { } ) [EOL] return self . _do_api_call ( request_function , url ) [EOL] [EOL] def post ( self , url , data = None , no_raise = False ) : [EOL] request_function = partial ( requests . post , data = data or { } ) [EOL] return self . _do_api_call ( request_function , url ) [EOL] [EOL] def delete ( self , url , data = None , no_raise = False ) : [EOL] request_function = partial ( requests . delete , data = data or { } ) [EOL] return self . _do_api_call ( request_function , url ) [EOL] [EOL] def patch ( self , url , data = None , no_raise = False ) : [EOL] request_function = partial ( requests . patch , data = data or { } ) [EOL] return self . _do_api_call ( request_function , url ) [EOL] [EOL] def _do_api_call ( self , request_function , url , no_raise = False ) : [EOL] try : [EOL] response = request_function ( self . _endpoint + url , headers = { [string] : [string] . format ( self . _api_key ) } , ) [EOL] except ConnectionError as e : [EOL] if no_raise : [EOL] return [number] , None [EOL] [EOL] logger . error ( [string] , extra = { [string] : { [string] : self . _endpoint + url } } ) [EOL] raise PycroftBackendError ( [string] ) from e [EOL] [EOL] if response . status_code not in [ [number] , [number] , [number] , [number] , [number] , [number] ] and not no_raise : [EOL] try : [EOL] response . raise_for_status ( ) [EOL] except HTTPError as e : [EOL] raise PycroftBackendError ( f" [string] " f" [string] { response . status_code }" ) from e [EOL] [EOL] return response . status_code , response . json ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,builtins.dict]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[requests.models.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[requests.models.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[requests.models.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[requests.models.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[requests.models.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[requests.models.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[requests.models.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[requests.models.Response]$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.Any]$ 0 0 0 $typing.Callable$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Callable$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] from __future__ import annotations [EOL] [EOL] from datetime import date [EOL] from decimal import Decimal [EOL] from typing import List , Optional [EOL] [EOL] from sipa . model . pycroft . unserialize import unserializer [EOL] [EOL] [EOL] @ unserializer class UserData : [EOL] id = ... [EOL] user_id = ... [EOL] login = ... [EOL] name = ... [EOL] status = ... [EOL] room = ... [EOL] mail = ... [EOL] properties = ... [EOL] traffic_history = ... [EOL] interfaces = ... [EOL] finance_balance = ... [EOL] finance_history = ... [EOL] [comment] [EOL] last_finance_update = ... [EOL] [EOL] [comment] [EOL] [EOL] membership_end_date = ... [EOL] wifi_password = ... [EOL] [EOL] [EOL] @ unserializer class UserStatus : [EOL] member = ... [EOL] traffic_exceeded = ... [EOL] network_access = ... [EOL] account_balanced = ... [EOL] violation = ... [EOL] [EOL] [EOL] @ unserializer class Interface : [EOL] id = ... [EOL] mac = ... [EOL] ips = ... [EOL] [EOL] [EOL] @ unserializer class TrafficHistoryEntry : [EOL] timestamp = ... [EOL] ingress = ... [EOL] egress = ... [EOL] [EOL] [EOL] @ unserializer class FinanceHistoryEntry : [EOL] valid_on = ... [EOL] amount = ... [EOL] description = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $UserStatus$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[TrafficHistoryEntry]$ 0 0 0 $typing.List[Interface]$ 0 0 0 $decimal.Decimal$ 0 0 0 $typing.List[FinanceHistoryEntry]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $decimal.Decimal$ 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Callable , Set , Any , Type , Optional , Dict [EOL] import builtins [EOL] import typing [EOL] import _importlib_modulespec [EOL] import inspect [EOL] import sys [EOL] from typing import Callable , Optional , Any , List , Union [EOL] [EOL] [EOL] class UnserializationError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class MissingKeysError ( KeyError , UnserializationError ) : [EOL] pass [EOL] [EOL] [EOL] class ConversionError ( TypeError , UnserializationError ) : [EOL] pass [EOL] [EOL] [EOL] def canonicalize_key ( key ) : [EOL] return key [ : - [number] ] if key . endswith ( [string] ) else key [EOL] [EOL] [EOL] def _maybe_setattr ( cls , attrname , attr ) : [EOL] if attrname in cls . __dict__ : [EOL] return [EOL] setattr ( cls , attrname , attr ) [EOL] [EOL] [EOL] NoneType = type ( None ) [EOL] [EOL] [EOL] def _is_optional ( t ) : [EOL] return getattr ( t , [string] , None ) is Union and len ( t . __args__ ) == [number] and t . __args__ [ [number] ] is NoneType [EOL] [EOL] [EOL] MAXDEPTH = [number] [EOL] [EOL] [EOL] def constructor_from_generic ( name , args , * a , ** kw ) : [EOL] [docstring] [EOL] if name == Any . _name : [EOL] def constructor ( val ) : [EOL] return val [EOL] [EOL] elif name == List . _name : [EOL] if len ( args ) == [number] : [EOL] item_constructor = constructor_from_annotation ( args [ [number] ] , * a , ** kw ) [EOL] [EOL] def constructor ( val ) : [EOL] return [ item_constructor ( i ) for i in val ] [EOL] else : [EOL] raise UnserializationError ( [string] [string] ) [EOL] elif name == Optional . _name : [EOL] if len ( args ) >= [number] : [EOL] item_constructor = constructor_from_annotation ( args [ [number] ] , * a , ** kw ) [EOL] [EOL] def constructor ( val ) : [EOL] return item_constructor ( val ) if val is not None else None [EOL] else : [EOL] raise UnserializationError ( [string] [string] ) [EOL] else : [EOL] raise UnserializationError ( f" [string] { name } [string] " ) [EOL] [EOL] return constructor [EOL] [EOL] [EOL] def constructor_from_annotation ( type_ , module , maxdepth = MAXDEPTH ) : [EOL] [docstring] [EOL] if maxdepth <= [number] : [EOL] raise UnserializationError ( [string] f" [string] { MAXDEPTH } [string] " ) [EOL] [EOL] [comment] [EOL] if isinstance ( type_ , str ) : [EOL] try : [EOL] type_ = eval ( type_ , module . __dict__ , None ) [EOL] except NameError : [EOL] raise UnserializationError ( f" [string] { type_ !r}" f" [string] { module . __name__ !r}" ) [EOL] [EOL] constructor = None [EOL] [EOL] [comment] [EOL] if hasattr ( type_ , [string] ) : [EOL] type_name = type_ . _name [EOL] if _is_optional ( type_ ) : [EOL] type_name = Optional . _name [EOL] constructor = constructor_from_generic ( type_name , getattr ( type_ , [string] , ( ) ) , module = module , maxdepth = maxdepth - [number] ) [EOL] [EOL] [comment] [EOL] elif inspect . isclass ( type_ ) : [EOL] constructor = type_ [EOL] [EOL] if not constructor : [EOL] raise UnserializationError ( f" [string] { type_ !r}" ) [EOL] [EOL] return constructor [EOL] [EOL] [EOL] def unserializer ( cls ) : [EOL] [docstring] [EOL] annotations = { canonicalize_key ( key ) : val for key , val in getattr ( cls , [string] , { } ) . items ( ) } [EOL] setattr ( cls , [string] , annotations ) [EOL] [EOL] [comment] [EOL] @ property def _json_keys ( self ) : [EOL] return self . __annotations__ . keys ( ) [comment] [EOL] [EOL] _maybe_setattr ( cls , [string] , _json_keys ) [EOL] [EOL] def __init__ ( self , dict_like = None ) : [EOL] if not dict_like : [EOL] dict_like = { } [EOL] [EOL] [comment] [EOL] module = sys . modules [ type ( self ) . __module__ ] [EOL] constructor_map = { key : constructor_from_annotation ( type_ = val , module = module ) for key , val in self . __annotations__ . items ( ) } [EOL] [EOL] missing_keys = set ( constructor_map . keys ( ) ) - set ( dict_like . keys ( ) ) [EOL] if missing_keys : [EOL] raise MissingKeysError ( f" [string] { len ( missing_keys ) } [string] " f" [string] { type ( self ) . __name__ } [string] " f" [string] { [string] . join ( missing_keys ) }" ) [EOL] [comment] [EOL] [EOL] for attrname , constructor in constructor_map . items ( ) : [EOL] val = dict_like [ attrname ] [EOL] if not constructor or val is None : [EOL] converted = val [EOL] else : [EOL] try : [EOL] converted = constructor ( val ) [EOL] except ( TypeError , ValueError ) as e : [EOL] typename = self . __annotations__ [ attrname ] [EOL] raise ConversionError ( f" [string] { val !r}" f" [string] { typename !r}" ) from e [EOL] [EOL] self . __dict__ [ attrname ] = converted [EOL] [EOL] _maybe_setattr ( cls , [string] , __init__ ) [EOL] [EOL] return cls [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from sipa . backends . exceptions import BackendError [EOL] [EOL] [EOL] class PycroftBackendError ( BackendError ) : [EOL] def __init__ ( self , * a , ** kw ) : [EOL] super ( ) . __init__ ( [string] , * a , ** kw ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] from datetime import datetime [EOL] from logging import getLogger [EOL] from subprocess import call [EOL] from typing import List [EOL] [EOL] import git [EOL] from flask_babel import format_datetime [EOL] from git . exc import ( GitCommandError , InvalidGitRepositoryError , NoSuchPathError , CacheError ) [EOL] [EOL] logger = getLogger ( __name__ ) [EOL] [EOL] [EOL] def init_repo ( repo_dir , repo_url ) : [EOL] [docstring] [EOL] try : [EOL] repo = git . Repo ( repo_dir ) [EOL] except ( NoSuchPathError , InvalidGitRepositoryError ) : [EOL] call ( [ [string] , [string] , repo_url , repo_dir , [string] ] ) [EOL] repo = git . Repo ( repo_dir ) [EOL] [EOL] if repo . remotes : [EOL] origin = repo . remote ( [string] ) [EOL] else : [EOL] origin = repo . create_remote ( [string] , repo_url ) [EOL] [EOL] try : [EOL] origin . fetch ( ) [EOL] except GitCommandError : [EOL] logger . error ( [string] , extra = { [string] : { [string] : repo_dir } } ) [EOL] return [EOL] [EOL] try : [EOL] master = repo . refs [ [string] ] [EOL] except IndexError : [EOL] raise OSError ( [string] . format ( repo_dir ) ) [EOL] [EOL] repo . head . set_reference ( master ) [EOL] [EOL] repo . git . reset ( [string] , [string] ) [EOL] logger . info ( [string] , repo_url , repo_dir ) [EOL] [EOL] [EOL] def update_repo ( repo_dir ) : [EOL] repo = git . Repo . init ( repo_dir ) [EOL] [EOL] try : [EOL] if repo . commit ( ) . hexsha != repo . remote ( ) . fetch ( ) [ [number] ] . commit . hexsha : [EOL] origin = repo . remote ( ) [EOL] origin . fetch ( ) [EOL] repo . git . reset ( [string] , [string] ) [EOL] return True [EOL] else : [EOL] return False [EOL] except GitCommandError : [EOL] logger . error ( [string] , extra = { [string] : { [string] : repo_dir } } ) [EOL] else : [EOL] logger . info ( [string] , extra = { [string] : { [string] : repo_dir } } ) [EOL] [EOL] [EOL] def get_repo_active_branch ( repo_dir ) : [EOL] [docstring] [EOL] try : [EOL] sipa_repo = git . Repo ( repo_dir ) [EOL] return sipa_repo . active_branch . name [EOL] except GitCommandError : [EOL] return [string] [EOL] except TypeError : [comment] [EOL] return [string] . format ( sipa_repo . head . commit . hexsha [ : [number] ] ) [EOL] [EOL] [EOL] def get_latest_commits ( repo_dir , commit_count ) : [EOL] [docstring] [EOL] try : [EOL] sipa_repo = git . Repo ( repo_dir ) [EOL] commits = sipa_repo . iter_commits ( max_count = commit_count ) [EOL] return [ { [string] : commit . hexsha , [string] : commit . summary , [string] : commit . author , [string] : format_datetime ( datetime . fromtimestamp ( commit . committed_date ) ) , } for commit in commits ] [EOL] except ( InvalidGitRepositoryError , CacheError , GitCommandError ) : [EOL] logger . exception ( [string] , extra = { [string] : { [string] : repo_dir } } ) [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import re [EOL] [EOL] from flask import request [EOL] from markdown . extensions import Extension [EOL] from markdown . postprocessors import Postprocessor [EOL] [EOL] [EOL] def absolute_path_replacer ( match ) : [EOL] [docstring] [EOL] assert len ( match . groups ( ) ) == [number] [EOL] [EOL] prefix = request . script_root [EOL] if prefix . endswith ( [string] ) : [EOL] prefix = prefix [ : - [number] ] [EOL] [EOL] return [string] . format ( key = match . group ( [number] ) , path = prefix + match . group ( [number] ) ) [EOL] [EOL] [EOL] class LinkPostprocessor ( Postprocessor ) : [EOL] @ staticmethod def run ( text ) : [EOL] return re . sub ( [string] , absolute_path_replacer , text , flags = re . IGNORECASE , ) [EOL] [EOL] [EOL] class AbsoluteLinkExtension ( Extension ) : [EOL] [docstring] [EOL] [EOL] @ staticmethod def extendMarkdown ( md , md_globals ) : [EOL] [docstring] [EOL] md . postprocessors [ [string] ] = LinkPostprocessor ( md ) [EOL] [EOL] [EOL] def makeExtension ( * args , ** kwargs ) : [EOL] return AbsoluteLinkExtension ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , List [EOL] import pygal [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] import pygal [EOL] from flask_babel import gettext [EOL] from pygal import Graph [EOL] from pygal . colors import hsl_to_rgb [EOL] from pygal . style import Style [EOL] [EOL] from sipa . units import ( format_as_traffic , max_divisions , reduce_by_base ) [EOL] from sipa . utils . babel_utils import get_weekday [EOL] [EOL] [EOL] def rgb_string ( r , g , b ) : [EOL] return [string] . format ( int ( r ) , int ( g ) , int ( b ) ) [EOL] [EOL] [EOL] def hsl ( h , s , l ) : [EOL] return rgb_string ( * hsl_to_rgb ( h , s , l ) ) [EOL] [EOL] [EOL] traffic_style = Style ( background = [string] , opacity = [string] , opacity_hover = [string] , transition = [string] , colors = ( hsl ( [number] , [number] , [number] ) , hsl ( [number] , [number] , [number] ) , hsl ( [number] , [number] , [number] ) ) , font_family = [string] ) [EOL] [EOL] [EOL] def default_chart ( chart_type , title , inline = True , ** kwargs ) : [EOL] return chart_type ( fill = True , title = title , height = [number] , show_y_guides = True , human_readable = False , major_label_font_size = [number] , label_font_size = [number] , style = traffic_style , disable_xml_declaration = inline , js = [ ] , ** kwargs , ) [EOL] [EOL] [EOL] def generate_traffic_chart ( traffic_data , inline = True ) : [EOL] [docstring] [EOL] [comment] [EOL] divisions = ( max_divisions ( max ( day [ [string] ] for day in traffic_data ) ) [EOL] if traffic_data else [number] ) [EOL] [EOL] traffic_data = [ { key : ( reduce_by_base ( val , divisions = divisions ) [EOL] if key in [ [string] , [string] , [string] ] [EOL] else val ) for key , val in entry . items ( ) } for entry in traffic_data ] [EOL] [EOL] traffic_chart = default_chart ( pygal . Bar , gettext ( [string] ) , inline , value_formatter = lambda value : format_as_traffic ( value , divisions , divide = False ) , ) [EOL] [EOL] traffic_chart . x_labels = ( get_weekday ( day [ [string] ] ) for day in traffic_data ) [EOL] traffic_chart . add ( gettext ( [string] ) , [ day [ [string] ] for day in traffic_data ] , stroke_style = { [string] : [string] } ) [EOL] traffic_chart . add ( gettext ( [string] ) , [ day [ [string] ] for day in traffic_data ] , stroke_style = { [string] : [string] } ) [EOL] traffic_chart . add ( gettext ( [string] ) , [ day [ [string] ] for day in traffic_data ] , stroke_style = { [string] : [string] } ) [EOL] [EOL] return traffic_chart [EOL] [EOL] [EOL] def provide_render_function ( generator ) : [EOL] def renderer ( data , ** kwargs ) : [EOL] return generator ( data , ** kwargs ) . render ( ) [EOL] [EOL] return renderer [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pygal.Graph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Iterable , Any , Union , Optional , Dict [EOL] import http [EOL] import typing [EOL] import requests [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import http . client [EOL] import json [EOL] import requests [EOL] import socket [EOL] import time [EOL] from functools import wraps [EOL] from itertools import chain [EOL] from typing import Iterable [EOL] [EOL] from flask import flash , redirect , request , url_for , session [EOL] from flask_login import current_user [EOL] [EOL] from datetime import datetime , timedelta [EOL] [EOL] from sipa . config . default import PBX_URI [EOL] [EOL] [EOL] def timetag_today ( ) : [EOL] [docstring] [EOL] return int ( time . time ( ) // [number] ) [EOL] [EOL] [EOL] def get_bustimes ( stopname , count = [number] ) : [EOL] [docstring] [EOL] conn = http . client . HTTPConnection ( [string] , timeout = [number] ) [EOL] [EOL] stopname = stopname . replace ( [string] , [string] ) [EOL] try : [EOL] conn . request ( [string] , [string] . format ( stopname ) ) [EOL] response = conn . getresponse ( ) [EOL] except socket . error : [EOL] return None [EOL] [EOL] response_data = json . loads ( response . read ( ) . decode ( ) ) [EOL] [EOL] return ( { [string] : i [ [number] ] , [string] : i [ [number] ] , [string] : int ( i [ [number] ] ) if i [ [number] ] else [number] , } for i in response_data ) [EOL] [comment] [EOL] [EOL] [EOL] def support_hotline_available ( ) : [EOL] [docstring] [EOL] [ avail , time ] = session . get ( [string] , [ False , datetime . fromtimestamp ( [number] ) ] ) [EOL] [EOL] if datetime . now ( ) - time > timedelta ( minutes = [number] ) : [EOL] [comment] [EOL] try : [EOL] r = requests . get ( PBX_URI , timeout = [number] ) [EOL] r . raise_for_status ( ) [EOL] avail = r . text [EOL] session [ [string] ] = [ avail , datetime . now ( ) ] [EOL] except requests . exceptions . RequestException : [EOL] avail = False [EOL] [EOL] if avail == [string] : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def password_changeable ( user ) : [EOL] [docstring] [EOL] def feature_decorator ( func ) : [EOL] @ wraps ( func ) def decorated_view ( * args , ** kwargs ) : [EOL] if user . is_authenticated and user . can_change_password : [EOL] return func ( * args , ** kwargs ) [EOL] else : [EOL] def not_supported ( ) : [EOL] flash ( [string] , [string] ) [EOL] return redirect ( redirect_url ( ) ) [EOL] return not_supported ( ) [EOL] [EOL] return decorated_view [EOL] return feature_decorator [EOL] [EOL] [EOL] def get_user_name ( user = current_user ) : [EOL] if user . is_authenticated : [EOL] return user . uid [EOL] [EOL] if user . is_anonymous : [EOL] return [string] [EOL] [EOL] return [string] [EOL] [EOL] [EOL] def url_self ( ** values ) : [EOL] [docstring] [EOL] if request . endpoint is None : [EOL] endpoint = [string] [EOL] else : [EOL] endpoint = request . endpoint [EOL] [comment] [EOL] [comment] [EOL] kw = request . view_args . copy ( ) if request . view_args is not None else { } [EOL] kw . update ( values ) [EOL] return url_for ( endpoint , ** kw ) [EOL] [EOL] [EOL] def redirect_url ( default = [string] ) : [EOL] return request . args . get ( [string] ) or request . referrer or url_for ( default ) [EOL] [EOL] [EOL] def argstr ( * args , ** kwargs ) : [EOL] return [string] . join ( chain ( ( [string] . format ( arg ) for arg in args ) , ( [string] . format ( key , val ) for key , val in kwargs . items ( ) ) , ) ) [EOL] [EOL] [EOL] def replace_empty_handler_callables ( config , func ) : [EOL] [docstring] [EOL] [EOL] if [string] not in config : [EOL] return config [EOL] [EOL] ret = config . copy ( ) [EOL] ret [ [string] ] = { h_name : { param : ( func [EOL] if val is None and param == [string] [EOL] else val ) for param , val in h_conf . items ( ) } for h_name , h_conf in ret [ [string] ] . items ( ) } [EOL] return ret [EOL] [EOL] [EOL] def dict_diff ( d1 , d2 ) : [EOL] [docstring] [EOL] for key in set ( d1 . keys ( ) ) | set ( d2 . keys ( ) ) : [EOL] if key not in d1 or key not in d2 or d1 [ key ] != d2 [ key ] : [EOL] yield key [EOL] [EOL] [EOL] def compare_all_attributes ( one , other , attr_list ) : [EOL] [docstring] [EOL] try : [EOL] return all ( getattr ( one , attr ) == getattr ( other , attr ) for attr in attr_list ) [EOL] except AttributeError : [EOL] return False [EOL] [EOL] [EOL] def xor_hashes ( * elements ) : [EOL] [docstring] [EOL] _hash = [number] [EOL] for element in elements : [EOL] _hash ^= hash ( element ) [EOL] [EOL] return _hash [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from flask_babel import get_locale [EOL] [EOL] [EOL] def lang ( ) : [EOL] return str ( get_locale ( ) ) [EOL] [EOL] [EOL] def get_weekday ( day ) : [EOL] return get_locale ( ) . days [ [string] ] [ [string] ] [ day ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Union , Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] SENTRY_DSN = None [EOL] [EOL] CONTENT_URL = None [EOL] [EOL] LOCALE_COOKIE_NAME = [string] [EOL] LOCALE_COOKIE_MAX_AGE = [number] * [number] [EOL] [EOL] [comment] [EOL] NUM_PROXIES = [number] [EOL] [EOL] BACKENDS = [ [string] ] [EOL] [EOL] FLATPAGES_ROOT = None [EOL] FLATPAGES_EXTENSION = [string] [EOL] [EOL] FLATPAGES_MARKDOWN_EXTENSIONS = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] MAILSERVER_HOST = [string] [EOL] MAILSERVER_PORT = [number] [EOL] MAILSERVER_SSL = None [EOL] MAILSERVER_SSL_VERIFY = False [EOL] MAILSERVER_SSL_CA_DATA = None [EOL] MAILSERVER_SSL_CA_FILE = None [EOL] MAILSERVER_USER = None [EOL] MAILSERVER_PASSWORD = None [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] DB_HELIOS_IP_MASK = None [EOL] [EOL] SQL_TIMEOUT = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] UWSGI_TIMER_ENABLED = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] GIT_UPDATE_HOOK_TOKEN = [string] [EOL] [EOL] [comment] [EOL] LANGUAGES = { [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] BUSSTOPS = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] MEMBERSHIP_CONTRIBUTION = [number] [EOL] [EOL] [comment] [EOL] PYCROFT_ENDPOINT = [string] [EOL] PYCROFT_API_KEY = [string] [EOL] [EOL] DB_HELIOS_URI = [string] . format ( [string] ) [EOL] DB_HELIOS_IP_MASK = [string] [EOL] [EOL] [comment] [EOL] PBX_URI = [string] [EOL] [EOL] [comment] [EOL] CONTACT_ADDRESSES = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } , { [string] : [string] , [string] : [number] , [string] : [string] , } , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
import builtins [EOL] from typing_extensions import Protocol [EOL] [EOL] [EOL] [comment] [EOL] class UserLike ( Protocol ) : [EOL] @ property def is_active ( self ) : ... [EOL] [EOL] @ property def is_authenticated ( self ) : ... [EOL] [EOL] @ property def is_anonymous ( self ) : ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0
from typing import Callable , Any , Type , Dict , List [EOL] import types [EOL] import flask [EOL] import sipa [EOL] import typing [EOL] import ipaddress [EOL] import builtins [EOL] from __future__ import annotations [EOL] from ipaddress import IPv4Network , IPv4Address [EOL] from typing import Callable , Dict , List , Type [EOL] [EOL] from flask import Flask [EOL] [EOL] from sipa . utils import argstr , compare_all_attributes , xor_hashes [EOL] from . logging import logger [EOL] from . types import UserLike [EOL] [EOL] [EOL] InitContextCallable = Callable [ [ Flask ] , None ] [EOL] [EOL] [EOL] class DataSource : [EOL] [docstring] [EOL] def __init__ ( self , name , user_class , mail_server , webmailer_url = None , support_mail = None , init_context = None ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . name = name [EOL] [EOL] class _user_class ( user_class ) : [comment] [EOL] datasource = self [EOL] [comment] [EOL] self . user_class = _user_class [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . mail_server = mail_server [EOL] self . webmailer_url = webmailer_url [EOL] self . support_mail = ( support_mail if support_mail [EOL] else [string] . format ( mail_server ) ) [EOL] self . _init_context = init_context [EOL] self . _dormitories = { } [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return compare_all_attributes ( self , other , [ [string] ] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( cls = type ( self ) . __name__ , name = self . name , ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return xor_hashes ( self . name , self . user_class , self . support_mail , self . mail_server ) [EOL] [EOL] def register_dormitory ( self , dormitory ) : [EOL] name = dormitory . name [EOL] if name in self . _dormitories : [EOL] raise ValueError ( [string] , name ) [EOL] self . _dormitories [ name ] = dormitory [EOL] [EOL] @ property def dormitories ( self ) : [EOL] [docstring] [EOL] return list ( self . _dormitories . values ( ) ) [EOL] [EOL] def init_context ( self , app ) : [EOL] [docstring] [EOL] [comment] [EOL] config = app . config . get ( [string] , { } ) . get ( self . name , { } ) . copy ( ) [EOL] [EOL] try : [EOL] self . support_mail = config . pop ( [string] ) [EOL] except KeyError : [EOL] pass [EOL] [EOL] for key in config . keys ( ) : [EOL] logger . warning ( [string] , key , extra = { [string] : { [string] : config } } ) [EOL] [EOL] if self . _init_context : [EOL] return self . _init_context ( app ) [EOL] [EOL] [EOL] class SubnetCollection : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , subnets ) : [EOL] if isinstance ( subnets , list ) : [EOL] for subnet in subnets : [EOL] if not isinstance ( subnet , IPv4Network ) : [EOL] raise TypeError ( [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] self . subnets = subnets [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( __name__ , type ( self ) . __name__ , argstr ( subnets = self . subnets , ) ) [EOL] [EOL] [comment] [EOL] def __contains__ ( self , address ) : [EOL] for subnet in self . subnets : [EOL] if address in subnet : [EOL] return True [EOL] return False [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return compare_all_attributes ( self , other , [ [string] ] ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return xor_hashes ( * self . subnets ) [EOL] [EOL] [EOL] class Dormitory : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , display_name , datasource , subnets = None ) : [EOL] self . name = name [EOL] self . display_name = display_name [EOL] self . datasource = datasource [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] datasource . register_dormitory ( self ) [EOL] self . subnets = SubnetCollection ( subnets if subnets else [ ] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( __name__ , type ( self ) . __name__ , argstr ( name = self . name , display_name = self . display_name , datasource = self . datasource , subnets = self . subnets . subnets , ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return compare_all_attributes ( self , other , [ [string] , [string] ] ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return xor_hashes ( self . name , self . display_name , self . datasource , self . subnets ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Callable[[flask.app.Flask],None]$ 0 0 0 0 0 $typing.Dict[builtins.str,Dormitory]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Dormitory$ 0 0 0 $builtins.str$ 0 $Dormitory$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $Dormitory$ 0 0 0 0 0 $typing.List[Dormitory]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 $typing.Any$ 0 $flask.Flask$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[ipaddress.IPv4Network]$ 0 0 0 0 0 0 $typing.List[ipaddress.IPv4Network]$ 0 0 0 0 0 0 0 0 $typing.List[ipaddress.IPv4Network]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ipaddress.IPv4Network]$ 0 $typing.List[ipaddress.IPv4Network]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ipaddress.IPv4Address$ 0 0 0 0 0 0 0 0 0 0 0 0 $ipaddress.IPv4Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $sipa.backends.datasource.DataSource$ 0 $sipa.backends.datasource.SubnetCollection$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $sipa.backends.datasource.DataSource$ 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 $sipa.backends.datasource.DataSource$ 0 0 0 0 0 0 0 0 $sipa.backends.datasource.SubnetCollection$ 0 0 0 $sipa.backends.datasource.SubnetCollection$ 0 $sipa.backends.datasource.SubnetCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class InvalidConfiguration ( IndexError ) : [EOL] pass [EOL] [EOL] [EOL] class BackendError ( RuntimeError ) : [EOL] def __init__ ( self , backend_name , * a , ** kw ) : [EOL] self . backend_name = backend_name [EOL] super ( ) . __init__ ( * a , ** kw ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import annotations [EOL] [EOL] from . extension import Backends , backends [EOL] from . datasource import DataSource , Dormitory , InitContextCallable [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any , List [EOL] import typing [EOL] import flask [EOL] [docstring] [EOL] from operator import attrgetter [EOL] [EOL] from flask import Blueprint , abort , current_app , render_template , request [EOL] [EOL] bp_news = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] [EOL] @ bp_news . route ( [string] ) def show ( ) : [EOL] [docstring] [EOL] start = request . args . get ( [string] , None , int ) [EOL] end = request . args . get ( [string] , None , int ) [EOL] cf_pages = current_app . cf_pages [EOL] cf_pages . reload ( ) [EOL] news = sorted ( ( article for article in cf_pages . get_articles_of_category ( [string] ) if hasattr ( article , [string] ) ) , key = attrgetter ( [string] ) , reverse = True , ) [EOL] if len ( news ) is [number] : [EOL] return render_template ( [string] , articles = None , previous_range = [number] , next_range = [number] ) [EOL] [EOL] default_step = [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if start is None : [EOL] if end is None : [EOL] start , end = [number] , default_step [EOL] else : [EOL] end %= len ( news ) [EOL] start = max ( end - default_step + [number] , [number] ) [EOL] else : [EOL] start %= len ( news ) [EOL] if end is None : [EOL] end = min ( start + default_step - [number] , len ( news ) - [number] ) [EOL] else : [EOL] end %= len ( news ) [EOL] [EOL] delta = end - start + [number] [EOL] prev_range , next_range = None , None [EOL] [EOL] if start > [number] : [EOL] prev_range = { [string] : max ( start - delta , [number] ) , [string] : start - [number] } [EOL] if end < len ( news ) - [number] : [EOL] next_range = { [string] : end + [number] , [string] : min ( end + delta , len ( news ) - [number] ) } [EOL] [EOL] return render_template ( [string] , articles = news [ start : end + [number] ] , previous_range = prev_range , next_range = next_range ) [EOL] [EOL] [EOL] @ bp_news . route ( [string] ) def show_news ( filename ) : [EOL] news = current_app . cf_pages . get_articles_of_category ( [string] ) [EOL] [EOL] for article in news : [EOL] if article . file_basename == filename : [EOL] return render_template ( [string] , article = article ) [EOL] [EOL] abort ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Generator , Any , Literal , Optional , Union , Dict , List [EOL] import logging [EOL] import flask [EOL] import sipa [EOL] import typing [EOL] import typing_extensions [EOL] import logging [EOL] import os [EOL] [EOL] from flask import render_template , request , redirect , url_for , flash , session , abort , current_app , jsonify [EOL] from flask . blueprints import Blueprint [EOL] from flask_babel import gettext , format_date [EOL] from flask_login import current_user , login_user , logout_user , login_required [EOL] from sqlalchemy . exc import DatabaseError [EOL] [EOL] from sipa . backends . exceptions import BackendError [EOL] from sipa . forms import flash_formerrors , LoginForm , AnonymousContactForm , OfficialContactForm [EOL] from sipa . mail import send_official_contact_mail , send_contact_mail [EOL] from sipa . backends . extension import backends [EOL] from sipa . units import dynamic_unit , format_money [EOL] from sipa . utils import get_user_name , redirect_url [EOL] from sipa . model . exceptions import UserNotFound , InvalidCredentials [EOL] from sipa . utils . git_utils import get_repo_active_branch , get_latest_commits [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] bp_generic = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ bp_generic . before_app_request def log_request ( ) : [EOL] if [string] in current_app . extensions : [EOL] current_app . extensions [ [string] ] . client . extra_context ( { [string] : get_user_name ( current_user ) , [string] : get_user_name ( backends . user_from_ip ( request . remote_addr ) ) } ) [EOL] [EOL] logging . getLogger ( __name__ + [string] ) . debug ( [string] , request . method , request . path , extra = { [string] : { [string] : get_user_name ( current_user ) , [string] : request . remote_addr } } ) [EOL] [EOL] [EOL] @ bp_generic . app_errorhandler ( [number] ) @ bp_generic . app_errorhandler ( [number] ) @ bp_generic . app_errorhandler ( [number] ) def error_handler_redirection ( e ) : [EOL] [docstring] [EOL] if e . code == [number] : [EOL] message = gettext ( [string] ) [EOL] elif e . code == [number] : [EOL] message = gettext ( [string] ) [EOL] elif e . code == [number] : [EOL] message = gettext ( [string] ) [EOL] else : [EOL] message = gettext ( [string] ) [EOL] return render_template ( [string] , errorcode = e . code , message = message ) , e . code [EOL] [EOL] [EOL] @ bp_generic . app_errorhandler ( DatabaseError ) def exceptionhandler_sql ( ex ) : [EOL] [docstring] [EOL] flash ( gettext ( [string] [string] ) , [string] ) [EOL] logger . critical ( [string] , extra = { [string] : { [string] : ex . args } } , exc_info = True ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] [EOL] @ bp_generic . app_errorhandler ( BackendError ) def exceptionhandler_backend ( ex ) : [EOL] flash ( gettext ( [string] [string] , name = ex . backend_name ) , [string] ) [EOL] logger . critical ( [string] , ex . backend_name , extra = { [string] : { [string] : ex . args } } , exc_info = True , ) [EOL] return redirect ( url_for ( [string] ) , [number] ) [EOL] [EOL] [EOL] @ bp_generic . route ( [string] ) @ bp_generic . route ( [string] ) def index ( ) : [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] [EOL] @ bp_generic . route ( [string] , methods = [ [string] , [string] ] ) def login ( ) : [EOL] [docstring] [EOL] form = LoginForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] dormitory = backends . get_dormitory ( form . dormitory . data ) [EOL] username = form . username . data [EOL] password = form . password . data [EOL] remember = form . remember . data [EOL] User = dormitory . datasource . user_class [EOL] [EOL] valid_suffix = [string] . format ( dormitory . datasource . mail_server ) [EOL] [EOL] if username . endswith ( valid_suffix ) : [EOL] username = username [ : - len ( valid_suffix ) ] [EOL] [EOL] try : [EOL] user = User . authenticate ( username , password ) [EOL] except InvalidCredentials as e : [EOL] cause = [string] if isinstance ( e , UserNotFound ) else [string] [EOL] logger . info ( [string] , cause , extra = { [string] : { [string] : username , [string] : True } } ) [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] if isinstance ( user , User ) : [EOL] session [ [string] ] = dormitory . name [EOL] login_user ( user , remember = remember ) [EOL] logger . info ( [string] , extra = { [string] : { [string] : username } } ) [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] if current_user . is_authenticated : [EOL] [comment] [EOL] [comment] [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] return render_template ( [string] , form = form , unsupported = backends . premature_dormitories ) [EOL] [EOL] [EOL] @ bp_generic . route ( [string] ) @ login_required def logout ( ) : [EOL] logger . info ( [string] , extra = { [string] : { [string] : current_user . uid } } ) [EOL] logout_user ( ) [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] [EOL] bp_generic . add_app_template_filter ( dynamic_unit , name = [string] ) [EOL] [EOL] [EOL] @ bp_generic . app_template_filter ( [string] ) def to_gigabytes ( number ) : [EOL] [docstring] [EOL] return number / [number] ** [number] [EOL] [EOL] [EOL] @ bp_generic . app_template_filter ( [string] ) def jinja_format_date ( date ) : [EOL] return format_date ( date ) [EOL] [EOL] [EOL] bp_generic . add_app_template_filter ( format_money , name = [string] ) [EOL] [EOL] [EOL] @ bp_generic . route ( [string] ) def usertraffic ( ) : [EOL] [docstring] [EOL] ip_user = backends . user_from_ip ( request . remote_addr ) [EOL] [EOL] chosen_user = None [EOL] [EOL] if current_user . is_authenticated : [EOL] chosen_user = current_user [EOL] if not current_user . has_connection and not ip_user . is_authenticated : [EOL] flash ( gettext ( [string] [string] ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] if ip_user . is_authenticated : [EOL] chosen_user = ip_user [EOL] [EOL] if current_user . is_authenticated : [EOL] if current_user != ip_user : [EOL] flash ( gettext ( [string] [string] ) , [string] ) [EOL] flash ( gettext ( [string] [string] ) , [string] ) [EOL] [EOL] if chosen_user : [EOL] user_id = chosen_user . id . value if chosen_user . id . supported else None [EOL] return render_template ( [string] , user_id = user_id , traffic_user = chosen_user ) [EOL] [EOL] abort ( [number] ) [EOL] [EOL] [EOL] @ bp_generic . route ( [string] ) def traffic_api ( ) : [EOL] user = ( current_user if current_user . is_authenticated [EOL] else backends . user_from_ip ( request . remote_addr ) ) [EOL] [EOL] if not user . is_authenticated : [EOL] return jsonify ( version = [number] ) [EOL] [EOL] traffic_history = ( { [string] : x [ [string] ] , [string] : x [ [string] ] , } for x in reversed ( user . traffic_history ) ) [EOL] [EOL] trafficdata = { [string] : next ( traffic_history ) , [string] : list ( traffic_history ) , } [EOL] [EOL] return jsonify ( version = [number] , ** trafficdata ) [EOL] [EOL] [EOL] @ bp_generic . route ( [string] , methods = [ [string] , [string] ] ) def contact ( ) : [EOL] form = AnonymousContactForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] success = send_contact_mail ( author = form . email . data , subject = form . subject . data , name = form . name . data , message = form . message . data , dormitory_name = form . dormitory . data , ) [EOL] [EOL] if success : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] elif current_user . is_authenticated : [EOL] flash ( gettext ( [string] [string] [string] [string] ) , [string] ) [EOL] [EOL] return render_template ( [string] , form = form ) [EOL] [EOL] [EOL] @ bp_generic . route ( [string] , methods = [ [string] , [string] ] ) def contact_official ( ) : [EOL] form = OfficialContactForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] success = send_official_contact_mail ( author = form . email . data , subject = form . subject . data , name = form . name . data , message = form . message . data , ) [EOL] [EOL] if success : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] return render_template ( [string] , form = form ) [EOL] [EOL] [EOL] @ bp_generic . route ( [string] ) def version ( ) : [EOL] [docstring] [EOL] sipa_dir = os . getcwd ( ) [EOL] return render_template ( [string] , active_branch = get_repo_active_branch ( sipa_dir ) , commits = get_latest_commits ( sipa_dir , [number] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import flask [EOL] import os [EOL] [EOL] from flask import Blueprint , send_from_directory , current_app [EOL] from flask_login import current_user [EOL] from flask . views import View [EOL] [EOL] from sipa . base import login_manager [EOL] [EOL] [EOL] bp_documents = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] class StaticFiles ( View ) : [EOL] def __init__ ( self , directory , login_required = False , member_required = False ) : [EOL] self . directory = directory [EOL] self . login_required = login_required [EOL] self . member_required = member_required [EOL] [EOL] def dispatch_request ( self , filename ) : [EOL] if self . login_required and not current_user . is_authenticated : [EOL] return current_app . login_manager . unauthorized ( ) [EOL] [EOL] if self . member_required and not current_user . is_member : [EOL] return current_app . login_manager . unauthorized ( ) [EOL] [EOL] if os . path . isabs ( self . directory ) : [EOL] directory = self . directory [EOL] else : [EOL] directory = os . path . join ( current_app . root_path , self . directory ) [EOL] cache_timeout = current_app . get_send_file_max_age ( filename ) [EOL] return send_from_directory ( directory , filename , cache_timeout = cache_timeout ) [EOL] [EOL] [EOL] bp_documents . add_url_rule ( [string] , view_func = StaticFiles . as_view ( [string] , [string] ) ) [EOL] login_manager . ignore_endpoint ( [string] ) [EOL] [EOL] bp_documents . add_url_rule ( [string] , view_func = StaticFiles . as_view ( [string] , [string] ) ) [EOL] login_manager . ignore_endpoint ( [string] ) [EOL] [EOL] [EOL] bp_documents . add_url_rule ( [string] , view_func = StaticFiles . as_view ( [string] , [string] , login_required = True , member_required = True ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , OrderedDict , Union , Optional , Dict [EOL] import logging [EOL] import flask [EOL] import collections [EOL] import sipa [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from collections import OrderedDict [EOL] import logging [EOL] from datetime import datetime [EOL] [EOL] from babel . numbers import format_currency [EOL] from flask import Blueprint , render_template , url_for , redirect , flash , abort , request [EOL] from flask_babel import format_date , gettext [EOL] from flask_login import current_user , login_required [EOL] from flask_wtf import FlaskForm [EOL] from markupsafe import Markup [EOL] [EOL] from sipa . config . default import MEMBERSHIP_CONTRIBUTION [EOL] from sipa . forms import ContactForm , ChangeMACForm , ChangeMailForm , ChangePasswordForm , flash_formerrors , HostingForm , DeleteMailForm , PaymentForm , ActivateNetworkAccessForm , TerminateMembershipForm , TerminateMembershipConfirmForm , ContinueMembershipForm [EOL] from sipa . mail import send_usersuite_contact_mail [EOL] from sipa . model . fancy_property import ActiveProperty [EOL] from sipa . utils import password_changeable [EOL] from sipa . model . exceptions import DBQueryEmpty , PasswordInvalid , UserNotFound , MacAlreadyExists , TerminationNotPossible , UnknownError , ContinuationNotPossible [EOL] from sipa . model . misc import PaymentDetails [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] bp_usersuite = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] [EOL] def capability_or_403 ( active_property , capability ) : [EOL] prop = getattr ( current_user , active_property ) [EOL] if not getattr ( prop . capabilities , capability ) : [EOL] abort ( [number] ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def index ( ) : [EOL] [docstring] [EOL] info = current_user . finance_information [EOL] last_update = info . last_update if info else None [EOL] finance_update_string = ( [string] . format ( gettext ( [string] ) , format_date ( last_update , [string] , rebase = False ) ) [EOL] if last_update [EOL] else [string] ) [EOL] descriptions = OrderedDict ( [ ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) ) , ( [string] , gettext ( [string] ) + finance_update_string ) , ] ) [EOL] [EOL] try : [EOL] rows = current_user . generate_rows ( descriptions ) [EOL] except DBQueryEmpty as e : [EOL] logger . error ( [string] , extra = { [string] : { [string] : e . args } , [string] : True } ) [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] payment_form = PaymentForm ( ) [EOL] if payment_form . validate_on_submit ( ) : [EOL] months = payment_form . months . data [EOL] else : [EOL] months = payment_form . months . default [EOL] flash_formerrors ( payment_form ) [EOL] [EOL] datasource = current_user . datasource [EOL] context = dict ( rows = rows , webmailer_url = datasource . webmailer_url , terminate_membership_url = url_for ( [string] ) , continue_membership_url = url_for ( [string] ) , payment_details = render_payment_details ( current_user . payment_details ( ) , months ) , girocode = generate_epc_qr_code ( current_user . payment_details ( ) , months ) ) [EOL] [EOL] if current_user . has_connection : [EOL] context . update ( show_traffic_data = True , traffic_user = current_user , ) [EOL] [EOL] if info and info . has_to_pay : [EOL] context . update ( show_transaction_log = True , last_update = info . last_update , balance = info . balance . raw_value , logs = info . history , ) [EOL] [EOL] return render_template ( [string] , payment_form = payment_form , ** context ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def contact ( ) : [EOL] [docstring] [EOL] form = ContactForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] types = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] success = send_usersuite_contact_mail ( author = form . email . data , category = types . get ( form . type . data , [string] ) , subject = form . subject . data , message = form . message . data ) [EOL] [EOL] if success : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] flash ( gettext ( [string] [string] . format ( current_user . datasource . support_mail ) ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] form . email . default = current_user . mail . raw_value [EOL] [EOL] return render_template ( [string] , form = form ) [EOL] [EOL] [EOL] def render_payment_details ( details , months ) : [EOL] return { gettext ( [string] ) : details . recipient , gettext ( [string] ) : details . bank , gettext ( [string] ) : details . iban , gettext ( [string] ) : details . bic , gettext ( [string] ) : details . purpose , gettext ( [string] ) : format_currency ( months * MEMBERSHIP_CONTRIBUTION / [number] , [string] , locale = [string] ) } [EOL] [EOL] [EOL] def generate_epc_qr_code ( details , months ) : [EOL] [comment] [EOL] EPC_FORMAT = [string] [EOL] [EOL] return EPC_FORMAT . format ( bic = details . bic . replace ( [string] , [string] ) , recipient = details . recipient , iban = details . iban . replace ( [string] , [string] ) , amount = months * MEMBERSHIP_CONTRIBUTION / [number] , purpose = details . purpose ) [EOL] [EOL] [EOL] def get_attribute_endpoint ( attribute , capability = [string] ) : [EOL] [docstring] [EOL] if capability == [string] : [EOL] attribute_mappings = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert attribute in attribute_mappings . keys ( ) , [string] . format ( attribute ) [EOL] else : [EOL] assert capability == [string] , [string] [EOL] [EOL] attribute_mappings = { [string] : [string] , [string] : [string] , } [EOL] [EOL] assert attribute in attribute_mappings . keys ( ) , [string] . format ( attribute ) [EOL] [EOL] return [string] . format ( bp_usersuite . name , attribute_mappings [ attribute ] ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required @ password_changeable ( current_user ) def change_password ( ) : [EOL] [docstring] [EOL] form = ChangePasswordForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] old = form . old . data [EOL] new = form . new . data [EOL] [EOL] try : [EOL] with current_user . tmp_authentication ( old ) : [EOL] current_user . change_password ( old , new ) [EOL] except PasswordInvalid : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] return render_template ( [string] , form = form ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def change_mail ( ) : [EOL] [docstring] [EOL] [EOL] capability_or_403 ( [string] , [string] ) [EOL] [EOL] form = ChangeMailForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] password = form . password . data [EOL] email = form . email . data [EOL] [EOL] try : [EOL] with current_user . tmp_authentication ( password ) : [EOL] current_user . mail = email [EOL] except UserNotFound : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] except PasswordInvalid : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] return render_template ( [string] , form = form ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def delete_mail ( ) : [EOL] [docstring] [EOL] [EOL] capability_or_403 ( [string] , [string] ) [EOL] [EOL] form = DeleteMailForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] password = form . password . data [EOL] [EOL] try : [EOL] with current_user . tmp_authentication ( password ) : [EOL] del current_user . mail [EOL] except UserNotFound : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] except PasswordInvalid : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] return render_template ( [string] , form = form ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def change_mac ( ) : [EOL] [docstring] [EOL] [EOL] capability_or_403 ( [string] , [string] ) [EOL] [EOL] form = ChangeMACForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] password = form . password . data [EOL] mac = form . mac . data [EOL] host_name = form . host_name . data [EOL] [EOL] try : [EOL] with current_user . tmp_authentication ( password ) : [EOL] current_user . change_mac_address ( mac , host_name ) [EOL] except PasswordInvalid : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] except MacAlreadyExists : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] logger . info ( [string] , extra = { [string] : { [string] : mac } , [string] : { [string] : True } } ) [EOL] [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] flash ( gettext ( [string] [string] ) , [string] ) [EOL] [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] form . mac . default = current_user . mac . value [EOL] [EOL] return render_template ( [string] , form = form ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def activate_network_access ( ) : [EOL] [docstring] [EOL] [EOL] capability_or_403 ( [string] , [string] ) [EOL] [EOL] form = ActivateNetworkAccessForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] password = form . password . data [EOL] mac = form . mac . data [EOL] birthdate = form . birthdate . data [EOL] host_name = form . host_name . data [EOL] [EOL] try : [EOL] with current_user . tmp_authentication ( password ) : [EOL] current_user . activate_network_access ( password , mac , birthdate , host_name ) [EOL] except PasswordInvalid : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] except MacAlreadyExists : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] logger . info ( [string] , extra = { [string] : { [string] : mac , [string] : birthdate , [string] : host_name } , [string] : { [string] : True } } ) [EOL] [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] flash ( gettext ( [string] [string] ) , [string] ) [EOL] [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] return render_template ( [string] , form = form ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def hosting ( action = None ) : [EOL] [docstring] [EOL] if not current_user . has_property ( [string] ) : [EOL] abort ( [number] ) [EOL] [EOL] if action == [string] : [EOL] current_user . userdb . drop ( ) [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] form = HostingForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] if form . action . data == [string] : [EOL] current_user . userdb . create ( form . password . data ) [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] current_user . userdb . change_password ( form . password . data ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] try : [EOL] user_has_db = current_user . userdb . has_db [EOL] except NotImplementedError : [EOL] abort ( [number] ) [EOL] [EOL] return render_template ( [string] , form = form , user_has_db = user_has_db , action = action ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] ) @ login_required def finance_logs ( ) : [EOL] return redirect ( url_for ( [string] , _anchor = [string] ) ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def terminate_membership ( ) : [EOL] [docstring] [EOL] [EOL] capability_or_403 ( [string] , [string] ) [EOL] [EOL] if current_user . membership_end_date . raw_value is not None : [EOL] abort ( [number] ) [EOL] [EOL] form = TerminateMembershipForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] end_date = form . end_date . data [EOL] [EOL] return redirect ( url_for ( [string] , end_date = end_date ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] form_args = { [string] : form , [string] : url_for ( [string] ) , [string] : gettext ( [string] ) } [EOL] [EOL] return render_template ( [string] , page_title = gettext ( [string] ) , form_args = form_args ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def terminate_membership_confirm ( ) : [EOL] [docstring] [EOL] [EOL] capability_or_403 ( [string] , [string] ) [EOL] [EOL] if current_user . membership_end_date . raw_value is not None : [EOL] abort ( [number] ) [EOL] [EOL] end_date = request . args . get ( [string] , None , lambda x : datetime . strptime ( x , [string] ) . date ( ) ) [EOL] [EOL] form = TerminateMembershipConfirmForm ( ) [EOL] [EOL] if end_date is not None : [EOL] try : [EOL] form . estimated_balance . default = str ( current_user . estimate_balance ( end_date ) ) [EOL] [EOL] except UnknownError : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] form . end_date . default = end_date [EOL] else : [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] try : [EOL] current_user . terminate_membership ( form . end_date . data ) [EOL] except TerminationNotPossible : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] except MacAlreadyExists : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] logger . info ( [string] , extra = { [string] : { [string] : form . end_date . data } , [string] : { [string] : True } } ) [EOL] [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] [EOL] return redirect ( url_for ( [string] ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] form_args = { [string] : form , [string] : url_for ( [string] ) } [EOL] [EOL] return render_template ( [string] , page_title = gettext ( [string] ) , form_args = form_args ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def continue_membership ( ) : [EOL] [docstring] [EOL] [EOL] capability_or_403 ( [string] , [string] ) [EOL] [EOL] if current_user . membership_end_date . raw_value is None : [EOL] abort ( [number] ) [EOL] [EOL] form = ContinueMembershipForm ( ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] try : [EOL] current_user . continue_membership ( ) [EOL] except ContinuationNotPossible : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] except UnknownError : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] logger . info ( [string] , extra = { [string] : { [string] : True } } ) [EOL] [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] [EOL] return redirect ( url_for ( [string] ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] form_args = { [string] : form , [string] : url_for ( [string] ) } [EOL] [EOL] return render_template ( [string] , page_title = gettext ( [string] ) , form_args = form_args ) [EOL] [EOL] [EOL] @ bp_usersuite . route ( [string] , methods = [ [string] , [string] ] ) @ login_required def reset_wifi_password ( ) : [EOL] [docstring] [EOL] [EOL] form = FlaskForm ( ) [EOL] [EOL] capability_or_403 ( [string] , [string] ) [EOL] [EOL] if form . validate_on_submit ( ) : [EOL] try : [EOL] new_password = current_user . reset_wifi_password ( ) [EOL] except UnknownError : [EOL] flash ( gettext ( [string] ) , [string] ) [EOL] else : [EOL] logger . info ( [string] , extra = { [string] : { [string] : True } } ) [EOL] [EOL] flash ( Markup ( [string] . format ( gettext ( [string] ) , new_password ) ) , [string] ) [EOL] [EOL] return redirect ( url_for ( [string] ) ) [EOL] elif form . is_submitted ( ) : [EOL] flash_formerrors ( form ) [EOL] [EOL] form_args = { [string] : form , [string] : url_for ( [string] ) , [string] : gettext ( [string] ) } [EOL] [EOL] return render_template ( [string] , page_title = gettext ( [string] ) , form_args = form_args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from . generic import bp_generic [EOL] from . pages import bp_pages [EOL] from . usersuite import bp_usersuite [EOL] from . documents import bp_documents [EOL] from . features import bp_features [EOL] from . news import bp_news [EOL] from . hooks import bp_hooks [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Tuple , Dict , Any , List [EOL] import logging [EOL] import typing [EOL] import flask [EOL] [docstring] [EOL] [EOL] import os . path [EOL] from logging import getLogger [EOL] import json [EOL] [EOL] from flask import Blueprint , render_template , redirect , current_app [EOL] from flask_login import current_user [EOL] [EOL] from sipa . backends . extension import backends [EOL] [EOL] logger = getLogger ( __name__ ) [EOL] [EOL] bp_pages = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] [EOL] @ bp_pages . route ( [string] ) def show ( category_id , article_id ) : [EOL] [docstring] [EOL] article = current_app . cf_pages . get_or_404 ( category_id , article_id ) [EOL] [EOL] try : [EOL] restricted = article . restricted [EOL] except AttributeError : [EOL] restricted = False [EOL] if restricted and not current_user . is_authenticated : [EOL] return current_app . login_manager . unauthorized ( ) [EOL] [EOL] if article . link : [EOL] return redirect ( article . link ) [EOL] [EOL] box_filename = os . path . join ( os . path . abspath ( current_app . config [ [string] ] ) , [string] . format ( article . localized_page . path ) ) [EOL] [EOL] dynamic_data = load_dynamic_json ( box_filename ) [EOL] [EOL] if not dynamic_data : [EOL] return render_template ( [string] , article = article , dynamic = False ) [EOL] [EOL] return render_template ( [string] , article = article , default_dormitory = backends . preferred_dormitory_name ( ) , dynamic = True , ** dynamic_data ) [EOL] [EOL] [EOL] def load_dynamic_json ( filename ) : [EOL] try : [EOL] with open ( filename , encoding = [string] ) as f : [EOL] json_string = f . read ( ) [EOL] except OSError : [EOL] return [EOL] [EOL] try : [EOL] dynamic_data = json . loads ( json_string ) [EOL] except ValueError : [EOL] logger . error ( [string] , filename , extra = { [string] : { [string] : json_string , } } , exc_info = True ) [EOL] return [EOL] [EOL] try : [EOL] keys = dynamic_data [ [string] ] [EOL] values = dynamic_data [ [string] ] [EOL] mappings = dynamic_data [ [string] ] [EOL] title = dynamic_data [ [string] ] [EOL] except KeyError : [EOL] logger . error ( [string] , filename , extra = { [string] : { [string] : dynamic_data } , } , exc_info = True ) [EOL] [EOL] values = { dorm . name : values [ mappings [ dorm . name ] ] for dorm in backends . dormitories if dorm . name in mappings } [EOL] dormitories = [ ( dorm . name , dorm . display_name ) for dorm in backends . dormitories if dorm . name in mappings ] [EOL] [EOL] return { [string] : title , [string] : keys , [string] : dormitories , [string] : values } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import flask [EOL] [docstring] [EOL] [EOL] from flask import Blueprint , current_app [EOL] from flask . templating import render_template [EOL] from sipa . utils import get_bustimes [EOL] [EOL] bp_features = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ bp_features . route ( [string] ) @ bp_features . route ( [string] ) def bustimes ( stopname = None ) : [EOL] [docstring] [EOL] data = { } [EOL] [EOL] if stopname : [EOL] [comment] [EOL] data [ stopname ] = get_bustimes ( stopname ) [EOL] else : [EOL] [comment] [EOL] for stop in current_app . config [ [string] ] : [EOL] data [ stop ] = get_bustimes ( stop , [number] ) [EOL] [EOL] return render_template ( [string] , stops = data , stopname = stopname ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import flask [EOL] import logging [EOL] [EOL] from flask import current_app , request , abort [EOL] from flask . blueprints import Blueprint [EOL] [EOL] from sipa . utils . git_utils import update_repo [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] bp_hooks = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] [EOL] @ bp_hooks . route ( [string] , methods = [ [string] ] ) def content_hook ( ) : [EOL] auth_key = current_app . config . get ( [string] ) [EOL] [EOL] if not auth_key : [EOL] [comment] [EOL] abort ( [number] ) [EOL] [EOL] key = request . args . get ( [string] ) [EOL] if not key : [EOL] logger . debug ( [string] , extra = { [string] : { [string] : request . args } } ) [EOL] abort ( [number] ) [EOL] [EOL] if key != auth_key : [EOL] logger . warning ( [string] , extra = { [string] : { [string] : request . args , [string] : auth_key } } ) [EOL] abort ( [number] ) [EOL] [EOL] logger . info ( [string] ) [EOL] reload_necessary = update_repo ( current_app . config [ [string] ] ) [EOL] if reload_necessary : [EOL] try : [EOL] import uwsgi [EOL] except ImportError : [EOL] logger . debug ( [string] ) [EOL] pass [EOL] else : [EOL] logger . debug ( [string] ) [EOL] uwsgi . reload ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] return [string] , [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0