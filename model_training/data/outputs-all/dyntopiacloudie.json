from typing import Dict , MutableMapping , Any [EOL] import typing [EOL] import subprocess [EOL] import os [EOL] import pathlib [EOL] import subprocess [EOL] import tempfile [EOL] from unittest import TestCase [EOL] from unittest . mock import patch [EOL] [EOL] from cloudie import config , utils [EOL] [EOL] [EOL] class TestConfigPermission ( TestCase ) : [EOL] [comment] [EOL] [EOL] def setUp ( self ) : [EOL] self . config = tempfile . NamedTemporaryFile ( [string] ) [EOL] self . cache = tempfile . TemporaryDirectory ( ) [EOL] [EOL] with patch ( [string] ) as mock : [EOL] mock . return_value = pathlib . Path ( self . cache . name ) [EOL] self . permission = config . ConfigPermission ( self . config ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . config . close ( ) [EOL] self . cache . cleanup ( ) [EOL] [EOL] def test_missing_digest_cache ( self ) : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] with patch ( [string] ) as mock : [EOL] self . permission . ask ( ) [EOL] self . assertEqual ( mock . call_count , [number] ) [EOL] [EOL] def test_invalid_digest_cache ( self ) : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] name = os . path . basename ( self . config . name ) [EOL] self . permission . _cache . joinpath ( name ) . write_text ( [string] ) [EOL] [EOL] with patch ( [string] ) as mock : [EOL] self . permission . ask ( ) [EOL] self . assertEqual ( mock . call_count , [number] ) [EOL] [EOL] def test_valid_digest_cache ( self ) : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] name = os . path . basename ( self . config . name ) [EOL] self . permission . _cache . joinpath ( name ) . write_text ( [string] ) [EOL] [EOL] self . assertTrue ( self . permission . ask ( ) ) [EOL] [EOL] def test_answer_no ( self ) : [EOL] for answer in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] with patch ( [string] ) as mock : [EOL] mock . return_value = answer [EOL] [EOL] self . assertFalse ( self . permission . ask ( ) ) [EOL] self . assertEqual ( mock . call_count , [number] ) [EOL] [EOL] def test_answer_yes ( self ) : [EOL] for answer in [ [string] , [string] ] : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] with patch ( [string] ) as mock : [EOL] mock . return_value = answer [EOL] [EOL] self . assertTrue ( self . permission . ask ( ) ) [EOL] self . assertEqual ( mock . call_count , [number] ) [EOL] [EOL] name = os . path . basename ( self . config . name ) [EOL] self . assertEqual ( utils . sha256 ( self . config ) , self . permission . _cache . joinpath ( name ) . read_text ( ) ) [EOL] [EOL] def test_mkdir ( self ) : [EOL] with tempfile . TemporaryDirectory ( ) as tmp : [EOL] with patch ( [string] ) as mock : [EOL] home = os . path . join ( tmp , [string] , [string] , [string] ) [EOL] mock . return_value = pathlib . Path ( home ) [EOL] self . permission = config . ConfigPermission ( self . config ) [EOL] self . assertTrue ( os . path . isdir ( home ) ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class TestConfigDecoder ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . config = tempfile . NamedTemporaryFile ( [string] ) [EOL] self . tmpdir = tempfile . TemporaryDirectory ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . config . close ( ) [EOL] self . tmpdir . cleanup ( ) [EOL] [EOL] def test_permission_denied ( self ) : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] with self . assertRaises ( config . ConfigPermissionError ) : [EOL] with patch ( [string] ) as mock : [EOL] mock . return_value = [string] [EOL] config . load ( self . config . name ) [EOL] [EOL] def test_permission_granted ( self ) : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] with patch ( [string] ) as home_mock : [EOL] home_mock . return_value = pathlib . Path ( self . tmpdir . name ) [EOL] [EOL] with patch ( [string] ) as input_mock : [EOL] input_mock . return_value = [string] [EOL] got = config . load ( self . config . name ) [EOL] want = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } [EOL] self . assertEqual ( got , want ) [EOL] [EOL] def test_execution_failure ( self ) : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] with patch ( [string] ) as home_mock : [EOL] home_mock . return_value = pathlib . Path ( self . tmpdir . name ) [EOL] [EOL] with patch ( [string] ) as co_mock_a : [EOL] with self . assertRaises ( config . ConfigCommandError ) : [EOL] exc = subprocess . CalledProcessError ( [number] , [string] ) [EOL] co_mock_a . side_effect = exc [EOL] with patch ( [string] ) as input_mock : [EOL] input_mock . return_value = [string] [EOL] config . load ( self . config . name ) [EOL] [EOL] with patch ( [string] ) as co_mock_b : [EOL] with self . assertRaises ( config . ConfigCommandError ) : [EOL] co_mock_b . side_effect = FileNotFoundError [EOL] with patch ( [string] ) as input_mock : [EOL] input_mock . return_value = [string] [EOL] config . load ( self . config . name ) [EOL] [EOL] [EOL] class TestLoad ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . config = tempfile . NamedTemporaryFile ( [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . config . close ( ) [EOL] [EOL] def test_file_not_found ( self ) : [EOL] self . config . close ( ) [EOL] [EOL] with self . assertRaises ( config . ConfigError ) as ctx : [EOL] config . load ( self . config . name ) [EOL] [EOL] self . assertTrue ( [string] in str ( ctx . exception ) ) [EOL] [EOL] def test_invalid_config ( self ) : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] with self . assertRaises ( config . ConfigError ) as ctx : [EOL] config . load ( self . config . name ) [EOL] [EOL] self . assertTrue ( [string] in str ( ctx . exception ) ) [EOL] [EOL] def test_success ( self ) : [EOL] self . config . write ( [string] ) [EOL] self . config . flush ( ) [EOL] [EOL] result = config . load ( self . config . name ) [EOL] self . assertEqual ( result , { [string] : [string] , [string] : { [string] : [number] } } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from cloudie import security [comment] [EOL] [EOL] from unittest import TestCase [EOL] [EOL] import libcloud [EOL] import libcloud . common . ovh [EOL] import libcloud . compute . deployment [EOL] import libcloud . compute . drivers . ec2 [EOL] import libcloud . compute . drivers . vultr [EOL] import libcloud . compute . ssh [EOL] import libcloud . security [EOL] [EOL] assert security [comment] [EOL] [EOL] [EOL] class TestSecurity ( TestCase ) : [EOL] def test_connection_no_insecure ( self ) : [EOL] allow_insecure = [ libcloud . common . base . Connection . allow_insecure , libcloud . common . ovh . OvhConnection . allow_insecure , libcloud . compute . drivers . ec2 . EC2Connection . allow_insecure , libcloud . compute . drivers . vultr . VultrConnection . allow_insecure , ] [EOL] for insecure in allow_insecure : [EOL] self . assertFalse ( insecure ) [EOL] [EOL] def test_ssh_deploy_exception ( self ) : [EOL] [docstring] [EOL] driver = libcloud . get_driver ( libcloud . DriverType . COMPUTE , libcloud . DriverType . COMPUTE . DUMMY , ) ( creds = [string] ) [EOL] driver . features [ [string] ] . append ( [string] ) [EOL] [EOL] orig_paramiko = libcloud . compute . ssh . have_paramiko [EOL] libcloud . compute . ssh . have_paramiko = True [EOL] [EOL] deploy = libcloud . compute . deployment . SSHKeyDeployment ( [string] ) [EOL] [EOL] with self . assertRaises ( libcloud . compute . types . DeploymentError ) as ctx : [EOL] driver . deploy_node ( deploy = deploy ) [EOL] [EOL] self . assertEqual ( str ( ctx . exception . value ) , [string] ) [EOL] [EOL] libcloud . compute . ssh . have_paramiko = orig_paramiko [EOL] [EOL] def test_ssh_exception ( self ) : [EOL] self . assertEqual ( len ( security . SSH_CLIENTS ) , [number] ) [EOL] [EOL] for cls in security . SSH_CLIENTS : [EOL] with self . assertRaises ( RuntimeError ) as ctx : [EOL] getattr ( libcloud . compute . ssh , cls ) ( ) [comment] [EOL] self . assertEqual ( str ( ctx . exception ) , [string] ) [EOL] [EOL] def test_ssl_cert ( self ) : [EOL] self . assertTrue ( libcloud . security . VERIFY_SSL_CERT ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import io [EOL] import io [EOL] import tempfile [EOL] from unittest import TestCase [EOL] [EOL] import click [EOL] [EOL] from cloudie import utils [EOL] [EOL] [EOL] class TestReadPublicKey ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . key = tempfile . NamedTemporaryFile ( [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . key . close ( ) [EOL] [EOL] def test_empty_file ( self ) : [EOL] with self . assertRaises ( click . ClickException ) : [EOL] utils . read_public_key ( self . key ) [EOL] [EOL] def test_missing_field ( self ) : [EOL] self . key . write ( [string] ) [EOL] self . key . flush ( ) [EOL] self . key . seek ( [number] ) [EOL] [EOL] with self . assertRaises ( click . ClickException ) : [EOL] utils . read_public_key ( self . key ) [EOL] [EOL] def test_empty_comment ( self ) : [EOL] self . key . write ( [string] ) [EOL] self . key . flush ( ) [EOL] self . key . seek ( [number] ) [EOL] [EOL] with self . assertRaises ( click . ClickException ) : [EOL] utils . read_public_key ( self . key ) [EOL] [EOL] def test_invalid_kind ( self ) : [EOL] self . key . write ( [string] ) [EOL] self . key . flush ( ) [EOL] self . key . seek ( [number] ) [EOL] [EOL] with self . assertRaises ( click . ClickException ) : [EOL] utils . read_public_key ( self . key ) [EOL] [EOL] def test_invalid_data ( self ) : [EOL] self . key . write ( [string] ) [EOL] self . key . flush ( ) [EOL] self . key . seek ( [number] ) [EOL] [EOL] with self . assertRaises ( click . ClickException ) : [EOL] utils . read_public_key ( self . key ) [EOL] [EOL] def test_success ( self ) : [EOL] self . key . write ( [string] ) [EOL] self . key . flush ( ) [EOL] self . key . seek ( [number] ) [EOL] [EOL] kind , key , comment , data = utils . read_public_key ( self . key ) [EOL] self . assertEqual ( kind , [string] ) [EOL] self . assertEqual ( key , [string] ) [EOL] self . assertEqual ( comment , [string] ) [EOL] self . assertEqual ( data , [string] ) [EOL] [EOL] [EOL] class TestSha256 ( TestCase ) : [EOL] def test_success ( self ) : [EOL] f = io . StringIO ( [string] ) [EOL] pos = f . tell ( ) [EOL] self . assertEqual ( utils . sha256 ( f ) , [string] ) [EOL] self . assertEqual ( f . tell ( ) , pos ) [EOL] [EOL] f . write ( [string] ) [EOL] pos = f . tell ( ) [EOL] self . assertEqual ( utils . sha256 ( f ) , [string] ) [EOL] self . assertEqual ( pos , f . tell ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 $builtins.int$ 0 0 0 $io.StringIO$ 0 0 0 0 0 0 $builtins.int$ 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $io.StringIO$ 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import libcloud . common . base [EOL] import libcloud . common . ovh [EOL] import libcloud . compute . ssh [EOL] import libcloud . security [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] CONNECTIONS = [ libcloud . common . base . Connection , libcloud . common . ovh . OvhConnection , ] [EOL] [EOL] for cls in CONNECTIONS : [EOL] assert hasattr ( cls , [string] ) [EOL] setattr ( cls , [string] , False ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class NoSSH : [EOL] def __init__ ( self , * _args , ** _kwargs ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] SSH_CLIENTS = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] for cls in SSH_CLIENTS : [EOL] assert hasattr ( libcloud . compute . ssh , cls ) [EOL] setattr ( libcloud . compute . ssh , cls , NoSSH ) [EOL] [EOL] [comment] [EOL] libcloud . security . VERIFY_SSL_CERT = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import IO , Tuple , Any , MutableMapping , Type [EOL] import typing [EOL] import cloudie [EOL] import builtins [EOL] import os [EOL] import pathlib [EOL] import subprocess [EOL] from typing import IO , Any , MutableMapping , Tuple , Type [EOL] [EOL] import toml [EOL] [EOL] from . import __project__ , utils [EOL] [EOL] [EOL] class ConfigError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class ConfigPermissionError ( ConfigError ) : [EOL] pass [EOL] [EOL] [EOL] class ConfigCommandError ( ConfigError ) : [EOL] pass [EOL] [EOL] [EOL] class ConfigPermission : [EOL] def __init__ ( self , f ) : [EOL] self . _f = f [EOL] self . _cache = pathlib . Path . home ( ) . joinpath ( [string] , __project__ ) [EOL] self . _cache . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] def ask ( self ) : [EOL] [docstring] [EOL] digest = utils . sha256 ( self . _f ) [EOL] cache = self . _cache . joinpath ( os . path . basename ( self . _f . name ) ) [EOL] [EOL] try : [EOL] if cache . read_text ( ) == digest : [EOL] return True [EOL] except OSError : [EOL] pass [EOL] [EOL] msg = [string] [EOL] answer = input ( msg . format ( self . _f . name ) ) [EOL] if answer in ( [string] , [string] ) : [EOL] cache . write_text ( digest ) [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] class ConfigDecoder ( toml . TomlDecoder ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , permission , dict_class , ) : [EOL] super ( ) . __init__ ( dict_class ) [EOL] self . _permission = permission [EOL] [EOL] def load_value ( self , v , strictly_valid = True ) : [EOL] value , vtype = super ( ) . load_value ( v , strictly_valid ) [EOL] if vtype == [string] : [EOL] if value . startswith ( [string] ) and value . endswith ( [string] ) : [EOL] if not self . _permission . ask ( ) : [EOL] msg = [string] [EOL] raise ConfigPermissionError ( msg ) [EOL] [EOL] try : [EOL] args = value [ [number] : - [number] ] . split ( ) [EOL] value = subprocess . check_output ( args ) . decode ( ) . strip ( ) [EOL] except ( OSError , subprocess . SubprocessError ) : [EOL] raise ConfigCommandError ( [string] . format ( value ) ) [EOL] return value , vtype [EOL] [EOL] [EOL] def load ( path , dict_class = dict ) : [EOL] [docstring] [EOL] try : [EOL] with open ( os . path . expanduser ( path ) , [string] ) as f : [EOL] decoder = ConfigDecoder ( ConfigPermission ( f ) , dict_class ) [EOL] return toml . load ( f , decoder = decoder ) [comment] [EOL] except OSError as e : [EOL] raise ConfigError ( [string] . format ( path , e . strerror ) ) [EOL] except toml . TomlDecodeError as e : [EOL] raise ConfigError ( [string] . format ( path , e ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 $typing.IO[builtins.str]$ 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $ConfigPermission$ 0 $typing.Type[typing.MutableMapping]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.MutableMapping]$ 0 0 0 0 $cloudie.config.ConfigPermission$ 0 $ConfigPermission$ 0 0 0 $typing.Tuple$ 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.MutableMapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__project__ = [string] [EOL] __version__ = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import List , Any [EOL] import typing [EOL] import os [EOL] import builtins [EOL] import shutil [EOL] from typing import Any , List [EOL] [EOL] import texttable [EOL] [EOL] [EOL] def show ( columns , rows ) : [EOL] [docstring] [EOL] size = shutil . get_terminal_size ( ) [EOL] table = texttable . Texttable ( max_width = size . columns ) [EOL] table . set_deco ( table . VLINES | table . HEADER ) [EOL] [EOL] table . header ( [ column [ [number] ] for column in columns ] ) [EOL] table . set_cols_dtype ( [ [string] for _ in range ( len ( columns ) ) ] ) [EOL] [EOL] table . add_rows ( [ [ [ next ( ( isinstance ( v , list ) and [string] . join ( str ( elm ) for elm in v ) or v for v in ( _get_value ( row , name ) for name in column [ [number] : ] ) if v ) , [string] ) ] [ [number] ] for column in columns ] for row in rows ] , False ) [EOL] [EOL] print ( table . draw ( ) ) [EOL] [EOL] [EOL] def _get_value ( obj , name , default = None ) : [EOL] [docstring] [EOL] for elem in name . split ( [string] ) : [EOL] if isinstance ( obj , dict ) : [EOL] obj = obj . get ( elem , default ) [EOL] else : [EOL] obj = getattr ( obj , elem , default ) [EOL] [EOL] return obj or default [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Mapping , Dict , Callable , Union , Any , Optional [EOL] import typing [EOL] import inspect [EOL] import click [EOL] import builtins [EOL] import inspect [EOL] from typing import Any , Callable , Optional , Union [EOL] [EOL] import click [EOL] import libcloud [EOL] [EOL] [EOL] class Option ( click . Option ) : [EOL] def get_default ( self , ctx ) : [EOL] [docstring] [EOL] try : [EOL] value = ctx . obj . role [ self . name . replace ( [string] , [string] ) ] [EOL] except ( AttributeError , KeyError ) : [EOL] return super ( ) . get_default ( ctx ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if self . multiple : [EOL] return self . type_cast_value ( ctx , ( str ( x ) for x in value ) ) [EOL] return self . type_cast_value ( ctx , str ( value ) ) [EOL] [EOL] [EOL] def add ( * param_decls , ** attrs ) : [EOL] [docstring] [EOL] return click . option ( * param_decls , ** attrs , cls = Option ) [comment] [EOL] [EOL] [EOL] def pass_driver ( driver_type ) : [EOL] [docstring] [EOL] [EOL] def callback ( ctx , _param , role , ) : [EOL] role = role or ctx . obj . config . get ( [string] , { } ) . get ( [string] ) [EOL] if not role : [EOL] raise click . ClickException ( [string] ) [EOL] [EOL] try : [EOL] ctx . obj . role = ctx . obj . config . role [ role ] [EOL] provider = ctx . obj . role . provider [EOL] key = ctx . obj . role . key [EOL] other = { k : v for k , v in ctx . obj . role . items ( ) if k not in [ [string] , [string] ] } [EOL] except KeyError : [EOL] raise click . ClickException ( [string] . format ( role ) ) [EOL] except AttributeError as e : [EOL] raise click . ClickException ( [string] . format ( e , role ) ) [EOL] [EOL] try : [EOL] driver = libcloud . get_driver ( driver_type , provider ) [EOL] params = inspect . signature ( driver ) . parameters [EOL] kwargs = { k : v for k , v in other . items ( ) if k in params } [EOL] [EOL] [comment] [EOL] if [string] in params : [EOL] kwargs [ [string] ] = True [EOL] [EOL] return driver ( key , ** kwargs ) [EOL] except AttributeError as e : [EOL] raise click . ClickException ( [string] . format ( e ) ) [EOL] [EOL] return add ( [string] , [string] , is_eager = True , callback = callback ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $click.Context$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $click.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.Context$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $click.Context$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Mapping , List , Any , Callable [EOL] import typing [EOL] import munch [EOL] import builtins [EOL] import libcloud [EOL] import inspect [EOL] from . import security [comment] [EOL] [EOL] import base64 [EOL] import inspect [EOL] from typing import Any , Callable [EOL] [EOL] import click [EOL] from libcloud . common . base import BaseDriver [EOL] from libcloud . compute . base import NodeAuthPassword , NodeAuthSSHKey [EOL] from libcloud . compute . providers import Provider [EOL] from munch import DefaultMunch , Munch [EOL] [EOL] from . import option , table , utils [EOL] [EOL] assert security [comment] [EOL] [EOL] [EOL] @ click . group ( ) def compute ( ) : [EOL] pass [EOL] [EOL] [EOL] @ compute . command ( [string] ) @ option . pass_driver ( Provider ) def list_images ( driver ) : [EOL] [docstring] [EOL] table . show ( [ [ [string] , [string] ] , [ [string] , [string] ] , ] , driver . list_images ( ) ) [EOL] [EOL] [EOL] @ compute . command ( [string] ) @ option . pass_driver ( Provider ) def list_key_pairs ( driver ) : [EOL] [docstring] [EOL] table . show ( [ [ [string] , [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] , [string] ] , ] , driver . list_key_pairs ( ) ) [EOL] [EOL] [EOL] @ compute . command ( [string] ) @ option . pass_driver ( Provider ) def list_locations ( driver ) : [EOL] [docstring] [EOL] table . show ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , ] , driver . list_locations ( ) ) [EOL] [EOL] [EOL] @ compute . command ( [string] ) @ option . pass_driver ( Provider ) def list_nodes ( driver ) : [EOL] [docstring] [EOL] table . show ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , ] , driver . list_nodes ( ) ) [EOL] [EOL] [EOL] @ compute . command ( [string] ) @ option . pass_driver ( Provider ) def list_sizes ( driver ) : [EOL] [docstring] [EOL] table . show ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] , [string] ] , ] , driver . list_sizes ( ) ) [EOL] [EOL] [EOL] @ compute . command ( [string] ) @ option . add ( [string] , required = True ) @ option . add ( [string] , required = True , type = click . File ( [string] ) ) @ option . pass_driver ( Provider ) def import_key_pair ( driver , ** kwargs ) : [EOL] [docstring] [EOL] method = driver . import_key_pair_from_string [EOL] [EOL] create_key_pair = inspect . signature ( driver . create_key_pair ) . parameters [EOL] if [string] in create_key_pair : [EOL] method = driver . create_key_pair [EOL] [EOL] * _ , data = utils . read_public_key ( kwargs [ [string] ] ) [EOL] if not method ( kwargs [ [string] ] , data ) : [EOL] raise click . ClickException ( [string] ) [EOL] [EOL] table . show ( [ [ [string] , [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] , [string] ] , ] , driver . list_key_pairs ( ) ) [EOL] [EOL] [EOL] @ compute . command ( [string] ) @ option . add ( [string] , required = True ) @ option . pass_driver ( Provider ) def delete_key_pair ( driver , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] def predicate ( kp ) : [EOL] id_ = getattr ( kp , [string] , None ) or getattr ( kp , [string] , { } ) . get ( [string] , [string] ) [EOL] return str ( id_ ) == kwargs . get ( [string] ) [EOL] [EOL] kp = _get ( driver . list_key_pairs , predicate ) [EOL] try : [EOL] if not driver . delete_key_pair ( kp ) : [EOL] raise click . ClickException ( [string] ) [EOL] except AttributeError as e : [EOL] raise click . ClickException ( [string] . format ( driver . name , e ) ) [EOL] [EOL] table . show ( [ [ [string] , [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] , [string] ] , ] , driver . list_key_pairs ( ) ) [EOL] [EOL] [EOL] @ compute . command ( [string] ) @ option . add ( [string] , required = True ) @ option . pass_driver ( Provider ) def destroy_node ( driver , ** kwargs ) : [EOL] [docstring] [EOL] node = _get ( driver . list_nodes , lambda n : n . id == kwargs [ [string] ] ) [EOL] if not driver . destroy_node ( node ) : [EOL] raise click . ClickException ( [string] ) [EOL] click . echo ( [string] . format ( ** node . __dict__ ) ) [EOL] [EOL] [EOL] @ compute . command ( [string] ) @ option . add ( [string] , required = True ) @ option . add ( [string] , required = True ) @ option . add ( [string] , required = True ) @ option . add ( [string] , required = True ) @ option . add ( [string] , type = click . File ( [string] ) ) @ option . add ( [string] , is_flag = True ) @ option . add ( [string] , type = click . File ( [string] ) ) @ option . add ( [string] , type = int ) @ option . add ( [string] , default = [number] ) @ option . pass_driver ( Provider ) def create_node ( driver , ** kwargs ) : [EOL] [docstring] [EOL] kw = DefaultMunch ( ) [EOL] [EOL] [comment] [EOL] if kwargs . get ( [string] ) and kwargs . get ( [string] ) : [EOL] raise click . ClickException ( [string] ) [EOL] [EOL] [comment] [EOL] kw . name = kwargs . pop ( [string] ) [EOL] [EOL] image = kwargs . pop ( [string] ) [EOL] kw . image = _get ( driver . list_images , lambda i : i . id == image ) [EOL] [EOL] location = kwargs . pop ( [string] ) [EOL] kw . location = _get ( driver . list_locations , lambda l : l . id == location ) [EOL] [EOL] size = kwargs . pop ( [string] ) [EOL] kw . size = _get ( driver . list_sizes , lambda s : s . id == size ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] features = getattr ( driver , [string] , { } ) . get ( [string] , [ ] ) [EOL] [EOL] if [string] in features : [EOL] ssh_key = kwargs . pop ( [string] ) [EOL] if ssh_key : [EOL] kw . auth = NodeAuthSSHKey ( utils . read_public_key ( ssh_key ) [ [number] ] ) [EOL] [EOL] if [string] in features and not kw . auth : [EOL] password = kwargs . pop ( [string] ) [EOL] if password : [EOL] value = click . prompt ( text = [string] , hide_input = True , confirmation_prompt = True , ) [EOL] kw . auth = NodeAuthPassword ( value ) [comment] [EOL] [EOL] [comment] [EOL] func = globals ( ) . get ( [string] . format ( driver . type ) , None ) [EOL] if func : [EOL] kw . update ( func ( driver , kwargs ) ) [EOL] [EOL] [comment] [EOL] wait = kwargs . pop ( [string] ) [EOL] [EOL] [comment] [EOL] args = [ [string] . format ( k . replace ( [string] , [string] ) ) for k , v in kwargs . items ( ) if v ] [EOL] if args : [EOL] raise click . UsageError ( [string] . format ( driver . name , [string] . join ( args ) ) ) [EOL] [EOL] [comment] [EOL] node = driver . create_node ( ** kw ) [EOL] [EOL] click . echo ( [string] ) [EOL] table . show ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , ] , [ n for n , _ in driver . wait_until_running ( [ node ] , timeout = wait ) ] ) [EOL] [EOL] [EOL] def _get ( func , pred , no_error = False ) : [EOL] [docstring] [EOL] value = next ( ( elm for elm in func ( ) if pred ( elm ) ) , None ) [EOL] if value or no_error : [EOL] return value [EOL] name = func . __name__ . replace ( [string] , [string] ) . replace ( [string] , [string] ) . rstrip ( [string] ) [EOL] raise click . ClickException ( [string] . format ( name ) ) [EOL] [EOL] [EOL] def _create_node_digitalocean ( driver , kwargs ) : [EOL] [docstring] [EOL] kw = Munch ( ex_create_attr = Munch ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ssh_key = kwargs . pop ( [string] , None ) [EOL] if ssh_key : [EOL] kind , key , _comment , _data = utils . read_public_key ( ssh_key ) [EOL] kp = _get ( driver . list_key_pairs , lambda k : k . public_key . split ( [string] ) [ : [number] ] == [ kind , key ] ) [EOL] kw . ex_create_attr . ssh_keys = [ kp . fingerprint ] [EOL] [EOL] [comment] [EOL] user_data = kwargs . pop ( [string] , None ) [EOL] if user_data : [EOL] kw . ex_user_data = user_data . read ( ) [EOL] if len ( kw . ex_user_data ) > [number] * [number] : [EOL] raise click . ClickException ( [string] . format ( user_data . name ) ) [EOL] [EOL] return kw [EOL] [EOL] [EOL] def _create_node_vultr ( driver , kwargs ) : [EOL] [docstring] [EOL] kw = Munch ( ex_create_attr = Munch ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] ssh_key = kwargs . pop ( [string] , None ) [EOL] if ssh_key : [EOL] kind , key , _comment , _data = utils . read_public_key ( ssh_key ) [EOL] kp = _get ( driver . list_key_pairs , lambda k : k . pub_key . split ( [string] ) [ : [number] ] == [ kind , key ] ) [EOL] kw . ex_ssh_key_ids = [ kp . id ] [EOL] [EOL] [comment] [EOL] user_data = kwargs . pop ( [string] , None ) [EOL] if user_data : [EOL] content = user_data . read ( ) . encode ( ) [EOL] kw . ex_create_attr . userdata = base64 . b64encode ( content ) . decode ( ) [EOL] [EOL] [comment] [EOL] script_id = kwargs . pop ( [string] , None ) [EOL] if script_id : [EOL] kw . ex_create_attr . script_id = script_id [EOL] [EOL] return kw [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $munch.Munch$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $munch.Munch$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import click [EOL] import builtins [EOL] import click [EOL] import munch [EOL] [EOL] from . import compute , config , group , security [EOL] [EOL] assert security [comment] [EOL] [EOL] [EOL] @ click . group ( cls = group . Group ) @ click . option ( [string] , default = [string] , type = str ) @ click . pass_context def cli ( ctx , config_file ) : [EOL] ctx . obj = munch . Munch ( ) [EOL] [EOL] try : [EOL] ctx . obj . config = config . load ( config_file , munch . Munch ) [EOL] except config . ConfigError as e : [EOL] raise click . ClickException ( str ( e ) ) [EOL] [EOL] [EOL] cli . add_command ( compute . compute ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import click [EOL] from typing import Any [EOL] [EOL] import click [EOL] from libcloud . common . exceptions import BaseHTTPError [EOL] from libcloud . common . types import LibcloudError [EOL] from requests . exceptions import RequestException [EOL] [EOL] [EOL] class Group ( click . Group ) : [EOL] [docstring] [EOL] [EOL] def invoke ( self , ctx ) : [EOL] try : [EOL] return super ( ) . invoke ( ctx ) [EOL] except LibcloudError as e : [EOL] raise click . ClickException ( e . value ) [EOL] except ( BaseHTTPError , NotImplementedError ) as e : [EOL] raise click . ClickException ( str ( e ) ) [EOL] except RequestException : [EOL] raise click . ClickException ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $click.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . cli import cli [EOL] [EOL] if __name__ == [string] : [EOL] cli ( None , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , IO [EOL] import typing [EOL] import builtins [EOL] import base64 [EOL] import hashlib [EOL] from typing import IO , Tuple [EOL] [EOL] import click [EOL] [EOL] [EOL] def read_public_key ( f ) : [EOL] [docstring] [EOL] data = f . read ( ) [EOL] try : [EOL] kind , key , comment = data . split ( [string] ) [EOL] if kind . startswith ( [string] ) and comment : [EOL] base64 . b64decode ( key ) [EOL] return ( kind , key , comment , data ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] raise click . ClickException ( [string] . format ( f . name ) ) [EOL] [EOL] [EOL] def sha256 ( f ) : [EOL] [docstring] [EOL] pos = f . tell ( ) [EOL] f . seek ( [number] ) [EOL] digest = hashlib . sha256 ( f . read ( ) . encode ( ) ) . hexdigest ( ) [EOL] f . seek ( pos ) [EOL] [EOL] return digest [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0