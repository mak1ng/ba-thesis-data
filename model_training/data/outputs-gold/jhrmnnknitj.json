[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Dict , Tuple , Optional , OrderedDict , List , Iterator , Union [EOL] import jupyter_messaging [EOL] import knitj [EOL] import builtins [EOL] import parser [EOL] import typing [EOL] import cell [EOL] import logging [EOL] import collections [EOL] import logging [EOL] from collections import OrderedDict [EOL] [EOL] import ansi2html [EOL] from bs4 import BeautifulSoup [EOL] [EOL] from . parser import Parser [EOL] from . import jupyter_messaging as jupy [EOL] from . jupyter_messaging . content import MIME [EOL] [EOL] from typing import List , Optional , Tuple , Iterator , Dict , Any [EOL] from . cell import BaseCell , Hash , CodeCell [EOL] [EOL] ansi_convert = ansi2html . Ansi2HTMLConverter ( ) . convert [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Document : [EOL] def __init__ ( self , parser ) : [EOL] self . _parser = parser [EOL] self . _frontmatter = None [EOL] self . _cells = OrderedDict ( ) [EOL] [EOL] def items ( self ) : [EOL] yield from self . _cells . items ( ) [EOL] [EOL] def __iter__ ( self ) : [EOL] yield from self . _cells . values ( ) [EOL] [EOL] def __getitem__ ( self , hashid ) : [EOL] return self . _cells [ hashid ] [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _cells ) [EOL] [EOL] @ property def frontmatter ( self ) : [EOL] return self . _frontmatter . copy ( ) if self . _frontmatter is not None else { } [EOL] [EOL] def hashes ( self ) : [EOL] return list ( self . _cells ) [EOL] [EOL] def process_message ( self , msg , hashid ) : [EOL] if not hashid : [EOL] return None [EOL] try : [EOL] cell = self . _cells [ hashid ] [EOL] except KeyError : [EOL] log . warning ( f'{ hashid } [string] ' ) [EOL] return None [EOL] assert isinstance ( cell , CodeCell ) [EOL] if isinstance ( msg , jupy . EXECUTE_RESULT ) : [EOL] log . info ( f'{ hashid } [string] ' ) [EOL] cell . set_output ( msg . content . data ) [EOL] elif isinstance ( msg , jupy . STREAM ) : [EOL] cell . append_stream ( msg . content . text ) [EOL] elif isinstance ( msg , jupy . DISPLAY_DATA ) : [EOL] log . info ( f'{ hashid } [string] ' ) [EOL] cell . set_output ( msg . content . data ) [EOL] elif isinstance ( msg , jupy . EXECUTE_REPLY ) : [EOL] if isinstance ( msg . content , jupy . content . ERROR ) : [EOL] log . info ( f'{ hashid } [string] ' ) [EOL] html = ansi_convert ( [string] . join ( msg . content . traceback ) , full = False ) [EOL] cell . set_error ( html ) [EOL] elif isinstance ( msg . content , jupy . content . OK ) : [EOL] log . info ( f'{ hashid } [string] ' ) [EOL] elif isinstance ( msg , jupy . ERROR ) : [EOL] log . info ( f'{ hashid } [string] ' ) [EOL] html = ansi_convert ( [string] . join ( msg . content . traceback ) , full = False ) [EOL] cell . set_error ( html ) [EOL] elif isinstance ( msg , jupy . STATUS ) : [EOL] if msg . content . execution_state == jupy . content . State . IDLE : [EOL] log . info ( f'{ hashid } [string] ' ) [EOL] cell . set_done ( ) [EOL] elif isinstance ( msg , jupy . EXECUTE_INPUT ) : [EOL] pass [EOL] else : [EOL] raise ValueError ( f' [string] { type ( msg ) }' ) [EOL] return cell [EOL] [EOL] def load_output_from_html ( self , html ) : [EOL] soup = BeautifulSoup ( html , [string] ) [EOL] cells_tag = soup . find ( id = [string] ) [EOL] if not cells_tag : [EOL] return [EOL] n_loaded = [number] [EOL] for cell_tag in cells_tag . find_all ( [string] , class_ = [string] ) : [EOL] hashid = Hash ( cell_tag . attrs [ [string] ] [ [number] ] ) [EOL] if hashid in self . _cells : [EOL] n_loaded += [number] [EOL] cell = self . _cells [ hashid ] [EOL] assert isinstance ( cell , CodeCell ) [EOL] cell . set_output ( { MIME . TEXT_HTML : str ( cell_tag . find ( class_ = [string] ) ) } ) [EOL] if [string] in cell_tag . attrs [ [string] ] : [EOL] cell . set_done ( ) [EOL] if [string] in cell_tag . attrs [ [string] ] : [EOL] cell . flags . add ( [string] ) [EOL] log . info ( f'{ n_loaded } [string] ' ) [EOL] [EOL] def update_from_source ( self , source ) : [EOL] frontmatter , cell_list = self . _parser . parse ( source ) [EOL] if frontmatter is not None : [EOL] self . _frontmatter = frontmatter [EOL] cells = OrderedDict ( ( cell . hashid , cell ) for cell in cell_list ) [EOL] new_cells = [ ] [EOL] cells_with_updated_flags = [ ] [EOL] for hashid , cell in cells . items ( ) : [EOL] if hashid in self . _cells : [EOL] old_cell = self . _cells [ cell . hashid ] [EOL] if isinstance ( old_cell , CodeCell ) : [EOL] assert isinstance ( cell , CodeCell ) [EOL] if old_cell . update_flags ( cell ) : [EOL] cells_with_updated_flags . append ( old_cell ) [EOL] else : [EOL] new_cells . append ( cell ) [EOL] n_dropped = sum ( hashid not in cells for hashid in self . _cells ) [EOL] log . info ( f' [string] { len ( new_cells ) } [string] { len ( self ) } [string] ' f'{ n_dropped } [string] ' ) [EOL] cells = OrderedDict ( ( hashid , self . _cells . get ( hashid , cell ) ) for hashid , cell in cells . items ( ) ) [EOL] self . _cells . clear ( ) [EOL] self . _cells . update ( cells ) [EOL] return new_cells , new_cells + cells_with_updated_flags [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $knitj.parser.Parser$ 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.Dict[cell.Hash,cell.BaseCell]$ 0 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[cell.Hash,cell.BaseCell]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[cell.BaseCell]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cell.BaseCell$ 0 0 0 $cell.Hash$ 0 0 0 0 0 0 0 0 $cell.Hash$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[cell.Hash]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cell.BaseCell]$ 0 0 0 $jupyter_messaging.Message$ 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 $typing.Any$ 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 $typing.Any$ 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[cell.Hash]$ 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jupyter_messaging.Message$ 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.Hash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.Hash$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 $knitj.cell.Hash$ 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Tuple[typing.List[cell.BaseCell],typing.List[cell.BaseCell]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $collections.OrderedDict[knitj.cell.Hash,knitj.cell.BaseCell]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[cell.BaseCell]$ 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[knitj.cell.Hash,knitj.cell.BaseCell]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 0 0 $typing.List[cell.BaseCell]$ 0 0 0 $knitj.cell.BaseCell$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Union[builtins.bool,builtins.int]$ 0 0 0 0 0 0 $collections.OrderedDict[knitj.cell.Hash,knitj.cell.BaseCell]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.bool,builtins.int]$ 0 0 0 0 0 $collections.OrderedDict[knitj.cell.Hash,knitj.cell.BaseCell]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[knitj.cell.Hash,knitj.cell.BaseCell]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[knitj.cell.Hash,knitj.cell.BaseCell]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[cell.BaseCell]$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Dict , Callable [EOL] import builtins [EOL] import aiohttp [EOL] import typing [EOL] import logging [EOL] import logging [EOL] from weakref import WeakSet [EOL] from pkg_resources import resource_filename [EOL] [EOL] from aiohttp import web , WSCloseCode [EOL] [EOL] from typing import Callable , Dict [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] async def on_shutdown ( app ) : [EOL] log . info ( [string] ) [EOL] ws = ... [EOL] for ws in set ( app [ [string] ] ) : [EOL] await ws . close ( code = WSCloseCode . GOING_AWAY , message = [string] ) [EOL] [EOL] [EOL] async def handler ( request ) : [EOL] app = request . app [EOL] if request . path == [string] : [EOL] return web . Response ( text = app [ [string] ] ( ) , content_type = [string] ) [EOL] if request . path == [string] : [EOL] ws = web . WebSocketResponse ( autoclose = False ) [EOL] await ws . prepare ( request ) [EOL] log . info ( f' [string] { id ( ws ) }' ) [EOL] app [ [string] ] . add ( ws ) [EOL] async for msg in ws : [EOL] app [ [string] ] ( msg . json ( ) ) [EOL] log . info ( f' [string] { id ( ws ) }' ) [EOL] app [ [string] ] . remove ( ws ) [EOL] return ws [EOL] raise web . HTTPNotFound ( ) [EOL] [EOL] [EOL] def init_webapp ( get_index , ws_msg_handler ) : [EOL] app = web . Application ( ) [EOL] app [ [string] ] = get_index [EOL] app [ [string] ] = ws_msg_handler [EOL] app [ [string] ] = WeakSet ( ) [EOL] app . router . add_static ( [string] , resource_filename ( [string] , [string] ) , append_version = True ) [EOL] app . router . add_get ( [string] , handler ) [EOL] app . router . add_get ( [string] , handler ) [EOL] app . on_shutdown . append ( on_shutdown ) [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Dict , Tuple , Optional , List , Match [EOL] import builtins [EOL] import typing [EOL] import cell [EOL] import re [EOL] import yaml [EOL] [EOL] from . cell import BaseCell , TextCell , CodeCell , JinjaCell [EOL] [EOL] from typing import List , Tuple , Any , Optional , Dict [EOL] [EOL] [EOL] class ParsingError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Parser : [EOL] def __init__ ( self , fmt ) : [EOL] if fmt == [string] : [EOL] self . _parser = parse_markdown [EOL] elif fmt == [string] : [EOL] self . _parser = parse_python [EOL] else : [EOL] raise ValueError ( f' [string] { fmt }' ) [EOL] [EOL] def parse ( self , text ) : [EOL] frontmatter , cells = self . _parser ( text ) [EOL] if frontmatter is not None : [EOL] return yaml . load ( frontmatter ) , cells [EOL] return None , cells [EOL] [EOL] [EOL] def parse_markdown ( text ) : [EOL] m = re . match ( [string] , text ) [EOL] if m : [EOL] text = text [ m . end ( ) : ] [EOL] frontmatter = m . group ( [number] ) [EOL] else : [EOL] frontmatter = None [EOL] text = text . rstrip ( ) [EOL] cells = [ ] [EOL] buffer = [string] [EOL] while text : [EOL] m = re . search ( [string] , text ) [EOL] assert m [EOL] if m . group ( [number] ) == [string] or not m . group ( [number] ) : [EOL] buffer += text [ : m . start ( ) ] [EOL] buffer = buffer . strip ( ) [EOL] if buffer : [EOL] cells . append ( TextCell ( buffer ) ) [EOL] buffer = [string] [EOL] text = text [ m . end ( ) : ] [EOL] if m . group ( [number] ) == [string] : [EOL] m = re . search ( [string] , text ) [EOL] if not m : [EOL] raise ParsingError ( [string] ) [EOL] code = text [ : m . start ( ) ] . strip ( ) [EOL] cells . append ( CodeCell ( code ) ) [EOL] text = text [ m . end ( ) : ] [EOL] elif m . group ( [number] ) == [string] : [EOL] m = re . search ( [string] , text ) [EOL] if not m : [EOL] raise ParsingError ( [string] ) [EOL] buffer += text [ : m . end ( ) ] [EOL] text = text [ m . end ( ) : ] [EOL] return frontmatter , cells [EOL] [EOL] [EOL] def parse_python ( text ) : [EOL] m = re . match ( [string] , text ) [EOL] if m : [EOL] text = text [ m . end ( ) : ] [EOL] frontmatter = [string] . join ( l [ [number] : ] for l in m . group ( [number] ) . split ( [string] ) [ : - [number] ] ) [EOL] else : [EOL] frontmatter = None [EOL] text = text . rstrip ( ) [EOL] cells = [ ] [EOL] buffer = [string] [EOL] while text : [EOL] m = re . search ( [string] , text ) [EOL] assert m [EOL] buffer += text [ : m . start ( ) ] [EOL] buffer = buffer . strip ( ) [EOL] if buffer : [EOL] buffer = re . sub ( [string] , [string] , buffer ) [EOL] cells . append ( CodeCell ( buffer ) ) [EOL] buffer = [string] [EOL] text = text [ m . end ( ) : ] [EOL] if m . group ( [number] ) : [EOL] m = re . search ( [string] , text ) [EOL] if not m : [EOL] raise ParsingError ( [string] ) [EOL] chunk , text = text [ : m . start ( ) ] , text [ m . start ( ) : ] [EOL] assert chunk [ [number] ] in { [string] , [string] } [EOL] is_jinja = chunk [ [number] ] == [string] [EOL] if is_jinja : [EOL] chunk = chunk [ [number] : ] [EOL] md = re . sub ( [string] , [string] , chunk . strip ( ) ) [EOL] cells . append ( JinjaCell ( md ) if is_jinja else TextCell ( md ) ) [EOL] return frontmatter , cells [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Tuple[typing.Optional[typing.Dict[builtins.str,typing.Any]],typing.List[cell.BaseCell]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Callable , Dict , Optional , Any [EOL] import jupyter_messaging [EOL] import knitj [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import cell [EOL] import asyncio [EOL] import logging [EOL] from pprint import pformat [EOL] import queue [EOL] [EOL] import jupyter_client [EOL] [EOL] from . cell import Hash [EOL] from . import jupyter_messaging as jupy [EOL] from . jupyter_messaging import UUID [EOL] [EOL] from typing import Dict , Callable , Optional [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class Kernel : [EOL] def __init__ ( self , handler , kernel = None , ) : [EOL] self . _handler = handler [EOL] self . _kernel_name = kernel or [string] [EOL] self . _hashids = { } [EOL] self . _msg_queue = asyncio . Queue ( ) [EOL] self . _loop = asyncio . get_event_loop ( ) [EOL] [EOL] def start ( self ) : [EOL] log . info ( [string] ) [EOL] self . _kernel = jupyter_client . KernelManager ( kernel_name = self . _kernel_name ) [EOL] self . _kernel . start_kernel ( ) [EOL] self . _client = self . _kernel . client ( ) [EOL] log . info ( [string] ) [EOL] self . _channels = asyncio . gather ( self . _receiver ( ) , self . _iopub_receiver ( ) , self . _shell_receiver ( ) ) [EOL] [EOL] async def cleanup ( self ) : [EOL] self . _kernel . shutdown_kernel ( ) [EOL] self . _channels . cancel ( ) [EOL] try : [EOL] await self . _channels [EOL] except asyncio . CancelledError : [EOL] pass [EOL] log . info ( [string] ) [EOL] [EOL] def restart ( self ) : [EOL] log . info ( [string] ) [EOL] self . _kernel . restart_kernel ( ) [EOL] [EOL] def interrupt ( self ) : [EOL] log . info ( [string] ) [EOL] self . _kernel . interrupt_kernel ( ) [EOL] [EOL] def execute ( self , hashid , code ) : [EOL] msg_id = UUID ( self . _client . execute ( code ) ) [EOL] self . _hashids [ msg_id ] = hashid [EOL] [EOL] async def _receiver ( self ) : [EOL] while True : [EOL] dct = await self . _msg_queue . get ( ) [EOL] try : [EOL] msg = jupy . parse ( dct ) [EOL] except ( TypeError , ValueError ) : [EOL] log . info ( pformat ( dct ) ) [EOL] raise [EOL] if msg . parent_header : [EOL] hashid = self . _hashids . get ( msg . parent_header . msg_id ) [EOL] else : [EOL] hashid = None [EOL] self . _handler ( msg , hashid ) [EOL] [EOL] async def _iopub_receiver ( self ) : [EOL] def partial ( ) : [EOL] return self . _client . get_iopub_msg ( timeout = [number] ) [EOL] [EOL] while True : [EOL] try : [EOL] dct = await self . _loop . run_in_executor ( None , partial ) [EOL] except queue . Empty : [EOL] continue [EOL] self . _msg_queue . put_nowait ( dct ) [EOL] [EOL] async def _shell_receiver ( self ) : [EOL] def partial ( ) : [EOL] return self . _client . get_shell_msg ( timeout = [number] ) [EOL] [EOL] while True : [EOL] try : [EOL] dct = await self . _loop . run_in_executor ( None , partial ) [EOL] except queue . Empty : [EOL] continue [EOL] self . _msg_queue . put_nowait ( dct ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[jupyter_messaging.UUID,cell.Hash]$ 0 0 0 0 0 0 $'asyncio.Queue[Dict]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $cell.Hash$ 0 $builtins.str$ 0 0 0 $knitj.jupyter_messaging.message.UUID$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $knitj.jupyter_messaging.message.UUID$ 0 0 $cell.Hash$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $knitj.jupyter_messaging.message.BaseMessage$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $knitj.jupyter_messaging.message.BaseMessage$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 $knitj.jupyter_messaging.message.BaseMessage$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $knitj.jupyter_messaging.message.BaseMessage$ 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Dict , Set , Optional , List , Match [EOL] import knitj [EOL] import builtins [EOL] import typing [EOL] import jupyter_messaging [EOL] import re [EOL] import hashlib [EOL] import html [EOL] import asyncio [EOL] from abc import ABC , abstractmethod [EOL] from typing import Dict , Optional , Set [EOL] [EOL] from misaka import Markdown , HtmlRenderer [EOL] import pygments [EOL] from pygments . formatters import HtmlFormatter [EOL] from pygments . lexers import PythonLexer [EOL] [EOL] from . jupyter_messaging . content import MIME [EOL] [EOL] [EOL] _md = Markdown ( HtmlRenderer ( ) , extensions = [string] . split ( ) ) [EOL] [EOL] [EOL] class Hash : [EOL] def __init__ ( self , value ) : [EOL] self . _value = value [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Hash ) : [EOL] return NotImplemented [EOL] return self . _value == other . _value [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . _value ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . _value [ : [number] ] [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { repr ( self . _value ) } [string] ' [EOL] [EOL] @ property def value ( self ) : [EOL] return self . _value [EOL] [EOL] @ classmethod def from_string ( cls , s ) : [EOL] return cls ( hashlib . sha1 ( s . encode ( ) ) . hexdigest ( ) ) [EOL] [EOL] [EOL] class BaseCell ( ABC ) : [EOL] def __init__ ( self , content ) : [EOL] self . _html = None [EOL] self . _hashid = Hash . from_string ( content ) [EOL] [EOL] @ property def hashid ( self ) : [EOL] return self . _hashid [EOL] [EOL] @ property def html ( self ) : [EOL] if self . _html is None : [EOL] self . _html = self . to_html ( ) [EOL] return self . _html [EOL] [EOL] @ abstractmethod def to_html ( self ) : [EOL] ... [EOL] [EOL] [EOL] class TextCell ( BaseCell ) : [EOL] def __init__ ( self , content ) : [EOL] BaseCell . __init__ ( self , [string] + content ) [EOL] self . _content = content [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . hashid !r} [string] { self . _content !r} [string] ' [EOL] [EOL] def to_html ( self ) : [EOL] return f' [string] { self . hashid . value } [string] { _md ( self . _content ) } [string] ' [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , BaseCell ) : [EOL] return NotImplemented [EOL] return type ( self ) is type ( other ) and self . hashid == other . hashid [EOL] [EOL] [EOL] class CodeCell ( BaseCell ) : [EOL] def __init__ ( self , code ) : [EOL] BaseCell . __init__ ( self , [string] + code ) [EOL] m = re . match ( [string] , code ) [EOL] if m : [EOL] try : [EOL] modeline , code = code [ m . end ( ) : ] . split ( [string] , [number] ) [EOL] except ValueError : [EOL] modeline , code = code , [string] [EOL] modeline = re . sub ( [string] , [string] , modeline ) [EOL] self . flags = set ( modeline . split ( ) ) [EOL] else : [EOL] self . flags = set ( ) [EOL] self . _code = code [EOL] self . _output = None [EOL] self . _error = None [EOL] self . _stream = [string] [EOL] self . _done = asyncio . get_event_loop ( ) . create_future ( ) [EOL] self . _flags = set ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( f' [string] { self . __class__ . __name__ } [string] { self . hashid !r} [string] ' f' [string] { self . _code !r} [string] { self . _output !r} [string] ' ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , CodeCell ) : [EOL] return NotImplemented [EOL] return super ( ) . __eq__ ( other ) and self . flags == other . flags [EOL] [EOL] @ property def code ( self ) : [EOL] return self . _code [EOL] [EOL] def update_flags ( self , other ) : [EOL] update = self . flags != other . flags [EOL] if update : [EOL] self . flags = other . flags . copy ( ) [EOL] self . _html = None [EOL] return update [EOL] [EOL] def append_stream ( self , s ) : [EOL] if s [ [number] ] == [string] : [EOL] self . _stream = [string] . join ( self . _stream . split ( [string] ) [ : - [number] ] ) [EOL] s = s [ [number] : ] [EOL] self . _stream += s [EOL] self . _html = None [EOL] [EOL] def set_output ( self , output ) : [EOL] self . _output = output [EOL] self . _html = None [EOL] [EOL] def set_error ( self , error ) : [EOL] self . _error = error [EOL] self . _html = None [EOL] [EOL] def reset ( self ) : [EOL] self . _output = None [EOL] self . _error = None [EOL] self . _stream = [string] [EOL] self . _html = None [EOL] self . _flags . discard ( [string] ) [EOL] self . _done = asyncio . get_event_loop ( ) . create_future ( ) [EOL] [EOL] def set_done ( self ) : [EOL] self . _flags . discard ( [string] ) [EOL] self . _flags . add ( [string] ) [EOL] self . _html = None [EOL] if not self . done ( ) : [EOL] self . _done . set_result ( None ) [EOL] [EOL] def done ( self ) : [EOL] return self . _done . done ( ) [EOL] [EOL] async def wait_for ( self ) : [EOL] await self . _done [EOL] [EOL] def to_html ( self ) : [EOL] code = pygments . highlight ( self . _code , PythonLexer ( ) , HtmlFormatter ( ) ) [EOL] if self . _output is None : [EOL] output = [string] [EOL] elif MIME . IMAGE_SVG_XML in self . _output : [EOL] m = re . search ( [string] , self . _output [ MIME . IMAGE_SVG_XML ] ) [EOL] assert m [EOL] output = self . _output [ MIME . IMAGE_SVG_XML ] [ m . start ( ) : ] [EOL] elif MIME . IMAGE_PNG in self . _output : [EOL] output = ( [string] + self . _output [ MIME . IMAGE_PNG ] + [string] ) [EOL] elif MIME . TEXT_HTML in self . _output : [EOL] output = self . _output [ MIME . TEXT_HTML ] [EOL] elif MIME . TEXT_PLAIN in self . _output : [EOL] output = [string] + html . escape ( self . _output [ MIME . TEXT_PLAIN ] ) + [string] [EOL] else : [EOL] assert False [EOL] if self . _error : [EOL] output = [string] + self . _error + [string] + output [EOL] if self . _stream : [EOL] output = [string] + html . escape ( self . _stream ) + [string] + output [EOL] content = f' [string] { code } [string] { output } [string] ' [EOL] classes = [ self . hashid . value , [string] ] [EOL] classes . extend ( self . flags ) [EOL] classes . extend ( self . _flags ) [EOL] return f' [string] { [string] . join ( classes ) } [string] { content } [string] ' [EOL] [EOL] [EOL] class JinjaCell ( CodeCell ) : [EOL] def __init__ ( self , template ) : [EOL] code = f' [string] { template !r} [string] ' [EOL] CodeCell . __init__ ( self , code ) [EOL] self . _template = template [EOL] [EOL] def append_stream ( self , s ) : [EOL] super ( ) . set_output ( { MIME . TEXT_HTML : _md ( s ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Hash'$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $Hash$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[typing.Dict[jupyter_messaging.content.MIME,builtins.str]]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $'CodeCell'$ 0 0 0 $typing.Any$ 0 0 0 0 0 $'CodeCell'$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $'CodeCell'$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[jupyter_messaging.content.MIME,builtins.str]$ 0 0 0 0 0 $typing.Optional[typing.Dict[knitj.jupyter_messaging.content.content.MIME,builtins.str]]$ 0 $typing.Dict[jupyter_messaging.content.MIME,builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[knitj.jupyter_messaging.content.content.MIME,builtins.str]]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Callable [EOL] import os [EOL] import builtins [EOL] import watchdog [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] import pathlib [EOL] import os [EOL] import logging [EOL] from pathlib import Path [EOL] import asyncio [EOL] from asyncio import Queue [EOL] [EOL] from watchdog . observers import Observer [EOL] from watchdog . events import FileSystemEventHandler , FileSystemEvent [EOL] [EOL] from . cell import Hash [comment] [EOL] [EOL] from typing import Callable [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class FileChangedHandler ( FileSystemEventHandler ) : [EOL] def __init__ ( self , queue ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _loop = asyncio . get_event_loop ( ) [EOL] self . _queue = queue [EOL] [EOL] def _queue_modified ( self , event ) : [EOL] [comment] [EOL] [comment] [EOL] self . _loop . call_soon_threadsafe ( self . _queue . put_nowait , event . src_path ) [EOL] [EOL] def on_modified ( self , event ) : [EOL] self . _queue_modified ( event ) [EOL] [EOL] def on_created ( self , event ) : [EOL] self . _queue_modified ( event ) [EOL] [EOL] [EOL] class SourceWatcher : [EOL] def __init__ ( self , handler , path ) : [EOL] self . _path = Path ( path ) [EOL] self . _handler = handler [EOL] self . _file_change = Queue ( ) [EOL] self . _observer = Observer ( ) [EOL] self . _observer . schedule ( FileChangedHandler ( queue = self . _file_change ) , str ( self . _path . parent ) ) [EOL] [EOL] async def run ( self ) : [EOL] self . _observer . start ( ) [EOL] log . info ( f' [string] { self . _path } [string] ' ) [EOL] while True : [EOL] file = Path ( await self . _file_change . get ( ) ) [EOL] if file == self . _path : [EOL] self . _handler ( file . read_text ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $'Queue[str]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.queues.Queue[builtins.str]$ 0 $'Queue[str]'$ 0 0 0 $None$ 0 0 0 $watchdog.events.FileSystemEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $watchdog.events.FileSystemEvent$ 0 0 0 0 0 0 $None$ 0 0 0 $watchdog.events.FileSystemEvent$ 0 0 0 0 0 0 0 $watchdog.events.FileSystemEvent$ 0 0 0 0 $None$ 0 0 0 $watchdog.events.FileSystemEvent$ 0 0 0 0 0 0 0 $watchdog.events.FileSystemEvent$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[[builtins.str],None]$ 0 $os.PathLike$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $os.PathLike$ 0 0 0 0 $typing.Callable[[builtins.str],None]$ 0 $typing.Callable[[builtins.str],None]$ 0 0 0 $'Queue[str]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Queue[str]'$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0
from . message import ( UUID , BaseMessage as Message , ExecuteRequestMessage as EXECUTE_REQUEST , ExecuteReplyMessage as EXECUTE_REPLY , DisplayDataMessage as DISPLAY_DATA , StreamMessage as STREAM , ExecuteInputMessage as EXECUTE_INPUT , ExecuteResultMessage as EXECUTE_RESULT , ErrorMessage as ERROR , KernelStatusMessage as STATUS , ShutdownReplyMessage as SHUTDOWN_REPLY , parse , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . content import ( MIME , ExecuteReplyOkContent as OK , ExecuteReplyErrorContent as ERROR , ExecuteReplyAbortedContent as ABORTED , ExecutionState as State , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0