[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from codecs import open as codec_open [EOL] from os import path [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] HERE = path . abspath ( path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] def load_file_contents ( file_path , as_list = True ) : [EOL] [docstring] [EOL] abs_file_path = path . join ( HERE , file_path ) [EOL] with codec_open ( abs_file_path , encoding = [string] ) as file_pointer : [EOL] if as_list : [EOL] return file_pointer . read ( ) . splitlines ( ) [EOL] return file_pointer . read ( ) [EOL] [EOL] [EOL] [comment] [EOL] LONG_DESCRIPTION = load_file_contents ( [string] , as_list = False ) [EOL] [comment] [EOL] TESTS_REQUIRE = load_file_contents ( [string] ) [EOL] [EOL] setup ( name = [string] , version = [string] , keywords = [ [string] , [string] , [string] , [string] ] , description = ( [string] [string] ) , long_description = LONG_DESCRIPTION , url = [string] , packages = find_packages ( [string] ) , package_dir = { [string] : [string] } , zip_safe = False , setup_requires = [ [string] ] , extras_require = { [string] : [ [string] , ] , } , test_suite = [string] , tests_require = TESTS_REQUIRE , author = [string] , author_email = [string] , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] from roman_numerals import convert_to_integer [EOL] [EOL] from . parameters import LOWERCASE_PARAMETERS , STANDARD_PARAMETERS [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , LOWERCASE_PARAMETERS + STANDARD_PARAMETERS ) def test_integer_conversion ( roman_numeral , expected_integer , ) : [EOL] [docstring] [EOL] assert convert_to_integer ( roman_numeral ) == expected_integer [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , True , set ( ) , { [string] : [number] } , lambda : print ( [string] ) , ] ) def test_invalid_types ( non_strings ) : [EOL] [docstring] [EOL] with pytest . raises ( TypeError ) : [EOL] convert_to_integer ( non_strings ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) def test_invalid_numerals ( invalid_numerals ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] convert_to_integer ( invalid_numerals ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] from roman_numerals import LOWERCASE , convert_to_numeral [EOL] [EOL] from . parameters import LOWERCASE_PARAMETERS , STANDARD_PARAMETERS [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , STANDARD_PARAMETERS ) def test_standard_numeral_conversion ( decimal_integer , expected_numeral , ) : [EOL] [docstring] [EOL] assert convert_to_numeral ( decimal_integer ) == expected_numeral [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , LOWERCASE_PARAMETERS ) def test_lowercase_numeral_conversion ( decimal_integer , expected_numeral , ) : [EOL] [docstring] [EOL] assert ( convert_to_numeral ( decimal_integer , mode = LOWERCASE ) == expected_numeral ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [number] , True , set ( ) , { [string] : [number] } , ] ) def test_invalid_types ( non_integer_values ) : [EOL] [docstring] [EOL] with pytest . raises ( TypeError ) : [EOL] convert_to_numeral ( non_integer_values ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , True , False , [number] , - [number] , [number] , set ( [ [number] , [number] , [number] ] ) , { [string] : [string] } , ] ) def test_invalid_mode_values ( invalid_mode_values ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] convert_to_numeral ( [number] , mode = invalid_mode_values ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Pattern , Match , Any , Tuple , Dict , Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from re import ( VERBOSE , compile as re_compile , fullmatch , match , sub as substitute , ) [EOL] [EOL] [comment] [EOL] STANDARD = [number] [EOL] LOWERCASE = [number] [EOL] [EOL] ROMAN_NUMERAL_TABLE = [ ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ] [EOL] [EOL] SHORTENINGS = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] STANDARD_TRANS = [string] [EOL] LOWERCASE_TRANS = [string] [EOL] [EOL] [EOL] def convert_to_numeral ( decimal_integer , mode = STANDARD ) : [EOL] [docstring] [EOL] if ( not isinstance ( decimal_integer , int ) or isinstance ( decimal_integer , bool ) ) : [EOL] raise TypeError ( [string] ) [EOL] if ( not isinstance ( mode , int ) or isinstance ( mode , bool ) or mode not in [ LOWERCASE , STANDARD ] ) : [EOL] raise ValueError ( [string] [string] [string] ) [EOL] return_list = [ ] [EOL] remainder = decimal_integer [EOL] for integer , numeral in ROMAN_NUMERAL_TABLE : [EOL] repetitions , remainder = divmod ( remainder , integer ) [EOL] return_list . append ( numeral * repetitions ) [EOL] numeral_string = [string] . join ( return_list ) [EOL] [EOL] for full_string , shortening in SHORTENINGS : [EOL] numeral_string = substitute ( [string] % full_string , shortening , numeral_string , ) [EOL] [EOL] if mode == LOWERCASE : [EOL] trans_to_lowercase = str . maketrans ( STANDARD_TRANS , LOWERCASE_TRANS ) [EOL] numeral_string = numeral_string . translate ( trans_to_lowercase ) [EOL] return numeral_string [EOL] [EOL] [EOL] NUMERAL_PATTERN = re_compile ( [string] , VERBOSE ) [EOL] [EOL] [EOL] def convert_to_integer ( roman_numeral ) : [EOL] [docstring] [EOL] if not isinstance ( roman_numeral , str ) : [EOL] raise TypeError ( [string] ) [EOL] if roman_numeral == [string] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [comment] [EOL] trans_to_uppercase = str . maketrans ( LOWERCASE_TRANS , STANDARD_TRANS ) [EOL] [comment] [EOL] partial_numeral = roman_numeral . translate ( trans_to_uppercase ) [EOL] [EOL] [comment] [EOL] for full_string , shortening in SHORTENINGS : [EOL] partial_numeral = substitute ( [string] % shortening , full_string , partial_numeral , ) [EOL] [EOL] if not fullmatch ( NUMERAL_PATTERN , partial_numeral ) : [EOL] raise ValueError ( [string] % roman_numeral ) [EOL] [EOL] [comment] [EOL] return_value = [number] [EOL] for integer , numeral in ROMAN_NUMERAL_TABLE : [EOL] pattern_match = match ( [string] % numeral , partial_numeral ) [EOL] if pattern_match : [EOL] chars_matched = len ( pattern_match . group ( ) ) [EOL] numerals_matched = chars_matched // len ( numeral ) [EOL] return_value += numerals_matched * integer [EOL] partial_numeral = partial_numeral [ chars_matched : ] [EOL] return return_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0