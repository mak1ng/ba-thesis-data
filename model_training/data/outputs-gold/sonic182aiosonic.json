from typing import Any , Pattern [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] from setuptools import setup [EOL] [EOL] [EOL] RGX = re . compile ( [string] ) [EOL] [EOL] [EOL] def read_file ( filename ) : [EOL] [docstring] [EOL] with open ( filename ) as _file : [EOL] return _file . read ( ) . strip ( ) [EOL] [EOL] [EOL] def requirements ( filename ) : [EOL] [docstring] [EOL] return re . findall ( RGX , read_file ( filename ) ) or [ ] [EOL] [EOL] [EOL] def version ( ) : [EOL] data = read_file ( [string] ) [EOL] return re . findall ( [string] , data ) [ [number] ] [EOL] [EOL] [EOL] [comment] [EOL] env_marker = ( [string] [string] [string] ) [EOL] [EOL] [EOL] def add_marks ( dependencies , marks ) : [EOL] [docstring] [EOL] def _map_func ( dependency ) : [EOL] for item , marker in marks . items ( ) : [EOL] if item in dependency : [EOL] return dependency + marker [EOL] return dependency [EOL] [EOL] return list ( map ( _map_func , dependencies ) ) [EOL] [EOL] [EOL] setup ( name = [string] , version = version ( ) , description = [string] , author = [string] , author_email = [string] , long_description = read_file ( [string] ) , long_description_content_type = [string] , license = [string] , packages = [ [string] , [string] , ] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , ] , setup_requires = [ [string] ] , install_requires = requirements ( [string] ) , extras_require = { [string] : add_marks ( requirements ( [string] ) , { [string] : [string] + env_marker , [string] : [string] + env_marker , } ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
[EOL] from typing import Dict , Any [EOL] import aiosonic_utils [EOL] import typing [EOL] from collections . abc import MutableMapping [EOL] from collections . abc import Mapping [EOL] [EOL] [EOL] [comment] [EOL] class CaseInsensitiveDict ( MutableMapping ) : [EOL] [docstring] [EOL] def __init__ ( self , data = None , ** kwargs ) : [EOL] self . _store = dict ( ) [EOL] if data is None : [EOL] data = { } [EOL] self . update ( data , ** kwargs ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] [comment] [EOL] [comment] [EOL] self . _store [ key . lower ( ) ] = ( key , value ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return self . _store [ key . lower ( ) ] [ [number] ] [EOL] [EOL] def __delitem__ ( self , key ) : [EOL] del self . _store [ key . lower ( ) ] [EOL] [EOL] def __iter__ ( self ) : [EOL] return ( casedkey for casedkey , mappedvalue in self . _store . values ( ) ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _store ) [EOL] [EOL] def lower_items ( self ) : [EOL] [docstring] [EOL] return ( ( lowerkey , keyval [ [number] ] ) for ( lowerkey , keyval ) in self . _store . items ( ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , Mapping ) : [EOL] other = CaseInsensitiveDict ( other ) [EOL] else : [EOL] return NotImplemented [EOL] [comment] [EOL] return dict ( self . lower_items ( ) ) == dict ( other . lower_items ( ) ) [EOL] [EOL] [comment] [EOL] def copy ( self ) : [EOL] return CaseInsensitiveDict ( self . _store . values ( ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , dict ( self . items ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiosonic_utils.structures.CaseInsensitiveDict$ 0 0 0 0 0 0 $aiosonic_utils.structures.CaseInsensitiveDict$ 0 0 0 0 0 $aiosonic_utils.structures.CaseInsensitiveDict$ 0 0 0 $aiosonic_utils.structures.CaseInsensitiveDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiosonic_utils.structures.CaseInsensitiveDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Awaitable , Dict , Any , Optional [EOL] import asyncio [EOL] import aiosonic [EOL] import builtins [EOL] import typing [EOL] import asyncio [EOL] from typing import Optional [EOL] [EOL] import h2 . events [EOL] [EOL] from typing import Dict [EOL] from typing import Awaitable [EOL] [EOL] from aiosonic . exceptions import MissingEvent [EOL] from aiosonic . types import ParamsType [EOL] from aiosonic . types import ParsedBodyType [EOL] [EOL] [EOL] class Http2Handler ( object ) : [EOL] def __init__ ( self , connection ) : [EOL] [docstring] [EOL] self . connection = connection [EOL] h2conn = connection . h2conn [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] h2conn . initiate_connection ( ) [EOL] self . writer_q = asyncio . Queue ( ) [EOL] [EOL] self . requests = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . writer . write ( h2conn . data_to_send ( ) ) [EOL] self . reader_task = loop . create_task ( self . reader_t ( ) ) [EOL] self . writer_task = loop . create_task ( self . writer_t ( ) ) [EOL] [EOL] @ property def writer ( self ) : [EOL] return self . connection . writer [EOL] [EOL] @ property def reader ( self ) : [EOL] return self . connection . reader [EOL] [EOL] @ property def h2conn ( self ) : [EOL] return self . connection . h2conn [EOL] [EOL] def cleanup ( self ) : [EOL] [docstring] [EOL] self . reader_task . cancel ( ) [EOL] self . writer_task . cancel ( ) [EOL] [EOL] async def request ( self , headers , body ) : [EOL] stream_id = self . h2conn . get_next_available_stream_id ( ) [EOL] self . h2conn . send_headers ( stream_id , headers . items ( ) , end_stream = True ) [EOL] from aiosonic import HttpResponse [EOL] future = asyncio . Future ( ) [EOL] self . requests [ stream_id ] = { [string] : [string] , [string] : None , [string] : future } [EOL] await self . writer_q . put ( True ) [EOL] await future [EOL] res = self . requests [ stream_id ] . copy ( ) [EOL] del self . requests [ stream_id ] [EOL] [EOL] response = HttpResponse ( ) [EOL] for key , val in res [ [string] ] : [EOL] if key == [string] : [EOL] response . response_initial = { [string] : [string] , [string] : val } [EOL] else : [EOL] response . _set_header ( key , val ) [EOL] [EOL] if res [ [string] ] : [EOL] response . _set_body ( res [ [string] ] ) [EOL] [EOL] return response [EOL] [EOL] async def reader_t ( self ) : [EOL] [docstring] [EOL] read_size = [number] [EOL] [EOL] while True : [EOL] data = await asyncio . wait_for ( self . reader . read ( read_size ) , [number] ) [EOL] events = self . h2conn . receive_data ( data ) [EOL] [EOL] if events : [EOL] self . handle_events ( events ) [EOL] [EOL] await self . writer_q . put ( True ) [EOL] [EOL] def handle_events ( self , events ) : [EOL] [docstring] [EOL] h2conn = self . h2conn [EOL] [EOL] for event in events : [EOL] if isinstance ( event , h2 . events . StreamEnded ) : [EOL] self . requests [ event . stream_id ] [ [string] ] . set_result ( self . requests [ event . stream_id ] [ [string] ] ) [EOL] elif isinstance ( event , h2 . events . DataReceived ) : [EOL] self . requests [ event . stream_id ] [ [string] ] += event . data [EOL] [EOL] if ( event . stream_id in h2conn . streams [EOL] and not h2conn . streams [ event . stream_id ] . closed ) : [EOL] h2conn . increment_flow_control_window ( event . flow_controlled_length , event . stream_id ) [EOL] h2conn . increment_flow_control_window ( event . flow_controlled_length ) [EOL] elif isinstance ( event , h2 . events . ResponseReceived ) : [EOL] self . requests [ event . stream_id ] [ [string] ] = event . headers [EOL] elif isinstance ( event , ( h2 . events . WindowUpdated , h2 . events . PingReceived , h2 . events . RemoteSettingsChanged , h2 . events . SettingsAcknowledged ) ) : [EOL] pass [EOL] else : [EOL] raise MissingEvent ( f' [string] { event . __class__ . __name__ }' ) [EOL] [EOL] async def writer_t ( self ) : [EOL] [docstring] [EOL] h2conn = self . h2conn [EOL] [EOL] while True : [EOL] await self . writer_q . get ( ) [EOL] while True : [EOL] data_to_send = h2conn . data_to_send ( ) [EOL] [EOL] if data_to_send : [EOL] self . writer . write ( data_to_send ) [EOL] else : [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Optional[aiosonic.types.ParsedBodyType]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[builtins.bytes]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $aiosonic.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $aiosonic.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiosonic.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $aiosonic.HttpResponse$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $aiosonic.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def cache_decorator ( size = [number] ) : [EOL] [docstring] [EOL] _cache = { } [EOL] [EOL] def decorator ( func ) : [EOL] def _wrapper ( key ) : [EOL] if key in _cache : [EOL] return _cache [ key ] [EOL] [EOL] _cache [ key ] = res = func ( key ) [EOL] [EOL] if len ( _cache ) > size : [EOL] _cache . pop ( next ( iter ( _cache ) ) ) [EOL] return res [EOL] [EOL] _wrapper . cache = _cache [EOL] return _wrapper [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import urllib [EOL] import asyncio [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] from urllib . parse import ParseResult [EOL] [EOL] [EOL] class CyclicQueuePool : [EOL] [docstring] [EOL] def __init__ ( self , connector , pool_size , connection_cls ) : [EOL] self . pool_size = pool_size [EOL] self . pool = asyncio . Queue ( pool_size ) [EOL] [EOL] for _ in range ( pool_size ) : [EOL] self . pool . put_nowait ( connection_cls ( connector ) ) [EOL] [EOL] async def acquire ( self , _urlparsed = None ) : [EOL] [docstring] [EOL] return await self . pool . get ( ) [EOL] [EOL] async def release ( self , conn ) : [EOL] [docstring] [EOL] return self . pool . put_nowait ( conn ) [EOL] [EOL] def is_all_free ( self ) : [EOL] [docstring] [EOL] return self . pool_size == self . pool . qsize ( ) [EOL] [EOL] [EOL] class SmartPool : [EOL] [docstring] [EOL] def __init__ ( self , connector , pool_size , connection_cls ) : [EOL] self . pool_size = pool_size [EOL] self . pool = set ( ) [EOL] self . sem = asyncio . Semaphore ( pool_size ) [EOL] [EOL] for _ in range ( pool_size ) : [EOL] self . pool . add ( connection_cls ( connector ) ) [EOL] [EOL] async def acquire ( self , urlparsed = None ) : [EOL] [docstring] [EOL] await self . sem . acquire ( ) [EOL] if urlparsed : [EOL] key = [string] % ( urlparsed . hostname , urlparsed . port ) [EOL] for item in self . pool : [EOL] if item . key == key : [EOL] self . pool . remove ( item ) [EOL] return item [EOL] return self . pool . pop ( ) [EOL] [EOL] def release ( self , conn ) : [EOL] [docstring] [EOL] self . pool . add ( conn ) [EOL] self . sem . release ( ) [EOL] [EOL] def is_all_free ( self ) : [EOL] [docstring] [EOL] return self . pool_size == self . sem . _value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.locks.Semaphore$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 $builtins.str$ 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
VERSION = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] [EOL] class Timeouts ( ) : [EOL] [docstring] [EOL] def __init__ ( self , sock_connect = [number] , sock_read = [number] , pool_acquire = None , request_timeout = [number] ) : [EOL] [docstring] [EOL] self . sock_connect = sock_connect [EOL] self . sock_read = sock_read [EOL] self . pool_acquire = pool_acquire [EOL] self . request_timeout = request_timeout [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0
from typing import Any [EOL] import urllib [EOL] import aiosonic [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] from asyncio import StreamReader [EOL] from asyncio import StreamWriter [EOL] import ssl [EOL] from typing import Coroutine [EOL] from typing import Optional [EOL] from ssl import SSLContext [EOL] from urllib . parse import ParseResult [EOL] [EOL] import h2 . connection [EOL] from hyperframe . frame import SettingsFrame [EOL] [EOL] from concurrent import futures [EOL] from aiosonic . exceptions import ConnectTimeout [EOL] from aiosonic . exceptions import ConnectionPoolAcquireTimeout [EOL] from aiosonic . exceptions import TimeoutException [EOL] from aiosonic . pools import SmartPool [EOL] from aiosonic . timeout import Timeouts [EOL] [EOL] [EOL] class TCPConnector : [EOL] def __init__ ( self , pool_size = [number] , timeouts = None , connection_cls = None , pool_cls = None ) : [EOL] [docstring] [EOL] from aiosonic . connection import Connection [comment] [EOL] self . pool_size = pool_size [EOL] connection_cls = connection_cls or Connection [EOL] pool_cls = pool_cls or SmartPool [EOL] self . pool = pool_cls ( self , pool_size , connection_cls ) [EOL] self . timeouts = timeouts or Timeouts ( ) [EOL] [EOL] async def acquire ( self , urlparsed ) : [EOL] [docstring] [EOL] [comment] [EOL] if not self . timeouts . pool_acquire : [EOL] return await self . pool . acquire ( urlparsed ) [EOL] [EOL] try : [EOL] return await asyncio . wait_for ( self . pool . acquire ( urlparsed ) , self . timeouts . pool_acquire ) [EOL] except TimeoutException : [EOL] raise ConnectionPoolAcquireTimeout ( ) [EOL] [EOL] async def release ( self , conn ) : [EOL] [docstring] [EOL] res = self . pool . release ( conn ) [EOL] if isinstance ( res , Coroutine ) : [EOL] await res [EOL] [EOL] async def wait_free_pool ( self ) : [EOL] [docstring] [EOL] while True : [EOL] if self . pool . is_all_free ( ) : [EOL] return True [EOL] asyncio . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Union [EOL] from typing import Dict [EOL] from typing import Sequence [EOL] from typing import Tuple [EOL] from typing import AsyncIterator [EOL] from typing import Iterator [EOL] [EOL] [comment] [EOL] ParamsType = Union [ Dict [ str , str ] , Sequence [ Tuple [ str , str ] ] , ] [EOL] [comment] [EOL] DataType = Union [ str , bytes , dict , tuple , AsyncIterator [ bytes ] , Iterator [ bytes ] , ] [EOL] BodyType = Union [ str , bytes , AsyncIterator [ bytes ] , Iterator [ bytes ] , ] [EOL] ParsedBodyType = Union [ bytes , AsyncIterator [ bytes ] , Iterator [ bytes ] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , List [EOL] import typing [EOL] from aiosonic . version import VERSION [EOL] [EOL] [EOL] [comment] [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] release = VERSION [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import aiosonic [EOL] import datetime [EOL] import asyncio [EOL] import requests [EOL] import multiprocessing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] from concurrent import futures [EOL] from datetime import datetime [EOL] from datetime import timedelta [EOL] import json [EOL] import random [EOL] from time import sleep [EOL] [EOL] from urllib . request import urlopen [EOL] from urllib . error import URLError [EOL] [EOL] from multiprocessing import Process [EOL] [EOL] from uvicorn . main import Server [EOL] from uvicorn . main import Config [EOL] [EOL] import aiohttp [EOL] import httpx [EOL] import requests [EOL] [EOL] import aiosonic [EOL] from aiosonic . connectors import TCPConnector [EOL] from aiosonic . pools import CyclicQueuePool [EOL] [EOL] try : [EOL] import uvloop [EOL] uvloop . install ( ) [EOL] except Exception : [EOL] pass [EOL] [EOL] [EOL] async def app ( scope , receive , send ) : [EOL] assert scope [ [string] ] == [string] [EOL] res = [string] [EOL] await send ( { [string] : [string] , [string] : [number] , [string] : [ [ [string] , [string] ] , [ [string] , [string] % len ( res ) ] , ] } ) [EOL] await send ( { [string] : [string] , [string] : res , } ) [EOL] [EOL] [EOL] async def start_dummy_server ( loop , port ) : [EOL] [docstring] [EOL] host = [string] [EOL] [EOL] config = Config ( app , host = host , port = port , workers = [number] , log_level = [string] ) [EOL] server = Server ( config = config ) [EOL] [EOL] await server . serve ( ) [EOL] [EOL] [EOL] async def timeit_coro ( func , * args , ** kwargs ) : [EOL] [docstring] [EOL] repeat = kwargs . pop ( [string] , [number] ) [EOL] before = datetime . now ( ) [EOL] [comment] [EOL] await asyncio . gather ( * [ func ( * args , ** kwargs ) for _ in range ( repeat ) ] ) [EOL] after = datetime . now ( ) [EOL] return ( after - before ) / timedelta ( milliseconds = [number] ) [EOL] [EOL] [EOL] async def performance_aiohttp ( url , concurrency ) : [EOL] [docstring] [EOL] async with aiohttp . ClientSession ( connector = aiohttp . TCPConnector ( limit = concurrency ) ) as session : [EOL] return await timeit_coro ( session . get , (url) ) [EOL] [EOL] [EOL] async def performance_aiosonic ( url , concurrency , pool_cls = None , timeouts = None ) : [EOL] [docstring] [EOL] client = aiosonic . HTTPClient ( TCPConnector ( pool_size = concurrency , pool_cls = pool_cls ) ) [EOL] return await timeit_coro ( client . get , url , timeouts = timeouts ) [EOL] [EOL] [EOL] async def performance_httpx ( url , concurrency , pool_cls = None ) : [EOL] [docstring] [EOL] async with httpx . AsyncClient ( ) as client : [EOL] return await timeit_coro ( client . get , url ) [EOL] [EOL] [EOL] def timeit_requests ( url , concurrency , repeat = [number] ) : [EOL] [docstring] [EOL] session = requests . Session ( ) [EOL] adapter = requests . adapters . HTTPAdapter ( pool_connections = concurrency , pool_maxsize = concurrency ) [EOL] session . mount ( [string] , adapter ) [EOL] with futures . ThreadPoolExecutor ( concurrency ) as executor : [EOL] to_wait = [ ] [EOL] before = datetime . now ( ) [EOL] for _ in range ( repeat ) : [EOL] to_wait . append ( executor . submit ( session . get , url ) ) [EOL] for fut in to_wait : [EOL] fut . result ( ) [EOL] after = datetime . now ( ) [EOL] return ( after - before ) / timedelta ( milliseconds = [number] ) [EOL] [EOL] [EOL] def do_tests ( url ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] concurrency = [number] [EOL] loop = asyncio . get_event_loop ( ) [EOL] [EOL] [comment] [EOL] res1 = loop . run_until_complete ( performance_aiohttp ( url , concurrency ) ) [EOL] [EOL] [comment] [EOL] res2 = loop . run_until_complete ( performance_aiosonic ( url , concurrency ) ) [EOL] [EOL] [comment] [EOL] res3 = timeit_requests ( url , concurrency ) [EOL] [EOL] [comment] [EOL] res4 = loop . run_until_complete ( performance_aiosonic ( url , concurrency , pool_cls = CyclicQueuePool ) ) [EOL] [EOL] [comment] [EOL] httpx_exc = False [EOL] res5 = None [EOL] try : [EOL] res5 = loop . run_until_complete ( performance_httpx ( url , concurrency ) ) [EOL] except Exception as exc : [EOL] httpx_exc = exc [EOL] print ( [string] + str ( exc ) ) [EOL] [EOL] to_print = { [string] : [string] % res2 , [string] : [string] % res4 , [string] : [string] % res1 , [string] : [string] % res3 , } [EOL] [EOL] if not httpx_exc : [EOL] to_print . update ( { [string] : [string] % res5 } ) [EOL] [EOL] print ( json . dumps ( to_print , indent = True ) ) [EOL] [EOL] print ( [string] % ( ( ( res1 / res2 ) - [number] ) * [number] ) ) [EOL] print ( [string] % ( ( ( res3 / res2 ) - [number] ) * [number] ) ) [EOL] print ( [string] % ( ( ( res4 / res2 ) - [number] ) * [number] ) ) [EOL] [EOL] res = [ [ [string] , res1 ] , [ [string] , res2 ] , [ [string] , res3 ] , [ [string] , res4 ] , ] [EOL] [EOL] if not httpx_exc : [EOL] print ( [string] % ( ( ( res5 / res2 ) - [number] ) * [number] ) ) [EOL] res . append ( [ [string] , res5 ] ) [EOL] [EOL] return res [EOL] [EOL] [EOL] def start_server ( port ) : [EOL] [docstring] [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( start_dummy_server ( loop , port ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] port = random . randint ( [number] , [number] ) [EOL] url = [string] % port [EOL] process = Process ( target = start_server , args = ( port , ) ) [EOL] process . start ( ) [EOL] [EOL] max_wait = datetime . now ( ) + timedelta ( seconds = [number] ) [EOL] while True : [EOL] try : [EOL] with urlopen ( url ) as response : [EOL] response . read ( ) [EOL] break [EOL] except URLError : [EOL] sleep ( [number] ) [EOL] if datetime . now ( ) > max_wait : [EOL] raise [EOL] try : [EOL] res = do_tests ( url ) [EOL] assert [string] in sorted ( res , key = lambda x : x [ [number] ] ) [ [number] ] [ [number] ] [EOL] finally : [EOL] process . terminate ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] def test_the_truth ( ) : [EOL] [docstring] [EOL] assert True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import datetime [EOL] import aiohttp [EOL] import multiprocessing [EOL] import ssl [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] from datetime import datetime [EOL] from datetime import timedelta [EOL] import gzip [EOL] import multiprocessing as mp [EOL] import os [EOL] import random [EOL] import ssl [EOL] from time import sleep [EOL] from urllib . request import urlopen [EOL] from urllib . error import URLError [EOL] import zlib [EOL] [EOL] import aiohttp [EOL] from aiohttp import web [EOL] import pytest [EOL] [EOL] [EOL] async def hello ( request ) : [EOL] [docstring] [EOL] if [string] in request . query : [EOL] return web . Response ( text = request . query [ [string] ] ) [EOL] return web . Response ( text = [string] ) [EOL] [EOL] [EOL] async def hello_gzip ( request ) : [EOL] [docstring] [EOL] headers = { [string] : [string] } [EOL] return web . Response ( body = gzip . compress ( [string] ) , headers = headers ) [EOL] [EOL] [EOL] async def hello_deflate ( request ) : [EOL] [docstring] [EOL] headers = { [string] : [string] } [EOL] return web . Response ( body = zlib . compress ( [string] ) , headers = headers ) [EOL] [EOL] [EOL] async def hello_post ( request ) : [EOL] [docstring] [EOL] post = await request . post ( ) [EOL] if post and [string] in post : [EOL] return web . Response ( text = post [ [string] ] ) [EOL] [EOL] [comment] [EOL] data = await request . text ( ) [EOL] [EOL] if data and [string] in data : [EOL] res = web . Response ( text = data ) [EOL] res . force_close ( ) [EOL] return res [EOL] elif data : [EOL] return web . Response ( text = data ) [EOL] return web . Response ( text = [string] ) [EOL] [EOL] [EOL] async def hello_post_json ( request ) : [EOL] [docstring] [EOL] data = await request . json ( ) [EOL] if data and [string] in data : [EOL] return web . Response ( text = data [ [string] ] ) [EOL] return web . Response ( text = [string] ) [EOL] [EOL] [EOL] async def delete_handler ( request ) : [EOL] [docstring] [EOL] return web . Response ( text = [string] ) [EOL] [EOL] [EOL] async def put_patch_handler ( request ) : [EOL] [docstring] [EOL] return web . Response ( text = [string] ) [EOL] [EOL] [EOL] async def chunked_response ( request ) : [EOL] [docstring] [EOL] response = web . StreamResponse ( status = [number] , reason = [string] , headers = { [string] : [string] } , ) [EOL] [comment] [EOL] await response . prepare ( request ) [EOL] await response . write ( [string] ) [EOL] await response . write ( [string] ) [EOL] [EOL] await response . write_eof ( ) [EOL] return response [EOL] [EOL] [EOL] async def do_redirect ( request ) : [EOL] [docstring] [EOL] raise web . HTTPFound ( [string] ) [EOL] [EOL] [EOL] async def do_redirect_full_url ( request ) : [EOL] [docstring] [EOL] url = [string] . format ( request . scheme , request . host ) [EOL] raise web . HTTPFound ( url ) [EOL] [EOL] [EOL] async def max_redirects ( request ) : [EOL] [docstring] [EOL] raise web . HTTPFound ( [string] ) [EOL] [EOL] [EOL] async def slow_request ( request ) : [EOL] [docstring] [EOL] await asyncio . sleep ( [number] ) [EOL] return web . Response ( text = [string] ) [EOL] [EOL] [EOL] def get_app ( ) : [EOL] [docstring] [EOL] application = web . Application ( ) [EOL] application . router . add_get ( [string] , hello ) [EOL] application . router . add_get ( [string] , do_redirect ) [EOL] application . router . add_get ( [string] , do_redirect_full_url ) [EOL] application . router . add_get ( [string] , max_redirects ) [EOL] application . router . add_get ( [string] , hello_gzip ) [EOL] application . router . add_get ( [string] , hello_deflate ) [EOL] application . router . add_get ( [string] , chunked_response ) [EOL] application . router . add_get ( [string] , slow_request ) [EOL] application . router . add_post ( [string] , hello_post ) [EOL] application . router . add_post ( [string] , hello_post_json ) [EOL] application . router . add_put ( [string] , put_patch_handler ) [EOL] application . router . add_patch ( [string] , put_patch_handler ) [EOL] application . router . add_delete ( [string] , delete_handler ) [EOL] return application [EOL] [EOL] [EOL] @ pytest . fixture def app ( ) : [EOL] [docstring] [EOL] return get_app ( ) [EOL] [EOL] [EOL] @ pytest . fixture def ssl_context ( ) : [EOL] [comment] [EOL] context = ssl . SSLContext ( getattr ( ssl , [string] , ssl . PROTOCOL_TLS ) ) [EOL] context . load_cert_chain ( [string] , [string] ) [EOL] return context [EOL] [EOL] [EOL] def node_http2 ( port ) : [EOL] os . system ( f' [string] { port }' ) [EOL] [EOL] [EOL] @ pytest . fixture def http2_serv ( ) : [EOL] [docstring] [EOL] port = random . randint ( [number] , [number] ) [EOL] p = mp . Process ( target = node_http2 , args = ( port , ) ) [EOL] p . start ( ) [EOL] url = f' [string] { port } [string] ' [EOL] [EOL] [comment] [EOL] context = ssl . _create_unverified_context ( ) [EOL] [EOL] max_wait = datetime . now ( ) + timedelta ( seconds = [number] ) [EOL] while True : [EOL] try : [EOL] with urlopen ( url , context = context ) as response : [EOL] response . read ( ) [EOL] break [EOL] except URLError : [EOL] sleep ( [number] ) [EOL] if datetime . now ( ) > max_wait : [EOL] raise [EOL] yield url [EOL] p . terminate ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Type [EOL] import djangotestproj [EOL] import django [EOL] import typing [EOL] [docstring] [EOL] [EOL] from django . http import HttpRequest [EOL] from django . http import HttpResponse [EOL] from django . views . decorators . csrf import csrf_exempt [EOL] [EOL] from django import forms [EOL] [EOL] [EOL] class UploadFileForm ( forms . Form ) : [EOL] foo = forms . FileField ( ) [EOL] [EOL] [EOL] @ csrf_exempt def upload_file ( request ) : [EOL] [docstring] [EOL] if request . method == [string] : [EOL] form = UploadFileForm ( request . POST , request . FILES ) [EOL] if form . is_valid ( ) : [EOL] return HttpResponse ( content = form . cleaned_data [ [string] ] . read ( ) + [string] + request . POST [ [string] ] . encode ( ) ) [EOL] return HttpResponse ( content = form . errors ) [EOL] return HttpResponse ( content = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] from django . core . wsgi import get_wsgi_application [EOL] [EOL] os . environ . setdefault ( [string] , [string] ) [EOL] [EOL] application = get_wsgi_application ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from django . contrib import admin [EOL] from django . urls import path [EOL] from djangotestproj . djangotestproj import views [EOL] [EOL] [EOL] urlpatterns = [ path ( [string] , views . upload_file ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0