from typing import Any , Dict [EOL] import failure [EOL] import builtins [EOL] import failure_ocs [EOL] import typing [EOL] import kube [EOL] [docstring] [EOL] import logging [EOL] import random [EOL] import time [EOL] from typing import Dict [EOL] [EOL] import kubernetes [EOL] import kubernetes . client as k8s [EOL] [EOL] from failure import Failure , FailureType , NoSafeFailures [EOL] import kube [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class CephCluster : [EOL] [docstring] [EOL] def __init__ ( self , namespace , name ) : [EOL] self . _ns = namespace [EOL] self . _name = name [EOL] [EOL] def _get_cephcluster ( self ) : [EOL] crd = k8s . CustomObjectsApi ( ) [EOL] return kube . call ( crd . get_namespaced_custom_object , group = [string] , version = [string] , plural = [string] , namespace = self . _ns , name = self . _name ) [EOL] [EOL] def _is_healthy ( self ) : [EOL] ceph = self . _get_cephcluster ( ) [EOL] if ceph . get ( [string] ) is None : [EOL] return False [EOL] if ceph [ [string] ] . get ( [string] ) is None : [EOL] return False [EOL] healthy = ceph [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] return healthy [EOL] [EOL] def is_healthy ( self , timeout_seconds = [number] ) : [EOL] [docstring] [EOL] is_healthy = self . _is_healthy ( ) [EOL] deadline = time . time ( ) + timeout_seconds [EOL] while not is_healthy and deadline > time . time ( ) : [EOL] plist = [string] . join ( self . problems ( ) . keys ( ) ) [EOL] logging . info ( [string] , plist ) [EOL] time . sleep ( [number] ) [EOL] is_healthy = self . is_healthy ( ) [EOL] return is_healthy [EOL] [EOL] def problems ( self ) : [EOL] [docstring] [EOL] ceph = self . _get_cephcluster ( ) [EOL] if ceph . get ( [string] ) is None : [EOL] return { } [EOL] if ceph [ [string] ] . get ( [string] ) is None : [EOL] return { } [EOL] if ceph [ [string] ] [ [string] ] . get ( [string] ) is None : [EOL] return { } [EOL] problems = ceph [ [string] ] [ [string] ] [ [string] ] [EOL] return problems [EOL] [EOL] [EOL] class DeletePod ( Failure ) : [EOL] [docstring] [EOL] def __init__ ( self , deployment , pod ) : [EOL] self . _namespace = pod [ [string] ] [ [string] ] [EOL] self . _name = pod [ [string] ] [ [string] ] [EOL] self . _deployment = deployment [ [string] ] [ [string] ] [EOL] [EOL] def invoke ( self ) : [EOL] core_v1 = k8s . CoreV1Api ( ) [EOL] kube . call ( core_v1 . delete_namespaced_pod , namespace = self . _namespace , name = self . _name , grace_period_seconds = [number] , body = k8s . V1DeleteOptions ( ) ) [EOL] [EOL] def mitigated ( self , timeout_seconds = [number] ) : [EOL] timeout = { } [EOL] if timeout_seconds : [EOL] timeout = { [string] : timeout_seconds } [EOL] [EOL] [comment] [EOL] [comment] [EOL] mitigated = False [EOL] apps_v1 = k8s . AppsV1Api ( ) [EOL] watch = kubernetes . watch . Watch ( ) [EOL] for event in watch . stream ( func = apps_v1 . list_namespaced_deployment , namespace = self . _namespace , field_selector = f" [string] { self . _deployment }" , * timeout ) : [EOL] if event [ [string] ] . status . ready_replicas == event [ [string] ] . spec . replicas : [EOL] mitigated = True [EOL] watch . stop ( ) [EOL] [EOL] return mitigated [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . _namespace } [string] { self . _name } [string] { self . _deployment } [string] ' [EOL] [EOL] [EOL] class DeletePodType ( FailureType ) : [EOL] [docstring] [EOL] def __init__ ( self , namespace , labels , cluster ) : [EOL] self . _labels = labels [EOL] self . _namespace = namespace [EOL] self . _cluster = cluster [EOL] [EOL] def get ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not self . _cluster . is_healthy ( ) : [EOL] raise NoSafeFailures ( [string] ) [EOL] [EOL] selector = [string] . join ( [ f'{ key } [string] { val }' for ( key , val ) in self . _labels . items ( ) ] ) [EOL] apps_v1 = k8s . AppsV1Api ( ) [EOL] deployments = kube . call ( apps_v1 . list_namespaced_deployment , namespace = self . _namespace , label_selector = selector ) [EOL] if not deployments [ [string] ] : [EOL] raise NoSafeFailures ( f' [string] { selector }' ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for deployment in deployments [ [string] ] : [EOL] if deployment [ [string] ] [ [string] ] != deployment [ [string] ] . get ( [string] ) : [EOL] raise NoSafeFailures ( [string] ) [EOL] [EOL] random . shuffle ( deployments [ [string] ] ) [EOL] deployment = deployments [ [string] ] [ [number] ] [EOL] pod_selector = [string] . join ( [ f'{ key } [string] { val }' for ( key , val ) in deployment [ [string] ] [ [string] ] [ [string] ] . items ( ) ] ) [EOL] [EOL] core_v1 = k8s . CoreV1Api ( ) [EOL] pods = kube . call ( core_v1 . list_namespaced_pod , namespace = self . _namespace , label_selector = pod_selector ) [EOL] if not pods [ [string] ] : [EOL] raise NoSafeFailures ( f' [string] { pod_selector }' ) [EOL] [EOL] random . shuffle ( pods [ [string] ] ) [EOL] return DeletePod ( deployment , pods [ [string] ] [ [number] ] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . _namespace } [string] { self . _labels } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.bool$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $builtins.float$ 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $CephCluster$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $failure_ocs.CephCluster$ 0 $CephCluster$ 0 0 0 $failure.Failure$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import logging [EOL] import os [EOL] import time [EOL] [EOL] def setup_logging ( log_dir ) : [EOL] [docstring] [EOL] os . mkdir ( log_dir ) [EOL] [EOL] handlers = [ logging . FileHandler ( os . path . join ( log_dir , [string] ) ) , logging . StreamHandler ( ) ] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] logging . Formatter . converter = time . gmtime [EOL] formatter = logging . Formatter ( [string] ) [EOL] for handler in handlers : [EOL] handler . setFormatter ( formatter ) [EOL] logger . addHandler ( handler ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Callable , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] import time [EOL] from typing import Any , Callable , Dict [comment] [EOL] [EOL] import kubernetes [EOL] import kubernetes . client as k8s [EOL] from kubernetes . client . rest import ApiException [EOL] [EOL] [EOL] MANIFEST = Dict [ str , Any ] [EOL] [EOL] [comment] [EOL] if os . getenv ( [string] ) : [EOL] kubernetes . config . load_incluster_config ( ) [EOL] else : [EOL] kubernetes . config . load_kube_config ( ) [EOL] [EOL] [EOL] def call ( api , * args , ** kwargs ) : [EOL] [docstring] [EOL] fkwargs = kwargs . copy ( ) [EOL] codes = kwargs . get ( [string] ) [EOL] if codes is None : [EOL] codes = { [number] : [string] } [EOL] else : [EOL] del fkwargs [ [string] ] [EOL] while True : [EOL] try : [EOL] result = api ( * args , ** fkwargs ) [EOL] break [EOL] except ApiException as ex : [EOL] action = codes . get ( ex . status ) [EOL] if action == [string] : [EOL] return dict ( ) [EOL] if action == [string] : [EOL] time . sleep ( [number] ) [EOL] continue [EOL] raise [EOL] if isinstance ( result , dict ) : [EOL] return result [EOL] return dict ( result . to_dict ( ) ) [EOL] [EOL] def create_namespace ( name , existing_ok = False ) : [EOL] [docstring] [EOL] body = { [string] : { [string] : name } } [EOL] core_v1 = k8s . CoreV1Api ( ) [EOL] try : [EOL] return call ( core_v1 . create_namespace , body = body ) [EOL] except ApiException as ex : [EOL] if ex . status != [number] or not existing_ok : [EOL] raise [EOL] [EOL] ns_list = call ( core_v1 . list_namespace , field_selector = f' [string] { name }' ) [EOL] return ns_list [ [string] ] [ [number] ] [comment] [EOL] [EOL] def deployment_is_ready ( namespace , name ) : [EOL] [docstring] [EOL] apps_v1 = k8s . AppsV1Api ( ) [EOL] deployments = call ( apps_v1 . list_namespaced_deployment , namespace = namespace , field_selector = f' [string] { name }' ) [EOL] if not deployments [ [string] ] : [EOL] return False [EOL] deployment = deployments [ [string] ] [ [number] ] [EOL] if deployment [ [string] ] [ [string] ] == deployment [ [string] ] . get ( [string] ) : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MANIFEST$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MANIFEST$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] import abc [EOL] [EOL] [EOL] class Error ( Exception ) : [EOL] [docstring] [EOL] [EOL] class NoSafeFailures ( Error ) : [EOL] [docstring] [EOL] [EOL] [EOL] class Failure ( abc . ABC ) : [EOL] [docstring] [EOL] [EOL] @ abc . abstractmethod def invoke ( self ) : [EOL] [docstring] [EOL] [EOL] def repair ( self ) : [EOL] [docstring] [EOL] [EOL] @ abc . abstractmethod def mitigated ( self , timeout_seconds = [number] ) : [EOL] [docstring] [EOL] [EOL] def execute ( self , timeout_seconds = [number] ) : [EOL] [docstring] [EOL] self . invoke ( ) [EOL] result = self . mitigated ( timeout_seconds ) [EOL] self . repair ( ) [EOL] return result [EOL] [EOL] [EOL] class FailureType ( abc . ABC ) : [comment] [EOL] [docstring] [EOL] [EOL] @ abc . abstractmethod def get ( self ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Failure$ 0 0 0 0 0 0 0
from typing import Callable , List [EOL] import queue [EOL] import builtins [EOL] import typing [EOL] import event [EOL] import logging [EOL] [docstring] [EOL] [EOL] import abc [EOL] import logging [EOL] import queue [EOL] import time [EOL] from typing import Callable , List [comment] [EOL] [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] class Dispatcher : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] _event_queue = ... [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _event_queue = queue . PriorityQueue ( ) [EOL] [EOL] def add ( self , * events ) : [EOL] [docstring] [EOL] for event in events : [EOL] LOGGER . debug ( [string] , event ) [EOL] self . _event_queue . put ( event ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] try : [EOL] while True : [EOL] event = self . _event_queue . get_nowait ( ) [EOL] now = time . time ( ) [EOL] delta = event . when - now [EOL] if delta > [number] : [EOL] time . sleep ( delta ) [EOL] LOGGER . debug ( [string] , event ) [EOL] self . add ( * event . execute ( ) ) [EOL] except queue . Empty : [EOL] pass [EOL] [EOL] [EOL] class Event ( abc . ABC ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] _when = ... [EOL] [EOL] def __init__ ( self , when ) : [EOL] [docstring] [EOL] self . _when = when [EOL] [EOL] @ abc . abstractmethod def execute ( self ) : [EOL] [docstring] [EOL] return [ ] [EOL] [EOL] @ property def when ( self ) : [EOL] [docstring] [EOL] return self . _when [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return f" [string] { self . when }" [EOL] [EOL] def __eq__ ( self , other ) : [EOL] [docstring] [EOL] if not isinstance ( other , Event ) : [EOL] return NotImplemented [EOL] return self . when == other . when [EOL] [EOL] def __ne__ ( self , other ) : [EOL] [docstring] [EOL] if not isinstance ( other , Event ) : [EOL] return NotImplemented [EOL] return self . when != other . when [EOL] [EOL] def __lt__ ( self , other ) : [EOL] [docstring] [EOL] if not isinstance ( other , Event ) : [EOL] return NotImplemented [EOL] return self . when < other . when [EOL] [EOL] def __le__ ( self , other ) : [EOL] [docstring] [EOL] if not isinstance ( other , Event ) : [EOL] return NotImplemented [EOL] return self . when <= other . when [EOL] [EOL] def __gt__ ( self , other ) : [EOL] [docstring] [EOL] if not isinstance ( other , Event ) : [EOL] return NotImplemented [EOL] return self . when > other . when [EOL] [EOL] def __ge__ ( self , other ) : [EOL] [docstring] [EOL] if not isinstance ( other , Event ) : [EOL] return NotImplemented [EOL] return self . when >= other . when [EOL] [EOL] [EOL] class OneShot ( Event ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _action = ... [EOL] [EOL] def __init__ ( self , when , action ) : [EOL] [docstring] [EOL] self . _action = [ action ] [EOL] super ( ) . __init__ ( when = when ) [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] self . _action [ [number] ] ( ) [EOL] return [ ] [EOL] [EOL] [EOL] class Periodic ( Event ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _action = ... [EOL] _interval = ... [EOL] [EOL] def __init__ ( self , interval , action ) : [EOL] [docstring] [EOL] self . _action = [ action ] [EOL] self . _interval = interval [EOL] super ( ) . __init__ ( when = time . time ( ) + self . _interval ) [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] if self . _action [ [number] ] ( ) : [EOL] return [ Periodic ( self . _interval , self . _action [ [number] ] ) ] [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'queue.PriorityQueue[Event]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $'List[Event]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Callable[[],None]]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 $'Callable[[],None]'$ 0 0 0 0 0 0 0 $typing.List[typing.Callable[[],None]]$ 0 0 $'Callable[[],None]'$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $'List[Event]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Callable[[],builtins.bool]]$ 0 0 0 $builtins.float$ 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 $'Callable[[],bool]'$ 0 0 0 0 0 0 0 $typing.List[typing.Callable[[],builtins.bool]]$ 0 0 $'Callable[[],bool]'$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $'List[Event]'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import builtins [EOL] import typing [EOL] import event [EOL] import logging [EOL] import kube [EOL] import concurrent [EOL] [docstring] [EOL] [EOL] [EOL] import concurrent . futures [EOL] import copy [EOL] import logging [EOL] import random [EOL] import time [EOL] from typing import Any , Callable , Dict , List [comment] [EOL] [EOL] import kubernetes [EOL] import kubernetes . client as k8s [EOL] [EOL] import kube [EOL] from event import Event [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] EXECUTOR = concurrent . futures . ThreadPoolExecutor ( max_workers = [number] ) [EOL] WORKAROUND_MIN_RUNTIME = True [EOL] [EOL] class UnhealthyDeployment ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , namespace , name ) : [EOL] [docstring] [EOL] self . namespace = namespace [EOL] self . name = name [EOL] super ( ) . __init__ ( self , namespace , name ) [EOL] [EOL] [EOL] def start ( namespace , storage_class , access_mode , interarrival , lifetime , active , idle , kernel_slots , kernel_untar , kernel_rm , workload_image ) : [EOL] [docstring] [EOL] LOGGER . info ( [string] , interarrival , lifetime , active , idle ) [EOL] LOGGER . info ( [string] , namespace ) [EOL] LOGGER . info ( [string] , storage_class ) [EOL] LOGGER . info ( [string] , access_mode ) [EOL] LOGGER . info ( [string] , lifetime / interarrival ) [EOL] LOGGER . info ( [string] , active / ( active + idle ) ) [EOL] LOGGER . info ( [string] , [number] * lifetime / ( active + idle ) ) [EOL] LOGGER . info ( [string] , kernel_slots ) [EOL] LOGGER . info ( [string] , kernel_untar ) [EOL] LOGGER . info ( [string] , kernel_rm ) [EOL] LOGGER . info ( [string] , workload_image ) [EOL] if WORKAROUND_MIN_RUNTIME : [EOL] LOGGER . warning ( [string] ) [EOL] [EOL] return Creator ( namespace = namespace , storage_class = storage_class , access_mode = access_mode , interarrival = interarrival , lifetime = lifetime , active = active , idle = idle , kernel_slots = kernel_slots , kernel_untar = kernel_untar , kernel_rm = kernel_rm , workload_image = workload_image ) [EOL] [EOL] def resume ( namespace ) : [EOL] [docstring] [EOL] events = [ ] [EOL] apps_v1 = k8s . AppsV1Api ( ) [EOL] deployments = kube . call ( apps_v1 . list_namespaced_deployment , namespace = namespace , label_selector = [string] ) [EOL] for deployment in deployments [ [string] ] : [EOL] LOGGER . info ( [string] , deployment [ [string] ] [ [string] ] , deployment [ [string] ] [ [string] ] ) [EOL] events . append ( Lifecycle ( when = [number] , namespace = deployment [ [string] ] [ [string] ] , name = deployment [ [string] ] [ [string] ] ) ) [EOL] return events [EOL] [EOL] def _matchlabel_from_deployment ( deployment ) : [EOL] selector = deployment [ [string] ] [ [string] ] [EOL] if [string] in selector : [comment] [EOL] did = selector [ [string] ] [ [string] ] [EOL] else : [comment] [EOL] did = selector [ [string] ] [ [string] ] [EOL] return f' [string] { did }' [EOL] [EOL] def _pod_start_watcher ( deployment ) : [EOL] namespace = deployment [ [string] ] [ [string] ] [EOL] name = deployment [ [string] ] [ [string] ] [EOL] full_name = f'{ namespace } [string] { name }' [EOL] label = _matchlabel_from_deployment ( deployment ) [EOL] LOGGER . debug ( [string] , full_name ) [EOL] start_time = time . time ( ) [EOL] watch = kubernetes . watch . Watch ( ) [EOL] core_v1 = k8s . CoreV1Api ( ) [EOL] for event in watch . stream ( func = core_v1 . list_namespaced_pod , namespace = namespace , label_selector = label , timeout_seconds = [number] ) : [EOL] if event [ [string] ] . status . phase == [string] : [EOL] watch . stop ( ) [EOL] end_time = time . time ( ) [EOL] LOGGER . info ( [string] , full_name , end_time - start_time ) [EOL] return [EOL] [comment] [EOL] if event [ [string] ] == [string] : [EOL] [comment] [EOL] LOGGER . debug ( [string] , full_name ) [EOL] watch . stop ( ) [EOL] return [EOL] LOGGER . warning ( [string] , full_name ) [EOL] [EOL] def _pod_stop_watcher ( deployment ) : [EOL] namespace = deployment [ [string] ] [ [string] ] [EOL] name = deployment [ [string] ] [ [string] ] [EOL] full_name = f'{ namespace } [string] { name }' [EOL] label = _matchlabel_from_deployment ( deployment ) [EOL] LOGGER . debug ( [string] , full_name ) [EOL] start_time = time . time ( ) [EOL] watch = kubernetes . watch . Watch ( ) [EOL] core_v1 = k8s . CoreV1Api ( ) [EOL] for event in watch . stream ( func = core_v1 . list_namespaced_pod , namespace = namespace , label_selector = label , timeout_seconds = [number] ) : [EOL] [comment] [EOL] if event [ [string] ] == [string] : [EOL] end_time = time . time ( ) [EOL] watch . stop ( ) [EOL] LOGGER . info ( [string] , full_name , end_time - start_time ) [EOL] return [EOL] LOGGER . warning ( [string] , full_name ) [EOL] [EOL] def _get_workload ( ns_name , sc_name , access_mode , kernel_slots , kernel_untar , kernel_rm , workload_image ) : [EOL] [docstring] [EOL] manifests = { } [EOL] unique_id = str ( random . randrange ( [number] ) ) [EOL] [EOL] manifests [ [string] ] = { [string] : { [string] : f" [string] { unique_id }" , [string] : ns_name , [string] : { [string] : [string] } } , [string] : { [string] : [number] , [string] : { [string] : { [string] : unique_id } } , [string] : { [string] : { [string] : { [string] : unique_id } } , [string] : { [string] : [ { [string] : [string] , [string] : workload_image , [string] : [ [string] , f"{ kernel_untar }" , [string] , f"{ kernel_rm }" , [string] , f"{ kernel_slots }" ] , [string] : { [string] : { [string] : [ [string] ] } , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] } ] , [string] : [ { [string] : [string] , [string] : { [string] : [string] } } , { [string] : [string] , [string] : { [string] : f" [string] { unique_id }" } } ] } } } } [EOL] [EOL] manifests [ [string] ] = { [string] : { [string] : f" [string] { unique_id }" , [string] : ns_name } , [string] : { [string] : [ access_mode ] , [string] : { [string] : { [string] : [string] } } , [string] : sc_name } } [EOL] return manifests [EOL] [EOL] class Creator ( Event ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , namespace , storage_class , access_mode , interarrival , lifetime , active , idle , kernel_slots , kernel_untar , kernel_rm , workload_image ) : [EOL] [docstring] [EOL] self . _namespace = namespace [EOL] self . _storage_class = storage_class [EOL] self . _access_mode = access_mode [EOL] self . _interarrival = interarrival [EOL] self . _lifetime = lifetime [EOL] self . _active = active [EOL] self . _idle = idle [EOL] self . _kernel_slots = kernel_slots [EOL] self . _kernel_untar = kernel_untar [EOL] self . _kernel_rm = kernel_rm [EOL] self . _workload_image = workload_image [EOL] super ( ) . __init__ ( when = time . time ( ) + random . expovariate ( [number] / self . _interarrival ) ) [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] destroy_time = time . time ( ) + random . expovariate ( [number] / self . _lifetime ) [EOL] manifests = _get_workload ( self . _namespace , self . _storage_class , self . _access_mode , self . _kernel_slots , self . _kernel_untar , self . _kernel_rm , self . _workload_image ) [EOL] pvc = manifests [ [string] ] [EOL] deploy = manifests [ [string] ] [EOL] [comment] [EOL] anno = deploy [ [string] ] . setdefault ( [string] , { } ) [EOL] anno [ [string] ] = str ( self . _active ) [EOL] anno [ [string] ] = str ( self . _idle ) [EOL] anno [ [string] ] = str ( destroy_time ) [EOL] anno [ [string] ] = pvc [ [string] ] [ [string] ] [EOL] deploy [ [string] ] [ [string] ] = anno [EOL] LOGGER . info ( [string] , deploy [ [string] ] [ [string] ] , deploy [ [string] ] [ [string] ] , pvc [ [string] ] [ [string] ] ) [EOL] core_v1 = k8s . CoreV1Api ( ) [EOL] kube . call ( core_v1 . create_namespaced_persistent_volume_claim , namespace = pvc [ [string] ] [ [string] ] , body = pvc ) [EOL] apps_v1 = k8s . AppsV1Api ( ) [EOL] kube . call ( apps_v1 . create_namespaced_deployment , namespace = deploy [ [string] ] [ [string] ] , body = deploy ) [EOL] EXECUTOR . submit ( _pod_start_watcher , deploy ) [EOL] return [ Lifecycle ( when = [number] , namespace = deploy [ [string] ] [ [string] ] , name = deploy [ [string] ] [ [string] ] , ) , Creator ( self . _namespace , self . _storage_class , self . _access_mode , self . _interarrival , self . _lifetime , self . _active , self . _idle , self . _kernel_slots , self . _kernel_untar , self . _kernel_rm , self . _workload_image ) ] [EOL] [EOL] class Lifecycle ( Event ) : [EOL] [docstring] [EOL] [EOL] _health_interval = [number] [comment] [EOL] _health_interval_initial = [number] [comment] [EOL] [EOL] def __init__ ( self , when , namespace , name ) : [EOL] [docstring] [EOL] self . _namespace = namespace [EOL] self . _name = name [EOL] super ( ) . __init__ ( when ) [EOL] [EOL] def _get_deployment ( self ) : [EOL] apps_v1 = k8s . AppsV1Api ( ) [EOL] v1dl = kube . call ( apps_v1 . list_namespaced_deployment , namespace = self . _namespace , field_selector = f' [string] { self . _name }' ) [EOL] return v1dl [ [string] ] [ [number] ] [comment] [EOL] [EOL] def _action_initialize ( self , deploy ) : [EOL] anno = deploy [ [string] ] [ [string] ] [EOL] idle_mean = float ( anno [ [string] ] ) [EOL] idle_duration = random . expovariate ( [number] / idle_mean ) [EOL] if WORKAROUND_MIN_RUNTIME : [EOL] idle_duration = max ( idle_duration , self . _health_interval_initial ) [EOL] idle_time = time . time ( ) + idle_duration [EOL] anno [ [string] ] = str ( idle_time ) [EOL] health_time = time . time ( ) + self . _health_interval_initial [EOL] anno [ [string] ] = str ( health_time ) [EOL] return deploy [EOL] [EOL] def _action_destroy ( self , deploy ) : [EOL] anno = deploy [ [string] ] [ [string] ] [EOL] pvc_name = anno [ [string] ] [EOL] LOGGER . info ( [string] , self . _namespace , self . _name , pvc_name ) [EOL] EXECUTOR . submit ( _pod_stop_watcher , copy . deepcopy ( deploy ) ) [EOL] apps_v1 = k8s . AppsV1Api ( ) [EOL] kube . call ( apps_v1 . delete_namespaced_deployment , namespace = self . _namespace , name = self . _name , body = k8s . V1DeleteOptions ( ) ) [EOL] core_v1 = k8s . CoreV1Api ( ) [EOL] kube . call ( core_v1 . delete_namespaced_persistent_volume_claim , namespace = self . _namespace , name = pvc_name , body = k8s . V1DeleteOptions ( ) ) [EOL] [EOL] def _action_health ( self , deploy ) : [EOL] if deploy [ [string] ] [ [string] ] == [number] : [comment] [EOL] if deploy [ [string] ] . get ( [string] ) != [number] : [EOL] LOGGER . error ( [string] , self . _namespace , self . _name ) [EOL] raise UnhealthyDeployment ( self . _namespace , self . _name ) [EOL] anno = deploy [ [string] ] [ [string] ] [EOL] health_time = time . time ( ) + self . _health_interval [EOL] anno [ [string] ] = str ( health_time ) [EOL] return deploy [EOL] [EOL] def _action_idle ( self , deploy ) : [EOL] anno = deploy [ [string] ] [ [string] ] [EOL] if deploy [ [string] ] [ [string] ] == [number] : [comment] [EOL] deploy [ [string] ] [ [string] ] = [number] [EOL] active_mean = float ( anno [ [string] ] ) [EOL] active_duration = random . expovariate ( [number] / active_mean ) [EOL] if WORKAROUND_MIN_RUNTIME : [EOL] active_duration = max ( active_duration , self . _health_interval_initial ) [EOL] idle_time = time . time ( ) + active_duration [EOL] health_time = time . time ( ) + self . _health_interval_initial [EOL] LOGGER . info ( [string] , self . _namespace , self . _name ) [EOL] EXECUTOR . submit ( _pod_start_watcher , copy . deepcopy ( deploy ) ) [EOL] else : [comment] [EOL] deploy [ [string] ] [ [string] ] = [number] [EOL] idle_mean = float ( anno [ [string] ] ) [EOL] idle_duration = random . expovariate ( [number] / idle_mean ) [EOL] if WORKAROUND_MIN_RUNTIME : [EOL] idle_duration = max ( idle_duration , self . _health_interval_initial ) [EOL] idle_time = time . time ( ) + idle_duration [EOL] health_time = time . time ( ) + self . _health_interval [EOL] LOGGER . info ( [string] , self . _namespace , self . _name ) [EOL] EXECUTOR . submit ( _pod_stop_watcher , copy . deepcopy ( deploy ) ) [EOL] anno [ [string] ] = str ( idle_time ) [EOL] anno [ [string] ] = str ( health_time ) [EOL] return deploy [EOL] [EOL] def _update_and_schedule ( self , deploy ) : [EOL] [docstring] [EOL] anno = deploy [ [string] ] [ [string] ] [EOL] destroy_time = float ( anno [ [string] ] ) [EOL] idle_time = float ( anno [ [string] ] ) [EOL] health_time = float ( anno [ [string] ] ) [EOL] next_time = min ( destroy_time , idle_time , health_time ) [EOL] anno [ [string] ] = str ( next_time ) [EOL] if next_time == destroy_time : [EOL] anno [ [string] ] = [string] [EOL] elif next_time == idle_time : [EOL] anno [ [string] ] = [string] [EOL] else : [EOL] anno [ [string] ] = [string] [EOL] apps_v1 = k8s . AppsV1Api ( ) [EOL] kube . call ( apps_v1 . patch_namespaced_deployment , namespace = self . _namespace , name = self . _name , body = deploy ) [EOL] return [ Lifecycle ( next_time , self . _namespace , self . _name ) ] [EOL] [EOL] def execute ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] deploy = self . _get_deployment ( ) [EOL] anno = deploy [ [string] ] . setdefault ( [string] , { } ) [EOL] [comment] [EOL] if [string] not in anno : [EOL] deploy = self . _action_initialize ( deploy ) [EOL] return self . _update_and_schedule ( deploy ) [EOL] [EOL] etime = float ( anno [ [string] ] ) [EOL] if etime > time . time ( ) : [comment] [EOL] return [ Lifecycle ( etime , self . _namespace , self . _name ) ] [EOL] [EOL] [comment] [EOL] eaction = anno [ [string] ] [EOL] if eaction == [string] : [EOL] self . _action_destroy ( deploy ) [EOL] return [ ] [comment] [EOL] if eaction == [string] : [EOL] self . _action_health ( deploy ) [EOL] elif eaction == [string] : [EOL] self . _action_idle ( deploy ) [EOL] else : [EOL] assert False , f' [string] { eaction }' [EOL] return self . _update_and_schedule ( deploy ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[event.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,kube.MANIFEST]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $'List[Event]'$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 $kube.MANIFEST$ 0 0 0 $typing.Any$ 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.bool$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $kube.MANIFEST$ 0 0 0 $None$ 0 0 0 $kube.MANIFEST$ 0 0 0 $typing.Any$ 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 $kube.MANIFEST$ 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $kube.MANIFEST$ 0 0 0 $kube.MANIFEST$ 0 0 0 $kube.MANIFEST$ 0 0 0 $typing.Any$ 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.bool$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.bool$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $kube.MANIFEST$ 0 0 0 $typing.List[event.Event]$ 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 $typing.Any$ 0 $kube.MANIFEST$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $kube.MANIFEST$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[event.Event]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0
from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import random [EOL] [EOL] import kubernetes . client as k8s [EOL] from kubernetes . client . rest import ApiException [EOL] import pytest [EOL] [EOL] import kube [EOL] [EOL] @ pytest . mark . kube_required def test_create_namespace ( ) : [EOL] [docstring] [EOL] ns_name = f" [string] { random . randrange ( [number] ) }" [EOL] res = kube . create_namespace ( ns_name ) [EOL] assert res [ [string] ] [ [string] ] == ns_name [EOL] _delete_namespace ( ns_name ) [EOL] [EOL] @ pytest . mark . kube_required def test_exclusive_ns_create ( ) : [EOL] [docstring] [EOL] ns_name = f" [string] { random . randrange ( [number] ) }" [EOL] kube . create_namespace ( ns_name ) [EOL] with pytest . raises ( ApiException ) : [EOL] kube . create_namespace ( ns_name ) [EOL] _delete_namespace ( ns_name ) [EOL] [EOL] @ pytest . mark . kube_required def test_existing_ns_create ( ) : [EOL] [docstring] [EOL] ns_name = f" [string] { random . randrange ( [number] ) }" [EOL] res = kube . create_namespace ( ns_name ) [EOL] res2 = kube . create_namespace ( ns_name , existing_ok = True ) [EOL] assert res [ [string] ] [ [string] ] == ns_name [EOL] assert res2 [ [string] ] [ [string] ] == ns_name [EOL] _delete_namespace ( ns_name ) [EOL] [EOL] def _delete_namespace ( ns_name ) : [EOL] core_v1 = k8s . CoreV1Api ( ) [EOL] kube . call ( core_v1 . delete_namespace , name = ns_name , body = k8s . V1DeleteOptions ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import random [EOL] [EOL] import kubernetes [EOL] import kubernetes . client as k8s [EOL] import pytest [EOL] [EOL] import kube [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] [docstring] [EOL] parser . addoption ( [string] , action = [string] , default = False , help = [string] ) [EOL] parser . addoption ( [string] , action = [string] , default = False , help = [string] ) [EOL] [EOL] def pytest_configure ( config ) : [EOL] [docstring] [EOL] config . addinivalue_line ( [string] , [string] ) [EOL] [EOL] def pytest_collection_modifyitems ( config , items ) : [EOL] [docstring] [EOL] if not config . getoption ( [string] ) : [EOL] skip_kube = pytest . mark . skip ( reason = [string] ) [EOL] for item in items : [EOL] if [string] in item . keywords : [EOL] item . add_marker ( skip_kube ) [EOL] if not config . getoption ( [string] ) : [EOL] skip_bench = pytest . mark . skip ( reason = [string] ) [EOL] for item in items : [EOL] if [string] in item . keywords : [EOL] item . add_marker ( skip_bench ) [EOL] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def load_kubeconfig ( ) : [EOL] [docstring] [EOL] kubernetes . config . load_kube_config ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ [string] , [string] , [string] ] ) def storageclass_iterator ( request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . fixture [comment] [EOL] [comment] [EOL] def unique_namespace ( request , load_kubeconfig ) : [EOL] [docstring] [EOL] core_v1 = k8s . CoreV1Api ( ) [EOL] ns_name = f" [string] { random . randrange ( [number] ) }" [EOL] namespace = kube . call ( core_v1 . create_namespace , body = { [string] : { [string] : ns_name } } ) [EOL] [EOL] def teardown ( ) : [EOL] kube . call ( core_v1 . delete_namespace , name = namespace [ [string] ] [ [string] ] , body = k8s . V1DeleteOptions ( ) ) [EOL] request . addfinalizer ( teardown ) [EOL] return namespace [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import subprocess [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import os [EOL] import subprocess [EOL] [EOL] import log_gather [EOL] [EOL] [comment] [EOL] class MustGather ( log_gather . Collector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , oc ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( [string] ) [EOL] self . _oc = oc [EOL] def gather ( self , path ) : [EOL] [docstring] [EOL] mg_dir = os . path . join ( path , [string] ) [EOL] completed = subprocess . run ( f'{ self . _oc } [string] ' f' [string] { mg_dir }' , shell = True , check = False ) [EOL] return completed . returncode == [number] [EOL] [EOL] class OcsMustGather ( log_gather . Collector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , oc ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( [string] ) [EOL] self . _oc = oc [EOL] def gather ( self , path ) : [EOL] [docstring] [EOL] mg_dir = os . path . join ( path , [string] ) [EOL] completed = subprocess . run ( f'{ self . _oc } [string] ' f' [string] ' f' [string] { mg_dir }' , shell = True , check = False ) [EOL] return completed . returncode == [number] [EOL] [EOL] class OcsImageVersions ( log_gather . Collector ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , oc , ocs_namespace ) : [EOL] [docstring] [EOL] self . _oc = oc [EOL] self . _ns = ocs_namespace [EOL] super ( ) . __init__ ( [string] ) [EOL] def gather ( self , path ) : [EOL] [docstring] [EOL] completed = subprocess . run ( f'{ self . _oc } [string] { self . _ns } [string] ' [string] f' [string] { path } [string] ' , shell = True , check = False ) [EOL] return completed . returncode == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0
from typing import List [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import abc [EOL] import logging [EOL] from typing import List [comment] [EOL] [EOL] _collectors = [ ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] class Collector ( abc . ABC ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name ) : [EOL] [docstring] [EOL] self . _name = name [EOL] super ( ) . __init__ ( ) [EOL] [EOL] @ abc . abstractmethod def gather ( self , path ) : [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def gather ( path ) : [EOL] [docstring] [EOL] for collector in _collectors : [EOL] _LOGGER . info ( [string] , collector ) [EOL] if collector . gather ( path ) : [EOL] _LOGGER . info ( [string] ) [EOL] else : [EOL] _LOGGER . warning ( [string] , collector ) [EOL] [EOL] def add ( collector ) : [EOL] [docstring] [EOL] _collectors . append ( collector ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'List[Collector]'$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $'List[Collector]'$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $'List[Collector]'$ 0 0 0 0 0 0
[comment] [EOL] import event [EOL] import argparse [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import logging [EOL] import argparse [EOL] import os [EOL] import random [EOL] import time [EOL] [EOL] import event [EOL] import log_gather [EOL] import log_gather_ocs [EOL] import osio [EOL] import kube [EOL] import util [EOL] [EOL] CLI_ARGS = ... [EOL] RUN_ID = random . randrange ( [number] ) [EOL] [EOL] def set_health ( healthy ) : [EOL] [docstring] [EOL] filename = [string] [EOL] if healthy : [EOL] logging . info ( [string] , filename ) [EOL] file = os . open ( filename , os . O_CREAT | os . O_WRONLY ) [EOL] os . close ( file ) [EOL] else : [EOL] logging . info ( [string] , filename ) [EOL] os . unlink ( filename ) [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , default = os . getcwd ( ) , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , default = [string] , type = str , choices = [ [string] , [string] ] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , default = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , default = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , default = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , default = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , default = [number] , type = float , help = [string] ) [EOL] parser . add_argument ( [string] , default = [number] , type = float , help = [string] ) [EOL] parser . add_argument ( [string] , default = [number] , type = float , help = [string] ) [EOL] parser . add_argument ( [string] , default = [number] , type = float , help = [string] ) [EOL] parser . add_argument ( [string] , default = [number] , type = int , help = [string] ) [EOL] parser . add_argument ( [string] , default = [number] , type = float , help = [string] ) [EOL] parser . add_argument ( [string] , default = [number] , type = float , help = [string] ) [EOL] parser . add_argument ( [string] , default = [string] , type = str , help = [string] ) [EOL] global CLI_ARGS [comment] [EOL] CLI_ARGS = parser . parse_args ( ) [EOL] [EOL] log_dir = os . path . join ( CLI_ARGS . log_dir , f' [string] { RUN_ID }' ) [EOL] util . setup_logging ( log_dir ) [EOL] [EOL] logging . info ( [string] , RUN_ID ) [EOL] logging . info ( [string] , CLI_ARGS ) [EOL] logging . info ( [string] , log_dir ) [EOL] [EOL] [comment] [EOL] log_gather . add ( log_gather_ocs . OcsMustGather ( CLI_ARGS . oc ) ) [EOL] log_gather . add ( log_gather_ocs . MustGather ( CLI_ARGS . oc ) ) [EOL] log_gather . add ( log_gather_ocs . OcsImageVersions ( CLI_ARGS . oc , CLI_ARGS . ocs_namespace ) ) [EOL] [EOL] kube . create_namespace ( CLI_ARGS . namespace , existing_ok = True ) [EOL] [EOL] if CLI_ARGS . sleep_on_error : [EOL] set_health ( True ) [EOL] [EOL] dispatch = event . Dispatcher ( ) [EOL] dispatch . add ( * osio . resume ( CLI_ARGS . namespace ) ) [EOL] dispatch . add ( osio . start ( namespace = CLI_ARGS . namespace , storage_class = CLI_ARGS . storageclass , access_mode = CLI_ARGS . accessmode , interarrival = CLI_ARGS . osio_interarrival , lifetime = CLI_ARGS . osio_lifetime , active = CLI_ARGS . osio_active_time , idle = CLI_ARGS . osio_idle_time , kernel_slots = CLI_ARGS . osio_kernel_slots , kernel_untar = CLI_ARGS . osio_kernel_untar , kernel_rm = CLI_ARGS . osio_kernel_rm , workload_image = CLI_ARGS . osio_image ) ) [EOL] try : [EOL] dispatch . run ( ) [EOL] except osio . UnhealthyDeployment : [EOL] if CLI_ARGS . sleep_on_error : [EOL] set_health ( False ) [EOL] logging . info ( [string] ) [EOL] log_gather . gather ( log_dir ) [EOL] logging . info ( [string] ) [EOL] while CLI_ARGS . sleep_on_error : [EOL] time . sleep ( [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import NoReturn , Any , Dict , List [EOL] import typing [EOL] import subprocess [EOL] import argparse [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import logging [EOL] import os [EOL] import random [EOL] import signal [EOL] import shutil [EOL] import subprocess [EOL] import sys [EOL] import time [EOL] from typing import Any , Dict , List , NoReturn [EOL] [EOL] [comment] [EOL] _HOURLY_DRAW_RATE = [number] [EOL] _CONTINUE = True [EOL] [EOL] def get_slots ( path , max_slots ) : [EOL] [docstring] [EOL] summary = { [string] : [ ] , [string] : [ ] } [EOL] for slot in range ( max_slots ) : [EOL] slot_dir = os . path . join ( path , f' [string] { slot }' ) [EOL] if os . path . exists ( slot_dir ) : [EOL] summary [ [string] ] . append ( slot_dir ) [EOL] else : [EOL] summary [ [string] ] . append ( slot_dir ) [EOL] return summary [EOL] [EOL] def do_untar ( image , data_dir ) : [EOL] [docstring] [EOL] logging . info ( [string] , image , data_dir ) [EOL] os . mkdir ( data_dir ) [EOL] completed = subprocess . run ( f' [string] { data_dir } [string] { image } [string] ' , shell = True , check = False ) [EOL] return completed . returncode == [number] [EOL] [EOL] def do_rm ( data_dir ) : [EOL] [docstring] [EOL] logging . info ( [string] , data_dir ) [EOL] shutil . rmtree ( data_dir ) [EOL] return True [EOL] [EOL] def rate_to_probability ( rate_per_hour , draw_rate ) : [EOL] [docstring] [EOL] return min ( rate_per_hour / draw_rate , [number] ) [EOL] [EOL] def _sig_handler ( signum , stack ) : [comment] [EOL] global _CONTINUE [comment] [EOL] _CONTINUE = False [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] ) [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , type = float , default = [number] , help = [string] ) [EOL] cli_args = parser . parse_args ( ) [EOL] [EOL] logging . info ( [string] ) [EOL] logging . info ( [string] , cli_args ) [EOL] [EOL] [comment] [EOL] signal . signal ( signal . SIGINT , _sig_handler ) [EOL] [EOL] while _CONTINUE : [EOL] time . sleep ( _HOURLY_DRAW_RATE / [number] ) [EOL] if random . random ( ) < rate_to_probability ( cli_args . untar_rate , _HOURLY_DRAW_RATE ) : [EOL] logging . info ( [string] ) [EOL] slots = get_slots ( cli_args . data_dir , cli_args . kernel_slots ) [EOL] try : [EOL] slot_dir = random . choice ( slots [ [string] ] ) [EOL] if not do_untar ( cli_args . untar_image , slot_dir ) : [EOL] logging . error ( [string] ) [EOL] sys . exit ( [number] ) [EOL] except IndexError : [EOL] logging . info ( [string] ) [EOL] continue [EOL] if random . random ( ) < rate_to_probability ( cli_args . rm_rate , _HOURLY_DRAW_RATE ) : [EOL] logging . info ( [string] ) [EOL] slots = get_slots ( cli_args . data_dir , cli_args . kernel_slots ) [EOL] try : [EOL] slot_dir = random . choice ( slots [ [string] ] ) [EOL] if not do_rm ( slot_dir ) : [EOL] logging . error ( [string] ) [EOL] sys . exit ( [number] ) [EOL] except IndexError : [EOL] logging . info ( [string] ) [EOL] continue [EOL] [EOL] logging . info ( [string] ) [EOL] sys . exit ( os . EX_OK ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.NoReturn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0