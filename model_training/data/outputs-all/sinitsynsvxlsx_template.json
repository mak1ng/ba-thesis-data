import builtins [EOL] from typing import Any , List , Tuple [EOL] import xlsx_template [EOL] import typing [EOL] import os [EOL] import sys [EOL] import shutil [EOL] import datetime [EOL] [EOL] sys . path . insert ( [number] , os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] import data_generators [EOL] from xlsx_template import Template [EOL] [EOL] [EOL] ROOT_DIR = os . path . dirname ( __file__ ) [EOL] EXAMPLE_RES_DIR = os . path . join ( ROOT_DIR , [string] ) [EOL] [EOL] BASE_TEMPLATE_DIR = os . path . join ( ROOT_DIR , [string] , [string] ) [EOL] EXAMPLE_DEF = [ ( [string] , data_generators . generate_for_test_variables ) , ( [string] , data_generators . generate_for_test_simple_loop ) , ( [string] , data_generators . generate_for_test_two_nested_loops ) , ( [string] , data_generators . generate_for_test_two_nested_loops , ) , ( [string] , data_generators . generate_for_test_loop_context ) , ( [string] , data_generators . generate_for_test_merge ) , ( [string] , data_generators . generate_for_test_if ) , ( [string] , data_generators . generate_for_loop_with_formulas ) , ( [string] , data_generators . generate_for_test_column_width ) , ] [EOL] [EOL] EXAMPLE_DEF = [ ( os . path . join ( BASE_TEMPLATE_DIR , template ) , data_generator ) for ( template , data_generator ) in EXAMPLE_DEF ] [EOL] [EOL] [EOL] def main ( ) : [EOL] if not os . path . exists ( EXAMPLE_RES_DIR ) : [EOL] os . mkdir ( EXAMPLE_RES_DIR ) [EOL] [EOL] for i , ( template_name , dg ) in enumerate ( EXAMPLE_DEF , [number] ) : [EOL] base_template_name = os . path . basename ( template_name ) [EOL] if base_template_name . startswith ( [string] ) : [EOL] base_template_name = base_template_name [ [number] : ] [EOL] base_template_name = [string] . format ( i , base_template_name ) [EOL] file_name , _ = os . path . splitext ( base_template_name ) [EOL] template = Template ( open ( template_name , [string] ) . read ( ) , debug = True ) [EOL] source_code_file_name = os . path . join ( EXAMPLE_RES_DIR , file_name + [string] ) [EOL] with open ( source_code_file_name , [string] ) as f : [EOL] f . write ( template . code_source ) [EOL] print ( [string] . format ( datetime . datetime . now ( ) , base_template_name ) ) [EOL] res = template . render ( dg ( ) ) [EOL] print ( [string] . format ( datetime . datetime . now ( ) , base_template_name ) ) [EOL] res_template_name = os . path . join ( EXAMPLE_RES_DIR , base_template_name ) [EOL] result_file_name = os . path . join ( EXAMPLE_RES_DIR , file_name + [string] ) [EOL] shutil . copy ( template_name , res_template_name ) [EOL] with open ( result_file_name , [string] ) as f : [EOL] f . write ( res ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import setuptools [EOL] [EOL] with open ( [string] , [string] ) as fh : [EOL] long_description = fh . read ( ) [EOL] [EOL] with open ( [string] ) as f : [EOL] requirements = f . read ( ) . splitlines ( ) [EOL] requirements = [ r for r in requirements if [string] not in r ] [EOL] [EOL] setuptools . setup ( name = [string] , version = [string] , author = [string] , author_email = [string] , description = [string] , include_package_data = True , long_description = long_description , long_description_content_type = [string] , url = [string] , packages = setuptools . find_packages ( ) , classifiers = [ [string] , [string] , [string] , ] , install_requires = requirements , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0
	0
from typing import Any , Tuple , Optional [EOL] import typing [EOL] import io [EOL] from collections import defaultdict [EOL] [EOL] from xlsx_template import nodes [EOL] [EOL] [EOL] class Symbols : [EOL] [EOL] BUILTINS = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self ) : [EOL] self . symbols = defaultdict ( list ) [EOL] [EOL] def declare_ref ( self , name ) : [EOL] self . symbols [ name ] . append ( [string] . format ( name , len ( self . symbols [ name ] ) ) ) [EOL] return self . symbols [ name ] [ - [number] ] [EOL] [EOL] def undeclare_ref ( self , name ) : [EOL] self . symbols [ name ] . pop ( - [number] ) [EOL] if not self . symbols [ name ] : [EOL] self . symbols . pop ( name ) [EOL] [EOL] def add_ref ( self , name , real_name ) : [EOL] self . symbols [ name ] . append ( real_name ) [EOL] [EOL] def find_ref ( self , name ) : [EOL] if name in self . symbols : [EOL] return self . symbols [ name ] [ - [number] ] [EOL] elif name in self . BUILTINS : [EOL] return name [EOL] [EOL] [EOL] class CodeGenerator : [EOL] def __init__ ( self ) : [EOL] self . indent_count = [number] [EOL] self . stream = None [EOL] self . symbols = None [EOL] self . cell_group_level = [number] [EOL] self . is_new_line = True [EOL] [EOL] def generate ( self , root_node ) : [EOL] self . indent_count = [number] [EOL] self . stream = io . StringIO ( ) [EOL] self . symbols = Symbols ( ) [EOL] self . is_new_line = True [EOL] self . cell_group_level = [number] [EOL] self . generate_for ( root_node ) [EOL] return self . stream . getvalue ( ) [EOL] [EOL] def write ( self , s ) : [EOL] if self . is_new_line : [EOL] self . stream . write ( [string] * self . indent_count ) [EOL] self . is_new_line = False [EOL] self . stream . write ( s ) [EOL] [EOL] def newline ( self ) : [EOL] self . stream . write ( [string] ) [EOL] self . is_new_line = True [EOL] [EOL] def write_line ( self , s ) : [EOL] self . write ( s ) [EOL] self . newline ( ) [EOL] [EOL] def indent ( self ) : [EOL] self . indent_count += [number] [EOL] [EOL] def unindent ( self ) : [EOL] self . indent_count -= [number] [EOL] [EOL] def generate_for ( self , node ) : [EOL] method_name = [string] . format ( node . __class__ . __name__ . lower ( ) ) [EOL] return getattr ( self , method_name ) ( node ) [EOL] [EOL] def generate_for_sheet ( self , sheet_node ) : [EOL] self . write ( [string] ) [EOL] self . generate_for ( sheet_node . name ) [EOL] self . write ( [string] ) [EOL] self . newline ( ) [EOL] size = [string] . format ( sheet_node . last_cell [ [number] ] + [number] , sheet_node . last_cell [ [number] ] + [number] ) [EOL] self . write_line ( [string] . format ( size ) ) [EOL] self . newline ( ) [EOL] for child in sheet_node . body : [EOL] self . generate_for ( child ) [EOL] self . newline ( ) [EOL] self . write_line ( [string] ) [EOL] self . indent ( ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . indent ( ) [EOL] self . write_line ( [string] ) [EOL] self . unindent ( ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . unindent ( ) [EOL] self . write_line ( [string] ) [EOL] self . indent ( ) [EOL] self . write_line ( [string] ) [EOL] self . unindent ( ) [EOL] [EOL] def generate_for_remove ( self , remove ) : [EOL] size = [string] . format ( remove . height , remove . width ) [EOL] self . write_line ( [string] . format ( self . cell_group_level + [number] , size ) ) [EOL] self . write_line ( [string] . format ( self . cell_group_level , remove . base_cell [ [number] ] , remove . base_cell [ [number] ] , self . cell_group_level + [number] , ) ) [EOL] [EOL] def generate_for_if ( self , if_d ) : [EOL] self . cell_group_level += [number] [EOL] size = [string] . format ( if_d . height , if_d . width ) [EOL] self . write_line ( [string] . format ( self . cell_group_level , size ) ) [EOL] self . write ( [string] ) [EOL] self . generate_for ( if_d . condition ) [EOL] self . write_line ( [string] ) [EOL] self . indent ( ) [EOL] for node in if_d . body : [EOL] self . generate_for ( node ) [EOL] self . unindent ( ) [EOL] if if_d . else_block : [EOL] self . write_line ( [string] ) [EOL] self . indent ( ) [EOL] for node in if_d . else_block : [EOL] self . generate_for ( node ) [EOL] self . unindent ( ) [EOL] self . write_line ( [string] . format ( self . cell_group_level - [number] , if_d . base_cell [ [number] ] , if_d . base_cell [ [number] ] , self . cell_group_level , ) ) [EOL] self . cell_group_level -= [number] [EOL] [EOL] def generate_for_cellgroup ( self , cell_group ) : [EOL] self . cell_group_level += [number] [EOL] size = [string] . format ( cell_group . height , cell_group . width ) [EOL] self . write_line ( [string] . format ( self . cell_group_level , size ) ) [EOL] for node in cell_group . body : [EOL] self . generate_for ( node ) [EOL] self . write_line ( [string] . format ( self . cell_group_level - [number] , cell_group . base_cell [ [number] ] , cell_group . base_cell [ [number] ] , self . cell_group_level , ) ) [EOL] self . cell_group_level -= [number] [EOL] [EOL] def generate_for_cellloop ( self , cell_loop ) : [EOL] self . cell_group_level += [number] [EOL] size = [string] . format ( cell_loop . height , cell_loop . width ) [EOL] self . write_line ( [string] . format ( self . cell_group_level , size , cell_loop . direction ) ) [EOL] loop_ref = self . symbols . declare_ref ( [string] ) [EOL] if cell_loop . name : [EOL] self . symbols . add_ref ( [string] . format ( cell_loop . name ) , loop_ref ) [EOL] self . write ( [string] . format ( loop_ref ) ) [EOL] self . generate_for ( cell_loop . items ) [EOL] self . write_line ( [string] ) [EOL] target_ref = self . symbols . declare_ref ( cell_loop . target ) [EOL] self . write_line ( [string] . format ( target_ref , loop_ref ) ) [EOL] self . indent ( ) [EOL] self . cell_group_level += [number] [EOL] self . write_line ( [string] . format ( self . cell_group_level , size ) ) [EOL] for node in cell_loop . body : [EOL] self . generate_for ( node ) [EOL] self . write_line ( [string] . format ( self . cell_group_level - [number] , self . cell_group_level ) ) [EOL] self . cell_group_level -= [number] [EOL] self . unindent ( ) [EOL] self . write_line ( [string] . format ( self . cell_group_level - [number] , cell_loop . base_cell [ [number] ] , cell_loop . base_cell [ [number] ] , self . cell_group_level , ) ) [EOL] self . cell_group_level -= [number] [EOL] self . symbols . undeclare_ref ( [string] ) [EOL] self . symbols . undeclare_ref ( cell_loop . target ) [EOL] [EOL] def generate_for_funccelloutput ( self , func_cell_output ) : [EOL] self . write_line ( [string] ) [EOL] self . indent ( ) [EOL] for arg in func_cell_output . args : [EOL] self . generate_for ( arg ) [EOL] self . write_line ( [string] ) [EOL] self . unindent ( ) [EOL] self . write_line ( [string] ) [EOL] self . write ( [string] ) [EOL] self . generate_for ( func_cell_output . row_height ) [EOL] self . newline ( ) [EOL] self . write ( [string] ) [EOL] self . generate_for ( func_cell_output . col_width ) [EOL] self . newline ( ) [EOL] style = ( None [EOL] if func_cell_output . style is None [EOL] else [string] . format ( func_cell_output . style ) ) [EOL] self . write ( [string] . format ( func_cell_output . base_cell [ [number] ] , func_cell_output . base_cell [ [number] ] , style , func_cell_output . value , ) ) [EOL] if func_cell_output . default_value : [EOL] self . generate_for ( func_cell_output . default_value ) [EOL] else : [EOL] self . write ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] . format ( self . cell_group_level ) ) [EOL] if func_cell_output . merge : [EOL] self . generate_for_merge ( func_cell_output ) [EOL] [EOL] def generate_for_funcarg ( self , func_arg ) : [EOL] cells = [string] . join ( [string] . format ( cell [ [number] ] , cell [ [number] ] ) for cell in func_arg . cells ) [EOL] direction = [string] if func_arg . direction is None else str ( func_arg . direction ) [EOL] self . write ( [string] . format ( func_arg . start_index , func_arg . end_index , cells , direction ) ) [EOL] [EOL] def generate_for_merge ( self , cell_output ) : [EOL] self . write ( [string] . format ( self . cell_group_level , cell_output . base_cell [ [number] ] , cell_output . base_cell [ [number] ] , ) ) [EOL] if cell_output . merge . rows : [EOL] self . generate_for ( cell_output . merge . rows ) [EOL] else : [EOL] self . write ( [string] ) [EOL] self . write ( [string] ) [EOL] if cell_output . merge . cols : [EOL] self . generate_for ( cell_output . merge . cols ) [EOL] else : [EOL] self . write ( [string] ) [EOL] self . write_line ( [string] ) [EOL] [EOL] def generate_for_getattr ( self , get_attr ) : [EOL] self . write ( [string] ) [EOL] self . generate_for ( get_attr . obj ) [EOL] self . write ( [string] . format ( get_attr . attr_name ) ) [EOL] [EOL] def generate_for_getitem ( self , get_item ) : [EOL] self . write ( [string] ) [EOL] self . generate_for ( get_item . obj ) [EOL] self . write ( [string] ) [EOL] self . generate_for ( get_item . key ) [EOL] self . write ( [string] ) [EOL] [EOL] def generate_for_celloutput ( self , cell_output ) : [EOL] style = None if cell_output . style is None else [string] . format ( cell_output . style ) [EOL] self . write ( [string] ) [EOL] self . generate_for ( cell_output . row_height ) [EOL] self . newline ( ) [EOL] self . write ( [string] ) [EOL] self . generate_for ( cell_output . col_width ) [EOL] self . newline ( ) [EOL] self . write ( [string] . format ( cell_output . base_cell [ [number] ] , cell_output . base_cell [ [number] ] , style ) ) [EOL] if cell_output . value : [EOL] self . generate_for ( cell_output . value ) [EOL] else : [EOL] self . write ( [string] ) [EOL] self . write ( [string] ) [EOL] self . newline ( ) [EOL] self . write_line ( [string] . format ( self . cell_group_level ) ) [EOL] if cell_output . merge : [EOL] self . generate_for_merge ( cell_output ) [EOL] [EOL] def generate_for_call ( self , call_node ) : [EOL] self . generate_for ( call_node . obj ) [EOL] self . write ( [string] ) [EOL] for arg in call_node . args : [EOL] self . generate_for ( arg ) [EOL] self . write ( [string] ) [EOL] self . write ( [string] ) [EOL] [EOL] def generate_for_arg ( self , arg ) : [EOL] self . generate_for ( arg . value ) [EOL] [EOL] def generate_for_value ( self , value ) : [EOL] for child in value . body [ : - [number] ] : [EOL] self . generate_for ( child ) [EOL] self . write ( [string] ) [EOL] self . generate_for ( value . body [ - [number] ] ) [EOL] [EOL] def generate_for_const ( self , const ) : [EOL] self . write ( repr ( const . value ) ) [EOL] [EOL] def generate_for_strconst ( self , const ) : [EOL] self . write ( const . value ) [EOL] [EOL] def generate_for_filter ( self , filter_ ) : [EOL] self . write ( [string] . format ( filter_ . name ) ) [EOL] self . write ( [string] ) [EOL] self . generate_for ( filter_ . obj ) [EOL] self . write ( [string] ) [EOL] for arg in filter_ . args : [EOL] self . generate_for ( arg ) [EOL] self . write ( [string] ) [EOL] self . write ( [string] ) [EOL] [EOL] def generate_for_kwarg ( self , kwarg ) : [EOL] self . write ( [string] . format ( kwarg . name ) ) [EOL] self . generate_for ( kwarg . value ) [EOL] [EOL] def generate_for_tostr ( self , to_str ) : [EOL] self . write ( [string] ) [EOL] self . generate_for ( to_str . value ) [EOL] self . write ( [string] ) [EOL] [EOL] def generate_for_var ( self , var ) : [EOL] ref = self . symbols . find_ref ( var . name ) [EOL] if ref is not None : [EOL] res = ref [EOL] else : [EOL] res = [string] . format ( var . name ) [EOL] self . write ( res ) [EOL] [EOL] def generate_for_template ( self , template_node ) : [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . newline ( ) [EOL] self . write_line ( [string] ) [EOL] self . newline ( ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . newline ( ) [EOL] self . newline ( ) [EOL] self . write_line ( [string] ) [EOL] self . indent ( ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . indent ( ) [EOL] self . write_line ( [string] ) [EOL] self . unindent ( ) [EOL] self . newline ( ) [EOL] for child_node in template_node . body : [EOL] self . generate_for ( child_node ) [EOL] self . newline ( ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . write_line ( [string] ) [EOL] self . unindent ( ) [EOL] self . write_line ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import string [EOL] import collections [EOL] [EOL] [EOL] def col_str_to_int ( col ) : [EOL] final_column = [number] [EOL] for letter in col : [EOL] final_column = final_column * [number] + string . ascii_uppercase . index ( letter ) + [number] [EOL] return final_column [EOL] [EOL] [EOL] def cell_str_to_int ( row , col ) : [EOL] row = int ( row ) [EOL] return ( row , col_str_to_int ( col ) ) [EOL] [EOL] [EOL] def cell_int_to_str ( row , col ) : [EOL] return col_int_to_str ( col ) + str ( row ) [EOL] [EOL] [EOL] def col_int_to_str ( col ) : [EOL] res = [string] [EOL] while col > [number] : [EOL] col , reminder = divmod ( col , [number] ) [EOL] if reminder == [number] : [EOL] reminder = [number] [EOL] col -= [number] [EOL] res = string . ascii_uppercase [ reminder - [number] ] + res [EOL] return res [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class ParseError ( Exception ) : [EOL] def __init__ ( self , msg , source_hint , orig_exc = None ) : [EOL] self . msg = msg [EOL] self . source_hint = source_hint [EOL] self . orig_exc = orig_exc [EOL] [EOL] [EOL] class TemplateRuntimeException ( RuntimeError ) : [EOL] def __init__ ( self , msg , orig_exception = None ) : [EOL] super ( ) . __init__ ( msg ) [EOL] self . orig_exception = orig_exception [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Dict [EOL] import typing [EOL] import string [EOL] [EOL] import pyparsing as pp [EOL] from pyparsing import pyparsing_common as ppc [EOL] [EOL] from . import nodes , utils [EOL] [EOL] [EOL] LPAR , RPAR , LBRACK , RBRACK , DOT , EQ , COMMA , COLON = [ pp . Suppress ( _ ) for _ in [string] ] [EOL] [EOL] [EOL] hex_constant = pp . Regex ( [string] ) . addParseAction ( lambda t : int ( t [ [number] ] [ [number] : ] , [number] ) ) [EOL] int_constant = hex_constant | ppc . integer [EOL] double_constant = ppc . real [EOL] [EOL] [EOL] def double_constant_pa ( r ) : [EOL] return nodes . Const ( value = float ( r . asList ( ) [ [number] ] ) ) [EOL] [EOL] [EOL] double_constant . setParseAction ( double_constant_pa ) [EOL] string_constant = pp . quotedString [EOL] [EOL] [EOL] def string_constant_pa ( r ) : [EOL] res = r . asList ( ) [ [number] ] [EOL] return nodes . StrConst ( value = res ) [EOL] [EOL] [EOL] string_constant . setParseAction ( string_constant_pa ) [EOL] [EOL] boolean_constant = ( pp . Keyword ( [string] ) | pp . Keyword ( [string] ) | pp . Keyword ( [string] ) | pp . Keyword ( [string] ) ) [EOL] [EOL] [EOL] def boolean_constant_pa ( r ) : [EOL] res = r . asList ( ) [ [number] ] . lower ( ) [EOL] if res == [string] : [EOL] return nodes . Const ( value = True ) [EOL] else : [EOL] return nodes . Const ( value = False ) [EOL] [EOL] [EOL] boolean_constant . setParseAction ( boolean_constant_pa ) [EOL] [EOL] [EOL] constant = double_constant | int_constant | string_constant | boolean_constant [EOL] constant . setResultsName ( [string] ) [EOL] [EOL] [EOL] def constant_pa ( r ) : [EOL] return nodes . Const ( value = r . asList ( ) [ [number] ] ) [EOL] [EOL] [EOL] int_constant . setParseAction ( constant_pa ) [EOL] [EOL] [EOL] name = pp . Word ( pp . alphas + [string] , pp . alphanums + [string] ) [EOL] get_attr = DOT + name ( [string] ) [EOL] [EOL] [EOL] def get_attr_pa ( r ) : [EOL] return nodes . GetAttr ( attr_name = r . attr_name ) [EOL] [EOL] [EOL] get_attr . setParseAction ( get_attr_pa ) [EOL] [EOL] expr = pp . Forward ( ) [EOL] get_item = LBRACK + expr ( [string] ) + RBRACK [EOL] [EOL] [EOL] def get_item_pa ( r ) : [EOL] return nodes . GetItem ( key = r . key ) [EOL] [EOL] [EOL] get_item . setParseAction ( get_item_pa ) [EOL] [EOL] kwarg = name ( [string] ) + EQ + expr ( [string] ) [EOL] [EOL] [EOL] def kwarg_pa ( r ) : [EOL] return nodes . Kwarg ( name = r . name , value = r . value ) [EOL] [EOL] [EOL] kwarg . setParseAction ( kwarg_pa ) [EOL] [EOL] arg = expr ( [string] ) [EOL] [EOL] [EOL] def arg_pa ( r ) : [EOL] return nodes . Arg ( value = r . asList ( ) [ [number] ] ) [EOL] [EOL] [EOL] arg . setParseAction ( arg_pa ) [EOL] [EOL] call_args = pp . delimitedList ( kwarg | arg ) [EOL] call = LPAR + pp . Group ( pp . Optional ( call_args ) ) ( [string] ) + RPAR [EOL] [EOL] [EOL] def call_pa ( r ) : [EOL] return nodes . Call ( args = r . asList ( ) [ [number] ] ) [EOL] [EOL] [EOL] call . setParseAction ( call_pa ) [EOL] [EOL] var = name ( [string] ) [EOL] [EOL] [EOL] def var_pa ( r ) : [EOL] return nodes . Var ( name = r . asList ( ) [ [number] ] ) [EOL] [EOL] [EOL] var . setParseAction ( var_pa ) [EOL] [EOL] expr << ( ( constant | var ) + pp . ZeroOrMore ( get_attr | get_item | call ) ) [EOL] [EOL] [EOL] def expr_pa ( r ) : [EOL] obj = None [EOL] r = r . asList ( ) [EOL] for part in r : [EOL] if obj is not None : [EOL] part . obj = obj [EOL] obj = part [EOL] return obj [EOL] [EOL] [EOL] expr . setParseAction ( expr_pa ) [EOL] [EOL] filter_expr = name ( [string] ) + pp . Optional ( LPAR + pp . Group ( pp . Optional ( call_args ) ) ( [string] ) + RPAR ) [EOL] [EOL] [EOL] def filter_expr_pa ( r ) : [EOL] return nodes . Filter ( name = r . name , args = r . args ) [EOL] [EOL] [EOL] filter_expr . setParseAction ( filter_expr_pa ) [EOL] [EOL] expr_with_filter = expr + pp . ZeroOrMore ( pp . Suppress ( [string] ) + filter_expr ) [EOL] [EOL] [EOL] expr_with_filter . setParseAction ( expr_pa ) [EOL] [EOL] [EOL] def parse_expr_with_filter ( s ) : [EOL] return expr_with_filter . parseString ( s , True ) . asList ( ) [ [number] ] [EOL] [EOL] [EOL] cell = pp . Word ( pp . alphas . upper ( ) ) ( [string] ) + pp . Word ( pp . nums ) ( [string] ) [EOL] [EOL] [EOL] def cell_pa ( r ) : [EOL] res = ( int ( r [ [string] ] ) , utils . col_str_to_int ( r [ [string] ] ) ) [EOL] return res [EOL] [EOL] [EOL] cell . setParseAction ( cell_pa ) [EOL] [EOL] [EOL] cell_range = cell ( [string] ) + COLON + cell ( [string] ) [EOL] [EOL] [EOL] def cell_range_pa ( r ) : [EOL] return r . asList ( ) [EOL] [EOL] [EOL] cell_range . setParseAction ( cell_range_pa ) [EOL] [EOL] [EOL] def param_pa ( r ) : [EOL] r = r . asList ( ) [EOL] res = { [string] : r [ [number] ] , [string] : r [ [number] : ] } [EOL] if len ( res [ [string] ] ) == [number] : [EOL] res [ [string] ] = res [ [string] ] [ [number] ] [EOL] return res [EOL] [EOL] [EOL] def make_param ( param_name , param_value ) : [EOL] r = pp . Keyword ( param_name ) + EQ + param_value [EOL] r . setParseAction ( param_pa ) [EOL] return r [EOL] [EOL] [EOL] for_statement = ( pp . Keyword ( [string] ) . suppress ( ) + name ( [string] ) + pp . Keyword ( [string] ) . suppress ( ) + expr ( [string] ) ) [EOL] [EOL] [EOL] def for_statement_pa ( r ) : [EOL] return { [string] : r [ [string] ] , [string] : r [ [string] ] } [EOL] [EOL] [EOL] for_statement . setParseAction ( for_statement_pa ) [EOL] [EOL] cell_loop = for_statement ( [string] ) + pp . Group ( pp . Optional ( COMMA + pp . delimitedList ( make_param ( [string] , name ) | make_param ( [string] , cell ) ) ) ) ( [string] ) [EOL] [EOL] [EOL] def cell_loop_pa ( r ) : [EOL] keywords = { param [ [string] ] : param [ [string] ] for param in r [ [string] ] . asList ( ) } [EOL] return nodes . CellLoop ( target = r [ [string] ] [ [string] ] , items = r [ [string] ] [ [string] ] , ** keywords ) [EOL] [EOL] [EOL] cell_loop . setParseAction ( cell_loop_pa ) [EOL] [EOL] [EOL] def parse_cell_loop_directive ( s ) : [EOL] return cell_loop . parseString ( s , True ) . asList ( ) [ [number] ] [EOL] [EOL] [EOL] merge = pp . delimitedList ( make_param ( [string] , expr ) | make_param ( [string] , expr ) ) [EOL] [EOL] [EOL] def merge_pa ( r ) : [EOL] return nodes . Merge ( ** { param [ [string] ] : param [ [string] ] for param in r . asList ( ) } ) [EOL] [EOL] [EOL] merge . setParseAction ( merge_pa ) [EOL] [EOL] [EOL] def parse_merge ( s ) : [EOL] return merge . parseString ( s , True ) . asList ( ) [ [number] ] [EOL] [EOL] [EOL] group = pp . delimitedList ( make_param ( [string] , cell ) ) [EOL] [EOL] [EOL] def group_pa ( r ) : [EOL] return nodes . CellGroup ( ** { param [ [string] ] : param [ [string] ] for param in r . asList ( ) } ) [EOL] [EOL] [EOL] group . setParseAction ( group_pa ) [EOL] [EOL] [EOL] def parse_group ( s ) : [EOL] return group . parseString ( s , True ) . asList ( ) [ [number] ] [EOL] [EOL] [EOL] remove = pp . Optional ( make_param ( [string] , cell ) ) [EOL] [EOL] [EOL] def remove_pa ( r ) : [EOL] params = { param [ [string] ] : param [ [string] ] for param in r . asList ( ) } [EOL] return nodes . Remove ( ** params ) [EOL] [EOL] [EOL] remove . setParseAction ( remove_pa ) [EOL] [EOL] [EOL] def parse_remove ( s ) : [EOL] return remove . parseString ( s , True ) . asList ( ) [ [number] ] [EOL] [EOL] [EOL] excel_func_arg = cell_range | cell [EOL] [EOL] [EOL] def excel_func_arg_pa ( r ) : [EOL] return r . asList ( ) [EOL] [EOL] [EOL] excel_func_arg . setParseAction ( excel_func_arg_pa ) [EOL] [EOL] [EOL] excel_func_args = pp . ZeroOrMore ( excel_func_arg ) [EOL] [EOL] [EOL] def parse_func_args ( s ) : [EOL] return [ ( ( start_index , end_index ) , parse_res ) for ( parse_res , start_index , end_index ) in excel_func_args . scanString ( s ) ] [EOL] [EOL] [EOL] if_d = pp . delimitedList ( make_param ( [string] , expr ) | make_param ( [string] , cell ) | make_param ( [string] , excel_func_arg ) ) [EOL] [EOL] [EOL] def if_pa ( r ) : [EOL] params = { param [ [string] ] : param [ [string] ] for param in r . asList ( ) } [EOL] params [ [string] ] = params . pop ( [string] , None ) [EOL] return nodes . If ( ** params ) [EOL] [EOL] [EOL] if_d . setParseAction ( if_pa ) [EOL] [EOL] [EOL] def parse_if ( s ) : [EOL] return if_d . parseString ( s , True ) . asList ( ) [ [number] ] [EOL] [EOL] [EOL] def parse_col_width ( s ) : [EOL] return nodes . ColWidth ( value = parse_expr_with_filter ( s ) ) [EOL] [EOL] [EOL] def parse_row_height ( s ) : [EOL] return nodes . RowHeight ( value = parse_expr_with_filter ( s ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . template import Template [EOL]	0 0 0 0 0 0
from typing import Any [EOL] import xlsx_template [EOL] import typing [EOL] import tempfile [EOL] import os [EOL] [EOL] from xlsx_template . parser import Parser [EOL] from xlsx_template . code_generator import CodeGenerator [EOL] from xlsx_template . environment import Environment [EOL] from xlsx_template . runtime . context import Context [EOL] [EOL] [EOL] class Template : [EOL] def __init__ ( self , source , env = None , debug = False ) : [EOL] if env is None : [EOL] env = Environment ( ) [EOL] self . env = env [EOL] if hasattr ( source , [string] ) : [EOL] source = source . read ( ) [EOL] parser = Parser ( source ) [EOL] self . root_node , self . styles = parser . parse ( ) [EOL] code_source = CodeGenerator ( ) . generate ( self . root_node ) [EOL] if debug : [EOL] fd , self . debug_file_name = tempfile . mkstemp ( suffix = [string] ) [EOL] filename = self . debug_file_name [EOL] with open ( fd , [string] ) as f : [EOL] f . write ( code_source ) [EOL] self . code_source = code_source [EOL] else : [EOL] filename = [string] [EOL] source = compile ( code_source , filename , [string] ) [EOL] self . namespace = { } [EOL] exec ( source , self . namespace ) [EOL] [EOL] def render ( self , context_data ) : [EOL] return self . namespace [ [string] ] ( Context ( context_data , self . env ) , self . styles , self . env ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $xlsx_template.parser.Parser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $xlsx_template.parser.Parser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import xlsx_template [EOL] from . exceptions import TemplateRuntimeException [EOL] from . import filters [EOL] from . parser import Parser [EOL] [EOL] [EOL] class StrictResolveStrategy : [EOL] def resolve ( self , obj , name , found ) : [EOL] if not found : [EOL] raise Unresolved ( [string] . format ( name ) ) [EOL] return obj [EOL] [EOL] [EOL] class StrictGetAttrStrategy : [EOL] def get_attr ( self , obj , attr_name ) : [EOL] try : [EOL] return getattr ( obj , attr_name ) [EOL] except AttributeError as e : [EOL] raise TemplateRuntimeException ( [string] . format ( attr_name , obj ) , e ) [EOL] [EOL] [EOL] class SoftGetAttrStrategy : [EOL] def get_attr ( self , obj , attr_name ) : [EOL] exc = None [EOL] try : [EOL] return getattr ( obj , attr_name ) [EOL] except AttributeError as e : [EOL] exc = e [EOL] try : [EOL] return obj [ attr_name ] [EOL] except Exception as e : [EOL] exc = exc or e [EOL] raise TemplateRuntimeException ( [string] . format ( attr_name , obj ) , exc ) [EOL] [EOL] [EOL] class StrictGetItemStrategy : [EOL] def get_item ( self , obj , key ) : [EOL] try : [EOL] return obj [ key ] [EOL] except Exception as e : [EOL] raise TemplateRuntimeException ( [string] . format ( key , obj ) , e ) [EOL] [EOL] [EOL] class Environment : [EOL] [EOL] filters = { [string] : filters . default_if_none , [string] : filters . yes_no } [EOL] [EOL] def __init__ ( self , resolve_strategy = None , get_attr_strategy = None , get_item_strategy = None ) : [EOL] if resolve_strategy is None : [EOL] resolve_strategy = StrictResolveStrategy ( ) [EOL] [EOL] if get_attr_strategy is None : [EOL] get_attr_strategy = SoftGetAttrStrategy ( ) [EOL] [EOL] if get_item_strategy is None : [EOL] get_item_strategy = StrictGetItemStrategy ( ) [EOL] [EOL] self . resolve_strategy = resolve_strategy [EOL] self . get_attr_strategy = get_attr_strategy [EOL] self . get_item_strategy = get_item_strategy [EOL] [EOL] def resolve ( self , obj , name , found ) : [EOL] return self . resolve_strategy . resolve ( obj , name , found ) [EOL] [EOL] def get_attr ( self , obj , attr_name ) : [EOL] return self . get_attr_strategy . get_attr ( obj , attr_name ) [EOL] [EOL] def get_item ( self , obj , key ) : [EOL] return self . get_item_strategy . get_item ( obj , key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import enum [EOL] [EOL] [EOL] class LoopDirection ( enum . Enum ) : [EOL] DOWN = [string] [EOL] RIGHT = [string] [EOL] [EOL] [EOL] class FuncArgDirection ( enum . Enum ) : [EOL] HORIZONTAL = [string] [EOL] VERTICAL = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Type , Any , List , Dict , Union , Tuple [EOL] import typing [EOL] import xlsx_template [EOL] import copy [EOL] import io [EOL] [EOL] import pyparsing [EOL] from openpyxl import load_workbook , styles [EOL] [EOL] from . import grammar , nodes , utils [EOL] from . consts import LoopDirection , FuncArgDirection [EOL] from . exceptions import ParseError [EOL] [EOL] [EOL] class Parser : [EOL] def __init__ ( self , source , filename = None ) : [EOL] self . wb = load_workbook ( io . BytesIO ( source ) ) [EOL] self . source_hint = [ [string] . format ( filename ) ] if filename else [ ] [EOL] [EOL] def parse ( self ) : [EOL] template = nodes . Template ( body = [ ] ) [EOL] self . styles = { } [EOL] for sheet_name in self . wb . sheetnames : [EOL] self . source_hint . append ( [string] . format ( sheet_name ) ) [EOL] ws = self . wb [ sheet_name ] [EOL] self . cells = { } [EOL] self . merged_cells = { } [EOL] self . post_remove = [ ] [EOL] self . original_cell_groups = { } [EOL] for cr in ws . merged_cells : [EOL] self . merged_cells [ ( cr . min_row , cr . min_col ) ] = ( cr . max_row - cr . min_row + [number] , cr . max_col - cr . min_col + [number] , ) [EOL] for row in range ( [number] , ws . max_row + [number] ) : [EOL] for col in range ( [number] , ws . max_column + [number] ) : [EOL] self . source_hint . append ( [string] . format ( utils . cell_int_to_str ( row , col ) ) ) [EOL] node = self . parse_cell ( ws , row , col ) [EOL] self . source_hint . pop ( ) [EOL] self . cells [ ( row , col ) ] = node [EOL] directives = self . get_directives ( ws ) [EOL] self . directives = self . parse_directives ( directives ) [EOL] body = self . _process_cell_group ( [number] , [number] , ws . max_row , ws . max_column ) [EOL] self . source_hint . append ( [string] ) [EOL] sheet_name_node = self . parse_value ( sheet_name ) [EOL] self . source_hint . pop ( ) [EOL] sheet_node = nodes . Sheet ( name = nodes . ToStr ( value = sheet_name_node ) , max_row = ws . max_row , max_col = ws . max_column , body = body , ) [EOL] self . source_hint . pop ( ) [EOL] [EOL] assert not self . source_hint [EOL] if self . post_remove : [EOL] for start_cell , end_cell in self . post_remove : [EOL] target_cell_group = None [EOL] target_cell = None [EOL] for ( row , col ) , cell_group in self . original_cell_groups . items ( ) : [EOL] if ( start_cell [ [number] ] >= row [EOL] and start_cell [ [number] ] >= col [EOL] and end_cell [ [number] ] <= row + cell_group . height [EOL] and end_cell [ [number] ] <= col + cell_group . width ) : [EOL] target_cell_group = cell_group [EOL] target_cell = ( row , col ) [EOL] assert target_cell_group is not None [EOL] target_cell_group . body . append ( nodes . Remove ( base_cell = ( start_cell [ [number] ] - target_cell [ [number] ] , start_cell [ [number] ] - target_cell [ [number] ] , ) , last_cell = ( end_cell [ [number] ] - target_cell [ [number] ] , end_cell [ [number] ] - target_cell [ [number] ] , ) , ) ) [EOL] template . body . append ( sheet_node ) [EOL] del self . post_remove [EOL] del self . original_cell_groups [EOL] return template , list ( self . styles . values ( ) ) [EOL] [EOL] def _process_cell_group ( self , start_row , start_col , end_row , end_col ) : [EOL] body = [ ] [EOL] for row in range ( start_row , end_row + [number] ) : [EOL] for col in range ( start_col , end_col + [number] ) : [EOL] if ( row , col ) in self . directives and self . directives [ ( row , col ) ] : [EOL] cur_directives = self . directives [ ( row , col ) ] [EOL] cur_directive = cur_directives . pop ( [number] ) [EOL] if not cur_directives : [EOL] del self . directives [ ( row , col ) ] [EOL] method = getattr ( self , [string] . format ( cur_directive . __class__ . __name__ . lower ( ) ) , ) [EOL] cur_directive = method ( cur_directive ) [EOL] if cur_directive is not None : [EOL] if isinstance ( cur_directive , nodes . CellGroup ) : [EOL] self . original_cell_groups [ ( row , col ) ] = cur_directive [EOL] cur_directive . adjust ( - start_row , - start_col ) [EOL] body . append ( cur_directive ) [EOL] if ( row , col ) in self . cells : [EOL] cell = self . cells . pop ( ( row , col ) ) [EOL] cell . adjust ( - start_row , - start_col ) [EOL] body . append ( cell ) [EOL] return body [EOL] [EOL] def _process_cellloop ( self , cell_loop ) : [EOL] cell_loop . body = self . _process_cell_group ( cell_loop . base_cell [ [number] ] , cell_loop . base_cell [ [number] ] , cell_loop . last_cell [ [number] ] , cell_loop . last_cell [ [number] ] , ) [EOL] return cell_loop [EOL] [EOL] def parse_directives ( self , directives ) : [EOL] res_directives = { } [EOL] for ( row , col ) , directives in directives . items ( ) : [EOL] self . source_hint . append ( [string] . format ( utils . cell_int_to_str ( row , col ) ) ) [EOL] res_directives [ ( row , col ) ] = [ ] [EOL] for index , directive in enumerate ( directives ) : [EOL] self . source_hint . append ( [string] . format ( index ) ) [EOL] res_directives [ ( row , col ) ] . append ( self . parse_directive ( row , col , directive ) ) [EOL] self . source_hint . pop ( ) [EOL] self . source_hint . pop ( ) [EOL] return res_directives [EOL] [EOL] def parse_directive ( self , row , col , directive ) : [EOL] if [string] in directive : [EOL] directive_name , tail = directive . split ( [string] , [number] ) [EOL] else : [EOL] directive_name , tail = directive , [string] [EOL] directive_name = directive_name . lower ( ) . replace ( [string] , [string] ) [EOL] method = getattr ( self , [string] . format ( directive_name ) , None ) [EOL] if method is None : [EOL] raise ParseError ( [string] . format ( directive_name ) , self . source_hint ) [EOL] node = method ( tail ) [EOL] node . base_cell = ( row , col ) [EOL] if hasattr ( node , [string] ) : [EOL] if node . last_cell is None : [EOL] node . last_cell = node . base_cell [EOL] if len ( node . last_cell ) == [number] : [EOL] node . last_cell = node . last_cell [ [number] ] [EOL] return node [EOL] [EOL] def parse_merge ( self , directive_def ) : [EOL] return self . _parse_pp ( grammar . parse_merge , directive_def ) [EOL] [EOL] def _process_merge ( self , merge ) : [EOL] cell_output = self . cells [ merge . base_cell ] [EOL] cell_output . merge = merge [EOL] [EOL] def parse_group ( self , directive_def ) : [EOL] return self . _parse_pp ( grammar . parse_group , directive_def ) [EOL] [EOL] def parse_remove ( self , directive_def ) : [EOL] return self . _parse_pp ( grammar . parse_remove , directive_def ) [EOL] [EOL] def _process_remove ( self , remove ) : [EOL] for cell in remove . get_cell_range ( ) : [EOL] self . directives . pop ( cell , None ) [EOL] self . cells . pop ( cell , None ) [EOL] return remove [EOL] [EOL] def parse_if ( self , directive_def ) : [EOL] return self . _parse_pp ( grammar . parse_if , directive_def ) [EOL] [EOL] def parse_col_width ( self , directive_def ) : [EOL] return self . _parse_pp ( grammar . parse_col_width , directive_def ) [EOL] [EOL] def parse_row_height ( self , directive_def ) : [EOL] return self . _parse_pp ( grammar . parse_row_height , directive_def ) [EOL] [EOL] def _process_colwidth ( self , col_width ) : [EOL] self . cells [ col_width . base_cell ] . col_width = col_width . value [EOL] [EOL] def _process_rowheight ( self , row_height ) : [EOL] self . cells [ row_height . base_cell ] . row_height = row_height . value [EOL] [EOL] def _process_if ( self , if_d ) : [EOL] if_d . body = self . _process_cell_group ( if_d . base_cell [ [number] ] , if_d . base_cell [ [number] ] , if_d . last_cell [ [number] ] , if_d . last_cell [ [number] ] ) [EOL] if if_d . else_block : [EOL] start_cell = if_d . else_block [ [number] ] [EOL] if len ( if_d . else_block ) == [number] : [EOL] end_cell = if_d . else_block [ [number] ] [EOL] else : [EOL] end_cell = start_cell [EOL] if_d . else_block = self . _process_cell_group ( start_cell [ [number] ] , start_cell [ [number] ] , end_cell [ [number] ] , end_cell [ [number] ] ) [EOL] self . post_remove . append ( ( start_cell , end_cell ) ) [EOL] return if_d [EOL] [EOL] def _process_cellgroup ( self , cell_group ) : [EOL] cell_group . body = self . _process_cell_group ( cell_group . base_cell [ [number] ] , cell_group . base_cell [ [number] ] , cell_group . last_cell [ [number] ] , cell_group . last_cell [ [number] ] , ) [EOL] return cell_group [EOL] [EOL] def parse_func_arg_v ( self , directive_def ) : [EOL] return nodes . FuncArgDirection ( direction = FuncArgDirection . VERTICAL ) [EOL] [EOL] def parse_func_arg_h ( self , directive_def ) : [EOL] return nodes . FuncArgDirection ( direction = FuncArgDirection . HORIZONTAL ) [EOL] [EOL] def _process_funcargdirection ( self , func_arg_dir ) : [EOL] cell = ( func_arg_dir . base_cell [ [number] ] , func_arg_dir . base_cell [ [number] ] ) [EOL] func_cell = self . cells . get ( cell ) [EOL] assert isinstance ( func_cell , nodes . FuncCellOutput ) , [string] [EOL] for arg in func_cell . args : [EOL] arg . direction = func_arg_dir . direction [EOL] assert ( self . directives . get ( cell ) is None ) , [string] [EOL] [EOL] def parse_loop_right ( self , directive_def ) : [EOL] return self . _parse_cell_loop ( directive_def , LoopDirection . RIGHT ) [EOL] [EOL] def parse_loop_down ( self , directive_def ) : [EOL] return self . _parse_cell_loop ( directive_def , LoopDirection . DOWN ) [EOL] [EOL] def _parse_cell_loop ( self , directive_def , loop_direction ) : [EOL] node = self . _parse_pp ( grammar . parse_cell_loop_directive , directive_def ) [EOL] node . direction = loop_direction [EOL] if node . last_cell is None : [EOL] node . last_cell = node . base_cell [EOL] return node [EOL] [EOL] def get_directives ( self , ws ) : [EOL] directives = { } [EOL] for row in range ( [number] , ws . max_row + [number] ) : [EOL] for col in range ( [number] , ws . max_column + [number] ) : [EOL] cell = ws . cell ( row , col ) [EOL] if cell . comment and cell . comment . text : [EOL] lines = [ line . strip ( ) for line in cell . comment . text . splitlines ( ) ] [EOL] lines = [ line for line in lines if line ] [EOL] if lines [ [number] ] . lower ( ) == [string] : [EOL] v2_directives = self . get_directives_synt_v2 ( lines [ [number] : ] ) [EOL] for ( row , col ) , cell_directives in v2_directives . items ( ) : [EOL] if ( row , col ) not in directives : [EOL] directives [ ( row , col ) ] = [ ] [EOL] directives [ ( row , col ) ] . extend ( cell_directives ) [EOL] else : [EOL] directives [ ( row , col ) ] = lines [EOL] return directives [EOL] [EOL] def get_directives_synt_v2 ( self , lines ) : [EOL] state = [number] [EOL] current_cell = None [EOL] res_directives = { } [EOL] for line in lines : [EOL] if state == [number] : [EOL] current_cell = grammar . cell . parseString ( line , True ) [ [number] ] [EOL] state = [number] [EOL] else : [EOL] if all ( c == [string] for c in line ) : [EOL] state = [number] [EOL] else : [EOL] if current_cell not in res_directives : [EOL] res_directives [ current_cell ] = [ ] [EOL] res_directives [ current_cell ] . append ( line ) [EOL] return res_directives [EOL] [EOL] def _parse_pp ( self , pp , s ) : [EOL] try : [EOL] return pp ( s ) [EOL] except pyparsing . ParseBaseException as e : [EOL] msg = [string] . format ( s ) [EOL] raise ParseError ( msg , self . source_hint , e ) [EOL] [EOL] def parse_expression ( self , expr ) : [EOL] node = self . _parse_pp ( grammar . parse_expr_with_filter , expr ) [EOL] return node [EOL] [EOL] def parse_value ( self , value ) : [EOL] if not isinstance ( value , str ) or [string] not in value : [EOL] return nodes . Const ( value = value ) [EOL] else : [EOL] body = [ ] [EOL] index = [number] [EOL] while index < len ( value ) : [EOL] start_var_index = value . find ( [string] , index ) [EOL] [comment] [EOL] if start_var_index - index == [number] : [EOL] end_var_index = value . find ( [string] , start_var_index ) [EOL] if end_var_index != - [number] : [EOL] self . source_hint . append ( [string] . format ( start_var_index + [number] , end_var_index ) ) [EOL] body . append ( self . parse_expression ( value [ start_var_index + [number] : end_var_index ] ) ) [EOL] self . source_hint . pop ( ) [EOL] index = end_var_index + [number] [EOL] else : [EOL] body . append ( nodes . Const ( value = value [ index : ] ) ) [EOL] index = len ( value ) [EOL] else : [EOL] body . append ( nodes . Const ( value = value [ : start_var_index ] ) ) [EOL] index = start_var_index [EOL] if len ( body ) != [number] : [EOL] body = [ nodes . ToStr ( value = child ) [EOL] if not isinstance ( child , nodes . Const ) [EOL] else child for child in body ] [EOL] return nodes . Value ( body = body ) [EOL] [EOL] def parse_cell ( self , ws , row , col ) : [EOL] cell = ws . cell ( row , col ) [EOL] style_name = None [EOL] if cell . has_style : [EOL] style_key = ( copy . copy ( cell . font ) , copy . copy ( cell . fill ) , copy . copy ( cell . border ) , copy . copy ( cell . alignment ) , copy . copy ( cell . number_format ) , copy . copy ( cell . protection ) , ) [EOL] if style_key not in self . styles : [EOL] new_style_name = [string] . format ( len ( self . styles ) ) [EOL] new_style = styles . NamedStyle ( new_style_name ) [EOL] new_style . font = style_key [ [number] ] [EOL] new_style . fill = style_key [ [number] ] [EOL] new_style . border = style_key [ [number] ] [EOL] new_style . alignment = style_key [ [number] ] [EOL] new_style . number_format = style_key [ [number] ] [EOL] new_style . protection = style_key [ [number] ] [EOL] self . styles [ style_key ] = new_style [EOL] style_name = new_style_name [EOL] else : [EOL] style_name = self . styles [ style_key ] . name [EOL] col_letter = utils . col_int_to_str ( col ) [EOL] col_width = ws . column_dimensions [ col_letter ] . width [EOL] col_index = col [EOL] while not col_width : [EOL] col_letter = utils . col_int_to_str ( col_index ) [EOL] col_width = ws . column_dimensions [ col_letter ] . width [EOL] col_index -= [number] [EOL] node_kwargs = { [string] : ( row , col ) , [string] : style_name , [string] : nodes . Const ( value = ws . row_dimensions [ row ] . height ) , [string] : nodes . Const ( value = col_width ) , } [EOL] node_class = nodes . CellOutput [EOL] if cell . value : [EOL] if isinstance ( cell . value , str ) and cell . value . startswith ( [string] ) : [EOL] value = cell . value [EOL] node_kwargs [ [string] ] = self . parse_func_args ( value ) [EOL] node_class = nodes . FuncCellOutput [EOL] else : [EOL] value = self . parse_value ( cell . value ) [EOL] else : [EOL] value = None [EOL] node_kwargs [ [string] ] = value [EOL] if ( row , col ) in self . merged_cells : [EOL] node_kwargs [ [string] ] = nodes . Merge ( rows = nodes . Const ( value = self . merged_cells [ ( row , col ) ] [ [number] ] ) , cols = nodes . Const ( value = self . merged_cells [ ( row , col ) ] [ [number] ] ) , ) [EOL] cell_output = node_class ( ** node_kwargs ) [EOL] return cell_output [EOL] [EOL] def parse_func_args ( self , s ) : [EOL] res = [ ] [EOL] for ( start_index , end_index ) , cell_def in grammar . parse_func_args ( s ) : [EOL] if len ( cell_def ) == [number] : [EOL] cells = cell_def [EOL] else : [EOL] cells = [ ( row , col ) for row in range ( cell_def [ [number] ] [ [number] ] , cell_def [ [number] ] [ [number] ] + [number] ) for col in range ( cell_def [ [number] ] [ [number] ] , cell_def [ [number] ] [ [number] ] + [number] ) ] [EOL] res . append ( nodes . FuncArg ( start_index = start_index , end_index = end_index , cells = cells ) ) [EOL] return res [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $xlsx_template.nodes.Template$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $xlsx_template.nodes.Sheet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $xlsx_template.nodes.Template$ 0 $typing.Any$ 0 0 0 $xlsx_template.nodes.Sheet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $xlsx_template.nodes.Template$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[xlsx_template.nodes.Const,xlsx_template.nodes.ToStr]]$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Union[xlsx_template.nodes.Const,xlsx_template.nodes.ToStr]]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Union[xlsx_template.nodes.Const,xlsx_template.nodes.ToStr]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[xlsx_template.nodes.Const,xlsx_template.nodes.ToStr]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Union[xlsx_template.nodes.Const,xlsx_template.nodes.ToStr]]$ 0 0 0 0 0 $typing.List[typing.Union[xlsx_template.nodes.Const,xlsx_template.nodes.ToStr]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[xlsx_template.nodes.Const,xlsx_template.nodes.ToStr]]$ 0 0 0 0 0 0 0 $typing.List[typing.Union[xlsx_template.nodes.Const,xlsx_template.nodes.ToStr]]$ 0 $typing.List[typing.Union[xlsx_template.nodes.Const,xlsx_template.nodes.ToStr]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[unknown,unknown,unknown,unknown,unknown,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Type[xlsx_template.nodes.FuncCellOutput]$ 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 $None$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 $None$ 0 0 $typing.Type[xlsx_template.nodes.FuncCellOutput]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $xlsx_template.nodes.CellOutput$ 0 $typing.Type[xlsx_template.nodes.FuncCellOutput]$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $xlsx_template.nodes.CellOutput$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import Any , Type , Dict [EOL] import typing [EOL] import xlsx_template [EOL] class NodeMetaclass ( type ) : [EOL] def __new__ ( cls , name , bases , attrs ) : [EOL] if bases : [EOL] base = bases [ [number] ] [EOL] attributes = base . attributes . copy ( ) [EOL] else : [EOL] attributes = { } [EOL] attributes . update ( { key : value for key , value in attrs . items ( ) if not key . startswith ( [string] ) and key != [string] } ) [EOL] attrs [ [string] ] = attributes [EOL] return super ( ) . __new__ ( cls , name , bases , attrs ) [EOL] [EOL] [EOL] class Node ( metaclass = NodeMetaclass ) : [EOL] attributes = [ ] [EOL] [EOL] def __init__ ( self , ** kwargs ) : [EOL] for attr_name , value in kwargs . items ( ) : [EOL] if attr_name not in self . attributes : [EOL] raise RuntimeError ( [string] . format ( attr_name ) ) [EOL] setattr ( self , attr_name , value ) [EOL] [EOL] [EOL] class Const ( Node ) : [EOL] value = None [EOL] [EOL] [EOL] class StrConst ( Const ) : [EOL] pass [EOL] [EOL] [EOL] class Var ( Node ) : [EOL] name = None [EOL] [EOL] [EOL] class Value ( Node ) : [EOL] body = None [EOL] [EOL] [EOL] class ToStr ( Node ) : [EOL] value = None [EOL] [EOL] [EOL] class BaseObjNode ( Node ) : [EOL] obj = None [EOL] [EOL] [EOL] class GetAttr ( BaseObjNode ) : [EOL] attr_name = None [EOL] [EOL] [EOL] class GetItem ( BaseObjNode ) : [EOL] key = None [EOL] [EOL] [EOL] class Arg ( Node ) : [EOL] value = None [EOL] [EOL] [EOL] class Kwarg ( Node ) : [EOL] name = None [EOL] value = None [EOL] [EOL] [EOL] class Call ( BaseObjNode ) : [EOL] args = None [EOL] [EOL] [EOL] class Filter ( BaseObjNode ) : [EOL] name = None [EOL] args = None [EOL] [EOL] [EOL] class Template ( Node ) : [EOL] body = None [EOL] [EOL] [EOL] class CellOutput ( Node ) : [EOL] base_cell = None [EOL] value = None [EOL] style = None [EOL] row_height = None [EOL] col_width = None [EOL] merge = None [EOL] [EOL] def adjust ( self , row , col ) : [EOL] self . base_cell = ( self . base_cell [ [number] ] + row , self . base_cell [ [number] ] + col ) [EOL] [EOL] [EOL] class CellGroup ( Node ) : [EOL] base_cell = None [EOL] last_cell = None [EOL] body = None [EOL] [EOL] def adjust ( self , row , col ) : [EOL] self . base_cell = ( self . base_cell [ [number] ] + row , self . base_cell [ [number] ] + col ) [EOL] self . last_cell = ( self . last_cell [ [number] ] + row , self . last_cell [ [number] ] + col ) [EOL] [EOL] @ property def height ( self ) : [EOL] return self . last_cell [ [number] ] - self . base_cell [ [number] ] + [number] [EOL] [EOL] @ property def width ( self ) : [EOL] return self . last_cell [ [number] ] - self . base_cell [ [number] ] + [number] [EOL] [EOL] def get_cell_range ( self ) : [EOL] for row in range ( self . base_cell [ [number] ] , self . last_cell [ [number] ] + [number] ) : [EOL] for col in range ( self . base_cell [ [number] ] , self . last_cell [ [number] ] + [number] ) : [EOL] yield ( row , col ) [EOL] [EOL] [EOL] class Remove ( CellGroup ) : [EOL] pass [EOL] [EOL] [EOL] class If ( CellGroup ) : [EOL] condition = None [EOL] else_block = None [EOL] [EOL] [EOL] class Sheet ( CellGroup ) : [EOL] name = None [EOL] [EOL] def __init__ ( self , name , max_row , max_col , body ) : [EOL] super ( ) . __init__ ( base_cell = ( [number] , [number] ) , last_cell = ( max_row - [number] , max_col - [number] ) , body = body ) [EOL] self . name = name [EOL] [EOL] [EOL] class CellLoop ( CellGroup ) : [EOL] target = None [EOL] items = None [EOL] name = None [EOL] body = None [EOL] direction = None [EOL] [EOL] [EOL] class FuncArg ( Node ) : [EOL] start_index = None [EOL] end_index = None [EOL] cells = None [EOL] direction = None [EOL] [EOL] [EOL] class Merge ( Node ) : [EOL] rows = None [EOL] cols = None [EOL] [EOL] [EOL] class FuncArgDirection ( Node ) : [EOL] direction = None [EOL] [EOL] [EOL] class FuncCellOutput ( CellOutput ) : [EOL] default_value = None [EOL] args = None [EOL] [EOL] def adjust ( self , row , col ) : [EOL] for arg in self . args : [EOL] arg . cells = [ ( cell [ [number] ] - self . base_cell [ [number] ] , cell [ [number] ] - self . base_cell [ [number] ] ) for cell in arg . cells ] [EOL] super ( ) . adjust ( row , col ) [EOL] [EOL] [EOL] class ColWidth ( Node ) : [EOL] value = None [EOL] [EOL] [EOL] class RowHeight ( Node ) : [EOL] value = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def default_if_none ( value , default_value ) : [EOL] return default_value if value is None else value [EOL] [EOL] [EOL] def yes_no ( value , yes_value , no_value ) : [EOL] if value : [EOL] return yes_value [EOL] else : [EOL] return no_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class Context : [EOL] def __init__ ( self , context_data , env ) : [EOL] self . context_data = context_data [EOL] self . env = env [EOL] [EOL] def resolve ( self , name ) : [EOL] if name in self . context_data : [EOL] return self . env . resolve ( self . context_data [ name ] , name , True ) [EOL] else : [EOL] return self . env . resolve ( None , name , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , DefaultDict , List , Literal , Tuple [EOL] import typing_extensions [EOL] import typing [EOL] import xlsx_template [EOL] from collections import defaultdict , namedtuple [EOL] import itertools [EOL] import typing [EOL] [EOL] from cached_property import cached_property [EOL] [EOL] from . . import utils , consts [EOL] [EOL] [EOL] Size = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] class Cell : [EOL] def __init__ ( self , row , col , style , value , row_height , col_width ) : [EOL] self . row = row [EOL] self . col = col [EOL] self . value = value [EOL] self . style = style [EOL] self . row_height = row_height [EOL] self . col_width = col_width [EOL] [EOL] def move ( self , row , col ) : [EOL] self . row += row [EOL] self . col += col [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . row == other . row [EOL] and self . col == other . col [EOL] and self . value == other . value [EOL] and self . style == other . style ) [EOL] [EOL] def __str__ ( self ) : [comment] [EOL] return [string] . format ( self . row , self . col , self . value ) [EOL] [EOL] def __repr__ ( self ) : [comment] [EOL] return str ( self ) [EOL] [EOL] [EOL] class Merge : [EOL] def __init__ ( self , row , col , rows , cols ) : [EOL] self . row , self . col = row , col [EOL] self . rows , self . cols = rows , cols [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] [EOL] [EOL] def move ( self , row , col ) : [EOL] self . row += row [EOL] self . col += col [EOL] [EOL] [EOL] class FuncArg : [EOL] def __init__ ( self , start_index , end_index , cells , direction = None ) : [EOL] self . start_index = start_index [EOL] self . end_index = end_index [EOL] self . cells = cells [EOL] self . final_cells = [ ] [EOL] self . direction = direction [EOL] [EOL] def finalize_cells ( self , current_row , current_col , initial_cell , final_cells ) : [EOL] self . cells . remove ( initial_cell ) [EOL] if self . direction is not None : [EOL] if self . direction == consts . FuncArgDirection . HORIZONTAL : [EOL] cells = [ ( cell . row , cell . col ) for cell in final_cells if cell . row == current_row ] [EOL] elif self . direction == consts . FuncArgDirection . VERTICAL : [EOL] cells = [ ( cell . row , cell . col ) for cell in final_cells if cell . col == current_col ] [EOL] else : [EOL] cells = [ ( cell . row , cell . col ) for cell in final_cells ] [EOL] self . final_cells . extend ( cells ) [EOL] [EOL] [EOL] class FuncCell : [EOL] def __init__ ( self , row , col , style , initial_value , row_height , col_width , args , default_value = [string] , ) : [EOL] self . row = row [EOL] self . col = col [EOL] self . style = style [EOL] self . initial_value = initial_value [EOL] self . row_height = row_height [EOL] self . col_width = col_width [EOL] self . default_value = default_value [EOL] self . args = { ( arg . start_index , arg . end_index ) : arg for arg in args } [EOL] self . final_args = [ ] [EOL] [EOL] def move ( self , row , col ) : [EOL] self . row += row [EOL] self . col += col [EOL] for arg in self . final_args : [EOL] arg . final_cells = [ ( arg_row + row , arg_col + col ) for arg_row , arg_col in arg . final_cells ] [EOL] [EOL] def finalize_arg ( self , arg_key , initial_cell , final_cells ) : [EOL] arg = self . args [ arg_key ] [EOL] arg . finalize_cells ( self . row , self . col , initial_cell , final_cells ) [EOL] if not arg . cells : [EOL] arg = self . args . pop ( arg_key ) [EOL] self . final_args . append ( arg ) [EOL] [EOL] def get_final_value ( self ) : [EOL] str_args = [ ] [EOL] if not self . final_args : [EOL] return self . default_value [EOL] for arg in self . final_args : [EOL] cells = list ( sorted ( arg . final_cells ) ) [EOL] if not cells : [EOL] return self . default_value [EOL] rectangle_cell_count = ( cells [ - [number] ] [ [number] ] - cells [ [number] ] [ [number] ] + [number] ) * ( cells [ - [number] ] [ [number] ] - cells [ [number] ] [ [number] ] + [number] ) [EOL] if len ( cells ) > [number] and len ( cells ) == rectangle_cell_count : [EOL] start_cell = cells [ [number] ] [EOL] start_cell = utils . cell_int_to_str ( start_cell [ [number] ] , start_cell [ [number] ] ) [EOL] end_cell = cells [ - [number] ] [EOL] end_cell = utils . cell_int_to_str ( end_cell [ [number] ] , end_cell [ [number] ] ) [EOL] str_value = [string] . format ( start_cell , end_cell ) [EOL] else : [EOL] str_value = [string] . join ( utils . cell_int_to_str ( cell [ [number] ] , cell [ [number] ] ) for cell in cells ) [EOL] str_args . append ( ( arg . start_index , arg . end_index , str_value ) ) [EOL] value = self . initial_value [EOL] value_parts = [ ] [EOL] value_part_start_index = [number] [EOL] for arg in str_args : [EOL] value_parts . append ( value [ value_part_start_index : arg [ [number] ] ] ) [EOL] value_parts . append ( arg [ [number] ] ) [EOL] value_part_start_index = arg [ [number] ] [EOL] value_parts . append ( value [ value_part_start_index : ] ) [EOL] return [string] . join ( value_parts ) [EOL] [EOL] [EOL] class CellGroupFinalResult : [EOL] def __init__ ( self , cells , func_cells , merges , size ) : [EOL] self . cells = cells [EOL] self . func_cells = func_cells [EOL] self . merges = merges [EOL] self . size = size [EOL] [EOL] def get_simple_display ( self ) : [EOL] result = [ [ None ] * self . size . width for _ in range ( self . size . height ) ] [EOL] for cell in self . cells : [EOL] result [ cell . row ] [ cell . col ] = cell . value [EOL] return result [EOL] [EOL] [EOL] class BaseCellGroup : [EOL] def add_cell ( self , row , col , cell ) : [comment] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def add_cell_group ( self , row , col , cell_group ) : [comment] [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ cached_property def final_result ( self ) : [EOL] return self . get_final_result ( ) [EOL] [EOL] def get_final_result ( self ) : [comment] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def get_final_size ( self ) : [EOL] return self . final_result . size [EOL] [EOL] def get_final_cells ( self ) : [EOL] return self . final_result . cells [EOL] [EOL] def get_final_func_cells ( self ) : [EOL] return self . final_result . func_cells [EOL] [EOL] def get_final_merges ( self ) : [EOL] return self . final_result . merges [EOL] [EOL] def calc_last_cell ( self , final_cells , final_func_cells ) : [EOL] last_cell = ( - [number] , - [number] ) [EOL] for cells in itertools . chain ( final_cells . values ( ) , final_func_cells . values ( ) ) : [EOL] for cell in cells : [EOL] last_cell = ( max ( last_cell [ [number] ] , cell . row ) , max ( last_cell [ [number] ] , cell . col ) ) [EOL] return last_cell [EOL] [EOL] [EOL] class CellGroup ( BaseCellGroup ) : [EOL] def __init__ ( self , initial_size ) : [EOL] self . initial_size = initial_size [EOL] self . cells = [ ] [EOL] self . func_cells = [ ] [EOL] self . cell_groups = { } [EOL] self . merges = [ ] [EOL] [EOL] def add_merge ( self , row , col , rows , cols ) : [EOL] self . merges . append ( Merge ( row , col , rows , cols ) ) [EOL] [EOL] def add_cell ( self , cell ) : [EOL] self . cells . append ( cell ) [EOL] [EOL] def add_func_cell ( self , cell ) : [EOL] self . func_cells . append ( cell ) [EOL] [EOL] def add_cell_group ( self , row , col , cell_group ) : [EOL] self . cell_groups [ ( row , col ) ] = cell_group [EOL] [EOL] def get_final_result ( self ) : [EOL] row_offsets = [ [ None ] * self . initial_size . width for _ in range ( self . initial_size . height + [number] ) ] [EOL] col_offsets = [ [ None ] * self . initial_size . height for _ in range ( self . initial_size . width + [number] ) ] [EOL] for ( row , col ) , cell_group in self . cell_groups . items ( ) : [EOL] final_size = cell_group . get_final_size ( ) [EOL] if final_size . width > cell_group . initial_size . width : [EOL] col_offsets [ col + [number] ] [ row ] = ( final_size . width - cell_group . initial_size . width ) [EOL] else : [EOL] for i in range ( col , col + final_size . width ) : [EOL] col_offsets [ i ] [ row ] = max ( col_offsets [ i ] [ row ] or [number] , [number] ) [EOL] for i in range ( col + final_size . width , col + cell_group . initial_size . width ) : [EOL] col_offsets [ i ] [ row ] = - [number] [EOL] [EOL] if final_size . height > cell_group . initial_size . height : [EOL] row_offsets [ row + [number] ] [ col ] = ( final_size . height - cell_group . initial_size . height ) [EOL] else : [EOL] for i in range ( row , row + final_size . height ) : [EOL] row_offsets [ i ] [ col ] = max ( row_offsets [ i ] [ col ] or [number] , [number] ) [EOL] for i in range ( row + final_size . height , row + cell_group . initial_size . height ) : [EOL] row_offsets [ i ] [ col ] = - [number] [EOL] [EOL] for cell in itertools . chain ( self . cells , self . func_cells ) : [EOL] row_offsets [ cell . row ] [ cell . col ] = max ( row_offsets [ cell . row ] [ cell . col ] or [number] , [number] ) [EOL] col_offsets [ cell . col ] [ cell . row ] = max ( col_offsets [ cell . col ] [ cell . row ] or [number] , [number] ) [EOL] [EOL] row_offsets = [ [ offset for offset in row if offset is not None ] for row in row_offsets ] [EOL] row_offsets = [ max ( row ) if row else [number] for row in row_offsets ] [EOL] row_offsets = list ( itertools . accumulate ( row_offsets ) ) [EOL] [EOL] col_offsets = [ [ offset for offset in col if offset is not None ] for col in col_offsets ] [EOL] col_offsets = [ max ( col ) if col else [number] for col in col_offsets ] [EOL] col_offsets = list ( itertools . accumulate ( col_offsets ) ) [EOL] [EOL] final_cells = defaultdict ( list ) [EOL] final_func_cells = defaultdict ( list ) [EOL] final_merges = [ ] [EOL] [EOL] for ( cg_row , cg_col ) , cell_group in self . cell_groups . items ( ) : [EOL] for ( c_row , c_col ) , cells in cell_group . get_final_cells ( ) . items ( ) : [EOL] for cell in cells : [EOL] cell . move ( cg_row + row_offsets [ cg_row ] , cg_col + col_offsets [ cg_col ] ) [EOL] final_cells [ ( cg_row + c_row , cg_col + c_col ) ] . append ( cell ) [EOL] for ( c_row , c_col ) , cells in cell_group . get_final_func_cells ( ) . items ( ) : [EOL] for cell in cells : [EOL] cell . move ( cg_row + row_offsets [ cg_row ] , cg_col + col_offsets [ cg_col ] ) [EOL] final_func_cells [ ( cg_row + c_row , cg_col + c_col ) ] . append ( cell ) [EOL] for merge in cell_group . get_final_merges ( ) : [EOL] merge . move ( cg_row + row_offsets [ cg_row ] , cg_col + col_offsets [ cg_col ] ) [EOL] final_merges . append ( merge ) [EOL] [EOL] for cell in self . cells : [EOL] row , col = cell . row , cell . col [EOL] cell . move ( row_offsets [ row ] , col_offsets [ col ] ) [EOL] final_cells [ ( row , col ) ] . append ( cell ) [EOL] [EOL] for cell in self . func_cells : [EOL] row , col = cell . row , cell . col [EOL] cell . move ( row_offsets [ row ] , col_offsets [ col ] ) [EOL] final_func_cells [ ( row , col ) ] . append ( cell ) [EOL] [EOL] for merge in self . merges : [EOL] row , col = merge . row , merge . col [EOL] merge . move ( row_offsets [ row ] , col_offsets [ col ] ) [EOL] final_merges . append ( merge ) [EOL] [EOL] for ( row , col ) , cells in final_func_cells . items ( ) : [EOL] finalized_args = [ ] [EOL] for arg_key , arg in cells [ [number] ] . args . items ( ) : [EOL] for cell in arg . cells : [EOL] final_row = row + cell [ [number] ] [EOL] final_col = col + cell [ [number] ] [EOL] if ( final_row >= [number] [EOL] and final_row < self . initial_size . height [EOL] and final_col >= [number] [EOL] and final_col < self . initial_size . width ) : [EOL] finalized_args . append ( ( arg_key , cell ) ) [EOL] for arg_key , initial_cell in finalized_args : [EOL] for cell in cells : [EOL] final_row = initial_cell [ [number] ] + row [EOL] final_col = initial_cell [ [number] ] + col [EOL] cell . finalize_arg ( arg_key , initial_cell , itertools . chain ( final_cells . get ( ( final_row , final_col ) , [ ] ) , final_func_cells . get ( ( final_row , final_col ) , [ ] ) , ) , ) [EOL] [EOL] last_cell = self . calc_last_cell ( final_cells , final_func_cells ) [EOL] [EOL] return CellGroupFinalResult ( cells = final_cells , size = Size ( width = last_cell [ [number] ] + [number] , height = last_cell [ [number] ] + [number] ) , func_cells = final_func_cells , merges = final_merges , ) [EOL] [EOL] [EOL] class SheetCellGroup ( CellGroup ) : [EOL] def get_final_result ( self ) : [EOL] result = super ( ) . get_final_result ( ) [EOL] cells = [ cell for _cells in result . cells . values ( ) for cell in _cells ] [EOL] func_cells = [ cell for _cells in result . func_cells . values ( ) for cell in _cells ] [EOL] merges = result . merges [EOL] [EOL] for cell in itertools . chain ( cells , func_cells , merges ) : [EOL] cell . move ( [number] , [number] ) [EOL] [EOL] func_cells = [ Cell ( cell . row , cell . col , cell . style , cell . get_final_value ( ) , cell . row_height , cell . col_width , ) for cell in func_cells ] [EOL] [EOL] return CellGroupFinalResult ( cells = cells + func_cells , func_cells = [ ] , merges = merges , size = Size ( result . size . height + [number] , result . size . width + [number] ) , ) [EOL] [EOL] [EOL] class LoopCellGroup ( BaseCellGroup ) : [EOL] def __init__ ( self , initial_size , direction ) : [EOL] self . initial_size = initial_size [EOL] self . direction = direction [EOL] self . cell_groups = [ ] [EOL] [EOL] def add_cell_group ( self , cell_group ) : [EOL] self . cell_groups . append ( cell_group ) [EOL] [EOL] def get_final_result ( self ) : [EOL] row_offsets = [ [number] ] [EOL] col_offsets = [ [number] ] [EOL] if self . direction == consts . LoopDirection . DOWN : [EOL] for cell_group in self . cell_groups : [EOL] final_size = cell_group . get_final_size ( ) [EOL] row_offsets . append ( final_size . height ) [EOL] col_offsets = [ [number] ] * len ( row_offsets ) [EOL] else : [EOL] for cell_group in self . cell_groups : [EOL] final_size = cell_group . get_final_size ( ) [EOL] col_offsets . append ( final_size . width ) [EOL] row_offsets = [ [number] ] * len ( col_offsets ) [EOL] [EOL] row_offsets = list ( itertools . accumulate ( row_offsets ) ) [EOL] col_offsets = list ( itertools . accumulate ( col_offsets ) ) [EOL] final_cells = defaultdict ( list ) [EOL] final_func_cells = defaultdict ( list ) [EOL] final_merges = [ ] [EOL] for index , cell_group in enumerate ( self . cell_groups ) : [EOL] for ( row , col ) , cells in cell_group . get_final_cells ( ) . items ( ) : [EOL] for cell in cells : [EOL] cell . move ( row_offsets [ index ] , col_offsets [ index ] ) [EOL] final_cells [ ( row , col ) ] . append ( cell ) [EOL] for ( row , col ) , cells in cell_group . get_final_func_cells ( ) . items ( ) : [EOL] for cell in cells : [EOL] cell . move ( row_offsets [ index ] , col_offsets [ index ] ) [EOL] final_func_cells [ ( row , col ) ] . append ( cell ) [EOL] for merge in cell_group . merges : [EOL] merge . move ( row_offsets [ index ] , col_offsets [ index ] ) [EOL] final_merges . append ( merge ) [EOL] [EOL] last_cell = self . calc_last_cell ( final_cells , final_func_cells ) [EOL] [EOL] return CellGroupFinalResult ( cells = final_cells , size = Size ( width = last_cell [ [number] ] + [number] , height = last_cell [ [number] ] + [number] ) , func_cells = final_func_cells , merges = final_merges , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[xlsx_template.runtime.cell_groups.Size]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[unknown,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[unknown,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[unknown,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[unknown,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[unknown,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal[-1],typing_extensions.Literal[-1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal[-1],typing_extensions.Literal[-1]]$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal[-1],typing_extensions.Literal[-1]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal[-1],typing_extensions.Literal[-1]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal[-1],typing_extensions.Literal[-1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $xlsx_template.runtime.cell_groups.Size$ 0 0 0 0 0 $xlsx_template.runtime.cell_groups.Size$ 0 $xlsx_template.runtime.cell_groups.Size$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 $typing.Type[xlsx_template.runtime.cell_groups.Size]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[xlsx_template.runtime.cell_groups.Cell]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[xlsx_template.runtime.cell_groups.Cell]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[xlsx_template.runtime.cell_groups.Cell]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[xlsx_template.runtime.cell_groups.Cell]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[xlsx_template.runtime.cell_groups.Cell]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[xlsx_template.runtime.cell_groups.Cell]$ 0 $typing.List[xlsx_template.runtime.cell_groups.Cell]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[xlsx_template.runtime.cell_groups.Size]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 $typing.Type[xlsx_template.runtime.cell_groups.Size]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0
class LoopContext : [EOL] def __init__ ( self , items ) : [EOL] if not hasattr ( items , [string] ) : [EOL] items = list ( items ) [EOL] self . items = items [EOL] self . index0 = - [number] [EOL] self . length = len ( items ) [EOL] [EOL] def __iter__ ( self ) : [EOL] for item in self . items : [EOL] self . index0 += [number] [EOL] yield item [EOL] [EOL] @ property def index ( self ) : [EOL] return self . index0 + [number] [EOL] [EOL] @ property def revindex ( self ) : [EOL] return self . length - self . index0 [EOL] [EOL] @ property def revindex0 ( self ) : [EOL] return self . length - self . index [EOL] [EOL] @ property def first ( self ) : [EOL] return self . index0 == [number] [EOL] [EOL] @ property def last ( self ) : [EOL] return self . index0 == self . length - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . loop_context import LoopContext [EOL]	0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import xlsx_template [EOL] import os [EOL] import io [EOL] [EOL] from openpyxl import load_workbook [EOL] import pytest [EOL] [EOL] from xlsx_template . template import Template [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def template_dir ( ) : [EOL] return os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def get_template ( template_dir ) : [EOL] def inner ( template_name ) : [EOL] return open ( os . path . join ( template_dir , template_name ) , [string] ) [EOL] [EOL] return inner [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def render_template ( get_template ) : [EOL] def inner ( template_name , context ) : [EOL] template = Template ( get_template ( template_name ) , debug = True ) [EOL] res = template . render ( context ) [EOL] wb = load_workbook ( io . BytesIO ( res ) ) [EOL] return wb [EOL] [EOL] return inner [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Union [EOL] import decimal [EOL] import typing [EOL] import decimal [EOL] [EOL] [EOL] def generate_for_test_variables ( ) : [EOL] class Obj : [EOL] def __getattr__ ( self , attr_name ) : [EOL] return [string] . format ( attr_name ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return [string] . format ( repr ( key ) ) [EOL] [EOL] def complex_call ( * args , ** kwargs ) : [EOL] res = [string] . join ( str ( arg ) for arg in args ) [EOL] if kwargs : [EOL] if res : [EOL] res += [string] [EOL] res += [string] . join ( [string] . format ( key , value ) for key , value in kwargs . items ( ) ) [EOL] return res [EOL] [EOL] return { [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : decimal . Decimal ( [number] ) , [string] : lambda : [string] , [string] : complex_call , [string] : [string] , [string] : True , [string] : Obj ( ) , [string] : None , } [EOL] [EOL] [EOL] def generate_for_test_simple_loop ( ) : [EOL] items = list ( [string] . format ( i ) for i in range ( [number] , [number] ) ) [EOL] return { [string] : items } [EOL] [EOL] [EOL] def generate_for_test_two_nested_loops ( ) : [EOL] table = [ [ row * [number] + col for col in range ( [number] ) ] for row in range ( [number] ) ] [EOL] return { [string] : table , [string] : [number] , [string] : [number] } [EOL] [EOL] [EOL] def generate_for_test_loop_context ( ) : [EOL] items = [ [string] . format ( i ) for i in range ( [number] ) ] [EOL] return { [string] : items } [EOL] [EOL] [EOL] def generate_for_loop_with_formulas ( ) : [EOL] employees = [ { [string] : [string] . format ( index + [number] ) , [string] : [number] + ( ( index % [number] ) * [number] ) , [string] : decimal . Decimal ( [string] ) * ( [number] - ( index % [number] ) ) , } for index in range ( [number] ) ] [EOL] return { [string] : employees } [EOL] [EOL] [EOL] def generate_for_test_merge ( ) : [EOL] return { [string] : [ i for i in range ( [number] ) ] } [EOL] [EOL] [EOL] def generate_for_test_if ( ) : [EOL] return { [string] : [ { [string] : value , [string] : value % [number] == [number] } for value in range ( [number] ) ] } [EOL] [EOL] [EOL] def generate_for_test_column_width ( ) : [EOL] return { [string] : [ { [string] : [number] * index } for index in range ( [number] , [number] ) ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Literal , Union [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] import io [EOL] import decimal [EOL] import itertools [EOL] import string [EOL] [EOL] from openpyxl import load_workbook [EOL] [EOL] from xlsx_template . template import Template [EOL] import data_generators [EOL] [EOL] [EOL] BASE_TEMPLATE_DIR = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] [EOL] def test_variables ( render_template ) : [EOL] wb = render_template ( [string] , data_generators . generate_for_test_variables ( ) ) [EOL] assert [string] in wb [EOL] assert [string] in wb [EOL] assert [string] in wb [EOL] ws = wb [ [string] ] [EOL] assert ws [ [string] ] . value == [string] [EOL] assert ws [ [string] ] . value is True [EOL] assert ws [ [string] ] . value is False [EOL] assert ws [ [string] ] . value == [number] [EOL] assert ws [ [string] ] . value == [number] [EOL] assert ws [ [string] ] . value == [string] [EOL] assert ws [ [string] ] . value == [number] [EOL] assert ws [ [string] ] . value == [number] [EOL] assert ws [ [string] ] . value == [number] [EOL] assert ws [ [string] ] . value == [string] [EOL] assert ws [ [string] ] . value is None [EOL] assert ws [ [string] ] . value == [string] [EOL] assert ws [ [string] ] . value == [string] [EOL] assert ws [ [string] ] . value == [string] [EOL] assert ws [ [string] ] . value == [string] [EOL] assert ws [ [string] ] . value is None [EOL] assert ws [ [string] ] . value == [string] [EOL] assert ws [ [string] ] . value == [string] [EOL] assert ws [ [string] ] . value == [string] [EOL] [EOL] [EOL] def test_simple_loop ( render_template ) : [EOL] wb = render_template ( [string] , data_generators . generate_for_test_simple_loop ( ) ) [EOL] ws = wb [ [string] ] [EOL] assert ws [ [string] ] . value == [string] [EOL] for row in range ( [number] , [number] ) : [EOL] assert ws [ [string] . format ( row ) ] . value == [string] . format ( row - [number] ) [EOL] assert ws [ [string] ] . value == [string] [EOL] [EOL] assert ws [ [string] ] . value == [string] [EOL] for index , col in enumerate ( [string] , [number] ) : [EOL] assert ws [ [string] . format ( col ) ] . value == [string] . format ( index ) [EOL] [EOL] [EOL] def _test_two_loops ( wb ) : [EOL] ws = wb [ [string] ] [EOL] rows = [ str ( _ ) for _ in range ( [number] , [number] ) ] [EOL] cols = string . ascii_uppercase [ [number] : [number] ] [EOL] for index , ( row , col ) in enumerate ( itertools . product ( rows , cols ) ) : [EOL] cell = col + row [EOL] assert ws [ cell ] . value == index [EOL] for cell in ( [string] , [string] , [string] , [string] ) : [EOL] assert ws [ cell ] . value == [string] [EOL] [EOL] for row in rows : [EOL] cell1 = [string] + row [EOL] cell2 = [string] + row [EOL] valid_value = [string] . format ( row ) [EOL] assert ws [ cell1 ] . value == valid_value [EOL] assert ws [ cell2 ] . value == valid_value [EOL] [EOL] for col in cols : [EOL] cell1 = col + [string] [EOL] cell2 = col + [string] [EOL] valid_value = [string] . format ( col ) [EOL] assert ws [ cell1 ] . value == valid_value [EOL] assert ws [ cell2 ] . value == valid_value [EOL] [EOL] [EOL] def test_two_loops ( render_template ) : [EOL] _test_two_loops ( render_template ( [string] , data_generators . generate_for_test_two_nested_loops ( ) , ) ) [EOL] [EOL] [EOL] def test_two_loops_synt_v2 ( render_template ) : [EOL] _test_two_loops ( render_template ( [string] , data_generators . generate_for_test_two_nested_loops ( ) , ) ) [EOL] [EOL] [EOL] def test_loop_context ( render_template ) : [EOL] data = data_generators . generate_for_test_loop_context ( ) [EOL] items_length = len ( data [ [string] ] ) [EOL] wb = render_template ( [string] , data ) [EOL] ws = wb [ [string] ] [EOL] for index , row in enumerate ( range ( [number] , [number] ) ) : [EOL] assert ws . cell ( row , [number] ) . value == ws . cell ( row , [number] ) . value == index + [number] [EOL] assert ws . cell ( row , [number] ) . value == ws . cell ( row , [number] ) . value == index [EOL] assert ws . cell ( row , [number] ) . value == ws . cell ( row , [number] ) . value == items_length - index [EOL] assert ( ws . cell ( row , [number] ) . value == ws . cell ( row , [number] ) . value == items_length - index - [number] ) [EOL] assert ws . cell ( row , [number] ) . value == ws . cell ( row , [number] ) . value == ( index == [number] ) [EOL] assert ( ws . cell ( row , [number] ) . value == ws . cell ( row , [number] ) . value == ( index == items_length - [number] ) ) [EOL] assert ws . cell ( row , [number] ) . value == ws . cell ( row , [number] ) . value == items_length [EOL] assert ws . cell ( row , [number] ) . value == [string] . format ( index ) [EOL] [EOL] [EOL] def test_merge ( render_template ) : [EOL] data = data_generators . generate_for_test_merge ( ) [EOL] wb = render_template ( [string] , data ) [EOL] ws = wb [ [string] ] [EOL] assert [string] in ws . merged_cells [EOL] for row in range ( [number] , [number] ) : [EOL] assert [string] . format ( row ) in ws . merged_cells [EOL] assert [string] in ws . merged_cells [EOL] assert [string] in ws . merged_cells [EOL] assert [string] in ws . merged_cells [EOL] [EOL] [EOL] def test_if ( render_template ) : [EOL] data = data_generators . generate_for_test_if ( ) [EOL] wb = render_template ( [string] , data ) [EOL] ws = wb [ [string] ] [EOL] for row in range ( [number] , [number] ) : [EOL] value1 = ws [ [string] . format ( row ) ] . value [EOL] value2 = [string] if value1 % [number] == [number] else [string] [EOL] assert ws [ [string] . format ( row ) ] . value == value2 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List , Dict , Union , Tuple [EOL] import xlsx_template [EOL] import typing [EOL] from xlsx_template . runtime . cell_groups import ( CellGroup , Cell , LoopCellGroup , FuncArg , FuncCell , Size , SheetCellGroup , ) [EOL] from xlsx_template . consts import LoopDirection [EOL] [EOL] [EOL] def test_cell_group_with_cells ( ) : [EOL] cell_group = CellGroup ( initial_size = Size ( height = [number] , width = [number] ) ) [EOL] cell_group . add_cell ( Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) ) [EOL] cell_group . add_cell ( Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) ) [EOL] cell_group . add_cell ( Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) ) [EOL] valid_result = { ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) ] , } [EOL] assert valid_result == cell_group . get_final_cells ( ) [EOL] [EOL] [EOL] def test_loop_cell_group ( ) : [EOL] cell_group0 = CellGroup ( initial_size = Size ( height = [number] , width = [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] [EOL] cell_group1 = LoopCellGroup ( initial_size = Size ( height = [number] , width = [number] ) , direction = LoopDirection . DOWN ) [EOL] for row_index in range ( [number] , [number] ) : [EOL] cell_group2 = CellGroup ( initial_size = Size ( height = [number] , width = [number] ) ) [EOL] cell_group2 . add_cell ( Cell ( [number] , [number] , [string] , row_index * [number] , [number] , [number] ) ) [EOL] cell_group2 . add_cell ( Cell ( [number] , [number] , [string] , row_index * [number] , [number] , [number] ) ) [EOL] cell_group2 . add_cell ( Cell ( [number] , [number] , [string] , row_index * [number] , [number] , [number] ) ) [EOL] cell_group1 . add_cell_group ( cell_group2 ) [EOL] [EOL] cell_group0 . add_cell_group ( [number] , [number] , cell_group1 ) [EOL] [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] [EOL] valid_cells = { ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) , Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) , Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) , ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) , Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) , Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) , ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) , Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) , Cell ( [number] , [number] , [string] , [number] , [number] , [number] ) , ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ] , ( [number] , [number] ) : [ Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ] , } [EOL] final_cells = cell_group0 . get_final_cells ( ) [EOL] assert valid_cells == final_cells [EOL] [EOL] [EOL] def test_table_with_formulas ( ) : [EOL] sheet_cell_group = SheetCellGroup ( initial_size = Size ( [number] , [number] ) ) [EOL] cell_group0 = CellGroup ( initial_size = Size ( [number] , [number] ) ) [EOL] [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] [EOL] cell_group1 = LoopCellGroup ( initial_size = Size ( [number] , [number] ) , direction = LoopDirection . DOWN ) [EOL] [EOL] for row_index in range ( [number] , [number] ) : [EOL] cell_group2 = CellGroup ( initial_size = Size ( [number] , [number] ) ) [EOL] cell_group2 . add_cell ( Cell ( [number] , [number] , [string] , [string] . format ( row_index ) , [number] , [number] ) ) [EOL] cell_group2 . add_cell ( Cell ( [number] , [number] , [string] , row_index * [number] , [number] , [number] ) ) [EOL] cell_group2 . add_cell ( Cell ( [number] , [number] , [string] , row_index * [number] , [number] , [number] ) ) [EOL] func_args = [ FuncArg ( [number] , [number] , [ ( [number] , - [number] ) ] ) , FuncArg ( [number] , [number] , [ ( [number] , - [number] ) ] ) ] [EOL] cell_group2 . add_func_cell ( FuncCell ( [number] , [number] , [string] , [string] , [number] , [number] , args = func_args ) ) [EOL] func_args = [ FuncArg ( [number] , [number] , [ ( [number] , - [number] ) ] ) , FuncArg ( [number] , [number] , [ ( [number] , - [number] ) ] ) ] [EOL] cell_group2 . add_func_cell ( FuncCell ( [number] , [number] , [string] , [string] , [number] , [number] , args = func_args ) ) [EOL] cell_group1 . add_cell_group ( cell_group2 ) [EOL] [EOL] cell_group0 . add_cell_group ( [number] , [number] , cell_group1 ) [EOL] [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] [EOL] func_args = [ FuncArg ( [number] , [number] , [ ( - [number] , [number] ) ] ) ] [EOL] cell_group0 . add_func_cell ( FuncCell ( [number] , [number] , [string] , [string] , [number] , [number] , args = func_args ) ) [EOL] [EOL] func_args = [ FuncArg ( [number] , [number] , [ ( - [number] , [number] ) ] ) ] [EOL] cell_group0 . add_func_cell ( FuncCell ( [number] , [number] , [string] , [string] , [number] , [number] , args = func_args ) ) [EOL] [EOL] func_args = [ FuncArg ( [number] , [number] , [ ( - [number] , [number] ) ] ) ] [EOL] cell_group0 . add_func_cell ( FuncCell ( [number] , [number] , [string] , [string] , [number] , [number] , args = func_args ) ) [EOL] [EOL] func_args = [ FuncArg ( [number] , [number] , [ ( - [number] , [number] ) ] ) ] [EOL] cell_group0 . add_func_cell ( FuncCell ( [number] , [number] , [string] , [string] , [number] , [number] , args = func_args ) ) [EOL] [EOL] sheet_cell_group . add_cell_group ( [number] , [number] , cell_group0 ) [EOL] [EOL] valid_result = [ [ None , None , None , None , None , None ] , [ None , [string] , [string] , [string] , [string] , [string] ] , [ None , [string] , [number] , [number] , [string] , [string] ] , [ None , [string] , [number] , [number] , [string] , [string] ] , [ None , [string] , [number] , [number] , [string] , [string] ] , [ None , [string] , [string] , [string] , [string] , [string] ] , ] [EOL] result = sheet_cell_group . final_result . get_simple_display ( ) [EOL] assert result == valid_result [EOL] [EOL] [EOL] def test_negative_row_offset ( ) : [EOL] sheet_cell_group = SheetCellGroup ( initial_size = Size ( [number] , [number] ) ) [EOL] cell_group0 = CellGroup ( initial_size = Size ( [number] , [number] ) ) [EOL] [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] cell_group0 . add_cell ( Cell ( [number] , [number] , [string] , [string] , [number] , [number] ) ) [EOL] [EOL] cell_group1 = CellGroup ( initial_size = Size ( [number] , [number] ) ) [EOL] [EOL] cell_group0 . add_cell_group ( [number] , [number] , cell_group1 ) [EOL] [EOL] func_args = [ FuncArg ( [number] , [number] , [ ( - [number] , [number] ) ] ) ] [EOL] [EOL] cell_group0 . add_func_cell ( FuncCell ( [number] , [number] , [string] , [string] , [number] , [number] , args = func_args , default_value = [number] ) ) [EOL] cell_group0 . add_func_cell ( FuncCell ( [number] , [number] , [string] , [string] , [number] , [number] , args = func_args ) ) [EOL] cell_group0 . add_func_cell ( FuncCell ( [number] , [number] , [string] , [string] , [number] , [number] , args = func_args ) ) [EOL] sheet_cell_group . add_cell_group ( [number] , [number] , cell_group0 ) [EOL] valid_result = [ [ None , None , None , None ] , [ None , [string] , [string] , [string] ] , [ None , [number] , [string] , [string] ] , ] [EOL] result = sheet_cell_group . final_result . get_simple_display ( ) [EOL] assert result == valid_result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0