	0
from typing import List , Union , Dict , Any [EOL] import typing [EOL] import click [EOL] import builtins [EOL] import click [EOL] [EOL] SCHEMA_BASE_MAP = { [string] : click . STRING , [string] : click . INT , [string] : click . FLOAT , [string] : click . BOOL , } [EOL] COMPLEX_TYPES = [ [string] , [string] ] [EOL] [EOL] [EOL] def handle_oneof ( oneof_schema ) : [EOL] [docstring] [EOL] oneof_dict = { schema [ [string] ] : schema for schema in oneof_schema } [EOL] click_type = None [EOL] multiple = False [EOL] description = None [EOL] for key , value in oneof_dict . items ( ) : [EOL] if key == [string] : [EOL] continue [EOL] elif key in SCHEMA_BASE_MAP : [EOL] if oneof_dict . get ( [string] ) and oneof_dict [ [string] ] [ [string] ] [ [string] ] == key : [EOL] multiple = True [EOL] [comment] [EOL] click_type = SCHEMA_BASE_MAP [ key ] [EOL] description = value . get ( [string] ) [EOL] break [EOL] return click_type , multiple , description [EOL] [EOL] [EOL] def json_schema_to_click_type ( schema ) : [EOL] [docstring] [EOL] choices = None [EOL] if isinstance ( schema [ [string] ] , list ) : [EOL] if [string] in schema [ [string] ] : [EOL] schema [ [string] ] = [string] [EOL] click_type = SCHEMA_BASE_MAP [ schema [ [string] ] ] [EOL] description = schema . get ( [string] ) [EOL] if schema . get ( [string] ) : [EOL] choices = click . Choice ( schema [ [string] ] ) [EOL] return click_type , description , choices [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[click.types.BoolParamType,click.types.FloatParamType,click.types.IntParamType,click.types.StringParamType]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[click.types.BoolParamType,click.types.FloatParamType,click.types.IntParamType,click.types.StringParamType]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[click.types.BoolParamType,click.types.FloatParamType,click.types.IntParamType,click.types.StringParamType]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[click.types.BoolParamType,click.types.FloatParamType,click.types.IntParamType,click.types.StringParamType]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Dict , Any [EOL] import click [EOL] import typing [EOL] import functools [EOL] import builtins [EOL] import json [EOL] from functools import partial [EOL] from typing import List [EOL] [EOL] import click [EOL] [EOL] from diffy_cli . utils . json_schema import ( COMPLEX_TYPES , json_schema_to_click_type , handle_oneof , ) [EOL] [EOL] CORE_COMMANDS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] [comment] [EOL] def validate_schema_callback ( ctx , param , value ) : [EOL] [docstring] [EOL] return value [EOL] [EOL] [EOL] def params_factory ( schemas ) : [EOL] [docstring] [EOL] params = [ ] [EOL] unique_decls = [ ] [EOL] for schema in schemas : [EOL] for prpty , prpty_schema in schema . items ( ) : [EOL] multiple = False [EOL] choices = None [EOL] [EOL] if any ( char in prpty for char in [ [string] ] ) : [EOL] continue [EOL] [EOL] if prpty_schema . get ( [string] ) in COMPLEX_TYPES : [EOL] continue [EOL] [EOL] if prpty_schema . get ( [string] ) : [EOL] continue [EOL] [EOL] elif not prpty_schema . get ( [string] ) : [EOL] click_type , description , choices = json_schema_to_click_type ( prpty_schema ) [EOL] else : [EOL] click_type , multiple , description = handle_oneof ( prpty_schema [ [string] ] ) [EOL] [comment] [EOL] if not click_type : [EOL] continue [EOL] [EOL] [comment] [EOL] if click_type == click . BOOL : [EOL] param_decls = [ get_flag_param_decals_from_bool ( prpty ) ] [EOL] click_type = None [EOL] else : [EOL] param_decls = [ get_param_decals_from_name ( prpty ) ] [EOL] [EOL] if description : [EOL] description = description . capitalize ( ) [EOL] [EOL] if multiple : [EOL] if not description . endswith ( [string] ) : [EOL] description += [string] [EOL] description += [string] [EOL] [EOL] param_decls = [ x for x in param_decls if x not in unique_decls ] [EOL] if not param_decls : [EOL] continue [EOL] [EOL] unique_decls += param_decls [EOL] option = partial ( click . Option , param_decls = param_decls , help = description , default = prpty_schema . get ( [string] ) , callback = validate_schema_callback , multiple = multiple , ) [EOL] [EOL] if choices : [EOL] option = option ( type = choices ) [EOL] elif click_type : [EOL] option = option ( type = click_type ) [EOL] else : [EOL] option = option ( ) [EOL] [EOL] params . append ( option ) [EOL] return params [EOL] [EOL] [EOL] def func_factory ( p , method ) : [EOL] [docstring] [EOL] [EOL] def callback ( pretty = False ) : [EOL] res = getattr ( p , method ) [EOL] dump = partial ( json . dumps , indent = [number] ) if pretty else partial ( json . dumps ) [EOL] click . echo ( dump ( res ) ) [EOL] [EOL] return callback [EOL] [EOL] [EOL] def get_param_decals_from_name ( option_name ) : [EOL] [docstring] [EOL] name = option_name . replace ( [string] , [string] ) [EOL] return f" [string] { name }" [EOL] [EOL] [EOL] def get_flag_param_decals_from_bool ( option_name ) : [EOL] [docstring] [EOL] name = option_name . replace ( [string] , [string] ) [EOL] return f" [string] { name } [string] { name }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from rapidfuzz import process [EOL] [EOL] from honeybee . extensions import swag [EOL] from honeybee . exceptions import ResolveException [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_fuzzy_accounts ( identifier , accounts ) : [EOL] [docstring] [EOL] [comment] [EOL] choices = [ ] [EOL] for a in accounts : [EOL] choices . append ( a [ [string] ] ) [EOL] choices += a [ [string] ] [EOL] [EOL] return process . extract ( identifier , choices , limit = [number] ) [EOL] [EOL] [EOL] def valid_account ( identifier ) : [EOL] [docstring] [EOL] account = get_account_id ( identifier ) [EOL] if account : [EOL] return True [EOL] [EOL] [EOL] def get_account_name ( identifier ) : [EOL] [docstring] [EOL] log . debug ( f" [string] { identifier }" ) [EOL] account_data = swag . get ( f" [string] { identifier } [string] " ) [EOL] [EOL] if not account_data : [EOL] raise ResolveException ( f" [string] { identifier }" ) [EOL] [EOL] return account_data [ [string] ] [EOL] [EOL] [EOL] def get_account_id ( identifier ) : [EOL] [docstring] [EOL] log . debug ( f" [string] { identifier }" ) [EOL] account_data = swag . get ( f" [string] { identifier } [string] " ) [EOL] [EOL] if not account_data : [EOL] account_data = swag . get_by_name ( identifier , alias = True ) [EOL] [EOL] if not account_data : [EOL] raise ResolveException ( f" [string] { identifier }" ) [EOL] [EOL] if len ( account_data ) > [number] : [EOL] raise ResolveException ( f" [string] { len ( account_data ) } [string] { identifier }" ) [EOL] [EOL] return account_data [ [number] ] [ [string] ] [EOL] return account_data [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from swag_client . backend import SWAGManager [EOL] [EOL] swag = SWAGManager ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Pattern [EOL] import typing [EOL] import re [EOL] import logging [EOL] [EOL] AWS_REGEX = re . compile ( [string] ) [EOL] [EOL] [EOL] def replace ( m ) : [EOL] return [string] + len ( m . group ( [string] ) ) * [string] [EOL] [EOL] [EOL] class AWSFilter ( logging . Filter ) : [EOL] def filter ( self , record ) : [EOL] record . msg = re . sub ( AWS_REGEX , replace , record . msg ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class DiffyException ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . message = kwargs . pop ( [string] , None ) [EOL] super ( ) . __init__ ( self . message ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . message } [string] " [EOL] [EOL] [EOL] class InvalidConfiguration ( DiffyException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . message = kwargs . pop ( [string] , None ) [EOL] super ( ) . __init__ ( self . message ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . message } [string] " [EOL] [EOL] [EOL] class PendingException ( DiffyException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . message = kwargs . pop ( [string] , None ) [EOL] super ( ) . __init__ ( self . message ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . message } [string] " [EOL] [EOL] [EOL] class SchemaError ( DiffyException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , schema_error , * args , ** kwargs ) : [EOL] kwargs [ [string] ] = f" [string] { schema_error }" [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . message } [string] " [EOL] [EOL] [EOL] class BadArguments ( DiffyException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , validation_error , * args , ** kwargs ) : [EOL] kwargs [ [string] ] = f" [string] { validation_error }" [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . message } [string] " [EOL] [EOL] [EOL] class TargetNotFound ( DiffyException ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , target_key , plugin_slug , * args , ** kwargs ) : [EOL] options = [string] [EOL] for k , v in kwargs . items ( ) : [EOL] options += f"{ k } [string] { v } [string] " [EOL] [EOL] kwargs [ [string] ] = f" [string] { target_key } [string] { plugin_slug } [string] { options }" [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . message } [string] " [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def analysis ( target_key , target_plugin , payload_plugin , collection_plugin , persistence_plugin , analysis_plugin , ** kwargs , ) : [EOL] [docstring] [EOL] logger . debug ( f' [string] { target_plugin } [string] { target_key }' ) [EOL] target_plugin [ [string] ] . update ( kwargs ) [EOL] targets = target_plugin [ [string] ] . get ( target_key , ** target_plugin [ [string] ] ) [EOL] [EOL] logger . debug ( f' [string] { payload_plugin }' ) [EOL] payload_plugin [ [string] ] . update ( kwargs ) [EOL] commands = payload_plugin [ [string] ] . generate ( None , ** kwargs ) [EOL] [EOL] logger . debug ( f' [string] { collection_plugin } [string] { len ( targets ) }' ) [EOL] collection_plugin [ [string] ] . update ( kwargs ) [EOL] results = collection_plugin [ [string] ] . get ( targets , commands , ** collection_plugin [ [string] ] ) [EOL] [EOL] logger . debug ( f' [string] { persistence_plugin } [string] ' ) [EOL] [EOL] [comment] [EOL] items = [ ] [EOL] for k , v in results . items ( ) : [EOL] for i in v : [EOL] instance_id = i [ [string] ] [EOL] key = f"{ target_key } [string] { instance_id }" [EOL] [EOL] items . append ( i ) [EOL] persistence_plugin [ [string] ] . save ( None , key , i ) [EOL] [EOL] logger . debug ( [string] ) [EOL] [EOL] results = analysis_plugin [ [string] ] . run ( items , baseline = persistence_plugin [ [string] ] . get ( [string] , target_key ) , syntax = [string] , ) [EOL] [EOL] persistence_plugin [ [string] ] . update ( kwargs ) [EOL] persistence_plugin [ [string] ] . save ( [string] , target_key , results , ** persistence_plugin [ [string] ] ) [EOL] return { [string] : results } [EOL] [EOL] [EOL] def baseline ( target_key , target_plugin , payload_plugin , collection_plugin , persistence_plugin , ** kwargs , ) : [EOL] [docstring] [EOL] target_plugin [ [string] ] . update ( kwargs ) [EOL] targets = target_plugin [ [string] ] . get ( target_key , ** target_plugin [ [string] ] ) [ : [number] ] [EOL] [EOL] logger . debug ( [string] ) [EOL] [EOL] payload_plugin [ [string] ] . update ( kwargs ) [EOL] commands = payload_plugin [ [string] ] . generate ( None , ** payload_plugin [ [string] ] ) [EOL] [EOL] logger . debug ( f" [string] { len ( targets ) }" ) [EOL] [EOL] collection_plugin [ [string] ] . update ( kwargs ) [EOL] results = collection_plugin [ [string] ] . get ( targets , commands , ** collection_plugin [ [string] ] ) [EOL] [EOL] logger . debug ( [string] ) [EOL] [EOL] baselines = [ ] [EOL] for k , v in results . items ( ) : [EOL] persistence_plugin [ [string] ] . update ( kwargs ) [EOL] persistence_plugin [ [string] ] . save ( [string] , target_key , v [ [number] ] , ** persistence_plugin [ [string] ] ) [comment] [EOL] baselines . append ( { target_key : v [ [number] ] } ) [EOL] [EOL] return { [string] : baselines } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from functools import wraps [EOL] [EOL] import boto3 [EOL] [EOL] from diffy . config import CONFIG [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def sts_client ( service , service_type = [string] ) : [EOL] def decorator ( f ) : [EOL] @ wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] sts = boto3 . client ( [string] ) [EOL] [EOL] account_number = kwargs [ [string] ] [EOL] role = CONFIG . get ( [string] , [string] ) [EOL] [EOL] arn = f" [string] { account_number } [string] { role }" [EOL] [EOL] kwargs . pop ( [string] ) [EOL] [EOL] [comment] [EOL] logger . debug ( f" [string] { arn }" ) [EOL] role = sts . assume_role ( RoleArn = arn , RoleSessionName = [string] ) [EOL] [EOL] if service_type == [string] : [EOL] client = boto3 . client ( service , region_name = kwargs [ [string] ] , aws_access_key_id = role [ [string] ] [ [string] ] , aws_secret_access_key = role [ [string] ] [ [string] ] , aws_session_token = role [ [string] ] [ [string] ] , ) [EOL] kwargs [ [string] ] = client [EOL] elif service_type == [string] : [EOL] resource = boto3 . resource ( service , region_name = kwargs [ [string] ] , aws_access_key_id = role [ [string] ] [ [string] ] , aws_secret_access_key = role [ [string] ] [ [string] ] , aws_session_token = role [ [string] ] [ [string] ] , ) [EOL] kwargs [ [string] ] = resource [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] return decorated_function [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] from typing import List [EOL] [EOL] from retrying import retry [EOL] from botocore . exceptions import ClientError [EOL] [EOL] from . sts import sts_client [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def retry_throttled ( exception ) : [EOL] [docstring] [EOL] logger . debug ( exception ) [EOL] if isinstance ( exception , ClientError ) : [EOL] if exception . response [ [string] ] [ [string] ] == [string] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] @ sts_client ( [string] ) @ retry ( retry_on_exception = retry_throttled , stop_max_attempt_number = [number] , wait_exponential_multiplier = [number] , ) def describe_auto_scaling_group ( group_name , ** kwargs ) : [EOL] [docstring] [EOL] logger . debug ( f" [string] { group_name }" ) [EOL] [EOL] return kwargs [ [string] ] . describe_auto_scaling_groups ( AutoScalingGroupNames = [ group_name ] ) [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import json [EOL] import logging [EOL] [EOL] from retrying import retry [EOL] from botocore . exceptions import ClientError [EOL] [EOL] from . sts import sts_client [EOL] [EOL] from diffy . config import CONFIG [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ retry ( stop_max_attempt_number = [number] , wait_exponential_multiplier = [number] , wait_exponential_max = [number] , ) def _get_from_s3 ( client , bucket , data_file ) : [EOL] return client . get_object ( Bucket = bucket , Key = data_file ) [ [string] ] . read ( ) [EOL] [EOL] [EOL] @ retry ( stop_max_attempt_number = [number] , wait_exponential_multiplier = [number] , wait_exponential_max = [number] , ) def _put_to_s3 ( client , bucket , data_file , body ) : [EOL] return client . put_object ( Bucket = bucket , Key = data_file , Body = body , ContentType = [string] , CacheControl = [string] , ) [EOL] [EOL] [EOL] @ sts_client ( [string] ) def load_file ( key , ** kwargs ) : [EOL] [docstring] [EOL] bucket = CONFIG . get ( [string] ) [EOL] logger . debug ( f" [string] { bucket } [string] { key }" ) [EOL] try : [EOL] data = _get_from_s3 ( kwargs [ [string] ] , bucket , key ) [EOL] [EOL] data = data . decode ( [string] ) [EOL] [EOL] return json . loads ( data ) [EOL] except ClientError as e : [EOL] logger . exception ( e ) [EOL] assert False [EOL] [EOL] [EOL] @ sts_client ( [string] ) def save_file ( key , item , dry_run = None , ** kwargs ) : [EOL] [docstring] [EOL] bucket = CONFIG . get ( [string] ) [EOL] logger . debug ( f" [string] { bucket } [string] { key }" ) [EOL] [EOL] if not dry_run : [EOL] return _put_to_s3 ( kwargs [ [string] ] , bucket , key , item ) [EOL] return { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from diffy . _version import __version__ [comment] [EOL]	0 0 0 0 0 0 0 0
from diffy . tests . conftest import * [EOL]	0 0 0 0 0 0 0 0 0
	0
from diffy . _version import __version__ [comment] [EOL]	0 0 0 0 0 0 0 0
from diffy . tests . conftest import * [comment] [EOL]	0 0 0 0 0 0 0 0 0 0
	0
from diffy . _version import __version__ [comment] [EOL]	0 0 0 0 0 0 0 0
from diffy . tests . conftest import * [comment] [EOL]	0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from diffy . exceptions import InvalidConfiguration [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] class InstanceManager ( object ) : [EOL] def __init__ ( self , class_list = None , instances = True ) : [EOL] if class_list is None : [EOL] class_list = [ ] [EOL] self . instances = instances [EOL] self . update ( class_list ) [EOL] [EOL] def get_class_list ( self ) : [EOL] return self . class_list [EOL] [EOL] def add ( self , class_path ) : [EOL] self . cache = None [EOL] if class_path not in self . class_list : [EOL] self . class_list . append ( class_path ) [EOL] [EOL] def remove ( self , class_path ) : [EOL] self . cache = None [EOL] self . class_list . remove ( class_path ) [EOL] [EOL] def update ( self , class_list ) : [EOL] [docstring] [EOL] self . cache = None [EOL] self . class_list = class_list [EOL] [EOL] def all ( self ) : [EOL] [docstring] [EOL] class_list = list ( self . get_class_list ( ) ) [EOL] if not class_list : [EOL] self . cache = [ ] [EOL] return [ ] [EOL] [EOL] if self . cache is not None : [EOL] return self . cache [EOL] [EOL] results = [ ] [EOL] for cls_path in class_list : [EOL] module_name , class_name = cls_path . rsplit ( [string] , [number] ) [EOL] try : [EOL] module = __import__ ( module_name , { } , { } , class_name ) [EOL] cls = getattr ( module , class_name ) [EOL] if self . instances : [EOL] results . append ( cls ( ) ) [EOL] else : [EOL] results . append ( cls ) [EOL] [EOL] except InvalidConfiguration as e : [EOL] logger . warning ( f" [string] { class_name } [string] { e }" ) [EOL] [EOL] except Exception as e : [EOL] logger . exception ( f" [string] { cls_path } [string] { e }" ) [EOL] continue [EOL] [EOL] self . cache = results [EOL] [EOL] return results [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import builtins [EOL] from typing import List , Tuple , Dict , Any [EOL] import typing [EOL] from recommonmark . parser import CommonMarkParser [EOL] [EOL] [comment] [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] version = [string] [EOL] [comment] [EOL] release = [string] [EOL] [EOL] source_parsers = { [string] : CommonMarkParser , } [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] ) , ] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import flask [EOL] import typing [EOL] [docstring] [EOL] from flask import Blueprint , current_app , request [EOL] from flask_restful import Api , Resource [EOL] [EOL] from diffy . plugins . base import plugins [EOL] from diffy . exceptions import TargetNotFound [EOL] from diffy_api . core import async_baseline [EOL] from diffy_api . common . util import validate_schema [EOL] from diffy_api . schemas import ( baseline_input_schema , baseline_output_schema , task_output_schema , ) [EOL] [EOL] [EOL] mod = Blueprint ( [string] , __name__ ) [EOL] api = Api ( mod ) [EOL] [EOL] [EOL] class BaselineList ( Resource ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( BaselineList , self ) . __init__ ( ) [EOL] [EOL] @ validate_schema ( None , baseline_output_schema ) def get ( self ) : [EOL] [docstring] [EOL] data = plugins . get ( current_app . config [ [string] ] ) . get_all ( [string] ) [EOL] return data , [number] [EOL] [EOL] @ validate_schema ( baseline_input_schema , task_output_schema ) def post ( self , data = None ) : [EOL] [docstring] [EOL] try : [EOL] return async_baseline . queue ( request . json ) [EOL] except TargetNotFound as ex : [EOL] return { [string] : ex . message } , [number] [EOL] [EOL] [EOL] class Baseline ( Resource ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( Baseline , self ) . __init__ ( ) [EOL] [EOL] def get ( self , key ) : [EOL] [docstring] [EOL] return plugins . get ( current_app . config [ [string] ] ) . get ( [string] , key ) [EOL] [EOL] [EOL] api . add_resource ( Baseline , [string] ) [EOL] api . add_resource ( BaselineList , [string] , endpoint = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import os [EOL] [EOL] _basedir = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] [EOL] THREADS_PER_PAGE = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] CORS = False [EOL] debug = False [EOL] [EOL] [comment] [EOL] SECRET_KEY = [string] [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0
import pytest [EOL] import json [EOL] from diffy_api . baseline . views import * [comment] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_list_get ( client , token , status ) : [EOL] assert client . get ( api . url_for ( BaselineList ) , headers = token ) . status_code == status [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_list_post ( client , token , status , sts ) : [EOL] assert ( client . post ( api . url_for ( BaselineList ) , data = { } , headers = token ) . status_code == status ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_list_put ( client , token , status ) : [EOL] assert ( client . put ( api . url_for ( BaselineList ) , data = { } , headers = token ) . status_code == status ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_list_delete ( client , token , status ) : [EOL] assert client . delete ( api . url_for ( BaselineList ) , headers = token ) . status_code == status [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_list_patch ( client , token , status ) : [EOL] assert ( client . patch ( api . url_for ( BaselineList ) , data = { } , headers = token ) . status_code == status ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_get ( client , token , status ) : [EOL] assert ( client . get ( api . url_for ( Baseline , key = [string] ) , headers = token ) . status_code == status ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_post ( client , token , status ) : [EOL] assert ( client . post ( api . url_for ( Baseline , key = [string] ) , data = { } , headers = token ) . status_code == status ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_put ( client , token , status ) : [EOL] assert ( client . put ( api . url_for ( Baseline , key = [string] ) , data = { } , headers = token ) . status_code == status ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_delete ( client , token , status ) : [EOL] assert ( client . delete ( api . url_for ( Baseline , key = [string] ) , headers = token ) . status_code == status ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [number] ) ] ) def test_baseline_patch ( client , token , status ) : [EOL] assert ( client . patch ( api . url_for ( Baseline , key = [string] ) , data = { } , headers = token ) . status_code == status ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0