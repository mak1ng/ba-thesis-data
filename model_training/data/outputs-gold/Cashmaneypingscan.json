from typing import List , Any , Dict [EOL] import typing [EOL] import sys [EOL] from setuptools import setup , Extension [EOL] from setuptools . command . build_ext import build_ext [EOL] [EOL] SRC_DIR = [string] [EOL] PACKAGES = [ SRC_DIR ] [EOL] [EOL] with open ( [string] , [string] ) as fh : [EOL] long_description = fh . read ( ) [EOL] [EOL] extensions = [ ] [EOL] [EOL] if [string] in sys . argv : [EOL] USE_CYTHON = True [EOL] sys . argv . remove ( [string] ) [EOL] else : [EOL] USE_CYTHON = False [EOL] [EOL] ext = [string] if USE_CYTHON else [string] [EOL] extensions = [ Extension ( SRC_DIR + [string] , [ SRC_DIR + [string] + ext ] , language = [string] ) ] [EOL] cmd = { [string] : build_ext } [EOL] [EOL] if USE_CYTHON : [EOL] from Cython . Build import cythonize [EOL] from Cython . Distutils import build_ext as cy_build_ext [EOL] extensions = cythonize ( extensions ) [EOL] cmd = { [string] : cy_build_ext } [EOL] [EOL] setup ( cmdclass = cmd , ext_modules = extensions , name = [string] , version = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , url = [string] , author = [string] , author_email = [string] , python_requires = [string] , license = [string] , packages = PACKAGES , include_package_data = True , package_data = { SRC_DIR : [ [string] , [string] ] } , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import time [EOL] import logging [EOL] import pingscan [EOL] [EOL] [EOL] def main ( ) : [EOL] logging . basicConfig ( level = logging . CRITICAL ) [EOL] [EOL] start_time = time . time ( ) [EOL] [EOL] ips = [ [string] , [string] , [string] , [string] , [string] ] [EOL] res = pingscan . scan ( ips , timeout = [number] ) [EOL] print ( f" [string] { int ( ( time . time ( ) - start_time ) * [number] ) } [string] { len ( res ) } [string] { res }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import asyncio [EOL] import pytest [EOL] [EOL] from pingscan . pingscan import * [EOL] [EOL] import logging [EOL] [EOL] logging . basicConfig ( level = logging . ERROR ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def loop ( ) : [EOL] asyncio . set_event_loop ( asyncio . new_event_loop ( ) ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] yield loop [EOL] loop . close ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import asyncio [EOL] import sys [EOL] import types [EOL] [EOL] [EOL] def loop_compat ( self ) : [EOL] [docstring] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] async def sock_recv_into ( self , sock , buf ) : [EOL] [docstring] [EOL] if self . _debug and sock . gettimeout ( ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] fut = self . create_future ( ) [EOL] self . _sock_recv_into ( fut , None , sock , buf ) [EOL] return await fut [EOL] [EOL] def _sock_recv_into ( self , fut , registered_fd , sock , buf ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if registered_fd is not None : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . remove_reader ( registered_fd ) [EOL] if fut . cancelled ( ) : [EOL] return [EOL] try : [EOL] nbytes = sock . recv_into ( buf ) [EOL] except ( BlockingIOError , InterruptedError ) : [EOL] fd = sock . fileno ( ) [EOL] self . add_reader ( fd , self . _sock_recv_into , fut , fd , sock , buf ) [EOL] except Exception as exc : [EOL] fut . set_exception ( exc ) [EOL] else : [EOL] fut . set_result ( nbytes ) [EOL] self . sock_recv_into = types . MethodType ( sock_recv_into , self ) [EOL] self . _sock_recv_into = types . MethodType ( _sock_recv_into , self ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import socket [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] import socket [EOL] from contextlib import contextmanager , suppress [EOL] [EOL] [EOL] SOCK_BUFSIZ = [number] [EOL] [EOL] [EOL] def _create_socket ( ) : [EOL] sock = socket . socket ( family = socket . AF_INET , type = socket . SOCK_RAW , proto = socket . IPPROTO_ICMP ) [EOL] sock . setsockopt ( socket . SOL_SOCKET , socket . SO_RCVBUF , SOCK_BUFSIZ ) [EOL] sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEPORT , [number] ) [EOL] sock . setsockopt ( socket . SOL_SOCKET , socket . SO_SNDBUF , SOCK_BUFSIZ ) [EOL] sock . setblocking ( False ) [EOL] return sock [EOL] [EOL] [EOL] @ contextmanager def get_eventloop ( ) : [EOL] [comment] [EOL] _loop = asyncio . new_event_loop ( ) [EOL] asyncio . set_event_loop ( _loop ) [EOL] yield _loop [EOL] [EOL] [comment] [EOL] pending = asyncio . Task . all_tasks ( ) [EOL] for task in pending : [EOL] task . cancel ( ) [EOL] [comment] [EOL] [comment] [EOL] with suppress ( asyncio . CancelledError ) : [EOL] _loop . run_until_complete ( task ) [EOL] _loop . close ( ) [EOL] [EOL] [EOL] @ contextmanager def get_socket ( ) : [EOL] [comment] [EOL] _socket = _create_socket ( ) [EOL] try : [EOL] yield _socket [EOL] finally : [EOL] [comment] [EOL] _socket . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , DefaultDict , Tuple , Union , Generator , Any [EOL] import socket [EOL] import typing [EOL] import builtins [EOL] import itertools [EOL] import ipaddress [EOL] import logging [EOL] import ipaddress [EOL] import ctypes [EOL] import math [EOL] import socket [EOL] import logging [EOL] import itertools [EOL] import sys [EOL] from collections import defaultdict [EOL] from typing import Tuple , List , Generator , Union , Any [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def _validate_ip ( ip ) : [EOL] [docstring] [EOL] if isinstance ( ip , int ) : [EOL] raise ValueError ( f' [string] { ip }' ) [EOL] try : [EOL] ipaddress . IPv4Address ( ip ) [EOL] except ipaddress . AddressValueError as e : [EOL] sys . tracebacklimit = [number] [EOL] raise ValueError ( e . __str__ ( ) ) from None [comment] [EOL] [EOL] [EOL] def split_addrs ( ips , workers = [number] ) : [EOL] ip_lists = defaultdict ( list ) [EOL] pos = [number] [EOL] [comment] [EOL] for ip in ips : [EOL] _validate_ip ( ip ) [EOL] [comment] [EOL] if ip_has_netmask ( ip ) : [EOL] [comment] [EOL] for count , net in enumerate ( split_networks ( ip , partitions = workers ) ) : [EOL] ip_lists [ count ] . append ( tuple ( net ) ) [EOL] else : [EOL] ip_lists [ pos ] . append ( ( ip , [string] ) ) [EOL] [EOL] pos = ( pos + [number] ) % workers [EOL] [comment] [EOL] return dict ( ip_lists ) [EOL] [EOL] [EOL] def _generate_ips ( ip , netmask ) : [EOL] [docstring] [EOL] return ip_mask_to_list ( ip , netmask ) [EOL] [EOL] [EOL] def ip_mask_to_list ( ip , netmask = [string] ) : [EOL] [docstring] [EOL] if len ( ip . split ( [string] ) ) == [number] and netmask : [EOL] if netmask == [string] : [EOL] [comment] [EOL] return ( _ for _ in [ ip ] ) [EOL] net = ipaddress . IPv4Network ( f'{ ip } [string] { netmask }' ) [EOL] [EOL] elif len ( ip . split ( [string] ) ) == [number] : [EOL] net = ipaddress . IPv4Network ( ip ) [EOL] else : [EOL] [comment] [EOL] raise ValueError [EOL] [EOL] [comment] [EOL] return itertools . chain ( _gen_network_addr ( net ) , net . hosts ( ) , _gen_broadcast ( net ) ) [EOL] [EOL] [EOL] def _gen_network_addr ( net ) : [EOL] yield net . network_address [EOL] [EOL] [EOL] def _gen_broadcast ( net ) : [EOL] yield net . broadcast_address [EOL] [EOL] [EOL] def host_count ( ip , netmask ) : [EOL] [docstring] [EOL] if netmask == [string] : [EOL] return [number] [EOL] if netmask == [string] : [EOL] return [number] [EOL] [EOL] net = ipaddress . IPv4Network ( f'{ ip } [string] { netmask }' ) [EOL] return net . num_addresses - [number] [EOL] [EOL] [EOL] def ip_has_netmask ( ip = [string] ) : [EOL] [docstring] [EOL] particles = ip . split ( [string] ) [EOL] if len ( particles ) == [number] : [EOL] try : [EOL] if [number] >= int ( particles [ [number] ] ) >= [number] : [EOL] return True [EOL] raise ValueError [EOL] except ValueError as err : [EOL] sys . tracebacklimit = [number] [EOL] err . args = ( f' [string] { particles [ [number] ] } [string] ' , ) [EOL] raise [EOL] return False [EOL] [EOL] [EOL] def _seperate_ip_netmask ( ip ) : [EOL] [docstring] [EOL] net = ipaddress . IPv4Network ( ip ) [EOL] return str ( net . network_address ) , str ( net . netmask ) [EOL] [EOL] [EOL] def split_networks ( ip , netmask = [string] , partitions = [number] ) : [EOL] [docstring] [EOL] _validate_ip ( ip ) [EOL] if ip_has_netmask ( ip ) : [EOL] ip , netmask = _seperate_ip_netmask ( ip ) [EOL] [comment] [EOL] ip_int = int ( ipaddress . IPv4Address ( ip ) ) [EOL] [EOL] [comment] [EOL] shr = int ( math . log ( partitions , [number] ) ) [EOL] [EOL] [comment] [EOL] int_addr = int ( ipaddress . IPv4Address ( netmask ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] mask_add = ctypes . c_uint32 ( ~ int_addr ) . value >> shr [EOL] [EOL] [comment] [EOL] new_mask = ipaddress . IPv4Address ( ctypes . c_uint32 ( ~ mask_add ) . value ) [EOL] [EOL] pairs = [ ] [EOL] for i in range ( partitions ) : [EOL] [comment] [EOL] pairs . append ( ( str ( ipaddress . IPv4Address ( ip_int + i * ( mask_add + [number] ) ) ) , str ( ipaddress . IPv4Address ( new_mask ) ) ) ) [EOL] return pairs [EOL] [EOL] [EOL] def _send ( sock , dest , packet ) : [EOL] try : [EOL] sock . sendto ( packet , ( dest , [number] ) ) [EOL] except OSError as e : [EOL] logger . error ( f" [string] { dest } [string] { packet } [string] { sock } [string] { e }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from pingscan . pingscan import scan [EOL]	0 0 0 0 0 0 0
from typing import Type , Any [EOL] import pingscan [EOL] import typing [EOL] import builtins [EOL] import struct [EOL] import collections [EOL] [comment] [EOL] from pingscan . c_icmp import build as cbuild [EOL] [EOL] ICMPHeader = collections . namedtuple ( [string] , [string] ) [EOL] [EOL] ICMP_ECHO_REPLY = [number] [EOL] ICMP_OFFSET_V4 = [number] [EOL] MSG_ID_OFFSET_V4 = [number] [EOL] SRC_IP_OFFSET_v4 = [number] [EOL] ICMP_NETWORK_UNREACH = [number] [EOL] MAX_SEQUENCE = [number] [EOL] IPv4 = [number] [EOL] IPv6 = [number] [EOL] [EOL] msg_id_offset = MSG_ID_OFFSET_V4 [EOL] offset = ICMP_OFFSET_V4 [EOL] offset_src_ip = SRC_IP_OFFSET_v4 [EOL] [EOL] [EOL] def parse ( packet ) : [EOL] icmp_header = packet [ ICMP_OFFSET_V4 : ICMP_OFFSET_V4 + [number] ] [EOL] icmp_type , code , checksum , _ , _ = struct . unpack ( [string] , icmp_header ) [EOL] return ICMPHeader ( icmp_type , code , checksum ) [EOL] [EOL] [EOL] def build ( seq = [number] , msg_id = [number] ) : [EOL] packet = cbuild ( seq , msg_id ) [EOL] return bytes ( packet ) [EOL] [EOL] [EOL] def msg_id_match ( packet , msg_id = [number] , pos = [number] , family = IPv4 ) : [EOL] return int ( ) . from_bytes ( packet [ msg_id_offset + pos : msg_id_offset + [number] + pos ] , byteorder = [string] ) == msg_id [EOL] [EOL] [EOL] def src_ip_from_packet ( packet , pos = [number] , family = IPv4 ) : [EOL] resp_ip = int ( ) . from_bytes ( packet [ offset_src_ip + pos : offset_src_ip + [number] + pos ] , byteorder = [string] ) [EOL] return resp_ip [EOL] [EOL] [EOL] def is_icmp_reply ( packet , pos = [number] , family = IPv4 ) : [EOL] return packet [ offset + pos ] == ICMP_ECHO_REPLY [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[pingscan.icmp.ICMPHeader]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $ICMPHeader$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[pingscan.icmp.ICMPHeader]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0