[comment] [EOL] [comment] [EOL] from typing import Any , Dict [EOL] import apps [EOL] import typing [EOL] import io [EOL] import os [EOL] from apps . mailagent import MailAgent [EOL] import smtplib [EOL] import pandas as pd [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def parse_excel ( filepath ) : [EOL] [comment] [EOL] [EOL] sheet_name = [string] [EOL] print ( [string] . format ( sheet_name ) ) [EOL] excel = pd . ExcelFile ( filepath ) [EOL] [EOL] if sheet_name not in excel . sheet_names : [EOL] raise Exception ( [string] ) [EOL] [EOL] [comment] [EOL] agent = MailAgent ( [string] ) [EOL] [EOL] sheet_df = excel . parse ( sheet_name ) [EOL] [comment] [EOL] [comment] [EOL] df_name_email_rows = sheet_df [ [ [string] , [string] ] ] [EOL] num = [number] [EOL] for tup in df_name_email_rows . itertuples ( ) : [EOL] [comment] [EOL] print ( [string] + str ( num ) ) [EOL] print ( [string] , tup [ [number] ] , tup [ [number] ] ) [EOL] print ( [string] ) [EOL] if [string] in tup [ [number] ] : [EOL] clean_data = tup [ [number] ] [ : tup [ [number] ] . index ( [string] ) ] [EOL] else : [EOL] clean_data = tup [ [number] ] [EOL] print ( clean_data ) [EOL] row = { [string] : clean_data , [string] : tup [ [number] ] , } [EOL] if num > [number] : [EOL] break [EOL] else : [EOL] num += [number] [EOL] agent . send_mapped_data_email ( row ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [comment] [EOL] filepath = [string] [EOL] if os . path . isfile ( filepath ) : [EOL] print ( [string] ) [EOL] parse_excel ( filepath ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import os [EOL] import pytest [EOL] import logging [EOL] from logging import Logger [EOL] from . config import TestCommonConifg [EOL] from typing import Callable [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def logger ( ) : [EOL] name = TestCommonConifg . LOGGER_NAME [EOL] return logging . getLogger ( name ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . fixture def find_sheet_path ( ) : [EOL] [docstring] [EOL] def _find_sheet_path ( filename ) : [EOL] dirpath = os . path . dirname ( __file__ ) [EOL] sheet_dir = TestCommonConifg . SHEET_TEST_DIRNAME [EOL] filepath = os . path . join ( dirpath , sheet_dir , filename ) [EOL] return filepath [EOL] [EOL] return _find_sheet_path [EOL] [EOL] [EOL] @ pytest . fixture def find_email_template_path ( ) : [EOL] [docstring] [EOL] def _find_email_template_path ( filename ) : [EOL] dirpath = os . path . dirname ( __file__ ) [EOL] email_dir = TestCommonConifg . EMAIL_TEMPLATE_TEST_DIRNAME [EOL] filepath = os . path . join ( dirpath , email_dir , filename ) [EOL] return filepath [EOL] [EOL] return _find_email_template_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Callable [EOL] import builtins [EOL] import apps [EOL] import typing [EOL] import logging [EOL] import pytest [EOL] from typing import Callable [EOL] from logging import Logger [EOL] from apps . dto . source import PreMergeSourceDTO [EOL] from apps . services . datasource import PreMergeSourceParsingService [EOL] from tests . config import TestSheetConifg , TestParsingSourceConifg [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def cn_header_sheet_path ( find_sheet_path ) : [EOL] filename = TestSheetConifg . TEST_CN_HEADER_SHEET_FILENAME [EOL] return find_sheet_path ( filename ) [EOL] [EOL] [EOL] class TestPreMergeSourceParsingService ( object ) : [EOL] def test_parsing_excel_result_correct ( self , logger , cn_header_sheet_path ) : [EOL] [EOL] expected = PreMergeSourceDTO ( TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_EXPECTED_COLHEADER , TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_EXPECTED_ROWSET ) [EOL] [EOL] service = PreMergeSourceParsingService ( ) [EOL] result_dto = service . parsing_excel ( cn_header_sheet_path ) [EOL] logger . debug ( f" [string] { result_dto }" ) [EOL] assert result_dto == expected [EOL] [EOL] def test_parsing_excel_result_header_data_not_correct ( self , logger , cn_header_sheet_path ) : [EOL] [EOL] expected = PreMergeSourceDTO ( TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_NON_EXPECTED_COLHEADER_DATA_DIFF , TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_EXPECTED_ROWSET ) [EOL] [EOL] service = PreMergeSourceParsingService ( ) [EOL] result_dto = service . parsing_excel ( cn_header_sheet_path ) [EOL] logger . debug ( f" [string] { result_dto }" ) [EOL] assert result_dto != expected [EOL] [EOL] def test_parsing_excel_result_header_order_not_correct ( self , logger , cn_header_sheet_path ) : [EOL] [EOL] expected = PreMergeSourceDTO ( TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_NON_EXPECTED_COLHEADER_ORDER_DIFF , TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_EXPECTED_ROWSET ) [EOL] [EOL] service = PreMergeSourceParsingService ( ) [EOL] result_dto = service . parsing_excel ( cn_header_sheet_path ) [EOL] logger . debug ( f" [string] { result_dto }" ) [EOL] assert result_dto != expected [EOL] [EOL] def test_parsing_excel_result_row_data_not_correct ( self , logger , cn_header_sheet_path ) : [EOL] [EOL] expected = PreMergeSourceDTO ( TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_NON_EXPECTED_COLHEADER_DATA_DIFF , TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_EXPECTED_ROWSET ) [EOL] [EOL] service = PreMergeSourceParsingService ( ) [EOL] result_dto = service . parsing_excel ( cn_header_sheet_path ) [EOL] logger . debug ( f" [string] { result_dto }" ) [EOL] assert result_dto != expected [EOL] [EOL] def test_parsing_excel_result_row_order_not_correct ( self , logger , cn_header_sheet_path ) : [EOL] [EOL] expected = PreMergeSourceDTO ( TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_NON_EXPECTED_COLHEADER_ORDER_DIFF , TestParsingSourceConifg . TEST_CH_PREMERGE_SOURCE_EXPECTED_ROWSET ) [EOL] [EOL] service = PreMergeSourceParsingService ( ) [EOL] result_dto = service . parsing_excel ( cn_header_sheet_path ) [EOL] logger . debug ( f" [string] { result_dto }" ) [EOL] assert result_dto != expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List , Callable , Any , Dict [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import pytest [EOL] from logging import Logger [EOL] from unittest . mock import MagicMock [EOL] from typing import Dict , List , Callable , Any [EOL] from domain . models . excel import ExcelSheetParser [EOL] from infra . excepts . codes import ErrorCodesInfo [EOL] from infra . excepts . types import FilePathNotFound [EOL] from infra . excepts . types import FileFormatError [EOL] from infra . excepts . types import FileContentNotExist [EOL] from tests . config import TestSheetConifg , TestParsinExcelSheetConifg [EOL] [EOL] [EOL] class TestExcelSheetParser ( object ) : [EOL] [EOL] def test_file_is_excel_format_and_exist ( self , logger , find_sheet_path ) : [EOL] exist_sheet_filename = TestSheetConifg . TEST_CN_HEADER_SHEET_FILENAME [EOL] exist_filepath = find_sheet_path ( exist_sheet_filename ) [EOL] self . excel = ExcelSheetParser ( exist_filepath ) [EOL] logger . debug ( f" [string] { exist_filepath }" ) [EOL] [EOL] assert self . excel . filename == exist_filepath [EOL] [EOL] def test_file_not_exist ( self , logger , find_sheet_path ) : [EOL] [comment] [EOL] expected = ErrorCodesInfo . SOURCE_EXCEL_NOT_EXIST . name [EOL] [EOL] non_exist_filename = TestSheetConifg . TEST_NON_EXIST_SHEET_FILENAME [EOL] non_exist_filepath = find_sheet_path ( non_exist_filename ) [EOL] logger . debug ( f" [string] { non_exist_filepath }" ) [EOL] with pytest . raises ( FilePathNotFound ) as errinfo : [EOL] self . excel = ExcelSheetParser ( non_exist_filepath ) [EOL] logger . debug ( f" [string] { errinfo . value }" ) [EOL] [EOL] assert errinfo . value . error_code == expected [EOL] [EOL] def test_file_not_excel_format ( self , logger , find_sheet_path ) : [EOL] expected = ErrorCodesInfo . SOURCE_FILE_NOT_EXCEL_FORMAT . name [EOL] [EOL] non_excel_format_filename = TestSheetConifg . TEST_NON_EXCEL_FORMAT_FILE [EOL] non_excel_format_filepath = find_sheet_path ( non_excel_format_filename ) [EOL] logger . debug ( f" [string] { non_excel_format_filepath }" ) [EOL] with pytest . raises ( FileFormatError ) as errinfo : [EOL] self . excel = ExcelSheetParser ( non_excel_format_filepath ) [EOL] logger . debug ( f" [string] { errinfo . value }" ) [EOL] [EOL] assert errinfo . value . error_code == expected [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( TestSheetConifg . TEST_CN_HEADER_SHEET_FILENAME , TestParsinExcelSheetConifg . TEST_CN_HEADER_SHEET_EXPECTED_RESULT ) , ( TestSheetConifg . TEST_EN_HEADER_SHEET_FILENAME , TestParsinExcelSheetConifg . TEST_EN_HEADER_SHEET_EXPECTED_RESULT ) ] ) def test_read_default_datasheet_correct ( self , sheet_filename , expected , logger , find_sheet_path ) : [EOL] filepath = find_sheet_path ( sheet_filename ) [EOL] self . excel = ExcelSheetParser ( filepath ) [EOL] self . excel . read_sheet ( ) [EOL] sheet_records = self . excel . datasheet . to_dict ( [string] ) [EOL] [EOL] assert sheet_records == expected [EOL] [EOL] def test_read_default_datasheet_data_not_correct ( self , logger , find_sheet_path ) : [EOL] expected = TestParsinExcelSheetConifg . TEST_CN_HEADER_SHEET_NON_EXPECTED_RESULT_DATA_DIFF [EOL] [EOL] sheet_filename = TestSheetConifg . TEST_CN_HEADER_SHEET_FILENAME [EOL] filepath = find_sheet_path ( sheet_filename ) [EOL] self . excel = ExcelSheetParser ( filepath ) [EOL] self . excel . read_sheet ( ) [EOL] sheet_records = self . excel . datasheet . to_dict ( [string] ) [EOL] [EOL] assert sheet_records != expected [EOL] [EOL] def test_read_default_datasheet_order_not_correct ( self , logger , find_sheet_path ) : [EOL] expected = TestParsinExcelSheetConifg . TEST_CN_HEADER_SHEET_NON_EXPECTED_RESULT_ORDER_DIFF [EOL] [EOL] sheet_filename = TestSheetConifg . TEST_CN_HEADER_SHEET_FILENAME [EOL] filepath = find_sheet_path ( sheet_filename ) [EOL] self . excel = ExcelSheetParser ( filepath ) [EOL] self . excel . read_sheet ( ) [EOL] result = self . excel . datasheet . to_dict ( [string] ) [EOL] [EOL] assert result != expected [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def test_read_sepcific_non_exist_sheetname ( self , logger , find_sheet_path ) : [EOL] expected = ErrorCodesInfo . SHEET_NOT_FOUND_IN_EXCEL . name [EOL] [EOL] filename = TestSheetConifg . TEST_EN_HEADER_SHEET_FILENAME [EOL] sheetname = TestSheetConifg . TEST_EN_HEADER_NON_EXIST_SHEET_NAME [EOL] filepath = find_sheet_path ( filename ) [EOL] self . excel = ExcelSheetParser ( filepath ) [EOL] [EOL] with pytest . raises ( FileContentNotExist ) as errinfo : [EOL] self . excel . read_sheet ( sheetname ) [EOL] [EOL] assert errinfo . value . error_code == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $logging.Logger$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $logging.Logger$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $logging.Logger$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 $builtins.str$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $None$ 0 0 0 $logging.Logger$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $None$ 0 0 0 $logging.Logger$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $logging.Logger$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Callable[[builtins.str],builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[comment] [EOL] [EOL] [EOL] from typing import Type [EOL] import settings [EOL] import typing [EOL] class Config ( object ) : [EOL] ACTION_OPTION_PDF = [string] [EOL] ACTION_OPTION_HTML = [string] [EOL] ACTION_OPTION_EMAIL = [string] [EOL] ACTION_OPTIONS = [ ACTION_OPTION_PDF , ACTION_OPTION_HTML , ACTION_OPTION_EMAIL ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . base import Config [EOL] [EOL] [EOL] class ProdConfig ( Config ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . base import Config [EOL] [EOL] [EOL] class DevConfig ( Config ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import os [EOL] from . factory import LoggerFactory [EOL] [EOL] [EOL] proj_path = os . path . dirname ( os . path . dirname ( os . path . dirname ( __file__ ) ) ) [EOL] logging_conf = os . path . abspath ( os . path . join ( proj_path , [string] ) ) [EOL] [EOL] factory = LoggerFactory ( ) [EOL] factory . load_config ( logging_conf ) [EOL] scraping_logger = factory . get_logger ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0
	0
import builtins [EOL] import abc [EOL] [EOL] [EOL] class IWriter ( abc . ABC ) : [EOL] [EOL] @ classmethod @ abc . abstractmethod def write ( cls , filename , src ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0
import builtins [EOL] from . import IWriter [EOL] [EOL] [EOL] class HtmlWriter ( IWriter ) : [EOL] @ classmethod def write ( cls , filename , src ) : [EOL] filename = filename + [string] [EOL] try : [EOL] with open ( filename , [string] , encoding = [string] ) as fp : [EOL] fp . write ( src ) [EOL] return True [EOL] except Exception as e : [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] import pdfkit [EOL] from . import IWriter [EOL] [EOL] [EOL] class PDFWriter ( IWriter ) : [EOL] @ classmethod def write ( cls , filename , src ) : [EOL] filename = filename + [string] [EOL] success = pdfkit . from_string ( src , filename , options = { [string] : [string] } ) [EOL] return success [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
import builtins [EOL] import os [EOL] from infra . excepts . types import FilePathNotFound [EOL] from infra . excepts . codes import ErrorCodesInfo [EOL] [EOL] [EOL] class FilePathSearcher ( object ) : [EOL] [EOL] @ classmethod def exist ( cls , path ) : [EOL] [docstring] [EOL] if path . startswith ( [string] ) : [EOL] fullpath = os . path . realpath ( os . path . expanduser ( path ) ) [EOL] else : [EOL] fullpath = os . path . realpath ( path ) [EOL] if os . path . exists ( fullpath ) : [EOL] return True [EOL] return False [EOL] [EOL] @ classmethod def fullpath ( cls , path ) : [EOL] [docstring] [EOL] if cls . exist ( path ) : [EOL] if path . startswith ( [string] ) : [EOL] return os . path . realpath ( os . path . expanduser ( path ) ) [EOL] else : [EOL] return os . path . realpath ( path ) [EOL] raise FilePathNotFound ( ErrorCodesInfo . PATH_NOT_FOUND , path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
	0
	0
[comment] [EOL] from enum import Enum [EOL] [EOL] [EOL] class ErrorCodesInfo ( Enum ) : [EOL] [docstring] [EOL] PATH_NOT_FOUND = [string] [EOL] SOURCE_EXCEL_NOT_EXIST = [string] [EOL] EMAIL_DRAFT_PATH_NOT_EXIST = [string] [EOL] SOURCE_FILE_NOT_EXCEL_FORMAT = [string] [EOL] SHEET_NOT_FOUND_IN_EXCEL = [string] [EOL] SHEET_CONTENT_EMPTY = [string] [EOL] EMAIL_DRAFT_CONTENT_NOT_EXIST = [string] [EOL] ALL_MERGE_TAG_NOT_MATCH = [string] [EOL] NO_MERGE_TAGS = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import codes [EOL] from typing import Optional [EOL] from . codes import ErrorCodesInfo [EOL] [EOL] [EOL] class ApplicationException ( Exception ) : [EOL] def __init__ ( self , error , detail = None ) : [EOL] self . _error_code = error . name [EOL] self . _error_message = error . value [EOL] self . _detail = detail [EOL] [EOL] @ property def error_code ( self ) : [EOL] return self . _error_code [EOL] [EOL] @ property def error_message ( self ) : [EOL] return self . _error_message [EOL] [EOL] @ property def detail ( self ) : [EOL] return self . _detail [EOL] [EOL] [EOL] class FilePathNotFound ( ApplicationException ) : [EOL] [docstring] [EOL] def __init__ ( self , error , detail , path = None ) : [EOL] self . _path = path [EOL] super ( FilePathNotFound , self ) . __init__ ( error , detail ) [EOL] [EOL] @ property def path ( self ) : [EOL] return self . _path [EOL] [EOL] [EOL] class FileFormatError ( ApplicationException ) : [EOL] [docstring] [EOL] def __init__ ( self , error , detail , path = None ) : [EOL] self . _path = path [EOL] super ( FileFormatError , self ) . __init__ ( error , detail ) [EOL] [EOL] @ property def path ( self ) : [EOL] return self . _path [EOL] [EOL] [EOL] class FileContentNotExist ( ApplicationException ) : [EOL] [docstring] [EOL] def __init__ ( self , error , detail = None ) : [EOL] super ( FileContentNotExist , self ) . __init__ ( error , detail ) [EOL] [EOL] [EOL] class MergedContentFailed ( ApplicationException ) : [EOL] [docstring] [EOL] def __init__ ( self , error , detail = None ) : [EOL] super ( MergedContentFailed , self ) . __init__ ( error , detail ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $codes.ErrorCodesInfo$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $codes.ErrorCodesInfo$ 0 0 0 0 0 0 0 $codes.ErrorCodesInfo$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $codes.ErrorCodesInfo$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $codes.ErrorCodesInfo$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $codes.ErrorCodesInfo$ 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $codes.ErrorCodesInfo$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $codes.ErrorCodesInfo$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $codes.ErrorCodesInfo$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $codes.ErrorCodesInfo$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $codes.ErrorCodesInfo$ 0 $typing.Optional[builtins.str]$ 0 0
	0
	0
from typing import List , Any , Dict , Type [EOL] import domain [EOL] import apps [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import re [EOL] import copy [EOL] from typing import List , Dict [EOL] from collections import OrderedDict [EOL] from logging import Logger [EOL] from jinja2 import BaseLoader [EOL] from jinja2 import Environment , meta [EOL] from jinja2 import TemplatesNotFound [EOL] from apps . dto . source import ColHeader , RowSet [EOL] from domain . models . merged import MergedSetVO [EOL] from infra . excepts . codes import ErrorCodesInfo [EOL] from infra . excepts . types import MergedContentFailed [EOL] from infra . logging import scraping_logger [EOL] import pdfkit [EOL] [EOL] [EOL] class SourceMerger ( object ) : [EOL] [comment] [EOL] _logger = scraping_logger [EOL] [EOL] def __init__ ( self , draft_content ) : [EOL] self . _draft_content = draft_content [EOL] self . _find_pattern = [string] [EOL] self . _sub_pattern = [string] [EOL] [EOL] def _clean_word ( self , word ) : [EOL] return re . sub ( self . _sub_pattern , [string] , word ) . strip ( ) [EOL] [EOL] def _merge_rowset ( self , src_headers , src_dataset , found_words ) : [EOL] [docstring] [EOL] merge_content = copy . deepcopy ( self . _draft_content ) [EOL] matched_headers = [ self . _clean_word ( found_word ) for found_word in found_words if self . _clean_word ( found_word ) in src_headers ] [EOL] if not matched_headers : [EOL] raise MergedContentFailed ( ErrorCodesInfo . ALL_MERGE_TAG_NOT_MATCH ) [EOL] [EOL] for header in matched_headers : [EOL] merged_pattern = [string] + header + [string] [EOL] self . _logger . debug ( f" [string] { header }" ) [EOL] source_content = src_dataset [ header ] [EOL] merge_content = re . sub ( merged_pattern , source_content , merge_content ) [EOL] return merge_content [EOL] [EOL] def merge_source ( self , src_headers , src_datasets ) : [EOL] [docstring] [EOL] ROWSET_NAME_IDX = [number] [EOL] found_words = re . findall ( self . _find_pattern , self . _draft_content ) [EOL] merged_contents = [ ] [EOL] if found_words : [EOL] for dataset in src_datasets : [EOL] merged_name = dataset [ src_headers [ ROWSET_NAME_IDX ] ] [EOL] merged_content = self . _merge_rowset ( src_headers , dataset , found_words ) [EOL] merged_contents . append ( MergedSetVO ( merged_name , merged_content ) ) [EOL] return merged_contents [EOL] raise MergedContentFailed ( ErrorCodesInfo . NO_MERGE_TAGS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[domain.models.merged.MergedSetVO]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] import builtins [EOL] class OutputResultVO ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , name , success ) : [EOL] self . _name = name [EOL] self . _success = success [EOL] [EOL] @ property def name ( self ) : [EOL] return self . _name [EOL] [EOL] @ property def success ( self ) : [EOL] return self . _success [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , OutputResultVO ) : [EOL] return False [EOL] if self . name == other . name and self . success == other . success : [EOL] return True [EOL] return False [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . name , self . success ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] import builtins [EOL] class MergedSetVO ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , name , content ) : [EOL] self . _name = name [EOL] self . _content = content [EOL] [EOL] @ property def name ( self ) : [EOL] return self . _name [EOL] [EOL] @ property def content ( self ) : [EOL] return self . _content [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , MergedSetVO ) : [EOL] return False [EOL] if self . name == other . name and self . content == other . content : [EOL] return True [EOL] return False [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . name , self . content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from enum import Enum [EOL] [EOL] [EOL] class OutputOption ( Enum ) : [EOL] PDF = [number] [EOL] HTML = [number] [EOL] EMAIL_SEND = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . dataset import MergedSetVO [EOL] from . output import MergedOutputExcutor [EOL] from . option import OutputOption [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict , Type [EOL] import option [EOL] import infra [EOL] import result [EOL] import typing [EOL] import dataset [EOL] from typing import List , Dict , Type [EOL] from collections import OrderedDict [EOL] from . dataset import MergedSetVO [EOL] from . option import OutputOption [EOL] from . result import OutputResultVO [EOL] from infra . writer import IWriter [EOL] from infra . writer . pdf import PDFWriter [EOL] from infra . writer . html import HtmlWriter [EOL] [EOL] [EOL] class MergedOutputExcutor ( object ) : [EOL] [EOL] output_options = { OutputOption . PDF : PDFWriter , OutputOption . HTML : HtmlWriter } [EOL] [EOL] @ classmethod def output ( cls , option , merged_sets ) : [EOL] [docstring] [EOL] dataset = ... [EOL] results = [ ] [EOL] for dataset in merged_sets : [EOL] success = cls . output_options [ option ] . write ( dataset . name , dataset . content ) [EOL] results . append ( OutputResultVO ( dataset . name , success ) ) [EOL] return results [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[option.OutputOption,typing.Type[infra.writer.IWriter]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[result.OutputResultVO]$ 0 0 0 $option.OutputOption$ 0 $typing.List[dataset.MergedSetVO]$ 0 0 0 0 0 $dataset.MergedSetVO$ 0 0 0 $typing.List[result.OutputResultVO]$ 0 0 0 0 0 $dataset.MergedSetVO$ 0 $typing.List[dataset.MergedSetVO]$ 0 0 $builtins.bool$ 0 0 0 0 0 $option.OutputOption$ 0 0 0 0 $dataset.MergedSetVO$ 0 0 0 $dataset.MergedSetVO$ 0 0 0 0 $typing.List[result.OutputResultVO]$ 0 0 0 0 0 $dataset.MergedSetVO$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.List[result.OutputResultVO]$ 0
from . excel import ExcelSheetParser [EOL] from . draft import EmailDraftReader [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import logging [EOL] import os [EOL] import re [EOL] from logging import Logger [EOL] from jinja2 import FileSystemLoader [EOL] from jinja2 import Environment [EOL] from jinja2 import TemplatesNotFound [EOL] from infra . excepts . codes import ErrorCodesInfo [EOL] from infra . excepts . types import FilePathNotFound [EOL] from infra . excepts . types import FileContentNotExist [EOL] from infra . logging import scraping_logger [EOL] from infra . path . searcher import FilePathSearcher [EOL] [EOL] [EOL] class EmailDraftReader ( object ) : [EOL] _logger = scraping_logger [EOL] [EOL] def __init__ ( self , draftname ) : [EOL] self . _draftname = draftname [EOL] self . _draftpath = self . _find_draftpath ( draftname ) [EOL] [EOL] def _find_draftpath ( self , draftname ) : [EOL] [docstring] [EOL] if not FilePathSearcher . exist ( draftname ) : [EOL] raise FilePathNotFound ( ErrorCodesInfo . EMAIL_DRAFT_PATH_NOT_EXIST , draftname ) [EOL] [EOL] return FilePathSearcher . fullpath ( draftname ) [EOL] [EOL] def read ( self ) : [EOL] [docstring] [EOL] content = [string] [EOL] with open ( self . _draftpath , mode = [string] , encoding = [string] ) as fp : [EOL] content = fp . read ( ) [EOL] return content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0
[comment] [EOL] from typing import List , Optional , Type [EOL] import builtins [EOL] import pandas [EOL] import typing [EOL] import domain [EOL] import os [EOL] from typing import Optional [EOL] from logging import Logger [EOL] import pandas as pd [EOL] from infra . logging import scraping_logger [EOL] from infra . excepts . types import FilePathNotFound [EOL] from infra . excepts . types import FileFormatError [EOL] from infra . excepts . types import FileContentNotExist [EOL] from infra . excepts . codes import ErrorCodesInfo [EOL] from infra . path . searcher import FilePathSearcher [EOL] [EOL] [EOL] class ExcelSheetParser ( object ) : [EOL] [comment] [EOL] _logger = scraping_logger [EOL] [EOL] def __init__ ( self , filename ) : [EOL] self . _set_filename ( filename ) [EOL] self . _datasheet = pd . DataFrame ( ) [EOL] self . _excel = pd . ExcelFile ( self . filename ) [EOL] [EOL] def _does_excel_format ( self , path ) : [EOL] support_extension = [ [string] , [string] ] [EOL] for extension in support_extension : [EOL] if path . endswith ( extension ) : [EOL] return True [EOL] return False [EOL] [EOL] def _set_filename ( self , filename ) : [EOL] if not FilePathSearcher . exist ( filename ) : [EOL] raise FilePathNotFound ( ErrorCodesInfo . SOURCE_EXCEL_NOT_EXIST , filename ) [EOL] if not self . _does_excel_format ( filename ) : [EOL] raise FileFormatError ( ErrorCodesInfo . SOURCE_FILE_NOT_EXCEL_FORMAT , filename ) [EOL] [EOL] self . _filename = FilePathSearcher . fullpath ( filename ) [EOL] [EOL] @ property def datasheet ( self ) : [EOL] return self . _datasheet [EOL] [EOL] @ property def filename ( self ) : [EOL] return self . _filename [EOL] [EOL] def read_sheet ( self , sheetname = None ) : [EOL] [docstring] [EOL] [EOL] if sheetname : [EOL] if sheetname not in self . _excel . sheet_names : [EOL] raise FileContentNotExist ( ErrorCodesInfo . SHEET_NOT_FOUND_IN_EXCEL ) [EOL] self . _datasheet = self . _excel . parse ( sheetname ) [EOL] else : [EOL] self . _datasheet = self . _excel . parse ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[domain.models.sources.excel.ExcelSheetParser]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $pandas.DataFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Set [EOL] import jinja2 [EOL] import email [EOL] import typing [EOL] import smtplib [EOL] import os [EOL] import math [EOL] import smtplib [EOL] import json [EOL] from jinja2 import Environment , PackageLoader , select_autoescape , meta , TemplateNotFound [EOL] from email . mime . multipart import MIMEMultipart [EOL] from email . mime . text import MIMEText [EOL] [EOL] [EOL] class MailAgent ( object ) : [EOL] def __init__ ( self , mail_name ) : [EOL] [docstring] [EOL] self . _jinja_env = Environment ( loader = PackageLoader ( [string] , [string] ) , autoescape = select_autoescape ( [ [string] , [string] ] ) ) [EOL] self . _mail_name = mail_name [EOL] self . _mail_content_template = None [EOL] self . _config_json = json . loads ( open ( os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) , [string] ) , [string] ) . read ( ) ) [EOL] [EOL] def __find_variables ( self , env , mail_name ) : [EOL] [docstring] [EOL] try : [EOL] template_source = env . loader . get_source ( env , mail_name ) [ [number] ] [EOL] parsed_content = env . parse ( template_source ) [EOL] vars = meta . find_undeclared_variables ( parsed_content ) [EOL] return vars [EOL] except TemplateNotFound as te : [EOL] print ( [string] ) [EOL] [EOL] def __mapping_variable ( self , template_vars , mapping_data ) : [EOL] [comment] [EOL] [comment] [EOL] template_vars = set ( [ var . decode ( [string] ) for var in template_vars ] ) [EOL] not_include_template_vars = set ( mapping_data . keys ( ) ) - template_vars [EOL] [comment] [EOL] not_mapped_var_in_template = template_vars - set ( mapping_data . keys ( ) ) [EOL] if not_include_template_vars : [EOL] print ( [string] . format ( [string] . join ( not_include_template_vars ) ) ) [EOL] if not_mapped_var_in_template : [EOL] print ( [string] . format ( [string] . join ( not_mapped_var_in_template ) ) ) [EOL] [comment] [EOL] [comment] [EOL] return True [EOL] [EOL] def send_mapped_data_email ( self , mapping_data ) : [EOL] [docstring] [EOL] [EOL] template_vars = self . __find_variables ( self . _jinja_env , self . _mail_name ) [EOL] if self . __mapping_variable ( template_vars , mapping_data ) : [EOL] html_content = self . _jinja_env . get_template ( self . _mail_name ) . render ( ** mapping_data ) [EOL] sender = self . _config_json [ [string] ] [EOL] sender_name = self . _config_json [ [string] ] [EOL] receivers = self . _config_json [ [string] ] [ [string] ] [EOL] [comment] [EOL] msg_root = MIMEMultipart ( [string] ) [EOL] msg_root [ [string] ] = self . _config_json [ [string] ] [EOL] msg_root [ [string] ] = sender_name [EOL] if [string] in mapping_data . keys ( ) and ( type ( mapping_data [ [string] ] ) is str ) : [EOL] receivers = [ mapping_data [ [string] ] ] [EOL] [comment] [EOL] msg_root [ [string] ] = [string] . join ( receivers ) [EOL] else : [EOL] print ( [string] , mapping_data [ [string] ] , [string] ) [EOL] print ( [string] ) [EOL] return [EOL] msg_alternative = MIMEMultipart ( [string] ) [EOL] msg_root . attach ( msg_alternative ) [EOL] msg_alternative . attach ( MIMEText ( html_content , [string] , [string] ) ) [EOL] try : [EOL] smtp_obj = smtplib . SMTP ( self . _config_json [ [string] ] , [number] ) [EOL] smtp_obj . ehlo ( ) [EOL] smtp_obj . starttls ( ) [EOL] smtp_obj . login ( sender , self . _config_json [ [string] ] ) [EOL] smtp_obj . sendmail ( sender , receivers , msg_root . as_string ( ) ) [EOL] print ( [string] , mapping_data [ [string] ] , [string] ) [EOL] print ( [string] ) [EOL] except smtplib . SMTPException : [EOL] print ( [string] , [string] , mapping_data [ [string] ] , [string] ) [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $smtplib.SMTP$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $email.mime.multipart.MIMEMultipart$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] import builtins [EOL] import apps [EOL] import logging [EOL] from logging import Logger [EOL] from apps . dto . source import PreMergeSourceDTO [EOL] from apps . assembler . source import PreMergeSourceAssembler [EOL] from domain . models . sources import ExcelSheetParser [EOL] from infra . logging import scraping_logger [EOL] [EOL] [EOL] class PreMergeSourceParsingService ( object ) : [EOL] [comment] [EOL] _logger = scraping_logger [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def parsing_excel ( self , filename ) : [EOL] self . _excel = ExcelSheetParser ( filename ) [EOL] self . _excel . read_sheet ( ) [EOL] resp_dto = PreMergeSourceAssembler ( ) . sheet2source ( self . _excel . datasheet ) [EOL] self . _logger . debug ( f" [string] { resp_dto }" ) [EOL] return resp_dto [EOL] [EOL] [EOL] parsing_service = PreMergeSourceParsingService ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 $apps.services.datasource.PreMergeSourceParsingService$ 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import domain [EOL] import builtins [EOL] import apps [EOL] import typing [EOL] import logging [EOL] from typing import List [EOL] from logging import Logger [EOL] from infra . logging import scraping_logger [EOL] from apps . dto . source import PreMergeSourceDTO [EOL] from domain . models . sources import EmailDraftReader [EOL] from domain . models . merged import MergedSetVO [EOL] from domain . models . merged import OutputOption [EOL] from domain . models . merged import MergedOutputExcutor [EOL] from domain . models . merger import SourceMerger [EOL] [EOL] [EOL] class SourceMergeEmailDraftService ( object ) : [EOL] [comment] [EOL] _logger = scraping_logger [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def read_draft ( self , filename ) : [EOL] [docstring] [EOL] reader = EmailDraftReader ( filename ) [EOL] return reader . read ( ) [EOL] [EOL] def merge2pdf ( self , draft_content , source ) : [EOL] merger = SourceMerger ( draft_content ) [EOL] merged_contents = merger . merge_source ( source . headers , source . dataset ) [EOL] results = MergedOutputExcutor . output ( OutputOption . PDF , merged_contents ) [EOL] print ( results ) [EOL] [EOL] def merge2html ( self , draft_content , source ) : [EOL] merger = SourceMerger ( draft_content ) [EOL] merged_contents = merger . merge_source ( source . headers , source . dataset ) [EOL] results = MergedOutputExcutor . output ( OutputOption . HTML , merged_contents ) [EOL] print ( results ) [EOL] [EOL] def merge2send ( self , draft_content , source ) : [EOL] pass [EOL] [EOL] [EOL] merge_service = SourceMergeEmailDraftService ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $domain.models.sources.draft.EmailDraftReader$ 0 0 0 $builtins.str$ 0 0 0 $domain.models.sources.draft.EmailDraftReader$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 $domain.models.merger.SourceMerger$ 0 0 0 $builtins.str$ 0 0 $typing.List[domain.models.merged.MergedSetVO]$ 0 $domain.models.merger.SourceMerger$ 0 0 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 0 $typing.List[domain.models.merged.result.OutputResultVO]$ 0 0 0 0 0 0 0 0 0 $typing.List[domain.models.merged.MergedSetVO]$ 0 0 0 0 $typing.List[domain.models.merged.result.OutputResultVO]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 $domain.models.merger.SourceMerger$ 0 0 0 $builtins.str$ 0 0 $typing.List[domain.models.merged.MergedSetVO]$ 0 $domain.models.merger.SourceMerger$ 0 0 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 0 $typing.List[domain.models.merged.result.OutputResultVO]$ 0 0 0 0 0 0 0 0 0 $typing.List[domain.models.merged.MergedSetVO]$ 0 0 0 0 $typing.List[domain.models.merged.result.OutputResultVO]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 0 0 0 0 $apps.services.draftmerge.SourceMergeEmailDraftService$ 0 0 0 0 0
	0
from typing import List , Dict [EOL] import apps [EOL] import pandas [EOL] import typing [EOL] from typing import List , Dict [EOL] from pandas import DataFrame [EOL] from apps . dto . source import PreMergeSourceDTO , ColHeader , RowSet [EOL] [EOL] [EOL] class PreMergeSourceAssembler ( object ) : [EOL] [EOL] def sheet2source ( self , datasheet ) : [EOL] headers = list ( datasheet . columns . values ) [EOL] [comment] [EOL] datasets = datasheet . to_dict ( [string] ) [EOL] return PreMergeSourceDTO ( headers , datasets ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $apps.dto.source.PreMergeSourceDTO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[apps.dto.source.ColHeader,apps.dto.source.RowSet]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[apps.dto.source.ColHeader,apps.dto.source.RowSet]]$ 0 0
from typing import List , Any , Dict , Type [EOL] import builtins [EOL] import typing [EOL] from typing import List , Dict , NewType , Any [EOL] [EOL] [EOL] ColHeader = str [EOL] RowSet = Any [EOL] [EOL] [EOL] class PreMergeSourceDTO ( object ) : [EOL] def __init__ ( self , headers , dataset ) : [EOL] self . headers = headers [EOL] self . dataset = dataset [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , PreMergeSourceDTO ) : [EOL] if self . headers == other . headers and self . dataset == other . dataset : [EOL] return True [EOL] return False [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . headers } [string] { self . dataset }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0