from typing import Any , List [EOL] import typing [EOL] import dash [EOL] import dash_core_components as dcc [EOL] import dash_html_components as html [EOL] import pandas as pd [EOL] import plotly . graph_objs as go [EOL] [EOL] df = pd . read_csv ( [string] [string] ) [EOL] [EOL] external_stylesheets = [ [string] ] [EOL] [EOL] app = dash . Dash ( __name__ , external_stylesheets = external_stylesheets ) [EOL] [EOL] app . layout = html . Div ( [ dcc . Graph ( id = [string] ) , dcc . Slider ( id = [string] , min = df [ [string] ] . min ( ) , max = df [ [string] ] . max ( ) , value = df [ [string] ] . min ( ) , marks = { str ( year ) : str ( year ) for year in df [ [string] ] . unique ( ) } ) ] ) [EOL] [EOL] [EOL] @ app . callback ( dash . dependencies . Output ( [string] , [string] ) , [ dash . dependencies . Input ( [string] , [string] ) ] ) def update_figure ( selected_year ) : [EOL] filtered_df = df [ df . year == selected_year ] [EOL] traces = [ ] [EOL] for i in filtered_df . continent . unique ( ) : [EOL] df_by_continent = filtered_df [ filtered_df [ [string] ] == i ] [EOL] traces . append ( go . Scatter ( x = df_by_continent [ [string] ] , y = df_by_continent [ [string] ] , text = df_by_continent [ [string] ] , mode = [string] , opacity = [number] , marker = { [string] : [number] , [string] : { [string] : [number] , [string] : [string] } } , name = i ) ) [EOL] [EOL] return { [string] : traces , [string] : go . Layout ( xaxis = { [string] : [string] , [string] : [string] } , yaxis = { [string] : [string] , [string] : [ [number] , [number] ] } , margin = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , legend = { [string] : [number] , [string] : [number] } , hovermode = [string] ) } [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . run_server ( debug = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import itcfinally [EOL] import unittest [EOL] [EOL] [EOL] class TestAdd ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_get_search_query_1 ( self ) : [EOL] [docstring] [EOL] list2 = [ [string] , [string] ] [EOL] result = itcfinally . get_search_query ( list2 , [number] ) [EOL] list3 = [string] [EOL] self . assertEqual ( result , list3 ) [EOL] [EOL] def test_get_search_query_2 ( self ) : [EOL] [docstring] [EOL] list2 = [ [string] , [string] ] [EOL] result = itcfinally . get_search_query ( list2 , [number] ) [EOL] list3 = [string] [EOL] self . assertEqual ( result , list3 ) [EOL] [EOL] def test_prep_numbers_1 ( self ) : [EOL] [docstring] [EOL] count = [number] [EOL] result = itcfinally . prep_numbers ( count ) [EOL] list3 = [ [string] ] [EOL] self . assertListEqual ( result , list3 ) [EOL] [EOL] @ unittest . skip ( [string] ) def test_prep_numbers_2 ( self ) : [EOL] [docstring] [EOL] list2 = [ [string] , [string] ] [EOL] count = [number] [EOL] result = itcfinally . prep_numbers_2 ( count , list2 ) [EOL] list3 = [ [string] , [string] ] [EOL] self . assertListEqual ( result , list3 ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , List , Tuple [EOL] import requests [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import datetime as dt [EOL] import os [EOL] import time as t [EOL] from datetime import datetime [EOL] from typing import Any , List , Tuple , Iterable [EOL] [EOL] import pandas as pd [EOL] import psycopg2 [EOL] import requests [EOL] [EOL] [comment] [EOL] from bs4 import BeautifulSoup [EOL] from dotenv import find_dotenv , load_dotenv [EOL] from selenium import webdriver [EOL] from selenium . webdriver . common . desired_capabilities import DesiredCapabilities [EOL] from selenium . webdriver . common . keys import Keys [EOL] from selenium . webdriver . firefox . options import Options as FirefoxOptions [EOL] [EOL] load_dotenv ( ) [EOL] [EOL] [EOL] def catch_error ( something ) : [EOL] [docstring] [EOL] try : [EOL] something [EOL] except IndexError : [EOL] something = [string] [EOL] print ( [string] ) [EOL] return something [EOL] else : [EOL] [comment] [EOL] return something [EOL] [EOL] [EOL] def create_conn ( ) : [EOL] [docstring] [EOL] DATABASE_URL = os . environ [ [string] ] [EOL] conn = psycopg2 . connect ( DATABASE_URL ) [EOL] cursor = conn . cursor ( ) [EOL] return conn , cursor [EOL] [EOL] [EOL] def create_table ( conn , cursor ) : [EOL] [docstring] [EOL] sql_query = [string] [EOL] cursor . execute ( sql_query ) [EOL] [EOL] [EOL] def fill_table ( conn , cursor , csv_file_name ) : [EOL] [docstring] [EOL] sql = [string] [EOL] cursor . copy_expert ( sql , open ( csv_file_name , [string] ) ) [EOL] [EOL] [EOL] def check_table ( conn , cursor ) : [EOL] [docstring] [EOL] df = pd . read_sql ( [string] , conn ) [EOL] print ( df . head ( [number] ) ) [EOL] print ( len ( df ) ) [EOL] return df [EOL] [EOL] [EOL] def delete_duplicates ( conn , cursor ) : [EOL] [docstring] [EOL] [comment] [EOL] sql_query = [string] [EOL] cursor . execute ( sql_query ) [EOL] [EOL] [EOL] def delete_counts_null ( conn , cursor ) : [EOL] [docstring] [EOL] [comment] [EOL] sql_query = [string] [EOL] cursor . execute ( sql_query ) [EOL] [EOL] [EOL] def sort_by_dates ( conn , cursor ) : [EOL] [docstring] [EOL] [comment] [EOL] sql_query = [string] [EOL] df = pd . read_sql ( sql_query , conn ) [EOL] print ( df . head ( [number] ) ) [EOL] print ( len ( df ) ) [EOL] return df [EOL] [EOL] [EOL] def drop_table ( conn , cursor ) : [EOL] [docstring] [EOL] sql_query = [string] [EOL] cursor . execute ( sql_query ) [EOL] [EOL] [EOL] def save_changes ( conn , cursor ) : [EOL] [docstring] [EOL] [comment] [EOL] conn . commit ( ) [EOL] [EOL] [EOL] def close_conn ( conn , cursor ) : [EOL] [docstring] [EOL] conn . close ( ) [EOL] cursor . close ( ) [EOL] [EOL] [EOL] def get_count ( adres ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from selenium . webdriver . firefox . options import Options [EOL] [EOL] options = Options ( ) [EOL] options . headless = True [EOL] from selenium . webdriver . common . desired_capabilities import DesiredCapabilities [EOL] [EOL] cap = DesiredCapabilities ( ) . FIREFOX [EOL] [EOL] cap [ [string] ] = True [EOL] [EOL] options . binary = os . environ [ [string] ] [EOL] driver = webdriver . Firefox ( capabilities = cap , options = options , executable_path = os . environ [ [string] ] ) [EOL] [comment] [EOL] driver . get ( adres ) [EOL] elems = driver . find_elements_by_class_name ( [string] ) [EOL] list_counts = [ int ( i . text ) if i . text is not [string] else [number] for i in elems ] [EOL] driver . close ( ) [EOL] return list_counts [EOL] [EOL] [EOL] def prep_dashboard ( conn , cursor ) : [EOL] [docstring] [EOL] df = sort_by_dates ( conn , cursor ) [EOL] df [ [string] ] = pd . to_datetime ( df [ [string] ] , format = [string] ) [EOL] last_date_string = df [ [string] ] . dt . strftime ( [string] ) . tolist ( ) [ [number] ] [EOL] first_date_string = df [ [string] ] . dt . strftime ( [string] ) . tolist ( ) [ - [number] ] [EOL] month_allowed = df [ [string] ] . dt . strftime ( [string] ) . tolist ( ) [ [number] ] [EOL] df [ [string] ] = df [ [string] ] . dt . strftime ( [string] ) [EOL] first_date , last_date = df [ [string] ] . min ( ) , df [ [string] ] . max ( ) [EOL] df = check_table ( conn , cursor ) [EOL] df [ [string] ] = pd . to_datetime ( df [ [string] ] , format = [string] ) [EOL] df [ [string] ] = df [ [string] ] . apply ( lambda x : dt . datetime . strftime ( x , [string] ) ) [EOL] df = df . sort_values ( [string] , ascending = False ) [EOL] df = df . reset_index ( drop = True ) [EOL] return ( last_date_string , first_date_string , month_allowed , first_date , last_date , df , ) [EOL] [EOL] [EOL] def get_dates ( df ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] today_date = datetime . now ( ) . strftime ( [string] ) [EOL] print ( today_date ) [EOL] df [ [string] ] = pd . to_datetime ( df [ [string] ] , format = [string] ) [EOL] [comment] [EOL] df [ [string] ] = df [ [string] ] . dt . strftime ( [string] ) [EOL] last_date = df [ [string] ] . tolist ( ) [ [number] ] [EOL] [comment] [EOL] print ( last_date ) [EOL] del df [ [string] ] [EOL] return last_date , today_date [EOL] [EOL] [EOL] def prep_list_dates ( last_date , today_date ) : [EOL] [docstring] [EOL] list2 = [ last_date , today_date ] [EOL] return list2 [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def get_search_query ( list2 , t ) : [EOL] [docstring] [EOL] if t > [number] : [EOL] search_query = ( [string] + str ( t ) + [string] + str ( list2 [ [number] ] ) + [string] + str ( list2 [ [number] ] ) ) [EOL] else : [EOL] search_query = ( [string] + str ( list2 [ [number] ] ) + [string] + str ( list2 [ [number] ] ) ) [EOL] return search_query [EOL] [EOL] [EOL] def prep_numbers_2 ( count , list2 ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] numbers = list ( range ( [number] , count ) ) [EOL] [comment] [EOL] listadres = [ ] [EOL] [comment] [EOL] for i in numbers : [EOL] if i == [number] : [EOL] example = ( [string] + str ( list2 [ [number] ] ) + [string] + str ( list2 [ [number] ] ) ) [EOL] else : [EOL] example = ( [string] + str ( i ) + [string] + str ( list2 [ [number] ] ) + [string] + str ( list2 [ [number] ] ) ) [EOL] [EOL] listadres . append ( example ) [EOL] [comment] [EOL] print ( listadres ) [EOL] return listadres [EOL] [EOL] [EOL] def onepage ( adres ) : [EOL] [docstring] [EOL] [comment] [EOL] headers = { [string] : [string] } [EOL] [comment] [EOL] page = requests . get ( adres , headers = headers ) [comment] [EOL] [comment] [EOL] soup = BeautifulSoup ( page . content , [string] ) [EOL] header = soup . find ( [string] , class_ = [string] ) [EOL] [comment] [EOL] if header is not None : [EOL] print ( [string] ) [EOL] return None [EOL] [EOL] [comment] [EOL] title = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] time = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] timeup = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] author = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] [comment] [EOL] listcounts = get_count ( adres ) [EOL] [comment] [EOL] [comment] [EOL] sometext = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] category = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] listtitle = [ ] [EOL] listtime = [ ] [EOL] listtimeup = [ ] [EOL] listauthor = [ ] [EOL] [comment] [EOL] listsometext = [ ] [EOL] listcategory = [ ] [EOL] [EOL] limit = min ( [ len ( list ( title ) ) , len ( list ( time ) ) , len ( list ( timeup ) ) , len ( list ( timeup ) ) , len ( list ( author ) ) , len ( listcounts ) , len ( list ( sometext ) ) , len ( list ( category ) ) , ] ) [EOL] [EOL] [comment] [EOL] for i in range ( [number] , limit ) : [EOL] k = title [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] listtitle . append ( k ) [EOL] [comment] [EOL] [comment] [EOL] ll = time [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] listtime . append ( ll ) [EOL] [comment] [EOL] m = timeup [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] listtimeup . append ( m ) [EOL] [comment] [EOL] try : [EOL] n = author [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] except IndexError : [EOL] n = [string] [EOL] listauthor . append ( n ) [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] p = sometext [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] except IndexError : [EOL] p = [string] [EOL] listsometext . append ( p ) [EOL] c = category [ i ] . get_text ( ) [EOL] listcategory . append ( c ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] df = pd . DataFrame ( { [string] : listtitle , [string] : listtime , [string] : listtimeup , [string] : listauthor , [string] : listcounts , [string] : listsometext , [string] : listcategory , } ) [EOL] [comment] [EOL] return df [EOL] [EOL] [EOL] def calc2 ( listadres ) : [EOL] [docstring] [EOL] [comment] [EOL] df = pd . DataFrame ( ) [EOL] [comment] [EOL] for c , v in enumerate ( listadres ) : [EOL] if onepage ( v ) is None : [EOL] break [EOL] else : [EOL] t . sleep ( [number] ) [EOL] df = pd . concat ( [ df , onepage ( v ) ] , ignore_index = True ) [EOL] print ( [string] . format ( c + [number] ) ) [EOL] listadres . append ( get_search_query ( list2 , c + [number] ) ) [EOL] t . sleep ( [number] ) [EOL] return df [EOL] [EOL] [EOL] def get_one_csv ( df ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] df [ [string] ] = df [ [string] ] . str . strip ( ) . str . replace ( [string] , [string] ) [EOL] [EOL] df [ [string] ] = pd . to_datetime ( df [ [string] ] , format = [string] ) [EOL] df [ [string] ] = df [ [string] ] . apply ( lambda x : dt . datetime . strftime ( x , [string] ) ) [EOL] [EOL] df . drop_duplicates ( subset = [string] , inplace = True ) [EOL] df [ [string] ] = pd . to_datetime ( df [ [string] ] , format = [string] ) [EOL] df [ [string] ] = df [ [string] ] . apply ( lambda x : dt . datetime . strftime ( x , [string] ) ) [EOL] df = df . sort_values ( [string] , ascending = False ) [EOL] df = df . reset_index ( drop = True ) [EOL] return df [EOL] [EOL] [EOL] def remove_csv ( names ) : [EOL] [docstring] [EOL] for i in names : [EOL] if os . path . exists ( i ) : [EOL] os . remove ( i ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] start0 = t . time ( ) [EOL] [EOL] names = [ [string] , [string] , [string] ] [EOL] print ( [string] ) [EOL] conn , cursor = create_conn ( ) [EOL] print ( [string] ) [EOL] create_table ( conn , cursor ) [EOL] [docstring] [EOL] print ( [string] ) [EOL] df1 = sort_by_dates ( conn , cursor ) [EOL] [comment] [EOL] df1 . to_csv ( names [ [number] ] , index = False ) [EOL] print ( [string] ) [EOL] [EOL] last_date , today_date = get_dates ( df1 ) [EOL] [comment] [EOL] print ( last_date ) [EOL] print ( today_date ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] print ( [string] ) [EOL] list2 = prep_list_dates ( last_date , today_date ) [EOL] print ( [string] ) [EOL] listadres = prep_numbers_2 ( [number] , list2 ) [EOL] [EOL] df = calc2 ( listadres ) [EOL] [comment] [EOL] df = get_one_csv ( df ) [EOL] [comment] [EOL] df . to_csv ( names [ [number] ] , index = False ) [EOL] [EOL] print ( [string] ) [EOL] fill_table ( conn , cursor , names [ [number] ] ) [EOL] print ( [string] ) [EOL] delete_duplicates ( conn , cursor ) [EOL] [comment] [EOL] df3 = sort_by_dates ( conn , cursor ) [EOL] print ( df3 . head ( [number] ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] df3 . to_csv ( names [ [number] ] , index = False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] print ( df3 . head ( [number] ) ) [EOL] print ( df3 . date4 . tolist ( ) [ : [number] ] ) [EOL] print ( [string] ) [EOL] save_changes ( conn , cursor ) [EOL] [EOL] print ( [string] ) [EOL] close_conn ( conn , cursor ) [EOL] print ( [string] ) [EOL] remove_csv ( names ) [EOL] [EOL] [docstring] [EOL] end0 = t . time ( ) [EOL] elapsed_time0 = end0 - start0 [EOL] elapsed_time0 = t . strftime ( [string] , t . gmtime ( elapsed_time0 ) ) [EOL] print ( [string] + str ( elapsed_time0 ) ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import subprocess [EOL] import typing [EOL] [docstring] [EOL] from apscheduler . schedulers . blocking import BlockingScheduler [EOL] import subprocess [EOL] import signal [EOL] import os [EOL] [EOL] [comment] [EOL] [comment] [EOL] cmd = [string] [EOL] print ( [string] ) [EOL] dash_app_process = subprocess . Popen ( cmd , stdout = subprocess . PIPE , shell = True , preexec_fn = os . setsid ) [EOL] [EOL] [EOL] [EOL] [EOL] sched = BlockingScheduler ( timezone = [string] ) [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ sched . scheduled_job ( [string] , day_of_week = [string] , hour = [number] , minute = [number] ) def scheduled_job ( process = dash_app_process ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] os . killpg ( os . getpgid ( process . pid ) , signal . SIGTERM ) [EOL] cmd = [string] [EOL] subprocess . call ( cmd , shell = True ) [EOL] print ( [string] ) [EOL] cmd = [string] [EOL] global dash_app_process [EOL] dash_app_process = subprocess . Popen ( cmd , stdout = subprocess . PIPE , shell = True , preexec_fn = os . setsid ) [EOL] [EOL] [EOL] sched . start ( ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , List , Dict [EOL] import requests [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import argparse [EOL] from bs4 import BeautifulSoup [EOL] import datetime as dt [EOL] import pandas as pd [EOL] import requests [EOL] import time as t [EOL] from tqdm import tqdm [EOL] [EOL] from selenium import webdriver [EOL] from selenium . webdriver . common . keys import Keys [EOL] from selenium . webdriver . firefox . options import Options as FirefoxOptions [EOL] [EOL] [comment] [EOL] ap = argparse . ArgumentParser ( ) [EOL] ap . add_argument ( [string] , [string] , required = False , type = str , default = None , help = [string] ) [EOL] ap . add_argument ( [string] , [string] , required = False , type = str , default = None , help = [string] ) [EOL] ap . add_argument ( [string] , [string] , required = False , type = int , default = None , help = [string] ) [EOL] args = vars ( ap . parse_args ( ) ) [EOL] [EOL] [EOL] def get_count ( adres ) : [EOL] options = FirefoxOptions ( ) [EOL] options . add_argument ( [string] ) [EOL] driver = webdriver . Firefox ( options = options ) [EOL] driver . get ( adres ) [EOL] elems = driver . find_elements_by_class_name ( [string] ) [EOL] list_counts = [ int ( i . text ) for i in elems ] [EOL] driver . close ( ) [EOL] return list_counts [EOL] [EOL] [EOL] def catch_error ( something ) : [EOL] [docstring] [EOL] try : [EOL] something [EOL] except IndexError : [EOL] something = [string] [EOL] print ( [string] ) [EOL] return something [EOL] else : [EOL] [comment] [EOL] return something [EOL] [EOL] [EOL] [comment] [EOL] list2 = [ args [ [string] ] , args [ [string] ] ] [EOL] [comment] [EOL] [EOL] [EOL] def get_search_query ( list2 , t ) : [EOL] [docstring] [EOL] if t > [number] : [EOL] search_query = ( [string] + str ( t ) + [string] + str ( list2 [ [number] ] ) + [string] + str ( list2 [ [number] ] ) ) [EOL] else : [EOL] search_query = ( [string] + str ( list2 [ [number] ] ) + [string] + str ( list2 [ [number] ] ) ) [EOL] return search_query [EOL] [EOL] [EOL] def prep_numbers_2 ( count , list2 ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] numbers = list ( range ( [number] , count ) ) [EOL] [comment] [EOL] listadres = [ ] [EOL] [comment] [EOL] for i in numbers : [EOL] if i == [number] : [EOL] example = ( [string] + str ( list2 [ [number] ] ) + [string] + str ( list2 [ [number] ] ) ) [EOL] else : [EOL] example = ( [string] + str ( i ) + [string] + str ( list2 [ [number] ] ) + [string] + str ( list2 [ [number] ] ) ) [EOL] [EOL] listadres . append ( example ) [EOL] [comment] [EOL] print ( listadres ) [EOL] return listadres [EOL] [EOL] [EOL] def prep_numbers ( count ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] numbers = [ i for i in range ( [number] , count ) ] [EOL] [comment] [EOL] listadres = [ ] [EOL] [comment] [EOL] for i in numbers : [EOL] if i == [number] : [EOL] example = [string] [EOL] else : [EOL] example = [string] + str ( i + [number] ) + [string] [EOL] listadres . append ( example ) [EOL] [comment] [EOL] print ( listadres ) [EOL] return listadres [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def onepage ( adres ) : [EOL] [docstring] [EOL] [comment] [EOL] headers = { [string] : [string] } [EOL] [comment] [EOL] page = requests . get ( adres , headers = headers ) [comment] [EOL] [comment] [EOL] soup = BeautifulSoup ( page . content , [string] ) [EOL] header = soup . find ( [string] , class_ = [string] ) [EOL] [comment] [EOL] if header is not None : [EOL] print ( [string] ) [EOL] return None [EOL] [EOL] [comment] [EOL] title = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] time = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] timeup = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] author = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] [comment] [EOL] listcounts = get_count ( adres ) [EOL] [comment] [EOL] sometext = soup . find_all ( [string] , class_ = [string] ) [EOL] [comment] [EOL] category = soup . find_all ( [string] , class_ = [string] ) [EOL] [docstring] [EOL] [comment] [EOL] listtitle = [ ] [EOL] listtime = [ ] [EOL] listtimeup = [ ] [EOL] listauthor = [ ] [EOL] [comment] [EOL] listsometext = [ ] [EOL] listcategory = [ ] [EOL] [EOL] limit = min ( [ len ( list ( title ) ) , len ( list ( time ) ) , len ( list ( timeup ) ) , len ( list ( timeup ) ) , len ( list ( author ) ) , len ( listcounts ) , len ( list ( sometext ) ) , len ( list ( category ) ) ] ) [EOL] [EOL] [comment] [EOL] for i in range ( [number] , limit ) : [EOL] k = title [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] listtitle . append ( k ) [EOL] [comment] [EOL] [comment] [EOL] ll = time [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] listtime . append ( ll ) [EOL] [comment] [EOL] m = timeup [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] listtimeup . append ( m ) [EOL] [comment] [EOL] try : [EOL] n = author [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] except IndexError : [EOL] n = [string] [EOL] listauthor . append ( n ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] p = sometext [ i ] . get_text ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] except IndexError : [EOL] p = [string] [EOL] listsometext . append ( p ) [EOL] c = category [ i ] . get_text ( ) [EOL] listcategory . append ( c ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] df = pd . DataFrame ( { [string] : listtitle , [string] : listtime , [string] : listtimeup , [string] : listauthor , [string] : listcounts , [string] : listsometext , [string] : listcategory , } ) [EOL] [comment] [EOL] return df [EOL] [EOL] [EOL] def calc ( listadres ) : [EOL] [docstring] [EOL] [comment] [EOL] df = pd . DataFrame ( ) [EOL] [comment] [EOL] for c , v in tqdm ( enumerate ( listadres ) ) : [EOL] if onepage ( v ) is None : [EOL] break [EOL] else : [EOL] t . sleep ( [number] ) [EOL] df = pd . concat ( [ df , onepage ( v ) ] , ignore_index = True ) [EOL] u = [number] / ( len ( listadres ) ) [EOL] percent = int ( round ( u * ( c + [number] ) , [number] ) ) [EOL] print ( [string] + str ( percent ) + [string] ) [EOL] [comment] [EOL] t . sleep ( [number] ) [EOL] return df [EOL] [EOL] [EOL] def calc2 ( listadres ) : [EOL] [docstring] [EOL] [comment] [EOL] df = pd . DataFrame ( ) [EOL] [comment] [EOL] for c , v in enumerate ( listadres ) : [EOL] if onepage ( v ) is None : [EOL] break [EOL] else : [EOL] t . sleep ( [number] ) [EOL] df = pd . concat ( [ df , onepage ( v ) ] , ignore_index = True ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] print ( [string] . format ( c + [number] ) ) [EOL] listadres . append ( get_search_query ( list2 , c + [number] ) ) [EOL] t . sleep ( [number] ) [EOL] return df [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [EOL] def get_years ( df ) : [EOL] [docstring] [EOL] list1 = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] for i in list1 : [EOL] df = df [ df [ [string] ] . dt . year == i ] [EOL] [comment] [EOL] [comment] [EOL] [EOL] df [ [string] ] = ( df [ [string] ] . apply ( lambda x : dt . datetime . strftime ( x , [string] ) ) ) [EOL] [EOL] print ( df [ [string] ] ) [EOL] [EOL] df . drop_duplicates ( subset = [string] , inplace = True ) [EOL] print ( df . dtypes ) [EOL] df = df . sort_values ( [string] , ascending = False ) [EOL] [comment] [EOL] df = df . reset_index ( drop = True ) [EOL] print ( df [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] print ( df ) [EOL] [comment] [EOL] [comment] [EOL] df . to_csv ( [string] + str ( i ) + [string] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def get_one_csv ( df ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] df [ [string] ] = df [ [string] ] . str . strip ( ) . str . replace ( [string] , [string] ) [EOL] df [ [string] ] = pd . to_datetime ( df [ [string] ] , format = [string] ) [EOL] df [ [string] ] = ( df [ [string] ] . apply ( lambda x : dt . datetime . strftime ( x , [string] ) ) ) [EOL] [EOL] [comment] [EOL] [EOL] df . drop_duplicates ( subset = [string] , inplace = True ) [EOL] [comment] [EOL] df = df . sort_values ( [string] , ascending = False ) [EOL] [comment] [EOL] [comment] [EOL] df = df . reset_index ( drop = True ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] print ( df . head ( [number] ) ) [EOL] [comment] [EOL] df . to_csv ( [string] , index = False ) [EOL] [comment] [EOL] [comment] [EOL] return df [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] start0 = t . time ( ) [EOL] if args [ [string] ] is None \ [EOL] and args [ [string] ] is not None and args [ [string] ] is not None : [EOL] [comment] [EOL] print ( [string] ) [EOL] listadres = prep_numbers_2 ( [number] , list2 ) [EOL] df = calc2 ( listadres ) [EOL] get_one_csv ( df ) [EOL] if args [ [string] ] is not None \ [EOL] and args [ [string] ] is None and args [ [string] ] is None : [EOL] print ( [string] ) [EOL] listadres = prep_numbers ( args [ [string] ] ) [EOL] df = calc ( listadres ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] get_one_csv ( df ) [EOL] end0 = t . time ( ) [EOL] elapsed_time0 = end0 - start0 [EOL] elapsed_time0 = t . strftime ( [string] , t . gmtime ( elapsed_time0 ) ) [EOL] print ( [string] + str ( elapsed_time0 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List , Dict [EOL] import datetime [EOL] import typing [EOL] import dash [EOL] import datetime [EOL] from datetime import datetime as dt [EOL] from dash . dependencies import Input , Output [EOL] import dash_core_components as dcc [EOL] import dash_html_components as html [EOL] import dash_table [EOL] import pandas as pd [EOL] import plotly . graph_objs as go [EOL] import psycopg2 [EOL] from itcfinally2 import create_conn , sort_by_dates , close_conn , prep_dashboard , check_table [EOL] [EOL] external_stylesheets = [ [string] ] [EOL] [EOL] app = dash . Dash ( __name__ , external_stylesheets = external_stylesheets ) [EOL] server = app . server [EOL] [EOL] print ( [string] ) [EOL] conn , cursor = create_conn ( ) [EOL] print ( [string] ) [EOL] ( last_date_string , first_date_string , month_allowed , first_date , last_date , df ) = prep_dashboard ( conn , cursor ) [EOL] print ( last_date_string , first_date_string , month_allowed , first_date , last_date ) [EOL] [comment] [EOL] print ( [string] ) [EOL] close_conn ( conn , cursor ) [EOL] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] colors = { [string] : [string] , [string] : [string] } [EOL] [EOL] app . layout = html . Div ( [ html . H1 ( children = [string] , style = { [string] : [string] } ) , html . Div ( children = [string] , style = { [string] : [string] } ) , dash_table . DataTable ( id = [string] , columns = [ { [string] : i , [string] : i , [string] : True } for i in df . columns ] , data = df . to_dict ( [string] ) , pagination_settings = { [string] : [number] , [string] : [number] } , pagination_mode = [string] , style_table = { [string] : [string] , [string] : [string] } , style_cell = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , style_cell_conditional = [ { [string] : { [string] : [string] } , [string] : [string] } , ] , ) , html . Div ( children = [string] . format ( first_date_string , last_date_string ) ) , dcc . DatePickerRange ( id = [string] , first_day_of_week = [number] , min_date_allowed = first_date , max_date_allowed = last_date , initial_visible_month = last_date , ) , html . Div ( id = [string] ) , html . Div ( id = [string] ) , html . Div ( id = [string] ) , html . Div ( id = [string] ) , html . Div ( id = [string] ) , html . Div ( id = [string] ) , html . Div ( id = [string] ) ] ) [EOL] [EOL] [EOL] @ app . callback ( Output ( [string] , [string] ) , [ Input ( [string] , [string] ) , Input ( [string] , [string] ) ] ) def update_barchart1 ( start_date , end_date ) : [EOL] if start_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ start_date ] ) ] [EOL] if end_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ end_date ] ) ] [EOL] if start_date and end_date is not None : [EOL] dff = df [ df [ [string] ] . between ( start_date , end_date ) ] [EOL] else : [EOL] dff = df [EOL] df1 = dff . groupby ( [string] ) [ [string] , [string] ] . sum ( ) . reset_index ( ) [EOL] dff = df1 . sort_values ( by = [string] , ascending = False ) . reset_index ( drop = True ) [EOL] return html . Div ( dcc . Graph ( id = [string] , figure = { [string] : [ { [string] : dff [ [string] ] , [string] : dff [ [string] ] , [string] : [string] , [string] : { [string] : [string] } , } ] , [string] : { [string] : [string] , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , } , ) ) [EOL] [EOL] [EOL] @ app . callback ( Output ( [string] , [string] ) , [ Input ( [string] , [string] ) , Input ( [string] , [string] ) ] ) def update_barchart2 ( start_date , end_date ) : [EOL] if start_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ start_date ] ) ] [EOL] if end_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ end_date ] ) ] [EOL] if start_date and end_date is not None : [EOL] dff = df [ df [ [string] ] . between ( start_date , end_date ) ] [EOL] else : [EOL] dff = df [EOL] df1 = dff [EOL] df1 [ [string] ] = df1 [ [string] ] . apply ( lambda x : dt . strptime ( x , [string] ) . strftime ( [string] ) ) [EOL] [EOL] df1 = df1 . groupby ( [string] ) [ [string] , [string] ] . sum ( ) . reset_index ( ) [EOL] df1 . sort_values ( by = [string] , ascending = True ) . reset_index ( drop = True ) [EOL] dff = df1 [EOL] return html . Div ( dcc . Graph ( id = [string] , figure = { [string] : [ { [string] : dff [ [string] ] , [string] : dff [ [string] ] , [string] : [string] , [string] : { [string] : [string] } , } ] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : dff [ [string] ] , [string] : dff [ [string] ] } , [string] : { [string] : [string] } } , } , ) ) [EOL] [EOL] [EOL] @ app . callback ( Output ( [string] , [string] ) , [ Input ( [string] , [string] ) , Input ( [string] , [string] ) ] ) def update_barchart3 ( start_date , end_date ) : [EOL] if start_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ start_date ] ) ] [EOL] if end_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ end_date ] ) ] [EOL] if start_date and end_date is not None : [EOL] dff = df [ df [ [string] ] . between ( start_date , end_date ) ] [EOL] else : [EOL] dff = df [EOL] dff = df [EOL] df1 = dff [EOL] df1 [ [string] ] = df1 [ [string] ] . apply ( lambda x : dt . strptime ( x , [string] ) . strftime ( [string] ) ) [EOL] df1 = df1 . groupby ( [string] ) [ [string] , [string] ] . count ( ) . reset_index ( ) [EOL] df1 . sort_values ( by = [string] , ascending = True ) . reset_index ( drop = True ) [EOL] dff = df1 [EOL] return html . Div ( dcc . Graph ( id = [string] , figure = { [string] : [ { [string] : dff [ [string] ] , [string] : dff [ [string] ] , [string] : [string] , [string] : { [string] : [string] } , } ] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : dff [ [string] ] , [string] : dff [ [string] ] } , [string] : { [string] : [string] } } , } , ) ) [EOL] [EOL] [EOL] @ app . callback ( Output ( [string] , [string] ) , [ Input ( [string] , [string] ) , Input ( [string] , [string] ) ] ) def update_pie1 ( start_date , end_date ) : [EOL] if start_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ start_date ] ) ] [EOL] if end_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ end_date ] ) ] [EOL] if start_date and end_date is not None : [EOL] dff = df [ df [ [string] ] . between ( start_date , end_date ) ] [EOL] else : [EOL] dff = df [EOL] df1 = df . groupby ( [string] ) [ [string] , [string] ] . count ( ) . reset_index ( ) [EOL] df2 = df . groupby ( [string] ) [ [string] , [string] ] . sum ( ) . reset_index ( ) [EOL] [EOL] df3 = pd . merge ( df1 , df2 ) [EOL] df3 [ [string] ] = df3 [ [string] ] / df3 [ [string] ] [EOL] dff = df3 [EOL] return html . Div ( dcc . Graph ( id = [string] , figure = { [string] : [ go . Pie ( labels = dff [ [string] ] , values = dff [ [string] ] ) ] , [string] : { [string] : [string] , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , } , ) ) [EOL] [EOL] [EOL] @ app . callback ( Output ( [string] , [string] ) , [ Input ( [string] , [string] ) , Input ( [string] , [string] ) ] ) def update_graph3 ( start_date , end_date ) : [EOL] global df [EOL] if start_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ start_date ] ) ] [EOL] if end_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ end_date ] ) ] [EOL] if start_date and end_date is not None : [EOL] dff = df [ df [ [string] ] . between ( start_date , end_date ) ] [EOL] else : [EOL] dff = df [EOL] df = dff [EOL] df1 = df . groupby ( [string] ) [ [string] , [string] ] . count ( ) . reset_index ( ) [EOL] df2 = df . groupby ( [string] ) [ [string] , [string] ] . sum ( ) . reset_index ( ) [EOL] [EOL] df3 = pd . merge ( df1 , df2 ) [EOL] df3 [ [string] ] = df3 [ [string] ] / df3 [ [string] ] [EOL] dff = df3 [EOL] return html . Div ( dcc . Graph ( id = [string] , figure = { [string] : [ go . Pie ( labels = dff [ [string] ] , values = dff [ [string] ] ) ] , [string] : { [string] : [string] , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , } , ) ) [EOL] [EOL] [EOL] @ app . callback ( Output ( [string] , [string] ) , [ Input ( [string] , [string] ) , Input ( [string] , [string] ) ] ) def update_scatter ( start_date , end_date ) : [EOL] global df [EOL] if start_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ start_date ] ) ] [EOL] if end_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ end_date ] ) ] [EOL] if start_date and end_date is not None : [EOL] dff = df [ df [ [string] ] . between ( start_date , end_date ) ] [EOL] else : [EOL] dff = df [EOL] df0 = dff [EOL] df0 [ [string] ] = pd . to_datetime ( df0 [ [string] ] , format = [string] ) [EOL] df0 [ [string] ] = ( df0 [ [string] ] . apply ( lambda x : dt . strftime ( x , [string] ) ) ) [EOL] df1 = df0 . groupby ( [string] ) [ [string] , [string] ] . count ( ) . reset_index ( ) [EOL] df2 = df0 . groupby ( [string] ) [ [string] , [string] ] . sum ( ) . reset_index ( ) [EOL] [EOL] df3 = pd . merge ( df1 , df2 ) [EOL] df3 [ [string] ] = df3 [ [string] ] / df3 [ [string] ] [EOL] dff = df3 [EOL] return html . Div ( dcc . Graph ( id = [string] , figure = { [string] : [ { [string] : dff [ [string] ] , [string] : dff [ [string] ] , [string] : [string] , [string] : { [string] : [string] } , } ] , [string] : { [string] : [string] , [string] : { [string] : [string] , } , [string] : { [string] : [string] } } , } , ) ) [EOL] [EOL] [EOL] @ app . callback ( Output ( [string] , [string] ) , [ Input ( [string] , [string] ) , Input ( [string] , [string] ) ] ) def update_output_container ( start_date , end_date ) : [EOL] string_prefix = [string] [EOL] if start_date is not None : [EOL] start_date = dt . strptime ( start_date , [string] ) [EOL] start_date_string = start_date . strftime ( [string] ) [EOL] string_prefix = string_prefix + [string] + start_date_string + [string] [EOL] if end_date is not None : [EOL] end_date = dt . strptime ( end_date , [string] ) [EOL] end_date_string = end_date . strftime ( [string] ) [EOL] string_prefix = string_prefix + [string] + end_date_string [EOL] if len ( string_prefix ) == len ( [string] ) : [EOL] return [string] [EOL] else : [EOL] return string_prefix [EOL] [EOL] [EOL] @ app . callback ( Output ( [string] , [string] ) , [ Input ( [string] , [string] ) , Input ( [string] , [string] ) , Input ( [string] , [string] ) ] ) def update_data_table ( start_date , end_date , pagination_settings ) : [EOL] if start_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ start_date ] ) ] [EOL] if end_date is not None : [EOL] dff = df . loc [ df [ [string] ] . isin ( [ end_date ] ) ] [EOL] if start_date and end_date is not None : [EOL] dff = df [ df [ [string] ] . between ( start_date , end_date ) ] [EOL] else : [EOL] dff = df [EOL] [comment] [EOL] return dff . iloc [ pagination_settings [ [string] ] * pagination_settings [ [string] ] : ( pagination_settings [ [string] ] + [number] ) * pagination_settings [ [string] ] ] . to_dict ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . run_server ( debug = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0