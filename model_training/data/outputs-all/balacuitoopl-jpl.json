[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Iterator [EOL] import typing [EOL] def f ( ) : [EOL] yield [number] [EOL] yield [number] [EOL] yield [number] [EOL] [EOL] x = f ( ) [EOL] print ( x is iter ( x ) ) [comment] [EOL] [EOL] print ( list ( x ) ) [comment] [EOL] print ( list ( x ) ) [comment] [EOL] [EOL] print ( list ( f ( ) ) ) [comment] [EOL] print ( list ( f ( ) ) ) [comment] [EOL] [EOL] r = range ( [number] , [number] ) [EOL] print ( type ( r ) ) [comment] [EOL] [EOL] p = iter ( r ) [EOL] print ( type ( p ) ) [comment] [EOL] [EOL] [docstring] [EOL] [EOL] x = [ [number] , [number] , [number] ] [EOL] y = x [EOL] [EOL] print ( x is y ) [comment] [EOL] print ( x == y ) [comment] [EOL] [EOL] x = [ [number] , [number] , [number] ] [EOL] y = [ [number] , [number] , [number] ] [EOL] [EOL] print ( x is y ) [comment] [EOL] print ( x == y ) [comment] [EOL] [EOL] class A : [EOL] def __init__ ( self , i = [number] , j = [number] ) : [EOL] ... [EOL] [EOL] def __eq__ ( self , rhs ) : [EOL] ... [EOL] [EOL] x = A ( ) [EOL] y = A ( [number] ) [EOL] z = A ( [number] , [number] ) [EOL] [EOL] x = A ( [number] , [number] ) [EOL] y = x [EOL] [EOL] print ( x is y ) [comment] [EOL] [EOL] x = A ( [number] , [number] ) [EOL] y = A ( [number] , [number] ) [EOL] [EOL] print ( x is y ) [comment] [EOL] print ( x == y ) [comment] [EOL] [EOL] [docstring] [EOL] [EOL] [docstring] [EOL] [EOL] x = A ( [number] ) [EOL] y = A ( [number] ) [EOL] print ( x is y ) [comment] [EOL] [EOL] x = A [EOL] y = A [EOL] print ( x is y ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] , end = [string] ) [EOL] [EOL] v = next ( p ) if not v else v [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.range$ 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $builtins.range$ 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] print ( [string] ) [EOL] [EOL] def f ( x , y , z = [number] ) : [EOL] return [ x , y , z ] [EOL] [EOL] assert f ( [number] , [number] ) == [ [number] , [number] , [number] ] [EOL] assert f ( [number] , [number] , [number] ) == [ [number] , [number] , [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def g ( x = [number] , y = [number] , z = [number] ) : [EOL] return [ x , y , z ] [EOL] [EOL] assert g ( ) == [ [number] , [number] , [number] ] [EOL] assert g ( [number] ) == [ [number] , [number] , [number] ] [EOL] assert g ( [number] , [number] ) == [ [number] , [number] , [number] ] [EOL] assert g ( [number] , [number] , [number] ) == [ [number] , [number] , [number] ] [EOL] assert g ( [number] , z = [number] ) == [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] [EOL] def h1 ( x = [ ] ) : [comment] [EOL] x += [ [number] ] [EOL] return x [EOL] [EOL] assert h1 ( ) == [ [number] ] [EOL] assert h1 ( ) == [ [number] , [number] ] [EOL] assert h1 ( [ [number] ] ) == [ [number] , [number] ] [EOL] assert h1 ( ) == [ [number] , [number] , [number] ] [EOL] assert h1 ( [ [number] ] ) == [ [number] , [number] ] [EOL] [EOL] [EOL] [EOL] def h2 ( x = ( ) ) : [comment] [EOL] x += ( [number] , ) [EOL] return x [EOL] [EOL] assert h2 ( ) == ( [number] , ) [EOL] assert h2 ( ) == ( [number] , ) [EOL] assert h2 ( ( [number] , ) ) == ( [number] , [number] ) [EOL] assert h2 ( ) == ( [number] , ) [EOL] assert h2 ( ( [number] , ) ) == ( [number] , [number] ) [EOL] [EOL] [EOL] [EOL] def h3 ( x = None ) : [EOL] if x is None : [EOL] x = [ ] [EOL] x += [ [number] ] [EOL] return x [EOL] [EOL] assert h3 ( ) == [ [number] ] [EOL] assert h3 ( ) == [ [number] ] [EOL] assert h3 ( [ [number] ] ) == [ [number] , [number] ] [EOL] assert h3 ( ) == [ [number] ] [EOL] assert h3 ( [ [number] ] ) == [ [number] , [number] ] [EOL] assert h3 ( None ) == [ [number] ] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL] pi = [number] [EOL] [EOL] s = [string] % pi [comment] [EOL] assert isinstance ( s , str ) [EOL] assert s is not [string] [EOL] assert s == [string] [EOL] [EOL] s = [string] % ( pi , pi ) [comment] [EOL] assert isinstance ( s , str ) [EOL] assert s is not [string] [EOL] assert s == [string] [EOL] [EOL] s = [string] % pi [EOL] assert isinstance ( s , str ) [EOL] assert s is not [string] [EOL] assert s == [string] [EOL] [EOL] s = [string] % pi [EOL] assert isinstance ( s , str ) [EOL] assert s is not [string] [EOL] assert s == [string] [EOL] [EOL] s = [string] % pi [EOL] assert isinstance ( s , str ) [EOL] assert s is not [string] [EOL] assert s == [string] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterator , Callable [EOL] import typing [EOL] import builtins [EOL] from typing import Callable [EOL] [EOL] print ( [string] ) [EOL] [EOL] def f ( ) : [EOL] return lambda n : n ** [number] [EOL] [EOL] def g ( p ) : [EOL] return lambda n : n ** p [EOL] [EOL] m = map ( f ( ) , [ [number] , [number] , [number] ] ) [EOL] assert list ( m ) == [ [number] , [number] , [number] ] [EOL] assert list ( m ) == [ ] [EOL] [EOL] m = map ( g ( [number] ) , [ [number] , [number] , [number] ] ) [EOL] assert list ( m ) == [ [number] , [number] , [number] ] [EOL] assert list ( m ) == [ ] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.int],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL] def f ( x , y , z ) : [EOL] return [ x , y , z ] [EOL] [EOL] assert f ( [number] , [number] , [number] ) == [ [number] , [number] , [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] assert f ( [number] , z = [number] , y = [number] ) == [ [number] , [number] , [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def g ( x , * , y , z ) : [EOL] return [ x , y , z ] [EOL] [EOL] assert g ( [number] , z = [number] , y = [number] ) == [ [number] , [number] , [number] ] [EOL] assert g ( x = [number] , z = [number] , y = [number] ) == [ [number] , [number] , [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Sequence , Tuple , Set , Iterable , Dict , List , Iterator [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , Iterable , Iterator , List , Sequence , Set , Tuple [EOL] [EOL] print ( [string] ) [EOL] [EOL] def f ( ) : [EOL] pass [EOL] [EOL] f ( ) [EOL] [comment] [EOL] [EOL] [EOL] [EOL] def f_int ( n ) : [EOL] assert n [EOL] [EOL] f_int ( [number] ) [EOL] [comment] [EOL] [EOL] [EOL] [EOL] def f_list ( a ) : [EOL] assert a [EOL] [EOL] f_list ( [ [number] , [number] , [number] ] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] def f_tuple ( a ) : [EOL] assert a [EOL] [EOL] f_tuple ( ( [number] , [string] ) ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] def f_sequence ( a ) : [EOL] assert a [EOL] [EOL] f_sequence ( [ [number] , [number] , [number] ] ) [EOL] f_sequence ( ( [number] , [number] , [number] ) ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] def f_set ( a ) : [EOL] assert a [EOL] [EOL] f_set ( { [number] , [number] , [number] } ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] def f_dict ( a ) : [EOL] assert a [EOL] [EOL] f_dict ( { [number] : [string] , [number] : [string] , [number] : [string] } ) [EOL] [comment] [EOL] [EOL] [EOL] [EOL] def f_iterable ( a ) : [EOL] assert a [EOL] [EOL] f_iterable ( [ [number] , [number] , [number] ] ) [EOL] f_iterable ( ( [number] , [number] , [number] ) ) [EOL] f_iterable ( { [number] , [number] , [number] } ) [EOL] f_iterable ( { [number] : [string] , [number] : [string] , [number] : [string] } ) [EOL] f_iterable ( ( map ( lambda v : v ** [number] , ( [number] , [number] , [number] ) ) ) ) [EOL] [comment] [EOL] [EOL] [EOL] [EOL] def f_iterator ( a ) : [EOL] assert a [EOL] [EOL] f_iterator ( ( map ( lambda v : v ** [number] , ( [number] , [number] , [number] ) ) ) ) [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Union , List , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] from copy import copy , deepcopy [EOL] [EOL] print ( [string] ) [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] [EOL] assert a [ [number] ] == [number] [EOL] assert a [ - [number] ] == [number] [EOL] assert a [ [number] : [number] ] == [ [number] ] [EOL] assert a [ [number] : [number] ] == [ [number] , [number] ] [EOL] assert a [ [number] : [number] ] == [ [number] , [number] , [number] ] [EOL] assert a [ : ] == [ [number] , [number] , [number] ] [EOL] [EOL] b = [ [number] , a , [number] ] [EOL] [EOL] c = b [ : ] [EOL] assert b is not c [EOL] assert b == c [EOL] assert b [ [number] ] is c [ [number] ] [EOL] [EOL] c = copy ( b ) [EOL] assert b is not c [EOL] assert b == c [EOL] assert b [ [number] ] is c [ [number] ] [EOL] [EOL] c = deepcopy ( b ) [EOL] assert b is not c [EOL] assert b == c [EOL] assert b [ [number] ] is not c [ [number] ] [EOL] assert b [ [number] ] == c [ [number] ] [EOL] [EOL] u = ( [number] , [number] , [number] ) [EOL] [EOL] assert u [ [number] : [number] ] == ( [number] , ) [EOL] assert u [ [number] : [number] ] == ( [number] , [number] ) [EOL] assert u [ [number] : [number] ] == ( [number] , [number] , [number] ) [EOL] assert u [ : ] == ( [number] , [number] , [number] ) [EOL] [EOL] v = ( [number] , u , [number] ) [EOL] [EOL] w = v [ : ] [EOL] assert v is w [EOL] [EOL] w = copy ( v ) [EOL] assert v is w [EOL] [EOL] w = deepcopy ( v ) [EOL] assert v is w [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL] x1 = [number] [EOL] [EOL] def f1 ( ) : [EOL] x1 = [number] [EOL] [EOL] def g1 ( ) : [EOL] x1 = [number] [EOL] assert x1 == [number] [EOL] [EOL] g1 ( ) [EOL] assert x1 == [number] [EOL] [EOL] f1 ( ) [EOL] assert x1 == [number] [EOL] [EOL] [EOL] [EOL] x2 = [number] [EOL] [EOL] def f2 ( ) : [EOL] x2 = [number] [EOL] [EOL] def g2 ( ) : [EOL] nonlocal x2 [EOL] x2 = [number] [EOL] [EOL] g2 ( ) [EOL] assert x2 == [number] [EOL] [EOL] f2 ( ) [EOL] assert x2 == [number] [EOL] [EOL] [EOL] [EOL] x3 = [number] [EOL] [EOL] def f3 ( ) : [EOL] global x3 [EOL] x3 = [number] [EOL] [EOL] def g3 ( ) : [EOL] global x3 [EOL] x3 = [number] [EOL] [EOL] g3 ( ) [EOL] assert x3 == [number] [EOL] [EOL] f3 ( ) [EOL] assert x3 == [number] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Tuple [EOL] import typing [EOL] print ( [string] ) [EOL] [EOL] def f ( x , y , ** z ) : [EOL] return [ x , y , z ] [EOL] [EOL] assert f ( [number] , [number] ) == [ [number] , [number] , { } ] [EOL] assert f ( [number] , [number] , a = [number] ) == [ [number] , [number] , { [string] : [number] } ] [EOL] assert f ( [number] , [number] , a = [number] , b = [number] ) == [ [number] , [number] , { [string] : [number] , [string] : [number] } ] [EOL] [EOL] d1 = { [string] : [number] , [string] : [number] } [EOL] assert f ( [number] , [number] , ** d1 ) == [ [number] , [number] , { [string] : [number] , [string] : [number] } ] [EOL] assert f ( [number] , y = [number] , ** d1 ) == [ [number] , [number] , { [string] : [number] , [string] : [number] } ] [EOL] u = ( [number] , ) [EOL] assert f ( y = [number] , * u , ** d1 ) == [ [number] , [number] , { [string] : [number] , [string] : [number] } ] [EOL] assert f ( * u , y = [number] , ** d1 ) == [ [number] , [number] , { [string] : [number] , [string] : [number] } ] [EOL] [EOL] d2 = { [string] : [number] , [string] : [number] } [EOL] assert f ( ** d2 ) == [ [number] , [number] , { } ] [EOL] [EOL] d3 = { [string] : [number] } [EOL] assert f ( [number] , ** d3 ) == [ [number] , [number] , { } ] [EOL] assert f ( x = [number] , ** d3 ) == [ [number] , [number] , { } ] [EOL] [EOL] d4 = { [string] : [number] , [string] : [number] } [EOL] assert f ( [number] , ** d4 ) == [ [number] , [number] , { [string] : [number] } ] [EOL] assert f ( x = [number] , ** d4 ) == [ [number] , [number] , { [string] : [number] } ] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int]$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterable , Iterator [EOL] import typing [EOL] import builtins [EOL] from typing import Iterable , Iterator [EOL] [EOL] def test_iterator ( p ) : [EOL] assert hasattr ( p , [string] ) [EOL] assert hasattr ( p , [string] ) [EOL] q = iter ( p ) [comment] [EOL] assert q is p [EOL] [EOL] assert next ( p ) == [number] [comment] [EOL] assert next ( p ) == [number] [EOL] assert next ( p ) == [number] [EOL] [EOL] try : [EOL] assert next ( p ) == [number] [comment] [EOL] assert False [EOL] except StopIteration : [EOL] pass [EOL] [EOL] def test_iterable ( x ) : [EOL] assert not hasattr ( x , [string] ) [EOL] assert hasattr ( x , [string] ) [EOL] p = iter ( x ) [comment] [EOL] assert p is not x [EOL] test_iterator ( p ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] test_iterator ( iter ( [ [number] , [number] , [number] ] ) ) [comment] [EOL] test_iterator ( iter ( ( [number] , [number] , [number] ) ) ) [comment] [EOL] test_iterator ( iter ( { [number] , [number] , [number] } ) ) [comment] [EOL] test_iterator ( iter ( { [number] : [string] , [number] : [string] , [number] : [string] } ) ) [comment] [EOL] test_iterator ( iter ( [ v for v in [ [number] , [number] , [number] ] ] ) ) [comment] [EOL] test_iterator ( iter ( range ( [number] , [number] ) ) ) [EOL] test_iterator ( v for v in [ [number] , [number] , [number] ] ) [comment] [EOL] test_iterator ( map ( lambda v : v , [ [number] , [number] , [number] ] ) ) [EOL] test_iterator ( filter ( lambda v : True , [ [number] , [number] , [number] ] ) ) [EOL] [EOL] test_iterable ( [ [number] , [number] , [number] ] ) [comment] [EOL] test_iterable ( ( [number] , [number] , [number] ) ) [comment] [EOL] test_iterable ( { [number] , [number] , [number] } ) [comment] [EOL] test_iterable ( { [number] : [string] , [number] : [string] , [number] : [string] } ) [comment] [EOL] test_iterable ( [ v for v in [ [number] , [number] , [number] ] ] ) [comment] [EOL] test_iterable ( range ( [number] , [number] ) ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Literal , List , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] from typing import Tuple [EOL] [EOL] from copy import copy [EOL] [EOL] print ( [string] ) [EOL] [EOL] i = [number] [EOL] j = i [EOL] assert i is j [EOL] j += [number] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] b = a [EOL] assert a is b [EOL] b [ [number] ] += [number] [EOL] assert a [ [number] ] == [number] [EOL] assert a is b [EOL] [EOL] u = ( [number] , [number] , [number] ) [EOL] v = u [EOL] assert u is v [EOL] [comment] [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] b = copy ( a ) [EOL] assert a is not b [EOL] assert a == b [EOL] b [ [number] ] += [number] [EOL] assert a [ [number] ] == [number] [EOL] assert b [ [number] ] == [number] [EOL] [EOL] u = ( [number] , [number] , [number] ) [EOL] v = copy ( u ) [EOL] assert u is v [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] b = a [EOL] assert a is b [EOL] b += [ [number] ] [EOL] assert a == [ [number] , [number] , [number] , [number] ] [EOL] assert a is b [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] b = a [EOL] assert a is b [EOL] b += ( [number] , ) [EOL] assert a == [ [number] , [number] , [number] , [number] ] [EOL] assert a is b [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] b = a [EOL] assert a is b [EOL] b = b + [ [number] ] [EOL] assert a == [ [number] , [number] , [number] ] [EOL] assert b == [ [number] , [number] , [number] , [number] ] [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] b = a [EOL] assert a is b [EOL] [comment] [EOL] [EOL] x = ( [number] , [number] , [number] ) [comment] [EOL] y = x [EOL] assert x is y [EOL] y += ( [number] , ) [EOL] assert x == ( [number] , [number] , [number] ) [EOL] assert y == ( [number] , [number] , [number] , [number] ) [EOL] [EOL] u = ( [number] , [number] , [number] ) [EOL] v = u [EOL] assert u is v [EOL] [comment] [EOL] [EOL] x = ( [number] , [number] , [number] ) [EOL] y = x [EOL] assert x is y [EOL] y = y + ( [number] , ) [EOL] assert x == ( [number] , [number] , [number] ) [EOL] assert y == ( [number] , [number] , [number] , [number] ) [EOL] [EOL] u = ( [number] , [number] , [number] ) [EOL] v = u [EOL] assert u is v [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 $typing.Tuple[builtins.int,...]$ 0 0 $typing.Tuple[builtins.int,...]$ 0 $typing.Tuple[builtins.int,...]$ 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 $typing.Tuple[builtins.int,...]$ 0 0 $typing.Tuple[builtins.int,...]$ 0 $typing.Tuple[builtins.int,...]$ 0 $typing.Tuple[builtins.int,...]$ 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterator [EOL] import typing [EOL] import builtins [EOL] from typing import Iterator [EOL] [EOL] print ( [string] ) [EOL] [EOL] def f ( ) : [EOL] yield [number] [EOL] yield [number] [EOL] yield [number] [EOL] [EOL] p = f ( ) [EOL] assert p is iter ( p ) [EOL] n = next ( p ) [EOL] assert n == [number] [EOL] n = next ( p ) [EOL] assert n == [number] [EOL] n = next ( p ) [EOL] assert n == [number] [EOL] try : [EOL] n = next ( p ) [EOL] except StopIteration : [EOL] pass [EOL] [EOL] p = f ( ) [EOL] assert list ( p ) == [ [number] , [number] , [number] ] [EOL] assert list ( p ) == [ ] [EOL] [EOL] p = f ( ) [EOL] assert list ( p ) == [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] [EOL] def g ( ) : [EOL] for v in [ [number] , [number] , [number] ] : [EOL] yield v [EOL] [EOL] p = g ( ) [EOL] assert p is iter ( p ) [EOL] n = next ( p ) [EOL] assert n == [number] [EOL] n = next ( p ) [EOL] assert n == [number] [EOL] n = next ( p ) [EOL] assert n == [number] [EOL] try : [EOL] n = next ( p ) [EOL] except StopIteration : [EOL] pass [EOL] [EOL] p = g ( ) [EOL] assert list ( p ) == [ [number] , [number] , [number] ] [EOL] assert list ( p ) == [ ] [EOL] [EOL] p = g ( ) [EOL] assert list ( p ) == [ [number] , [number] , [number] ] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 $builtins.int$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 $builtins.int$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Tuple [EOL] import typing [EOL] print ( [string] ) [EOL] [EOL] def f ( x , y , * z ) : [EOL] return [ x , y , z ] [EOL] [EOL] assert f ( [number] , [number] ) == [ [number] , [number] , ( ) ] [EOL] assert f ( [number] , [number] , [number] ) == [ [number] , [number] , ( [number] , ) ] [EOL] assert f ( [number] , [number] , [number] , [number] ) == [ [number] , [number] , ( [number] , [number] ) ] [EOL] [EOL] t = ( [number] , [number] ) [EOL] assert f ( [number] , [number] , t ) == [ [number] , [number] , ( ( [number] , [number] ) , ) ] [EOL] assert f ( [number] , [number] , * t ) == [ [number] , [number] , ( [number] , [number] ) ] [EOL] assert f ( [number] , * t ) == [ [number] , [number] , ( [number] , ) ] [EOL] assert f ( * t ) == [ [number] , [number] , ( ) ] [EOL] [EOL] u = ( [number] , ) [EOL] assert f ( y = [number] , * u ) == [ [number] , [number] , ( ) ] [EOL] assert f ( * u , y = [number] ) == [ [number] , [number] , ( ) ] [EOL] [EOL] d1 = { [string] : [number] , [string] : [number] } [EOL] assert f ( ** d1 ) == [ [number] , [number] , ( ) ] [EOL] [EOL] d2 = { [string] : [number] } [EOL] assert f ( [number] , ** d2 ) == [ [number] , [number] , ( ) ] [EOL] assert f ( x = [number] , ** d2 ) == [ [number] , [number] , ( ) ] [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Tuple [EOL] import typing [EOL] from typing import Tuple [EOL] [EOL] from operator import add [EOL] [EOL] print ( [string] ) [EOL] [EOL] i = [number] [EOL] j = - i [comment] [EOL] assert i == [number] [EOL] assert j == - [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i = j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] k = i + j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert k == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] k = add ( i , j ) [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert k == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i += j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] f = i / j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert isinstance ( f , float ) [EOL] assert str ( f ) == [string] [EOL] [EOL] g = [number] [comment] [EOL] j = [number] [EOL] g /= j [EOL] assert isinstance ( g , float ) [EOL] assert str ( g ) == [string] [EOL] assert j == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] k = i // j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert isinstance ( k , int ) [EOL] assert k == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i //= j [EOL] assert isinstance ( i , int ) [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] f = [number] [EOL] j = [number] [EOL] g = f // j [comment] [EOL] assert f == [number] [EOL] assert j == [number] [EOL] assert isinstance ( g , float ) [EOL] assert str ( g ) == [string] [EOL] [EOL] f = [number] [EOL] j = [number] [EOL] f //= j [EOL] assert isinstance ( f , float ) [EOL] assert str ( f ) == [string] [EOL] assert j == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] k = i % j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert k == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i %= j [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] k = i ** j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert k == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i **= j [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] k = i << j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert k == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i <<= j [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [comment] [EOL] j = ~ i [comment] [EOL] k = ~ i + [number] [comment] [EOL] assert i == [number] [EOL] assert j == - [number] [EOL] assert k == - [number] [EOL] [EOL] i = [number] [comment] [EOL] j = [number] [comment] [EOL] k = i & j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert k == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i &= j [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [comment] [EOL] j = [number] [comment] [EOL] k = i | j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert k == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i |= j [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [comment] [EOL] j = [number] [comment] [EOL] k = i ^ j [comment] [EOL] assert i == [number] [EOL] assert j == [number] [EOL] assert k == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i ^= j [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [comment] [EOL] j = [number] [comment] [EOL] i ^= j [EOL] assert i == [number] [comment] [EOL] assert j == [number] [comment] [EOL] j ^= i [EOL] assert i == [number] [comment] [EOL] assert j == [number] [comment] [EOL] i ^= j [EOL] assert i == [number] [comment] [EOL] assert j == [number] [comment] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i += j [EOL] assert i == [number] [EOL] assert j == [number] [EOL] j = i - j [EOL] assert i == [number] [EOL] assert j == [number] [EOL] i -= j [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] i , j = j , i [EOL] assert i == [number] [EOL] assert j == [number] [EOL] [EOL] i = [number] [EOL] j = not i & ( i - [number] ) [EOL] assert j is True [comment] [EOL] [EOL] i = [number] [comment] [EOL] j = [number] [EOL] while i != [number] : [EOL] i &= ( i - [number] ) [EOL] j += [number] [EOL] assert j == [number] [comment] [EOL] [EOL] i = [number] [EOL] j = [number] [EOL] k = [number] [EOL] l = [number] [EOL] assert ( i < j ) and ( j < k ) and ( k < l ) [EOL] assert i < j < k < l [EOL] [EOL] p = True [EOL] q = True [EOL] r = False [EOL] assert p and q [EOL] assert not ( p and r ) [EOL] assert p or q [EOL] assert p or r [EOL] assert p and q [EOL] assert not ( p and r ) [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] assert a [ [number] ] == [number] [comment] [EOL] a [ [number] ] += [number] [EOL] assert a [ [number] ] == [number] [EOL] [EOL] u = ( [number] , [number] , [number] ) [comment] [EOL] assert u [ [number] ] == [number] [comment] [EOL] [comment] [EOL] [EOL] s = [string] [EOL] t = [string] [EOL] m = s + t [comment] [EOL] assert m is not [string] [EOL] assert m == [string] [EOL] [EOL] a = [ [number] ] [EOL] b = [ [number] , [number] ] [EOL] c = a + b [comment] [EOL] assert c is not [ [number] , [number] , [number] ] [EOL] assert c == [ [number] , [number] , [number] ] [EOL] assert c != ( [number] , [number] , [number] ) [EOL] [EOL] u = ( [number] , ) [EOL] v = ( [number] , [number] ) [comment] [EOL] w = ( u + v ) [comment] [EOL] assert w is not ( [number] , [number] , [number] ) [EOL] assert w == ( [number] , [number] , [number] ) [EOL] assert w != [ [number] , [number] , [number] ] [EOL] [EOL] s = [string] [EOL] t = [number] * s [comment] [EOL] assert t is not [string] [EOL] assert t == [string] [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] b = [number] * a [comment] [EOL] assert b is not [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] assert b == [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] u = ( [number] , [number] , [number] ) [EOL] v = [number] * u [comment] [EOL] assert u is not ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] assert v == ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 $typing.Tuple[typing.Any,...]$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] def f ( b ) : [EOL] if b : [EOL] raise NameError ( [string] ) [EOL] return [number] [EOL] [EOL] print ( [string] ) [EOL] [EOL] try : [EOL] assert f ( False ) == [number] [EOL] except NameError : [EOL] assert False [EOL] else : [comment] [EOL] pass [comment] [EOL] finally : [comment] [EOL] pass [comment] [EOL] [EOL] try : [EOL] assert f ( True ) == [number] [EOL] assert False [EOL] except NameError as e : [EOL] assert isinstance ( e , NameError ) [EOL] assert isinstance ( e . args , tuple ) [EOL] assert len ( e . args ) == [number] [EOL] assert e . args is not ( [string] , ) [EOL] assert e . args == ( [string] , ) [EOL] else : [comment] [EOL] assert False [comment] [EOL] finally : [comment] [EOL] pass [comment] [EOL] [EOL] assert isinstance ( NameError , type ) [EOL] assert isinstance ( type , type ) [EOL] [EOL] assert issubclass ( NameError , Exception ) [EOL] assert issubclass ( Exception , BaseException ) [EOL] assert issubclass ( NameError , BaseException ) [EOL] assert issubclass ( BaseException , object ) [EOL] [EOL] assert issubclass ( type , object ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import builtins [EOL] def cycle_length ( n ) : [EOL] assert n > [number] [EOL] c = [number] [EOL] while n > [number] : [EOL] if ( n % [number] ) == [number] : [EOL] n = ( n // [number] ) [EOL] else : [EOL] n = ( [number] * n ) + [number] [EOL] c += [number] [EOL] assert c > [number] [EOL] return c [EOL] [EOL] print ( [string] ) [EOL] [EOL] assert cycle_length ( [number] ) == [number] [EOL] assert cycle_length ( [number] ) == [number] [EOL] assert cycle_length ( [number] ) == [number] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import io [EOL] from sys import argv [EOL] [EOL] assert isinstance ( argv , list ) [EOL] assert len ( argv ) == [number] [EOL] [EOL] assert argv is not [ [string] ] [EOL] assert argv == [ [string] ] [EOL] [EOL] f = open ( argv [ [number] ] ) [EOL] assert str ( type ( f ) ) == [string] [EOL] assert hasattr ( f , [string] ) [EOL] assert hasattr ( f , [string] ) [EOL] [EOL] assert f is iter ( f ) [EOL] [EOL] for v in f : [EOL] assert isinstance ( v , str ) [EOL] print ( v , end = [string] ) [EOL] [EOL] for v in f : [comment] [EOL] assert isinstance ( v , str ) [EOL] print ( v , end = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] def my_zip_iter ( ) : [EOL] pass [EOL] [EOL] def my_zip_map ( ) : [EOL] pass	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] class my_complex : [EOL] [EOL] def __init__ ( self , r = [number] , i = [number] ) : [EOL] self . real = r [EOL] self . imag = i [EOL] [EOL] def __add__ ( self , c ) : [EOL] return my_complex ( self . real + c . real , self . imag + c . imag ) [EOL] [EOL] def __isub__ ( self , c ) : [EOL] return my_complex ( self . real - c . real , self . imag - c . imag ) [EOL] [EOL] def __sub__ ( self , c ) : [EOL] return my_complex ( self . real - c . real , self . imag - c . imag ) [EOL] [EOL] def __str__ ( self ) : [EOL] if self . imag < [number] : [EOL] return [string] . format ( self . real , self . imag ) [EOL] return [string] . format ( self . real , self . imag ) [EOL] [EOL] def __eq__ ( self , c ) : [EOL] if not isinstance ( c , my_complex ) : [EOL] return False [EOL] return self . real == c . real and self . imag == c . imag [EOL] [EOL] def conjugate ( self ) : [EOL] return my_complex ( self . real , - self . imag ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] def map_iter_yield ( ) : [EOL] pass [EOL] [EOL] def map_zip_yield ( ) : [EOL] pass [EOL] [EOL] def map_zip_generator ( ) : [EOL] pass	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from timeit import timeit [EOL] from unittest import main , TestCase [EOL] [EOL] from RMSE import rmse_for_range , rmse_for_enumerate , rmse_iterator , rmse_map_sum , rmse_zip_for , rmse_zip_map_sum , rmse_zip_list_sum , rmse_zip_generator_sum , rmse_numpy [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . a = [ rmse_for_range , rmse_for_enumerate , rmse_iterator , rmse_map_sum , rmse_zip_for , rmse_zip_map_sum , rmse_zip_list_sum , rmse_zip_generator_sum , rmse_numpy , ] [EOL] def test_1 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ) , [number] ) [EOL] [EOL] def test_2 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ) , [number] ) [EOL] [EOL] def test_3 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ) , [number] ) [EOL] [EOL] def test_4 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) ) , [number] ) [EOL] [EOL] def test_5 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] print ( ) [EOL] print ( f . __name__ ) [EOL] t = timeit ( f . __name__ + [string] , [string] + f . __name__ , number = [number] ) [EOL] print ( [string] . format ( t * [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from functools import reduce [EOL] from operator import sub [EOL] [EOL] import numpy as np [EOL] [EOL] [EOL] def rmse_for_range ( predictions , targets ) : [EOL] [docstring] [EOL] diffs = [ ] [EOL] for i in range ( [number] , len ( predictions ) ) : [EOL] diff = predictions [ i ] - targets [ i ] [EOL] diffs . append ( diff ** [number] ) [EOL] [EOL] sums = [number] [EOL] for i in diffs : [EOL] sums += i [EOL] [EOL] mean = sums / len ( diffs ) [EOL] [EOL] return int ( mean ** [number] ) [EOL] [EOL] [EOL] def rmse_for_enumerate ( predictions , targets ) : [EOL] [docstring] [EOL] diffs = [ ] [EOL] for i in range ( [number] , len ( predictions ) ) : [EOL] diff = predictions [ i ] - targets [ i ] [EOL] diffs . append ( diff ** [number] ) [EOL] [EOL] sums = [number] [EOL] for i in diffs : [EOL] sums += i [EOL] [EOL] mean = sums / len ( diffs ) [EOL] [EOL] return int ( mean ** [number] ) [EOL] [EOL] [EOL] def rmse_iterator ( predictions , targets ) : [EOL] [docstring] [EOL] diffs = [ ] [EOL] for i in range ( [number] , len ( predictions ) ) : [EOL] diff = predictions [ i ] - targets [ i ] [EOL] diffs . append ( diff ** [number] ) [EOL] [EOL] sums = [number] [EOL] for i in diffs : [EOL] sums += i [EOL] [EOL] mean = sums / len ( diffs ) [EOL] [EOL] return int ( mean ** [number] ) [EOL] [EOL] [EOL] def rmse_map_sum ( predictions , targets ) : [EOL] [docstring] [EOL] diffs = [ ] [EOL] for i in range ( [number] , len ( predictions ) ) : [EOL] diff = predictions [ i ] - targets [ i ] [EOL] diffs . append ( diff ** [number] ) [EOL] [EOL] sums = sum ( diffs ) [EOL] [EOL] mean = sums / len ( diffs ) [EOL] [EOL] return int ( mean ** [number] ) [EOL] [EOL] [EOL] def rmse_zip_for ( predictions , targets ) : [EOL] [docstring] [EOL] diffs = [ ] [EOL] for i , j in zip ( predictions , targets ) : [EOL] diffs . append ( ( i - j ) ** [number] ) [EOL] [EOL] sums = [number] [EOL] for i in diffs : [EOL] sums = sums + i [EOL] mean = sums / len ( diffs ) [EOL] [EOL] return int ( mean ** [number] ) [EOL] [EOL] [EOL] def rmse_zip_map_sum ( predictions , targets ) : [EOL] [docstring] [EOL] zips = list ( zip ( predictions , targets ) ) [EOL] [EOL] diffs = list ( map ( lambda x : ( x [ [number] ] - x [ [number] ] ) ** [number] , zips ) ) [EOL] [EOL] sums = sum ( diffs ) [EOL] [EOL] mean = sums / len ( predictions ) [EOL] [EOL] return int ( mean ** [number] ) [EOL] [EOL] [EOL] def rmse_zip_list_sum ( predictions , targets ) : [EOL] [docstring] [EOL] zips = list ( zip ( predictions , targets ) ) [EOL] [EOL] [comment] [EOL] diffs = list ( map ( lambda x : ( x [ [number] ] - x [ [number] ] ) ** [number] , zips ) ) [EOL] [EOL] sums = sum ( diffs ) [EOL] [EOL] mean = sums / len ( diffs ) [EOL] [EOL] return int ( mean ** [number] ) [EOL] [EOL] [EOL] def rmse_zip_generator_sum ( predictions , targets ) : [EOL] [docstring] [EOL] zips = list ( zip ( predictions , targets ) ) [EOL] [EOL] diffs = list ( ( ( a - b ) ** [number] for a , b in zips ) ) [EOL] [EOL] sums = sum ( diffs ) [EOL] [EOL] mean = sums / len ( diffs ) [EOL] [EOL] return int ( mean ** [number] ) [EOL] [EOL] [EOL] def rmse_numpy ( predictions , targets ) : [EOL] [docstring] [EOL] return np . sqrt ( ( ( np . array ( predictions ) - np . array ( targets ) ) ** [number] ) . mean ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class Range_1 : [EOL] [docstring] [EOL] class Iterator ( ) : [EOL] def __init__ ( self , b , e ) : [EOL] self . b = b [EOL] self . e = e [EOL] [EOL] def __iter__ ( self ) : [EOL] return self [EOL] [EOL] def __next__ ( self ) : [EOL] if self . b == self . e : [EOL] raise StopIteration ( ) [EOL] v = self . b [EOL] self . b += [number] [EOL] return v [EOL] [EOL] def __init__ ( self , start , end ) : [EOL] self . start = start [EOL] self . end = end [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] return Range_1 . Iterator ( self . start , self . end ) [EOL] [EOL] [EOL] class Range_2 : [EOL] def __init__ ( self , start , end ) : [EOL] self . start = start [EOL] self . end = end [EOL] [EOL] def __iter__ ( self ) : [EOL] start = self . start [EOL] while start != self . end : [EOL] yield start [EOL] start += [number]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class Map_Iterator : [EOL] [EOL] def __init__ ( self , f , a ) : [EOL] [docstring] [EOL] self . f = f [EOL] self . i = iter ( a ) [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] return self [EOL] [EOL] def __next__ ( self ) : [EOL] return self . f ( next ( self . i ) ) [EOL] [EOL] [EOL] def map_for_range ( f , x ) : [EOL] for i in range ( len ( x ) ) : [EOL] yield f ( x [ i ] ) [EOL] [EOL] [EOL] def map_for_enumerate ( f , x ) : [EOL] for i , _ in enumerate ( x ) : [EOL] yield f ( x [ i ] ) [EOL] [EOL] [EOL] def map_for ( f , x ) : [EOL] for i in x : [EOL] yield f ( i ) [EOL] [EOL] [EOL] def map_generator ( f , x ) : [EOL] return ( f ( i ) for i in x ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any , Iterator [EOL] import typing [EOL] def reduce_for ( f , l , * s ) : [EOL] [EOL] if not l and not s : [EOL] raise TypeError [EOL] i = iter ( l ) [EOL] [EOL] if s : [EOL] v = s [ [number] ] [EOL] else : [EOL] v = next ( i ) [EOL] [EOL] for j in i : [EOL] v = f ( v , j ) [EOL] [EOL] return v [EOL] [EOL] [EOL] def reduce_while ( f , l , * s ) : [EOL] [EOL] if not l and not s : [EOL] raise TypeError [EOL] i = iter ( l ) [EOL] [EOL] if s : [EOL] v = s [ [number] ] [EOL] else : [EOL] v = next ( i ) [EOL] try : [EOL] while True : [EOL] v = f ( v , next ( i ) ) [EOL] except StopIteration as e : [EOL] pass [EOL] return v [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] class Range_Iterator : [EOL] [EOL] def __init__ ( self , start , end ) : [EOL] self . start = start [EOL] self . end = end [EOL] [EOL] def __iter__ ( self ) : [EOL] return self [EOL] [EOL] def __next__ ( self ) : [EOL] if self . i < self . end : [EOL] i = self . i [EOL] self . i += [number] [EOL] return i [EOL] [EOL] raise StopIteration [EOL] [EOL] [EOL] def range_iterator_yield ( start , end ) : [EOL] while start < end : [EOL] yield start [EOL] start += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from unittest import main , TestCase [EOL] [EOL] from UnitTests1 import cycle_length [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def test_1 ( self ) : [EOL] self . assertEqual ( cycle_length ( [number] ) , [number] ) [EOL] [EOL] def test_2 ( self ) : [EOL] self . assertEqual ( cycle_length ( [number] ) , [number] ) [EOL] [EOL] def test_3 ( self ) : [EOL] self . assertEqual ( cycle_length ( [number] ) , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from math import factorial [EOL] from timeit import timeit [EOL] from unittest import main , TestCase [EOL] [EOL] from Factorial import factorial_recursion , factorial_tail_recursion , factorial_while , factorial_range_for , factorial_range_iterator , factorial_range_reduce [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . a = [ factorial_recursion , factorial_tail_recursion , factorial_while , factorial_range_for , factorial_range_iterator , factorial_range_reduce , factorial ] [EOL] [EOL] def test_0 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( [number] ) , [number] ) [EOL] [EOL] def test_1 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( [number] ) , [number] ) [EOL] [EOL] def test_2 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( [number] ) , [number] ) [EOL] [EOL] def test_3 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( [number] ) , [number] ) [EOL] [EOL] def test_4 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( [number] ) , [number] ) [EOL] [EOL] def test_5 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( [number] ) , [number] ) [EOL] [EOL] def test_6 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] print ( ) [EOL] print ( f . __name__ ) [EOL] t = timeit ( f . __name__ + [string] , [string] + f . __name__ , number = [number] ) [EOL] print ( [string] . format ( t * [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterator [EOL] import typing [EOL] import builtins [EOL] from typing import Iterator [EOL] [EOL] class Range_1 : [EOL] class iterator ( ) : [EOL] def __init__ ( self , b , e ) : [EOL] self . b = b [EOL] self . e = e [EOL] [EOL] def __iter__ ( self ) : [EOL] return self [EOL] [EOL] def __next__ ( self ) : [EOL] if self . b == self . e : [EOL] raise StopIteration ( ) [EOL] v = self . b [EOL] self . b += [number] [EOL] return v [EOL] [EOL] def __init__ ( self , b , e ) : [EOL] self . b = b [EOL] self . e = e [EOL] [EOL] def __iter__ ( self ) : [EOL] return Range_1 . iterator ( self . b , self . e ) [EOL] [EOL] class Range_2 : [EOL] def __init__ ( self , b , e ) : [EOL] self . b = b [EOL] self . e = e [EOL] [EOL] def __iter__ ( self ) : [EOL] b = self . b [EOL] while b != self . e : [EOL] yield b [EOL] b += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $"Range_1.iterator"$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Iterator [EOL] import typing [EOL] def reduce_1 ( bf , a , * v ) : [EOL] if not a and not v : [EOL] raise TypeError ( [string] ) [EOL] p = iter ( a ) [EOL] if not v : [EOL] v = next ( p ) [EOL] else : [EOL] v = v [ [number] ] [EOL] for w in p : [EOL] v = bf ( v , w ) [EOL] return v [EOL] [EOL] def reduce_2 ( bf , a , * v ) : [EOL] p = iter ( a ) [EOL] if not v : [EOL] if not a : [EOL] raise TypeError ( [string] ) [EOL] v = next ( p ) [EOL] else : [EOL] v = v [ [number] ] [EOL] for w in p : [EOL] v = bf ( v , w ) [EOL] return v [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from unittest import main , TestCase [EOL] [EOL] from IsPrime2 import is_prime [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def test_01 ( self ) : [EOL] self . assertFalse ( is_prime ( [number] ) ) [EOL] [EOL] def test_02 ( self ) : [EOL] self . assertTrue ( is_prime ( [number] ) ) [EOL] [EOL] def test_03 ( self ) : [EOL] self . assertTrue ( is_prime ( [number] ) ) [EOL] [EOL] def test_04 ( self ) : [EOL] self . assertFalse ( is_prime ( [number] ) ) [EOL] [EOL] def test_05 ( self ) : [EOL] self . assertTrue ( is_prime ( [number] ) ) [EOL] [EOL] def test_07 ( self ) : [EOL] self . assertTrue ( is_prime ( [number] ) ) [EOL] [EOL] def test_09 ( self ) : [EOL] self . assertFalse ( is_prime ( [number] ) ) [EOL] [EOL] def test_27 ( self ) : [EOL] self . assertFalse ( is_prime ( [number] ) ) [EOL] [EOL] def test_29 ( self ) : [EOL] self . assertTrue ( is_prime ( [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from functools import reduce [EOL] from operator import add , sub [EOL] from unittest import main , TestCase [EOL] [EOL] from Reduce import reduce_for_range , reduce_for_enumerate , reduce_for , reduce_while [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . a = [ reduce_for_range , reduce_for_enumerate , reduce_for , reduce_while , reduce ] [EOL] [EOL] def test_1 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( None , [ ] , [number] ) , [number] ) [EOL] [EOL] def test_2 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( add , [ [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_3 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( add , [ [number] , [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_4 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( f ( sub , [ [number] , [number] , [number] ] , [number] ) , - [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from unittest import main , TestCase [EOL] [EOL] from Coverage1 import cycle_length [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def test ( self ) : [EOL] self . assertEqual ( cycle_length ( [number] ) , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Iterator [EOL] import typing [EOL] import builtins [EOL] from functools import reduce [EOL] from operator import mul [EOL] [EOL] [comment] [EOL] [comment] [EOL] def factorial_recursion ( n ) : [EOL] assert n >= [number] [EOL] if n < [number] : [EOL] return [number] [EOL] return n * factorial_recursion ( n - [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def factorial_tail_recursion ( n ) : [EOL] assert n >= [number] [EOL] def f ( n , v ) : [EOL] assert n >= [number] [EOL] assert v >= [number] [EOL] if n < [number] : [EOL] return v [EOL] return f ( n - [number] , n * v ) [EOL] return f ( n , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def factorial_while ( n ) : [EOL] assert n >= [number] [EOL] v = [number] [EOL] while n > [number] : [EOL] v *= n [EOL] n -= [number] [EOL] return v [EOL] [EOL] [comment] [EOL] [comment] [EOL] def factorial_range_for ( n ) : [EOL] assert n >= [number] [EOL] v = [number] [EOL] for i in range ( [number] , n + [number] ) : [EOL] v *= i [EOL] return v [EOL] [EOL] [comment] [EOL] [comment] [EOL] def factorial_range_iterator ( n ) : [EOL] assert n >= [number] [EOL] v = [number] [EOL] p = iter ( range ( [number] , n + [number] ) ) [EOL] try : [EOL] while True : [EOL] i = next ( p ) [EOL] v *= i [EOL] except StopIteration : [EOL] pass [EOL] return v [EOL] [EOL] [comment] [EOL] [comment] [EOL] def factorial_range_reduce ( n ) : [EOL] assert n >= [number] [EOL] return reduce ( mul , range ( [number] , n + [number] ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] def cycle_length ( n ) : [EOL] assert n > [number] [EOL] c = [number] [EOL] while n > [number] : [EOL] if ( n % [number] ) == [number] : [EOL] n = ( n // [number] ) [EOL] else : [EOL] n = ( [number] * n ) + [number] [EOL] c += [number] [EOL] assert c > [number] [EOL] return c [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Iterator [EOL] import typing [EOL] def my_zip_iter ( * a ) : [EOL] if not a : [EOL] return iter ( a ) [EOL] x = [ iter ( v ) for v in a ] [EOL] for _ in a [ [number] ] : [EOL] y = [ next ( v ) for v in x ] [EOL] yield tuple ( y ) [EOL] [EOL] def my_zip_map ( * a ) : [EOL] if not a : [EOL] return iter ( a ) [EOL] return map ( lambda * a : a , * a ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from unittest import main , TestCase [EOL] [EOL] from Coverage2 import cycle_length [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def test ( self ) : [EOL] self . assertEqual ( cycle_length ( [number] ) , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from timeit import timeit [EOL] from unittest import main , TestCase [EOL] [EOL] from Map import Map_Iterator , map_for_range , map_for_enumerate , map_for , map_generator [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . a = [ Map_Iterator , map_for_range , map_for_enumerate , map_for , map_generator , map ] [EOL] [EOL] def test_1 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( None , ( ) ) [EOL] self . assertEqual ( list ( x ) , [ ] ) [EOL] [EOL] def test_2 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( lambda v : v ** [number] , ( [number] , ) ) [EOL] self . assertEqual ( list ( x ) , [ [number] ] ) [EOL] self . assertEqual ( list ( x ) , [ ] ) [EOL] [EOL] def test_3 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( lambda v : v ** [number] , [ [number] , [number] ] ) [EOL] self . assertEqual ( list ( x ) , [ [number] , [number] ] ) [EOL] self . assertEqual ( list ( x ) , [ ] ) [EOL] [EOL] def test_4 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( lambda v : v ** [number] , ( [number] , [number] , [number] ) ) [EOL] self . assertEqual ( list ( x ) , [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( list ( x ) , [ ] ) [EOL] [EOL] def test_5 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] print ( ) [EOL] print ( f . __name__ ) [EOL] if f . __name__ == [string] : [EOL] t = timeit ( [string] + f . __name__ + [string] , [string] , number = [number] ) [EOL] else : [EOL] t = timeit ( [string] + f . __name__ + [string] , [string] + f . __name__ , number = [number] ) [EOL] print ( [string] . format ( t * [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] def cycle_length ( n ) : [EOL] assert n > [number] [EOL] c = [number] [EOL] while n > [number] : [EOL] if ( n % [number] ) == [number] : [EOL] n = ( n // [number] ) [EOL] else : [EOL] n = ( [number] * n ) + [number] [EOL] c += [number] [EOL] assert c > [number] [EOL] return c [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] def cycle_length ( n ) : [EOL] assert n > [number] [EOL] c = [number] [EOL] while n > [number] : [EOL] if ( n % [number] ) == [number] : [EOL] n = ( n // [number] ) [EOL] else : [EOL] n = ( [number] * n ) + [number] [EOL] c += [number] [EOL] assert c > [number] [EOL] return c [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Iterator [EOL] import typing [EOL] from unittest import main , TestCase [EOL] [EOL] from Range import Range_1 , Range_2 [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . a = [ Range_1 , Range_2 , range ] [EOL] [EOL] def test_1 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( [number] , [number] ) [EOL] p = iter ( x ) [EOL] self . assertIsNot ( x , p ) [EOL] self . assertIs ( p , iter ( p ) ) [EOL] self . assertRaises ( StopIteration , next , p ) [EOL] [EOL] def test_2 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( [number] , [number] ) [EOL] p = iter ( x ) [EOL] self . assertIsNot ( x , p ) [EOL] self . assertIs ( p , iter ( p ) ) [EOL] self . assertEqual ( next ( p ) , [number] ) [EOL] self . assertRaises ( StopIteration , next , p ) [EOL] [EOL] def test_3 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( [number] , [number] ) [EOL] p = iter ( x ) [EOL] self . assertIsNot ( x , p ) [EOL] self . assertIs ( p , iter ( p ) ) [EOL] self . assertEqual ( next ( p ) , [number] ) [EOL] self . assertEqual ( next ( p ) , [number] ) [EOL] self . assertRaises ( StopIteration , next , p ) [EOL] [EOL] def test_4 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( [number] , [number] ) [EOL] self . assertEqual ( list ( x ) , [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( list ( x ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Sequence , Iterator , Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Sequence , TypeVar [EOL] [EOL] from math import sqrt [EOL] from numpy import mean , square , subtract [EOL] [EOL] def rmse_for_range ( a , p ) : [EOL] assert len ( a ) == len ( p ) [EOL] v = [number] [EOL] if not a : [EOL] return v [EOL] for i in range ( len ( a ) ) : [EOL] v += ( a [ i ] - p [ i ] ) ** [number] [EOL] return sqrt ( v / len ( a ) ) [EOL] [EOL] def rmse_for_enumerate ( a , p ) : [EOL] assert len ( a ) == len ( p ) [EOL] v = [number] [EOL] if not a : [EOL] return v [EOL] for i , _ in enumerate ( a ) : [EOL] v += ( a [ i ] - p [ i ] ) ** [number] [EOL] return sqrt ( v / len ( a ) ) [EOL] [EOL] def rmse_iterator ( a , p ) : [EOL] assert len ( a ) == len ( p ) [EOL] v = [number] [EOL] if not a : [EOL] return v [EOL] ai = iter ( a ) [EOL] pi = iter ( p ) [EOL] try : [EOL] while True : [EOL] v += ( next ( ai ) - next ( pi ) ) ** [number] [EOL] except StopIteration : [EOL] pass [EOL] return sqrt ( v / len ( a ) ) [EOL] [EOL] def rmse_map_sum ( a , p ) : [EOL] assert len ( a ) == len ( p ) [EOL] v = [number] [EOL] if not a : [EOL] return v [EOL] v = sum ( map ( lambda x , y : ( x - y ) ** [number] , a , p ) ) [EOL] return sqrt ( v / len ( a ) ) [EOL] [EOL] def rmse_zip_map_sum ( a , p ) : [EOL] assert len ( a ) == len ( p ) [EOL] v = [number] [EOL] if not a : [EOL] return v [EOL] z = zip ( a , p ) [EOL] v = sum ( map ( lambda u : ( u [ [number] ] - u [ [number] ] ) ** [number] , z ) ) [EOL] return sqrt ( v / len ( a ) ) [EOL] [EOL] def rmse_zip_for ( a , p ) : [EOL] assert len ( a ) == len ( p ) [EOL] v = [number] [EOL] if not a : [EOL] return v [EOL] z = zip ( a , p ) [EOL] v = [number] [EOL] for x , y in z : [EOL] v += ( x - y ) ** [number] [EOL] return sqrt ( v / len ( a ) ) [EOL] [EOL] def rmse_zip_list_sum ( a , p ) : [EOL] assert len ( a ) == len ( p ) [EOL] v = [number] [EOL] if not a : [EOL] return v [EOL] z = zip ( a , p ) [EOL] v = sum ( [ ( x - y ) ** [number] for x , y in z ] ) [EOL] return sqrt ( v / len ( a ) ) [EOL] [EOL] def rmse_zip_generator_sum ( a , p ) : [EOL] assert len ( a ) == len ( p ) [EOL] v = [number] [EOL] if not a : [EOL] return v [EOL] z = zip ( a , p ) [EOL] v = sum ( ( x - y ) ** [number] for x , y in z ) [EOL] return sqrt ( v / len ( a ) ) [EOL] [EOL] def rmse_numpy ( a , p ) : [EOL] assert len ( a ) == len ( p ) [EOL] v = [number] [EOL] if not a : [EOL] return v [EOL] return sqrt ( mean ( square ( subtract ( a , p ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] def cycle_length ( n ) : [EOL] assert n > [number] [EOL] c = [number] [EOL] while n > [number] : [EOL] if ( n % [number] ) == [number] : [EOL] n = ( n // [number] ) [EOL] else : [EOL] n = ( [number] * n ) + [number] [EOL] c += [number] [EOL] assert c > [number] [EOL] return c [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from unittest import main , TestCase [EOL] [EOL] from Coverage3 import cycle_length [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def test ( self ) : [EOL] self . assertEqual ( cycle_length ( [number] ) , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from unittest import main , TestCase [EOL] [EOL] from RangeIterator import Range_Iterator , range_iterator_yield [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . a = [ Range_Iterator , range_iterator_yield ] [EOL] [EOL] def test_1 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] p = f ( [number] , [number] ) [EOL] self . assertIs ( p , iter ( p ) ) [EOL] self . assertRaises ( StopIteration , next , p ) [EOL] [EOL] def test_2 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] p = f ( [number] , [number] ) [EOL] self . assertIs ( p , iter ( p ) ) [EOL] self . assertEqual ( next ( p ) , [number] ) [EOL] self . assertRaises ( StopIteration , next , p ) [EOL] [EOL] def test_3 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] p = f ( [number] , [number] ) [EOL] self . assertIs ( p , iter ( p ) ) [EOL] self . assertEqual ( next ( p ) , [number] ) [EOL] self . assertEqual ( next ( p ) , [number] ) [EOL] self . assertRaises ( StopIteration , next , p ) [EOL] [EOL] def test_4 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] p = f ( [number] , [number] ) [EOL] self . assertEqual ( list ( p ) , [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( list ( p ) , [ ] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from math import sqrt [EOL] [EOL] def is_prime ( n ) : [EOL] assert n > [number] [EOL] if ( n == [number] ) : [comment] [EOL] return True [EOL] if ( n == [number] ) or ( ( n % [number] ) == [number] ) : [EOL] return False [EOL] for i in range ( [number] , int ( sqrt ( n ) ) + [number] , [number] ) : [comment] [EOL] if ( n % i ) == [number] : [EOL] return False [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] def cycle_length ( n ) : [EOL] assert n > [number] [EOL] c = [number] [EOL] while n > [number] : [EOL] if ( n % [number] ) == [number] : [EOL] n = ( n // [number] ) [EOL] else : [EOL] n = ( [number] * n ) + [number] [EOL] c += [number] [EOL] assert c > [number] [EOL] return c [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import builtins [EOL] class my_complex : [EOL] def __init__ ( self , real = [number] , imag = [number] ) : [EOL] self . real = real [EOL] self . imag = imag [EOL] [EOL] def __add__ ( self , rhs ) : [EOL] if not isinstance ( rhs , my_complex ) : [EOL] raise TypeError [EOL] return my_complex ( self . real + rhs . real , self . imag + rhs . imag ) [EOL] [EOL] def __eq__ ( self , rhs ) : [EOL] if not isinstance ( rhs , my_complex ) : [EOL] return False [EOL] return ( self . real == rhs . real ) and ( self . imag == rhs . imag ) [EOL] [EOL] def __str__ ( self ) : [EOL] return ( [string] if self . imag < [number] else [string] ) % ( self . real , self . imag ) [EOL] [EOL] def __sub__ ( self , rhs ) : [EOL] if not isinstance ( rhs , my_complex ) : [EOL] raise TypeError [EOL] return my_complex ( self . real - rhs . real , self . imag - rhs . imag ) [EOL] [EOL] def __isub__ ( self , rhs ) : [EOL] if not isinstance ( rhs , my_complex ) : [EOL] raise TypeError [EOL] return my_complex ( self . real - rhs . real , self . imag - rhs . imag ) [EOL] [EOL] def conjugate ( self ) : [EOL] return my_complex ( self . real , - self . imag ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $"my_complex"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"my_complex"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"my_complex"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"my_complex"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Iterator [EOL] import typing [EOL] def map_iter_yield ( nf , * a ) : [EOL] x = [ iter ( v ) for v in a ] [EOL] for _ in a [ [number] ] : [EOL] y = [ next ( v ) for v in x ] [EOL] yield nf ( * y ) [EOL] [EOL] def map_zip_yield ( nf , * a ) : [EOL] for v in zip ( * a ) : [EOL] yield nf ( * v ) [EOL] [EOL] def map_zip_generator ( nf , * a ) : [EOL] return ( nf ( * v ) for v in zip ( * a ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from unittest import main , TestCase [EOL] [EOL] from Map2 import map_iter_yield , map_zip_yield , map_zip_generator [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . a = [ map_iter_yield , map_zip_yield , map_zip_generator ] [EOL] [EOL] def test_1 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( lambda v : v ** [number] , [ [number] , [number] ] ) [EOL] self . assertEqual ( list ( x ) , [ [number] , [number] ] ) [EOL] self . assertEqual ( list ( x ) , [ ] ) [EOL] [EOL] def test_2 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] x = f ( lambda v , w : v ** w , ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] self . assertEqual ( list ( x ) , [ [number] , [number] ] ) [EOL] self . assertEqual ( list ( x ) , [ ] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] def cycle_length ( n ) : [EOL] assert n > [number] [EOL] c = [number] [EOL] while n > [number] : [EOL] if ( n % [number] ) == [number] : [EOL] n = ( n // [number] ) [EOL] else : [EOL] n = ( [number] * n ) + [number] [EOL] c += [number] [EOL] assert c > [number] [EOL] return c [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from math import sqrt [EOL] [EOL] def is_prime ( n ) : [EOL] assert n > [number] [EOL] if n == [number] : [EOL] return True [EOL] if ( n == [number] ) or ( ( n % [number] ) == [number] ) : [EOL] return False [EOL] for i in range ( [number] , int ( sqrt ( n ) ) + [number] , [number] ) : [EOL] if ( n % i ) == [number] : [EOL] return False [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from unittest import main , TestCase [EOL] [EOL] from Complex import my_complex [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . a = [ my_complex , complex ] [EOL] [EOL] def test_01 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( ) [EOL] self . assertEqual ( x . real , [number] ) [EOL] self . assertEqual ( x . imag , [number] ) [EOL] [EOL] def test_02 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( [number] ) [EOL] self . assertEqual ( x . real , [number] ) [EOL] self . assertEqual ( x . imag , [number] ) [EOL] [EOL] def test_03 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( [number] , [number] ) [EOL] self . assertEqual ( x . real , [number] ) [EOL] self . assertEqual ( x . imag , [number] ) [EOL] [EOL] def test_04 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( [number] , [number] ) [EOL] self . assertNotEqual ( x , ( [number] , [number] ) ) [comment] [EOL] self . assertEqual ( x , c ( [number] , [number] ) ) [comment] [EOL] [EOL] def test_05 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( [number] , [number] ) [EOL] s = str ( x ) [comment] [EOL] self . assertEqual ( s , [string] ) [EOL] x = c ( - [number] , - [number] ) [EOL] s = str ( x ) [comment] [EOL] self . assertEqual ( s , [string] ) [EOL] [EOL] def test_06 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( [number] , [number] ) [EOL] [comment] [EOL] y = x + c ( [number] , [number] ) [comment] [EOL] self . assertEqual ( x , c ( [number] , [number] ) ) [EOL] self . assertEqual ( y , c ( [number] , [number] ) ) [EOL] [EOL] def test_07 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( [number] , [number] ) [EOL] y = x [EOL] [comment] [EOL] x += c ( [number] , [number] ) [comment] [EOL] self . assertEqual ( x , c ( [number] , [number] ) ) [EOL] self . assertEqual ( y , c ( [number] , [number] ) ) [EOL] [EOL] def test_08 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( [number] , [number] ) [EOL] [comment] [EOL] y = x - c ( [number] , [number] ) [comment] [EOL] self . assertEqual ( x , c ( [number] , [number] ) ) [EOL] self . assertEqual ( y , c ( [number] , [number] ) ) [EOL] [EOL] def test_09 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( [number] , [number] ) [EOL] y = x [EOL] [comment] [EOL] x -= c ( [number] , [number] ) [comment] [EOL] self . assertEqual ( x , c ( [number] , [number] ) ) [EOL] self . assertEqual ( y , c ( [number] , [number] ) ) [EOL] [EOL] def test_10 ( self ) : [EOL] for c in self . a : [EOL] with self . subTest ( msg = c . __name__ ) : [EOL] x = c ( [number] , [number] ) [EOL] y = x . conjugate ( ) [EOL] self . assertEqual ( x , c ( [number] , [number] ) ) [EOL] self . assertEqual ( y , c ( [number] , - [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from unittest import main , TestCase [EOL] [EOL] from Zip import my_zip_iter , my_zip_map [EOL] [EOL] class MyUnitTests ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . a = [ my_zip_iter , my_zip_map , zip ] [EOL] [EOL] def test_1 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( list ( f ( ) ) , [ ] ) [EOL] [EOL] def test_2 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( list ( f ( [ ] ) ) , [ ] ) [EOL] [EOL] def test_3 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( list ( f ( ( ) , ( ) ) ) , [ ] ) [EOL] [EOL] def test_4 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( list ( f ( [ [number] , [number] ] ) ) , [ ( [number] , ) , ( [number] , ) ] ) [EOL] [EOL] def test_5 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( list ( f ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) ) , [ ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ] ) [EOL] [EOL] def test_6 ( self ) : [EOL] for f in self . a : [EOL] with self . subTest ( msg = f . __name__ ) : [EOL] self . assertEqual ( list ( f ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) ) , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0