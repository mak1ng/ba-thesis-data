[comment] [EOL] from typing import Any , Union [EOL] import signal [EOL] import argparse [EOL] import shutil [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from pathlib import Path [EOL] import subprocess [EOL] import shutil [EOL] import os [EOL] import signal [EOL] import logging [EOL] from typing import Union [EOL] from argparse import ArgumentParser [EOL] [EOL] SIG = signal . SIGTERM [EOL] [EOL] [EOL] def diskfree_sigterm ( disk , pid , freethres , verbose = False ) : [EOL] [EOL] def _stop ( pid ) : [EOL] if verbose : [EOL] print ( [string] , SIG , [string] , pid ) [EOL] os . kill ( pid , SIG ) [EOL] [EOL] disk = Path ( disk ) . expanduser ( ) . resolve ( ) . anchor [EOL] [EOL] du = shutil . disk_usage ( disk ) [EOL] [EOL] freerat = du . free / du . total [EOL] if freerat < freethres : [EOL] for p in pid : [EOL] if isinstance ( p , str ) : [EOL] try : [EOL] pstr = subprocess . check_output ( [ [string] , [string] , p ] , timeout = [number] , universal_newlines = True ) [EOL] except Exception : [EOL] logging . error ( f' [string] { p }' ) [EOL] for s in pstr . split ( ) : [EOL] _stop ( int ( s ) ) [EOL] [EOL] _stop ( p ) [EOL] [EOL] if verbose : [EOL] print ( f'{ disk } [string] { freerat * [number] : [string] }' ) [EOL] [EOL] [EOL] def main ( ) : [EOL] p = ArgumentParser ( ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] p . add_argument ( [string] , help = [string] , nargs = [string] ) [EOL] p . add_argument ( [string] , help = [string] , default = [number] , type = float ) [EOL] p . add_argument ( [string] , [string] , action = [string] ) [EOL] P = p . parse_args ( ) [EOL] [EOL] try : [EOL] pid = list ( map ( int , P . pid ) ) [EOL] except ValueError : [comment] [EOL] pid = P . pid [EOL] [EOL] diskfree_sigterm ( P . disk , pid , P . freethres , P . verbose ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signal.Signals$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $signal.Signals$ 0 0 0 0 0 0 0 0 0 0 0 0 $signal.Signals$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] from pybashutils . os_detect import Os [EOL] [EOL] [EOL] def main ( ) : [EOL] print ( Os ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] try : [EOL] from urllib . request import urlopen [EOL] except ImportError : [EOL] from urllib2 import urlopen [comment] [EOL] [EOL] print ( urlopen ( [string] ) . read ( ) . decode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import argparse [EOL] from argparse import ArgumentParser [EOL] import pybashutils . ulimit as ulimit [EOL] [EOL] [EOL] def main ( ) : [EOL] p = ArgumentParser ( ) [EOL] p . add_argument ( [string] , [string] , help = [string] , type = int , default = [number] ) [EOL] P = p . parse_args ( ) [EOL] [EOL] soft , hard = ulimit . raise_nofile ( P . nofile ) [EOL] print ( f' [string] { soft } [string] { hard }' ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] import psutil [EOL] [EOL] [EOL] def main ( ) : [EOL] print ( psutil . virtual_memory ( ) . available ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import argparse [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] import argparse [EOL] [EOL] p = argparse . ArgumentParser ( ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] P = p . parse_args ( ) [EOL] [EOL] source = Path ( P . source ) . expanduser ( ) [EOL] target = Path ( P . target ) . expanduser ( ) [EOL] [EOL] if not source . exists ( ) : [EOL] source . touch ( ) [EOL] [EOL] print ( [string] , source , target ) [EOL] [EOL] target . symlink_to ( source , source . is_dir ( ) ) [EOL] [EOL] assert target . is_symlink ( ) , f"{ target } [string] { source }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0
[comment] [EOL] import argparse [EOL] import filecmp [EOL] import pathlib [EOL] [docstring] [EOL] from pathlib import Path [EOL] import filecmp [EOL] from argparse import ArgumentParser [EOL] [EOL] [EOL] def diff_dir ( path1 , path2 ) : [EOL] path1 = Path ( path1 ) . expanduser ( ) [EOL] path2 = Path ( path2 ) . expanduser ( ) [EOL] [EOL] if path1 . samefile ( path2 ) : [EOL] raise OSError ( f' [string] { path1 } [string] ' ) [EOL] [EOL] diff = filecmp . dircmp ( path1 , path2 ) [comment] [EOL] print ( [string] . join ( diff . diff_files ) , end = [string] ) [comment] [EOL] print ( [string] . join ( diff . left_only ) , end = [string] ) [comment] [EOL] print ( [string] . join ( diff . right_only ) , end = [string] ) [comment] [EOL] [comment] [EOL] if any ( [ diff . diff_files , diff . left_only , diff . right_only ] ) : [EOL] print ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] p = ArgumentParser ( ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] P = p . parse_args ( ) [EOL] [EOL] diff_dir ( P . path1 , P . path2 ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Generator [EOL] import argparse [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] [docstring] [EOL] import filecmp [EOL] from pathlib import Path [EOL] from argparse import ArgumentParser [EOL] [EOL] [EOL] def compbin ( dir1 , dir2 , pat ) : [EOL] dir1 = Path ( dir1 ) . expanduser ( ) [EOL] dir2 = Path ( dir2 ) . expanduser ( ) [EOL] [EOL] fl1 = dir1 . glob ( pat ) [EOL] fl2 = dir2 . glob ( pat ) [EOL] [EOL] for f , g in zip ( fl1 , fl2 ) : [EOL] if not filecmp . cmp ( f , g , False ) : [comment] [EOL] print ( [string] , f . name ) [EOL] [EOL] [EOL] def main ( ) : [EOL] p = ArgumentParser ( ) [EOL] p . add_argument ( [string] , help = [string] , nargs = [number] ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] P = p . parse_args ( ) [EOL] [EOL] compbin ( P . dirs [ [number] ] , P . dirs [ [number] ] , P . pat ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Union [EOL] import argparse [EOL] import io [EOL] import pycurl [EOL] import ipaddress [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from argparse import ArgumentParser [EOL] import ipaddress [EOL] import pycurl [EOL] from io import BytesIO [EOL] from typing import List , Union [EOL] [EOL] length = [number] [comment] [EOL] [EOL] URL = [string] [EOL] [EOL] [EOL] def main ( ) : [EOL] p = ArgumentParser ( ) [EOL] p . add_argument ( [string] , help = [string] , nargs = [string] ) [EOL] p . add_argument ( [string] , help = [string] , default = [string] ) [EOL] P = p . parse_args ( ) [EOL] [EOL] addr = getip ( P . url , P . iface ) [EOL] for a in addr : [EOL] print ( a ) [EOL] [EOL] [EOL] def getip ( url = None , iface = None ) : [EOL] if url is None : [EOL] url = URL [EOL] [EOL] addrs = [ ] [EOL] for v in ( pycurl . IPRESOLVE_V4 , pycurl . IPRESOLVE_V6 ) : [EOL] addr = _public_addr ( v , url , iface ) [EOL] if addr is not None : [EOL] addrs . append ( addr ) [EOL] [EOL] return addrs [EOL] [EOL] [EOL] def _public_addr ( v , url , iface = None ) : [EOL] B = BytesIO ( ) [EOL] C = pycurl . Curl ( ) [EOL] addr = None [EOL] [comment] [EOL] C . setopt ( pycurl . TIMEOUT , [number] ) [comment] [EOL] if iface : [EOL] C . setopt ( pycurl . INTERFACE , iface ) [EOL] C . setopt ( C . URL , url ) [comment] [EOL] C . setopt ( pycurl . IPRESOLVE , v ) [EOL] C . setopt ( C . WRITEDATA , B ) [comment] [EOL] [comment] [EOL] ret = None [EOL] try : [EOL] C . perform ( ) [EOL] ret = B . getvalue ( ) [EOL] C . close ( ) [EOL] except pycurl . error : [EOL] pass [EOL] [comment] [EOL] if ret : [EOL] addr = ipaddress . ip_address ( ret . decode ( [string] ) ) [EOL] [EOL] return addr [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[ipaddress.IPv4Address,ipaddress.IPv6Address]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,ipaddress.IPv4Address,ipaddress.IPv6Address]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] import pandas [EOL] from argparse import ArgumentParser [EOL] from pathlib import Path [EOL] import numpy as np [EOL] [EOL] [EOL] def main ( ) : [EOL] p = ArgumentParser ( ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] p = p . parse_args ( ) [EOL] [EOL] ids = pandas . read_excel ( Path ( p . fn ) . expanduser ( ) , usecols = [string] ) . dropna ( ) [EOL] ids = np . append ( ids . iloc [ : , [number] ] . values , ids . iloc [ : , [number] ] . values ) [EOL] [EOL] emails = ( ids + f' [string] { p . domain }' ) . tolist ( ) [EOL] [EOL] print ( [string] . join ( emails ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import argparse [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] import logging [EOL] from pathlib import Path [EOL] import tarfile [EOL] from argparse import ArgumentParser [EOL] [EOL] [EOL] def tarcp ( din , fout , method = [string] , compresslevel = [number] ) : [EOL] [comment] [EOL] assert isinstance ( method , str ) , [string] [EOL] din = Path ( din ) . expanduser ( ) [EOL] assert din . is_dir ( ) , [string] [EOL] [comment] [EOL] fout = Path ( fout ) . expanduser ( ) . with_suffix ( [string] + method ) [EOL] fout . parent . mkdir ( parents = True , exist_ok = True ) [EOL] [comment] [EOL] dlist = [ d for d in din . iterdir ( ) if d . is_dir ( ) ] [EOL] print ( f' [string] { len ( dlist ) } [string] { din } [string] { fout }' ) [EOL] [comment] [EOL] with tarfile . open ( fout , mode = [string] + method , compresslevel = compresslevel ) as tar : [EOL] for d in dlist : [EOL] try : [EOL] tar . add ( d , recursive = True ) [EOL] except PermissionError : [EOL] logging . error ( f' [string] { d }' ) [EOL] [EOL] assert fout . is_file ( ) , f' [string] { fout } [string] ' [EOL] [EOL] [EOL] def main ( ) : [EOL] p = ArgumentParser ( description = [string] ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] p . add_argument ( [string] , help = [string] ) [EOL] P = p . parse_args ( ) [EOL] [EOL] tarcp ( P . din , P . fout ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from setuptools import setup [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] [EOL] class ChDir ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path ) : [EOL] self . old_dir = os . getcwd ( ) [EOL] self . new_dir = path [EOL] [EOL] def __enter__ ( self ) : [EOL] os . chdir ( self . new_dir ) [EOL] [EOL] def __exit__ ( self , * args ) : [EOL] os . chdir ( self . old_dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] import logging [EOL] logging . basicConfig ( format = [string] , datefmt = [string] ) [EOL] [EOL] [EOL] def alwaysfail ( ) : [EOL] logging . warning ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] alwaysfail ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any [EOL] import argparse [EOL] import typing [EOL] import socket [EOL] [docstring] [EOL] import socket [EOL] [EOL] [EOL] [comment] [EOL] SO_BINDTODEVICE = [number] [EOL] [EOL] [EOL] def freeport ( iface = None ) : [EOL] s = socket . socket ( ) [EOL] [EOL] if iface : [comment] [EOL] s . setsockopt ( socket . SOL_SOCKET , SO_BINDTODEVICE , bytes ( iface , [string] ) ) [EOL] [EOL] s . bind ( ( [string] , [number] ) ) [EOL] port = s . getsockname ( ) [ [number] ] [EOL] s . close ( ) [comment] [EOL] [EOL] return port [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] from argparse import ArgumentParser [EOL] p = ArgumentParser ( ) [EOL] p . add_argument ( [string] , [string] , help = [string] ) [EOL] P = p . parse_args ( ) [EOL] [EOL] port = freeport ( P . iface ) [EOL] [EOL] print ( port ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Tuple [EOL] import resource as res [EOL] [EOL] [EOL] def raise_nofile ( nofile_atleast = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] soft , ohard = res . getrlimit ( res . RLIMIT_NOFILE ) [EOL] hard = ohard [EOL] [comment] [EOL] if soft < nofile_atleast : [EOL] soft = nofile_atleast [EOL] [EOL] if hard < soft : [EOL] hard = soft [EOL] [EOL] print ( [string] . format ( soft , hard ) ) [EOL] try : [EOL] res . setrlimit ( res . RLIMIT_NOFILE , ( soft , hard ) ) [EOL] except ( ValueError , res . error ) : [EOL] try : [EOL] hard = soft [EOL] print ( [string] . format ( soft , hard ) ) [EOL] res . setrlimit ( res . RLIMIT_NOFILE , ( soft , hard ) ) [EOL] except Exception : [EOL] print ( [string] ) [EOL] soft , hard = res . getrlimit ( res . RLIMIT_NOFILE ) [EOL] [EOL] return soft , hard [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from platform import system , uname [EOL] [EOL] [EOL] class Os : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] syst = system ( ) . lower ( ) [EOL] [EOL] [comment] [EOL] self . cygwin = False [EOL] self . wsl = False [EOL] self . mac = False [EOL] self . linux = False [EOL] self . windows = False [EOL] self . bsd = False [EOL] [EOL] if [string] in syst : [EOL] self . cygwin = True [EOL] self . os = [string] [EOL] elif [string] in syst : [EOL] self . mac = True [EOL] self . os = [string] [EOL] elif [string] in syst : [EOL] self . linux = True [EOL] self . os = [string] [EOL] if [string] in uname ( ) . release : [EOL] self . wsl = True [EOL] self . linux = False [EOL] self . os = [string] [EOL] elif [string] in syst : [EOL] self . windows = True [EOL] self . os = [string] [EOL] elif [string] in syst : [EOL] self . bsd = True [EOL] self . os = [string] [EOL] [EOL] def __str__ ( self ) : [EOL] return self . os [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] from pybashutils . getfreeport import freeport [EOL] from pybashutils . os_detect import Os [EOL] [EOL] [EOL] def test_getfreeport ( ) : [EOL] [EOL] port = freeport ( ) [EOL] assert isinstance ( port , int ) [EOL] [EOL] [EOL] def test_os ( ) : [EOL] os = str ( Os ( ) ) [EOL] [EOL] assert isinstance ( os , str ) and len ( os ) >= [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] pytest . main ( [ [string] , __file__ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] def test_ulimit ( ) : [EOL] [EOL] ulimit = pytest . importorskip ( [string] ) [EOL] [EOL] soft , hard = ulimit . raise_nofile ( [number] ) [EOL] [EOL] assert soft >= [number] [EOL] assert hard >= [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] pytest . main ( [ [string] , __file__ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0