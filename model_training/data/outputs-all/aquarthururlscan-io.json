	0
	0
from typing import Any , Tuple , List , Dict [EOL] import uuid [EOL] import typing [EOL] import itertools [EOL] import uuid [EOL] [EOL] import pytest [EOL] [EOL] from . . context import utils [EOL] [EOL] TEST_WEBSITE = [string] [EOL] TEST_UUID = uuid . uuid4 ( ) [EOL] [EOL] TEST_FLAGS = { [string] : f" [string] { TEST_WEBSITE }" , [string] : f" [string] { TEST_WEBSITE }" , [string] : f" [string] { TEST_UUID }" } [EOL] [EOL] ALL_FLAG_COMBOS = [ combo for i in range ( len ( TEST_FLAGS ) + [number] ) for combo in itertools . combinations ( TEST_FLAGS . values ( ) , i ) ] [EOL] [EOL] ALL_SPLIT_FLAG_COMBOS = [ ] [EOL] for combo in ALL_FLAG_COMBOS : [EOL] split_flags = [ ] [EOL] for flag in combo : [EOL] split_flags += flag . split ( [string] ) [EOL] ALL_SPLIT_FLAG_COMBOS . append ( split_flags ) [EOL] [EOL] [comment] [EOL] ALL_SPLIT_FLAG_COMBOS . append ( [ [string] ] ) [EOL] [EOL] [comment] [EOL] ALL_SPLIT_FLAG_COMBOS . append ( [ [string] ] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ALL_SPLIT_FLAG_COMBOS ) def test_create_arg_parser_mutually_exclusive_group ( mock_flags ) : [EOL] parser = utils . create_arg_parser ( ) [EOL] if [string] . join ( mock_flags ) in TEST_FLAGS . values ( ) : [EOL] args = vars ( parser . parse_args ( mock_flags ) ) [EOL] for name , value in args . items ( ) : [EOL] if ( name not in ( [string] , [string] ) ) and args [ name ] is not None : [EOL] assert TEST_FLAGS [ name ] . split ( [string] ) [ [number] ] . strip ( ) == value . strip ( ) [EOL] else : [EOL] with pytest . raises ( SystemExit ) : [EOL] parser . parse_args ( mock_flags ) [EOL] [EOL] MOCK_INVALID_VERBOSITY_LEVELS = ( - [number] , [number] , [number] , [number] , [string] , [string] , [ [string] , [string] ] , ( [string] , [string] ) , ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , MOCK_INVALID_VERBOSITY_LEVELS ) def test_create_arg_parser_fails_with_invalid_verbosity_level ( mock_invalid_verbosity_level ) : [EOL] parser = utils . create_arg_parser ( ) [EOL] with pytest . raises ( SystemExit ) : [EOL] parser . parse_args ( [ [string] , str ( mock_invalid_verbosity_level ) , [string] , TEST_WEBSITE ] ) [EOL] [EOL] MOCK_INVALID_URLS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , MOCK_INVALID_URLS ) def test_is_url_valid_for_invalid_urls ( mock_invalid_url ) : [comment] [EOL] assert not utils . is_url_valid ( mock_invalid_url ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , TEST_FLAGS . values ( ) ) def test_validate_arguments_with_valid_arguments ( mock_flag ) : [comment] [EOL] parser = utils . create_arg_parser ( ) [EOL] args = parser . parse_args ( mock_flag . split ( [string] ) ) [EOL] utils . validate_arguments ( args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 $typing.List[typing.Tuple[builtins.str,...]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,...]]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.float,builtins.str,builtins.str,typing.List[builtins.str],typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.float,builtins.str,builtins.str,typing.List[builtins.str],typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Tuple , List , Dict [EOL] import pathlib [EOL] import io [EOL] import typing [EOL] import _csv [EOL] import asyncio [EOL] import csv [EOL] import json [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] import aiofiles [EOL] import aiohttp [EOL] [EOL] logging . basicConfig ( format = [string] , datefmt = [string] ) [EOL] [EOL] class UrlScan : [EOL] URLSCAN_API_URL = [string] [EOL] DEFAULT_PAUSE_TIME = [number] [EOL] DEFAULT_MAX_ATTEMPTS = [number] [EOL] [EOL] def __init__ ( self , api_key , data_dir = Path . cwd ( ) , log_level = [number] ) : [EOL] self . api_key = api_key [EOL] self . data_dir = data_dir [EOL] self . session = aiohttp . ClientSession ( trust_env = True ) [EOL] self . verbose = True [EOL] self . logger = logging . getLogger ( [string] ) [EOL] self . logger . setLevel ( log_level ) [EOL] [EOL] async def __aenter__ ( self ) : [EOL] return self [EOL] [EOL] async def __aexit__ ( self , * excinfo ) : [EOL] await self . session . close ( ) [EOL] [EOL] async def execute ( self , method , url , headers = None , payload = None ) : [EOL] async with self . session . request ( method = method , url = url , headers = headers , data = json . dumps ( payload ) , ssl = False ) as response : [EOL] self . logger . debug ( [string] , method , url , response . status ) [EOL] return response . status , await response . read ( ) [EOL] [EOL] async def save_file ( self , target_path , content ) : [EOL] self . logger . debug ( [string] , target_path ) [EOL] async with aiofiles . open ( target_path , [string] ) as data : [EOL] await data . write ( content ) [EOL] [EOL] async def submit_scan_request ( self , url , private = False ) : [EOL] headers = { [string] : [string] , [string] : self . api_key } [EOL] payload = { [string] : url } if private else { [string] : url , [string] : [string] } [EOL] status , response = await self . execute ( [string] , f"{ self . URLSCAN_API_URL } [string] " , headers , payload ) [EOL] if status == [number] : [EOL] self . logger . critical ( [string] , url ) [EOL] return [string] [EOL] body = json . loads ( response ) [EOL] if status >= [number] : [EOL] self . logger . critical ( [string] , url , body [ [string] ] ) [EOL] return [string] [EOL] return body [ [string] ] [EOL] [EOL] async def fetch_result ( self , scan_uuid ) : [EOL] _ , response = await self . execute ( [string] , f"{ self . URLSCAN_API_URL } [string] { scan_uuid }" ) [EOL] body = json . loads ( response ) [EOL] return { [string] : scan_uuid , [string] : body [ [string] ] [ [string] ] , [string] : await self . download_screenshot ( body [ [string] ] [ [string] ] ) , [string] : await self . download_dom ( scan_uuid , body [ [string] ] [ [string] ] ) } [EOL] [EOL] async def download_screenshot ( self , screenshot_url ) : [EOL] self . logger . info ( [string] , screenshot_url ) [EOL] screenshot_name = screenshot_url . split ( [string] ) [ - [number] ] [EOL] screenshot_location = Path ( f"{ self . data_dir } [string] { screenshot_name }" ) [EOL] status , response = await self . execute ( [string] , screenshot_url ) [EOL] if status == [number] : [EOL] await self . save_file ( screenshot_location , response ) [EOL] return str ( screenshot_location ) [EOL] [EOL] async def download_dom ( self , scan_uuid , dom_url ) : [EOL] self . logger . info ( [string] , dom_url ) [EOL] dom_location = Path ( f"{ self . data_dir } [string] { scan_uuid } [string] " ) [EOL] status , response = await self . execute ( [string] , dom_url ) [EOL] if status == [number] : [EOL] await self . save_file ( dom_location , response ) [EOL] return str ( dom_location ) [EOL] [EOL] async def investigate ( self , url , private = False ) : [EOL] self . logger . critical ( [string] , url ) [EOL] self . logger . debug ( [string] , self . DEFAULT_PAUSE_TIME , self . DEFAULT_MAX_ATTEMPTS ) [EOL] [EOL] self . logger . info ( [string] , url ) [EOL] scan_uuid = await self . submit_scan_request ( url , private ) [EOL] if scan_uuid == [string] : [EOL] self . logger . critical ( [string] , url ) [EOL] return { } [EOL] [EOL] self . logger . info ( [string] , url , scan_uuid ) [EOL] [EOL] attempts = [number] [EOL] await asyncio . sleep ( self . DEFAULT_PAUSE_TIME ) [EOL] while attempts < self . DEFAULT_MAX_ATTEMPTS : [EOL] self . logger . debug ( [string] , url , scan_uuid , attempts ) [EOL] try : [EOL] return await self . fetch_result ( scan_uuid ) [EOL] except KeyError : [EOL] attempts += [number] [EOL] await asyncio . sleep ( self . DEFAULT_PAUSE_TIME ) [EOL] [EOL] self . logger . critical ( [string] , attempts , scan_uuid ) [EOL] return { [string] : scan_uuid } [EOL] [EOL] async def batch_investigate ( self , urls_file , private = False ) : [EOL] output_file = open ( f"{ Path ( urls_file ) . stem } [string] " , [string] ) [EOL] output = csv . writer ( output_file ) [EOL] output . writerow ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] async with aiofiles . open ( urls_file , [string] ) as urls_data : [EOL] coros = [ ] [EOL] urls = [ ] [EOL] async for url in urls_data : [EOL] url = url . rstrip ( ) [EOL] urls . append ( url ) [EOL] coros . append ( asyncio . gather ( self . investigate ( url , private ) ) ) [EOL] await asyncio . sleep ( [number] ) [EOL] all_results = await asyncio . gather ( * coros ) [EOL] [EOL] for i , result in enumerate ( all_results ) : [EOL] result = result [ [number] ] [EOL] [EOL] report_url = result . get ( [string] ) [EOL] if not report_url : [EOL] scan_uuid = result . get ( [string] ) [EOL] if scan_uuid : [EOL] report_url = f" [string] { scan_uuid } [string] " [EOL] output . writerow ( [ urls [ i ] . rstrip ( ) , report_url , result . get ( [string] ) , result . get ( [string] ) ] ) [EOL] [EOL] output_file . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._writer$ 0 0 0 0 0 $io.TextIOWrapper$ 0 0 $_csv._writer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $_csv._writer$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0
from typing import Pattern , List , Dict [EOL] import argparse [EOL] import typing [EOL] import urllib [EOL] import argparse [EOL] import logging [EOL] import pathlib [EOL] import re [EOL] import urllib . parse [EOL] [EOL] def create_arg_parser ( ) : [EOL] parser = argparse . ArgumentParser ( prog = [string] , description = ( [string] [string] [string] [string] [string] [string] ) , ) [EOL] parser . add_argument ( [string] , [string] , help = ( [string] [string] [string] [string] [string] ) , choices = [ [number] , [number] , [number] ] , default = [number] , nargs = [string] , const = [number] , type = int ) [EOL] [EOL] parser . add_argument ( [string] , [string] , help = ( [string] ) , action = [string] ) [EOL] [EOL] group = parser . add_mutually_exclusive_group ( required = True ) [EOL] group . add_argument ( [string] , [string] , help = ( [string] [string] [string] ) , type = str ) [EOL] group . add_argument ( [string] , [string] , help = ( [string] [string] ) , type = str ) [EOL] group . add_argument ( [string] , [string] , help = [string] , type = str ) [EOL] group . add_argument ( [string] , [string] , help = ( [string] [string] ) , type = str ) [EOL] [EOL] return parser [EOL] [EOL] [EOL] def is_url_valid ( url ) : [EOL] minimum_url_attributes = [ [string] , [string] ] [EOL] token = urllib . parse . urlparse ( url ) [EOL] return all ( [ getattr ( token , attribute ) for attribute in minimum_url_attributes ] ) and len ( [ s for s in token . netloc . split ( [string] ) if s != [string] ] ) > [number] [EOL] [EOL] [EOL] def validate_arguments ( args ) : [EOL] uuid_validator = re . compile ( [string] ) [EOL] [EOL] if ( args . investigate and not is_url_valid ( args . investigate ) ) or ( args . submit and not is_url_valid ( args . submit ) ) : [EOL] raise ValueError ( [string] [string] ) [EOL] elif args . retrieve and not bool ( uuid_validator . match ( args . retrieve ) ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def create_data_dir ( data_dir ) : [EOL] pathlib . Path ( f"{ data_dir } [string] " ) . mkdir ( exist_ok = True ) [EOL] pathlib . Path ( f"{ data_dir } [string] " ) . mkdir ( exist_ok = True ) [EOL] [EOL] def convert_int_to_logging_level ( log_level ) : [EOL] mapping = { [number] : logging . CRITICAL , [number] : logging . INFO , [number] : logging . DEBUG } [EOL] return mapping [ log_level ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0