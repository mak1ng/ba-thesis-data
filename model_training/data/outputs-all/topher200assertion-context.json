from typing import Any [EOL] import requests [EOL] import typing [EOL] import os [EOL] import subprocess [EOL] import tempfile [EOL] import time [EOL] [EOL] import pytest [EOL] import requests [EOL] [EOL] from common_util import config_util [EOL] [EOL] [EOL] BADCORP_PAPERTRAIL_API_KEY = config_util . get ( [string] ) [EOL] assert BADCORP_PAPERTRAIL_API_KEY [EOL] [EOL] ROOT_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) [EOL] MAKEFILE_PATH = os . path . join ( ROOT_DIR , [string] ) [EOL] PAPERTRAIL_API_CONFIG = os . path . join ( ROOT_DIR , [string] ) [EOL] [EOL] [EOL] def test_papertrail_to_elasticsearch_integration ( setup_server_daemon ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] subprocess . check_call ( [string] , cwd = ROOT_DIR , shell = True ) [EOL] [EOL] [comment] [EOL] with tempfile . NamedTemporaryFile ( mode = [string] ) as papertrail_creds_file : [EOL] api_key_string = [string] . format ( BADCORP_PAPERTRAIL_API_KEY ) [EOL] papertrail_creds_file . write ( api_key_string ) [EOL] papertrail_creds_file . flush ( ) [EOL] res = subprocess . check_output ( [string] . format ( papertrail_creds_file . name ) , shell = True , universal_newlines = True ) [EOL] result_string = str ( res ) [EOL] assert [string] in result_string [EOL] [EOL] [comment] [EOL] res = requests . get ( [string] ) [EOL] assert res . ok , res [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def setup_server_daemon ( request ) : [EOL] [comment] [EOL] res = subprocess . check_output ( [string] , cwd = ROOT_DIR , shell = True , universal_newlines = True ) [EOL] container_id = res . strip ( ) . splitlines ( ) [ - [number] ] [EOL] [EOL] def check_server_is_running ( ) : [EOL] docker_ps_output = str ( subprocess . check_output ( [string] . format ( container_id ) , shell = True , universal_newlines = True ) ) [EOL] server_logs = str ( subprocess . check_output ( [string] . format ( container_id ) , shell = True , universal_newlines = True ) ) [EOL] assert [string] in docker_ps_output , server_logs [EOL] [EOL] check_server_is_running ( ) [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] check_server_is_running ( ) [EOL] [EOL] def teardown_server_daemon ( ) : [EOL] subprocess . call ( [string] . format ( container_id ) , shell = True , universal_newlines = True ) [EOL] request . addfinalizer ( teardown_server_daemon ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import json [EOL] import logging [EOL] from pprint import pprint [EOL] [EOL] import requests [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] __EIGHT_HOURS_IN_SECONDS = [number] * [number] * [number] [EOL] [EOL] FULLSTORY_AUTH_TOKEN = [string] [EOL] [EOL] def get_fullstory_link ( profile_name , timestamp_string ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] timestamp = datetime . datetime . strptime ( timestamp_string , [string] ) . timestamp ( ) [EOL] except ValueError : [EOL] [comment] [EOL] timestamp = datetime . datetime . strptime ( timestamp_string , [string] ) . timestamp ( ) [EOL] [EOL] [comment] [EOL] url = [string] % profile_name [EOL] headers = { [string] : FULLSTORY_AUTH_TOKEN } [EOL] sessions = requests . get ( url , headers = headers ) . json ( ) [EOL] [EOL] logger . debug ( [string] , len ( sessions ) , profile_name ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] most_recent_session = None [EOL] for session in sessions : [EOL] [comment] [EOL] if session [ [string] ] < timestamp : [EOL] [comment] [EOL] if ( most_recent_session is None or most_recent_session [ [string] ] < session [ [string] ] ) : [EOL] [comment] [EOL] most_recent_session = session [EOL] [EOL] if not most_recent_session : [EOL] logger . debug ( [string] ) [EOL] return None [comment] [EOL] [EOL] if timestamp - most_recent_session [ [string] ] > __EIGHT_HOURS_IN_SECONDS : [EOL] logger . debug ( [string] , most_recent_session [ [string] ] , timestamp ) [EOL] return None [EOL] [EOL] timestamp_in_millis = timestamp * [number] [comment] [EOL] link_to_session = [string] % ( most_recent_session [ [string] ] , timestamp_in_millis ) [EOL] [EOL] return link_to_session [EOL] [EOL] pprint ( get_fullstory_link ( [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import datetime [EOL] [EOL] from elasticsearch import Elasticsearch [EOL] import certifi [EOL] [EOL] from app import ( config_util , profile_name_parser , traceback_db , tracing , ) [EOL] [EOL] [EOL] tracer = tracing . initialize_tracer ( ) [EOL] [EOL] ES_ADDRESS = config_util . get ( [string] ) [EOL] ES = Elasticsearch ( [ ES_ADDRESS ] , ca_certs = certifi . where ( ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] for m in range ( [number] , [number] + [number] ) : [EOL] for d in range ( [number] , [number] + [number] ) : [EOL] try : [EOL] date_ = datetime . date ( [number] , m , d ) [EOL] print ( [string] % date_ ) [EOL] except Exception : [EOL] print ( [string] % date_ ) [EOL] continue [EOL] tracebacks = traceback_db . get_tracebacks ( ES , tracer , date_ , date_ , [number] ) [EOL] print ( [string] % len ( tracebacks ) ) [EOL] for traceback in tracebacks : [EOL] new_traceback = profile_name_parser . parse ( traceback ) [EOL] if new_traceback : [EOL] traceback_db . save_traceback ( ES , new_traceback ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import random [EOL] [EOL] from elasticsearch import Elasticsearch [EOL] import certifi [EOL] import pytz [EOL] [EOL] from app import ( api_aservice , config_util , ) [EOL] from app . services import ( slack_poster , ) [EOL] [EOL] [comment] [EOL] ES_ADDRESS = config_util . get ( [string] ) [EOL] ES = Elasticsearch ( [ ES_ADDRESS ] , ca_certs = certifi . where ( ) ) [EOL] [EOL] [comment] [EOL] today = datetime . datetime . now ( pytz . timezone ( [string] ) ) . date ( ) [EOL] yesterday = today - datetime . timedelta ( days = [number] ) [EOL] print ( [string] ) [EOL] tracebacks_with_metadata = api_aservice . get_tracebacks_for_day ( ES , None , today , [string] , set ( ) ) [EOL] tb_meta = random . choice ( tracebacks_with_metadata ) [EOL] traceback = tb_meta . traceback [EOL] similar_tracebacks = tb_meta . similar_tracebacks [EOL] jira_issues = tb_meta . jira_issues [EOL] [EOL] print ( [string] ) [EOL] response = slack_poster . post_traceback ( traceback , similar_tracebacks , jira_issues ) [EOL] print ( [string] % response ) [EOL] print ( response . text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import logging [EOL] import builtins [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [EOL] import pytz [EOL] import redis [EOL] [EOL] from elasticsearch import Elasticsearch [EOL] import celery [EOL] import certifi [EOL] [EOL] from common_util import ( config_util , logging_util , ) [EOL] from lib . api_call import api_call_db [EOL] from lib . common import ( cache_util , ) [EOL] from lib . jira import ( jira_issue_aservice , jira_issue_db , ) [EOL] from lib . papertrail import ( realtime_updater , ) [EOL] from lib . parser import ( s3 , ) [EOL] from lib . slack import ( slack_poster , ) [EOL] from lib . traceback import ( traceback_db , ) [EOL] from webapp import ( api_aservice , ) [EOL] [EOL] REDIS_ADDRESS = config_util . get ( [string] ) [EOL] ES_ADDRESS = config_util . get ( [string] ) [EOL] [EOL] app = celery . Celery ( [string] , broker = [string] + REDIS_ADDRESS ) [EOL] [EOL] [comment] [EOL] ES = Elasticsearch ( [ ES_ADDRESS ] , ca_certs = certifi . where ( ) ) [EOL] REDIS = redis . StrictRedis ( host = REDIS_ADDRESS ) [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] @ app . task def update_jira_issue ( issue_key , do_invalidate_cache ) : [EOL] [docstring] [EOL] issue = None [EOL] num_tries = [number] [EOL] while issue is None and num_tries < [number] : [EOL] num_tries += [number] [EOL] issue = jira_issue_aservice . get_issue ( issue_key ) [EOL] if issue is None : [EOL] [comment] [EOL] logger . info ( [string] , issue_key ) [EOL] jira_issue_db . remove_jira_issue ( ES , issue_key ) [EOL] else : [EOL] jira_issue_db . save_jira_issue ( ES , issue ) [EOL] logger . info ( [string] , issue_key ) [EOL] [EOL] if do_invalidate_cache : [EOL] cache_util . invalidate_cache ( [string] ) [EOL] [EOL] [EOL] @ app . task def update_all_jira_issues ( ) : [EOL] [docstring] [EOL] logger . info ( [string] ) [EOL] count = [number] [EOL] for issue in jira_issue_aservice . get_all_issues ( ) : [EOL] count += [number] [EOL] update_jira_issue . delay ( issue . key , do_invalidate_cache = False ) [EOL] logger . info ( [string] , count ) [EOL] [EOL] [EOL] @ app . task def parse_log_file ( bucket , key ) : [EOL] [docstring] [EOL] logger . info ( [string] , bucket , key ) [EOL] [EOL] [comment] [EOL] tracebacks , api_calls = s3 . parse_s3_file ( bucket , key ) [EOL] if tracebacks is None : [EOL] logger . error ( [string] , bucket , key ) [EOL] return [EOL] [EOL] [comment] [EOL] count = [number] [EOL] for tb in tracebacks : [EOL] count += [number] [EOL] traceback_db . save_traceback ( ES , tb ) [EOL] logger . info ( [string] , count , bucket , key ) [EOL] cache_util . invalidate_cache ( [string] ) [EOL] [EOL] [comment] [EOL] logger . info ( [string] , len ( api_calls ) , bucket , key ) [EOL] if api_call_db . save ( ES , api_calls ) : [EOL] logger . info ( [string] , len ( api_calls ) , bucket , key ) [EOL] else : [EOL] logger . error ( [string] , bucket , key ) [EOL] [EOL] [EOL] @ app . task def realtime_update ( start_time , end_time ) : [EOL] logger . info ( [string] , start_time , end_time ) [EOL] realtime_updater . run ( ES , start_time , end_time ) [EOL] [EOL] [EOL] @ app . task def hydrate_cache ( ) : [EOL] [docstring] [EOL] _ = api_aservice . get_tracebacks_for_day ( ES , None , datetime . date . today ( ) , [string] , set ( ) ) [EOL] [EOL] [EOL] @ app . task def post_unticketed_tracebacks_to_slack ( ) : [EOL] [docstring] [EOL] [comment] [EOL] today = datetime . datetime . now ( pytz . timezone ( [string] ) ) . date ( ) [EOL] [EOL] [comment] [EOL] tracebacks_with_metadata = api_aservice . get_tracebacks_for_day ( ES , None , today , [string] , set ( ) ) [EOL] tracebacks_with_metadata . reverse ( ) [comment] [EOL] [EOL] [comment] [EOL] for tb_meta in ( tb_meta for tb_meta in tracebacks_with_metadata if not REDIS . get ( __SEEN_TRACEBACKS_KEY . format ( traceback_id = tb_meta . traceback . origin_papertrail_id ) ) ) : [EOL] REDIS . setex ( __SEEN_TRACEBACKS_KEY . format ( traceback_id = tb_meta . traceback . origin_papertrail_id ) , __TWO_DAYS_IN_SECONDS , [string] ) [EOL] slack_poster . post_traceback ( tb_meta . traceback , tb_meta . similar_tracebacks , tb_meta . jira_issues ) [EOL] [EOL] [EOL] @ app . task def create_jira_ticket ( origin_papertrail_id , assign_to ) : [EOL] [docstring] [EOL] api_aservice . create_ticket ( ES , origin_papertrail_id , assign_to , reject_if_ticket_exists = True ) [EOL] [EOL] [EOL] @ app . task def create_comment_on_existing_ticket ( selected_ticket_key , origin_papertrail_id ) : [EOL] [docstring] [EOL] api_aservice . create_comment_on_existing_ticket ( ES , selected_ticket_key , origin_papertrail_id ) [EOL] [EOL] [EOL] @ app . task def tell_slack_about_new_jira_ticket ( channel , ticket_id ) : [EOL] [comment] [EOL] slack_poster . post_message_to_slack_as_real_user ( channel , [string] % ticket_id ) [EOL] [EOL] [EOL] @ app . task def tell_slack_about_updated_jira_ticket ( channel , ticket_id ) : [EOL] [comment] [EOL] slack_poster . post_message_to_slack_as_real_user ( channel , [string] % ticket_id ) [EOL] [EOL] [EOL] @ app . task def tell_slack_about_error ( channel , error ) : [EOL] [comment] [EOL] slack_poster . post_message_to_slack_as_real_user ( channel , error ) [EOL] [EOL] [EOL] @ celery . signals . setup_logging . connect def setup_logging ( * _ , ** __ ) : [EOL] logging_util . setup_logging ( ) [EOL] [EOL] [EOL] __SEEN_TRACEBACKS_KEY = [string] [EOL] [docstring] [EOL] [EOL] [EOL] __TWO_DAYS_IN_SECONDS = [number] * [number] * [number] * [number] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , List , Dict , Any , Optional [EOL] import logging [EOL] import flask [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import datetime [EOL] import logging [EOL] import json [EOL] import os [EOL] import time [EOL] import traceback [EOL] import urllib [EOL] [EOL] import certifi [EOL] import flask [EOL] import opentracing [EOL] import redis [EOL] from flask_bootstrap import Bootstrap [EOL] from flask_env import MetaFlaskEnv [EOL] from flask_kvsession import KVSessionExtension [EOL] from elasticsearch import Elasticsearch [EOL] from simplekv . memory . redisstore import RedisStore [EOL] from simplekv . decorator import PrefixDecorator [EOL] [EOL] from opentracing_instrumentation . request_context import span_in_context [EOL] [EOL] from common_util import ( es_util , logging_util , ) [EOL] from lib . common import ( cache_util , ) [EOL] from lib . jira import ( jira_issue_aservice , jira_issue_db , ) [EOL] [EOL] from lib . papertrail import ( realtime_updater , ) [EOL] from lib . traceback import ( traceback_db , traceback_formatter , ) [EOL] from webapp import ( api_aservice , healthz , text_keys , tracing , ) [EOL] import tasks [EOL] [EOL] [EOL] [comment] [EOL] ROOT_DIR = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] app = flask . Flask ( __name__ ) [EOL] [EOL] [comment] [EOL] class EnvironmentVarConfig ( metaclass = MetaFlaskEnv ) : [EOL] ENV_LOAD_ALL = True [comment] [EOL] [EOL] app . config . from_object ( EnvironmentVarConfig ) [EOL] [EOL] logging_util . setup_logging ( ) [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [comment] [EOL] Bootstrap ( app ) [EOL] [EOL] [comment] [EOL] ES = Elasticsearch ( [ app . config [ [string] ] ] , ca_certs = certifi . where ( ) ) [EOL] [EOL] [comment] [EOL] REDIS = redis . StrictRedis ( host = app . config [ [string] ] ) [EOL] store = RedisStore ( REDIS ) [EOL] prefixed_store = PrefixDecorator ( [string] , store ) [EOL] KVSessionExtension ( prefixed_store , app ) [EOL] [EOL] [comment] [EOL] healthz . add_healthcheck_endpoint ( app , ES , REDIS ) [EOL] [EOL] [comment] [EOL] DEBUG_TIMING = True [EOL] [EOL] FILTERS = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def index ( ) : [EOL] [comment] [EOL] days_ago_raw = flask . request . args . get ( [string] ) [EOL] if days_ago_raw is not None : [EOL] try : [EOL] days_ago_int = int ( days_ago_raw ) [EOL] except ValueError : [EOL] return [string] , [number] [EOL] else : [EOL] days_ago_int = [number] [EOL] filter_text = flask . request . args . get ( [string] ) [EOL] if filter_text is not None : [EOL] filter_text = urllib . parse . unquote_plus ( filter_text ) [EOL] if filter_text not in FILTERS : [EOL] return [string] % filter_text , [number] [EOL] if filter_text is None : [EOL] filter_text = [string] [EOL] [EOL] [comment] [EOL] span = flask . g . tracer_root_span [EOL] tracer = opentracing . tracer [EOL] with span_in_context ( span ) : [EOL] [comment] [EOL] hidden_traceback_ids = set ( ) [EOL] if flask . session . get ( text_keys . HIDDEN_TRACEBACK ) is not None : [EOL] for traceback_text in flask . session . get ( text_keys . HIDDEN_TRACEBACK ) : [EOL] for tb in traceback_db . get_matching_tracebacks ( ES , tracer , traceback_text , es_util . EXACT_MATCH , [number] ) : [EOL] hidden_traceback_ids . add ( tb . origin_papertrail_id ) [EOL] logger . info ( [string] , len ( hidden_traceback_ids ) ) [EOL] [EOL] with span_in_context ( span ) : [EOL] span . set_tag ( [string] , filter_text ) [EOL] return api_aservice . render_main_page ( ES , tracer , days_ago_int , filter_text , set ( ) ) [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def parse_s3 ( ) : [EOL] [docstring] [EOL] [comment] [EOL] json_request = flask . request . get_json ( ) [EOL] if json_request is None or not all ( k in json_request for k in ( [string] , [string] ) ) : [EOL] return [string] , [number] [EOL] bucket = json_request [ [string] ] [EOL] key = json_request [ [string] ] [EOL] [EOL] logger . info ( [string] , bucket , key ) [EOL] tasks . parse_log_file . delay ( bucket , key ) [EOL] return [string] , [number] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def parse_s3_day ( ) : [EOL] [docstring] [EOL] [comment] [EOL] json_request = flask . request . get_json ( ) [EOL] if json_request is None or not [string] in json_request : [EOL] return [string] , [number] [EOL] date_ = json_request [ [string] ] [EOL] [EOL] api_aservice . parse_s3_for_date ( date_ , app . config [ [string] ] , app . config [ [string] ] ) [EOL] return [string] , [number] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def parse_s3_date_range ( ) : [EOL] [docstring] [EOL] [comment] [EOL] json_request = flask . request . get_json ( ) [EOL] if ( json_request is None or not [string] in json_request or not [string] in json_request ) : [EOL] return [string] , [number] [EOL] start_date_str = json_request [ [string] ] [EOL] end_date_str = json_request [ [string] ] [EOL] [EOL] [comment] [EOL] try : [EOL] start_date = datetime . datetime . strptime ( start_date_str , [string] ) . date ( ) [EOL] end_date = datetime . datetime . strptime ( end_date_str , [string] ) . date ( ) [EOL] except ValueError : [EOL] return [string] , [number] [EOL] [EOL] [comment] [EOL] date_ = start_date [EOL] while date_ <= end_date : [EOL] api_aservice . parse_s3_for_date ( date_ , app . config [ [string] ] , app . config [ [string] ] ) [EOL] date_ += datetime . timedelta ( days = [number] ) [EOL] [EOL] return [string] , [number] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def realtime_update ( ) : [EOL] [docstring] [EOL] [comment] [EOL] end_time = None [EOL] json_request = flask . request . get_json ( ) [EOL] if json_request is not None and [string] in json_request : [EOL] end_time = json_request [ [string] ] [EOL] [EOL] realtime_updater . enqueue ( end_time ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] tasks . post_unticketed_tracebacks_to_slack . apply_async ( tuple ( ) , expires = [number] ) [EOL] return [string] , [number] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def hide_traceback ( ) : [EOL] json_request = flask . request . get_json ( ) [EOL] if json_request is None or [string] not in json_request : [EOL] logger . warning ( [string] , json_request ) [EOL] return [string] , [number] [EOL] traceback_text = json_request [ [string] ] [EOL] our_set = flask . session . get ( text_keys . HIDDEN_TRACEBACK ) [EOL] if our_set is None : [EOL] our_set = set ( ) [EOL] [comment] [EOL] our_set . add ( traceback_text ) [EOL] flask . session [ text_keys . HIDDEN_TRACEBACK ] = our_set [EOL] return [string] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def restore_all_tracebacks ( ) : [EOL] flask . session [ text_keys . HIDDEN_TRACEBACK ] = None [EOL] return [string] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def create_jira_ticket ( ) : [EOL] [docstring] [EOL] [comment] [EOL] json_request = flask . request . get_json ( ) [EOL] if json_request is None or [string] not in json_request : [EOL] logger . warning ( [string] , json_request ) [EOL] return [string] , [number] [EOL] origin_papertrail_id = json_request [ [string] ] [EOL] [EOL] ticket_key = api_aservice . create_ticket ( ES , origin_papertrail_id , None , reject_if_ticket_exists = False ) [EOL] [EOL] [comment] [EOL] url = jira_issue_aservice . get_link_to_issue ( ticket_key ) [EOL] return [string] % ( url , ticket_key ) [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def jira_comment ( ) : [EOL] [docstring] [EOL] [comment] [EOL] json_request = flask . request . get_json ( ) [EOL] if json_request is None : [EOL] logger . warning ( [string] , json_request ) [EOL] return [string] , [number] [EOL] if [string] not in json_request : [EOL] logger . warning ( [string] , json_request ) [EOL] return [string] , [number] [EOL] if [string] not in json_request : [EOL] logger . warning ( [string] , json_request ) [EOL] return [string] , [number] [EOL] origin_papertrail_id = json_request [ [string] ] [EOL] issue_key = json_request [ [string] ] [EOL] [EOL] api_aservice . create_comment_on_existing_ticket ( ES , issue_key , origin_papertrail_id ) [EOL] url = jira_issue_aservice . get_link_to_issue ( issue_key ) [EOL] return [string] % ( url , issue_key ) [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def jira_formatted_list ( traceback_origin_id ) : [EOL] [docstring] [EOL] try : [EOL] traceback_id = int ( traceback_origin_id ) [EOL] except ValueError : [EOL] return [string] , [number] [EOL] if not traceback_id : [EOL] return [string] , [number] [EOL] [EOL] [comment] [EOL] tb = traceback_db . get_traceback ( ES , traceback_id ) [EOL] [EOL] [comment] [EOL] tracebacks = traceback_db . get_matching_tracebacks ( ES , opentracing . tracer , tb . traceback_text , es_util . EXACT_MATCH , [number] ) [EOL] tracebacks . sort ( key = lambda tb : int ( tb . origin_papertrail_id ) , reverse = True ) [EOL] [EOL] return ( traceback_formatter . create_hits_list ( tracebacks , traceback_formatter . jira_formatted_string ) , [number] , { [string] : [string] } ) [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def slack_callback ( ) : [EOL] data = flask . request . get_data ( ) [EOL] if data is None : [EOL] return [string] , [number] [EOL] [EOL] parsed_data = urllib . parse . parse_qs ( data ) [EOL] payload = json . loads ( parsed_data [ [string] ] [ [number] ] ) [EOL] if [string] in payload : [EOL] [comment] [EOL] action = payload [ [string] ] [ [number] ] [ [string] ] [EOL] logger . info ( [string] , action ) [EOL] if action == [string] : [EOL] origin_papertrail_id = payload [ [string] ] [EOL] assign_to = payload [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [EOL] tasks . create_jira_ticket . delay ( origin_papertrail_id , assign_to ) [EOL] [EOL] [comment] [EOL] original_message = payload [ [string] ] [EOL] original_message [ [string] ] . pop ( ) [comment] [EOL] original_message [ [string] ] . append ( { [string] : [string] } ) [EOL] return flask . jsonify ( original_message ) [EOL] elif action == [string] : [EOL] origin_papertrail_id = payload [ [string] ] [EOL] selected_ticket_key = payload [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [EOL] tasks . create_comment_on_existing_ticket . delay ( selected_ticket_key , origin_papertrail_id ) [EOL] [EOL] [comment] [EOL] original_message = payload [ [string] ] [EOL] original_message [ [string] ] . pop ( ) [comment] [EOL] original_message [ [string] ] . append ( { [string] : [string] % selected_ticket_key } ) [EOL] return flask . jsonify ( original_message ) [EOL] else : [EOL] logger . error ( [string] , action ) [EOL] logger . warning ( [string] , payload ) [EOL] elif [string] in payload : [EOL] [comment] [EOL] action = payload [ [string] ] [EOL] logger . info ( [string] , action ) [EOL] if action == [string] : [EOL] search_phrase = payload [ [string] ] [EOL] options = { [string] : list ( jira_issue_aservice . search_matching_jira_tickets ( ES , search_phrase ) ) } [EOL] return flask . Response ( json . dumps ( options ) , mimetype = [string] ) [EOL] else : [EOL] logger . error ( [string] , action ) [EOL] logger . warning ( [string] , payload ) [EOL] else : [EOL] logger . error ( [string] , payload ) [EOL] return [string] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def update_jira_db ( ) : [EOL] [docstring] [EOL] [comment] [EOL] json_request = flask . request . get_json ( ) [EOL] if json_request is None or not any ( k in json_request for k in ( [string] , [string] ) ) : [EOL] return [string] , [number] [EOL] [EOL] if [string] in json_request : [EOL] [comment] [EOL] issue_key = json_request [ [string] ] [EOL] tasks . update_jira_issue . delay ( issue_key , do_invalidate_cache = True ) [EOL] return [string] , [number] [EOL] else : [EOL] if json_request [ [string] ] != True : [EOL] return [string] , [number] [EOL] [comment] [EOL] tasks . update_all_jira_issues . delay ( ) [EOL] return [string] , [number] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) @ app . route ( [string] , methods = [ [string] ] ) def invalidate_cache ( cache = None ) : [EOL] [docstring] [EOL] cache_util . invalidate_cache ( cache ) [EOL] return [string] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def purge_celery_queue ( ) : [EOL] num_tasks = REDIS . llen ( [string] ) [EOL] REDIS . delete ( [string] ) [EOL] logger . info ( [string] , num_tasks ) [EOL] return [string] [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def admin ( ) : [EOL] error = False [EOL] num_jira_issues = None [EOL] try : [EOL] num_jira_issues = jira_issue_db . get_num_jira_issues ( ES ) [EOL] except Exception : [EOL] logger . warning ( [string] , exc_info = True ) [EOL] error = True [EOL] num_celery_tasks = None [EOL] try : [EOL] num_celery_tasks = REDIS . llen ( [string] ) [EOL] except Exception : [EOL] logger . warning ( [string] , exc_info = True ) [EOL] error = True [EOL] return flask . render_template ( [string] , num_jira_issues = num_jira_issues , num_celery_tasks = num_celery_tasks , error = error , ) [EOL] [EOL] [EOL] @ app . before_first_request def before_first_request ( ) : [EOL] [comment] [EOL] tracing . initialize_tracer ( ) [EOL] [EOL] [EOL] @ app . before_request def start_request ( ) : [EOL] [comment] [EOL] json_request = flask . request . get_json ( ) [EOL] json_str = [string] % str ( json_request ) [ : [number] ] if json_request is not None else [string] [EOL] logger . info ( [string] , flask . request . method , flask . request . full_path , flask . request . remote_addr , json_str , ) [EOL] [EOL] [comment] [EOL] headers = { } [EOL] endpoint = flask . request . endpoint [EOL] for k , v in flask . request . headers : [EOL] headers [ k . lower ( ) ] = v [EOL] try : [EOL] tracer = opentracing . tracer [EOL] span_ctx = tracer . extract ( opentracing . Format . HTTP_HEADERS , headers ) [EOL] span = tracer . start_span ( operation_name = endpoint , child_of = span_ctx ) [EOL] except ( opentracing . InvalidCarrierException , opentracing . SpanContextCorruptedException ) as e : [EOL] span = tracer . start_span ( operation_name = endpoint , tags = { [string] : str ( e ) } ) [EOL] span . set_tag ( [string] , flask . request . full_path ) [EOL] span . set_tag ( [string] , flask . request . method ) [EOL] span . set_tag ( [string] , [string] in flask . request . full_path ) [EOL] flask . g . tracer_root_span = span [EOL] [EOL] [comment] [EOL] flask . g . start_time = time . time ( ) [EOL] [EOL] [EOL] @ app . after_request def after_request ( response ) : [EOL] [docstring] [EOL] flask . g . tracer_root_span . finish ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] time_diff = time . time ( ) - flask . g . start_time [EOL] time_diff_str = [string] % time_diff [EOL] except AttributeError : [EOL] logger . warning ( [string] ) [EOL] time_diff_str = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if response . status_code != [number] : [EOL] logger . info ( [string] , flask . request . method , flask . request . full_path , flask . request . remote_addr , time_diff_str , response . status , ) [EOL] return response [EOL] [EOL] [EOL] @ app . errorhandler ( Exception ) def exceptions ( _ ) : [EOL] [docstring] [EOL] tb = traceback . format_exc ( ) [EOL] logger . error ( [string] , flask . request . method , flask . request . full_path , flask . request . remote_addr , tb , ) [EOL] [EOL] return [string] , [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( debug = True , use_reloader = False , host = [string] , port = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import logging [EOL] [EOL] import click [EOL] [EOL] from badcorp . util . setup_logging import setup_logging [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] LOG_FILE_LOCATION = [string] [EOL] [EOL] [EOL] @ click . command ( ) def main ( ) : [EOL] from badcorp . main import generate_assertions [EOL] [EOL] setup_logging ( LOG_FILE_LOCATION ) [EOL] [EOL] logger . debug ( [string] ) [EOL] generate_assertions ( ) [EOL] logger . debug ( [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List , Set , Optional [EOL] import logging [EOL] import src [EOL] import datetime [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import typing [EOL] [EOL] import flask [EOL] import opentracing [EOL] import pytz [EOL] [EOL] from opentracing_instrumentation . request_context import get_current_span , span_in_context [EOL] [EOL] from common_util import ( es_util , ) [EOL] from lib . jira import ( jira_issue_aservice , jira_issue_db , ) [EOL] from lib . slack import slack_channel [EOL] from lib . traceback import ( traceback_db , ) [EOL] from webapp import ( text_keys , ) [EOL] import tasks [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] TWO_WEEKS_AGO = datetime . datetime . now ( datetime . timezone . utc ) - datetime . timedelta ( days = [number] ) [EOL] [EOL] [EOL] class TracebackPlusMetadata ( ) : [EOL] [docstring] [EOL] def __init__ ( self , traceback ) : [EOL] self . traceback = traceback [EOL] self . jira_issues = None [EOL] self . similar_jira_issues = None [EOL] self . similar_tracebacks = None [EOL] [EOL] __slots__ = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def get_tracebacks_for_day ( ES , tracer , date_to_analyze , filter_text , hidden_traceback_ids , ) : [EOL] [docstring] [EOL] tracer = tracer or opentracing . tracer [EOL] root_span = get_current_span ( ) [EOL] [EOL] [comment] [EOL] with tracer . start_span ( [string] , child_of = root_span ) as span : [EOL] with span_in_context ( span ) : [EOL] tracebacks = traceback_db . get_tracebacks ( ES , tracer , date_to_analyze , date_to_analyze ) [EOL] logger . debug ( [string] , len ( tracebacks ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] tb_meta = [ TracebackPlusMetadata ( traceback = t ) for t in tracebacks if t . origin_papertrail_id not in hidden_traceback_ids ] [EOL] [EOL] [comment] [EOL] with tracer . start_span ( [string] , child_of = root_span ) as span : [EOL] with span_in_context ( span ) : [EOL] for tb in tb_meta : [EOL] tb . jira_issues = jira_issue_db . get_matching_jira_issues ( ES , tracer , tb . traceback . traceback_text , es_util . EXACT_MATCH ) [EOL] matching_jira_keys = set ( jira_issue . key for jira_issue in tb . jira_issues ) [EOL] similar_jira_issues = jira_issue_db . get_matching_jira_issues ( ES , tracer , tb . traceback . traceback_text , es_util . SIMILAR_MATCH ) [EOL] tb . similar_jira_issues = [ similar_jira_issue for similar_jira_issue in similar_jira_issues if similar_jira_issue . key not in matching_jira_keys ] [EOL] [EOL] [comment] [EOL] if filter_text == [string] : [EOL] tb_meta = [ tb for tb in tb_meta if tb . jira_issues ] [EOL] elif filter_text == [string] : [EOL] tb_meta = [ tb for tb in tb_meta if not tb . jira_issues ] [EOL] elif filter_text == [string] : [EOL] tb_meta_without_recent_ticket = [ ] [EOL] for tb in tb_meta : [EOL] has_recent_issues = False [EOL] for issue in tb . jira_issues : [EOL] if issue . updated > TWO_WEEKS_AGO : [EOL] has_recent_issues = True [EOL] break [EOL] if not has_recent_issues : [EOL] tb_meta_without_recent_ticket . append ( tb ) [EOL] tb_meta = tb_meta_without_recent_ticket [EOL] elif filter_text == [string] : [EOL] tb_meta = [ tb for tb in tb_meta if [ issue for issue in tb . jira_issues if issue . status != [string] ] ] [EOL] else : [EOL] tb_meta = tb_meta [EOL] [EOL] [comment] [EOL] tb_meta = tb_meta [ : [number] ] [EOL] [EOL] [comment] [EOL] with tracer . start_span ( [string] , child_of = root_span ) as span : [EOL] with span_in_context ( span ) : [EOL] for tb in tb_meta : [EOL] tb . similar_tracebacks = [ ] [EOL] tb . similar_tracebacks = traceback_db . get_matching_tracebacks ( ES , tracer , tb . traceback . traceback_text , es_util . EXACT_MATCH , [number] ) [EOL] [EOL] return tb_meta [EOL] [EOL] [EOL] def render_main_page ( ES , tracer , days_ago , filter_text , hidden_traceback_ids ) : [EOL] [docstring] [EOL] tracer = tracer or opentracing . tracer [EOL] root_span = get_current_span ( ) [EOL] [EOL] [comment] [EOL] today = datetime . datetime . now ( pytz . timezone ( [string] ) ) . date ( ) [EOL] date_to_analyze = today - datetime . timedelta ( days = days_ago ) [EOL] [EOL] tb_meta = get_tracebacks_for_day ( ES , tracer , date_to_analyze , filter_text , hidden_traceback_ids ) [EOL] [EOL] with tracer . start_span ( [string] , child_of = root_span ) as span : [EOL] with span_in_context ( span ) : [EOL] render = flask . render_template ( [string] , tb_meta = tb_meta , show_restore_button = len ( hidden_traceback_ids ) > [number] , date_to_analyze = date_to_analyze , days_ago = days_ago , filter_text = filter_text ) [EOL] return render [EOL] [EOL] [EOL] def __user_has_hidden_tracebacks ( ) : [EOL] [docstring] [EOL] return flask . session . get ( text_keys . HIDDEN_TRACEBACK ) is not None [EOL] [EOL] [EOL] def parse_s3_for_date ( date_ , bucket , key_prefix ) : [EOL] [docstring] [EOL] for hour in range ( [number] , [number] ) : [EOL] filename_string = [string] % ( date_ , date_ , hour ) [EOL] key = [string] . join ( ( key_prefix , filename_string ) ) [EOL] logger . info ( [string] , bucket , key ) [EOL] tasks . parse_log_file . delay ( bucket , key ) [EOL] [EOL] [EOL] def create_ticket ( ES , origin_papertrail_id , assign_to , reject_if_ticket_exists ) : [EOL] [docstring] [EOL] traceback = traceback_db . get_traceback ( ES , origin_papertrail_id ) [EOL] [EOL] if reject_if_ticket_exists : [EOL] jira_issues = jira_issue_db . get_matching_jira_issues ( ES , None , traceback . traceback_text , es_util . EXACT_MATCH ) [EOL] if jira_issues : [EOL] key = jira_issues [ [number] ] . key [EOL] channel = slack_channel . get_channel_name ( traceback ) [EOL] logger . info ( [string] , key ) [EOL] tasks . tell_slack_about_error ( channel , [string] % key ) [EOL] [EOL] [comment] [EOL] similar_tracebacks = traceback_db . get_matching_tracebacks ( ES , opentracing . tracer , traceback . traceback_text , es_util . EXACT_MATCH , [number] ) [EOL] [EOL] [comment] [EOL] description = jira_issue_aservice . create_description ( similar_tracebacks ) [EOL] [EOL] [comment] [EOL] title = jira_issue_aservice . create_title ( traceback . traceback_text ) [EOL] [EOL] if assign_to : [EOL] assign_to_team = jira_issue_aservice . AssignToTeam ( assign_to ) [EOL] else : [EOL] assign_to_team = jira_issue_aservice . AssignToTeam ( [string] ) [EOL] [EOL] [comment] [EOL] ticket_id = jira_issue_aservice . create_jira_issue ( title , description , assign_to_team ) [EOL] [EOL] [comment] [EOL] channel = slack_channel . get_channel_name ( traceback ) [EOL] tasks . tell_slack_about_new_jira_ticket . delay ( channel , ticket_id ) [EOL] [EOL] return ticket_id [EOL] [EOL] def create_comment_on_existing_ticket ( ES , existing_jira_issue_key , origin_papertrail_id ) : [EOL] [docstring] [EOL] traceback = traceback_db . get_traceback ( ES , origin_papertrail_id ) [EOL] [EOL] [comment] [EOL] similar_tracebacks = traceback_db . get_matching_tracebacks ( ES , opentracing . tracer , traceback . traceback_text , es_util . EXACT_MATCH , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] existing_issue = None [EOL] for issue in jira_issue_db . get_matching_jira_issues ( ES , opentracing . tracer , traceback . traceback_text , es_util . EXACT_MATCH ) : [EOL] if issue . key == existing_jira_issue_key : [EOL] existing_issue = issue [EOL] break [EOL] [EOL] [comment] [EOL] comment = [string] [EOL] if existing_issue : [EOL] [comment] [EOL] [comment] [EOL] latest = jira_issue_aservice . find_latest_referenced_id ( existing_issue ) [EOL] if latest is not None : [EOL] tracebacks_to_comment = [ tb for tb in similar_tracebacks if int ( tb . origin_papertrail_id ) > latest ] [EOL] else : [EOL] [comment] [EOL] tracebacks_to_comment = similar_tracebacks [EOL] logger . info ( [string] , latest , len ( tracebacks_to_comment ) , len ( similar_tracebacks ) ) [EOL] comment = jira_issue_aservice . create_comment_with_hits_list ( tracebacks_to_comment ) [EOL] else : [EOL] [comment] [EOL] comment = jira_issue_aservice . create_description ( similar_tracebacks ) [EOL] [EOL] [comment] [EOL] jira_issue = jira_issue_aservice . get_issue ( existing_jira_issue_key ) [EOL] assert jira_issue [EOL] jira_issue_aservice . create_comment ( jira_issue , comment ) [EOL] [EOL] [comment] [EOL] channel = slack_channel . get_channel_name ( traceback ) [EOL] tasks . tell_slack_about_updated_jira_ticket . delay ( channel , jira_issue . key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[TracebackPlusMetadata]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from opentracing_instrumentation . client_hooks import install_all_patches [EOL] import jaeger_client [EOL] from jaeger_client . metrics . prometheus import PrometheusMetricsFactory [EOL] [EOL] from common_util import config_util [EOL] [EOL] JAEGER_REPORTING_HOST = config_util . get ( [string] ) [EOL] [EOL] [EOL] def initialize_tracer ( ) : [EOL] install_all_patches ( ) [EOL] [EOL] config = jaeger_client . Config ( config = { [string] : { [string] : [string] , [string] : [number] } , [string] : True , [string] : { [string] : JAEGER_REPORTING_HOST , } } , service_name = [string] , validate = True , metrics_factory = PrometheusMetricsFactory ( namespace = [string] ) , ) [EOL] [EOL] return config . initialize_tracer ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
HIDDEN_TRACEBACK = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] import healthcheck [EOL] from elasticsearch import Elasticsearch [EOL] import certifi [EOL] import redis [EOL] [EOL] [EOL] def add_healthcheck_endpoint ( app , ES , REDIS ) : [EOL] health = healthcheck . HealthCheck ( app , [string] ) [EOL] [EOL] ES = Elasticsearch ( [ app . config [ [string] ] ] , ca_certs = certifi . where ( ) , timeout = [number] ) [EOL] REDIS = redis . StrictRedis ( host = app . config [ [string] ] , socket_connect_timeout = [number] , socket_timeout = [number] ) [EOL] [EOL] def elasticsearch_available ( ) : [EOL] ES . info ( ) [EOL] return True , [string] [EOL] health . add_check ( elasticsearch_available ) [EOL] [EOL] def redis_available ( ) : [EOL] REDIS . info ( ) [EOL] return True , [string] [EOL] health . add_check ( redis_available ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] _ = healthcheck . EnvironmentDump ( app , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] [EOL] [EOL] def round_time ( dt = None , date_delta = datetime . timedelta ( minutes = [number] ) , to = [string] ) : [EOL] [docstring] [EOL] round_to = date_delta . total_seconds ( ) [EOL] [EOL] if dt is None : [EOL] dt = datetime . now ( ) [EOL] seconds = ( dt - dt . min ) . seconds [EOL] [EOL] if to == [string] : [EOL] rounding = ( seconds + round_to ) // round_to * round_to [EOL] elif to == [string] : [EOL] rounding = seconds // round_to * round_to [EOL] else : [EOL] rounding = ( seconds + round_to / [number] ) // round_to * round_to [EOL] [EOL] return dt + datetime . timedelta ( [number] , rounding - seconds , - dt . microsecond ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List [EOL] import logging [EOL] import pytz [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [EOL] import pytz [EOL] [EOL] [EOL] LOG_TIMEZONE = pytz . timezone ( [string] ) [EOL] [docstring] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] class ParserUtil ( ) : [EOL] @ staticmethod def parse_papertrail_log_line ( raw_log_line ) : [EOL] [docstring] [EOL] assert isinstance ( raw_log_line , str ) , ( type ( raw_log_line ) , raw_log_line ) [EOL] [EOL] log_line_pieces = raw_log_line . split ( [string] , [number] ) [EOL] assert len ( log_line_pieces ) == [number] , log_line_pieces [EOL] papertrail_id = log_line_pieces [ [number] ] [EOL] timestamp_string = log_line_pieces [ [number] ] [EOL] instance_id = log_line_pieces [ [number] ] [EOL] program_name = log_line_pieces [ [number] ] [EOL] parsed_log_message = log_line_pieces [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if [string] in timestamp_string : [EOL] timestamp_ignoring_timezone = datetime . datetime . strptime ( timestamp_string [ : [number] ] , [string] ) [EOL] else : [EOL] timestamp_ignoring_timezone = datetime . datetime . strptime ( timestamp_string [ : [number] ] , [string] ) [EOL] [EOL] [comment] [EOL] timezone_string = timestamp_string [ [number] : ] [EOL] if timezone_string == [string] : [EOL] [comment] [EOL] time_with_timezone = timestamp_ignoring_timezone . replace ( tzinfo = pytz . UTC ) [EOL] elif timezone_string in ( [string] , [string] ) : [EOL] [comment] [EOL] time_with_timezone = pytz . timezone ( [string] ) . localize ( timestamp_ignoring_timezone ) [EOL] else : [EOL] logger . error ( [string] , timezone_string , timestamp_string ) [EOL] assert False , locals ( ) [EOL] timestamp_with_tz = time_with_timezone . astimezone ( LOG_TIMEZONE ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] formatted_timestamp = timestamp_with_tz . strftime ( [string] ) [EOL] formatted_line = [string] % ( formatted_timestamp , instance_id , program_name , parsed_log_message ) [EOL] [EOL] return ( papertrail_id , timestamp_with_tz , instance_id , program_name , parsed_log_message , formatted_line , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 $typing.Union[pytz._DstTzInfo,pytz._StaticTzInfo,pytz._UTCclass]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0
from typing import Any , Set [EOL] import typing [EOL] EXACT_MATCH = [number] [comment] [EOL] SIMILAR_MATCH = [number] [comment] [EOL] ALL_MATCH_LEVELS = set ( ( EXACT_MATCH , SIMILAR_MATCH ) ) [EOL] [EOL] def generate_text_match_payload ( text , fields_to_match_against , match_level ) : [EOL] [docstring] [EOL] assert isinstance ( fields_to_match_against , list ) , ( type ( fields_to_match_against ) , fields_to_match_against ) [EOL] assert match_level in ALL_MATCH_LEVELS , ( match_level , ALL_MATCH_LEVELS ) [EOL] [EOL] if match_level is SIMILAR_MATCH : [EOL] culled_text = [string] . join ( text . split ( ) [ : - [number] ] ) [comment] [EOL] else : [EOL] culled_text = text [EOL] [EOL] return { [string] : { [string] : { [string] : culled_text , [string] : fields_to_match_against , [string] : [string] , } } } [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import logging [EOL] import logging . handlers [EOL] [EOL] from common_util import config_util [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] DEBUG_LOGGING = config_util . get ( [string] ) [EOL] [EOL] [EOL] def setup_logging ( ) : [EOL] [comment] [EOL] if logger . hasHandlers ( ) : [EOL] logger . handlers . clear ( ) [EOL] [EOL] formatter = logging . Formatter ( ( [string] [string] ) ) [EOL] [EOL] [comment] [EOL] handler = logging . StreamHandler ( ) [EOL] handler . setFormatter ( formatter ) [EOL] handler . setLevel ( logging . INFO ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] logger . setLevel ( logging . INFO ) [EOL] logger . info ( [string] , bool ( DEBUG_LOGGING ) ) [EOL] [EOL] if DEBUG_LOGGING : [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [comment] [EOL] handler = logging . handlers . RotatingFileHandler ( [string] , maxBytes = [number] , backupCount = [number] ) [EOL] handler . setFormatter ( formatter ) [EOL] handler . setLevel ( logging . DEBUG ) [EOL] logger . addHandler ( handler ) [EOL] else : [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Union , Tuple , Type [EOL] import types [EOL] import src [EOL] import typing [EOL] from collections import Callable [EOL] import functools [EOL] import logging [EOL] import sys [EOL] from time import sleep [EOL] [EOL] [EOL] class Retry ( ) : [EOL] [docstring] [EOL] [EOL] DEFAULT_SLEEP_SECONDS = ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [docstring] [EOL] [EOL] def __init__ ( self , retries = [number] , exceptions = ( Exception , ) , sleep_seconds = DEFAULT_SLEEP_SECONDS , debug = False ) : [EOL] [docstring] [EOL] assert isinstance ( retries , int ) , type ( retries ) [EOL] assert isinstance ( exceptions , tuple ) , type ( exceptions ) [EOL] assert isinstance ( sleep_seconds , tuple ) , type ( sleep_seconds ) [EOL] assert isinstance ( debug , bool ) , type ( debug ) [EOL] assert exceptions [EOL] assert all ( issubclass ( x , Exception ) for x in exceptions ) , exceptions [EOL] assert sleep_seconds [EOL] assert all ( isinstance ( x , ( int , float ) ) for x in sleep_seconds ) , sleep_seconds [EOL] assert all ( x > [number] for x in sleep_seconds ) , sleep_seconds [EOL] [EOL] self . __retries = retries [EOL] self . __exceptions = exceptions [EOL] self . __sleep_seconds = sleep_seconds [EOL] self . __debug = debug [EOL] [EOL] def __call__ ( self , func ) : [EOL] @ functools . wraps ( func ) def retry_func ( * args , ** kwargs ) : [EOL] return self . execute ( func , * args , ** kwargs ) [EOL] return retry_func [EOL] [EOL] [comment] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , * exception_args ) : [EOL] return False [EOL] [EOL] def execute ( self , func , * args , ** kwargs ) : [EOL] [docstring] [EOL] assert isinstance ( func , Callable ) , type ( func ) [EOL] [EOL] for i in range ( self . __retries ) : [EOL] try : [EOL] if self . __debug : [EOL] Retry . __LOGGER . debug ( [string] , func . __name__ , args , kwargs ) [EOL] return func ( * args , ** kwargs ) [EOL] except self . __exceptions : [EOL] exc_info = sys . exc_info ( ) [EOL] if i < self . __retries - [number] : [EOL] seconds = self . __sleep_seconds [ min ( i , len ( self . __sleep_seconds ) - [number] ) ] [EOL] Retry . __LOGGER . warning ( [string] , seconds , exc_info [ : [number] ] ) [EOL] sleep ( seconds ) [EOL] else : [EOL] raise exc_info [ [number] ] ( exc_info [ [number] ] ) . with_traceback ( exc_info [ [number] ] ) [EOL] [EOL] __LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] __slots__ = ( [string] , [string] , [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Tuple[None,None,None],typing.Tuple[typing.Type[builtins.BaseException],builtins.BaseException,types.TracebackType]]$ 0 0 0 $typing.Union[typing.Tuple[None,None,None],typing.Tuple[typing.Type[builtins.BaseException],builtins.BaseException,types.TracebackType]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Union[typing.Tuple[None,None,None],typing.Tuple[typing.Type[builtins.BaseException],builtins.BaseException,types.TracebackType]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Union[typing.Tuple[None,None,None],typing.Tuple[typing.Type[builtins.BaseException],builtins.BaseException,types.TracebackType]]$ 0 0 0 0 $typing.Union[typing.Tuple[None,None,None],typing.Tuple[typing.Type[builtins.BaseException],builtins.BaseException,types.TracebackType]]$ 0 0 0 0 0 0 0 $typing.Union[typing.Tuple[None,None,None],typing.Tuple[typing.Type[builtins.BaseException],builtins.BaseException,types.TracebackType]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] from cachetools import cached [EOL] [EOL] [EOL] class ConfigKeyNotFound ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ cached ( cache = { } ) def get ( key ) : [EOL] [docstring] [EOL] value = os . environ . get ( key ) [EOL] if value is None : [EOL] raise ConfigKeyNotFound ( key ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if value . lower ( ) in ( [string] , [string] ) : [EOL] value = value . lower ( ) == [string] [EOL] elif [string] in value : [EOL] try : [EOL] value = float ( value ) [EOL] except ValueError : [EOL] pass [EOL] else : [EOL] try : [EOL] value = int ( value ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] return value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import elasticsearch [EOL] import typing [EOL] from elasticsearch import Elasticsearch [EOL] import certifi [EOL] [EOL] from common_util import ( config_util , ) [EOL] [EOL] [EOL] def get_db ( ) : [EOL] ES_ADDRESS = config_util . get ( [string] ) [EOL] ES = Elasticsearch ( [ ES_ADDRESS ] , ca_certs = certifi . where ( ) ) [EOL] return ES [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elasticsearch.Elasticsearch$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import logging [EOL] import typing [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] def generate_assertions ( ) : [EOL] try : [EOL] empty_dict = { } [EOL] _ = empty_dict [ [string] ] [EOL] except KeyError : [EOL] logger . exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
import logging [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] __LINE_FORMATTER = logging . Formatter ( [string] , [string] ) [EOL] [EOL] [EOL] def setup_logging ( log_file ) : [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] [comment] [EOL] stream_handler = logging . StreamHandler ( ) [EOL] stream_handler . setFormatter ( __LINE_FORMATTER ) [EOL] logger . addHandler ( stream_handler ) [EOL] [EOL] [comment] [EOL] file_handler = logging . FileHandler ( log_file ) [EOL] file_handler . setFormatter ( __LINE_FORMATTER ) [EOL] logger . addHandler ( file_handler ) [EOL] [EOL] logger . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Optional [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] import logging [EOL] [EOL] from lib . jira import ( jira_issue_db , ) [EOL] from lib . traceback import ( traceback_db , ) [EOL] import tasks [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] def invalidate_cache ( cache ) : [EOL] [docstring] [EOL] if cache is None or cache == [string] : [EOL] logger . info ( [string] ) [EOL] traceback_db . invalidate_cache ( ) [EOL] if cache is None or cache == [string] : [EOL] logger . info ( [string] ) [EOL] jira_issue_db . invalidate_cache ( ) [EOL] tasks . hydrate_cache . apply_async ( tuple ( ) , expires = [number] ) [comment] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import tempfile [EOL] [EOL] import boto3 [EOL] import botocore [EOL] [EOL] from common_util import ( config_util , retry , ) [EOL] from lib . papertrail import file_parser [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] AWS_REGION = config_util . get ( [string] ) [EOL] AWS_ACCESS_KEY_ID = config_util . get ( [string] ) [EOL] AWS_SECRET_ACCESS_KEY = config_util . get ( [string] ) [EOL] [EOL] [EOL] @ retry . Retry ( exceptions = ( EOFError , ) ) def parse_s3_file ( bucket , key ) : [EOL] [docstring] [EOL] s3 = boto3 . client ( [string] , region_name = AWS_REGION , aws_access_key_id = AWS_ACCESS_KEY_ID , aws_secret_access_key = AWS_SECRET_ACCESS_KEY , ) [EOL] with tempfile . NamedTemporaryFile ( [string] ) as local_file : [EOL] try : [EOL] s3 . download_fileobj ( bucket , key , local_file ) [EOL] except botocore . exceptions . ClientError as e : [EOL] if e . response [ [string] ] [ [string] ] == [string] : [EOL] logger . warning ( [string] ) [EOL] logger . warning ( [string] ) [EOL] return None , None [EOL] elif e . response [ [string] ] [ [string] ] == [string] : [EOL] logger . info ( [string] ) [EOL] logger . info ( [string] ) [EOL] return None , None [EOL] logger . error ( [string] ) [EOL] raise [EOL] return file_parser . parse_gzipped_file ( local_file . name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Match , Optional [EOL] import logging [EOL] import builtins [EOL] import lib [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] import re [EOL] import typing [EOL] [EOL] from lib . traceback . traceback import Traceback [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] def parse ( traceback ) : [EOL] [docstring] [EOL] log_lines = traceback . raw_full_text . splitlines ( ) [EOL] precursor_lines = __strip_traceback_text ( log_lines ) [EOL] if precursor_lines is None : return None [EOL] [EOL] [comment] [EOL] index = __find_first_error_line ( precursor_lines ) [EOL] if index is None : return None [EOL] [EOL] profile_name = None [EOL] username = None [EOL] if [string] in traceback . program_name : [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] match = re . search ( [string] , precursor_lines [ index ] ) [EOL] if not match : return None [EOL] potential_profile_name = match . groups ( ) [ [number] ] [EOL] [EOL] [comment] [EOL] if [string] in potential_profile_name : [EOL] username = profile_name [EOL] else : [EOL] [comment] [EOL] profile_name = potential_profile_name [EOL] elif [string] in traceback . program_name : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] match = re . search ( [string] , precursor_lines [ index ] ) [EOL] if not match : return None [EOL] profile_name = match . groups ( ) [ [number] ] [EOL] if [string] in traceback . program_name or [string] in traceback . program_name : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] match = re . search ( [string] , precursor_lines [ index ] ) [EOL] [EOL] if not match : [EOL] [comment] [EOL] [comment] [EOL] pid_match = re . search ( [string] , precursor_lines [ index ] ) [EOL] if not pid_match : return None [EOL] pid = pid_match . groups ( ) [ [number] ] [EOL] [EOL] [comment] [EOL] index2 = None [EOL] for index2 in range ( index - [number] , - [number] , - [number] ) : [EOL] if pid in precursor_lines [ index2 ] : [EOL] break [EOL] if index2 is None : return None [EOL] [EOL] [comment] [EOL] match = re . search ( [string] , precursor_lines [ index2 ] ) [EOL] [EOL] if not match : return None [EOL] profile_name = match . groups ( ) [ [number] ] [EOL] username = match . groups ( ) [ [number] ] [EOL] [EOL] if ( ( profile_name and username ) [EOL] and ( [string] in profile_name or [string] in username ) ) : [EOL] [comment] [EOL] try : [EOL] profile_name , username = re . match ( [string] , profile_name + [string] + username ) . groups ( ) [ : [number] ] [EOL] except Exception : [EOL] print ( [string] % ( profile_name , username ) ) [EOL] [EOL] [comment] [EOL] modified = False [EOL] if profile_name : [EOL] traceback . profile_name = profile_name [EOL] modified = True [EOL] if username : [EOL] traceback . username = username [EOL] modified = True [EOL] if not modified : [EOL] return None [EOL] return traceback [EOL] [EOL] [EOL] def __strip_traceback_text ( log_lines ) : [EOL] [docstring] [EOL] index = None [EOL] for index , line in enumerate ( reversed ( log_lines ) ) : [EOL] if [string] in line : [EOL] break [EOL] if index is None : [EOL] return None [EOL] return log_lines [ : - ( index + [number] ) ] [EOL] [EOL] [EOL] def __find_first_error_line ( log_lines ) : [EOL] [docstring] [EOL] [EOL] index = None [EOL] for index in range ( len ( log_lines ) - [number] , - [number] , - [number] ) : [EOL] if ( ( [string] in log_lines [ index ] ) or ( [string] in log_lines [ index ] ) ) : [EOL] break [EOL] else : [EOL] [comment] [EOL] return None [EOL] return index [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class LogLine ( ) : [EOL] [docstring] [EOL] def __init__ ( self , parsed_log_message , raw_log_message , timestamp , papertrail_id , origin_papertrail_id , line_number , instance_id , program_name , ) : [EOL] self . _parsed_log_message = parsed_log_message [EOL] self . _raw_log_message = raw_log_message [EOL] self . _timestamp = timestamp [EOL] self . _papertrail_id = papertrail_id [EOL] self . _origin_papertrail_id = origin_papertrail_id [EOL] self . _line_number = line_number [EOL] self . _instance_id = instance_id [EOL] self . _program_name = program_name [EOL] [EOL] def document ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _parsed_log_message , [string] : self . _raw_log_message , [string] : self . _timestamp , [string] : self . _papertrail_id , [string] : self . _origin_papertrail_id , [string] : self . _line_number , [string] : self . _instance_id , [string] : self . _program_name , } [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self . document ( ) ) [EOL] [EOL] @ property def parsed_log_message ( self ) : [EOL] return self . _parsed_log_message [EOL] [EOL] @ property def raw_log_message ( self ) : [EOL] return self . _raw_log_message [EOL] [EOL] @ property def timestamp ( self ) : [EOL] return self . _timestamp [EOL] [EOL] @ property def papertrail_id ( self ) : [EOL] return self . _papertrail_id [EOL] [EOL] @ property def origin_papertrail_id ( self ) : [EOL] return self . _origin_papertrail_id [EOL] [EOL] @ property def line_number ( self ) : [EOL] return self . _line_number [EOL] [EOL] @ property def instance_id ( self ) : [EOL] return self . _instance_id [EOL] [EOL] @ property def program_name ( self ) : [EOL] return self . _program_name [EOL] [EOL] def generate_logline_from_source ( source ) : [EOL] [docstring] [EOL] assert isinstance ( source , dict ) , source [EOL] [EOL] return LogLine ( source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict , Optional [EOL] import logging [EOL] import requests [EOL] import builtins [EOL] import lib [EOL] import typing [EOL] from typing import ( cast , Dict , Optional , Union , ) [EOL] import logging [EOL] [EOL] import requests [EOL] [EOL] from common_util import ( config_util , redis_util , ) [EOL] from lib . traceback . traceback import Traceback [EOL] [EOL] [EOL] REGION_PREFIX = [string] [EOL] DOGPILE_REGION = redis_util . make_dogpile_region ( REGION_PREFIX ) [EOL] def invalidate_cache ( ) : [EOL] redis_util . force_redis_cache_invalidation ( REGION_PREFIX ) [EOL] [EOL] __FULLSTORY_AUTH_TOKEN = config_util . get ( [string] ) [EOL] [EOL] __ONE_HOUR_IN_SECONDS = [number] * [number] [EOL] [EOL] __FULLSTORY_SESSIONS_GET_API = [string] [EOL] [docstring] [EOL] [EOL] __FULLSTORY_SESSIONS_LIMIT = [number] [EOL] [docstring] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] def get_link_to_session_at_traceback_time ( t ) : [EOL] [docstring] [EOL] if not t . profile_name : return None [EOL] [EOL] [comment] [EOL] epoch_timestamp_seconds = t . origin_timestamp . timestamp ( ) [EOL] most_recent_session = { } [EOL] for session in __get_sessions ( t . profile_name ) : [EOL] if session [ [string] ] < epoch_timestamp_seconds : [EOL] [comment] [EOL] if ( not most_recent_session or most_recent_session [ [string] ] < session [ [string] ] ) : [EOL] [comment] [EOL] most_recent_session = session [EOL] [EOL] if not most_recent_session : [EOL] logger . info ( [string] ) [EOL] return None [comment] [EOL] [EOL] session_start_time = cast ( int , most_recent_session [ [string] ] ) [EOL] if epoch_timestamp_seconds - session_start_time > __ONE_HOUR_IN_SECONDS : [EOL] logger . info ( [string] , most_recent_session [ [string] ] , epoch_timestamp_seconds ) [EOL] return None [EOL] [EOL] timestamp_in_millis = epoch_timestamp_seconds * [number] [comment] [EOL] link_to_session = [string] % ( most_recent_session [ [string] ] , timestamp_in_millis ) [EOL] return link_to_session [EOL] [EOL] @ DOGPILE_REGION . cache_on_arguments ( ) def __get_sessions ( profile_name ) : [EOL] [docstring] [EOL] url = __FULLSTORY_SESSIONS_GET_API . format ( profile_name = profile_name , limit = __FULLSTORY_SESSIONS_LIMIT ) [EOL] headers = { [string] : [string] % __FULLSTORY_AUTH_TOKEN } [EOL] try : [EOL] sessions = None [EOL] response = requests . get ( url , headers = headers ) [EOL] if [string] in response . text : [EOL] return [ ] [EOL] sessions = response . json ( ) [EOL] assert isinstance ( sessions , list ) , sessions [EOL] assert all ( isinstance ( s , dict ) for s in sessions ) , sessions [EOL] assert all ( [string] in s for s in sessions ) , sessions [EOL] except Exception : [EOL] logging . error ( [string] , url , response , sessions ) [EOL] raise [EOL] [EOL] logger . info ( [string] , len ( sessions ) , profile_name ) [EOL] return sessions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import logging [EOL] import json [EOL] [EOL] from lib . api_call . api_call_parser import ApiCallParser [EOL] from lib . traceback . parser import Parser [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] def parse_json_file ( filename ) : [EOL] [docstring] [EOL] with open ( filename , [string] , encoding = [string] ) as f : [EOL] tracebacks = list ( Parser . parse_stream ( yield_lines ( f ) ) ) [EOL] with open ( filename , [string] , encoding = [string] ) as f : [EOL] api_calls = list ( ApiCallParser . parse_stream ( yield_lines ( f ) ) ) [EOL] [EOL] return tracebacks , api_calls [EOL] [EOL] [EOL] def yield_lines ( f ) : [EOL] [docstring] [EOL] for line in f : [EOL] event = json . loads ( line ) [EOL] yield [string] . join ( [ str ( event [ [string] ] ) , event [ [string] ] , event [ [string] ] , str ( event [ [string] ] ) , event [ [string] ] , event [ [string] ] , event [ [string] ] , event [ [string] ] , event [ [string] ] , event [ [string] ] , ] ) + [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , IO [EOL] import logging [EOL] import subprocess [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import math [EOL] import subprocess [EOL] import tempfile [EOL] import time [EOL] [EOL] from common_util import ( time_util , ) [EOL] from lib . api_call import ( api_call_db , ) [EOL] from lib . common import ( cache_util , ) [EOL] from lib . papertrail import ( json_parser , ) [EOL] from lib . traceback import ( traceback_db , ) [EOL] import tasks [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] def enqueue ( end_time ) : [EOL] [docstring] [EOL] assert end_time is None or isinstance ( end_time , datetime . datetime ) , end_time [EOL] [EOL] start_time , end_time = __get_times ( end_time ) [EOL] logger . info ( [string] , start_time , end_time ) [EOL] tasks . realtime_update . apply_async ( ( start_time , end_time ) , expires = [number] ) [comment] [EOL] [EOL] [EOL] def run ( ES , start_time , end_time ) : [EOL] [docstring] [EOL] assert isinstance ( start_time , str ) , ( type ( start_time ) , start_time ) [EOL] assert isinstance ( end_time , str ) , ( type ( end_time ) , end_time ) [EOL] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] local_file = __call_papertrail_cli ( start_time , end_time ) [EOL] if local_file is not None : [EOL] break [EOL] time . sleep ( math . pow ( [number] , i ) ) [comment] [EOL] if local_file is None : [EOL] logger . warning ( [string] , start_time , end_time ) [EOL] return [EOL] [EOL] tracebacks , api_calls = json_parser . parse_json_file ( local_file . name ) [EOL] count = [number] [EOL] for tb in tracebacks : [EOL] count += [number] [EOL] traceback_db . save_traceback ( ES , tb ) [EOL] logger . info ( [string] , count ) [EOL] [EOL] if count > [number] : [EOL] logger . info ( [string] ) [EOL] cache_util . invalidate_cache ( [string] ) [EOL] [EOL] if api_calls : [EOL] logger . info ( [string] , len ( api_calls ) ) [EOL] api_call_db . save ( ES , api_calls ) [EOL] else : [EOL] logger . info ( [string] , start_time , end_time ) [EOL] [EOL] logger . info ( [string] , start_time , end_time ) [EOL] [EOL] [EOL] def __call_papertrail_cli ( start_time , end_time ) : [EOL] local_file = tempfile . NamedTemporaryFile ( [string] ) [EOL] res = subprocess . run ( [ [string] , [string] , str ( start_time ) , [string] , str ( end_time ) , [string] ] , stdout = local_file , stderr = subprocess . PIPE , encoding = [string] ) [EOL] [EOL] if res . stderr : [EOL] [comment] [EOL] try : [EOL] logger . info ( [string] , res . stderr . split ( [string] ) [ [number] ] ) [EOL] except Exception : [EOL] logger . error ( [string] , res . stderr ) [EOL] logger . debug ( [string] , res . stderr ) [EOL] return None [EOL] [EOL] return local_file [EOL] [EOL] [EOL] def __get_times ( end_time = None ) : [EOL] if end_time is None : [EOL] now = datetime . datetime . now ( ) [EOL] [comment] [EOL] end_time = time_util . round_time ( now - datetime . timedelta ( minutes = [number] ) ) [EOL] [EOL] [comment] [EOL] start_time = end_time - datetime . timedelta ( minutes = [number] ) [EOL] [EOL] [comment] [EOL] end_time = end_time - datetime . timedelta ( seconds = [number] ) [EOL] [EOL] return ( start_time , end_time ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import gzip [EOL] [EOL] from lib . api_call . api_call_parser import ApiCallParser [EOL] from lib . traceback . parser import Parser [EOL] [EOL] [EOL] def parse_gzipped_file ( zipped_filename ) : [EOL] [docstring] [EOL] with gzip . open ( zipped_filename , [string] , encoding = [string] ) as f : [EOL] tracebacks = list ( Parser . parse_stream ( f ) ) [EOL] [EOL] with gzip . open ( zipped_filename , [string] , encoding = [string] ) as f : [EOL] api_calls = list ( ApiCallParser . parse_stream ( f ) ) [EOL] [EOL] return tracebacks , api_calls [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import typing [EOL] [EOL] [EOL] class Traceback ( ) : [EOL] [docstring] [EOL] def __init__ ( self , traceback_text , traceback_plus_context_text , raw_traceback_text , raw_full_text , origin_papertrail_id , origin_timestamp , instance_id , program_name , profile_name = None , username = None , ) : [EOL] assert isinstance ( origin_timestamp , datetime . datetime ) , ( type ( origin_timestamp ) , origin_timestamp ) [EOL] [EOL] self . _traceback_text = traceback_text [EOL] self . _traceback_plus_context_text = traceback_plus_context_text [EOL] self . _raw_traceback_text = raw_traceback_text [EOL] self . _raw_full_text = raw_full_text [EOL] self . _origin_papertrail_id = origin_papertrail_id [EOL] self . _origin_timestamp = origin_timestamp [EOL] self . _instance_id = instance_id [EOL] self . _program_name = program_name [EOL] self . _profile_name = profile_name [EOL] self . _username = username [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self . document ( ) ) [EOL] [EOL] @ property def traceback_text ( self ) : [EOL] return self . _traceback_text [EOL] [EOL] @ property def traceback_plus_context_text ( self ) : [EOL] [comment] [EOL] if self . _traceback_plus_context_text is None : [EOL] return self . traceback_text [EOL] [EOL] return self . _traceback_plus_context_text [EOL] [EOL] @ property def raw_traceback_text ( self ) : [EOL] [comment] [EOL] if self . _raw_full_text is None : [EOL] return self . traceback_text [EOL] [EOL] return self . _raw_full_text [EOL] [EOL] @ property def raw_full_text ( self ) : [EOL] return self . _raw_full_text [EOL] [EOL] @ property def origin_papertrail_id ( self ) : [EOL] return self . _origin_papertrail_id [EOL] [EOL] @ property def origin_timestamp ( self ) : [EOL] return self . _origin_timestamp [EOL] [EOL] @ property def instance_id ( self ) : [EOL] return self . _instance_id [EOL] [EOL] @ property def program_name ( self ) : [EOL] return self . _program_name [EOL] [EOL] @ property def profile_name ( self ) : [EOL] return self . _profile_name [EOL] [EOL] @ profile_name . setter def profile_name ( self , name ) : [EOL] self . _profile_name = name [EOL] [EOL] @ property def username ( self ) : [EOL] return self . _username [EOL] [EOL] @ username . setter def username ( self , name ) : [EOL] self . _username = name [EOL] [EOL] def document ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _traceback_text , [string] : self . _traceback_plus_context_text , [string] : self . _raw_traceback_text , [string] : self . _raw_full_text , [string] : self . _origin_papertrail_id , [string] : self . _origin_timestamp . strftime ( [string] ) , [string] : self . _instance_id , [string] : self . _program_name , [string] : self . _profile_name , [string] : self . _username , } [EOL] [EOL] [EOL] def generate_traceback_from_source ( source ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] timestamp = datetime . datetime . strptime ( source [ [string] ] , [string] ) [EOL] except ValueError : [EOL] [comment] [EOL] timestamp = datetime . datetime . strptime ( source [ [string] ] , [string] ) [EOL] [EOL] return Traceback ( source [ [string] ] , source . get ( [string] , None ) , source . get ( [string] , None ) , source . get ( [string] , [string] ) , source [ [string] ] , timestamp , source [ [string] ] , source [ [string] ] , source . get ( [string] , None ) , source . get ( [string] , None ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Traceback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Iterator , Pattern [EOL] from collections import deque [EOL] import logging [EOL] import collections [EOL] import typing [EOL] [docstring] [EOL] import collections [EOL] import itertools [EOL] import logging [EOL] import re [EOL] [EOL] from common_util . parser_util import ParserUtil [EOL] from lib . logparse import ( profile_name_parser , logline , ) [EOL] from lib . traceback . traceback import Traceback [EOL] [EOL] [EOL] ERROR_REGEX = re . compile ( [string] ) [EOL] ASSERTION_ERROR_REGEX_NEGATIVE = re . compile ( [string] ) [EOL] KEY_ERROR_REGEX_NEGATIVE = re . compile ( [string] ) [EOL] VALUE_ERROR_REGEX_NEGATIVE = re . compile ( [string] ) [EOL] [docstring] [EOL] [EOL] TRACEBACK_TEXT_REGEX_NEGATIVE = re . compile ( [string] ) [EOL] [docstring] [EOL] [EOL] NUM_PREVIOUS_LOG_LINES_TO_SAVE = [number] [EOL] [docstring] [EOL] [EOL] MAX_TRACEBACK_TEXT_SIZE = [number] [EOL] [docstring] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] class Parser ( ) : [EOL] @ staticmethod def parse_stream ( file_object ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] lifo_buffer = collections . deque ( maxlen = [number] ) [EOL] for line in file_object : [EOL] assert len ( line ) > [number] , line [comment] [EOL] assert isinstance ( line , str ) , line [EOL] [EOL] [comment] [EOL] if Parser . log_line_contains_important_error ( line ) : [EOL] [comment] [EOL] origin_line = Parser . __generate_LogLine ( line , None , [number] ) [EOL] [EOL] [comment] [EOL] previous_log_lines = list ( itertools . islice ( Parser . __get_previous_log_lines ( lifo_buffer , origin_line ) , NUM_PREVIOUS_LOG_LINES_TO_SAVE ) ) [EOL] [EOL] traceback = Parser . __generate_Traceback ( origin_line , reversed ( previous_log_lines ) ) [EOL] if traceback is not None : [EOL] profile_name_parser . parse ( traceback ) [EOL] yield traceback [EOL] [EOL] [comment] [EOL] assert isinstance ( line , str ) , line [EOL] lifo_buffer . append ( line ) [EOL] [EOL] @ staticmethod def __generate_LogLine ( raw_log_line , origin_papertrail_id , line_number ) : [EOL] [docstring] [EOL] ( papertrail_id , timestamp , instance_id , program_name , parsed_log_message , formatted_line , ) = ParserUtil . parse_papertrail_log_line ( raw_log_line ) [EOL] [EOL] return logline . LogLine ( parsed_log_message , formatted_line , timestamp , papertrail_id , origin_papertrail_id if origin_papertrail_id is not None else papertrail_id , line_number , instance_id , program_name , ) [EOL] [EOL] @ staticmethod def __generate_Traceback ( origin_logline , previous_loglines ) : [EOL] [docstring] [EOL] log_lines = itertools . chain ( previous_loglines , [ origin_logline ] ) [EOL] log_lines1 , log_lines2 = itertools . tee ( log_lines ) [EOL] [EOL] raw_full_text = [string] . join ( logline . raw_log_message for logline in log_lines1 ) [EOL] raw_traceback_text = Parser . __get_last_traceback_text_raw ( raw_full_text ) [EOL] [EOL] parsed_text = [string] . join ( logline . parsed_log_message for logline in log_lines2 ) [EOL] traceback_text , traceback_plus_context_text = Parser . __get_last_traceback_text ( parsed_text ) [EOL] if traceback_text is None or traceback_plus_context_text is None : [EOL] logger . warning ( [string] , origin_logline . papertrail_id ) [EOL] return None [EOL] if len ( traceback_text ) > MAX_TRACEBACK_TEXT_SIZE : [EOL] logger . warning ( [string] , origin_logline . papertrail_id ) [EOL] return None [EOL] if re . search ( TRACEBACK_TEXT_REGEX_NEGATIVE , traceback_text ) is not None : [EOL] logger . warning ( [string] , origin_logline . papertrail_id ) [EOL] return None [EOL] [EOL] return Traceback ( traceback_text , traceback_plus_context_text , raw_traceback_text , raw_full_text , origin_logline . papertrail_id , origin_logline . timestamp , origin_logline . instance_id , origin_logline . program_name , ) [EOL] [EOL] @ staticmethod def __get_last_traceback_text ( parsed_log_text ) : [EOL] [docstring] [EOL] assert isinstance ( parsed_log_text , str ) , ( type ( parsed_log_text ) , parsed_log_text ) [EOL] [EOL] previous_text , sep , traceback_text = parsed_log_text . rpartition ( [string] ) [EOL] if not sep : [EOL] return ( None , None ) [EOL] context_lines = [string] . join ( previous_text . splitlines ( ) [ - [number] : ] ) [EOL] return sep + traceback_text , context_lines + [string] + sep + traceback_text [EOL] [EOL] @ staticmethod def __get_last_traceback_text_raw ( raw_log_text ) : [EOL] [docstring] [EOL] assert isinstance ( raw_log_text , str ) , ( type ( raw_log_text ) , raw_log_text ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] index = None [EOL] lines = raw_log_text . splitlines ( ) [EOL] for index , line in enumerate ( reversed ( lines ) ) : [EOL] if [string] in line : [EOL] break [EOL] if index is None : [EOL] return [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] return [string] . join ( lines [ - ( index + [number] ) : ] ) [EOL] [EOL] @ staticmethod def __get_previous_log_lines ( circular_buffer , origin_line ) : [EOL] [docstring] [EOL] line_number = [number] [EOL] for raw_line in list ( circular_buffer ) [ : : - [number] ] : [EOL] assert isinstance ( raw_line , str ) , raw_line [EOL] log_line = Parser . __generate_LogLine ( raw_line , origin_line . papertrail_id , line_number ) [EOL] if ( ( log_line . instance_id == origin_line . instance_id ) and ( log_line . program_name == origin_line . program_name ) ) : [EOL] [comment] [EOL] yield log_line [EOL] line_number += [number] [EOL] [EOL] @ staticmethod def log_line_contains_important_error ( log_line ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if re . search ( ERROR_REGEX , log_line ) is None : [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if [string] in log_line : [EOL] if re . search ( ASSERTION_ERROR_REGEX_NEGATIVE , log_line ) is not None : [EOL] return False [EOL] [EOL] if [string] in log_line : [EOL] if re . search ( KEY_ERROR_REGEX_NEGATIVE , log_line ) is not None : [EOL] return False [EOL] [EOL] if [string] in log_line : [EOL] if re . search ( VALUE_ERROR_REGEX_NEGATIVE , log_line ) is not None : [EOL] return False [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.deque[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $collections.deque[typing.Any]$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.deque[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import logging [EOL] import builtins [EOL] import lib [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import elasticsearch [EOL] [EOL] from opentracing_instrumentation . request_context import get_current_span [EOL] [EOL] from common_util import ( es_util , redis_util , retry , ) [EOL] from lib . traceback . traceback import Traceback , generate_traceback_from_source [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] DOGPILE_REGION_PREFIX = [string] [EOL] DOGPILE_REGION = redis_util . make_dogpile_region ( DOGPILE_REGION_PREFIX ) [EOL] def invalidate_cache ( ) : [EOL] redis_util . force_redis_cache_invalidation ( DOGPILE_REGION_PREFIX ) [EOL] [EOL] [EOL] INDEX = [string] [EOL] DOC_TYPE = [string] [EOL] [EOL] [EOL] @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , ) ) def save_traceback ( es , traceback ) : [EOL] [docstring] [EOL] assert isinstance ( traceback , Traceback ) , ( type ( traceback ) , traceback ) [EOL] doc = traceback . document ( ) [EOL] res = es . index ( index = INDEX , doc_type = DOC_TYPE , id = traceback . origin_papertrail_id , body = doc ) [EOL] invalidate_cache ( ) [EOL] return res [EOL] [EOL] [EOL] @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , ) ) def refresh ( es ) : [EOL] [docstring] [EOL] es . indices . refresh ( index = INDEX ) [EOL] [EOL] [EOL] @ DOGPILE_REGION . cache_on_arguments ( ) @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , ) ) def get_tracebacks ( es , tracer , start_date = None , end_date = None , num_matches = [number] ) : [EOL] [docstring] [EOL] params_list = { } [EOL] if start_date is not None : [EOL] params_list [ [string] ] = [string] % start_date [EOL] if end_date is not None : [EOL] params_list [ [string] ] = [string] % end_date [EOL] [EOL] if params_list : [EOL] body = { [string] : { [string] : { [string] : params_list } } } [EOL] else : [EOL] body = { [string] : { [string] : { } } } [EOL] [EOL] root_span = get_current_span ( ) [EOL] with tracer . start_span ( [string] , child_of = root_span ) : [EOL] try : [EOL] raw_tracebacks = es . search ( index = INDEX , doc_type = DOC_TYPE , body = body , sort = [string] , size = num_matches ) [EOL] except elasticsearch . exceptions . NotFoundError : [EOL] logger . warning ( [string] ) [EOL] return [ ] [EOL] res = [ ] [EOL] for raw_traceback in raw_tracebacks [ [string] ] [ [string] ] : [EOL] res . append ( generate_traceback_from_source ( raw_traceback [ [string] ] ) ) [EOL] return res [EOL] [EOL] [EOL] @ DOGPILE_REGION . cache_on_arguments ( ) @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , ) ) def get_matching_tracebacks ( es , tracer , traceback_text , match_level , num_matches ) : [EOL] [docstring] [EOL] assert match_level in es_util . ALL_MATCH_LEVELS , ( match_level , es_util . ALL_MATCH_LEVELS ) [EOL] [EOL] body = es_util . generate_text_match_payload ( traceback_text , [ [string] ] , match_level ) [EOL] [EOL] root_span = get_current_span ( ) [EOL] with tracer . start_span ( [string] , child_of = root_span ) : [EOL] raw_es_response = es . search ( index = INDEX , doc_type = DOC_TYPE , body = body , sort = [string] , size = num_matches ) [EOL] res = [ ] [EOL] for raw_traceback in raw_es_response [ [string] ] [ [string] ] : [EOL] res . append ( generate_traceback_from_source ( raw_traceback [ [string] ] ) ) [EOL] return res [EOL] [EOL] [EOL] def get_traceback ( es , id_ ) : [EOL] [docstring] [EOL] raw_es_response = es . get ( index = INDEX , doc_type = DOC_TYPE , id = id_ ) [EOL] return generate_traceback_from_source ( raw_es_response [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.traceback.traceback.Traceback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Callable , List , Any , Optional [EOL] import logging [EOL] import builtins [EOL] import lib [EOL] import typing [EOL] from typing import Optional , Callable , Set [EOL] import logging [EOL] [EOL] from common_util import ( config_util , ) [EOL] from lib . fullstory import fullstory [EOL] from lib . traceback . traceback import Traceback [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] KIBANA_REDIRECT_URL = config_util . get ( [string] ) [EOL] PRODUCT_URL = config_util . get ( [string] ) [EOL] [EOL] TIMESTAMP_TEMPLATE = [string] [EOL] [docstring] [EOL] [EOL] PAPERTRAIL_LINK_JIRA_TEMPLATE = [string] [EOL] PAPERTRAIL_LINK_SLACK_TEMPLATE = [string] [EOL] [docstring] [EOL] [EOL] FULLSTORY_LINK_JIRA_TEMPLATE = [string] [EOL] FULLSTORY_LINK_SLACK_TEMPLATE = [string] [EOL] [docstring] [EOL] [EOL] PROFILE_NAME_JIRA_TEMPLATE = [string] [EOL] PROFILE_NAME_SLACK_TEMPLATE = [string] [EOL] [docstring] [EOL] [EOL] USERNAME_JIRA_TEMPLATE = [string] [EOL] USERNAME_SLACK_TEMPLATE = [string] [EOL] [docstring] [EOL] [EOL] [EOL] def jira_formatted_string ( t , include_profile_link , include_user_link ) : [EOL] [docstring] [EOL] [comment] [EOL] timestamp_str = PAPERTRAIL_LINK_JIRA_TEMPLATE . format ( timestamp = t . origin_timestamp . strftime ( TIMESTAMP_TEMPLATE ) , kibana_redirect_url = KIBANA_REDIRECT_URL , papertrail_id = t . origin_papertrail_id ) [EOL] [EOL] [comment] [EOL] profile_str = None [EOL] if t . profile_name : [EOL] if include_profile_link : [EOL] profile_str = PROFILE_NAME_JIRA_TEMPLATE . format ( profile_name = t . profile_name , product_url = PRODUCT_URL , ) [EOL] else : [EOL] profile_str = t . profile_name [EOL] user_str = None [EOL] if t . username : [EOL] if include_user_link : [EOL] user_str = USERNAME_JIRA_TEMPLATE . format ( username = t . username , product_url = PRODUCT_URL , ) [EOL] else : [EOL] user_str = t . username [EOL] [EOL] [comment] [EOL] fullstory_link = fullstory . get_link_to_session_at_traceback_time ( t ) [EOL] fullstory_str = None [EOL] if fullstory_link : [EOL] fullstory_str = FULLSTORY_LINK_JIRA_TEMPLATE . format ( fullstory_link = fullstory_link , ) [EOL] [EOL] [comment] [EOL] combined_str = [string] . join ( s for s in ( timestamp_str , profile_str , user_str , fullstory_str , ) if s is not None ) [EOL] return [string] % combined_str [EOL] [EOL] [EOL] [EOL] def slack_formatted_string ( t , include_profile_link , include_user_link ) : [EOL] [docstring] [EOL] [comment] [EOL] timestamp_str = PAPERTRAIL_LINK_SLACK_TEMPLATE . format ( timestamp = t . origin_timestamp . strftime ( TIMESTAMP_TEMPLATE ) , kibana_redirect_url = KIBANA_REDIRECT_URL , papertrail_id = t . origin_papertrail_id ) [EOL] [EOL] [comment] [EOL] profile_str = None [EOL] if t . profile_name : [EOL] if include_profile_link : [EOL] profile_str = PROFILE_NAME_SLACK_TEMPLATE . format ( profile_name = t . profile_name , product_url = PRODUCT_URL ) [EOL] else : [EOL] profile_str = t . profile_name [EOL] user_str = None [EOL] if t . username : [EOL] if include_user_link : [EOL] user_str = USERNAME_SLACK_TEMPLATE . format ( username = t . username , product_url = PRODUCT_URL ) [EOL] else : [EOL] user_str = t . username [EOL] [EOL] [comment] [EOL] fullstory_link = fullstory . get_link_to_session_at_traceback_time ( t ) [EOL] fullstory_str = None [EOL] if fullstory_link : [EOL] fullstory_str = FULLSTORY_LINK_SLACK_TEMPLATE . format ( fullstory_link = fullstory_link , ) [EOL] [EOL] [comment] [EOL] combined_str = [string] . join ( s for s in ( timestamp_str , profile_str , user_str , fullstory_str , ) if s is not None ) [EOL] return [string] % combined_str [EOL] [EOL] [EOL] def create_hits_list ( tracebacks , formatter , max_number_hits = None ) : [EOL] [docstring] [EOL] seen_profile_names = set ( ) [EOL] seen_usernames = set ( ) [EOL] hits_list = [ ] [EOL] for t in tracebacks : [EOL] [comment] [EOL] if t . profile_name and t . profile_name not in seen_profile_names : [EOL] include_profile_link = True [EOL] if t . profile_name . isdigit ( ) : [EOL] [comment] [EOL] include_profile_link = False [EOL] seen_profile_names . add ( t . profile_name ) [EOL] else : [EOL] include_profile_link = False [EOL] if t . username and t . username not in seen_usernames : [EOL] include_username_link = True [EOL] seen_usernames . add ( t . username ) [EOL] else : [EOL] include_username_link = False [EOL] [EOL] [comment] [EOL] if t . username and t . username . startswith ( [string] ) : [EOL] include_username_link = False [EOL] [EOL] hits_list . append ( formatter ( t , include_profile_link , include_username_link ) ) [EOL] [EOL] [comment] [EOL] index = len ( hits_list ) [EOL] if max_number_hits : [EOL] index = min ( index , max_number_hits ) [EOL] comment_string = [string] [EOL] for index in range ( index , [number] , - [number] ) : [EOL] comment_string = [string] . join ( hits_list [ : index ] ) [EOL] if len ( comment_string ) < [number] : [EOL] break [EOL] [EOL] logger . info ( [string] , len ( tracebacks ) , len ( hits_list ) , index , len ( comment_string ) ) [EOL] [EOL] return comment_string [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import unittest [EOL] [EOL] from lib . traceback . parser import Parser [EOL] [EOL] [EOL] LOG_LINES_THAT_SHOULD_MATCH = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] LOG_LINES_THAT_SHOULD_NOT_MATCH = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] class TestAssertionRegex ( unittest . TestCase ) : [EOL] def test_lines_that_should_match ( self ) : [EOL] [docstring] [EOL] for line in LOG_LINES_THAT_SHOULD_MATCH : [EOL] self . assertTrue ( Parser . log_line_contains_important_error ( line ) , line ) [EOL] [EOL] def test_lines_that_should_not_match ( self ) : [EOL] [docstring] [EOL] for line in LOG_LINES_THAT_SHOULD_NOT_MATCH : [EOL] self . assertFalse ( Parser . log_line_contains_important_error ( line ) , line ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , List , Dict [EOL] import logging [EOL] import builtins [EOL] import lib [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import ( List , ) [EOL] import logging [EOL] [EOL] import elasticsearch [EOL] [EOL] from opentracing_instrumentation . request_context import get_current_span [EOL] import opentracing [EOL] [EOL] from lib . jira . jira_issue import JiraIssue , generate_from_source [EOL] from common_util import ( es_util , redis_util , retry , ) [EOL] [EOL] [EOL] DOGPILE_REGION_PREFIX = [string] [EOL] DOGPILE_REGION = redis_util . make_dogpile_region ( DOGPILE_REGION_PREFIX ) [EOL] def invalidate_cache ( ) : [EOL] redis_util . force_redis_cache_invalidation ( DOGPILE_REGION_PREFIX ) [EOL] [EOL] [EOL] INDEX = [string] [EOL] DOC_TYPE = [string] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , ) ) def save_jira_issue ( es , jira_issue ) : [EOL] [docstring] [EOL] assert isinstance ( jira_issue , JiraIssue ) , ( type ( jira_issue ) , jira_issue ) [EOL] [EOL] doc = jira_issue . document ( ) [EOL] res = es . index ( index = INDEX , doc_type = DOC_TYPE , id = jira_issue . key , body = doc ) [EOL] invalidate_cache ( ) [EOL] return res [EOL] [EOL] [EOL] @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , ) ) def remove_jira_issue ( es , issue_key ) : [EOL] [docstring] [EOL] try : [EOL] es . delete ( index = INDEX , doc_type = DOC_TYPE , id = issue_key ) [EOL] except elasticsearch . exceptions . NotFoundError : [EOL] return [comment] [EOL] else : [EOL] invalidate_cache ( ) [EOL] [EOL] [EOL] @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , ) ) def refresh ( es ) : [EOL] [docstring] [EOL] es . indices . refresh ( index = INDEX ) [EOL] [EOL] [EOL] @ DOGPILE_REGION . cache_on_arguments ( ) @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , ) ) def get_matching_jira_issues ( es , tracer , traceback_text , match_level ) : [EOL] [docstring] [EOL] assert isinstance ( traceback_text , str ) , ( type ( traceback_text ) , traceback_text ) [EOL] assert match_level in es_util . ALL_MATCH_LEVELS , ( match_level , es_util . ALL_MATCH_LEVELS ) [EOL] [EOL] tracer = tracer or opentracing . tracer [EOL] [EOL] body = es_util . generate_text_match_payload ( traceback_text , [ [string] , [string] ] , match_level ) [EOL] [EOL] root_span = get_current_span ( ) [EOL] with tracer . start_span ( [string] , child_of = root_span ) : [EOL] try : [EOL] raw_es_response = es . search ( index = INDEX , doc_type = DOC_TYPE , body = body , size = [number] ) [EOL] except elasticsearch . exceptions . NotFoundError : [EOL] logger . warning ( [string] ) [EOL] return [ ] [EOL] res = [ ] [EOL] for raw_jira_issue in raw_es_response [ [string] ] [ [string] ] : [EOL] res . append ( generate_from_source ( raw_jira_issue [ [string] ] ) ) [EOL] return res [EOL] [EOL] [EOL] def search_jira_issues ( es , search_phrase , max_count ) : [EOL] [docstring] [EOL] body = { [string] : { [string] : { [string] : search_phrase , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [string] , } } } [EOL] raw_es_response = es . search ( index = INDEX , doc_type = DOC_TYPE , body = body , size = max_count ) [EOL] res = [ ] [EOL] for raw_jira_issue in raw_es_response [ [string] ] [ [string] ] : [EOL] res . append ( generate_from_source ( raw_jira_issue [ [string] ] ) ) [EOL] return res [EOL] [EOL] [EOL] @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , ) ) def get_num_jira_issues ( es ) : [EOL] [docstring] [EOL] try : [EOL] return es . count ( index = INDEX , doc_type = DOC_TYPE , body = { } , ) [ [string] ] [EOL] except elasticsearch . exceptions . NotFoundError : [EOL] logger . warning ( [string] ) [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[lib.jira.jira_issue.JiraIssue]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import datetime [EOL] import typing [EOL] from typing import List [EOL] import datetime [EOL] [EOL] [EOL] class JiraIssue ( ) : [EOL] [docstring] [EOL] def __init__ ( self , key , url , summary , description , description_filtered , comments , comments_filtered , issue_type , assignee , status , created , updated , labels , ) : [EOL] self . _key = key [EOL] self . _url = url [EOL] self . _summary = summary [EOL] self . _description = description [EOL] self . _description_filtered = description_filtered [EOL] self . _comments = comments [EOL] self . _comments_filtered = comments_filtered [EOL] self . _issue_type = issue_type [EOL] self . _assignee = assignee [EOL] self . _status = status [EOL] self . _created = created [EOL] self . _updated = updated [EOL] self . _labels = labels [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self . document ( ) ) [EOL] [EOL] @ property def key ( self ) : [EOL] return self . _key [EOL] [EOL] @ property def url ( self ) : [EOL] return self . _url [EOL] [EOL] @ property def summary ( self ) : [EOL] return self . _summary [EOL] [EOL] @ property def description ( self ) : [EOL] return self . _description [EOL] [EOL] @ property def description_filtered ( self ) : [EOL] return self . _description_filtered [EOL] [EOL] @ property def comments ( self ) : [EOL] return self . _comments [EOL] [EOL] @ property def comments_filtered ( self ) : [EOL] return self . _comments_filtered [EOL] [EOL] @ property def issue_type ( self ) : [EOL] return self . _issue_type [EOL] [EOL] @ property def assignee ( self ) : [EOL] return self . _assignee [EOL] [EOL] @ property def status ( self ) : [EOL] return self . _status [EOL] [EOL] @ property def created ( self ) : [EOL] return self . _created [EOL] [EOL] @ property def updated ( self ) : [EOL] return self . _updated [EOL] [EOL] @ property def labels ( self ) : [EOL] return self . _labels [EOL] [EOL] def document ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _key , [string] : self . _url , [string] : self . _summary , [string] : self . _description , [string] : self . _description_filtered , [string] : self . _comments , [string] : self . _comments_filtered , [string] : self . _issue_type , [string] : self . _assignee , [string] : self . _status , [string] : self . _created , [string] : self . _updated , [string] : self . _labels , } [EOL] [EOL] [EOL] def generate_from_source ( source ) : [EOL] [docstring] [EOL] [EOL] created = datetime . datetime . strptime ( source [ [string] ] , [string] ) [EOL] updated = datetime . datetime . strptime ( source [ [string] ] , [string] ) [EOL] [EOL] return JiraIssue ( source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] if [string] in source else [string] , source [ [string] ] , created , updated , source [ [string] ] if [string] in source else [ ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $JiraIssue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from common_util import ( elasticsearch_config , ) [EOL] from lib . jira import ( jira_issue_db , ) [EOL] [EOL] ES = elasticsearch_config . get_db ( ) [EOL] [EOL] [EOL] def test_refresh ( ) : [EOL] jira_issue_db . refresh ( ES ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , Union , List , Dict [EOL] import logging [EOL] import requests [EOL] import builtins [EOL] import lib [EOL] import typing [EOL] from typing import List [EOL] import logging [EOL] import json [EOL] [EOL] import requests [EOL] [EOL] from common_util import ( config_util , ) [EOL] from lib . jira import ( jira_issue_aservice , ) [EOL] from lib . jira . jira_issue import JiraIssue [EOL] from lib . slack import slack_channel [EOL] from lib . traceback import ( traceback_formatter , ) [EOL] from lib . traceback . traceback import Traceback [EOL] [EOL] [EOL] SLACK_REAL_USER_TOKEN = config_util . get ( [string] ) [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] MESSAGE_TEMPLATE = [string] [EOL] [EOL] JIRA_ISSUE_TEMPLATE = [string] [EOL] [docstring] [EOL] [EOL] NUM_LINES_TO_POST = [number] [EOL] [docstring] [EOL] [EOL] MAX_CHARS_PER_LINE = [number] [EOL] [docstring] [EOL] [EOL] [EOL] def post_traceback ( traceback , similar_tracebacks , jira_issues ) : [EOL] last_N_lines = [string] . join ( text [ : MAX_CHARS_PER_LINE ] for text in traceback . traceback_plus_context_text . splitlines ( ) [ - NUM_LINES_TO_POST : ] ) [EOL] traceback_text = MESSAGE_TEMPLATE . format ( traceback_text = last_N_lines ) [EOL] hits = traceback_formatter . create_hits_list ( similar_tracebacks , traceback_formatter . slack_formatted_string , max_number_hits = [number] ) [EOL] jira_issue_text = [string] . join ( JIRA_ISSUE_TEMPLATE . format ( issue_link = jira_issue_aservice . get_link_to_issue ( issue . key ) , issue_key = issue . key , issue_status = issue . status . upper ( ) , issue_assignee = issue . assignee if issue . assignee else [string] , issue_summary = issue . summary , ) for issue in jira_issues ) [EOL] [EOL] slack_data = { [string] : traceback_text , [string] : [ { [string] : MESSAGE_TEMPLATE . format ( traceback_text = traceback . traceback_plus_context_text ) , } , { [string] : hits , [string] : True , } , { [string] : jira_issue_text , [string] : True , } , { [string] : [string] % traceback . origin_papertrail_id , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } ] } , ] , [string] : True , } ] } [EOL] [EOL] webhook_url = slack_channel . get_webhook_url ( traceback ) [EOL] return __send_message_to_slack ( slack_data , webhook_url ) [EOL] [EOL] [EOL] def __send_message_to_slack ( slack_data , webhook_url ) : [EOL] logger . debug ( [string] , json . dumps ( slack_data ) ) [EOL] [EOL] response = requests . post ( webhook_url , data = json . dumps ( slack_data ) , headers = { [string] : [string] } ) [EOL] if response . status_code != [number] : [EOL] logger . error ( [string] , response . status_code , response . text ) [EOL] [EOL] return response [EOL] [EOL] [EOL] def post_message_to_slack_as_real_user ( channel , message ) : [EOL] [docstring] [EOL] assert SLACK_REAL_USER_TOKEN [EOL] [EOL] url = [string] [EOL] params = { [string] : SLACK_REAL_USER_TOKEN , [string] : channel , [string] : True , [string] : message , } [EOL] response = requests . post ( url , params = params , ) [EOL] if response . status_code == [number] : [EOL] logger . info ( [string] , channel ) [EOL] else : [EOL] logger . error ( [string] , response . status_code , response . text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import lib [EOL] import typing [EOL] from lib . traceback . traceback import Traceback [EOL] from common_util import ( config_util , ) [EOL] [EOL] [EOL] TRACEBACKS_CHANNEL_NAME = [string] [EOL] TRACEBACKS_CHANNEL_NAME_ADWORDS = [string] [EOL] TRACEBACKS_CHANNEL_NAME_SOCIAL = [string] [EOL] SLACK_WEBHOOK_TRACEBACKS = config_util . get ( [string] ) [EOL] SLACK_WEBHOOK_TRACEBACKS_ADWORDS = config_util . get ( [string] ) [EOL] SLACK_WEBHOOK_TRACEBACKS_SOCIAL = config_util . get ( [string] ) [EOL] [EOL] [EOL] def get_webhook_url ( traceback ) : [EOL] [docstring] [EOL] channel_name = get_channel_name ( traceback ) [EOL] if channel_name == TRACEBACKS_CHANNEL_NAME : [EOL] return SLACK_WEBHOOK_TRACEBACKS [EOL] elif channel_name == TRACEBACKS_CHANNEL_NAME_ADWORDS : [EOL] return SLACK_WEBHOOK_TRACEBACKS_ADWORDS [EOL] elif channel_name == TRACEBACKS_CHANNEL_NAME_SOCIAL : [EOL] return SLACK_WEBHOOK_TRACEBACKS_SOCIAL [EOL] else : [EOL] assert False , [string] % channel_name [EOL] return None [EOL] [EOL] [EOL] def get_channel_name ( traceback ) : [EOL] [docstring] [EOL] if [string] in traceback . traceback_text . lower ( ) : [EOL] return TRACEBACKS_CHANNEL_NAME_SOCIAL [EOL] elif [string] in traceback . traceback_text . lower ( ) : [EOL] return TRACEBACKS_CHANNEL_NAME_ADWORDS [EOL] else : [EOL] return TRACEBACKS_CHANNEL_NAME [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0
import logging [EOL] [docstring] [EOL] import collections [EOL] import logging [EOL] [EOL] import elasticsearch [EOL] import elasticsearch . helpers [EOL] [EOL] from common_util import retry [EOL] [EOL] [EOL] INDEX_TEMPLATE = [string] [EOL] [docstring] [EOL] DOC_TYPE = [string] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] @ retry . Retry ( exceptions = ( elasticsearch . exceptions . ConnectionTimeout , elasticsearch . ElasticsearchException ) ) def save ( es , api_calls ) : [EOL] [docstring] [EOL] assert isinstance ( api_calls , collections . Iterable ) , ( type ( api_calls ) , api_calls ) [EOL] elasticsearch . helpers . bulk ( es , _create_documents ( api_calls ) ) [EOL] return True [EOL] [EOL] [EOL] def _create_documents ( api_calls ) : [EOL] for api_call in api_calls : [EOL] index_name = INDEX_TEMPLATE % ( api_call . timestamp . year , api_call . timestamp . month ) [EOL] yield { [string] : index_name , [string] : DOC_TYPE , [string] : api_call . papertrail_id , [string] : api_call . document ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Match , Optional , Pattern [EOL] import logging [EOL] import typing [EOL] import logging [EOL] import re [EOL] [EOL] from lib . api_call . api_call import ApiCall [EOL] from common_util . parser_util import ParserUtil [EOL] [EOL] [EOL] API_CALL_REGEX = re . compile ( ( [string] [string] [string] [string] ) ) [EOL] [docstring] [EOL] [EOL] SERVERS_WE_CARE_ABOUT = frozenset ( ( [string] , [string] , ) ) [EOL] [docstring] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] [EOL] [EOL] class ApiCallParser ( ) : [EOL] @ staticmethod def parse_stream ( file_object ) : [EOL] [docstring] [EOL] for log_line in file_object : [EOL] assert len ( log_line ) > [number] , log_line [comment] [EOL] assert isinstance ( log_line , str ) , log_line [EOL] [EOL] if ApiCallParser . __log_line_contains_api_call_with_timing ( log_line ) : [EOL] api_call = ApiCallParser . __generate_ApiCall ( log_line ) [EOL] if api_call is not None : [EOL] yield api_call [EOL] [EOL] @ staticmethod def __log_line_contains_api_call_with_timing ( log_line ) : [EOL] [docstring] [EOL] if [string] not in log_line : [EOL] [comment] [EOL] return False [EOL] if [string] in log_line : [EOL] [comment] [EOL] return False [EOL] if not any ( server in log_line for server in SERVERS_WE_CARE_ABOUT ) : [EOL] [comment] [EOL] return False [EOL] return True [EOL] [EOL] @ staticmethod def __generate_ApiCall ( log_line ) : [EOL] [docstring] [EOL] ( papertrail_id , timestamp , instance_id , program_name , parsed_log_message , _ , ) = ParserUtil . parse_papertrail_log_line ( log_line ) [EOL] [EOL] match = re . search ( API_CALL_REGEX , parsed_log_message ) [EOL] if not match : [EOL] logger . debug ( [string] , log_line ) [EOL] return None [EOL] [EOL] duration = int ( match . group ( [string] ) ) [EOL] [EOL] [comment] [EOL] memory_final = None [EOL] memory_delta = None [EOL] memory_final_str = match . group ( [string] ) [EOL] memory_delta_str = match . group ( [string] ) [EOL] if memory_final_str : [EOL] memory_final = int ( memory_final_str ) [EOL] if memory_delta_str : [EOL] memory_delta = int ( memory_delta_str ) [EOL] [EOL] return ApiCall ( timestamp , papertrail_id , instance_id , program_name , match . group ( [string] ) , match . group ( [string] ) if match . group ( [string] ) else None , match . group ( [string] ) , match . group ( [string] ) , duration , memory_final , memory_delta , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 $typing.Optional[typing.Match[typing.Any]]$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0
import builtins [EOL] from typing import Any , List , Optional [EOL] import typing [EOL] import collections [EOL] import datetime [EOL] import unittest [EOL] [EOL] from lib . api_call . api_call import ApiCall [EOL] from lib . api_call . api_call_parser import ApiCallParser [EOL] [EOL] [EOL] MATCHING_LOG_LINES = frozenset ( ( [string] , [string] , [string] , [string] , [string] , [string] , ) ) [EOL] [EOL] NON_MATCHING_LOG_LINES = frozenset ( ( [string] , [string] , [string] , [string] , [string] , ) ) [EOL] [EOL] [comment] [EOL] DUMMY_API_CALL = [string] [EOL] EXPECTED_ENTTIY_FROM_DUMMY_API_CALL = ApiCall ( datetime . datetime . strptime ( [string] , [string] ) , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [number] , [number] , [number] , ) [EOL] [EOL] [EOL] class TestApiCallParser ( unittest . TestCase ) : [EOL] def test_that_we_get_expected_api_calls ( self ) : [EOL] [docstring] [EOL] api_calls = ApiCallParser . parse_stream ( MATCHING_LOG_LINES ) [EOL] self . assertIsInstance ( api_calls , collections . Iterable ) [EOL] api_calls = list ( api_calls ) [comment] [EOL] self . assertEqual ( len ( api_calls ) , len ( MATCHING_LOG_LINES ) ) [EOL] for entity in api_calls : [EOL] self . assertIsInstance ( entity , ApiCall ) [EOL] [EOL] def test_that_we_do_not_see_unexpected_api_calls ( self ) : [EOL] [docstring] [EOL] api_calls = ApiCallParser . parse_stream ( NON_MATCHING_LOG_LINES ) [EOL] self . assertIsInstance ( api_calls , collections . Iterable ) [EOL] api_calls = list ( api_calls ) [comment] [EOL] self . assertEqual ( len ( api_calls ) , [number] ) [EOL] [EOL] def test_dummy_api_call ( self ) : [EOL] [docstring] [EOL] api_calls = ApiCallParser . parse_stream ( ( DUMMY_API_CALL , ) ) [EOL] self . assertIsInstance ( api_calls , collections . Iterable ) [EOL] api_calls = list ( api_calls ) [comment] [EOL] self . assertEqual ( len ( api_calls ) , [number] ) [EOL] self . maxDiff = None [EOL] self . assertDictEqual ( api_calls [ [number] ] . document ( ) , EXPECTED_ENTTIY_FROM_DUMMY_API_CALL . document ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] [EOL] [EOL] class ApiCall ( ) : [EOL] [docstring] [EOL] def __init__ ( self , timestamp , papertrail_id , instance_id , program_name , api_name , profile_name , username , method , duration , memory_final , memory_delta , ) : [EOL] self . _timestamp = timestamp [EOL] self . _papertrail_id = papertrail_id [EOL] self . _instance_id = instance_id [EOL] self . _program_name = program_name [EOL] self . _api_name = api_name [EOL] self . _profile_name = profile_name [EOL] self . _username = username [EOL] self . _method = method [EOL] self . _duration = duration [EOL] self . _memory_final = memory_final [EOL] self . _memory_delta = memory_delta [EOL] [EOL] def document ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _timestamp . strftime ( [string] ) , [string] : self . _papertrail_id , [string] : self . _instance_id , [string] : self . _program_name , [string] : self . _api_name , [string] : self . _profile_name , [string] : self . _username , [string] : self . _method , [string] : self . _duration , [string] : self . _memory_final , [string] : self . _memory_delta , } [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . __class__ , self . document ( ) ) [EOL] [EOL] @ staticmethod def generate_from_source ( source ) : [EOL] [docstring] [EOL] assert isinstance ( source , dict ) , source [EOL] [EOL] [comment] [EOL] timestamp = datetime . datetime . strptime ( source [ [string] ] , [string] ) [EOL] [EOL] [comment] [EOL] memory_final = source . get ( [string] ) [EOL] memory_delta = source . get ( [string] ) [EOL] [EOL] return ApiCall ( timestamp , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , source [ [string] ] , memory_final , memory_delta , ) [EOL] [EOL] @ property def timestamp ( self ) : [EOL] return self . _timestamp [EOL] [EOL] @ property def papertrail_id ( self ) : [EOL] return self . _papertrail_id [EOL] [EOL] @ property def instance_id ( self ) : [EOL] return self . _instance_id [EOL] [EOL] @ property def program_name ( self ) : [EOL] return self . _program_name [EOL] [EOL] @ property def api_name ( self ) : [EOL] return self . _api_name [EOL] [EOL] @ property def profile_name ( self ) : [EOL] [comment] [EOL] return self . _profile_name [EOL] [EOL] @ property def username ( self ) : [EOL] return self . _username [EOL] [EOL] @ property def method ( self ) : [EOL] return self . _method [EOL] [EOL] @ property def duration ( self ) : [EOL] return self . _duration [EOL] [EOL] @ property def memory_final ( self ) : [EOL] [comment] [EOL] return self . _memory_final [EOL] [EOL] @ property def memory_delta ( self ) : [EOL] [comment] [EOL] return self . _memory_delta [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0