[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class MonkeyTypeError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class NameLookupError ( MonkeyTypeError ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidTypeError ( MonkeyTypeError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typeline . cli import entry_point_main [EOL] [EOL] entry_point_main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Optional , List , Iterator , Tuple [EOL] import pathlib [EOL] import typeline [EOL] import typing [EOL] import types [EOL] import builtins [EOL] from contextlib import contextmanager [EOL] import functools [EOL] import os [EOL] import pathlib [EOL] import sys [EOL] import sysconfig [EOL] [EOL] from abc import ( ABCMeta , abstractmethod , ) [EOL] from types import CodeType [EOL] from typing import Optional , Iterator [EOL] [EOL] from typeline . db . base import ( CallTraceStore , CallTraceStoreLogger , ) [EOL] from typeline . db . sqlite import SQLiteStore [EOL] from typeline . tracing import ( CallTraceLogger , CodeFilter , ) [EOL] from typeline . typing import ( DEFAULT_REWRITER , NoOpRewriter , TypeRewriter , ) [EOL] [EOL] [EOL] class Config ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] @ abstractmethod def trace_store ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ contextmanager def cli_context ( self , command ) : [EOL] [docstring] [EOL] yield [EOL] [EOL] def trace_logger ( self ) : [EOL] [docstring] [EOL] return CallTraceStoreLogger ( self . trace_store ( ) ) [EOL] [EOL] def code_filter ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def sample_rate ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def type_rewriter ( self ) : [EOL] [docstring] [EOL] return NoOpRewriter ( ) [EOL] [EOL] def query_limit ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] def include_unparsable_defaults ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] [EOL] lib_paths = { sysconfig . get_path ( n ) for n in [ [string] , [string] , [string] ] } [EOL] [comment] [EOL] venv_real_prefix = getattr ( sys , [string] , None ) [EOL] if venv_real_prefix : [EOL] lib_paths . add ( sysconfig . get_path ( [string] , vars = { [string] : venv_real_prefix } ) ) [EOL] LIB_PATHS = tuple ( pathlib . Path ( p ) . resolve ( ) for p in lib_paths if p is not None ) [EOL] [EOL] [EOL] def _startswith ( a , b ) : [EOL] try : [EOL] return bool ( a . relative_to ( b ) ) [EOL] except ValueError : [EOL] return False [EOL] [EOL] [EOL] @ functools . lru_cache ( maxsize = [number] ) def default_code_filter ( code ) : [EOL] [docstring] [EOL] [comment] [EOL] if not code . co_filename or code . co_filename [ [number] ] == [string] : [EOL] return False [EOL] [EOL] filename = pathlib . Path ( code . co_filename ) . resolve ( ) [EOL] [EOL] [comment] [EOL] trace_modules_str = os . environ . get ( [string] ) [EOL] if trace_modules_str is not None : [EOL] trace_modules = trace_modules_str . split ( [string] ) [EOL] [comment] [EOL] for lib_path in LIB_PATHS : [EOL] try : [EOL] filename = filename . relative_to ( lib_path ) [EOL] break [EOL] except ValueError : [EOL] pass [EOL] return any ( m == filename . stem or m in filename . parts for m in trace_modules ) [EOL] else : [EOL] return not any ( _startswith ( filename , lib_path ) for lib_path in LIB_PATHS ) [EOL] [EOL] [EOL] class DefaultConfig ( Config ) : [EOL] DB_PATH_VAR = [string] [EOL] [EOL] def type_rewriter ( self ) : [EOL] return DEFAULT_REWRITER [EOL] [EOL] def trace_store ( self ) : [EOL] [docstring] [EOL] db_path = os . environ . get ( self . DB_PATH_VAR , [string] ) [EOL] return SQLiteStore . make_store ( db_path ) [EOL] [EOL] def code_filter ( self ) : [EOL] [docstring] [EOL] return default_code_filter [EOL] [EOL] [EOL] def get_default_config ( ) : [EOL] [docstring] [EOL] try : [EOL] import monkeytype_config [comment] [EOL] except ImportError : [EOL] return DefaultConfig ( ) [EOL] return monkeytype_config . CONFIG [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typeline.db.base.CallTraceStore$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typeline.tracing.CodeFilter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Set , Callable , Optional , Dict , List , Iterator , Type , Tuple [EOL] import typeline [EOL] import logging [EOL] import typing [EOL] import types [EOL] import builtins [EOL] import inspect [EOL] import logging [EOL] import opcode [EOL] import random [EOL] import sys [EOL] from abc import ( ABCMeta , abstractmethod , ) [EOL] from contextlib import contextmanager [EOL] from types import ( CodeType , FrameType , ) [EOL] from typing import ( Any , Callable , Dict , Iterator , Optional , Union , cast , TYPE_CHECKING , List ) [EOL] [EOL] if TYPE_CHECKING : [EOL] from typeline . postgres . config import PostgresConfig [EOL] [EOL] try : [EOL] from django . utils . functional import cached_property [comment] [EOL] except ImportError : [EOL] cached_property = None [EOL] [EOL] from typeline . typing import get_type [EOL] from typeline . util import get_func_fqname [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ClassPropsTrace : [EOL] def __init__ ( self , module , qualname , class_props ) : [EOL] self . module = module [EOL] self . qualname = qualname [EOL] self . class_props = class_props [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , self . __class__ ) : [EOL] return self . __dict__ == other . __dict__ [EOL] return NotImplemented [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . module , self . qualname , frozenset ( self . class_props . items ( ) ) ) ) [EOL] [EOL] [EOL] class CallTrace : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , func , arg_types , return_type = None , yield_type = None ) : [EOL] [docstring] [EOL] self . func = func [EOL] self . arg_types = arg_types [EOL] self . return_type = return_type [EOL] self . yield_type = yield_type [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , self . __class__ ) : [EOL] return self . __dict__ == other . __dict__ [EOL] return NotImplemented [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . func , self . arg_types , self . return_type , self . yield_type ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . func , frozenset ( self . arg_types . items ( ) ) , self . return_type , self . yield_type ) ) [EOL] [EOL] def add_yield_type ( self , typ ) : [EOL] if self . yield_type is None : [EOL] self . yield_type = typ [EOL] else : [EOL] self . yield_type = Union [ self . yield_type , typ ] [EOL] [EOL] @ property def funcname ( self ) : [EOL] return get_func_fqname ( self . func ) [EOL] [EOL] [EOL] class CallTraceLogger ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def log ( self , trace ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def flush ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ClassPropsTraceLogger ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def log ( self , trace ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def flush ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def get_func_in_mro ( obj , code ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] val = inspect . getattr_static ( obj , code . co_name , None ) [EOL] if val is None : [EOL] return None [EOL] if isinstance ( val , ( classmethod , staticmethod ) ) : [EOL] cand = cast ( Callable , val . __func__ ) [EOL] elif isinstance ( val , property ) and ( val . fset is None ) and ( val . fdel is None ) : [EOL] cand = cast ( Callable , val . fget ) [EOL] elif cached_property and isinstance ( val , cached_property ) : [EOL] cand = cast ( Callable , val . func ) [EOL] else : [EOL] cand = cast ( Callable , val ) [EOL] return _has_code ( cand , code ) [EOL] [EOL] [EOL] def _has_code ( func , code ) : [EOL] while func is not None : [EOL] func_code = getattr ( func , [string] , None ) [EOL] if func_code is code : [EOL] return func [EOL] [comment] [EOL] func = getattr ( func , [string] , None ) [EOL] return None [EOL] [EOL] [EOL] def get_func ( frame ) : [EOL] [docstring] [EOL] code = frame . f_code [EOL] if code . co_name is None : [EOL] return None [EOL] [EOL] [comment] [EOL] cand = frame . f_globals . get ( code . co_name , None ) [EOL] func = _has_code ( cand , code ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if func is None and code . co_argcount >= [number] : [EOL] first_arg = frame . f_locals . get ( code . co_varnames [ [number] ] ) [EOL] func = get_func_in_mro ( first_arg , code ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if func is None : [EOL] for v in frame . f_globals . values ( ) : [EOL] if not isinstance ( v , type ) : [EOL] continue [EOL] func = get_func_in_mro ( v , code ) [EOL] if func is not None : [EOL] break [EOL] return func [EOL] [EOL] [EOL] RETURN_VALUE_OPCODE = opcode . opmap [ [string] ] [EOL] YIELD_VALUE_OPCODE = opcode . opmap [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] CodeFilter = Callable [ [ CodeType ] , bool ] [EOL] [EOL] EVENT_CALL = [string] [EOL] EVENT_RETURN = [string] [EOL] SUPPORTED_EVENTS = { EVENT_CALL , EVENT_RETURN } [EOL] [EOL] [EOL] def is_method_of_class ( frame ) : [EOL] return [string] in frame . f_locals [EOL] [EOL] [EOL] def is_private_function ( code ) : [EOL] return code . co_name . startswith ( [string] ) and not code . co_name . startswith ( [string] ) [EOL] [EOL] [EOL] class CallTracer : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , logger , class_logger , code_filter = None , sample_rate = None , skip_private_methods = True , skip_private_properties = True , acceptable_modules = None ) : [EOL] self . logger = logger [EOL] self . class_logger = class_logger [EOL] self . traces = { } [EOL] self . sample_rate = sample_rate [EOL] self . cache = { } [EOL] self . should_trace = code_filter [EOL] [EOL] self . mro_replacements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] self . skip_private_methods = skip_private_methods [EOL] self . skip_private_properties = skip_private_properties [EOL] [EOL] def _get_func ( self , frame ) : [EOL] code = frame . f_code [EOL] if code not in self . cache : [EOL] self . cache [ code ] = get_func ( frame ) [EOL] return self . cache [ code ] [EOL] [EOL] def handle_call ( self , frame ) : [EOL] if self . sample_rate and random . randrange ( self . sample_rate ) != [number] : [EOL] return [EOL] [EOL] func = self . _get_func ( frame ) [EOL] if func is None : [EOL] return [EOL] [EOL] code = frame . f_code [EOL] if self . skip_private_methods and is_private_function ( code ) : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if code . co_code [ frame . f_lasti ] == YIELD_VALUE_OPCODE : [EOL] return [EOL] [EOL] arg_names = code . co_varnames [ [number] : code . co_argcount ] [EOL] arg_types = { } [EOL] for name in arg_names : [EOL] if name in frame . f_locals : [EOL] arg_value = frame . f_locals [ name ] [EOL] arg_type = get_type ( arg_value ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] arg_types [ name ] = arg_type [EOL] [EOL] self . traces [ frame ] = CallTrace ( func , arg_types ) [EOL] [EOL] def handle_return ( self , frame , arg ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] typ = get_type ( arg ) [EOL] last_opcode = frame . f_code . co_code [ frame . f_lasti ] [EOL] trace = self . traces . get ( frame ) [EOL] if trace is None : [EOL] return [EOL] elif last_opcode == YIELD_VALUE_OPCODE : [EOL] trace . add_yield_type ( typ ) [EOL] else : [EOL] if last_opcode == RETURN_VALUE_OPCODE : [EOL] trace . return_type = typ [EOL] [EOL] if is_method_of_class ( frame ) : [EOL] parent_obj = frame . f_locals [ [string] ] [EOL] [EOL] module = None [EOL] try : [EOL] module = parent_obj . __class__ . __module__ [EOL] except Exception : [EOL] pass [EOL] [EOL] qualname = None [EOL] try : [EOL] qualname = parent_obj . __class__ . __qualname__ [EOL] except Exception : [EOL] pass [EOL] [EOL] props = { } [EOL] for key , val in list ( parent_obj . __dict__ . items ( ) ) : [EOL] if self . skip_private_properties and key . startswith ( [string] ) : [EOL] continue [EOL] props [ key ] = get_type ( val ) [EOL] [EOL] class_trace = ClassPropsTrace ( module , qualname , props ) [EOL] [comment] [EOL] self . class_logger . log ( class_trace ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] del self . traces [ frame ] [EOL] self . logger . log ( trace ) [EOL] [EOL] def __call__ ( self , frame , event , arg ) : [EOL] code = frame . f_code [EOL] if ( event not in SUPPORTED_EVENTS or code . co_name == [string] or self . should_trace and not self . should_trace ( code ) ) : [EOL] return self [EOL] [EOL] try : [EOL] if event == EVENT_CALL : [EOL] self . handle_call ( frame ) [EOL] elif event == EVENT_RETURN : [EOL] self . handle_return ( frame , arg ) [EOL] else : [EOL] logger . error ( [string] , event ) [EOL] except Exception : [EOL] logger . exception ( [string] ) [EOL] return self [EOL] [EOL] [EOL] @ contextmanager def trace_calls ( logger , code_filter = None , sample_rate = None , ) : [EOL] [docstring] [EOL] old_trace = sys . getprofile ( ) [EOL] sys . setprofile ( CallTracer ( logger , code_filter , sample_rate ) ) [EOL] try : [EOL] yield [EOL] finally : [EOL] sys . setprofile ( old_trace ) [EOL] logger . flush ( ) [EOL] [EOL] [EOL] @ contextmanager def trace_calls_init_with_config ( config ) : [EOL] [docstring] [EOL] old_trace = sys . getprofile ( ) [EOL] trace_logger = config . trace_logger ( ) [EOL] class_trace_logger = config . class_trace_logger ( ) [EOL] [EOL] sys . setprofile ( CallTracer ( logger = trace_logger , class_logger = class_trace_logger , code_filter = config . code_filter ( ) , sample_rate = config . sample_rate ( ) , skip_private_properties = config . skip_private_properties , skip_private_methods = config . skip_private_methods ) ) [EOL] [EOL] if config . skip_private_properties : [EOL] print ( [string] ) [EOL] if config . skip_private_methods : [EOL] print ( [string] ) [EOL] [EOL] try : [EOL] yield [EOL] finally : [EOL] sys . setprofile ( old_trace ) [EOL] trace_logger . flush ( ) [EOL] if hasattr ( trace_logger , [string] ) : [EOL] trace_logger . remove_duplicates ( ) [EOL] [EOL] class_trace_logger . flush ( ) [EOL] if hasattr ( trace_logger , [string] ) : [EOL] trace_logger . remove_duplicates ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typeline.tracing.ClassPropsTrace$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typeline.tracing.ClassPropsTrace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'CallTracer'$ 0 0 0 $types.FrameType$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 $types.CodeType$ 0 $types.FrameType$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $types.CodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.CodeType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $types.FrameType$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $types.FrameType$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Optional , ContextManager [EOL] import typeline [EOL] import typing [EOL] from typing import ( ContextManager , Optional , ) [EOL] [EOL] from typeline . config import ( Config , get_default_config , ) [EOL] from typeline . tracing import trace_calls , trace_calls_init_with_config [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] def trace ( config = None ) : [EOL] [docstring] [EOL] if config is None : [EOL] config = get_default_config ( ) [EOL] return trace_calls_init_with_config ( config ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ContextManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List , Iterable , Optional [EOL] import typing [EOL] import builtins [EOL] import typeline [EOL] from abc import ( ABCMeta , abstractmethod , ) [EOL] from typing import ( Iterable , List , Optional , ) [EOL] [EOL] [EOL] from typeline . tracing import CallTrace , CallTraceLogger [EOL] [EOL] [EOL] class CallTraceThunk ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def to_trace ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class CallTraceStore ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def add ( self , traces ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ abstractmethod def filter ( self , module , qualname_prefix = None , limit = [number] ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ classmethod def make_store ( cls , connection_string ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def list_modules ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( f" [string] { self . __class__ . __module__ } [string] { self . __class__ . __name__ } [string] " f" [string] " ) [EOL] [EOL] [EOL] class CallTraceStoreLogger ( CallTraceLogger ) : [EOL] [docstring] [EOL] def __init__ ( self , store ) : [EOL] self . store = store [EOL] self . traces = [ ] [EOL] [EOL] def log ( self , trace ) : [EOL] if not trace . func . __module__ == [string] : [EOL] self . traces . append ( trace ) [EOL] [EOL] def flush ( self ) : [EOL] self . store . add ( self . traces ) [EOL] self . traces = [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typeline.tracing.CallTrace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[typeline.tracing.CallTrace]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[CallTraceThunk]$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $'CallTraceStore'$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typeline.db.base.CallTraceStore$ 0 0 0 0 0 $typeline.db.base.CallTraceStore$ 0 $typeline.db.base.CallTraceStore$ 0 0 0 $typing.List[typeline.tracing.CallTrace]$ 0 0 0 0 0 0 $None$ 0 0 0 $typeline.tracing.CallTrace$ 0 0 0 0 0 $typeline.tracing.CallTrace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typeline.tracing.CallTrace$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typeline.tracing.CallTrace]$ 0 0 0 0 $typing.List[typeline.tracing.CallTrace]$ 0 0 0 0
	0
	0
	0
	0
class A1 ( object ) : [EOL] pass [EOL] [EOL] [EOL] class B1 ( object ) : [EOL] pass [EOL] [EOL] [EOL] class C1 ( object ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typeline . rewriters . tests . module1 import B1 [EOL] [EOL] [EOL] class A2 ( object ) : [EOL] pass [EOL] [EOL] [EOL] class D2 ( B1 ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import builtins [EOL] class MyClass : [EOL] @ property def method ( self ) : [EOL] ...	0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0
	0