import setuptools [EOL] [EOL] [EOL] setuptools . setup ( name = [string] , version = [string] , description = [string] , author = [string] , author_email = [string] , url = [string] , packages = setuptools . find_packages ( [string] ) , package_dir = { [string] : [string] } , include_package_data = True , classifiers = [ [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import flask [EOL] import flask . testing [EOL] [EOL] [EOL] def test_status_ok ( client ) : [EOL] res = client . get ( [string] ) [EOL] assert res . status_code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] import flask [EOL] import _pytest [EOL] import typing [EOL] import _pytest . monkeypatch [EOL] import flask . testing [EOL] import mock [EOL] import pytest [EOL] from bookie import app_generator [EOL] [EOL] [EOL] @ pytest . fixture def app ( monkeypatch ) : [EOL] def _get_google_secrets ( ) : [EOL] return { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] monkeypatch . setattr ( app_generator , [string] , _get_google_secrets ) [EOL] monkeypatch . setattr ( app_generator , [string] , mock . Mock ( ) ) [EOL] [EOL] return app_generator . create_app ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import flask [EOL] import mock [EOL] import _pytest [EOL] import _pytest . monkeypatch [EOL] import flask [EOL] import flask . testing [EOL] import mock [EOL] from bookie import app_generator [EOL] [EOL] [EOL] def test_index ( client ) : [EOL] res = client . get ( flask . url_for ( [string] ) ) [EOL] assert res . status_code == [number] [EOL] [EOL] [EOL] def test_search_unauthorized ( client ) : [EOL] res = client . get ( flask . url_for ( [string] ) ) [EOL] assert res . status_code == [number] [EOL] [EOL] [EOL] def test_search ( client ) : [EOL] with client . session_transaction ( ) as sess : [EOL] sess [ [string] ] = [string] [EOL] [EOL] res = client . get ( flask . url_for ( [string] ) ) [EOL] assert res . status_code == [number] [EOL] [EOL] [EOL] def test_search_isbn ( client , monkeypatch ) : [EOL] with client . session_transaction ( ) as sess : [EOL] sess [ [string] ] = [string] [EOL] [EOL] get_prices = mock . Mock ( ) [EOL] get_prices . return_value = { [string] : [string] , [string] : [string] } [EOL] monkeypatch . setattr ( app_generator . meta_scraper , [string] , get_prices ) [EOL] [EOL] res = client . get ( flask . url_for ( [string] , isbn = [string] ) ) [EOL] assert res . status_code == [number] [EOL] assert get_prices . call_count == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] import flask [EOL] import json [EOL] import os [EOL] import typing [EOL] import flask [EOL] from google . cloud import storage [EOL] import httplib2 [EOL] from flask_oauthlib . client import OAuth [EOL] from bookie . scrapers import meta_scraper [EOL] [EOL] AUTHORIZED_USERS = [ [string] , [string] , ] [EOL] [EOL] [EOL] def _get_google_secrets ( ) : [EOL] gclient = storage . Client ( ) [EOL] bucket = gclient . bucket ( [string] ) [EOL] blob = bucket . blob ( [string] ) [EOL] secrets = json . loads ( blob . download_as_string ( ) ) [EOL] [EOL] return { [string] : secrets [ [string] ] [ [string] ] , [string] : secrets [ [string] ] [ [string] ] , [string] : secrets [ [string] ] [ [string] ] } [EOL] [EOL] [EOL] def _request_user_info ( credentials ) : [EOL] http = httplib2 . Http ( ) [EOL] credentials . authorize ( http ) [EOL] resp , content = http . request ( [string] ) [EOL] [EOL] if resp . status != [number] : [EOL] flask . current_app . logger . error ( [string] , resp , content ) [EOL] return [EOL] [EOL] user_email = json . loads ( content . decode ( [string] ) ) [ [string] ] [EOL] [EOL] if user_email in AUTHORIZED_USERS : [EOL] flask . session [ [string] ] = json . loads ( content . decode ( [string] ) ) [ [string] ] [EOL] [EOL] [EOL] oauth = OAuth ( ) [comment] [EOL] [EOL] [EOL] def create_app ( ) : [EOL] [comment] [EOL] secrets = _get_google_secrets ( ) [EOL] [EOL] templates = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] app = flask . Flask ( __name__ , template_folder = templates ) [EOL] app . config . from_mapping ( secrets . items ( ) ) [EOL] [EOL] google = oauth . remote_app ( [string] , consumer_key = app . config . get ( [string] ) , consumer_secret = app . config . get ( [string] ) , request_token_params = { [string] : [string] } , base_url = [string] , request_token_url = None , access_token_method = [string] , access_token_url = [string] , authorize_url = [string] , ) [EOL] [EOL] @ app . route ( [string] ) def index ( ) : [EOL] user = flask . session . get ( [string] ) [EOL] return flask . render_template ( [string] , user = user ) [EOL] [EOL] @ app . route ( [string] ) def login ( ) : [EOL] return google . authorize ( callback = flask . url_for ( [string] , _external = True ) ) [EOL] [EOL] @ app . route ( [string] ) def authorized ( ) : [EOL] resp = google . authorized_response ( ) [EOL] if resp is None : [EOL] return [string] % ( flask . request . args [ [string] ] , flask . request . args [ [string] ] ) [EOL] flask . session [ [string] ] = ( resp [ [string] ] , [string] ) [EOL] [EOL] user_email = google . get ( [string] ) . data [ [string] ] [EOL] if user_email in AUTHORIZED_USERS : [EOL] flask . session [ [string] ] = google . get ( [string] ) . data [ [string] ] [EOL] return flask . redirect ( flask . url_for ( [string] ) ) [EOL] else : [EOL] flask . abort ( [number] ) [EOL] [EOL] @ app . route ( [string] ) def logout ( ) : [EOL] [comment] [EOL] if [string] in flask . session : [EOL] del flask . session [ [string] ] [EOL] del flask . session [ [string] ] [EOL] flask . session . modified = True [EOL] return flask . redirect ( [string] ) [EOL] [EOL] @ app . route ( [string] ) def status ( ) : [EOL] return [string] , [number] [EOL] [EOL] @ google . tokengetter def get_google_oauth_token ( ) : [EOL] return flask . session . get ( [string] ) [EOL] [EOL] @ app . errorhandler ( [number] ) def unauthorized ( _ ) : [EOL] return flask . Response ( [string] , [number] ) [EOL] [EOL] @ app . route ( [string] ) def search ( ) : [EOL] if [string] not in flask . session : [EOL] flask . abort ( [number] ) [EOL] [EOL] isbn = flask . request . args . get ( [string] ) [EOL] prices = meta_scraper . get_resale_prices ( isbn ) if isbn else { } [EOL] return flask . render_template ( [string] , isbn = isbn , prices = prices ) [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] from bookie import app_generator [EOL] [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] LOGGER . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] app = app_generator . create_app ( ) [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] [comment] [EOL] app . debug = False [EOL] app . run ( host = [string] , port = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Optional , List [EOL] import lxml [EOL] import typing [EOL] import builtins [EOL] import requests [EOL] import typing [EOL] import requests [EOL] from lxml import html [comment] [EOL] [EOL] [EOL] BOOKSTORE_URL = [string] [EOL] XPATH_LOCATION = [string] [EOL] [EOL] [EOL] def get_resale_price ( isbn ) : [EOL] res = requests . post ( BOOKSTORE_URL , data = { [string] : isbn } ) [EOL] tree = html . fromstring ( res . content ) [EOL] price_nodes = tree . xpath ( XPATH_LOCATION ) [EOL] if price_nodes : [EOL] return price_nodes [ [number] ] . text_content ( ) . split ( [string] ) [ [number] ] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict [EOL] import typing [EOL] import builtins [EOL] import typing [EOL] from bookie . scrapers import bookmob [EOL] from bookie . scrapers import bookscouter [EOL] from bookie . scrapers import queens [EOL] [EOL] [EOL] def get_resale_prices ( isbn ) : [EOL] return { [string] : bookmob . get_resale_price ( isbn ) , [string] : queens . get_resale_price ( isbn ) , [string] : bookscouter . get_resale_price ( isbn ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import builtins [EOL] import requests [EOL] import typing [EOL] import requests [EOL] from lxml import html [comment] [EOL] [EOL] URL = [string] [EOL] [EOL] [EOL] def get_resale_price ( isbn ) : [EOL] res = requests . post ( URL , data = { [string] : isbn } ) [EOL] tree = html . fromstring ( res . content ) [EOL] we_pay = tree . xpath ( [string] ) [EOL] [EOL] if we_pay : [EOL] options = we_pay [ [number] ] . getchildren ( ) [EOL] option_names = options [ [number] : : [number] ] [EOL] option_prices = options [ [number] : : [number] ] [EOL] [EOL] for name , price in zip ( option_names , option_prices ) : [EOL] if [string] in name . text_content ( ) : [EOL] return price . text_content ( ) [ [number] : ] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import builtins [EOL] import requests [EOL] import json [EOL] import typing [EOL] import requests [EOL] [EOL] URL = [string] [EOL] [EOL] [EOL] def get_resale_price ( isbn ) : [EOL] res = requests . get ( URL + isbn ) [EOL] data = json . loads ( res . content ) [EOL] if [string] in data : [EOL] return str ( max ( [ value [ [string] ] for value in data [ [string] ] [ [string] ] ] ) ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
	0