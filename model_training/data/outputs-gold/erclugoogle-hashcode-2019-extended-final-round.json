from typing import List , Any , Tuple [EOL] import model [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import networkx [EOL] import typing as tp [EOL] from pathlib import Path [EOL] [EOL] import networkx as nx [EOL] from tqdm import tqdm [EOL] [EOL] from . import model [EOL] [EOL] [EOL] def parse_file ( filename ) : [EOL] lines = filename . read_text ( encoding = [string] ) . split ( [string] ) [ : - [number] ] [EOL] [EOL] comp_files_number = ... [EOL] target_files_number = ... [EOL] servers_number = ... [EOL] comp_files_number , target_files_number , servers_number = ( int ( x ) for x in lines . pop ( [number] ) . split ( [string] ) ) [EOL] [EOL] assert len ( lines ) == comp_files_number * [number] + target_files_number [EOL] [EOL] raw_compiled_files = lines [ : comp_files_number * [number] - [number] : [number] ] [EOL] raw_dependencies_list = lines [ [number] : comp_files_number * [number] : [number] ] [EOL] raw_target_files = lines [ - target_files_number : ] [EOL] [EOL] return ( raw_compiled_files , raw_dependencies_list , raw_target_files , servers_number , ) [EOL] [EOL] [EOL] def build_graph ( raw_compiled_files , raw_dependencies_list , raw_target_files , ) : [EOL] dep_graph = nx . DiGraph ( ) [EOL] [EOL] for compiled_file , dependencies in tqdm ( zip ( raw_compiled_files , raw_dependencies_list ) , ascii = True ) : [EOL] [EOL] name , compilation_time , replication_time = compiled_file . split ( [string] ) [EOL] dep_graph . add_node ( name , props = model . CompiledFileProps ( compilation_time , replication_time ) , is_target = False ) [EOL] if len ( dependencies ) > [number] : [EOL] destinations = dependencies [ [number] : ] . split ( [string] ) [EOL] for dependency in destinations : [EOL] dep_graph . add_edge ( name , dependency ) [EOL] [EOL] for target_file in raw_target_files : [EOL] name , deadline , goal_points = target_file . split ( [string] ) [EOL] [EOL] props = dep_graph . nodes [ name ] [ [string] ] [EOL] [EOL] dep_graph . nodes [ name ] [ [string] ] = model . TargetFileProps ( props . compilation_time , props . replication_time , deadline , goal_points ) [EOL] dep_graph . nodes [ name ] [ [string] ] = True [EOL] [EOL] return dep_graph [EOL] [EOL] [EOL] def _solve ( filename ) : [EOL] ( raw_compiled_files , raw_dependencies_list , raw_target_files , servers_number , ) = parse_file ( filename ) [EOL] [EOL] dep_graph = build_graph ( raw_compiled_files , raw_dependencies_list , raw_target_files ) [EOL] [EOL] targets = list ( filter ( lambda x : dep_graph . nodes [ x ] [ [string] ] , dep_graph . nodes ) ) [EOL] [EOL] print ( * list ( x + [string] + str ( dep_graph . nodes [ x ] [ [string] ] ) for x in targets ) , sep = [string] ) [EOL] [EOL] [EOL] def main ( files ) : [EOL] for file in files : [EOL] _solve ( file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.str],typing.List[builtins.str],typing.List[builtins.str],builtins.int,]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $networkx.DiGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import pathlib [EOL] import sys [EOL] import typing as tp [EOL] from pathlib import Path [EOL] [EOL] from . import solve [EOL] [EOL] if __name__ == [string] : [EOL] args = [ Path ( x ) . resolve ( ) for x in sys . argv [ [number] : ] ] [EOL] solve . main ( args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pathlib.Path]$ 0 0
from typing import Set , List [EOL] import typing [EOL] import pathlib [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] import typing as tp [EOL] from pathlib import Path [EOL] [EOL] import attr [EOL] [EOL] [EOL] @ attr . s ( slots = True , frozen = True , auto_attribs = True ) class CompiledFile : [EOL] name = ... [EOL] compilation_time = attr . ib ( converter = int ) [EOL] replication_time = attr . ib ( converter = int ) [EOL] raw_dependencies = ... [EOL] [EOL] @ classmethod def from_rows ( cls , first_row , second_row ) : [EOL] name , compilation_time , replication_time = first_row . split ( [string] ) [EOL] [EOL] dep_list = ... [EOL] if len ( second_row ) > [number] : [EOL] dep_list = second_row [ [number] : ] . rstrip ( [string] ) . split ( [string] ) [EOL] else : [EOL] dep_list = [ ] [EOL] [EOL] return cls ( name , compilation_time , replication_time , dep_list ) [EOL] [EOL] @ staticmethod def find_in ( compiled_files_list , name ) : [EOL] [docstring] [EOL] return next ( filter ( lambda x : x . name == name , compiled_files_list ) ) [EOL] [EOL] [EOL] @ attr . s ( slots = True , frozen = True , auto_attribs = True ) class TargetFile : [EOL] name = ... [EOL] deadline = attr . ib ( converter = int ) [EOL] goal_points = attr . ib ( converter = int ) [EOL] [EOL] def score ( self , completion_time ) : [EOL] speed_points = self . deadline - completion_time [EOL] return speed_points + self . goal_points if speed_points >= [number] else [number] [EOL] [EOL] @ classmethod def from_row ( cls , row ) : [EOL] return cls ( * row . split ( [string] ) ) [EOL] [EOL] [EOL] @ attr . s ( slots = True , auto_attribs = True ) class Server : [EOL] number = attr . ib ( converter = int ) [EOL] available_files = attr . ib ( default = attr . Factory ( set ) ) [EOL] [EOL] [EOL] @ attr . s ( slots = True , frozen = True , auto_attribs = True ) class Step : [EOL] compiled_file = ... [EOL] server = ... [EOL] [EOL] [EOL] @ attr . s ( slots = True , auto_attribs = True ) class CompilationSteps : [EOL] steps = attr . ib ( default = attr . Factory ( list ) , init = False ) [EOL] score = attr . ib ( default = [number] , init = False ) [EOL] targets = attr . ib ( default = attr . Factory ( set ) ) [EOL] [EOL] def add_step ( self , step ) : [EOL] self . steps . append ( step ) [comment] [EOL] [EOL] def save ( self , outfile ) : [EOL] submission_rows = [ [string] . format ( len ( self . steps ) ) ] + [ [string] . format ( x . compiled_file . name , x . server . number ) for x in self . steps ] [EOL] [EOL] outfile . write_text ( [string] . join ( submission_rows ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $CompiledFile$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $CompiledFile$ 0 $typing.List[CompiledFile]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[CompiledFile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $TargetFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[CompiledFile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $CompiledFile$ 0 0 0 $Server$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Step]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[TargetFile]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Step$ 0 0 0 0 0 0 0 0 0 $Step$ 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0
import builtins [EOL] from __future__ import annotations [EOL] [EOL] [comment] [EOL] [comment] [EOL] import attr [EOL] [EOL] [EOL] @ attr . s ( frozen = True , slots = True , auto_attribs = True ) class CompiledFileProps : [EOL] compilation_time = attr . ib ( converter = int ) [EOL] replication_time = attr . ib ( converter = int ) [EOL] [EOL] [EOL] @ attr . s ( frozen = True , slots = True , auto_attribs = True ) class TargetFileProps ( CompiledFileProps ) : [EOL] deadline = attr . ib ( converter = int ) [EOL] goal_points = attr . ib ( converter = int ) [EOL] [EOL] def score ( self , completed_time ) : [EOL] speed_points = self . deadline - completed_time [EOL] return speed_points + self . goal_points if speed_points >= [number] else [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0
	0