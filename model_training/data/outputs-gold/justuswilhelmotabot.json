[comment] [EOL] import builtins [EOL] from typing import Iterator , Any , List , Dict , Type , Tuple [EOL] import typing [EOL] import decimal [EOL] import main [EOL] import functools [EOL] import readline [EOL] import random [EOL] [EOL] from decimal import Decimal [EOL] from enum import Enum , auto [EOL] [EOL] [EOL] class RandomPolicy : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , game ) : [EOL] [docstring] [EOL] self . game = game [EOL] [EOL] def genmove ( self , color ) : [EOL] [docstring] [EOL] [EOL] [EOL] class FieldState ( Enum ) : [EOL] [docstring] [EOL] [EOL] EMPTY = auto ( ) [EOL] BLACK = auto ( ) [EOL] WHITE = auto ( ) [EOL] [EOL] [EOL] class Game : [EOL] [docstring] [EOL] [EOL] BOARDSIZE = [number] [EOL] KOMI = Decimal ( [string] ) [EOL] COLUMNS = [string] [EOL] STARS = { [number] : [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] } [EOL] POLICY_CLS = RandomPolicy [EOL] [EOL] def __init__ ( self , boardsize = None , komi = None ) : [EOL] [docstring] [EOL] self . komi = komi or self . KOMI [EOL] self . create_board ( boardsize or self . BOARDSIZE ) [EOL] self . policy = self . POLICY_CLS ( self ) [EOL] [EOL] def create_board ( self , size ) : [EOL] [docstring] [EOL] self . board = [ [ FieldState . EMPTY for _ in range ( size ) ] for _ in range ( size ) ] [EOL] [EOL] def clear_board ( self ) : [EOL] [docstring] [EOL] self . create_board ( self . boardsize ) [EOL] [EOL] def parse_move ( self , move ) : [EOL] [docstring] [EOL] column , row = move [EOL] return self . COLUMNS . find ( column ) , int ( row ) - [number] [EOL] [EOL] def to_move ( self , move ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def play ( self , state , move ) : [EOL] [docstring] [EOL] column , row = move [EOL] self . board [ row ] [ column ] = state [EOL] [EOL] @ property def boardsize ( self ) : [EOL] [docstring] [EOL] return len ( self . board ) [EOL] [EOL] def is_star ( self , row , column ) : [EOL] [docstring] [EOL] stars = self . STARS [ self . boardsize ] [EOL] return ( row , column ) in stars [EOL] [EOL] def genmove ( self , color ) : [EOL] [docstring] [EOL] self . policy . genmove ( color ) [EOL] [EOL] def showboard ( self ) : [EOL] [docstring] [EOL] def _iter_cols ( index , row ) : [EOL] yield [string] . format ( index ) [EOL] for col_index , col in enumerate ( row , start = [number] ) : [EOL] if col == FieldState . EMPTY : [EOL] if self . is_star ( index , col_index ) : [EOL] yield [string] [EOL] else : [EOL] yield [string] [EOL] elif col == FieldState . WHITE : [EOL] yield [string] [EOL] elif col == FieldState . BLACK : [EOL] yield [string] [EOL] yield [string] . format ( index ) [EOL] [EOL] def _iter_rows ( ) : [EOL] cols = [string] . format ( [string] . join ( self . COLUMNS [ : self . boardsize ] ) ) [EOL] yield cols [EOL] indices = reversed ( range ( [number] , self . boardsize + [number] ) ) [EOL] for index , row in zip ( indices , self . board ) : [EOL] yield [string] . join ( _iter_cols ( index , row ) ) [EOL] yield cols [EOL] return [string] . format ( [string] . join ( _iter_rows ( ) ) ) [EOL] [EOL] [EOL] class Shell ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . game = Game ( ) [EOL] self . commands = { name [ [number] : ] : getattr ( self , name ) for name in dir ( self ) if name . startswith ( [string] ) } [EOL] [EOL] def answer ( self , line , success = True ) : [EOL] prefix_id = self . id or [string] [EOL] if success : [EOL] prefix = [string] . format ( prefix_id ) [EOL] else : [EOL] prefix = [string] . format ( prefix_id ) [EOL] print ( [string] . format ( prefix , line ) , end = [string] ) [EOL] [EOL] def call_command ( self , name , args ) : [EOL] [docstring] [EOL] try : [EOL] cmd = self . commands [ name ] [EOL] except KeyError : [EOL] self . answer ( [string] , success = False ) [EOL] else : [EOL] try : [EOL] result , success = cmd ( * args ) [EOL] result = result or [string] [EOL] self . answer ( result , success = success ) [EOL] except TypeError as e : [EOL] self . answer ( [string] . format ( e ) , success = False , ) [EOL] [EOL] def _loop ( self ) : [EOL] while True : [EOL] i = input ( ) . strip ( ) . split ( ) [EOL] [comment] [EOL] if not i : [EOL] self . answer ( [string] , success = True ) [EOL] self . id = None [EOL] [comment] [EOL] try : [EOL] id_raw , cmd_name , * args = i [EOL] self . id = int ( id_raw ) [EOL] [comment] [EOL] except ValueError : [EOL] cmd_name , * args = i [EOL] self . id = None [EOL] self . call_command ( cmd_name , args ) [EOL] [EOL] def cmdloop ( self ) : [EOL] readline . parse_and_bind ( [string] ) [EOL] readline . set_completer ( self . complete ) [EOL] try : [EOL] self . _loop ( ) [EOL] except EOFError : [EOL] pass [EOL] [EOL] @ functools . lru_cache ( ) def complete_prefix ( self , prefix ) : [EOL] [docstring] [EOL] return tuple ( k for k in self . commands . keys ( ) if k . startswith ( prefix ) ) [EOL] [EOL] def complete ( self , text , state ) : [EOL] [docstring] [EOL] return self . complete_prefix ( text ) [ state ] [EOL] [EOL] def do_version ( self ) : [EOL] [docstring] [EOL] return [string] , True [EOL] [EOL] def do_name ( self ) : [EOL] [docstring] [EOL] return [string] , True [EOL] [EOL] def do_protocol_version ( self ) : [EOL] [docstring] [EOL] return [string] , True [EOL] [EOL] def do_known_command ( self , cmd ) : [EOL] [docstring] [EOL] if cmd in self . commands : [EOL] return [string] , True [EOL] else : [EOL] return [string] , True [EOL] [EOL] def do_list_commands ( self ) : [EOL] [docstring] [EOL] result = [string] . join ( self . commands . keys ( ) ) [EOL] return result , True [EOL] [EOL] def do_boardsize ( self , size ) : [EOL] [docstring] [EOL] self . game . create_board ( int ( size ) ) [EOL] return None , True [EOL] [EOL] def do_clear_board ( self ) : [EOL] [docstring] [EOL] self . game . clear_board ( ) [EOL] return None , True [EOL] [EOL] def do_komi ( self , komi ) : [EOL] [docstring] [EOL] self . game . komi = Decimal ( komi ) [EOL] return None , True [EOL] [EOL] def do_play ( self , player , move ) : [EOL] [docstring] [EOL] state = { [string] : FieldState . WHITE , [string] : FieldState . BLACK , } [ player ] [EOL] move = self . game . parse_move ( move ) [EOL] self . game . play ( state , move ) [EOL] return None , True [EOL] [EOL] def do_showboard ( self ) : [EOL] return self . game . showboard ( ) , True [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] Shell ( ) . cmdloop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.int,typing.List[typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[main.RandomPolicy]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $main.Game$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $main.FieldState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $main.FieldState$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from otabot import tictac [EOL] from otabot import minmax [EOL] from otabot import base [EOL] [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] [EOL] player = tictac . X [EOL] pc = tictac . O [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] print ( [string] . format ( tictac . colors [ player ] ) ) [EOL] b = tictac . Board ( ) [EOL] s = minmax . MinMax ( ) [EOL] print ( b ) [EOL] print ( ) [EOL] while True : [EOL] while True : [EOL] try : [EOL] row , column = ( int ( i ) for i in input ( [string] ) . split ( ) ) [EOL] except ValueError : [EOL] print ( [string] ) [EOL] print ( ) [EOL] continue [EOL] try : [EOL] b . set ( ( row , column ) , player ) [EOL] except AssertionError : [EOL] print ( [string] ) [EOL] print ( ) [EOL] else : [EOL] break [EOL] print ( b ) [EOL] print ( ) [EOL] if b . win ( player ) : [EOL] print ( [string] ) [EOL] return [EOL] move , score = s . make_move ( b , pc , True , pc ) [EOL] if move is None : [EOL] print ( [string] ) [EOL] return [EOL] print ( [string] . format ( move , score ) ) [EOL] print ( ) [EOL] b . set ( move , pc ) [EOL] print ( b ) [EOL] print ( ) [EOL] if b . win ( pc ) : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Literal [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] from otabot . tictac import Board , X , O , E [EOL] from otabot . minmax import MinMax [EOL] [EOL] [EOL] class MinMaxTest ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . g = Board ( ) [EOL] self . s = MinMax ( ) [EOL] [EOL] def test_draw ( self ) : [EOL] self . g . set_board ( [ O , X , E , O , X , O , X , O , X , ] ) [EOL] expected = ( [number] , [number] ) , [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , X , True , X ) , expected , ) [EOL] expected = ( [number] , [number] ) , [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , X , True , O ) , expected , ) [EOL] expected = ( [number] , [number] ) , [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , O , True , O ) , expected , ) [EOL] expected = ( [number] , [number] ) , [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , O , True , X ) , expected , ) [EOL] [EOL] def test_last ( self ) : [EOL] self . g . set_board ( [ O , O , E , O , X , O , X , O , X , ] ) [EOL] expected = ( [number] , [number] ) , [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , X , True , X ) , expected , ) [EOL] expected = ( [number] , [number] ) , - [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , X , True , O ) , expected ) [EOL] [EOL] def test_two_empty ( self ) : [EOL] self . g . set_board ( [ X , O , O , X , X , O , E , O , E , ] ) [EOL] expected = ( [number] , [number] ) , [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , X , True , O ) , expected ) [EOL] expected = ( [number] , [number] ) , - [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , O , True , X ) , expected ) [EOL] expected = ( [number] , [number] ) , [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , O , True , O ) , expected ) [EOL] [EOL] def test_done ( self ) : [EOL] self . g . set_board ( [ X , O , O , X , X , O , E , O , O , ] ) [EOL] expected = None , [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , O , True , O ) , expected ) [EOL] expected = None , - [number] [EOL] self . assertEqual ( self . s . make_move ( self . g , X , True , X ) , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal]$ 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal]$ 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal]$ 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal[-1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal[-1]]$ 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal[-1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing_extensions.Literal[-1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],builtins.float]$ 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],builtins.float]$ 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[None,typing_extensions.Literal[-1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[None,typing_extensions.Literal[-1]]$ 0 0 $typing.Tuple[None,typing_extensions.Literal[-1]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[None,typing_extensions.Literal[-1]]$ 0 0
	0
from typing import Tuple , Literal [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] from unittest import TestCase [EOL] [EOL] from otabot . tictac import Board , X , O , E [EOL] [EOL] [EOL] class BoardTest ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . g = Board ( ) [EOL] [EOL] def test_get ( self ) : [EOL] a = [number] , [number] [EOL] self . assertEqual ( self . g . get ( a ) , E , ) [EOL] self . g . set ( a , O ) [EOL] self . assertEqual ( self . g . get ( a ) , O , ) [EOL] b = [number] , [number] [EOL] self . g . set ( b , X ) [EOL] self . assertEqual ( self . g . get ( b ) , X , ) [EOL] [EOL] def test_set ( self ) : [EOL] self . g . set ( [number] , [number] , X ) [EOL] self . assertEqual ( self . g . get ( [number] , [number] ) , X , ) [EOL] self . g . unset ( [number] , [number] ) [EOL] self . assertEqual ( self . g . get ( [number] , [number] ) , E , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0