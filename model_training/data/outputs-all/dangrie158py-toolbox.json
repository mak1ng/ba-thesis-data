from setuptools import setup [EOL] from os import path [EOL] import re [EOL] [EOL] def read ( fname ) : [EOL] return open ( path . join ( path . dirname ( __file__ ) , fname ) ) . read ( ) [EOL] [EOL] def get_version ( ) : [EOL] with open ( [string] ) as changelog : [EOL] for line in changelog : [EOL] if re . match ( [string] , line ) : [EOL] return line [EOL] [EOL] setup ( name = [string] , version = get_version ( ) , author = [string] , author_email = [string] , url = [string] , packages = [ [string] , [string] ] , include_package_data = True , license = [string] , description = [string] , long_description = read ( [string] ) , long_description_content_type = [string] , classifiers = [ [string] , [string] , [string] , ] , entry_points = { [string] : [ [string] ] , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import List [EOL] import typing [EOL] import os [EOL] import sys [EOL] sys . path . insert ( [number] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] todo_include_todos = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Optional , Mapping , Union , Dict , Sequence , Any , Generator , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import itertools [EOL] from copy import deepcopy [EOL] from collections . abc import Iterable [EOL] from typing import Optional , Union , Any , Mapping , Generator , Sequence [EOL] [EOL] [EOL] def named_product ( values = None , repeat = [number] , safe_copy = True , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if values is not None : [EOL] kwargs = { ** values , ** kwargs } [EOL] [EOL] [comment] [EOL] for name , entry in kwargs . copy ( ) . items ( ) : [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( entry , str ) or not isinstance ( entry , Iterable ) : [EOL] kwargs . update ( { name : ( entry , ) } ) [comment] [EOL] [EOL] if any ( isinstance ( v , dict ) for v in kwargs . values ( ) ) : [EOL] [comment] [EOL] for key_outer , val_outer in kwargs . items ( ) : [EOL] if isinstance ( val_outer , dict ) : [EOL] for key_inner , val_inner in val_outer . items ( ) : [EOL] subproduct = { key_outer : key_inner , ** val_inner } [EOL] [comment] [EOL] yield from named_product ( repeat = repeat , safe_copy = safe_copy , ** { ** kwargs , ** subproduct } ) [EOL] else : [EOL] [comment] [EOL] for combination in itertools . product ( * kwargs . values ( ) , repeat = repeat ) : [EOL] [EOL] combined_values = [ ] [EOL] if isinstance ( safe_copy , Iterable ) : [EOL] for key , val in zip ( list ( kwargs . keys ( ) ) , combination ) : [EOL] if key in safe_copy : [EOL] combined_values . append ( deepcopy ( val ) ) [EOL] else : [EOL] combined_values . append ( val ) [EOL] elif isinstance ( safe_copy , bool ) and safe_copy : [EOL] combined_values . append ( deepcopy ( list ( combination ) ) ) [EOL] else : [EOL] combined_values . append ( combination ) [EOL] [EOL] yield dict ( zip ( list ( kwargs . keys ( ) ) , * combined_values ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Mapping , Type , Callable , Sequence , Union , Dict , Optional , Any , List [EOL] import importlib [EOL] import builtins [EOL] import typing [EOL] import types [EOL] import pytb [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] import sys [EOL] import os [EOL] import builtins [EOL] import logging [EOL] from typing import ( Optional , Any , Sequence , Union , ContextManager , Type , Mapping , Callable , List , ) [EOL] from types import ModuleType , TracebackType [EOL] from importlib import reload as reload_module [EOL] from importlib . machinery import ModuleSpec [EOL] from importlib . _bootstrap import _calc___package__ , _resolve_name [EOL] from importlib . abc import MetaPathFinder , Loader [EOL] from contextlib import suppress [EOL] [EOL] from nbformat import read as read_notebook [EOL] [EOL] with suppress ( Exception ) : [EOL] from IPython import get_ipython [EOL] from IPython . core . interactiveshell import InteractiveShell [EOL] [EOL] from pytb . config import current_config as pytb_config [EOL] [EOL] [comment] [EOL] _PathType = Sequence [ Union [ bytes , str ] ] [EOL] [EOL] [EOL] class ModuleLoader ( MetaPathFinder , ContextManager [ [string] ] , Loader ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __init__ ( self , verbose = False ) : [EOL] self . _logger = logging . getLogger ( f"{ self . __class__ . __module__ } [string] { self . __class__ . __name__ }" ) [EOL] if verbose : [EOL] self . _logger . setLevel ( logging . INFO ) [EOL] handler = logging . StreamHandler ( stream = sys . stdout ) [EOL] handler . setLevel ( logging . INFO ) [EOL] self . _logger . addHandler ( handler ) [EOL] [EOL] def find_spec ( self , fullname , path , target = None , ) : [EOL] [comment] [EOL] [comment] [EOL] self . _logger . info ( f" [string] { fullname } [string] { path }" ) [EOL] return None [EOL] [EOL] def create_module ( self , spec ) : [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] [EOL] def exec_module ( self , module ) : [EOL] [comment] [EOL] self . _logger . info ( f" [string] { module . __name__ }" ) [EOL] raise NotImplementedError [EOL] [EOL] def __enter__ ( self ) : [EOL] self . install ( ) [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback , ) : [EOL] self . uninstall ( ) [EOL] [EOL] def install ( self ) : [EOL] [docstring] [EOL] if self in sys . meta_path : [EOL] raise RuntimeError ( [string] ) [EOL] sys . meta_path . append ( self ) [EOL] [EOL] def uninstall ( self ) : [EOL] [docstring] [EOL] try : [EOL] sys . meta_path . remove ( self ) [EOL] except ValueError : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] @ classmethod def install_hook ( cls ) : [EOL] [docstring] [EOL] loader = cls ( ) [EOL] loader . install ( ) [EOL] return loader [EOL] [EOL] [EOL] [comment] [EOL] _GlobalType = Mapping [ str , Any ] [EOL] [EOL] [comment] [EOL] _ImportFunType = Callable [ [ str , Optional [ _GlobalType ] , Optional [ _GlobalType ] , Sequence [ str ] , int ] , Any ] [EOL] [EOL] [EOL] class NoModuleCacheContext ( ContextManager [ [string] ] ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _no_reloadable_packages = pytb_config . getlist ( [string] , [string] ) [EOL] [EOL] class CachlessImporter : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , import_fun , verbose , max_depth ) : [EOL] self . import_fun = import_fun [EOL] self . module_stack = [ ] [EOL] self . reloaded_modules_in_last_call = [ ] [EOL] self . max_depth = max_depth [EOL] [EOL] self . _logger = logging . getLogger ( f"{ self . __class__ . __module__ } [string] { self . __class__ . __name__ }" ) [EOL] self . is_verbose = verbose [EOL] handler = logging . StreamHandler ( stream = sys . stdout ) [EOL] handler . setLevel ( logging . INFO ) [EOL] self . _logger . addHandler ( handler ) [EOL] [EOL] def __call__ ( self , name , globals = None , locals = None , fromlist = None , level = [number] , ) : [comment] [EOL] if self . is_verbose : [EOL] self . _logger . setLevel ( logging . INFO ) [EOL] [EOL] if globals is None : [EOL] globals = { } [EOL] [EOL] if locals is None : [EOL] locals = { } [EOL] [EOL] if fromlist is None : [EOL] fromlist = [ ] [EOL] [EOL] [comment] [EOL] if level > [number] : [EOL] [comment] [EOL] package = _calc___package__ ( globals ) [comment] [EOL] fullname = _resolve_name ( name , package , level ) [EOL] else : [EOL] [comment] [EOL] fullname = name [EOL] [EOL] if fullname in self . module_stack : [EOL] [comment] [EOL] [comment] [EOL] return self . import_fun ( name , globals , locals , fromlist , level ) [EOL] [EOL] module_name = fullname . partition ( [string] ) [ [number] ] [EOL] [EOL] if ( fullname not in self . reloaded_modules_in_last_call [EOL] and module_name not in NoModuleCacheContext . _no_reloadable_packages ) : [EOL] [comment] [EOL] [comment] [EOL] self . maybe_reload_module ( fullname ) [EOL] if fromlist : [EOL] [comment] [EOL] for part in fromlist : [EOL] el_name = [string] . join ( ( fullname , part ) ) [EOL] self . maybe_reload_module ( el_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . module_stack . append ( fullname ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] module = self . import_fun ( name , globals , locals , fromlist , level ) [EOL] [EOL] [comment] [EOL] self . module_stack . remove ( fullname ) [EOL] return module [EOL] [EOL] def maybe_reload_module ( self , fullname ) : [EOL] [docstring] [EOL] if fullname in sys . modules and ( self . max_depth is None or len ( self . module_stack ) < self . max_depth ) : [EOL] self . reloaded_modules_in_last_call . append ( fullname ) [EOL] reload_module ( sys . modules [ fullname ] ) [comment] [EOL] [EOL] def flush_reload_stack ( self ) : [EOL] [docstring] [EOL] self . _logger . info ( f" [string] { self . reloaded_modules_in_last_call }" ) [EOL] self . reloaded_modules_in_last_call . clear ( ) [EOL] [EOL] def __init__ ( self , verbose = False , max_depth = None ) : [EOL] self . is_verbose = verbose [EOL] self . _next_context_is_verbose = False [EOL] self . max_depth = max_depth [EOL] [EOL] self . original_import_fun = builtins . __import__ [EOL] self . custom_import_fun = self . CachlessImporter ( self . original_import_fun , verbose , self . max_depth ) [EOL] [EOL] def __enter__ ( self ) : [EOL] verbosity = self . _next_context_is_verbose or self . is_verbose [EOL] self . _next_context_is_verbose = False [EOL] self . original_import_fun = builtins . __import__ [EOL] builtins . __import__ = self . custom_import_fun [EOL] [EOL] self . custom_import_fun . is_verbose = verbosity [EOL] [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback , ) : [EOL] self . custom_import_fun . flush_reload_stack ( ) [EOL] builtins . __import__ = self . original_import_fun [EOL] self . is_verbose = False [EOL] [EOL] def __call__ ( self , verbose = False ) : [EOL] self . _next_context_is_verbose = verbose [EOL] return self [EOL] [EOL] [EOL] [comment] [EOL] no_module_cache = NoModuleCacheContext ( ) [EOL] [docstring] [EOL] [EOL] [EOL] class NotebookLoader ( ModuleLoader ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def __init__ ( self , verbose = False ) : [EOL] super ( ) . __init__ ( verbose ) [EOL] self . shell = ( InteractiveShell . instance ( ) if [string] in globals ( ) else None ) [EOL] [EOL] @ staticmethod def _find_notebook ( fullname , path ) : [EOL] name = fullname . rsplit ( [string] , [number] ) [ - [number] ] [EOL] if not path : [EOL] path = [ [string] ] [EOL] [EOL] for part in path : [EOL] nb_path = os . path . join ( str ( part ) , name + [string] ) [EOL] if os . path . isfile ( nb_path ) : [EOL] return nb_path [EOL] [comment] [EOL] nb_path = nb_path . replace ( [string] , [string] ) [EOL] if os . path . isfile ( nb_path ) : [EOL] return nb_path [EOL] return None [EOL] [EOL] def find_spec ( self , fullname , path , target = None , ) : [EOL] super ( ) . find_spec ( fullname , path , target ) [EOL] [EOL] nb_path = NotebookLoader . _find_notebook ( fullname , path ) [EOL] if nb_path is None : [EOL] return None [EOL] [EOL] self . _logger . info ( f" [string] { nb_path }" ) [EOL] [EOL] return ModuleSpec ( fullname , self , origin = nb_path ) [EOL] [EOL] def exec_module ( self , module ) : [EOL] module_file = getattr ( getattr ( module , [string] , None ) , [string] , None ) [EOL] if module_file is None : [EOL] raise ImportError ( [string] ) [EOL] [EOL] with open ( module_file , [string] , encoding = [string] ) as f : [EOL] notebook = read_notebook ( f , [number] ) [EOL] [EOL] if self . shell is not None : [EOL] module . __dict__ [ [string] ] = get_ipython [EOL] [comment] [EOL] [comment] [EOL] save_user_ns = self . shell . user_ns [EOL] self . shell . user_ns = module . __dict__ [EOL] [EOL] try : [EOL] for cell in notebook . cells : [EOL] if cell . cell_type == [string] : [EOL] if self . shell is not None : [EOL] code = self . shell . input_transformer_manager . transform_cell ( cell . source ) [EOL] else : [EOL] code = cell . source [EOL] [EOL] [comment] [EOL] [comment] [EOL] exec ( code , module . __dict__ ) [EOL] finally : [EOL] if self . shell is not None : [EOL] self . shell . user_ns = save_user_ns [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.Sequence[typing.Union[builtins.bytes,builtins.str]]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[typing.Union[builtins.bytes,builtins.str]]]$ 0 0 $typing.Optional[typing.Sequence[typing.Union[builtins.bytes,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[typing.Union[builtins.bytes,builtins.str]]]$ 0 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Sequence[typing.Union[builtins.bytes,builtins.str]]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[typing.Union[builtins.bytes,builtins.str]]]$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[typing.Union[builtins.bytes,builtins.str]]]$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[importlib.machinery.ModuleSpec]$ 0 0 0 $builtins.str$ 0 $typing.Optional[_PathType]$ 0 $typing.Optional[types.ModuleType]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[_PathType]$ 0 $typing.Optional[types.ModuleType]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[_PathType]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $None$ 0 0 0 $types.ModuleType$ 0 0 0 $typing.Any$ 0 0 0 0 0 $types.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.ModuleType$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Type , List , Sequence , Any , Mapping [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import pytb [EOL] import logging [EOL] [docstring] [EOL] [EOL] import sys [EOL] import configparser [EOL] import logging [EOL] from typing import Mapping , Any , Sequence , List , Optional [EOL] from pathlib import Path [EOL] [EOL] [EOL] class Config ( configparser . ConfigParser ) : [EOL] [docstring] [EOL] [EOL] _defaults = { [string] : { [string] : False , [string] : False , [string] : False , } , [string] : { [string] : [number] , [string] : [string] , [string] : [string] , [string] : True , } , [string] : { [string] : [ ] } , [string] : { [string] : [ ] , [string] : [string] , [string] : [number] , [string] : False , [string] : [string] , } , } [EOL] [docstring] [EOL] [EOL] config_file_name = [string] [EOL] [docstring] [EOL] [EOL] default_config_file = Path ( __file__ ) . parents [ [number] ] / config_file_name [EOL] [docstring] [EOL] [EOL] @ staticmethod def get_config_file_locations ( ) : [EOL] [docstring] [EOL] [comment] [EOL] directory = Path . cwd ( ) [EOL] config_paths = [ ] [EOL] while True : [EOL] [comment] [EOL] config_file = directory / Config . config_file_name [EOL] [EOL] config_paths . append ( config_file ) [EOL] [EOL] [comment] [EOL] if directory == Path ( directory . root ) : [EOL] break [EOL] [EOL] [comment] [EOL] directory = directory . parent [EOL] [EOL] [comment] [EOL] config_paths . append ( Config . default_config_file ) [EOL] return list ( reversed ( config_paths ) ) [EOL] [EOL] def __init__ ( self , verbose = False ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _logger = logging . getLogger ( f"{ self . __class__ . __module__ } [string] { self . __class__ . __name__ }" ) [EOL] if verbose : [EOL] self . _logger . setLevel ( logging . INFO ) [EOL] handler = logging . StreamHandler ( stream = sys . stdout ) [EOL] handler . setLevel ( logging . INFO ) [EOL] self . _logger . addHandler ( handler ) [EOL] [EOL] self . reload ( ) [EOL] [EOL] def reload ( self ) : [EOL] [docstring] [EOL] self . read_dict ( Config . _defaults ) [EOL] [EOL] potential_config_files = Config . get_config_file_locations ( ) [EOL] self . _logger . info ( f" [string] { potential_config_files }" ) [EOL] [EOL] files_loaded = self . read ( potential_config_files ) [EOL] self . _logger . info ( f" [string] { files_loaded }" ) [EOL] [EOL] def getlist ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] value = self . get ( * args , ** kwargs ) [EOL] [comment] [EOL] return [ entry for entry in value . split ( [string] ) if entry ] [EOL] [EOL] [EOL] current_config = Config ( ) [comment] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import ContextManager , Type , Sequence , TypeVar , IO , Union , Literal , Optional , TextIO , Any , Generator , List [EOL] import io [EOL] import contextlib [EOL] import email [EOL] import builtins [EOL] import configparser [EOL] import threading [EOL] import typing [EOL] import types [EOL] import pytb [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] import smtplib [EOL] import logging [EOL] import inspect [EOL] import linecache [EOL] import threading [EOL] from typing import ( Union , Any , Optional , Generator , ContextManager , Sequence , IO , TypeVar , cast , ) [EOL] from types import FrameType [EOL] from datetime import timedelta [EOL] from socket import getfqdn [EOL] from contextlib import contextmanager , nullcontext [EOL] from email . message import EmailMessage [EOL] from io import StringIO [comment] [EOL] from textwrap import dedent [EOL] [EOL] from pytb . config import current_config [EOL] from pytb . io import mirrored_stdstreams , render_text [EOL] [EOL] [comment] [EOL] _Interval = Union [ int , float , timedelta ] [EOL] [EOL] [comment] [EOL] _IterType = TypeVar ( [string] ) [EOL] [EOL] [EOL] def _get_caller_code_fragment ( caller_frame , context_size = [number] ) : [EOL] [docstring] [EOL] filename = caller_frame . f_code . co_filename [EOL] lineno = caller_frame . f_lineno [EOL] caller_file_lines = linecache . getlines ( filename ) [EOL] [EOL] def get_indentation ( line ) : [EOL] level = [number] [EOL] for char in line : [EOL] if char in ( [string] , [string] ) : [EOL] level += [number] [EOL] else : [EOL] return level [EOL] return level [EOL] [EOL] levels = [ get_indentation ( line ) for line in caller_file_lines ] [EOL] [EOL] [comment] [EOL] block_start = block_end = lineno - [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] while block_start > [number] and levels [ block_start ] > [number] : [EOL] [comment] [EOL] block_start -= [number] [EOL] [EOL] while len ( levels ) < block_end and levels [ block_end ] > [number] : [EOL] [comment] [EOL] block_end += [number] [EOL] [EOL] if block_start == block_end : [EOL] [comment] [EOL] [comment] [EOL] block_start = max ( [number] , block_start - context_size ) [EOL] block_end = min ( block_end + context_size , len ( caller_file_lines ) ) [EOL] [EOL] code_block_lines = caller_file_lines [ block_start : block_end + [number] ] [EOL] code_block = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] space_for_linenos = len ( str ( len ( caller_file_lines ) ) ) [EOL] for block_lineno , line in enumerate ( code_block_lines ) : [EOL] cur_lineno = block_start + block_lineno + [number] [EOL] prefix = [string] if cur_lineno == lineno else [string] [EOL] code_block += f"{ prefix } [string] { str ( cur_lineno ) . ljust ( space_for_linenos ) } [string] { line }" [EOL] [EOL] [comment] [EOL] return code_block . rstrip ( ) [EOL] [EOL] [EOL] def _get_caller_frame ( level ) : [EOL] [docstring] [EOL] caller_frame = inspect . currentframe ( ) [EOL] [comment] [EOL] level += [number] [EOL] while level > [number] : [EOL] level -= [number] [EOL] caller_frame = getattr ( caller_frame , [string] ) [EOL] return caller_frame [EOL] [EOL] [EOL] class Notify : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , task , render_outputs = True ) : [EOL] self . _logger = logging . getLogger ( f"{ self . __class__ . __module__ } [string] { self . __class__ . __name__ }" ) [EOL] [EOL] self . task = task [EOL] self . render_outputs = render_outputs [EOL] [EOL] def now ( self , message ) : [EOL] [docstring] [EOL] caller_frame = _get_caller_frame ( [number] ) [EOL] self . _send_notification ( self . task , message , caller_frame , [string] ) [EOL] [EOL] @ contextmanager def when_done ( self , only_if_error = False , capture_output = True , caller_frame = None , reason_prefix = [string] , ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if caller_frame is None : [EOL] [comment] [EOL] [comment] [EOL] caller_frame = _get_caller_frame ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _logger . info ( f" [string] " ) [EOL] [EOL] output_buffer = StringIO ( ) [EOL] output_handler = cast ( ContextManager [ None ] , mirrored_stdstreams ( output_buffer ) if capture_output else nullcontext ( ) , ) [EOL] [EOL] exception = None [EOL] [EOL] [comment] [EOL] try : [EOL] with output_handler : [EOL] yield [EOL] except Exception as current_exception : [EOL] exception = current_exception [EOL] [EOL] output = ( output_buffer . getvalue ( ) [EOL] if capture_output [EOL] else [string] ) [EOL] [EOL] if exception is None and only_if_error : [EOL] self . _logger . info ( f" [string] " ) [EOL] return [EOL] [EOL] if exception is not None : [EOL] self . _send_notification ( self . task , f"{ reason_prefix } [string] " . lstrip ( ) , caller_frame , output , exception , ) [EOL] raise exception [EOL] [EOL] self . _send_notification ( self . task , f"{ reason_prefix } [string] " . lstrip ( ) , caller_frame , output ) [EOL] [EOL] @ contextmanager def every ( self , interval , incremental_output = False , caller_frame = None , ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if caller_frame is None : [EOL] [comment] [EOL] [comment] [EOL] caller_frame = _get_caller_frame ( [number] ) [EOL] [EOL] output_buffer = StringIO ( ) [EOL] output_handler = mirrored_stdstreams ( output_buffer ) [EOL] [EOL] def send_progress ( ) : [EOL] self . _logger . info ( [string] ) [EOL] output = output_buffer . getvalue ( ) [EOL] [comment] [EOL] [comment] [EOL] if incremental_output : [EOL] output_buffer . truncate ( [number] ) [EOL] [EOL] self . _send_notification ( self . task , [string] , caller_frame , output ) [EOL] [EOL] progress_sender = Timer ( send_progress ) [EOL] progress_sender . call_every ( interval ) [EOL] [EOL] try : [EOL] with self . when_done ( False , True , caller_frame = caller_frame ) : [EOL] with output_handler : [EOL] yield [EOL] finally : [EOL] [comment] [EOL] progress_sender . stop ( ) [EOL] [EOL] @ contextmanager def when_stalled ( self , timeout , capture_output = True , caller_frame = None , ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if caller_frame is None : [EOL] [comment] [EOL] [comment] [EOL] caller_frame = _get_caller_frame ( [number] ) [EOL] [EOL] output_buffer = StringIO ( ) [EOL] output_handler = mirrored_stdstreams ( output_buffer ) [EOL] [EOL] last_output = output_buffer . getvalue ( ) [EOL] was_stalled = False [EOL] [EOL] def check_stalled ( ) : [EOL] nonlocal last_output , was_stalled [EOL] [EOL] self . _logger . info ( [string] ) [EOL] [EOL] output = output_buffer . getvalue ( ) [EOL] output_in_notification = ( output_buffer . getvalue ( ) [EOL] if capture_output [EOL] else [string] ) [EOL] if output == last_output and not was_stalled : [EOL] [comment] [EOL] self . _send_notification ( self . task , [string] , caller_frame , output_in_notification ) [EOL] was_stalled = True [EOL] elif was_stalled : [EOL] [comment] [EOL] self . _send_notification ( self . task , [string] , caller_frame , output_in_notification ) [EOL] was_stalled = False [EOL] [EOL] last_output = output [EOL] [EOL] stall_checker = Timer ( check_stalled ) [EOL] stall_checker . call_every ( timeout ) [EOL] [EOL] try : [EOL] with self . when_done ( True , capture_output , caller_frame = caller_frame ) : [EOL] with output_handler : [EOL] yield [EOL] finally : [EOL] [comment] [EOL] stall_checker . stop ( ) [EOL] [EOL] def on_iteration_of ( self , iterable , capture_output = True , after_every = [number] , caller_frame = None , ) : [EOL] [docstring] [EOL] [EOL] if caller_frame is None : [EOL] caller_frame = _get_caller_frame ( [number] ) [EOL] [EOL] total_iterations = str ( len ( iterable ) ) if hasattr ( iterable , [string] ) else [string] [EOL] [EOL] for iteration , item in enumerate ( iterable ) : [EOL] iteration_num = iteration + [number] [EOL] notification_context = nullcontext ( ) [EOL] if ( iteration_num % after_every == [number] or str ( iteration_num ) == total_iterations ) : [EOL] notification_context = self . when_done ( capture_output = capture_output , only_if_error = False , caller_frame = caller_frame , reason_prefix = f" [string] { iteration_num } [string] { total_iterations }" , ) [EOL] [EOL] with notification_context : [EOL] yield item [EOL] [EOL] def _send_notification ( self , task , reason , caller_frame , output , exception = None , ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] [EOL] class NotifyViaEmail ( Notify ) : [EOL] [docstring] [EOL] [EOL] message_template = dedent ( [string] ) [EOL] [docstring] [EOL] [EOL] subject_template = [string] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , task , email_addresses = None , sender = None , smtp_host = None , smtp_port = None , smtp_ssl = None , ) : [EOL] super ( ) . __init__ ( task ) [EOL] [EOL] notify_config = current_config [ [string] ] [EOL] [EOL] if isinstance ( email_addresses , str ) : [EOL] email_addresses = list ( email_addresses ) [EOL] if email_addresses is None : [EOL] email_addresses = notify_config . getlist ( [string] ) [EOL] [EOL] if smtp_host is None : [EOL] smtp_host = notify_config . get ( [string] ) [EOL] [EOL] if smtp_port is None : [EOL] smtp_port = notify_config . getint ( [string] ) [EOL] [EOL] if smtp_ssl is None : [EOL] smtp_ssl = notify_config . getboolean ( [string] ) [EOL] [EOL] if sender is None : [EOL] sender = notify_config . get ( [string] ) [EOL] if not sender : [EOL] sender = f" [string] { getfqdn ( ) }" [EOL] self . sender = sender [EOL] [EOL] if not email_addresses : [EOL] self . _logger . warning ( [string] ) [EOL] self . smtp_class = None [EOL] else : [EOL] self . _logger . info ( f" [string] { email_addresses }" ) [EOL] self . email_addresses = email_addresses [EOL] self . smtp_class = smtplib . SMTP_SSL if smtp_ssl else smtplib . SMTP [EOL] self . smtp_host = smtp_host [EOL] self . smtp_port = smtp_port [EOL] [EOL] def _create_message ( self , recipient , task , reason , caller_frame , output , exception = None , ) : [EOL] if caller_frame is not None : [EOL] code_block = _get_caller_code_fragment ( caller_frame ) [EOL] else : [EOL] code_block = [string] [EOL] [EOL] output = [string] if not output else output [EOL] exinfo = ( f" [string] { str ( exception ) } [string] " [EOL] if exception is not None [EOL] else [string] ) [EOL] [EOL] subject = self . subject_template . format ( task = task , sender = self . sender , recipient = recipient , reason = reason , exinfo = exinfo , code_block = code_block , output = output , ) [EOL] [EOL] content = self . message_template . format ( task = task , sender = self . sender , recipient = recipient , reason = reason , exinfo = exinfo , code_block = code_block , output = output , ) [EOL] [EOL] msg = EmailMessage ( ) [EOL] msg [ [string] ] = subject [EOL] msg [ [string] ] = self . sender [EOL] msg [ [string] ] = recipient [EOL] msg . set_content ( content ) [EOL] msg . set_type ( [string] ) [EOL] return msg [EOL] [EOL] def _send_notification ( self , task , reason , caller_frame , output , exception = None , ) : [EOL] [EOL] if self . render_outputs : [EOL] output = render_text ( output ) [EOL] [EOL] messages = ( self . _create_message ( address , task , reason , caller_frame , output , exception ) for address in self . email_addresses ) [EOL] [EOL] if self . smtp_class is not None : [EOL] [comment] [EOL] try : [EOL] with self . smtp_class ( self . smtp_host , self . smtp_port ) as smtp : [EOL] for message in messages : [EOL] self . _logger . info ( f" [string] { message [ [string] ] }" ) [EOL] smtp . send_message ( message ) [EOL] except Exception as current_exception : [EOL] [comment] [EOL] self . _logger . exception ( f" [string] " , current_exception ) [EOL] [EOL] [EOL] class NotifyViaStream ( Notify ) : [EOL] [docstring] [EOL] [EOL] notification_template = [string] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , task , stream ) : [EOL] super ( ) . __init__ ( task ) [EOL] self . stream = stream [EOL] [EOL] def _send_notification ( self , task , reason , caller_frame , output , exception = None , ) : [EOL] if caller_frame is not None : [EOL] code_block = _get_caller_code_fragment ( caller_frame ) [EOL] else : [EOL] code_block = [string] [EOL] [EOL] output = [string] if not output else output . strip ( ) [EOL] [EOL] if self . render_outputs : [EOL] output = render_text ( output ) [EOL] [EOL] exinfo = f"{ str ( exception ) }" if exception is not None else [string] [EOL] [EOL] content = self . notification_template . format ( task = task , reason = reason , exinfo = exinfo , code_block = code_block , output = output , ) [EOL] [EOL] self . stream . write ( content ) [EOL] [EOL] [EOL] class Timer ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , target , * args , ** kwargs , ) : [EOL] self . target = target [EOL] self . args = args [EOL] self . kwargs = kwargs [EOL] self . interval = - [number] [EOL] self . _stop_event = threading . Event ( ) [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] if self . _stop_event is None : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] self . _stop_event . set ( ) [EOL] [EOL] def call_every ( self , interval ) : [EOL] [docstring] [EOL] [comment] [EOL] if isinstance ( interval , timedelta ) : [EOL] interval = interval . total_seconds ( ) [EOL] [EOL] self . interval = float ( interval ) [EOL] [EOL] self . start ( ) [EOL] [EOL] def run ( self ) : [EOL] if self . interval == - [number] : [EOL] [comment] [EOL] [comment] [EOL] self . target ( * self . args , ** self . kwargs ) [EOL] else : [EOL] while True : [EOL] self . _stop_event . wait ( self . interval ) [EOL] [comment] [EOL] [comment] [EOL] if self . _stop_event . is_set ( ) : [EOL] break [EOL] self . target ( * self . args , ** self . kwargs ) [EOL] [EOL] self . _stop_event . clear ( ) [EOL] self . interval = - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $configparser.SectionProxy$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $email.message.EmailMessage$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[types.FrameType]$ 0 $builtins.str$ 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 $typing.Optional[types.FrameType]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[types.FrameType]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $email.message.EmailMessage$ 0 0 0 0 0 $email.message.EmailMessage$ 0 0 0 0 $builtins.str$ 0 $email.message.EmailMessage$ 0 0 0 0 0 0 0 0 $email.message.EmailMessage$ 0 0 0 0 $builtins.str$ 0 $email.message.EmailMessage$ 0 0 0 $typing.Any$ 0 0 $email.message.EmailMessage$ 0 0 0 0 0 0 0 $email.message.EmailMessage$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[types.FrameType]$ 0 $builtins.str$ 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Generator[email.message.EmailMessage,None,None]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[types.FrameType]$ 0 $builtins.str$ 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[email.message.EmailMessage,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.IO[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.IO[typing.Any]$ 0 $typing.IO[typing.Any]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[types.FrameType]$ 0 $builtins.str$ 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 $typing.Optional[types.FrameType]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[types.FrameType]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0
from typing import TextIO , Any , Generator [EOL] import typing [EOL] import io [EOL] import builtins [EOL] import pytb [EOL] [docstring] [EOL] import sys [EOL] import textwrap [EOL] from io import StringIO [EOL] from typing import Any , TextIO , Union , Generator , cast [EOL] from contextlib import contextmanager [EOL] [EOL] [EOL] class Tee : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args ) : [EOL] [docstring] [EOL] self . _fds = args [EOL] [EOL] def write ( self , text ) : [EOL] [docstring] [EOL] for stream in self . _fds : [EOL] written = stream . write ( text ) [EOL] [EOL] return written [EOL] [EOL] def flush ( self ) : [EOL] [docstring] [EOL] for stream in self . _fds : [EOL] stream . flush ( ) [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] for stream in self . _fds : [EOL] if stream not in [ sys . __stderr__ , sys . __stdout__ ] : [EOL] stream . close ( ) [EOL] [EOL] [EOL] AnyTextIOType = Union [ str , TextIO , Tee ] [EOL] [EOL] [EOL] @ contextmanager def _permissive_open ( file , mode = [string] ) : [EOL] [docstring] [EOL] if isinstance ( file , str ) : [EOL] file_obj = cast ( TextIO , open ( file , mode ) ) [EOL] else : [EOL] file_obj = cast ( TextIO , file ) [EOL] [EOL] try : [EOL] yield file_obj [EOL] finally : [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( file , str ) : [EOL] file_obj . close ( ) [EOL] [EOL] [EOL] @ contextmanager def _redirect_stream ( file , module , attr ) : [EOL] with _permissive_open ( file , [string] ) as out : [EOL] old = getattr ( module , attr ) [EOL] setattr ( module , attr , out ) [EOL] sys . stdout = out [EOL] try : [EOL] yield out [EOL] finally : [EOL] setattr ( module , attr , old ) [EOL] [EOL] [EOL] @ contextmanager def redirected_stdout ( file ) : [EOL] [docstring] [EOL] with _redirect_stream ( file , sys , [string] ) as redirected : [EOL] yield redirected [EOL] [EOL] [EOL] @ contextmanager def redirected_stderr ( file ) : [EOL] [docstring] [EOL] with _redirect_stream ( file , sys , [string] ) as redirected : [EOL] yield redirected [EOL] [EOL] [EOL] @ contextmanager def redirected_stdstreams ( file ) : [EOL] [docstring] [EOL] with _redirect_stream ( file , sys , [string] ) as _redirected_stdout : [EOL] with _redirect_stream ( _redirected_stdout , sys , [string] ) as _redirected_stderr : [EOL] yield _redirected_stderr [EOL] [EOL] [EOL] @ contextmanager def mirrored_stdout ( file ) : [EOL] [docstring] [EOL] with _permissive_open ( file , [string] ) as out : [EOL] tee_piece = Tee ( sys . stdout , out ) [EOL] with redirected_stdout ( tee_piece ) as out : [EOL] yield out [EOL] [EOL] [EOL] @ contextmanager def mirrored_stdstreams ( file ) : [EOL] [docstring] [EOL] with _permissive_open ( file , [string] ) as out : [EOL] tee_piece_out = Tee ( sys . stdout , out ) [EOL] with redirected_stdout ( tee_piece_out ) : [EOL] tee_piece_err = Tee ( sys . stderr , out ) [EOL] with redirected_stderr ( tee_piece_err ) : [EOL] yield out [EOL] [EOL] [EOL] def render_text ( text , maxwidth = - [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] outtext = StringIO ( ) [EOL] for char in text : [EOL] if char == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] outtext . seek ( outtext . getvalue ( ) . rfind ( [string] ) + [number] ) [EOL] [EOL] [comment] [EOL] continue [EOL] if char == [string] : [EOL] [comment] [EOL] [comment] [EOL] outtext . seek ( len ( outtext . getvalue ( ) ) ) [EOL] [EOL] [comment] [EOL] outtext . write ( char ) [EOL] [EOL] rendered_text = outtext . getvalue ( ) [EOL] [EOL] [comment] [EOL] if maxwidth > [number] : [EOL] rendered_text = textwrap . fill ( rendered_text , maxwidth ) [EOL] return rendered_text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.TextIO,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.TextIO,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.TextIO,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.TextIO,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.TextIO,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.TextIO,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import typing [EOL] import configparser [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] [EOL] import sys [EOL] import inspect [EOL] import logging [EOL] from typing import Optional [EOL] from pytb . config import current_config [EOL] from pytb . importlib import NoModuleCacheContext , NotebookLoader [EOL] from pytb . rdb import install_hook as install_rdb [EOL] [EOL] [comment] [EOL] _initializer_frame = None [EOL] [EOL] [EOL] def init ( verbose = True , reinitalisation_attempt_ok = False ) : [EOL] [docstring] [EOL] [EOL] global _initializer_frame [comment] [EOL] [EOL] _logger = logging . getLogger ( __name__ ) [EOL] if verbose : [EOL] _logger . setLevel ( logging . INFO ) [EOL] handler = logging . StreamHandler ( stream = sys . stdout ) [EOL] handler . setLevel ( logging . INFO ) [EOL] _logger . addHandler ( handler ) [EOL] if _initializer_frame : [EOL] reinitialization_message = f" [string] { _initializer_frame . f_code . co_filename } [string] { _initializer_frame . f_code . co_name } [string] { _initializer_frame . f_lineno }" [EOL] [EOL] if reinitalisation_attempt_ok : [EOL] _logger . warning ( f" [string] { reinitialization_message }" ) [EOL] else : [EOL] raise RuntimeError ( reinitialization_message ) [EOL] [EOL] config = current_config [ [string] ] [EOL] [EOL] if config . getboolean ( [string] ) : [EOL] _logger . info ( [string] ) [EOL] NoModuleCacheContext ( ) . __enter__ ( ) [EOL] else : [EOL] _logger . info ( [string] ) [EOL] [EOL] if config . getboolean ( [string] ) : [EOL] _logger . info ( [string] ) [EOL] NotebookLoader . install_hook ( ) [EOL] else : [EOL] _logger . info ( [string] ) [EOL] [EOL] if config . getboolean ( [string] ) : [EOL] _logger . info ( [string] ) [EOL] install_rdb ( ) [EOL] else : [EOL] _logger . info ( [string] ) [EOL] [EOL] [comment] [EOL] _initializer_frame = getattr ( inspect . currentframe ( ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
import unittest [EOL] import doctest [EOL] import unittest [EOL] [EOL] import pytb . notification [EOL] [EOL] suite = unittest . TestSuite ( ) [EOL] suite . addTest ( doctest . DocTestSuite ( pytb . notification ) ) [EOL] [EOL] runner = unittest . TextTestRunner ( verbosity = [number] ) [EOL] runner . run ( suite ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 $unittest.suite.TestSuite$ 0 0
from typing import TextIO , IO [EOL] import unittest [EOL] import typing [EOL] import io [EOL] import pytb [EOL] import doctest [EOL] import unittest [EOL] [EOL] from io import StringIO [EOL] import sys [EOL] import tempfile [EOL] [EOL] import pytb . io [EOL] [EOL] [EOL] class TestTeeManifold ( unittest . TestCase ) : [EOL] def test_tee_piece ( self ) : [EOL] file1 , file2 , file3 = StringIO ( ) , StringIO ( ) , StringIO ( ) [EOL] tee_piece = pytb . io . Tee ( file1 , file2 , file3 ) [EOL] tee_piece . write ( [string] ) [EOL] [EOL] self . assertEqual ( file1 . getvalue ( ) , [string] ) [EOL] self . assertEqual ( file2 . getvalue ( ) , [string] ) [EOL] self . assertEqual ( file3 . getvalue ( ) , [string] ) [EOL] [EOL] def test_tee_piece_closes_files ( self ) : [EOL] file1 , out , err = StringIO ( ) , sys . __stdout__ , sys . __stderr__ [EOL] tee_piece = pytb . io . Tee ( file1 , out , err ) [EOL] tee_piece . close ( ) [EOL] [EOL] self . assertTrue ( file1 . closed ) [EOL] self . assertFalse ( out . closed ) [EOL] self . assertFalse ( err . closed ) [EOL] [EOL] [EOL] class TestIORedirection ( unittest . TestCase ) : [EOL] def test__permissive_open_does_not_close_unopened ( self ) : [EOL] outfile = StringIO ( ) [EOL] with pytb . io . _permissive_open ( outfile ) as file : [EOL] self . assertFalse ( file . closed ) [EOL] self . assertFalse ( file . closed ) [EOL] [EOL] def test__permissive_open_does_close_stringfile ( self ) : [EOL] outfile = tempfile . NamedTemporaryFile ( [string] ) [EOL] with pytb . io . _permissive_open ( outfile . name , [string] ) as file : [EOL] self . assertFalse ( file . closed ) [EOL] self . assertTrue ( file . closed ) [EOL] [EOL] def test__redirect_stream ( self ) : [EOL] outfile = StringIO ( ) [EOL] with pytb . io . _redirect_stream ( outfile , sys , [string] ) : [EOL] print ( [string] ) [EOL] [EOL] with pytb . io . _redirect_stream ( outfile , sys , [string] ) : [EOL] print ( [string] , file = sys . stderr ) [EOL] self . assertEqual ( outfile . getvalue ( ) , [string] ) [EOL] [EOL] def test__redirect_stream_restores_original_state ( self ) : [EOL] old_stdout = sys . stdout [EOL] with pytb . io . _redirect_stream ( sys . stderr , sys , [string] ) : [EOL] self . assertNotEqual ( sys . stdout , old_stdout ) [EOL] self . assertEqual ( sys . stdout , old_stdout ) [EOL] [EOL] def test_mirrored_stdstreams ( self ) : [EOL] outfile , tmp_stdout , tmp_stderr = StringIO ( ) , StringIO ( ) , StringIO ( ) [EOL] with pytb . io . redirected_stdstreams ( outfile ) : [EOL] sys . stdout = pytb . io . Tee ( tmp_stdout , sys . stdout ) [EOL] sys . stderr = pytb . io . Tee ( tmp_stderr , sys . stderr ) [EOL] print ( [string] ) [EOL] print ( [string] , file = sys . stderr ) [EOL] [EOL] self . assertEqual ( tmp_stdout . getvalue ( ) , [string] ) [EOL] self . assertEqual ( tmp_stderr . getvalue ( ) , [string] ) [EOL] [EOL] self . assertEqual ( outfile . getvalue ( ) , [string] ) [EOL] [EOL] [EOL] suite = unittest . TestSuite ( ) [EOL] suite . addTest ( doctest . DocTestSuite ( pytb . io ) ) [EOL] [EOL] runner = unittest . TextTestRunner ( verbosity = [number] ) [EOL] runner . run ( suite ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pytb.io.Tee$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pytb.io.Tee$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pytb.io.Tee$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pytb.io.Tee$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 $unittest.suite.TestSuite$ 0 0
from typing import Any , List [EOL] import unittest [EOL] import typing [EOL] import doctest [EOL] import unittest [EOL] [EOL] import pytb . itertools [EOL] from functools import partial [EOL] [EOL] [EOL] class TestNamedProduct ( unittest . TestCase ) : [EOL] def test_does_safcopy ( self ) : [EOL] def test ( a , b ) : [EOL] pass [EOL] [EOL] a = list ( pytb . itertools . named_product ( { [string] : partial ( test , a = [number] ) , [string] : [ [number] , [number] ] } , [number] , safe_copy = True ) ) [EOL] self . assertIsNot ( a [ [number] ] [ [string] ] , a [ [number] ] [ [string] ] ) [EOL] [EOL] a [ [number] ] [ [string] ] . keywords [ [string] ] = [number] [EOL] self . assertEqual ( a [ [number] ] [ [string] ] . keywords [ [string] ] , [number] ) [EOL] self . assertEqual ( a [ [number] ] [ [string] ] . keywords [ [string] ] , [number] ) [EOL] [EOL] [EOL] suite = unittest . TestSuite ( ) [EOL] suite . addTest ( doctest . DocTestSuite ( pytb . itertools ) ) [EOL] [EOL] runner = unittest . TextTestRunner ( verbosity = [number] ) [EOL] runner . run ( suite ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 $unittest.suite.TestSuite$ 0 0
import unittest [EOL] import doctest [EOL] import unittest [EOL] [EOL] import pytb . config [EOL] [EOL] suite = unittest . TestSuite ( ) [EOL] suite . addTest ( doctest . DocTestSuite ( pytb . config ) ) [EOL] [EOL] runner = unittest . TextTestRunner ( verbosity = [number] ) [EOL] runner . run ( suite ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 $unittest.suite.TestSuite$ 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] import io [EOL] import doctest [EOL] import unittest [EOL] [EOL] import io [EOL] [EOL] from pytb import importlib , test , io as pyio [EOL] [EOL] [EOL] class TestNotebookLoader ( unittest . TestCase ) : [EOL] def test_load_notebook ( self ) : [EOL] out = io . StringIO ( ) [EOL] with pyio . redirected_stdout ( out ) : [EOL] with importlib . NotebookLoader ( ) , importlib . no_module_cache : [EOL] import pytb . test . fixtures . TestNB [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] [EOL] def test_transform_ipython_magic ( self ) : [EOL] out = io . StringIO ( ) [EOL] with pyio . redirected_stdout ( out ) : [EOL] with importlib . NotebookLoader ( ) : [EOL] import pytb . test . fixtures . IPython_TestNB [EOL] self . assertEqual ( out . getvalue ( ) , [string] ) [EOL] [EOL] [EOL] class TestNoModuleCache ( unittest . TestCase ) : [EOL] def test_reload_on_import ( self ) : [EOL] [EOL] from pytb . test . fixtures import random_module [EOL] [EOL] rand_num_one = random_module . random_number [EOL] with importlib . NoModuleCacheContext ( ) : [EOL] from pytb . test . fixtures import random_module [EOL] [EOL] rand_num_two = random_module . random_number [EOL] self . assertNotEqual ( rand_num_one , rand_num_two ) [EOL] [EOL] with importlib . no_module_cache : [EOL] from pytb . test . fixtures import random_module [EOL] [EOL] rand_num_three = random_module . random_number [EOL] self . assertNotEqual ( rand_num_two , rand_num_three ) [EOL] [EOL] [EOL] suite = unittest . TestSuite ( ) [EOL] suite . addTest ( doctest . DocTestSuite ( importlib ) ) [EOL] [EOL] runner = unittest . TextTestRunner ( verbosity = [number] ) [EOL] runner . run ( suite ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 $unittest.suite.TestSuite$ 0 0
import time [EOL] import random [EOL] [EOL] random_number = time . time_ns ( ) [EOL]	0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0