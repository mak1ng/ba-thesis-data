__version__ = [string] [EOL] [EOL] from . sire import sire [comment] [EOL]	$builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] [docstring] [EOL] BADLINES = dict ( readme = [ [string] , [string] [string] , [string] , [string] , ] , mkdocs = [ [string] ] , __init__ = [ [string] , [string] , [string] , ] , flake8 = [ [string] , [string] ] , isort = [ [string] , [string] ] , mypy = [ [string] ] , virtualenv = [ [string] , [string] , [string] ] , git = [ [string] , [string] , [string] , [string] , [string] , ] , codecoverage = [ [string] , [string] , [string] , [string] , [string] , ] , travis = [ [string] ] , black = [ [string] , [string] , [string] ] , setup = [ [string] , [string] , [string] , ] , bumpversion = [ [string] , [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Set , Dict , Any , Mapping , Tuple , Union , Match , Optional [EOL] import argparse [EOL] import os [EOL] import typing [EOL] import subprocess [EOL] import builtins [EOL] [docstring] [EOL] import argparse [EOL] import getpass [EOL] import os [EOL] import re [EOL] import shutil [EOL] import stat [EOL] import subprocess [EOL] import sys [EOL] from typing import Any , Mapping [EOL] [EOL] import requests [EOL] [EOL] from . string_matches import BADLINES [EOL] [EOL] GIT_URLS = dict ( github = [string] , bitbucket = [string] , gitlab = [string] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] PATHS = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] MODULE_TRANSLATION = dict ( codecoverage = [string] , bumpversion = [string] ) [EOL] [EOL] [comment] [EOL] SHORT_PATHS = [ os . path . basename ( os . path . splitext ( i ) [ [number] ] ) . strip ( [string] ) . lower ( ) for i in PATHS ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] EXCLUDE_TRANSLATIONS = dict ( codecov = [string] , coverage = [string] , bump2version = [string] , rtd = [string] , readthedocs = [string] , venv = [string] , docs = [string] , test = [string] , ) [EOL] [EOL] [EOL] class SafeDict ( dict ) : [EOL] [docstring] [EOL] [EOL] def __missing__ ( self , key ) : [EOL] return [string] + key + [string] [EOL] [EOL] [EOL] def _kwargs_to_clean_args ( kwargs ) : [EOL] [docstring] [EOL] exclude = kwargs [ [string] ] or str ( ) [EOL] exclude = { EXCLUDE_TRANSLATIONS . get ( i , i ) for i in exclude . split ( [string] ) } [EOL] for special in { [string] , [string] , [string] } : [EOL] if not kwargs [ special ] : [EOL] print ( f" [string] { special } [string] " ) [EOL] exclude . add ( special ) [EOL] return kwargs [ [string] ] , kwargs [ [string] ] , kwargs [ [string] ] , exclude [EOL] [EOL] [EOL] def _parse_cmdline_args ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] paths = [string] . join ( sorted ( SHORT_PATHS ) ) [EOL] [EOL] parser . add_argument ( [string] , [string] , nargs = [string] , type = str , required = False , help = f" [string] { paths }" , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , default = False , action = [string] , required = False , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , default = False , action = [string] , required = False , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , default = False , action = [string] , required = False , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , nargs = [string] , type = str , required = False , choices = [ [string] , [string] , [string] ] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] [EOL] kwargs = vars ( parser . parse_args ( ) ) [EOL] [EOL] return _kwargs_to_clean_args ( kwargs ) [EOL] [EOL] [EOL] def _locate_templates ( ) : [EOL] [docstring] [EOL] fpath = os . path . dirname ( __file__ ) [EOL] first = os . path . dirname ( fpath ) [EOL] second = os . path . dirname ( first ) [EOL] third = sys . prefix [EOL] fourth = os . path . join ( third , [string] ) [EOL] dirs = [ first , second , third , fourth ] [EOL] for path in dirs : [EOL] if os . path . isdir ( os . path . join ( path , [string] ) ) : [EOL] return os . path . join ( path , [string] ) [EOL] raise ValueError ( f" [string] { dirs }" ) [EOL] [EOL] [EOL] def _obtain_git_username ( git , name ) : [EOL] [docstring] [EOL] if git in { [string] , [string] , [string] } : [EOL] command = f' [string] { git } [string] ' [EOL] namefind = [string] [EOL] else : [EOL] raise NotImplementedError ( f" [string] { git } [string] " ) [EOL] [EOL] [comment] [EOL] prms = dict ( shell = True , stderr = subprocess . PIPE , universal_newlines = True ) [EOL] result = subprocess . run ( command , ** prms ) [EOL] match = re . search ( namefind , result . stderr ) [EOL] if match : [EOL] return match . group ( [number] ) [EOL] [comment] [EOL] guess = getpass . getuser ( ) [EOL] url = GIT_URLS [ git ] . format ( git_username = guess , name = name ) [EOL] if requests . get ( url ) . ok : [EOL] return getpass . getuser ( ) [EOL] return False [EOL] [EOL] [EOL] [comment] [EOL] TEMPLATES = _locate_templates ( ) [EOL] [EOL] [EOL] def _remove_excluded_lines ( formatted , exclude ) : [EOL] [docstring] [EOL] out = list ( ) [EOL] for line in formatted . splitlines ( ) : [EOL] for ex in exclude : [EOL] badlines = BADLINES . get ( ex , list ( ) ) [EOL] if any ( line . startswith ( i ) for i in badlines ) : [EOL] break [EOL] else : [EOL] out . append ( line ) [EOL] return [string] . join ( out ) [EOL] [EOL] [EOL] def _write ( proj , outpath , formatters , exclude ) : [EOL] [docstring] [EOL] fname = os . path . basename ( outpath ) [EOL] template = os . path . join ( TEMPLATES , fname ) [EOL] with open ( template , [string] ) as fo : [EOL] formatted = fo . read ( ) . format_map ( SafeDict ( name = proj , ** formatters ) ) [EOL] [comment] [EOL] if [string] in template : [EOL] deps = { MODULE_TRANSLATION . get ( i , i ) for i in exclude } [EOL] formatted = [string] . join ( i for i in formatted . splitlines ( ) if i not in deps ) [EOL] [comment] [EOL] formatted = _remove_excluded_lines ( formatted , exclude ) [EOL] with open ( os . path . join ( proj , outpath . format ( name = proj ) ) , [string] ) as fo : [EOL] fo . write ( formatted . strip ( ) + [string] ) [EOL] [EOL] [EOL] def _show_todos ( name , paths , exclude , formatters , git ) : [EOL] [docstring] [EOL] todos = [ f" [string] { name } [string] " ] [EOL] if [string] in paths : [EOL] todos . append ( [string] ) [EOL] if [string] not in exclude : [EOL] rtd = [string] [EOL] todos . append ( f" [string] { rtd }" ) [EOL] if [string] not in exclude : [EOL] git_username = formatters . get ( [string] , [string] ) [EOL] git_url = GIT_URLS [ git ] . format ( git_username = git_username , name = name ) [EOL] add_remote = f" [string] { git_url }" [EOL] set_remote = f" [string] { git_url }" [EOL] os . chdir ( name ) [EOL] subprocess . call ( add_remote . split ( ) ) [EOL] print ( f" [string] { git_url }" ) [EOL] subprocess . call ( set_remote . split ( ) ) [EOL] print ( f" [string] { git_url }" ) [EOL] os . chdir ( [string] ) [EOL] form = [string] . join ( todos ) [EOL] [comment] [EOL] cd = f" [string] { name } [string] " [EOL] print ( f" [string] { cd } [string] { form }" ) [EOL] [EOL] [EOL] def _filter_excluded ( exclude ) : [EOL] [docstring] [EOL] if not exclude : [EOL] return PATHS [EOL] [EOL] filtered = set ( ) [EOL] for path in PATHS : [EOL] [comment] [EOL] no_pth = os . path . basename ( path ) . lstrip ( [string] ) [EOL] no_ext = os . path . splitext ( no_pth ) [ [number] ] [EOL] possible = { path , no_pth , no_ext } [EOL] if any ( i in exclude for i in possible ) : [EOL] print ( f" [string] { path } [string] " ) [EOL] continue [EOL] filtered . add ( path ) [EOL] return filtered [EOL] [EOL] [EOL] def _build_virtualenv ( name ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] subprocess . call ( f" [string] { name } [string] { name }" . split ( ) ) [EOL] pip = os . path . abspath ( f"{ name } [string] { name } [string] " ) [EOL] subprocess . call ( f"{ pip } [string] " . split ( ) ) [EOL] subprocess . call ( f"{ pip } [string] { name } [string] " . split ( ) ) [EOL] vfile = os . path . join ( os . path . dirname ( pip ) , [string] ) [EOL] print ( f" [string] { vfile } [string] " ) [EOL] [EOL] [EOL] def _input_wrap ( prompt , default = None ) : [EOL] [docstring] [EOL] while True : [comment] [EOL] result = input ( prompt . format ( default = default ) ) . lower ( ) . strip ( ) [EOL] if result in { [string] , [string] } : [EOL] return True [EOL] if result in { [string] , [string] } : [EOL] return False [EOL] if not result : [EOL] return default [EOL] if result in { [string] , [string] , [string] } : [EOL] raise RuntimeError ( [string] ) [EOL] if not isinstance ( default , bool ) : [EOL] return result [EOL] print ( [string] ) [EOL] [EOL] [EOL] def _interactive ( git , name ) : [EOL] [docstring] [EOL] prompt = ( [string] [string] [string] [string] [string] [string] ) [EOL] _input_wrap ( prompt ) [EOL] output = dict ( ) [EOL] [comment] [EOL] usr = _obtain_git_username ( git , name ) [EOL] email = [string] . split ( ) [EOL] email = subprocess . check_output ( email ) . decode ( [string] ) . strip ( ) [EOL] real_name = [string] . split ( ) [EOL] real_name = subprocess . check_output ( real_name ) . decode ( [string] ) . strip ( ) [EOL] short = [string] . join ( sorted ( SHORT_PATHS ) ) [EOL] exes = f" [string] { short } [string] " [EOL] [EOL] [comment] [EOL] prompts = [ ( [string] , [string] , real_name ) , ( [string] , [string] , usr ) , ( [string] , [string] , email ) , ( [string] , [string] , usr ) , ( [string] , [string] , None ) , ( [string] , [string] , False ) , ( [string] , [string] , False ) , ( [string] , [string] , None ) , ( [string] , exes , set ( ) ) , ] [EOL] [EOL] for field , prompt , default in prompts : [EOL] output [ field ] = _input_wrap ( prompt , default ) [EOL] return output . pop ( [string] ) , output [EOL] [EOL] [EOL] def sire ( name , git = None , interactive = False , exclude = None ) : [EOL] [docstring] [EOL] git , formatters = git , dict ( ) if not interactive else _interactive ( git , name ) [EOL] [EOL] [comment] [EOL] dirname = os . path . abspath ( f" [string] { name }" ) [EOL] print ( f" [string] { dirname } [string] " ) [EOL] [EOL] [comment] [EOL] os . makedirs ( os . path . join ( name , name ) ) [EOL] with open ( os . path . join ( name , name , name + [string] ) , [string] ) as fo : [EOL] fo . write ( [string] ) [EOL] os . makedirs ( os . path . join ( name , [string] ) ) [EOL] with open ( os . path . join ( name , [string] , [string] ) , [string] ) as fo : [EOL] fo . write ( [string] ) [EOL] [EOL] [comment] [EOL] paths = _filter_excluded ( exclude ) [EOL] [EOL] [comment] [EOL] if [string] not in exclude : [EOL] subprocess . call ( f" [string] { name }" . split ( ) ) [EOL] paths . update ( { [string] , [string] } ) [EOL] formatters [ [string] ] = _obtain_git_username ( git , name ) [EOL] [EOL] [comment] [EOL] if [string] not in exclude : [EOL] files = { [string] , [string] , [string] , [string] } [EOL] os . makedirs ( os . path . join ( name , [string] ) ) [EOL] paths . update ( files ) [EOL] [EOL] [comment] [EOL] for path in paths : [EOL] _write ( name , path , formatters , exclude ) [EOL] [EOL] [comment] [EOL] st = os . stat ( f"{ name } [string] " ) [EOL] os . chmod ( f"{ name } [string] " , st . st_mode | stat . S_IEXEC ) [EOL] [EOL] [comment] [EOL] if [string] not in exclude : [EOL] _build_virtualenv ( name ) [EOL] [EOL] [comment] [EOL] _show_todos ( name , paths , exclude , formatters , git ) [EOL] [EOL] [EOL] def wrapped_sire ( * args ) : [EOL] [docstring] [EOL] try : [EOL] sire ( * args ) [EOL] except KeyboardInterrupt : [EOL] print ( [string] ) [EOL] shutil . rmtree ( args [ [number] ] , ignore_errors = True ) [EOL] except Exception : [EOL] print ( [string] ) [EOL] shutil . rmtree ( args [ [number] ] , ignore_errors = True ) [EOL] raise [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] wrapped_sire ( * _parse_cmdline_args ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
import unittest [EOL] [EOL] [EOL] class TestAll ( unittest . TestCase ) : [EOL] def test_something ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] [EOL] class TestAll ( unittest . TestCase ) : [EOL] def test_something ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0