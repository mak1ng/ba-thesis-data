[comment] [EOL] [EOL] from typing import List , Dict , Optional , Any [EOL] import contrib [EOL] import subprocess [EOL] import io [EOL] import typing [EOL] import pathlib [EOL] import os [EOL] from pathlib import Path [EOL] import subprocess [EOL] [EOL] HOME_PATH = os . environ . get ( [string] ) [EOL] [EOL] def _popen ( cmd_arg , env = { } ) : [EOL] devnull = open ( [string] ) [EOL] cmd = subprocess . Popen ( cmd_arg , stdout = subprocess . PIPE , stderr = devnull , env = env ) [EOL] retval = cmd . stdout . read ( ) . strip ( ) [EOL] err = cmd . wait ( ) [EOL] cmd . stdout . close ( ) [EOL] devnull . close ( ) [EOL] if err : [EOL] raise RuntimeError ( [string] % cmd_arg ) [EOL] return retval [EOL] [EOL] [EOL] class CheckSshAgentForCorpRsaKey ( object ) : [EOL] def run ( self ) : [EOL] env = { } [EOL] assert [string] in os . environ [EOL] assert [string] in os . environ [EOL] env . update ( os . environ ) [EOL] cmd = [ [string] , [string] ] [EOL] ret = _popen ( cmd , env = env ) [EOL] assert [string] in ret . decode ( [string] ) [EOL] [EOL] assert [string] in os . environ [EOL] assert [string] in os . environ [EOL] [EOL] molecule_tmp_path = Path ( [string] ) [EOL] ssh_dir_path = Path ( [string] . format ( HOME_PATH ) ) [EOL] known_hosts_path = Path ( [string] . format ( HOME_PATH ) ) [EOL] rsa_corp_git_path = Path ( [string] . format ( HOME_PATH ) ) [EOL] cloudops_beh_app_dev_path = Path ( [string] . format ( HOME_PATH ) ) [EOL] [EOL] assert molecule_tmp_path . exists ( ) [EOL] assert ssh_dir_path . exists ( ) [EOL] assert ssh_dir_path . is_dir ( ) [EOL] assert known_hosts_path . exists ( ) [EOL] assert rsa_corp_git_path . exists ( ) [EOL] assert cloudops_beh_app_dev_path . exists ( ) [EOL] [EOL] procedure = [ CheckSshAgentForCorpRsaKey ( ) ] [EOL] [EOL] for step in procedure : [EOL] step . run ( ) [EOL] [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.List[contrib.doctor.CheckSshAgentForCorpRsaKey]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[contrib.doctor.CheckSshAgentForCorpRsaKey]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import os [EOL] [EOL] assert [string] in os . environ [EOL] assert [string] in os . environ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any [EOL] import subprocess [EOL] import argparse [EOL] import typing [EOL] import io [EOL] [docstring] [EOL] from __future__ import absolute_import , print_function , unicode_literals [EOL] [EOL] import argparse [EOL] import contextlib [EOL] import errno [EOL] import getpass [EOL] import io [EOL] import os [EOL] import pipes [EOL] import re [EOL] import select [EOL] import shutil [EOL] import stat [EOL] import subprocess [EOL] import sys [EOL] import time [EOL] from urllib . parse import urlparse [EOL] [EOL] from typing import Optional , Sequence [EOL] [EOL] PROJECT_DIRECTORY = os . path . realpath ( os . path . curdir ) [EOL] [EOL] REPO = [string] [EOL] [EOL] [EOL] def debug_dump_exclude ( obj , exclude = [ [string] , [string] ] ) : [EOL] for attr in dir ( obj ) : [EOL] if hasattr ( obj , attr ) : [EOL] if attr not in exclude : [EOL] print ( [string] % ( attr , getattr ( obj , attr ) ) ) [EOL] [EOL] class ProcessException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Console : [comment] [EOL] [EOL] quiet = False [EOL] [EOL] @ classmethod def message ( cls , str_format , * args ) : [EOL] if cls . quiet : [EOL] return [EOL] [EOL] if args : [EOL] print ( str_format % args ) [EOL] else : [EOL] print ( str_format ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] sys . stdout . flush ( ) [EOL] [EOL] [EOL] def pquery ( command , stdin = None , ** kwargs ) : [EOL] [comment] [EOL] [comment] [EOL] print ( [string] . join ( command ) ) [EOL] proc = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE , ** kwargs ) [EOL] stdout , _ = proc . communicate ( stdin ) [EOL] [EOL] if proc . returncode != [number] : [EOL] raise ProcessException ( proc . returncode ) [EOL] [EOL] return stdout . decode ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] @ contextlib . contextmanager def cd ( newdir ) : [EOL] prevdir = os . getcwd ( ) [EOL] os . chdir ( newdir ) [EOL] try : [EOL] yield [EOL] finally : [EOL] os . chdir ( prevdir ) [EOL] [EOL] [EOL] def scm ( dir = None ) : [EOL] if not dir : [EOL] dir = os . getcwd ( ) [EOL] [EOL] if os . path . isdir ( os . path . join ( dir , [string] ) ) : [EOL] return [string] [EOL] elif os . path . isdir ( os . path . join ( dir , [string] ) ) : [EOL] return [string] [EOL] [EOL] [EOL] def _popen ( cmd_arg ) : [EOL] devnull = open ( [string] ) [EOL] cmd = subprocess . Popen ( cmd_arg , stdout = subprocess . PIPE , stderr = devnull , shell = True ) [EOL] retval = cmd . stdout . read ( ) . strip ( ) [EOL] err = cmd . wait ( ) [EOL] cmd . stdout . close ( ) [EOL] devnull . close ( ) [EOL] if err : [EOL] raise RuntimeError ( [string] % cmd_arg ) [EOL] return retval [EOL] [EOL] [EOL] def _popen_stdout ( cmd_arg , cwd = None ) : [EOL] [comment] [EOL] cmd = subprocess . Popen ( cmd_arg , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , cwd = cwd , bufsize = [number] , shell = True , ) [EOL] Console . message ( [string] . format ( cmd_arg ) ) [EOL] [comment] [EOL] [EOL] for line in iter ( cmd . stdout . readline , [string] ) : [EOL] [comment] [EOL] _line = line . rstrip ( ) [EOL] Console . message ( [string] . format ( _line . decode ( [string] ) ) ) [EOL] [EOL] Console . message ( [string] . format ( cmd_arg ) ) [EOL] [EOL] def remove_file ( filepath ) : [EOL] os . remove ( os . path . join ( PROJECT_DIRECTORY , filepath ) ) [EOL] [EOL] def wait_for_enter ( text = [string] ) : [EOL] t = input ( text ) [EOL] return t [EOL] [EOL] def check_has_aes256 ( path ) : [comment] [EOL] ansible_vault_tagline = [ ] [EOL] [EOL] with open ( path , [string] ) as f : [EOL] whole_file = f . readlines ( ) [EOL] [EOL] if [string] not in whole_file [ [number] ] . decode ( [string] ) : [EOL] print ( [string] [string] . format ( path = path , file_name = os . path . basename ( path ) ) , file = sys . stderr , ) [EOL] return [number] [EOL] else : [EOL] return [number] [EOL] [EOL] [EOL] def main ( argv = None ) : [comment] [EOL] parser = argparse . ArgumentParser ( description = __doc__ ) [EOL] parser . add_argument ( [string] , nargs = [string] ) [EOL] args = parser . parse_args ( argv ) [EOL] [EOL] retv = [number] [EOL] [EOL] for filename in args . filenames : [EOL] retv |= check_has_aes256 ( filename ) [EOL] [EOL] return retv [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import testinfra . utils . ansible_runner [EOL] [EOL] testinfra_hosts = testinfra . utils . ansible_runner . AnsibleRunner ( os . environ [ [string] ] ) . get_hosts ( [string] ) [EOL] [EOL] [EOL] def test_bundles_when ( host ) : [EOL] c = host . file ( [string] ) . content [EOL] assert [string] in c [EOL] assert [string] not in c [EOL] [EOL] [EOL] def test_bundles_command ( host ) : [EOL] c = host . file ( [string] ) . content [EOL] assert [string] in c [EOL] assert [string] not in c [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Type [EOL] import distutils [EOL] import typing [EOL] from distutils . version import LooseVersion , StrictVersion [EOL] from ansible import errors [EOL] import operator as py_operator [EOL] [EOL] def version_compare ( value , version , operator = [string] , strict = False ) : [EOL] [docstring] [EOL] op_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] if strict : [EOL] Version = StrictVersion [EOL] else : [EOL] Version = LooseVersion [EOL] [EOL] if operator in op_map : [EOL] operator = op_map [ operator ] [EOL] else : [EOL] raise errors . AnsibleFilterError ( [string] ) [EOL] [EOL] try : [EOL] method = getattr ( py_operator , operator ) [EOL] return method ( Version ( str ( value ) ) , Version ( str ( version ) ) ) [EOL] except Exception as e : [EOL] raise errors . AnsibleFilterError ( [string] % e ) [EOL] [EOL] class FilterModule ( object ) : [EOL] def filters ( self ) : [EOL] return { [string] : version_compare } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import re [EOL] from ansible import errors [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def get_var_type ( a_var ) : [EOL] try : [EOL] return str ( type ( a_var ) ) [EOL] except Exception as e : [EOL] raise errors . AnsibleFilterError ( [string] % str ( e ) , str ( a_var ) ) [EOL] [EOL] class FilterModule ( object ) : [EOL] [docstring] [EOL] def filters ( self ) : [EOL] return { [string] : get_var_type } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0