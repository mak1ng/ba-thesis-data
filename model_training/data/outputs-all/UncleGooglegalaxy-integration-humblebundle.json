from typing import Any , Dict [EOL] import asyncio [EOL] import pathlib [EOL] import typing [EOL] import test [EOL] import json [EOL] import os [EOL] from pathlib import Path [EOL] import asyncio [EOL] [EOL] [EOL] CREDENTIALS_FILE = [string] [EOL] [EOL] class RpcChannel : [EOL] def __init__ ( self , reader , writer ) : [EOL] self . reader = reader [EOL] self . writer = writer [EOL] self . _id = [number] [EOL] [EOL] async def _send_notification ( self , name , params ) : [EOL] await self . __call__ ( name , params , use_id = False ) [EOL] [EOL] async def install_game ( self , game_id ) : [EOL] await self . _send_notification ( [string] , { [string] : game_id } ) [EOL] [EOL] async def launch_game ( self , game_id ) : [EOL] await self . _send_notification ( [string] , { [string] : game_id } ) [EOL] [EOL] async def uninstall_game ( self , game_id ) : [EOL] await self . _send_notification ( [string] , { [string] : game_id } ) [EOL] [EOL] async def __call__ ( self , method , params = None , use_id = True ) : [EOL] print ( f' [string] { method } [string] { params }' ) [EOL] msg = { [string] : [string] , [string] : method } [EOL] if use_id : [EOL] self . _id += [number] [EOL] msg [ [string] ] = self . _id [EOL] if params is not None : [EOL] msg [ [string] ] = params [EOL] [EOL] encoded = json . dumps ( msg ) . encode ( ) + [string] [EOL] self . writer . write ( encoded ) [EOL] await self . writer . drain ( ) [EOL] response = await self . reader . readline ( ) [EOL] print ( [string] , response ) [EOL] return response [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] async def run_server_connection ( reader , writer ) : [EOL] [EOL] caller = RpcChannel ( reader , writer ) [EOL] [EOL] path = Path ( CREDENTIALS_FILE ) [EOL] if not path . exists ( ) : [EOL] path . touch ( ) [EOL] [EOL] with open ( CREDENTIALS_FILE , [string] ) as f : [EOL] data = f . read ( ) [EOL] if data : [EOL] credentials = json . loads ( data ) [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] await caller ( [string] , { [string] : { } } ) [EOL] await caller ( [string] , { [string] : credentials } ) [EOL] [comment] [EOL] [comment] [EOL] await caller . install_game ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] async def start_test ( ) : [EOL] await asyncio . start_server ( run_server_connection , [string] , [string] ) [EOL] [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . create_task ( start_test ( ) ) [EOL] loop . run_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0
from typing import Any , Dict , List [EOL] import pathlib [EOL] import typing [EOL] import sys [EOL] import psutil [EOL] import json [EOL] import os [EOL] import subprocess [EOL] import shutil [EOL] from pathlib import Path [EOL] from fog . buildtools import buildtools [EOL] [EOL] from invoke import task [EOL] import github [EOL] from galaxy . tools import zip_folder_to_file [EOL] [EOL] [EOL] with open ( [string] ) as f : [EOL] __version__ = json . load ( f ) [ [string] ] [EOL] [EOL] [EOL] REQUIREMENTS = [string] [EOL] REQUIREMENTS_DEV = [string] [EOL] CURRENT_VERSION_FILE = [string] [EOL] [EOL] GALAXY_PATH = [string] [EOL] DIST_DIR = [string] [EOL] GALAXY_PYTHONPATH = [string] [EOL] [EOL] if sys . platform == [string] : [EOL] PLATFORM = [string] [EOL] GALAXY_PATH = [string] [EOL] DIST_DIR = os . environ [ [string] ] + [string] [EOL] PYTHON = [string] [EOL] GALAXY_PYTHONPATH = str ( Path ( os . path . expandvars ( [string] ) ) / [string] / [string] / [string] ) [EOL] elif sys . platform == [string] : [EOL] PLATFORM = [string] [EOL] GALAXY_PATH = [string] [EOL] DIST_DIR = os . environ [ [string] ] + [string] [EOL] PYTHON = [string] [EOL] [EOL] DIST_PLUGIN = os . path . join ( DIST_DIR , [string] ) [EOL] THIRD_PARTY_RELATIVE_DEST = [string] [EOL] [EOL] [EOL] [EOL] def get_repo ( ) : [EOL] token = os . environ [ [string] ] [EOL] g = github . Github ( token ) [EOL] return g . get_repo ( [string] ) [EOL] [EOL] [EOL] def asset_name ( tag , platform ) : [EOL] return f' [string] { tag } [string] { platform [ : [number] ] . lower ( ) } [string] ' [EOL] [EOL] [EOL] @ task def install ( c , dev = False ) : [EOL] req = REQUIREMENTS_DEV if dev else REQUIREMENTS [EOL] c . run ( f"{ PYTHON } [string] { req }" ) [EOL] [EOL] [EOL] @ task def build ( c , output = [string] ) : [EOL] print ( f' [string] { output } [string] ' ) [EOL] buildtools . build ( output = output , third_party_output = [string] , requirements = REQUIREMENTS ) [EOL] [EOL] [EOL] @ task def dist ( c , output = DIST_PLUGIN , galaxy_path = GALAXY_PATH , no_deps = False ) : [EOL] for proc in psutil . process_iter ( attrs = [ [string] ] , ad_value = [string] ) : [EOL] if proc . info [ [string] ] == galaxy_path : [EOL] print ( f' [string] { galaxy_path } [string] ' ) [EOL] proc . terminate ( ) [EOL] break [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] if no_deps : [EOL] c . run ( f' [string] { output }' ) [EOL] else : [EOL] c . run ( f' [string] { output }' ) [EOL] [EOL] print ( f' [string] { galaxy_path }' ) [EOL] subprocess . Popen ( [ galaxy_path ] ) [EOL] [EOL] [EOL] @ task def debug ( c , output = DIST_PLUGIN , deps = False ) : [EOL] this_plugin = [string] [EOL] for proc in psutil . process_iter ( attrs = [ [string] ] , ad_value = [string] ) : [EOL] if proc . info [ [string] ] == GALAXY_PYTHONPATH : [EOL] if this_plugin in proc . cmdline ( ) [ - [number] ] : [EOL] print ( f' [string] ' ) [EOL] proc . terminate ( ) [EOL] break [EOL] if not deps : [EOL] c . run ( f' [string] { output }' ) [EOL] else : [EOL] c . run ( f' [string] { output }' ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def recursive_overwrite ( src , dest ) : [EOL] if os . path . isdir ( src ) : [EOL] if not os . path . isdir ( dest ) : [EOL] os . makedirs ( dest ) [EOL] files = os . listdir ( src ) [EOL] for f in files : [EOL] recursive_overwrite ( os . path . join ( src , f ) , os . path . join ( dest , f ) ) [EOL] else : [EOL] shutil . copyfile ( src , dest ) [EOL] [EOL] @ task def copy ( c , output = DIST_PLUGIN ) : [EOL] print ( [string] ) [EOL] recursive_overwrite ( [string] , output ) [EOL] [EOL] [EOL] @ task def test ( c , target = None ) : [EOL] print ( f' [string] { target } [string] ' ) [EOL] [EOL] if target is not None : [EOL] config = str ( Path ( __file__ ) . parent / [string] ) [EOL] with open ( config , [string] ) as f : [EOL] f . write ( [string] ) [EOL] f . write ( f" [string] { target }" ) [comment] [EOL] else : [EOL] config = [string] [EOL] [EOL] c . run ( f"{ PYTHON } [string] { config } [string] " ) [EOL] if sys . platform == [string] : [EOL] c . run ( f"{ PYTHON } [string] " ) [EOL] [EOL] if target : [EOL] modules = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] os . environ [ [string] ] = str ( Path ( target ) / THIRD_PARTY_RELATIVE_DEST ) [EOL] modules_full_path = [ str ( Path ( target ) / mod ) for mod in modules ] [EOL] print ( f' [string] { str ( Path ( target ) ) } [string] ' ) [EOL] c . run ( f"{ PYTHON } [string] { [string] . join ( modules_full_path ) } [string] " ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] @ task def archive ( c , zip_name = None , target = None ) : [EOL] if target is None : [EOL] build ( c , [string] ) [EOL] target = [string] [EOL] if zip_name is None : [EOL] zip_name = f' [string] { __version__ } [string] ' [EOL] print ( f' [string] { target } [string] { zip_name } [string] ' ) [EOL] [EOL] zip_folder_to_file ( target , zip_name ) [EOL] zip_path = Path ( [string] ) / zip_name [EOL] return str ( zip_path . resolve ( ) ) [EOL] [EOL] [EOL] @ task def curr_ver ( c , tag = None ) : [EOL] [docstring] [EOL] if tag is None : [EOL] tag = get_repo ( ) . get_latest_release ( ) . tag_name [EOL] content = { [string] : tag , [string] : [ ] } [EOL] for platform in [ [string] , [string] ] : [EOL] name = asset_name ( tag , platform ) [EOL] content [ [string] ] . append ( { [string] : f" [string] { tag } [string] { name }" , [string] : name } ) [EOL] with open ( CURRENT_VERSION_FILE , [string] ) as f : [EOL] json . dump ( content , f , indent = [number] ) [EOL] [EOL] [EOL] @ task ( aliases = [ [string] ] ) def create_tag ( c , tag = None ) : [EOL] if tag is None : [EOL] tag = [string] + __version__ [EOL] branch = c . run ( [string] ) . stdout . strip ( ) [EOL] [EOL] print ( f' [string] { tag } [string] { branch } [string] ' ) [EOL] if input ( [string] ) . lower ( ) != [string] : [EOL] return [EOL] [EOL] print ( f' [string] { tag } [string] ' ) [EOL] c . run ( f' [string] { tag }' ) [EOL] c . run ( f' [string] { tag }' ) [EOL] [EOL] print ( f' [string] { CURRENT_VERSION_FILE } [string] ' ) [EOL] curr_ver ( c , tag ) [EOL] [EOL] [EOL] @ task def release ( c , automa = False ) : [EOL] tag = [string] + __version__ [EOL] if automa : [EOL] print ( f' [string] { PLATFORM } [string] { tag }' ) [EOL] else : [EOL] print ( f' [string] { tag } [string] ' ) [EOL] if input ( [string] ) . lower ( ) != [string] : [EOL] return [EOL] [EOL] repo = get_repo ( ) [EOL] [EOL] for release in repo . get_releases ( ) : [EOL] if release . tag_name == tag and release . draft : [EOL] draft_release = release [EOL] break [EOL] else : [EOL] print ( [string] ) [EOL] if not automa : [EOL] create_tag ( c , tag ) [EOL] [EOL] print ( f' [string] { tag } [string] ' ) [EOL] draft_release = repo . create_git_release ( tag = tag , name = __version__ , message = [string] , draft = True , prerelease = not automa ) [EOL] [EOL] build ( c , output = [string] ) [EOL] test ( c , target = [string] ) [EOL] asset_path = archive ( c , target = [string] , zip_name = asset_name ( tag , PLATFORM ) ) [EOL] [EOL] print ( f' [string] { PLATFORM } [string] { asset_path }' ) [EOL] draft_release . upload_asset ( asset_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import copy [EOL] import re [EOL] [EOL] from model . game import Key [EOL] [EOL] [EOL] class SensitiveFilter ( logging . Filter ) : [EOL] KEY = [string] [EOL] SECRET = [string] [EOL] [EOL] def filter ( self , record ) : [EOL] record . msg = self . redact ( record . msg ) [EOL] if hasattr ( record , self . KEY ) : [EOL] record . redeemed_key_val = self . redact ( record . redeemed_key_val ) [EOL] if hasattr ( record , [string] ) : [EOL] record . game = self . redact ( record . game ) [EOL] if isinstance ( record . args , dict ) : [EOL] for k in record . args . keys ( ) : [EOL] record . args [ k ] = self . redact ( record . args [ k ] ) [EOL] else : [EOL] record . args = tuple ( self . redact ( arg ) for arg in record . args ) [EOL] return True [EOL] [EOL] def redact ( self , msg ) : [EOL] if type ( msg ) == dict : [EOL] if self . KEY in msg : [EOL] msg [ self . KEY ] = self . SECRET [EOL] elif isinstance ( msg , Key ) : [EOL] if self . KEY in msg . _data : [EOL] data_copy = copy . deepcopy ( msg . _data ) [EOL] msg = Key ( data_copy ) [comment] [EOL] msg . _data [ self . KEY ] = self . SECRET [EOL] elif type ( msg ) == str : [EOL] reg = [string] [EOL] msg = re . sub ( reg , rf'{ self . SECRET } [string] ' , msg , flags = re . IGNORECASE ) [EOL] return msg [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Set , List [EOL] import typing [EOL] import enum [EOL] import platform [EOL] import sys [EOL] [EOL] [EOL] class PlatformNotSupported ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SOURCE ( enum . Enum ) : [EOL] DRM_FREE = [string] [EOL] KEYS = [string] [EOL] [EOL] [EOL] class BITNESS ( enum . Enum ) : [EOL] B64 = [number] [EOL] B32 = [number] [EOL] [EOL] [EOL] TROVE_SUBSCRIPTION_NAME = [string] [EOL] [EOL] NON_GAME_BUNDLE_TYPES = { [string] , [string] , [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] IS_WINDOWS = sys . platform == [string] [EOL] IS_MAC = sys . platform == [string] [EOL] [EOL] if platform . machine ( ) . endswith ( [string] ) : [EOL] CURRENT_BITNESS = BITNESS . B64 [EOL] else : [EOL] CURRENT_BITNESS = BITNESS . B32 [EOL] [EOL] COMMA_SPLIT_BLACKLIST = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Optional , List [EOL] import model [EOL] import builtins [EOL] import http [EOL] import typing [EOL] from http . cookies import SimpleCookie [EOL] from http import HTTPStatus [EOL] import typing as t [EOL] import aiohttp [EOL] import json [EOL] import base64 [EOL] import logging [EOL] [EOL] import yarl [EOL] from galaxy . http import create_client_session , handle_exception [EOL] from galaxy . api . errors import UnknownBackendResponse [EOL] [EOL] from model . download import TroveDownload , DownloadStructItem [EOL] from model . subscription import MontlyContentData , ChoiceContentData , ContentChoiceOptions , ChoiceMarketingData , ChoiceMonth [EOL] [EOL] [EOL] class AuthorizedHumbleAPI : [EOL] _AUTHORITY = [string] [EOL] _PROCESS_LOGIN = [string] [EOL] _ORDER_LIST_URL = [string] [EOL] _ORDER_URL = [string] [EOL] [EOL] TROVES_PER_CHUNK = [number] [EOL] _SUBSCRIPTION = [string] [EOL] _SUBSCRIPTION_HOME = [string] [EOL] _SUBSCRIPTION_TROVE = [string] [EOL] _SUBSCRIPTION_PRODUCTS = [string] [EOL] _SUBSCRIPTION_HISTORY = [string] [EOL] _TROVE_CHUNK_URL = [string] [EOL] _DOWNLOAD_SIGN = [string] [EOL] _HUMBLER_REDEEM_DOWNLOAD = [string] [EOL] [EOL] _DEFAULT_HEADERS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] def __init__ ( self ) : [EOL] self . _session = create_client_session ( headers = self . _DEFAULT_HEADERS ) [EOL] [EOL] @ property def is_authenticated ( self ) : [EOL] return bool ( self . _session . cookie_jar ) [EOL] [EOL] async def _request ( self , method , path , * args , ** kwargs ) : [EOL] url = self . _AUTHORITY + path [EOL] logging . debug ( f'{ method } [string] { url } [string] { args } [string] { kwargs }' ) [EOL] with handle_exception ( ) : [EOL] return await self . _session . request ( method , url , * args , ** kwargs ) [EOL] [EOL] async def _is_session_valid ( self ) : [EOL] [docstring] [EOL] with handle_exception ( ) : [EOL] try : [EOL] await self . _session . request ( [string] , self . _AUTHORITY + self . _ORDER_LIST_URL ) [EOL] except aiohttp . ClientResponseError as e : [EOL] if e . status == HTTPStatus . UNAUTHORIZED : [EOL] return False [EOL] raise [EOL] return True [EOL] [EOL] def _decode_user_id ( self , _simpleauth_sess ) : [EOL] info = _simpleauth_sess . split ( [string] ) [ [number] ] [EOL] info += [string] [comment] [EOL] decoded = json . loads ( base64 . b64decode ( info ) ) [EOL] return decoded [ [string] ] [EOL] [EOL] async def authenticate ( self , auth_cookie ) : [EOL] [comment] [EOL] cookie = SimpleCookie ( ) [EOL] cookie_val = bytes ( auth_cookie [ [string] ] , [string] ) . decode ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] cookie_val = cookie_val . replace ( [string] , [string] ) [EOL] cookie [ auth_cookie [ [string] ] ] = cookie_val [EOL] [EOL] self . _session . cookie_jar . update_cookies ( cookie ) [EOL] return self . _decode_user_id ( cookie_val ) [EOL] [EOL] async def get_gamekeys ( self ) : [EOL] res = await self . _request ( [string] , self . _ORDER_LIST_URL ) [EOL] parsed = await res . json ( ) [EOL] logging . info ( f" [string] { parsed }" ) [EOL] gamekeys = [ it [ [string] ] for it in parsed ] [EOL] return gamekeys [EOL] [EOL] async def get_order_details ( self , gamekey ) : [EOL] res = await self . _request ( [string] , self . _ORDER_URL . format ( gamekey ) , params = { [string] : [string] } ) [EOL] return await res . json ( ) [EOL] [EOL] async def _get_trove_details ( self , chunk_index ) : [EOL] res = await self . _request ( [string] , self . _TROVE_CHUNK_URL . format ( chunk_index ) ) [EOL] return await res . json ( ) [EOL] [EOL] async def get_subscription_products_with_gamekeys ( self ) : [EOL] [docstring] [EOL] cursor = [string] [EOL] while True : [EOL] res = await self . _request ( [string] , self . _SUBSCRIPTION_PRODUCTS + f" [string] { cursor }" ) [EOL] if res . status == [number] : [comment] [EOL] return [EOL] res_json = await res . json ( ) [EOL] for product in res_json [ [string] ] : [EOL] if [string] in product : [EOL] yield ContentChoiceOptions ( product ) [EOL] else : [comment] [EOL] [comment] [EOL] return [EOL] cursor = res_json [ [string] ] [EOL] [EOL] async def get_subscription_history ( self , from_product ) : [EOL] [docstring] [EOL] res = await self . _request ( [string] , self . _SUBSCRIPTION_HISTORY . format ( from_product ) ) [EOL] return await res . json ( ) [EOL] [EOL] async def get_previous_subscription_months ( self , from_product ) : [EOL] [docstring] [EOL] while True : [EOL] res = await self . get_subscription_history ( from_product ) [EOL] if res . status == [number] : [EOL] return [EOL] for month in res [ [string] ] : [EOL] yield ChoiceMonth ( month ) [EOL] from_product = month [ [string] ] [EOL] [EOL] async def had_subscription ( self ) : [EOL] [docstring] [EOL] res = await self . _request ( [string] , self . _SUBSCRIPTION_HOME , allow_redirects = False ) [EOL] if res . status == [number] : [EOL] return True [EOL] elif res . status == [number] : [EOL] return False [EOL] else : [EOL] logging . warning ( f'{ self . _SUBSCRIPTION_HOME } [string] { res . status }' ) [EOL] return None [EOL] [EOL] async def _get_webpack_data ( self , path , webpack_id ) : [EOL] res = await self . _request ( [string] , path ) [EOL] txt = await res . text ( ) [EOL] search = f' [string] { webpack_id } [string] ' [EOL] json_start = txt . find ( search ) + len ( search ) [EOL] candidate = txt [ json_start : ] . strip ( ) [EOL] parsed , _ = json . JSONDecoder ( ) . raw_decode ( candidate ) [EOL] return parsed [EOL] [EOL] async def get_montly_trove_data ( self ) : [EOL] [docstring] [EOL] webpack_id = [string] [EOL] return await self . _get_webpack_data ( self . _SUBSCRIPTION_TROVE , webpack_id ) [EOL] [EOL] async def get_choice_marketing_data ( self ) : [EOL] [docstring] [EOL] webpack_id = [string] [EOL] data = await self . _get_webpack_data ( self . _SUBSCRIPTION , webpack_id ) [EOL] return ChoiceMarketingData ( data ) [EOL] [EOL] async def get_choice_content_data ( self , product_url_path ) : [EOL] [docstring] [EOL] url = [string] + product_url_path [EOL] webpack_id = [string] [EOL] data = await self . _get_webpack_data ( url , webpack_id ) [EOL] return ChoiceContentData ( data ) [EOL] [EOL] async def get_montly_content_data ( self , product_url_path ) : [EOL] [docstring] [EOL] url = [string] + product_url_path [EOL] webpack_id = [string] [EOL] data = await self . _get_webpack_data ( url , webpack_id ) [EOL] return MontlyContentData ( data ) [EOL] [EOL] async def get_trove_details ( self , from_chunk = [number] ) : [EOL] index = from_chunk [EOL] while True : [EOL] chunk_details = await self . _get_trove_details ( index ) [EOL] if type ( chunk_details ) != list : [EOL] logging . debug ( f' [string] { chunk_details }' ) [EOL] raise UnknownBackendResponse ( ) [EOL] elif len ( chunk_details ) == [number] : [EOL] logging . debug ( [string] ) [EOL] return [EOL] yield chunk_details [EOL] index += [number] [EOL] [EOL] async def sign_download ( self , machine_name , filename ) : [EOL] res = await self . _request ( [string] , self . _DOWNLOAD_SIGN , params = { [string] : machine_name , [string] : filename } ) [EOL] return await res . json ( ) [EOL] [EOL] async def _reedem_download ( self , download_machine_name , custom_data ) : [EOL] [docstring] [EOL] params = { [string] : download_machine_name , [string] : [string] , } [EOL] params . update ( custom_data ) [EOL] res = await self . _request ( [string] , self . _HUMBLER_REDEEM_DOWNLOAD , params = params ) [EOL] content = await res . read ( ) [EOL] if content != [string] : [EOL] raise UnknownBackendResponse ( f' [string] { content }' ) [EOL] [EOL] @ staticmethod def _filename_from_web_link ( link ) : [EOL] return yarl . URL ( link ) . parts [ - [number] ] [EOL] [EOL] async def sign_url_subproduct ( self , download , download_machine_name ) : [EOL] if download . web is None : [EOL] raise RuntimeError ( f' [string] { download }' ) [EOL] filename = self . _filename_from_web_link ( download . web ) [EOL] urls = await self . sign_download ( download_machine_name , filename ) [EOL] try : [EOL] await self . _reedem_download ( download_machine_name , { [string] : filename } ) [EOL] except Exception as e : [EOL] logging . error ( repr ( e ) + [string] ) [EOL] return urls [EOL] [EOL] async def sign_url_trove ( self , download , product_machine_name ) : [EOL] if download . web is None : [EOL] raise RuntimeError ( f' [string] { download }' ) [EOL] urls = await self . sign_download ( download . machine_name , download . web ) [EOL] try : [EOL] await self . _reedem_download ( download . machine_name , { [string] : product_machine_name } ) [EOL] except Exception as e : [EOL] logging . error ( repr ( e ) + [string] ) [EOL] return urls [EOL] [EOL] async def close_session ( self ) : [EOL] await self . _session . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.dict$ 0 0 0 0 0 $http.cookies.SimpleCookie[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $http.cookies.SimpleCookie[typing.Any]$ 0 $builtins.dict$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $http.cookies.SimpleCookie[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $model.subscription.ChoiceMarketingData$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $model.subscription.ChoiceContentData$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $model.subscription.MontlyContentData$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.dict$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $model.download.DownloadStructItem$ 0 $builtins.str$ 0 0 0 0 $model.download.DownloadStructItem$ 0 0 0 0 0 0 0 0 0 0 0 0 $model.download.DownloadStructItem$ 0 0 0 $typing.Any$ 0 0 0 0 0 $model.download.DownloadStructItem$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $model.download.TroveDownload$ 0 $builtins.str$ 0 0 0 0 $model.download.TroveDownload$ 0 0 0 0 0 0 0 0 0 0 0 0 $model.download.TroveDownload$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $model.download.TroveDownload$ 0 0 0 $model.download.TroveDownload$ 0 0 0 0 0 0 0 0 0 0 0 0 $model.download.TroveDownload$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import consts [EOL] import model [EOL] from model . download import DownloadStructItem , SubproductDownload [EOL] from consts import CURRENT_BITNESS , BITNESS [EOL] [EOL] [EOL] class HumbleDownloadResolver : [EOL] [docstring] [EOL] def __init__ ( self , target_bitness = CURRENT_BITNESS ) : [EOL] if target_bitness == BITNESS . B64 : [EOL] self . _expected_names = [ [string] , [string] , [string] ] [EOL] else : [EOL] self . _expected_names = [ [string] , [string] ] [EOL] [EOL] def __call__ ( self , download ) : [EOL] download_struct = download . download_struct [EOL] if len ( download_struct ) == [number] : [EOL] return download_struct [ [number] ] [EOL] [comment] [EOL] for name in self . _expected_names : [EOL] for dw in download_struct : [EOL] if name == dw . name : [EOL] return dw [EOL] raise NotImplementedError ( f' [string] { download_struct }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $consts.BITNESS$ 0 0 0 0 0 0 $consts.BITNESS$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $model.download.DownloadStructItem$ 0 0 0 $model.download.SubproductDownload$ 0 0 0 0 0 $model.download.SubproductDownload$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Type , Set , Any , Optional [EOL] import consts [EOL] import logging [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] import src [EOL] import pathlib [EOL] import logging [EOL] import os [EOL] import subprocess [EOL] import abc [EOL] from dataclasses import dataclass , field [EOL] from typing import Any , Dict , Optional , Set [EOL] [EOL] import toml [EOL] [EOL] from consts import SOURCE , IS_WINDOWS , IS_MAC [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class UpdateTracker ( abc . ABC ) : [EOL] [docstring] [EOL] __prev = None [EOL] [EOL] def has_changed ( self ) : [EOL] curr = self . serialize ( ) [EOL] if self . __prev != curr : [EOL] self . __prev = curr [EOL] logger . info ( f"{ self . __class__ . __name__ } [string] { curr }" ) [EOL] return True [EOL] return False [EOL] [EOL] def update ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] try : [EOL] self . _update ( * args , ** kwargs ) [EOL] except Exception as e : [EOL] logger . error ( f" [string] { repr ( e ) }" ) [EOL] [EOL] @ abc . abstractmethod def _update ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] @ abc . abstractmethod def serialize ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ dataclass class LibrarySettings ( UpdateTracker ) : [EOL] sources = field ( default_factory = lambda : set ( [ SOURCE . DRM_FREE , SOURCE . KEYS ] ) ) [EOL] show_revealed_keys = False [EOL] [EOL] def _update ( self , library ) : [EOL] sources = library . get ( [string] ) [EOL] show_keys = library . get ( [string] ) [EOL] [EOL] if sources and type ( sources ) != list : [EOL] raise TypeError ( [string] ) [EOL] if show_keys and type ( show_keys ) != bool : [EOL] raise TypeError ( f' [string] { show_keys }' ) [EOL] [EOL] if sources is not None : [EOL] self . sources = set ( [ SOURCE ( s ) for s in sources ] ) [EOL] if show_keys is not None : [EOL] self . show_revealed_keys = show_keys [EOL] [EOL] def serialize ( self ) : [EOL] return { [string] : [ s . value for s in self . sources ] , [string] : self . show_revealed_keys } [EOL] [EOL] [EOL] @ dataclass class InstalledSettings ( UpdateTracker ) : [EOL] search_dirs = field ( default_factory = set ) [EOL] [EOL] def _update ( self , installed ) : [EOL] dirs = installed . get ( [string] , [ ] ) [EOL] [EOL] if type ( dirs ) != list : [EOL] raise TypeError ( [string] ) [EOL] [EOL] dirs_set = set ( ) [EOL] for i in dirs : [EOL] expanded = os . path . expandvars ( i ) [EOL] path = pathlib . Path ( expanded ) . resolve ( ) [EOL] if not path . exists ( ) : [EOL] raise ValueError ( f' [string] { path } [string] ' ) [EOL] dirs_set . add ( path ) [EOL] self . search_dirs = dirs_set [EOL] [EOL] def serialize ( self ) : [EOL] return { [string] : [ str ( i ) for i in self . search_dirs ] } [EOL] [EOL] [EOL] class Settings : [EOL] DEFAULT_CONFIG_FILE = pathlib . Path ( __file__ ) . parent / [string] [comment] [EOL] [EOL] if IS_WINDOWS : [EOL] LOCAL_CONFIG_FILE = pathlib . Path . home ( ) / [string] [EOL] else : [EOL] LOCAL_CONFIG_FILE = pathlib . Path . home ( ) / [string] [EOL] [EOL] def __init__ ( self , suppress_initial_change = False ) : [EOL] self . _last_modification_time = None [EOL] [EOL] self . _library = LibrarySettings ( ) [EOL] self . _installed = InstalledSettings ( ) [EOL] if suppress_initial_change : [EOL] self . _library . has_changed ( ) [EOL] self . _installed . has_changed ( ) [EOL] [EOL] self . _config = self . get_config ( ) [EOL] [EOL] self . reload_config_if_changed ( initial = True ) [EOL] [EOL] @ property def library ( self ) : [EOL] return self . _library [EOL] [EOL] @ property def installed ( self ) : [EOL] return self . _installed [EOL] [EOL] def open_config_file ( self ) : [EOL] logger . info ( [string] ) [EOL] if IS_WINDOWS : [EOL] os . startfile ( self . LOCAL_CONFIG_FILE ) [EOL] elif IS_MAC : [EOL] subprocess . Popen ( [ [string] , [string] , [string] , str ( self . LOCAL_CONFIG_FILE . resolve ( ) ) ] ) [EOL] [EOL] def reload_config_if_changed ( self , initial = False ) : [EOL] if self . _has_config_changed ( ) or initial : [EOL] self . _load_config_file ( ) [EOL] return True [EOL] return False [EOL] [EOL] def _has_config_changed ( self ) : [EOL] path = self . LOCAL_CONFIG_FILE [EOL] try : [EOL] stat = path . stat ( ) [EOL] except FileNotFoundError : [EOL] if self . _last_modification_time is not None : [EOL] logger . warning ( f' [string] { path } [string] ' ) [EOL] self . _last_modification_time = None [EOL] return True [EOL] except Exception as e : [EOL] logger . exception ( f' [string] { path } [string] { repr ( e ) }' ) [EOL] else : [EOL] if stat . st_mtime != self . _last_modification_time : [EOL] self . _last_modification_time = stat . st_mtime [EOL] return True [EOL] return False [EOL] [EOL] def _load_config_file ( self ) : [EOL] try : [EOL] with open ( self . LOCAL_CONFIG_FILE , [string] ) as f : [EOL] self . _config = toml . load ( f ) [EOL] except FileNotFoundError : [EOL] logger . info ( f' [string] ' ) [EOL] except Exception as e : [EOL] logger . error ( f' [string] { self . LOCAL_CONFIG_FILE } [string] { repr ( e ) }' ) [EOL] return [EOL] else : [EOL] logger . info ( f' [string] { self . _config }' ) [EOL] self . _update_objects ( ) [EOL] [EOL] def _update_objects ( self ) : [EOL] self . _library . update ( self . _config . get ( [string] , { } ) ) [EOL] self . _installed . update ( self . _config . get ( [string] , { } ) ) [EOL] [EOL] def get_config ( self ) : [EOL] return { [string] : self . library . serialize ( ) , [string] : self . installed . serialize ( ) } [EOL] [EOL] def _get_config_file_comments ( self ) : [EOL] [docstring] [EOL] comment = [string] [EOL] with open ( self . DEFAULT_CONFIG_FILE , [string] ) as f : [EOL] for line in f . readlines ( ) : [EOL] comment += line [EOL] if line . strip ( ) == [string] : [EOL] break [EOL] return comment [EOL] [EOL] def save_config ( self ) : [EOL] logger . info ( f' [string] { self . LOCAL_CONFIG_FILE }' ) [EOL] self . LOCAL_CONFIG_FILE . parent . mkdir ( parents = True , exist_ok = True ) [EOL] serialized_data = toml . dumps ( self . get_config ( ) ) [EOL] with open ( self . LOCAL_CONFIG_FILE , [string] ) as f : [EOL] f . write ( self . _get_config_file_comments ( ) ) [EOL] f . write ( serialized_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 $src.settings.LibrarySettings$ 0 0 0 0 0 0 0 $src.settings.InstalledSettings$ 0 0 0 0 0 0 0 0 0 0 0 $src.settings.LibrarySettings$ 0 0 0 0 0 0 0 $src.settings.InstalledSettings$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LibrarySettings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $InstalledSettings$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Dict , List , Any , Optional , Match [EOL] import logging [EOL] import builtins [EOL] import pathlib [EOL] import local [EOL] import typing [EOL] import logging [EOL] import re [EOL] import asyncio [EOL] import pathlib [EOL] from typing import Optional , Dict [EOL] [EOL] from local . localgame import LocalHumbleGame [EOL] from local . baseappfinder import BaseAppFinder [EOL] from local . reg_watcher import WinRegUninstallWatcher , UninstallKey [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def location_exists ( location ) : [EOL] [docstring] [EOL] try : [EOL] return location and location . exists ( ) [EOL] except OSError : [EOL] return False [EOL] [EOL] [EOL] class WindowsAppFinder ( BaseAppFinder ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _reg = WinRegUninstallWatcher ( ignore_filter = self . is_other_store_game ) [EOL] [EOL] @ staticmethod def is_other_store_game ( key_name ) : [EOL] [docstring] [EOL] match = re . match ( [string] , key_name ) [comment] [EOL] if match : [EOL] return True [EOL] return [string] in key_name [EOL] [EOL] @ staticmethod def _matches ( human_name , uk ) : [EOL] def escape ( x ) : [EOL] return x . replace ( [string] , [string] ) . lower ( ) [EOL] def escaped_matches ( a , b ) : [EOL] return escape ( a ) == escape ( b ) [EOL] def norm ( x ) : [EOL] return x . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] if human_name == uk . display_name or escaped_matches ( human_name , uk . display_name ) or uk . key_name . lower ( ) . startswith ( human_name . lower ( ) ) : [EOL] return True [EOL] [EOL] location = uk . get_install_location ( ) [EOL] if location : [EOL] if escaped_matches ( human_name , location . name ) : [EOL] return True [EOL] [EOL] [comment] [EOL] return escaped_matches ( norm ( human_name ) , norm ( uk . display_name ) ) [EOL] [EOL] def _find_executable ( self , human_name , uk ) : [EOL] [docstring] [EOL] [comment] [EOL] upath = uk . local_uninstaller_path [EOL] ipath = uk . display_icon_path [EOL] if ipath and ipath . suffix == [string] : [EOL] if ipath != upath and [string] not in str ( ipath ) : [comment] [EOL] return ipath [EOL] [EOL] [comment] [EOL] location = uk . install_location_path or ( upath . parent if upath else None ) or ( ipath . parent if ipath else None ) [EOL] [EOL] [comment] [EOL] if location_exists ( location ) : [EOL] executables = list ( set ( self . _pathfinder . find_executables ( location ) ) - { str ( upath ) } ) [EOL] best_match = self . _pathfinder . choose_main_executable ( human_name , executables ) [EOL] if best_match is None : [EOL] logger . warning ( f' [string] { human_name } [string] { uk . install_location } [string] { upath } [string] { ipath } [string] { executables }' ) [EOL] return None [EOL] return pathlib . Path ( best_match ) [EOL] return None [EOL] [EOL] async def __call__ ( self , owned_title_id , paths = None ) : [EOL] local_games = { } [EOL] not_found = owned_title_id . copy ( ) [EOL] [EOL] [comment] [EOL] self . _reg . refresh ( ) [EOL] while self . _reg . uninstall_keys : [EOL] uk = self . _reg . uninstall_keys . pop ( ) [EOL] try : [EOL] for human_name , machine_name in owned_title_id . items ( ) : [EOL] if self . _matches ( human_name , uk ) : [EOL] exe = self . _find_executable ( human_name , uk ) [EOL] if exe is not None : [EOL] game = LocalHumbleGame ( machine_name , exe , uk . install_location_path , uk . uninstall_string ) [EOL] logger . info ( f' [string] { game }' ) [EOL] local_games [ machine_name ] = game [EOL] del not_found [ human_name ] [EOL] break [EOL] logger . warning ( f" [string] { human_name } [string] { uk }" ) [EOL] except Exception : [EOL] self . _reg . uninstall_keys . add ( uk ) [EOL] raise [EOL] await asyncio . sleep ( [number] ) [comment] [EOL] [EOL] [comment] [EOL] if paths is not None : [EOL] local_games . update ( await super ( ) . __call__ ( not_found , paths ) ) [EOL] [EOL] return local_games	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 $builtins.str$ 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 $builtins.str$ 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 0 0 0 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $local.reg_watcher.UninstallKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,local.localgame.LocalHumbleGame]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[pathlib.Path]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,local.localgame.LocalHumbleGame]$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,local.localgame.LocalHumbleGame]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,local.localgame.LocalHumbleGame]$
from typing import Dict , Iterable , List , Set , Any , Tuple , Union , AsyncGenerator [EOL] import logging [EOL] import builtins [EOL] import pathlib [EOL] import local [EOL] import typing [EOL] import os [EOL] import src [EOL] import logging [EOL] import asyncio [EOL] import difflib [EOL] import time [EOL] import os [EOL] import pathlib [EOL] import abc [EOL] from typing import Dict , Set , Iterable , Union , List , AsyncGenerator , Tuple , NamedTuple [EOL] from typing import cast [EOL] [EOL] from consts import IS_WINDOWS [EOL] from local . pathfinder import PathFinder [EOL] from local . localgame import LocalHumbleGame [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class GameLocation ( NamedTuple ) : [EOL] root = ... [EOL] exe = ... [EOL] [EOL] [EOL] class BaseAppFinder ( abc . ABC ) : [EOL] def __init__ ( self , get_close_matches = None , find_best_exe = None ) : [EOL] self . _pathfinder = PathFinder ( IS_WINDOWS ) [EOL] self . get_close_matches = get_close_matches or self . _get_close_matches [EOL] self . find_best_exe = find_best_exe or self . _find_best_exe [EOL] [EOL] async def __call__ ( self , owned_title_id , paths ) : [EOL] [docstring] [EOL] start = time . time ( ) [EOL] found_games = await self . _scan_folders ( paths , set ( owned_title_id ) ) [EOL] local_games = { owned_title_id [ title ] : LocalHumbleGame ( owned_title_id [ title ] , gl . exe , install_location = gl . root ) for title , gl in found_games . items ( ) } [EOL] logger . debug ( f' [string] { time . time ( ) - start }' ) [EOL] return local_games [EOL] [EOL] async def _scan_folders ( self , paths , app_names ) : [EOL] [docstring] [EOL] not_yet_found = app_names . copy ( ) [EOL] result = { } [EOL] close_matches = { } [EOL] [comment] [EOL] for path in paths : [EOL] async for app_name , install_dir , exe in self . __scan ( path , not_yet_found , similarity = [number] ) : [EOL] result [ app_name ] = GameLocation ( install_dir , exe ) [EOL] [comment] [EOL] for path in paths : [EOL] async for app_name , install_dir , exe in self . __scan ( path , not_yet_found , similarity = [number] ) : [EOL] close_matches [ app_name ] = GameLocation ( install_dir , exe ) [EOL] [comment] [EOL] close_matches . update ( result ) [EOL] return close_matches [EOL] [EOL] async def __scan ( self , path , candidates , similarity ) : [EOL] [docstring] [EOL] root , dirs , _ = next ( os . walk ( path ) ) [EOL] logger . debug ( f' [string] { similarity } [string] { list ( candidates ) }' ) [EOL] for dir_name in dirs : [EOL] await asyncio . sleep ( [number] ) [EOL] matches = self . get_close_matches ( dir_name , candidates , similarity ) [EOL] for app_name in matches : [EOL] dir_path = pathlib . Path ( root ) / dir_name [EOL] best_exe = self . find_best_exe ( dir_path , app_name ) [EOL] if best_exe is None : [EOL] logger . warning ( [string] ) [EOL] continue [EOL] candidates . remove ( app_name ) [EOL] yield app_name , dir_path . resolve ( ) , pathlib . Path ( best_exe ) [EOL] break [EOL] [EOL] def _get_close_matches ( self , dir_name , candidates , similarity ) : [EOL] [docstring] [EOL] matches_ = difflib . get_close_matches ( dir_name , candidates , cutoff = similarity ) [EOL] matches = cast ( List [ str ] , matches_ ) [comment] [EOL] if matches : [EOL] logging . info ( f' [string] { similarity } [string] { dir_name } [string] { matches }' ) [EOL] return matches [EOL] [EOL] def _find_best_exe ( self , dir_path , app_name ) : [EOL] executables = self . _pathfinder . find_executables ( dir_path ) [EOL] if not executables : [EOL] return None [EOL] logging . debug ( f' [string] { executables }' ) [EOL] return self . _pathfinder . choose_main_executable ( app_name , executables ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,local.localgame.LocalHumbleGame]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Set[pathlib.Path]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,src.local.baseappfinder.GameLocation]$ 0 0 0 0 0 0 $typing.Set[pathlib.Path]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,src.local.baseappfinder.GameLocation]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,GameLocation]$ 0 0 0 $typing.Iterable[typing.Union[builtins.str,os.PathLike]]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,GameLocation]$ 0 0 0 0 $typing.Dict[builtins.str,GameLocation]$ 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Union[builtins.str,os.PathLike]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,GameLocation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Union[builtins.str,os.PathLike]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,GameLocation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,GameLocation]$ 0 0 0 $typing.Dict[builtins.str,GameLocation]$ 0 0 0 $typing.Dict[builtins.str,GameLocation]$ 0 0 0 0 $typing.AsyncGenerator[typing.Tuple[builtins.str,pathlib.Path,pathlib.Path],None]$ 0 0 0 $typing.Union[builtins.str,os.PathLike]$ 0 $typing.Set[builtins.str]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,os.PathLike]$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $typing.Set[builtins.str]$ 0 $builtins.float$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Set[builtins.str]$ 0 0 0 $builtins.float$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $pathlib.PurePath$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $pathlib.PurePath$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0
from typing import Set , Dict , Optional , Any [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] import os [EOL] import src [EOL] import os [EOL] import plistlib [EOL] import logging [EOL] from typing import Optional , Dict [EOL] import pathlib [EOL] from dataclasses import dataclass [EOL] [EOL] from local . baseappfinder import BaseAppFinder [EOL] [EOL] [EOL] @ dataclass class BundleInfo : [EOL] location = ... [EOL] exe_name = ... [EOL] name = ... [EOL] [EOL] @ property def executable ( self ) : [EOL] return self . location / [string] / [string] / self . exe_name [EOL] [EOL] [EOL] class MacAppFinder ( BaseAppFinder ) : [EOL] DEFAULT_PATH = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( self . _get_close_matches , self . _find_best_exe ) [EOL] [EOL] async def __call__ ( self , owned_title_id , paths = None ) : [EOL] if paths is None : [EOL] return dict ( ) [EOL] if paths == set ( ) : [EOL] paths = { pathlib . Path ( self . DEFAULT_PATH ) } [EOL] return await super ( ) . __call__ ( owned_title_id , paths ) [EOL] [EOL] def _get_close_matches ( self , dir_name , candidates , similarity ) : [EOL] [docstring] [EOL] dir_name_stem = dir_name [ : - [number] ] if dir_name . endswith ( [string] ) else dir_name [EOL] return super ( ) . _get_close_matches ( dir_name_stem , candidates , similarity ) [EOL] [EOL] def _find_best_exe ( self , dir_path , app_name ) : [EOL] if dir_path . suffix == [string] : [EOL] return self . __parse_bundle ( dir_path ) [EOL] return super ( ) . _find_best_exe ( dir_path , app_name ) [EOL] [EOL] @ staticmethod def __parse_bundle ( app_dir ) : [EOL] dir_ = pathlib . Path ( app_dir ) . resolve ( ) [EOL] try : [EOL] with open ( dir_ / [string] / [string] , [string] ) as f : [EOL] plist = plistlib . load ( f ) [EOL] except ( FileExistsError , OSError ) as e : [EOL] logging . error ( f'{ repr ( e ) }' ) [EOL] return None [EOL] try : [EOL] exe_name = plist [ [string] ] [EOL] except KeyError as e : [EOL] logging . error ( f' [string] { repr ( e ) }' ) [EOL] return None [EOL] try : [EOL] name = plist . get ( [string] , plist [ [string] ] ) [EOL] except KeyError : [EOL] name = pathlib . PurePath ( app_dir ) . stem [EOL] bundle = BundleInfo ( dir_ , exe_name , name ) [EOL] return bundle . executable [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[pathlib.Path]$ 0 0 0 0 0 0 $typing.Set[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[pathlib.Path]$ 0 0 0 0 0 0 $typing.Set[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.PurePath$ 0 $builtins.str$ 0 0 0 0 $pathlib.PurePath$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.PurePath$ 0 0 0 0 0 0 0 0 0 $pathlib.PurePath$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[pathlib.Path]$ 0 $os.PathLike$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $os.PathLike$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $os.PathLike$ 0 0 0 0 $src.local.macappfinder.BundleInfo$ 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $src.local.macappfinder.BundleInfo$ 0 0 0
import logging [EOL] import logging [EOL] [EOL] from consts import IS_MAC , IS_WINDOWS [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] if IS_WINDOWS : [EOL] from local . winappfinder import WindowsAppFinder as AppFinder [comment] [EOL] elif IS_MAC : [EOL] from local . macappfinder import MacAppFinder as AppFinder [comment] [EOL] else : [EOL] raise RuntimeError ( f' [string] ' )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence , Dict , List , Optional , Union [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] import os [EOL] import os [EOL] import logging [EOL] import difflib [EOL] from pathlib import Path , PurePath [EOL] from typing import List , Union , Sequence , Optional [EOL] from typing import cast [EOL] [EOL] [EOL] class PathFinder : [EOL] def __init__ ( self , is_windows ) : [EOL] self . is_windows = is_windows [EOL] [EOL] def find_executables ( self , path ) : [EOL] folder = Path ( path ) [EOL] [EOL] if not folder . exists ( ) : [EOL] raise FileNotFoundError ( f' [string] { path } [string] ' ) [EOL] execs = [ ] [EOL] for root , _ , files in os . walk ( folder ) : [EOL] for path in files : [EOL] whole_path = os . path . join ( root , path ) [EOL] if self . is_exe ( whole_path ) : [EOL] execs . append ( whole_path ) [EOL] break [EOL] return execs [EOL] [EOL] def is_exe ( self , path ) : [EOL] if self . is_windows : [EOL] return path . endswith ( [string] ) [EOL] else : [EOL] return os . access ( path , os . X_OK ) [EOL] [EOL] @ staticmethod def choose_main_executable ( pattern , executables ) : [EOL] if len ( executables ) == [number] : [EOL] return executables [ [number] ] [EOL] [EOL] execs = { PurePath ( k ) . stem . lower ( ) : k for k in executables } [EOL] no_cutoff = [number] [EOL] [EOL] matches_ = difflib . get_close_matches ( pattern . lower ( ) , execs . keys ( ) , cutoff = no_cutoff ) [EOL] matches = cast ( List [ str ] , matches_ ) [comment] [EOL] try : [EOL] best_match = matches [ [number] ] [EOL] except IndexError : [EOL] logging . error ( f' [string] { pattern } [string] { executables }' ) [EOL] return None [EOL] else : [EOL] return execs [ best_match ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Union[builtins.str,os.PathLike]$ 0 0 0 $pathlib.Path$ 0 0 0 $typing.Union[builtins.str,os.PathLike]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,os.PathLike]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $typing.Union[builtins.str,os.PathLike]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[builtins.str,os.PathLike]$ 0 0 0 0 0 $typing.Union[builtins.str,os.PathLike]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0
	0
from typing import Callable , Union [EOL] import builtins [EOL] import typing [EOL] import asyncio [EOL] from contextlib import suppress [EOL] from functools import wraps [EOL] from typing import Callable , Union [EOL] [EOL] [EOL] def double_click_effect ( timeout , effect , * effect_args , ** effect_kwargs ) : [EOL] [docstring] [EOL] def _wrapper ( fn ) : [EOL] @ wraps ( fn ) async def wrap ( * args , ** kwargs ) : [EOL] async def delayed_fn ( ) : [EOL] await asyncio . sleep ( timeout ) [EOL] await fn ( * args , ** kwargs ) [EOL] [EOL] if wrap . task is None or wrap . task . done ( ) or wrap . task . cancelled ( ) : [EOL] wrap . task = asyncio . create_task ( delayed_fn ( ) ) [EOL] with suppress ( asyncio . CancelledError ) : [EOL] await wrap . task [EOL] else : [EOL] wrap . task . cancel ( ) [EOL] if isinstance ( effect , str ) : [comment] [EOL] return getattr ( args [ [number] ] , effect ) ( * effect_args , ** effect_kwargs ) [EOL] else : [EOL] return effect ( * effect_args , ** effect_kwargs ) [EOL] [EOL] wrap . task = None [EOL] return wrap [EOL] return _wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , List [EOL] import model [EOL] import builtins [EOL] import datetime [EOL] import typing [EOL] import src [EOL] import typing as t [EOL] import datetime [EOL] [EOL] from model . game import Key [EOL] from model . types import HP , DeliveryMethod , Tier [EOL] [EOL] [EOL] class UserSubscriptionPlan : [EOL] [docstring] [EOL] def __init__ ( self , data ) : [EOL] self . tier = Tier ( data [ [string] ] ) [EOL] self . machine_name = data [ [string] ] [EOL] self . human_name = data [ [string] ] [EOL] [EOL] [EOL] class ChoiceMarketingData : [EOL] [docstring] [EOL] def __init__ ( self , data ) : [EOL] self . user_options = data [ [string] ] [EOL] self . active_month = ChoiceMonth ( data [ [string] ] [ [string] ] , is_active = True ) [EOL] self . month_details = [ self . active_month ] + [ ChoiceMonth ( month , is_active = False ) for month in data [ [string] ] [ [string] ] ] [EOL] [EOL] [EOL] class ChoiceMonth : [EOL] [docstring] [EOL] def __init__ ( self , data , is_active = False ) : [EOL] self . is_active = is_active [EOL] self . machine_name = data [ [string] ] [EOL] self . short_human_name = data [ [string] ] [EOL] self . monthly_product_page_url = data [ [string] ] [EOL] [EOL] @ property def last_url_part ( self ) : [EOL] return self . monthly_product_page_url . split ( [string] ) [ - [number] ] [EOL] [EOL] [EOL] class Section ( ) : [EOL] [docstring] [EOL] def __init__ ( self , data ) : [EOL] self . id = data [ [string] ] [EOL] self . human_name = data [ [string] ] [EOL] self . delivery_methods = [ DeliveryMethod ( m ) for m in data [ [string] ] ] [EOL] self . platforms = [ HP ( p ) for p in data [ [string] ] ] [EOL] [EOL] [EOL] class ContentChoice : [EOL] [docstring] [EOL] def __init__ ( self , id , data ) : [EOL] self . id = id [EOL] self . title = data [ [string] ] [EOL] self . display_item_machine_name = data [ [string] ] [EOL] self . tpkds = [ Key ( tpkd ) for tpkd in data . get ( [string] , [ ] ) ] [EOL] self . delivery_methods = [ DeliveryMethod ( m ) for m in data [ [string] ] ] [EOL] self . platforms = [ HP ( p ) for p in data [ [string] ] ] [EOL] [EOL] [EOL] class Extras : [EOL] def __init__ ( self , data ) : [EOL] self . human_name = data [ [string] ] [EOL] self . icon_path = data . get ( [string] ) [EOL] self . machine_name = data [ [string] ] [EOL] self . class_ = data [ [string] ] [EOL] self . _types = data [ [string] ] [EOL] [EOL] [EOL] class ContentChoiceOptions : [EOL] def __init__ ( self , data ) : [EOL] self . MAX_CHOICES = data [ [string] ] [EOL] self . gamekey = data . get ( [string] ) [EOL] self . is_active_content = data [ [string] ] [EOL] self . product_url_path = data [ [string] ] [EOL] self . includes_any_uplay_tpkds = data . get ( [string] ) [EOL] self . is_choice_tier = data . get ( [string] ) [comment] [EOL] self . product_machine_name = data [ [string] ] [EOL] self . title = data [ [string] ] [EOL] [EOL] self . unlocked_content_events = data . get ( [string] ) [EOL] [EOL] content_choice_data = data [ [string] ] [EOL] try : [EOL] initial = content_choice_data [ [string] ] [EOL] except KeyError : [comment] [EOL] initial = content_choice_data [ [string] ] [EOL] [EOL] self . content_choices = [ ContentChoice ( id , c ) for id , c in initial [ [string] ] . items ( ) ] [EOL] self . extrases = [ Extras ( extras ) for extras in content_choice_data [ [string] ] ] [EOL] self . _content_choices_made = data . get ( [string] ) [EOL] [EOL] @ property def content_choices_made ( self ) : [EOL] if self . _content_choices_made : [EOL] return self . _content_choices_made [ [string] ] [ [string] ] [EOL] return [ ] [EOL] [EOL] @ property def remained_choices ( self ) : [EOL] if self . _content_choices_made is None : [EOL] return self . MAX_CHOICES [EOL] return self . MAX_CHOICES - len ( self . _content_choices_made ) [EOL] [EOL] [EOL] class MontlyContentData : [EOL] [docstring] [EOL] def __init__ ( self , data ) : [EOL] base = data [ [string] ] [EOL] self . user_options = base [ [string] ] [EOL] plan = base [ [string] ] [EOL] self . user_subscription_plan = UserSubscriptionPlan ( plan ) if plan else None [EOL] [EOL] content = data [ [string] ] [EOL] self . product_human_name = content [ [string] ] [EOL] self . sections = [ Section ( s ) for s in content [ [string] ] ] [EOL] [EOL] [EOL] class ChoiceContentData : [EOL] [docstring] [EOL] def __init__ ( self , data ) : [EOL] self . user_options = data [ [string] ] [EOL] plan = data [ [string] ] [EOL] self . user_subscription_plan = UserSubscriptionPlan ( plan ) if plan else None [EOL] self . pay_early_options = data [ [string] ] [EOL] self . content_choice_options = ContentChoiceOptions ( data [ [string] ] ) [EOL] [EOL] @ property def active_content_start ( self ) : [EOL] try : [EOL] iso = self . pay_early_options [ [string] ] [EOL] except KeyError : [EOL] return None [EOL] return datetime . datetime . fromisoformat ( iso ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $src.model.subscription.ChoiceMonth$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.model.subscription.ChoiceMonth$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $typing.List[model.types.DeliveryMethod]$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $typing.List[model.types.HP]$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[model.types.DeliveryMethod]$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 $typing.List[model.types.HP]$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $builtins.int$ 0 $builtins.dict$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[ContentChoice]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Extras]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $typing.Any$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.dict$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[Section]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 $typing.Any$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 $src.model.subscription.ContentChoiceOptions$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , Dict , Optional , List [EOL] import builtins [EOL] import typing [EOL] from typing import Optional , List [EOL] [EOL] [EOL] class DownloadStructItem ( ) : [EOL] [docstring] [EOL] def __init__ ( self , data ) : [EOL] self . _data = data [EOL] self . url = data . get ( [string] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . __class__ . __name__ } [string] { self . name } [string] " [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self } [string] { self . _data }" [EOL] [EOL] @ property def name ( self ) : [EOL] return self . _data . get ( [string] ) [EOL] [EOL] @ property def web ( self ) : [EOL] if self . url is None : [EOL] return None [EOL] return self . url [ [string] ] [EOL] [EOL] @ property def bittorrent ( self ) : [EOL] if self . url is None : [EOL] return None [EOL] return self . url . get ( [string] ) [EOL] [EOL] @ property def human_size ( self ) : [EOL] return self . _data [ [string] ] [EOL] [EOL] [EOL] class TroveDownload ( DownloadStructItem ) : [EOL] [docstring] [EOL] @ property def human_size ( self ) : [EOL] return self . _data [ [string] ] [EOL] [EOL] @ property def machine_name ( self ) : [EOL] return self . _data [ [string] ] [EOL] [EOL] [EOL] class SubproductDownload ( ) : [EOL] def __init__ ( self , data ) : [EOL] self . _data = data [EOL] self . _download_struct = [ DownloadStructItem ( x ) for x in data [ [string] ] ] [EOL] [EOL] @ property def machine_name ( self ) : [EOL] return self . _data [ [string] ] [EOL] [EOL] @ property def download_struct ( self ) : [EOL] return self . _download_struct [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.dict$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[DownloadStructItem]$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Optional , List [EOL] import model [EOL] import galaxy [EOL] import builtins [EOL] import typing [EOL] import abc [EOL] import logging [EOL] from dataclasses import dataclass , asdict [EOL] from typing import Dict , Optional , Any [EOL] [EOL] from galaxy . api . types import Game , LicenseType , LicenseInfo , SubscriptionGame [EOL] [EOL] from model . types import KEY_TYPE , HP [EOL] from model . download import TroveDownload , SubproductDownload [EOL] [EOL] [EOL] class HumbleGame ( abc . ABC ) : [EOL] def __init__ ( self , data ) : [EOL] self . _data = data [EOL] [EOL] @ abc . abstractproperty def downloads ( self ) : [EOL] pass [EOL] [EOL] def os_compatibile ( self , os ) : [EOL] return os in self . downloads [EOL] [EOL] @ property def human_name ( self ) : [EOL] return self . _data [ [string] ] [EOL] [EOL] @ property def machine_name ( self ) : [EOL] return self . _data [ [string] ] [EOL] [EOL] def in_galaxy_format ( self ) : [EOL] dlcs = [ ] [comment] [EOL] return Game ( self . machine_name , self . human_name , dlcs , self . license ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . __class__ . __name__ } [string] { self . human_name } [string] { self . machine_name }" [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , self . __class__ ) : [EOL] return False [EOL] return self . _data == other . _data [EOL] [EOL] [EOL] class TroveGame ( HumbleGame ) : [EOL] @ property def downloads ( self ) : [EOL] result = { } [EOL] for k , v in self . _data [ [string] ] . items ( ) : [EOL] try : [EOL] os_ = HP ( k ) [EOL] except TypeError as e : [EOL] logging . warning ( e , extra = { [string] : self . _data } ) [EOL] else : [EOL] result [ os_ ] = TroveDownload ( v ) [EOL] return result [EOL] [EOL] @ property def human_name ( self ) : [EOL] return self . _data [ [string] ] [EOL] [EOL] @ property def date_added ( self ) : [EOL] try : [EOL] return int ( self . _data [ [string] ] ) [EOL] except ( ValueError , KeyError ) : [comment] [EOL] return None [EOL] [EOL] def in_galaxy_format ( self ) : [EOL] return SubscriptionGame ( game_title = self . human_name , game_id = self . machine_name , start_time = self . date_added ) [EOL] [EOL] def serialize ( self ) : [EOL] data = { [string] : self . _data [ [string] ] , [string] : self . _data [ [string] ] , [string] : self . _data [ [string] ] , } [EOL] if [string] in self . _data : [EOL] data [ [string] ] = self . _data [ [string] ] [EOL] return data [EOL] [EOL] [EOL] class Subproduct ( HumbleGame ) : [EOL] @ property def downloads ( self ) : [EOL] result = { } [EOL] for dw in self . _data [ [string] ] : [EOL] try : [EOL] os_ = HP ( dw [ [string] ] ) [EOL] except TypeError as e : [EOL] logging . warning ( e , extra = { [string] : self . _data } ) [EOL] else : [EOL] result [ os_ ] = SubproductDownload ( dw ) [EOL] return result [EOL] [EOL] @ property def license ( self ) : [EOL] return LicenseInfo ( LicenseType . SinglePurchase ) [EOL] [EOL] [EOL] class Key ( HumbleGame ) : [EOL] @ property def downloads ( self ) : [EOL] [docstring] [EOL] return { } [EOL] [EOL] @ property def license ( self ) : [EOL] return LicenseInfo ( LicenseType . OtherUserLicense , None ) [EOL] [EOL] @ property def key_type ( self ) : [EOL] key_type = self . _data [ [string] ] [EOL] for typ in KEY_TYPE : [EOL] if typ . value == key_type : [EOL] return key_type [EOL] raise TypeError ( f' [string] { key_type }' ) [EOL] [EOL] @ property def key_type_human_name ( self ) : [EOL] extra_safety_default = [string] [EOL] return self . _data . get ( [string] , extra_safety_default ) [EOL] [EOL] @ property def key_val ( self ) : [EOL] [docstring] [EOL] return self . _data . get ( [string] ) [EOL] [EOL] [EOL] class KeyGame ( Key ) : [EOL] [docstring] [EOL] def __init__ ( self , key , game_id , game_name ) : [EOL] self . _game_name = game_name [EOL] self . _game_id = game_id [EOL] super ( ) . __init__ ( key . _data ) [EOL] [EOL] @ property def human_name ( self ) : [EOL] [docstring] [EOL] key_type = super ( ) . key_type_human_name [EOL] keywords = [ [string] , key_type ] [EOL] for keyword in keywords : [EOL] if keyword in self . _game_name : [EOL] return self . _game_name [EOL] return f'{ self . _game_name } [string] { key_type } [string] ' [EOL] [EOL] @ property def machine_name ( self ) : [EOL] return self . _game_id [EOL] [EOL] [EOL] @ dataclass class ChoiceGame ( HumbleGame ) : [EOL] id = ... [EOL] title = ... [EOL] slug = ... [EOL] is_extras = False [EOL] [EOL] @ property def machine_name ( self ) : [EOL] return self . id [EOL] [EOL] @ property def human_name ( self ) : [EOL] return self . title [EOL] [EOL] @ property def downloads ( self ) : [EOL] [docstring] [EOL] return { } [EOL] [EOL] @ property def presentation_url ( self ) : [EOL] if self . is_extras : [EOL] return f' [string] { self . slug }' [EOL] else : [EOL] return f' [string] { self . slug } [string] { self . id }' [EOL] [EOL] def in_galaxy_format ( self ) : [EOL] return SubscriptionGame ( game_title = self . title , game_id = self . id ) [EOL] [EOL] def serialize ( self ) : [EOL] return asdict ( self ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 $typing.Dict[model.types.HP,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $model.types.HP$ 0 0 0 0 $model.types.HP$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[model.types.HP,model.download.TroveDownload]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[model.types.HP,model.download.SubproductDownload]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $galaxy.api.types.LicenseInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $galaxy.api.types.LicenseInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $model.types.KEY_TYPE$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Key$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $Key$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import src [EOL] import typing [EOL] import enum [EOL] [EOL] [EOL] class HP ( enum . Enum ) : [EOL] WINDOWS = [string] [EOL] MAC = [string] [EOL] LINUX = [string] [EOL] ANDROID = [string] [EOL] AUDIO = [string] [EOL] EBOOK = [string] [EOL] ASMJS = [string] [EOL] UNITYWASM = [string] [EOL] VIDEO = [string] [EOL] COMEDY = [string] [EOL] OCULUS = [string] [EOL] VIVE = [string] [EOL] OTHER = [string] [EOL] _UNRECOGNIZED = [string] [EOL] [EOL] @ classmethod def _missing_ ( cls , value ) : [EOL] return HP . _UNRECOGNIZED [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if type ( other ) == str : [EOL] return self . value == other [EOL] return super ( ) . __eq__ ( other ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . value ) [EOL] [EOL] [EOL] GAME_PLATFORMS = set ( [ HP . WINDOWS , HP . MAC , HP . LINUX ] ) [EOL] [EOL] [EOL] class KEY_TYPE ( enum . Enum ) : [EOL] STEAM = [string] [EOL] ORIGIN = [string] [EOL] UPLAY = [string] [EOL] EPIC = [string] [EOL] BATTLENET = [string] [EOL] GOG = [string] [EOL] [EOL] [EOL] class DeliveryMethod ( enum . Enum ) : [EOL] STEAM = [string] [EOL] ORIGIN = [string] [EOL] UPLAY = [string] [EOL] EPIC = [string] [EOL] BATTLENET = [string] [EOL] GOG = [string] [EOL] DOWNLOAD = [string] [EOL] [EOL] [EOL] class Tier ( enum . Enum ) : [EOL] LITE = [string] [EOL] BASIC = [string] [EOL] PREMIUM = [string] [EOL] CLASSIC = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[src.model.types.HP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
	0
from typing import Any , Dict , Optional [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] [EOL] class Product : [EOL] [docstring] [EOL] def __init__ ( self , data ) : [EOL] self . _data = data [EOL] [EOL] @ property def category ( self ) : [EOL] return self . _data [ [string] ] [EOL] [EOL] @ property def bundle_type ( self ) : [EOL] if self . category != [string] : [EOL] return None [EOL] mn = self . _data [ [string] ] [EOL] return mn . split ( [string] ) [ - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from . baseapp import BaseApp [EOL] from . keys import ShowKey [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple , Literal , Optional , Union [EOL] import src [EOL] import typing_extensions [EOL] import builtins [EOL] import typing [EOL] import webbrowser [EOL] from typing import Optional [EOL] [EOL] from gui . baseapp import BaseApp [EOL] import toga [EOL] [EOL] [EOL] class ShowKey ( BaseApp ) : [EOL] SIZE = ( [number] , [number] ) [EOL] KEYS_URL = [string] [EOL] [EOL] def __init__ ( self , human_name , key_type , key_val = None ) : [EOL] self . _key_type = key_type [EOL] self . _key_val = key_val [EOL] revealed_info = [string] if self . _key_val is None else [string] [EOL] self . _info = f"{ human_name }{ revealed_info } [string] " [EOL] super ( ) . __init__ ( f'{ self . _key_type } [string] ' , self . SIZE , has_menu = False ) [EOL] [EOL] def startup_method ( self ) : [EOL] box = toga . Box ( ) [EOL] info = toga . Label ( self . _info ) [EOL] info . style . padding = [number] [EOL] box . add ( info ) [EOL] if self . _key_val is None : [EOL] el = toga . Button ( [string] , on_press = self . open_keys_url ) [EOL] else : [EOL] el = toga . TextInput ( readonly = True , initial = self . _key_val ) [EOL] el . style . width = [number] [EOL] el . style . padding = [number] [EOL] el . style . flex = [number] [EOL] box . add ( el ) [EOL] return box [EOL] [EOL] def open_keys_url ( self , _ ) : [EOL] print ( [string] , self . KEYS_URL ) [EOL] webbrowser . open ( self . KEYS_URL ) [EOL] [EOL] [EOL] def test ( ) : [EOL] key_data = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] human_name = key_data [ [string] ] [EOL] key_type = key_data [ [string] ] [EOL] key_val = key_data [ [string] ] [EOL] [EOL] app = ShowKey ( human_name , key_type , key_val ) [EOL] app . main_loop ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import builtins [EOL] import typing [EOL] import toga [EOL] import pathlib [EOL] import abc [EOL] from typing import Tuple [EOL] [EOL] import toga [EOL] [EOL] [EOL] class BaseApp ( toga . App , abc . ABC ) : [EOL] APP_ID = [string] [EOL] H_ICON = str ( pathlib . Path ( __file__ ) . resolve ( ) . parent / [string] / [string] ) [EOL] [EOL] def __init__ ( self , window_name , size , * args , has_menu = False , ** kwargs ) : [EOL] self . _app_size = size [EOL] self . _has_menu = has_menu [EOL] super ( ) . __init__ ( window_name , self . APP_ID , icon = self . H_ICON ) [EOL] [EOL] def startup ( self ) : [EOL] self . main_window = toga . MainWindow ( title = self . name , factory = self . factory , size = self . _app_size ) [EOL] self . main_window . content = self . startup_method ( ) [EOL] self . main_window . show ( ) [EOL] [EOL] @ abc . abstractmethod def startup_method ( self ) : [EOL] [docstring] [EOL] [EOL] def _create_impl ( self ) : [EOL] [docstring] [EOL] if self . _has_menu : [EOL] print ( [string] ) [EOL] return super ( ) . _create_impl ( ) [EOL] else : [EOL] factory_app = self . factory . App [EOL] factory_app . create_menus = lambda _ : None [EOL] return factory_app ( interface = self ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $toga.Widget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Tuple , Literal , Optional [EOL] import logging [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] import toga [EOL] import src [EOL] import typing_extensions [EOL] import logging [EOL] import pathlib [EOL] import enum [EOL] from typing import Optional [EOL] [EOL] import toga [EOL] from toga . style import Pack [EOL] [EOL] from gui . baseapp import BaseApp [EOL] from gui . toga_helpers import set_tooltip , LinkLabel , OneColumnTable , OptionContainer [EOL] [EOL] from settings import Settings [EOL] from consts import SOURCE , IS_MAC , IS_WINDOWS [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class OPTIONS_MODE ( enum . Enum ) : [EOL] NORMAL = [string] [EOL] WELCOME = [string] [EOL] NEWS = [string] [EOL] [EOL] [EOL] class Options ( BaseApp ) : [EOL] NAME = [string] [EOL] if IS_WINDOWS : [EOL] SIZE = ( [number] , [number] ) [EOL] TEXT_SIZE = [number] [EOL] TEXT_SIZE_BIG = [number] [EOL] elif IS_MAC : [EOL] SIZE = ( [number] , [number] ) [EOL] TEXT_SIZE = [number] [EOL] TEXT_SIZE_BIG = [number] [EOL] [EOL] def __init__ ( self , mode , changelog_path ) : [EOL] self . _mode = mode [EOL] self . _changelog_path = changelog_path [EOL] self . _cfg = Settings ( suppress_initial_change = True ) [EOL] super ( ) . __init__ ( self . NAME , self . SIZE , has_menu = False ) [EOL] [EOL] def _on_source_switch ( self , el ) : [EOL] logger . info ( f' [string] { el . label } [string] { el . is_on }' ) [EOL] val = SOURCE ( el . label ) [EOL] if el . is_on : [EOL] self . _cfg . library . sources . add ( val ) [EOL] else : [EOL] self . _cfg . library . sources . remove ( val ) [EOL] if val == SOURCE . KEYS : [EOL] self . show_revealed_sw . enabled = el . is_on [EOL] if self . _cfg . library . has_changed ( ) : [EOL] self . _cfg . save_config ( ) [EOL] [EOL] def _on_revealed_switch ( self , el ) : [EOL] logger . info ( f' [string] { el . label } [string] { el . is_on }' ) [EOL] self . _cfg . library . show_revealed_keys = el . is_on [EOL] if self . _cfg . library . has_changed ( ) : [EOL] self . _cfg . save_config ( ) [EOL] [EOL] def __cfg_add_path ( self , raw_path ) : [EOL] [docstring] [EOL] path = pathlib . Path ( raw_path ) . resolve ( ) [EOL] logger . info ( f' [string] { path }' ) [EOL] if str ( path ) in [ row . path for row in self . _paths_table . data ] : [EOL] logger . info ( [string] ) [EOL] return None [EOL] self . _cfg . installed . search_dirs . add ( path ) [EOL] self . _cfg . save_config ( ) [EOL] return str ( path ) [EOL] [EOL] def _add_path ( self , el ) : [EOL] try : [EOL] paths = self . main_window . select_folder_dialog ( [string] , multiselect = True ) [EOL] except ValueError : [EOL] logger . debug ( [string] ) [EOL] return [EOL] for raw_path in paths : [EOL] path = self . __cfg_add_path ( raw_path ) [EOL] if path is None : [EOL] continue [EOL] self . _paths_table . data . append ( path ) [EOL] self . _remove_btn . enabled = self . _paths_table . not_empty [EOL] [EOL] def __cfg_remove_path ( self , raw_path ) : [EOL] path = pathlib . Path ( raw_path ) . resolve ( ) [EOL] logger . info ( f' [string] { path }' ) [EOL] try : [EOL] self . _cfg . installed . search_dirs . remove ( path ) [EOL] except KeyError : [comment] [EOL] logger . error ( f' [string] { path } [string] { self . _cfg . installed . search_dirs }' ) [EOL] else : [EOL] self . _cfg . save_config ( ) [EOL] [EOL] def _remove_paths ( self , _ ) : [EOL] rows = self . _paths_table . selection [EOL] if rows is None : [EOL] try : [EOL] rows = [ self . _paths_table . data [ - [number] ] ] [EOL] except KeyError : [EOL] logger . error ( [string] ) [EOL] return [EOL] for row in rows : [EOL] self . __cfg_remove_path ( row . path ) [EOL] self . _paths_table . data . remove ( row ) [EOL] self . _remove_btn . enabled = self . _paths_table . not_empty [EOL] [EOL] def _library_section ( self ) : [EOL] desc = [string] [string] [EOL] source_help = { SOURCE . DRM_FREE : [string] , SOURCE . KEYS : [string] } [EOL] show_revealed_help = [string] [string] [string] [EOL] [EOL] description = toga . Label ( desc , style = Pack ( font_size = self . TEXT_SIZE_BIG , padding_bottom = [number] ) ) [EOL] rows = [ description ] [EOL] self . show_revealed_sw = toga . Switch ( [string] , on_toggle = self . _on_revealed_switch , is_on = self . _cfg . library . show_revealed_keys , enabled = SOURCE . KEYS in self . _cfg . library . sources , style = Pack ( padding_left = [number] , padding_top = [number] ) ) [EOL] for s in SOURCE : [EOL] sw = toga . Switch ( s . value , on_toggle = self . _on_source_switch , is_on = ( s in self . _cfg . library . sources ) ) [EOL] sw . style . padding_bottom = [number] [EOL] set_tooltip ( sw , source_help [ s ] ) [EOL] rows . append ( sw ) [EOL] set_tooltip ( self . show_revealed_sw , show_revealed_help ) [EOL] rows . append ( self . show_revealed_sw ) [EOL] [EOL] if IS_MAC : [comment] [EOL] inp = toga . MultilineTextInput ( readonly = True , style = Pack ( padding_top = [number] ) ) [EOL] inp . MIN_WIDTH = self . SIZE [ [number] ] - [number] [EOL] for k , v in source_help . items ( ) : [EOL] inp . value += f'{ k . value } [string] { v } [string] ' [EOL] inp . value += f' [string] { show_revealed_help }' [EOL] rows . append ( inp ) [EOL] [EOL] lib_box = toga . Box ( children = rows ) [EOL] lib_box . style . direction = [string] [EOL] lib_box . style . padding_bottom = [number] [EOL] return lib_box [EOL] [EOL] def _installed_section ( self ) : [EOL] desc = [string] [EOL] description = toga . Label ( desc , style = Pack ( font_size = self . TEXT_SIZE_BIG , padding_bottom = [number] ) ) [EOL] if IS_MAC : [EOL] desc_os = [string] [EOL] if IS_WINDOWS : [EOL] desc_os = [string] [EOL] description_os = toga . Label ( desc_os , style = Pack ( font_size = self . TEXT_SIZE_BIG , padding_bottom = [number] ) ) [EOL] [EOL] self . _paths_table = OneColumnTable ( [string] , data = [ str ( p ) for p in self . _cfg . installed . search_dirs ] ) [EOL] [EOL] select_btn = toga . Button ( [string] , on_press = self . _add_path ) [EOL] select_btn . style . flex = [number] [EOL] select_btn . style . padding_bottom = [number] [EOL] self . _remove_btn = toga . Button ( [string] , on_press = self . _remove_paths , enabled = self . _paths_table . not_empty ) [EOL] self . _remove_btn . style . flex = [number] [EOL] config_panel = toga . Box ( children = [ select_btn , self . _remove_btn ] ) [EOL] config_panel . style . direction = [string] [EOL] config_panel . style . padding_top = [number] [EOL] [EOL] paths_container = toga . Box ( children = [ description , description_os , self . _paths_table , config_panel ] ) [EOL] paths_container . style . direction = [string] [EOL] return paths_container [EOL] [EOL] def _about_section ( self ) : [EOL] lbl_style = Pack ( font_size = self . TEXT_SIZE_BIG , text_align = [string] , padding_bottom = [number] ) [EOL] labels = [ toga . Label ( [string] , style = lbl_style ) , LinkLabel ( [string] , style = lbl_style ) , toga . Label ( [string] , style = lbl_style ) ] [EOL] box = toga . Box ( children = labels ) [EOL] box . style . padding = ( self . SIZE [ [number] ] // [number] , self . SIZE [ [number] ] // [number] ) [EOL] box . style . direction = [string] [EOL] box . style . alignment = [string] [EOL] return box [EOL] [EOL] def _news_section ( self ) : [EOL] margin = [number] [EOL] box = toga . Box ( ) [EOL] box . style . padding_bottom = margin [EOL] [EOL] try : [EOL] with open ( self . _changelog_path , [string] ) as f : [EOL] changelog = f . read ( ) [EOL] except FileNotFoundError as e : [EOL] changelog = str ( e ) [EOL] text_box = toga . MultilineTextInput ( readonly = True ) [EOL] text_box . MIN_WIDTH = self . SIZE [ [number] ] - ( [number] * margin ) [EOL] text_box . MIN_HEIGHT = self . SIZE [ [number] ] - ( [number] * margin ) [EOL] text_box . value = changelog [EOL] [EOL] box . add ( text_box ) [EOL] return box [EOL] [EOL] def startup_method ( self ) : [EOL] main_container = OptionContainer ( ) [EOL] [EOL] sections = { [string] : self . _library_section , [string] : self . _installed_section , [string] : self . _news_section , [string] : self . _about_section } [EOL] for name , create_tab_content in sections . items ( ) : [EOL] section = toga . Box ( ) [EOL] section . style . padding = [number] [EOL] section . add ( create_tab_content ( ) ) [EOL] main_container . add ( name , section ) [EOL] [EOL] if self . _mode in [ OPTIONS_MODE . WELCOME , OPTIONS_MODE . NORMAL ] : [EOL] main_container . open_tab ( [number] ) [EOL] if self . _mode == OPTIONS_MODE . NEWS : [EOL] main_container . open_tab ( [number] ) [EOL] [EOL] return main_container [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $toga.Widget$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $toga.Widget$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $toga.Widget$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $toga.Widget$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $toga.Widget$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any , Optional , List [EOL] import builtins [EOL] import typing [EOL] import toga [EOL] import webbrowser [EOL] from typing import Optional [EOL] [EOL] import toga [EOL] [EOL] from consts import IS_WINDOWS , IS_MAC [EOL] [EOL] if IS_WINDOWS : [EOL] from toga_winforms . libs import WinForms , Color [EOL] from toga_winforms . widgets . label import Label as WinFormsLabel [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def set_tooltip ( el , text ) : [EOL] if IS_WINDOWS : [EOL] tt = WinForms . ToolTip ( ) [EOL] tt . IsBalloon = True [EOL] tt . InitialDelay = [number] [EOL] tt . ReshowDelay = [number] [EOL] tt . AutoPopDelay = [number] [EOL] tt . SetToolTip ( el . _impl . native , text ) [EOL] elif IS_MAC : [EOL] pass [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] if IS_WINDOWS : [EOL] class WinformsLinkLabel ( WinFormsLabel ) : [EOL] def create ( self ) : [EOL] self . native = WinForms . LinkLabel ( ) [EOL] self . native . LinkColor = Color . Black [EOL] self . native . LinkClicked += WinForms . LinkLabelLinkClickedEventHandler ( self . interface . _link_clicked ) [EOL] [EOL] [EOL] class LinkLabel ( toga . Label ) : [EOL] def __init__ ( self , text , link = None , id = None , style = None , factory = None ) : [EOL] toga . Widget . __init__ ( self , id = id , style = style , factory = factory ) [EOL] [EOL] if IS_WINDOWS : [EOL] self . _impl = WinformsLinkLabel ( interface = self ) [EOL] elif IS_MAC : [EOL] self . _impl = self . factory . Label ( interface = self ) [EOL] [comment] [EOL] [comment] [EOL] self . _impl . native . selectable = True [EOL] [EOL] self . link = link [EOL] self . text = text [EOL] [EOL] @ property def link ( self ) : [EOL] if self . _link is None : [EOL] return self . text [EOL] return self . _link [EOL] [EOL] @ link . setter def link ( self , link ) : [EOL] self . _link = link [EOL] [EOL] def _link_clicked ( self , el , _ ) : [EOL] webbrowser . open ( self . link ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class OneColumnTable ( toga . Table ) : [EOL] [docstring] [EOL] MIN_WIDTH = [number] [EOL] [EOL] def __init__ ( self , header , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( [ header ] , * args , ** kwargs ) [EOL] self . __set_full_width_one_column ( ) [EOL] [EOL] def __set_full_width_one_column ( self ) : [EOL] if IS_WINDOWS : [EOL] [comment] [EOL] [comment] [EOL] width = self . _impl . native . get_Width ( ) [EOL] [comment] [EOL] self . _impl . native . Columns [ [number] ] . set_Width ( width * [number] ) [EOL] elif IS_MAC : [EOL] pass [comment] [EOL] [EOL] @ property def not_empty ( self ) : [EOL] return len ( self . data ) > [number] [EOL] [EOL] @ property def selection ( self ) : [EOL] [docstring] [EOL] if IS_WINDOWS : [EOL] idcs = self . _impl . native . SelectedIndices [EOL] selected_rows = [ ] [EOL] for i in idcs : [EOL] selected_rows . append ( self . data [ i ] ) [EOL] if len ( selected_rows ) == [number] : [EOL] return None [EOL] return selected_rows [EOL] else : [EOL] sel = super ( ) . selection [EOL] if sel is not None and type ( sel ) != list : [EOL] return [ sel ] [EOL] return sel [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class OptionContainer ( toga . OptionContainer ) : [EOL] def open_tab ( self , index ) : [EOL] if IS_WINDOWS : [EOL] self . _impl . native . SelectTab ( index ) [EOL] elif IS_MAC : [EOL] pass [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.list]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import unittest [EOL] import pathlib [EOL] import typing [EOL] import pytest [EOL] import asyncio [EOL] import pathlib [EOL] import json [EOL] from unittest . mock import MagicMock , Mock [EOL] [EOL] [comment] [EOL] import sys [EOL] sys . path . insert ( [number] , str ( pathlib . PurePath ( __file__ ) . parent . parent / [string] ) ) [EOL] [EOL] from galaxy . api . errors import UnknownError [EOL] from plugin import HumbleBundlePlugin [EOL] from settings import Settings [EOL] [EOL] [EOL] class AsyncMock ( MagicMock ) : [EOL] async def __call__ ( self , * args , ** kwargs ) : [EOL] return super ( AsyncMock , self ) . __call__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] async def aiter ( seq ) : [EOL] [docstring] [EOL] for item in seq : [EOL] yield item [EOL] [EOL] [EOL] @ pytest . fixture def delayed_fn ( ) : [EOL] async def fn ( delay , awaitable , * args , ** kwargs ) : [EOL] await asyncio . sleep ( delay ) [EOL] await awaitable ( * args , ** kwargs ) [EOL] return fn [EOL] [EOL] [EOL] @ pytest . fixture def settings ( mocker ) : [EOL] mocker . patch ( [string] ) [EOL] mock = Settings ( ) [EOL] mock . save_config = Mock ( ) [EOL] return mock [EOL] [EOL] [EOL] @ pytest . fixture def api_mock_raw ( ) : [EOL] mock = MagicMock ( spec = ( ) ) [EOL] mock . authenticate = AsyncMock ( ) [EOL] mock . get_order_details = AsyncMock ( ) [EOL] mock . get_gamekeys = AsyncMock ( ) [EOL] mock . get_montly_trove_data = AsyncMock ( ) [EOL] mock . had_subscription = AsyncMock ( ) [EOL] mock . get_trove_details = AsyncMock ( ) [EOL] mock . sign_url_trove = AsyncMock ( ) [EOL] mock . sign_url_subproduct = AsyncMock ( ) [EOL] mock . close_session = AsyncMock ( ) [EOL] mock . get_choice_content_data = AsyncMock ( ) [EOL] mock . get_choice_month_details = AsyncMock ( return_value = MagicMock ( ) ) [EOL] mock . get_choice_marketing_data = AsyncMock ( return_value = MagicMock ( ) ) [EOL] mock . get_subscription_products_with_gamekeys = AsyncMock ( return_value = MagicMock ( ) ) [EOL] [EOL] return mock [EOL] [EOL] [EOL] @ pytest . fixture def api_mock ( api_mock_raw , orders_keys , get_troves ) : [EOL] mock = api_mock_raw [EOL] mock . orders = orders_keys [EOL] [EOL] def get_details ( gamekey ) : [EOL] for i in mock . orders : [EOL] if i [ [string] ] == gamekey : [EOL] return i [EOL] print ( [string] + gamekey ) [EOL] raise UnknownError ( ) [EOL] [EOL] mock . TROVES_PER_CHUNK = [number] [EOL] mock . get_gamekeys . return_value = [ i [ [string] ] for i in mock . orders ] [EOL] mock . get_order_details . side_effect = get_details [EOL] mock . had_subscription . return_value = True [EOL] mock . get_trove_details . side_effect = lambda from_chunk : get_troves ( from_chunk ) [EOL] [EOL] return mock [EOL] [EOL] [EOL] @ pytest . fixture async def plugin ( api_mock , settings , mocker ) : [EOL] mocker . patch ( [string] , return_value = api_mock ) [EOL] mocker . patch ( [string] , return_value = settings ) [EOL] plugin = HumbleBundlePlugin ( Mock ( ) , Mock ( ) , [string] ) [EOL] plugin . push_cache = Mock ( spec = ( ) ) [EOL] [EOL] plugin . _installed_check . cancel ( ) [EOL] plugin . _statuses_check . cancel ( ) [EOL] plugin . handshake_complete ( ) [EOL] [EOL] yield plugin [EOL] await plugin . shutdown ( ) [EOL] [EOL] [EOL] @ pytest . fixture def get_data ( ) : [EOL] def fn ( source ) : [EOL] path = pathlib . Path ( __file__ ) . parent / [string] / source [EOL] with open ( path , [string] ) as f : [EOL] return json . load ( f ) [EOL] return fn [EOL] [EOL] [EOL] @ pytest . fixture def orders ( get_data ) : [EOL] return get_data ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def orders_keys ( get_data ) : [EOL] return get_data ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def origin_bundle_order ( get_data ) : [EOL] return get_data ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def overgrowth ( get_data ) : [EOL] return get_data ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def get_troves ( get_data ) : [EOL] def fn ( from_index = [number] ) : [EOL] troves = [ ] [EOL] for i in range ( from_index , [number] ) : [EOL] troves . extend ( get_data ( f' [string] { i + [number] } [string] ' ) ) [EOL] return troves [EOL] return fn [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from webservice import AuthorizedHumbleAPI [EOL] [EOL] [EOL] def test_filename_from_web_link ( ) : [EOL] web_link = [string] [EOL] expected = [string] [EOL] assert expected == AuthorizedHumbleAPI . _filename_from_web_link ( web_link ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import unittest [EOL] import typing [EOL] from unittest . mock import MagicMock , Mock [EOL] import pytest [EOL] [EOL] from conftest import aiter , AsyncMock [EOL] [EOL] from galaxy . api . types import SubscriptionGame [EOL] from model . game import TroveGame , ChoiceGame [EOL] from model . subscription import ChoiceContentData , ContentChoiceOptions [EOL] from consts import TROVE_SUBSCRIPTION_NAME [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_trove ( api_mock , plugin ) : [EOL] parsed_from_page = { [string] : [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] } [EOL] api_mock . get_montly_trove_data . return_value = parsed_from_page [EOL] chunks_from_api = [ [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , [ { [string] : [string] , [string] : [string] } , ] , ] [EOL] api_mock . get_trove_details = MagicMock ( return_value = aiter ( chunks_from_api ) ) [EOL] ctx = None [EOL] trove_games = [ ] [EOL] async for bunch in plugin . get_subscription_games ( TROVE_SUBSCRIPTION_NAME , ctx ) : [EOL] trove_games . extend ( bunch ) [EOL] assert sorted ( trove_games , key = lambda x : x . game_id ) == sorted ( [ SubscriptionGame ( game_title = [string] , game_id = [string] ) , SubscriptionGame ( [string] , [string] ) , SubscriptionGame ( [string] , [string] ) , SubscriptionGame ( [string] , [string] ) , SubscriptionGame ( [string] , [string] ) , SubscriptionGame ( [string] , [string] ) , SubscriptionGame ( [string] , [string] ) ] , key = lambda x : x . game_id ) [EOL] assert plugin . _trove_games == { [string] : TroveGame ( { [string] : [string] , [string] : [string] } ) , [string] : TroveGame ( { [string] : [string] , [string] : [string] } ) , [string] : TroveGame ( { [string] : [string] , [string] : [string] } ) , [string] : TroveGame ( { [string] : [string] , [string] : [string] } ) , [string] : TroveGame ( { [string] : [string] , [string] : [string] } ) , [string] : TroveGame ( { [string] : [string] , [string] : [string] } ) , } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_trove_store_in_presistent_cache ( plugin ) : [EOL] plugin . push_cache . reset_mock ( ) [EOL] plugin . _trove_games = { [string] : TroveGame ( { [string] : [string] , [string] : [string] , [string] : { [string] : { } } , [string] : [number] } ) , [string] : TroveGame ( { [string] : [string] , [string] : [string] , [string] : { [string] : { } } } ) , } [EOL] plugin . subscription_games_import_complete ( ) [EOL] assert plugin . persistent_cache [ [string] ] == [string] [string] [string] [string] [EOL] plugin . push_cache . assert_called ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_trove_load_from_persistent_cache ( plugin ) : [EOL] plugin . persistent_cache [ [string] ] = [string] [string] [string] [string] [EOL] plugin . handshake_complete ( ) [EOL] assert plugin . _trove_games == { [string] : TroveGame ( { [string] : [string] , [string] : [string] , [string] : { [string] : { } } } ) , [string] : TroveGame ( { [string] : [string] , [string] : [string] , [string] : { [string] : { } } } ) , } [EOL] [EOL] [EOL] @ pytest . fixture def cco ( ) : [EOL] return Mock ( spec = ContentChoiceOptions ) [EOL] [EOL] [EOL] @ pytest . fixture def choice_data ( cco ) : [EOL] mock = Mock ( spec = ChoiceContentData ) [EOL] mock . content_choice_options = cco [EOL] return mock [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_choice_month_has_remained_choices ( api_mock , plugin , cco , choice_data ) : [EOL] [docstring] [EOL] cco . remained_choices = [number] [EOL] cco . content_choices_made = [ [string] , [string] ] [EOL] cco . content_choices = [ Mock ( ** { [string] : [string] , [string] : [string] } ) , Mock ( ** { [string] : [string] , [string] : [string] } ) , Mock ( ** { [string] : [string] , [string] : [string] } ) , ] [EOL] cco . extrases = [ Mock ( ** { [string] : [string] , [string] : [string] } ) ] [EOL] api_mock . get_choice_content_data = AsyncMock ( return_value = choice_data ) [EOL] ctx = None [EOL] async for one_month_games in plugin . get_subscription_games ( [string] , ctx ) : [EOL] assert one_month_games == [ SubscriptionGame ( game_title = [string] , game_id = [string] ) , SubscriptionGame ( game_title = [string] , game_id = [string] ) , SubscriptionGame ( game_title = [string] , game_id = [string] ) , SubscriptionGame ( game_title = [string] , game_id = [string] ) , ] [EOL] assert plugin . _choice_games == { [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = False ) , [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = False ) , [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = False ) , [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = True ) , } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_choice_month_no_remained_choices ( api_mock , plugin , cco , choice_data ) : [EOL] [docstring] [EOL] cco . remained_choices = [number] [EOL] cco . content_choices_made = [ [string] ] [EOL] cco . content_choices = [ Mock ( ** { [string] : [string] , [string] : [string] } ) , Mock ( ** { [string] : [string] , [string] : [string] } ) , Mock ( ** { [string] : [string] , [string] : [string] } ) , ] [EOL] cco . extrases = [ Mock ( ** { [string] : [string] , [string] : [string] } ) ] [EOL] api_mock . get_choice_content_data = AsyncMock ( return_value = choice_data ) [EOL] ctx = None [EOL] async for one_month_games in plugin . get_subscription_games ( [string] , ctx ) : [EOL] assert one_month_games == [ SubscriptionGame ( game_title = [string] , game_id = [string] ) , SubscriptionGame ( game_title = [string] , game_id = [string] ) , ] [EOL] assert plugin . _choice_games == { [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = False ) , [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = True ) , } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_choice_store_in_presistent_cache ( plugin ) : [EOL] plugin . push_cache . reset_mock ( ) [EOL] plugin . _choice_games = { [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = False ) , [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = True ) , } [EOL] plugin . subscription_games_import_complete ( ) [EOL] assert plugin . persistent_cache [ [string] ] == [string] [string] [string] [string] [EOL] plugin . push_cache . assert_called ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_choice_load_from_persistent_cache ( plugin ) : [EOL] plugin . persistent_cache [ [string] ] = [string] [string] [string] [string] [EOL] plugin . handshake_complete ( ) [EOL] assert plugin . _choice_games == { [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = False ) , [string] : ChoiceGame ( id = [string] , title = [string] , slug = [string] , is_extras = True ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] import pytest [EOL] from unittest . mock import patch , Mock , PropertyMock [EOL] import pathlib [EOL] [EOL] from galaxy . api . consts import OSCompatibility as OSC [EOL] from galaxy . api . types import GameLibrarySettings [EOL] [EOL] from consts import IS_WINDOWS , IS_MAC [EOL] from local . localgame import LocalHumbleGame [EOL] from model . game import Subproduct , KeyGame , TroveGame , ChoiceGame [EOL] from model . download import TroveDownload [EOL] from model . types import HP [EOL] [EOL] from conftest import AsyncMock [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_launch_game ( plugin , overgrowth ) : [EOL] id_ = overgrowth [ [string] ] [ [string] ] [EOL] plugin . _local_games = { id_ : LocalHumbleGame ( id_ , pathlib . Path ( [string] ) / [string] ) } [EOL] with patch ( [string] ) as subproc : [EOL] with patch ( [string] ) : [EOL] await plugin . launch_game ( id_ ) [EOL] if IS_WINDOWS : [EOL] subproc . assert_called_once_with ( [string] , creationflags = [number] , cwd = pathlib . Path ( [string] ) ) [EOL] elif IS_MAC : [EOL] subproc . assert_called_once ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_uninstall_game ( plugin , overgrowth ) : [EOL] id_ = overgrowth [ [string] ] [ [string] ] [EOL] plugin . _local_games = { id_ : LocalHumbleGame ( id_ , Mock ( ) , uninstall_cmd = [string] ) } [EOL] with patch ( [string] ) as subproc : [EOL] await plugin . uninstall_game ( id_ ) [EOL] subproc . assert_called_once_with ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_install_game_drm_free ( api_mock , plugin , overgrowth ) : [EOL] id_ = overgrowth [ [string] ] [ [string] ] [EOL] subproduct = overgrowth [ [string] ] [ [number] ] [EOL] game = Subproduct ( subproduct ) [EOL] plugin . _owned_games = { id_ : game } [EOL] expected_url = [string] [EOL] api_mock . sign_url_subproduct . return_value = { [string] : expected_url } [EOL] [EOL] with patch ( [string] ) as browser_open : [EOL] await plugin . install_game ( id_ ) [EOL] browser_open . assert_called_once_with ( expected_url ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_install_game_trove ( api_mock , plugin ) : [EOL] id_ = [string] [EOL] platform = HP . WINDOWS if IS_WINDOWS else HP . MAC [EOL] game = Mock ( spec = TroveGame , downloads = { platform : Mock ( spec = TroveDownload ) } ) [EOL] plugin . _owned_games = { id_ : game } [EOL] expected_url = [string] [EOL] api_mock . sign_url_trove . return_value = { [string] : expected_url } [EOL] [EOL] with patch ( [string] ) as browser_open : [EOL] await plugin . install_game ( id_ ) [EOL] browser_open . assert_called_once_with ( expected_url ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_install_game_choice ( plugin ) : [EOL] id_ = [string] [EOL] game = ChoiceGame ( id_ , [string] , [string] ) [EOL] plugin . _choice_games = { id_ : game } [EOL] expected_url = [string] [EOL] with patch ( [string] ) as browser_open : [EOL] await plugin . install_game ( id_ ) [EOL] browser_open . assert_called_once_with ( expected_url ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_install_game_choice_extras ( plugin ) : [EOL] [docstring] [EOL] id_ = [string] [EOL] game = ChoiceGame ( id_ , [string] , [string] , is_extras = True ) [EOL] plugin . _choice_games = { id_ : game } [EOL] expected_url = [string] [EOL] with patch ( [string] ) as browser_open : [EOL] await plugin . install_game ( id_ ) [EOL] browser_open . assert_called_once_with ( expected_url ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_os_compatibility ( plugin , overgrowth ) : [EOL] ovg_id = overgrowth [ [string] ] [ [string] ] [EOL] subproduct = overgrowth [ [string] ] [ [number] ] [EOL] game = Subproduct ( subproduct ) [EOL] [EOL] no_downloads_id = [string] [EOL] no_dw_game = Subproduct ( { [string] : [string] , [string] : no_downloads_id , [string] : [ ] } ) [EOL] [EOL] key_game_id = [string] [EOL] key_game = Mock ( spec = KeyGame ) [EOL] [EOL] plugin . _owned_games = { ovg_id : game , no_downloads_id : no_dw_game , key_game_id : key_game } [EOL] [EOL] ctx = await plugin . prepare_os_compatibility_context ( plugin . _owned_games . keys ( ) ) [EOL] assert await plugin . get_os_compatibility ( no_downloads_id , ctx ) == None [EOL] assert await plugin . get_os_compatibility ( ovg_id , ctx ) == OSC . Windows | OSC . MacOS | OSC . Linux [EOL] assert await plugin . get_os_compatibility ( key_game_id , ctx ) == OSC . Windows | OSC . MacOS | OSC . Linux [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_library_settings_key ( plugin ) : [EOL] trove = Mock ( spec = TroveGame ) [EOL] drm_free = Mock ( spec = Subproduct ) [EOL] key = Mock ( spec = KeyGame ) [EOL] type ( key ) . key_val = PropertyMock ( return_value = [string] ) [EOL] unrevealed_key = Mock ( spec = KeyGame ) [EOL] type ( unrevealed_key ) . key_val = PropertyMock ( return_value = None ) [EOL] [EOL] plugin . _owned_games = { [string] : drm_free , [string] : trove , [string] : key , [string] : unrevealed_key } [EOL] [EOL] ctx = await plugin . prepare_game_library_settings_context ( [ [string] , [string] , [string] , [string] ] ) [EOL] assert await plugin . get_game_library_settings ( [string] , ctx ) == GameLibrarySettings ( [string] , None , None ) [EOL] assert await plugin . get_game_library_settings ( [string] , ctx ) == GameLibrarySettings ( [string] , [ ] , None ) [EOL] assert await plugin . get_game_library_settings ( [string] , ctx ) == GameLibrarySettings ( [string] , [ [string] ] , None ) [EOL] assert await plugin . get_game_library_settings ( [string] , ctx ) == GameLibrarySettings ( [string] , [ [string] , [string] ] , None ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_local_size ( plugin ) : [EOL] local_game_mock = Mock ( spec = LocalHumbleGame ) [EOL] local_game_mock . get_size = AsyncMock ( return_value = [number] ) [EOL] plugin . _local_games = { [string] : local_game_mock } [EOL] ctx = await plugin . prepare_local_size_context ( [ [string] ] ) [EOL] assert await plugin . get_local_size ( [string] , ctx ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import tests [EOL] import typing [EOL] from unittest . mock import mock_open , patch [EOL] from pathlib import Path [EOL] from dataclasses import dataclass [EOL] import pytest [EOL] [EOL] from settings import UpdateTracker , Settings , InstalledSettings , LibrarySettings [EOL] from consts import IS_WINDOWS [EOL] [EOL] [comment] [EOL] [EOL] @ dataclass class MockSection ( UpdateTracker ) : [EOL] key = ... [EOL] [EOL] def _update ( self , key ) : [EOL] if type ( self . key ) != type ( key ) : [EOL] raise TypeError [EOL] self . key = key [EOL] [EOL] def serialize ( self ) : [EOL] return self . key [EOL] [EOL] [EOL] def test_ut_has_changed_on_init ( ) : [EOL] sec = MockSection ( key = False ) [EOL] assert sec . has_changed ( ) == True [EOL] [EOL] [EOL] def test_ut_has_changed_check_twice ( ) : [EOL] sec = MockSection ( key = False ) [EOL] assert sec . has_changed ( ) == True [EOL] assert sec . has_changed ( ) == False [EOL] [EOL] [EOL] def test_ut_has_not_changed ( ) : [EOL] sec = MockSection ( key = False ) ; sec . has_changed ( ) [EOL] sec . key = False [EOL] assert sec . has_changed ( ) == False [EOL] [EOL] [EOL] def test_ut_has_changed ( ) : [EOL] sec = MockSection ( key = False ) ; sec . has_changed ( ) [EOL] sec . key = True [EOL] assert sec . has_changed ( ) == True [EOL] [EOL] [EOL] def test_ut_has_changed_quickly ( ) : [EOL] sec = MockSection ( key = False ) ; sec . has_changed ( ) [EOL] sec . key = True [EOL] sec . key = False [EOL] assert sec . has_changed ( ) == False [EOL] [EOL] [EOL] def test_ut_update_error ( caplog ) : [EOL] sec = MockSection ( key = False ) [EOL] try : [EOL] sec . update ( key = [number] ) [EOL] except TypeError : [EOL] pytest . fail ( [string] ) [EOL] assert [string] in caplog . text [EOL] assert sec . key == False , [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def test_installed_defaults ( ) : [EOL] installed = InstalledSettings ( ) [EOL] assert installed . has_changed ( ) == True [EOL] assert installed . search_dirs == set ( ) [EOL] [EOL] [EOL] def test_installed_update_serialize ( mocker ) : [EOL] mocker . patch . object ( Path , [string] , return_value = True ) [EOL] if IS_WINDOWS : [EOL] path = [string] [EOL] else : [EOL] path = [string] [EOL] raw = { [string] : [ path ] } [EOL] installed = InstalledSettings ( ) [EOL] installed . update ( raw ) [EOL] assert raw == installed . serialize ( ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not IS_WINDOWS , reason = [string] ) def test_installed_from_raw_file_allowed_paths ( mocker ) : [EOL] [docstring] [EOL] config_content = [string] [EOL] mocker . patch . object ( Path , [string] , return_value = True ) [EOL] with patch ( [string] , mock_open ( read_data = config_content ) ) : [EOL] settings = Settings ( ) [EOL] assert settings . installed . search_dirs == { Path ( [string] ) , Path ( [string] ) , Path ( [string] ) } [EOL] [EOL] [EOL] def test_settings_default_config ( ) : [EOL] [docstring] [EOL] Settings ( ) . _config == { [string] : LibrarySettings ( ) . serialize ( ) , [string] : InstalledSettings ( ) . serialize ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] import asyncio [EOL] from unittest . mock import MagicMock [EOL] [EOL] from gui . options import OPTIONS_MODE [EOL] [EOL] [EOL] @ pytest . fixture def auth_cookie ( ) : [EOL] return { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_open_news_on_minor_update ( plugin , auth_cookie , mocker ) : [EOL] plugin . _open_config = MagicMock ( spec = ( ) ) [EOL] plugin . _last_version = [string] [EOL] mocker . patch ( [string] , [string] ) [EOL] await plugin . authenticate ( stored_credentials = auth_cookie ) [EOL] plugin . _open_config . assert_called_once_with ( OPTIONS_MODE . NEWS ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_do_not_open_news_on_patch_update ( plugin , auth_cookie , mocker ) : [EOL] plugin . _open_config = MagicMock ( spec = ( ) ) [EOL] plugin . _last_version = [string] [EOL] mocker . patch ( [string] , [string] ) [EOL] await plugin . authenticate ( stored_credentials = auth_cookie ) [EOL] plugin . _open_config . assert_not_called ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_open_welcome_on_authenticate ( plugin , auth_cookie ) : [EOL] plugin . _open_config = MagicMock ( spec = ( ) ) [EOL] await plugin . pass_login_credentials ( [string] , [string] , [ auth_cookie ] ) [EOL] plugin . _open_config . assert_called_once_with ( OPTIONS_MODE . WELCOME ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_open_options_on_clicking_install ( plugin , delayed_fn ) : [EOL] plugin . _open_config = MagicMock ( spec = ( ) ) [EOL] await asyncio . gather ( delayed_fn ( [number] , plugin . install_game ) , delayed_fn ( [number] , plugin . install_game ) ) [EOL] plugin . _open_config . assert_called_once ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Union , List [EOL] import typing [EOL] import pytest [EOL] import time [EOL] from functools import partial [EOL] from unittest . mock import Mock [EOL] [EOL] from galaxy . api . errors import UnknownError [EOL] [EOL] from consts import SOURCE [EOL] from settings import LibrarySettings [EOL] from library import LibraryResolver , KeyInfo [EOL] from model . game import Subproduct , Key , KeyGame [EOL] [EOL] [EOL] @ pytest . fixture def create_resolver ( plugin ) : [EOL] def fn ( settings , cache = { } ) : [EOL] return LibraryResolver ( api = plugin . _api , settings = settings , cache = cache , save_cache_callback = partial ( plugin . _save_cache , [string] ) ) [EOL] return fn [EOL] [EOL] [EOL] @ pytest . fixture def change_settings ( ) : [EOL] def fn ( plugin , lib_config ) : [EOL] plugin . _library_resolver . _settings . update ( lib_config ) [EOL] return fn [EOL] [EOL] [EOL] @ pytest . fixture def get_torchlight ( orders_keys ) : [EOL] for i in orders_keys : [EOL] if i [ [string] ] [ [string] ] == [string] : [EOL] torchlight_order = i [EOL] drm_free = Subproduct ( torchlight_order [ [string] ] [ [number] ] ) [EOL] key = Key ( torchlight_order [ [string] ] [ [string] ] [ [number] ] ) [EOL] key_game = KeyGame ( key , key . machine_name , key . human_name ) [EOL] return torchlight_order , drm_free , key_game [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ pytest . mark . asyncio async def test_library_cache_drm_free ( create_resolver , get_torchlight ) : [EOL] order , game , _ = get_torchlight [EOL] sources = { SOURCE . DRM_FREE } [EOL] cache = { [string] : { [string] : order } } [EOL] library = create_resolver ( LibrarySettings ( sources ) , cache ) [EOL] assert { game . machine_name : game } == await library ( only_cache = True ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_library_cache_key ( create_resolver , get_torchlight ) : [EOL] order , _ , key = get_torchlight [EOL] sources = { SOURCE . KEYS } [EOL] cache = { [string] : { [string] : order } } [EOL] library = create_resolver ( LibrarySettings ( sources ) , cache ) [EOL] assert { key . machine_name : key } == await library ( only_cache = True ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ pytest . mark . asyncio async def test_library_cache_orders ( plugin , get_torchlight , change_settings ) : [EOL] _ , drm_free , key_game = get_torchlight [EOL] [EOL] change_settings ( plugin , { [string] : [ [string] ] , [string] : True } ) [EOL] result = await plugin . _library_resolver ( ) [EOL] assert result [ drm_free . machine_name ] == drm_free [EOL] [EOL] plugin . _api . get_gamekeys . reset_mock ( ) [EOL] plugin . _api . get_order_details . reset_mock ( ) [EOL] [EOL] change_settings ( plugin , { [string] : [ [string] ] } ) [EOL] result = await plugin . _library_resolver ( only_cache = True ) [EOL] assert result [ key_game . machine_name ] == key_game [EOL] assert drm_free . machine_name not in result [EOL] [comment] [EOL] assert plugin . _api . get_gamekeys . call_count == [number] [EOL] assert plugin . _api . get_order_details . call_count == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_library_fetch_with_cache_orders ( plugin , get_torchlight , change_settings ) : [EOL] [docstring] [EOL] torchlight , _ , key = get_torchlight [EOL] [EOL] change_settings ( plugin , { [string] : [ [string] ] , [string] : False } ) [EOL] result = await plugin . _library_resolver ( ) [EOL] [EOL] [comment] [EOL] for i in plugin . _api . orders : [EOL] if i == torchlight : [EOL] for tpk in i [ [string] ] [ [string] ] : [EOL] tpk [ [string] ] = [string] [EOL] break [EOL] [comment] [EOL] unrevealed_order_keys = [ ] [EOL] for i in plugin . _api . orders : [EOL] if any ( ( [string] not in x for x in i [ [string] ] [ [string] ] ) ) : [EOL] unrevealed_order_keys . append ( i [ [string] ] ) [EOL] [EOL] [comment] [EOL] plugin . _api . get_gamekeys . reset_mock ( ) [EOL] plugin . _api . get_order_details . reset_mock ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] change_settings ( plugin , { [string] : [ [string] ] , [string] : False } ) [EOL] result = await plugin . _library_resolver ( ) [EOL] assert key . machine_name not in result [comment] [EOL] assert plugin . _api . get_gamekeys . call_count == [number] [EOL] assert plugin . _api . get_order_details . call_count == len ( unrevealed_order_keys ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_library_cache_period ( plugin , change_settings , orders_keys ) : [EOL] [docstring] [EOL] change_settings ( plugin , { [string] : [ [string] ] , [string] : False } ) [EOL] [EOL] [comment] [EOL] plugin . _library_resolver . _cache [ [string] ] = time . time ( ) - [number] [EOL] [EOL] [comment] [EOL] await plugin . _library_resolver ( ) [EOL] assert plugin . _api . get_gamekeys . call_count == [number] [EOL] assert plugin . _api . get_order_details . call_count == len ( orders_keys ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ pytest . mark . asyncio async def test_fetch_orders_filter_errors_ok ( plugin , create_resolver ) : [EOL] resolver = create_resolver ( Mock ( ) ) [EOL] await resolver . _fetch_orders ( [ ] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_fetch_orders_filter_errors_all_bad ( plugin , create_resolver ) : [EOL] resolver = create_resolver ( Mock ( ) ) [EOL] plugin . _api . get_gamekeys . return_value = [ [string] , [string] ] [EOL] with pytest . raises ( UnknownError ) : [EOL] await resolver . _fetch_orders ( [ ] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_fetch_orders_filter_errors_one_404 ( plugin , create_resolver , caplog ) : [EOL] [docstring] [EOL] resolver = create_resolver ( Mock ( ) ) [EOL] resolver = create_resolver ( Mock ( ) ) [EOL] real_gamekeys = await plugin . _api . get_gamekeys ( ) [EOL] plugin . _api . get_gamekeys . return_value = [ real_gamekeys [ [number] ] , [string] ] [EOL] caplog . clear ( ) [EOL] orders = await resolver . _fetch_orders ( [ ] ) [EOL] assert len ( orders ) == [number] [EOL] assert [string] in caplog . text [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [ ] , False ) , ( [string] , [string] , [ ] , False ) , ( [string] , [string] , [ [string] , [string] ] , False ) , ( [string] , [string] , [ [string] , [string] ] , True ) , ( [string] , [string] , [ ] , True ) , ] ) def test_is_multigame_key ( human_name , category , blacklist , is_multigame ) : [EOL] [docstring] [EOL] key = Key ( { [string] : [string] , [string] : human_name , [string] : [string] } ) [EOL] assert LibraryResolver . _is_multigame_key ( key , category , blacklist ) == is_multigame [EOL] [EOL] [EOL] def test_split_multigame_key ( ) : [EOL] tpks = { [string] : [string] , [string] : [string] , } [EOL] key = Key ( tpks ) [EOL] assert LibraryResolver . _split_multigame_key ( key ) == [ KeyGame ( key , [string] , [string] ) , KeyGame ( key , [string] , [string] ) , KeyGame ( key , [string] , [string] ) , KeyGame ( key , [string] , [string] ) ] [EOL] [EOL] [EOL] def test_get_key_info ( ) : [EOL] key_data_1 = { [string] : [string] , [string] : [string] } [EOL] key_data_2 = { [string] : [string] , [string] : [string] } [EOL] key_data_3 = { [string] : [string] , [string] : [string] } [EOL] orders = [ { [string] : { [string] : [string] } , [string] : { [string] : [ key_data_1 , key_data_2 ] } } , { [string] : { [string] : [string] } , [string] : { [string] : [ key_data_3 ] } } , ] [EOL] assert LibraryResolver . _get_key_infos ( orders ) == [ KeyInfo ( Key ( key_data_1 ) , [string] ) , KeyInfo ( Key ( key_data_2 ) , [string] ) , KeyInfo ( Key ( key_data_3 ) , [string] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import unittest [EOL] import typing [EOL] from unittest . mock import MagicMock , Mock [EOL] import pytest [EOL] [EOL] from galaxy . api . types import Subscription [EOL] from conftest import aiter [EOL] [EOL] from model . subscription import ChoiceMonth [EOL] from model . types import Tier [EOL] [EOL] [EOL] @ pytest . fixture def plugin_with_sub ( plugin ) : [EOL] [docstring] [EOL] plugin . _subscription_months = [ ChoiceMonth ( { [string] : [string] , [string] : [string] , [string] : [string] } , is_active = True ) , ChoiceMonth ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } , is_active = False ) , ChoiceMonth ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] } , is_active = False ) ] [EOL] return plugin [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_subscriptions_never_subscribed ( api_mock , plugin_with_sub ) : [EOL] api_mock . had_subscription . return_value = False [EOL] [EOL] res = await plugin_with_sub . get_subscriptions ( ) [EOL] assert res == [ Subscription ( [string] , owned = False ) , Subscription ( [string] , owned = False ) , ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_subscriptions_subscriber_all_from_api ( api_mock , plugin_with_sub ) : [EOL] api_mock . had_subscription . return_value = True [EOL] content_choice_options = [ Mock ( ** { [string] : [string] , [string] : True } ) , Mock ( ** { [string] : [string] , [string] : False } ) , Mock ( ** { [string] : [string] , [string] : False } ) , Mock ( ** { [string] : [string] , [string] : False } ) , Mock ( ** { [string] : [string] , [string] : False } ) , Mock ( ** { [string] : [string] , [string] : False } ) , ] [EOL] api_mock . get_subscription_products_with_gamekeys = MagicMock ( return_value = aiter ( content_choice_options ) ) [EOL] [EOL] res = await plugin_with_sub . get_subscriptions ( ) [EOL] assert sorted ( res , key = lambda x : x . subscription_name ) == [ Subscription ( [string] , owned = True ) , Subscription ( [string] , owned = True ) , Subscription ( [string] , owned = True ) , Subscription ( [string] , owned = True ) , Subscription ( [string] , owned = True ) , Subscription ( [string] , owned = True ) , Subscription ( [string] , owned = True ) , ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_subscriptions_past_subscriber ( api_mock , plugin_with_sub ) : [EOL] [docstring] [EOL] api_mock . had_subscription . return_value = True [EOL] api_mock . get_choice_content_data . return_value = Mock ( ** { [string] : None } ) [EOL] content_choice_options = [ Mock ( ** { [string] : [string] , [string] : False } ) , Mock ( ** { [string] : [string] , [string] : False } ) , ] [EOL] api_mock . get_subscription_products_with_gamekeys = MagicMock ( return_value = aiter ( content_choice_options ) ) [EOL] [EOL] res = await plugin_with_sub . get_subscriptions ( ) [EOL] assert sorted ( res , key = lambda x : x . subscription_name ) == [ Subscription ( [string] , owned = True ) , Subscription ( [string] , owned = True ) , Subscription ( [string] , owned = False ) , Subscription ( [string] , owned = False ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ pytest . param ( None , False , False , id = [string] ) , pytest . param ( Mock ( tier = Tier . LITE ) , False , True , id = [string] ) , pytest . param ( Mock ( tier = Tier . BASIC ) , True , True , id = [string] ) , pytest . param ( Mock ( tier = Tier . PREMIUM ) , True , True , id = [string] ) , pytest . param ( Mock ( tier = Tier . CLASSIC ) , True , True , id = [string] ) ] ) @ pytest . mark . asyncio async def test_get_subscriptions_current_month_not_unlocked_yet ( current_subscription_plan , current_month_owned , trove_owned , api_mock , plugin_with_sub ) : [EOL] [docstring] [EOL] api_mock . had_subscription . return_value = True [EOL] api_mock . get_choice_content_data . return_value = Mock ( user_subscription_plan = current_subscription_plan ) [EOL] content_choice_options = [ Mock ( ** { [string] : [string] , [string] : False } ) , ] [EOL] api_mock . get_subscription_products_with_gamekeys = MagicMock ( return_value = aiter ( content_choice_options ) ) [EOL] res = await plugin_with_sub . get_subscriptions ( ) [EOL] assert sorted ( res , key = lambda x : x . subscription_name ) == [ Subscription ( [string] , owned = True ) , Subscription ( [string] , owned = current_month_owned ) , Subscription ( [string] , owned = trove_owned ) , ] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import logging [EOL] import typing [EOL] import logging [EOL] import pytest [EOL] from model . game import Key [EOL] [EOL] import privacy [EOL] [EOL] [EOL] @ pytest . fixture def sensitive_logger ( ) : [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( [string] ) [EOL] logger . addFilter ( privacy . SensitiveFilter ( ) ) [EOL] yield logger [EOL] [EOL] [EOL] def test_strip_from_dict ( sensitive_logger , caplog ) : [EOL] sensitive_dict = { [string] : [string] , [string] : [string] } [EOL] logging . error ( sensitive_dict ) [EOL] assert [string] not in caplog . text [EOL] [EOL] [EOL] def test_strip_from_key ( sensitive_logger , caplog ) : [EOL] key_val = [string] [EOL] data = { [string] : [string] , [string] : [string] , [string] : key_val } [EOL] key = Key ( data ) [EOL] logging . error ( key ) [EOL] assert key_val not in caplog . text [EOL] assert key . key_val == key_val [comment] [EOL] [EOL] [EOL] def test_strip_extra ( sensitive_logger , caplog ) : [EOL] [docstring] [EOL] key_val = [string] [EOL] data = { [string] : [string] , [string] : [string] , [string] : key_val } [EOL] logging . error ( [string] , extra = data ) [EOL] assert key_val not in caplog . text [EOL] for record in caplog . records : [EOL] if hasattr ( record , [string] ) : [EOL] assert record . redeemed_key_val == [string] [EOL] assert data [ [string] ] == key_val [comment] [EOL] [EOL] def test_strip_extra_game_key ( sensitive_logger , caplog ) : [EOL] [docstring] [EOL] key_val = [string] [EOL] data = { [string] : [string] , [string] : [string] , [string] : key_val } [EOL] key = Key ( data ) [EOL] logging . error ( [string] , extra = { [string] : key } ) [EOL] for record in caplog . records : [EOL] if hasattr ( record , [string] ) : [EOL] assert record . game . key_val != key_val [EOL] assert record . game . _data [ [string] ] != key_val [EOL] [comment] [EOL] assert key . _data [ [string] ] == key_val [EOL] assert key . key_val == key_val [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) def test_strip_from_str ( sensitive_logger , caplog , key_val ) : [EOL] msg = f' [string] { key_val } [string] ' [EOL] logging . error ( msg ) [EOL] assert [string] in caplog . text [EOL] assert key_val not in caplog . text [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , ] ) def test_strip_from_str_false_positives ( sensitive_logger , caplog , key_val ) : [EOL] msg = f' [string] { key_val } [string] ' [EOL] logging . error ( msg ) [EOL] assert key_val in caplog . text [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set [EOL] import pathlib [EOL] import typing [EOL] import pytest [EOL] from pathlib import Path [EOL] [EOL] from local import AppFinder [EOL] from local . baseappfinder import GameLocation [EOL] from consts import IS_WINDOWS [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ pytest . fixture def candidates ( ) : [EOL] [docstring] [EOL] return set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ] ) def test_get_close_matches_exact ( dirname , expected , candidates ) : [EOL] result = AppFinder ( ) . get_close_matches ( dirname , candidates , similarity = [number] ) [EOL] assert expected == result [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ] ) def test_get_close_matches_close ( dirname , expected , candidates ) : [EOL] result = AppFinder ( ) . get_close_matches ( dirname , candidates , similarity = [number] ) [EOL] assert expected == result [EOL] [EOL] [comment] [EOL] [EOL] @ pytest . fixture def create_tmp_tree ( ) : [EOL] def fn ( paths ) : [EOL] [docstring] [EOL] for root , dirs , files in paths : [EOL] root . mkdir ( exist_ok = True ) [EOL] for d in dirs : [EOL] ( root / d ) . mkdir ( ) [EOL] for f in files : [EOL] ( root / f ) . touch ( ) [EOL] return root [EOL] return fn [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not IS_WINDOWS , reason = [string] ) @ pytest . mark . asyncio async def test_scan_folder_windows ( create_tmp_tree , tmp_path ) : [EOL] root = tmp_path [EOL] create_tmp_tree ( [ ( root , ( [string] , [string] ) , ( ) ) , ( root / [string] , ( [string] , [string] ) , ( [string] , [string] ) ) , ( root / [string] , ( [string] , [string] ) , ( [string] , [string] ) ) ] ) [EOL] [EOL] owned_games = { [string] } [EOL] result = await AppFinder ( ) . _scan_folders ( [ root ] , owned_games ) [EOL] root_shelter = Path ( root ) / [string] [EOL] assert { [string] : GameLocation ( root_shelter , root_shelter / [string] ) } == result [EOL] [EOL] owned_games = { [string] } [EOL] result = await AppFinder ( ) . _scan_folders ( [ root ] , owned_games ) [EOL] root_samorost = Path ( root ) / [string] [EOL] assert { [string] : GameLocation ( root_samorost , root_samorost / [string] ) } == result [EOL] [EOL] owned_games = { [string] , [string] } [EOL] assert { [string] : GameLocation ( root_samorost , root_samorost / [string] ) , [string] : GameLocation ( root_shelter , root_shelter / [string] ) } == await AppFinder ( ) . _scan_folders ( [ root ] , owned_games ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import pathlib [EOL] import typing [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] from local . localgame import LocalHumbleGame [EOL] [EOL] [EOL] @ pytest . fixture def create_file_at ( ) : [EOL] def fn ( path , content ) : [EOL] path . parent . mkdir ( exist_ok = True , parents = True ) [EOL] size = path . write_bytes ( content ) [EOL] return size [EOL] return fn [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_size_mac ( tmp_path , create_file_at ) : [EOL] app = tmp_path / [string] [EOL] exe = app / [string] / [string] / [string] [EOL] create_file_at ( exe , [string] * [number] ) , [EOL] create_file_at ( app / [string] / [string] , [string] * [number] ) [EOL] game = LocalHumbleGame ( [string] , executable = exe , install_location = app ) [EOL] assert await game . get_size ( ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_size_win ( tmp_path , create_file_at ) : [EOL] game_root = tmp_path / [string] [EOL] expected_size = sum ( [ create_file_at ( game_root / [string] / [string] , [string] ) , create_file_at ( game_root / [string] / [string] , [string] ) , create_file_at ( game_root / [string] / [string] , [string] ) ] ) [EOL] create_file_at ( tmp_path / [string] / [string] , [string] ) [comment] [EOL] game = LocalHumbleGame ( [string] , tmp_path / [string] / [string] , install_location = game_root ) [EOL] assert await game . get_size ( ) == expected_size [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_size_no_install_location ( tmp_path , create_file_at ) : [EOL] [docstring] [EOL] root = tmp_path [EOL] expected_size = sum ( [ create_file_at ( root / [string] , [string] ) , create_file_at ( root / [string] / [string] , [string] ) , create_file_at ( root / [string] / [string] , [string] ) ] ) [EOL] game = LocalHumbleGame ( [string] , root / [string] , install_location = None ) [EOL] assert await game . get_size ( ) == expected_size [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pytest [EOL] from pathlib import PureWindowsPath [EOL] [EOL] from local . pathfinder import PathFinder [EOL] from consts import IS_WINDOWS [EOL] [EOL] [EOL] @ pytest . fixture def systemize ( ) : [EOL] def fn ( executables ) : [EOL] if IS_WINDOWS : [EOL] new_execs = [ str ( x ) for x in executables ] [EOL] else : [EOL] new_execs = [ str ( x . as_posix ( ) ) for x in executables ] [EOL] return new_execs [EOL] return fn [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] def test_choose_1exe ( ) : [EOL] app_name = [string] [EOL] executables = [ [string] ] [EOL] res = PathFinder . choose_main_executable ( app_name , executables ) [EOL] assert res == executables [ [number] ] [EOL] [EOL] def test_choose_exact_match ( ) : [EOL] app_name = [string] [EOL] executables = [ [string] , [string] ] [EOL] res = PathFinder . choose_main_executable ( app_name , executables ) [EOL] assert res == [string] [EOL] [EOL] def test_choose_icase ( ) : [EOL] app_name = [string] [EOL] executables = [ [string] , [string] , [string] , [string] ] [EOL] res = PathFinder . choose_main_executable ( app_name , executables ) [EOL] assert res == [string] [EOL] [EOL] def test_choose_2exe ( ) : [EOL] app_name = [string] [EOL] executables = [ [string] , [string] ] [EOL] res = PathFinder . choose_main_executable ( app_name , executables ) [EOL] assert res == [string] [EOL] [EOL] def test_choose_full_path ( systemize ) : [EOL] app_name = [string] [EOL] executables = [ PureWindowsPath ( [string] ) , PureWindowsPath ( [string] ) ] [EOL] executables = systemize ( executables ) [EOL] expected = executables [ [number] ] [EOL] [EOL] res = PathFinder . choose_main_executable ( app_name , executables ) [EOL] assert res == str ( expected ) [EOL] [EOL] def test_choose_legendary_heroes ( systemize ) : [EOL] app_name = [string] [EOL] executables = [ PureWindowsPath ( [string] ) , PureWindowsPath ( [string] ) , PureWindowsPath ( [string] ) , PureWindowsPath ( [string] ) ] [EOL] executables = systemize ( executables ) [EOL] expected = executables [ [number] ] [EOL] [EOL] res = PathFinder . choose_main_executable ( app_name , executables ) [EOL] assert res == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Union , List [EOL] import typing [EOL] from humbledownloader import HumbleDownloadResolver [EOL] from model . download import SubproductDownload [EOL] from consts import BITNESS [EOL] [EOL] [EOL] def test_download_resolver_for_bitness ( ) : [EOL] data = { [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] } , { [string] : [string] } ] } [EOL] sub = SubproductDownload ( data ) [EOL] download = HumbleDownloadResolver ( BITNESS . B64 ) ( sub ) [EOL] assert download . name == [string] [EOL] download = HumbleDownloadResolver ( BITNESS . B32 ) ( sub ) [EOL] assert download . name == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest import mock [EOL] import pytest [EOL] import asyncio [EOL] [EOL] from utils . decorators import double_click_effect [EOL] from conftest import AsyncMock [EOL] [EOL] [EOL] @ pytest . fixture def mock_dbclick ( ) : [EOL] def mock_callable ( x ) : pass [EOL] return mock . MagicMock ( spec = mock_callable ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_async_fn ( ) : [EOL] return AsyncMock ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_clicked_once ( mock_dbclick , mock_async_fn ) : [EOL] timeout = [number] [EOL] decorated_fn = double_click_effect ( timeout , mock_dbclick ) ( mock_async_fn ) [EOL] await decorated_fn ( ) [EOL] assert mock_async_fn . call_count == [number] [EOL] assert mock_dbclick . call_count == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_fast_double_click ( mock_dbclick , mock_async_fn ) : [EOL] timeout = [number] [EOL] decorated_fn = double_click_effect ( timeout , mock_dbclick ) ( mock_async_fn ) [EOL] await asyncio . gather ( decorated_fn ( ) , decorated_fn ( ) ) [EOL] assert mock_async_fn . call_count == [number] [EOL] assert mock_dbclick . call_count == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_slow_double_click ( mock_dbclick , mock_async_fn , delayed_fn ) : [EOL] timeout = [number] [EOL] decorated_fn = double_click_effect ( timeout , mock_dbclick ) ( mock_async_fn ) [EOL] await asyncio . gather ( decorated_fn ( ) , delayed_fn ( timeout + [number] , decorated_fn ) ) [EOL] assert mock_async_fn . call_count == [number] [EOL] assert mock_dbclick . call_count == [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from model . game import Subproduct , Key , KeyGame [EOL] from model . types import GAME_PLATFORMS , HP [EOL] [EOL] [EOL] def test_game_properties_overgrowth ( overgrowth ) : [EOL] for sub_data in overgrowth [ [string] ] : [EOL] sub = Subproduct ( sub_data ) [EOL] sub . human_name [EOL] sub . machine_name [EOL] sub . license [EOL] for platform , download in sub . downloads . items ( ) : [EOL] assert platform in set ( HP ) [EOL] for dw_struct in download . download_struct : [EOL] dw_struct . web [EOL] dw_struct . bittorrent [EOL] dw_struct . human_size [EOL] assert not set ( sub . downloads ) . isdisjoint ( GAME_PLATFORMS ) [EOL] [EOL] [EOL] def test_game_properties_access ( orders ) : [EOL] for order in orders : [EOL] for sub_data in order [ [string] ] : [EOL] sub = Subproduct ( sub_data ) [EOL] sub . human_name [EOL] sub . machine_name [EOL] sub . license [EOL] for platform , download in sub . downloads . items ( ) : [EOL] assert platform in set ( HP ) [EOL] for dw_struct in download . download_struct : [EOL] dw_struct . web [EOL] dw_struct . bittorrent [EOL] dw_struct . human_size [EOL] [EOL] [EOL] def test_key_properties ( origin_bundle_order ) : [EOL] all_tpks = origin_bundle_order [ [string] ] [ [string] ] [EOL] for key_data in all_tpks : [EOL] key = Key ( key_data ) [EOL] key . key_type [EOL] key . key_val [EOL] key . downloads [EOL] key . in_galaxy_format ( ) [EOL] [EOL] [EOL] def test_key_key_game_data ( ) : [EOL] tpks = { [string] : [string] , [string] : [string] } [EOL] key = Key ( tpks ) [EOL] assert tpks == KeyGame ( key , [string] , [string] ) . _data [EOL] [EOL] [EOL] def test_key_game_human_name_changed ( ) : [EOL] tpks = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] assert KeyGame ( Key ( tpks ) , [string] , [string] ) . human_name == [string] [EOL] [EOL] [EOL] def test_key_game_human_name_not_changed ( ) : [EOL] tpks = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] assert KeyGame ( Key ( tpks ) , [string] , [string] ) . human_name == [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] import json [EOL] [EOL] from model . product import Product [EOL] [EOL] [EOL] @ pytest . fixture def software_photo ( ) : [EOL] return json . loads ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def storefront_prod ( ) : [EOL] return json . loads ( [string] ) [EOL] [EOL] [EOL] def test_bundle_type ( software_photo , storefront_prod ) : [EOL] prod = Product ( software_photo ) [EOL] not_bundle_prod = Product ( storefront_prod ) [EOL] assert prod . category == [string] [EOL] assert prod . bundle_type == [string] [EOL] assert not_bundle_prod . category == [string] [EOL] assert not_bundle_prod . bundle_type == None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any , Set , Tuple [EOL] import pathlib [EOL] import typing [EOL] import os [EOL] import pytest [EOL] import pathlib [EOL] from unittest . mock import patch [EOL] from contextlib import contextmanager [EOL] [EOL] try : [EOL] from local . winappfinder import WindowsAppFinder [EOL] from local . reg_watcher import WinRegUninstallWatcher , UninstallKey [EOL] except ModuleNotFoundError : [EOL] pass [comment] [EOL] [EOL] [EOL] @ pytest . fixture def patch_wrc ( ) : [EOL] @ contextmanager def fn ( subkeys ) : [EOL] def mock_get_val ( subkey , prop , optional = False ) : [EOL] if optional : [EOL] return subkey . get ( prop ) [EOL] return subkey [ prop ] [EOL] [EOL] with patch . object ( WinRegUninstallWatcher , [string] ) as subkey_gen , patch . object ( WinRegUninstallWatcher , [string] ) as get_val : [EOL] subkey_gen . return_value = iter ( subkeys ) [EOL] get_val . side_effect = mock_get_val [EOL] yield [EOL] return fn [EOL] [EOL] [EOL] @ pytest . fixture def uk_annas_quest ( ) : [EOL] return UninstallKey ( key_name = [string] , display_name = [string] , uninstall_string = [string] , install_location = [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def uk_windosill ( ) : [EOL] return UninstallKey ( key_name = [string] , display_name = [string] , uninstall_string = [string] , install_location = [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def test_uk_display_icon_path ( ) : [EOL] display_icons = [ [string] , [string] , [string] , [string] ] [EOL] for i in display_icons : [EOL] uk = UninstallKey ( [string] , [string] , [string] , display_icon = i ) [EOL] assert pathlib . Path ( [string] ) == uk . display_icon_path [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] ] ) def test_uk_local_uninstaller_path ( uninstall_string ) : [EOL] expected = pathlib . Path ( [string] ) [EOL] uk = UninstallKey ( [string] , [string] , uninstall_string = uninstall_string ) [EOL] assert expected == uk . local_uninstaller_path [EOL] [EOL] [EOL] def test_uk_local_uninstaller_path_empty ( ) : [EOL] assert None == UninstallKey ( [string] , [string] , uninstall_string = [string] ) . local_uninstaller_path [EOL] [EOL] [EOL] def test_uk_local_uninstaller_path_msi ( ) : [EOL] [docstring] [EOL] uninstall_string = [string] [EOL] uk = UninstallKey ( [string] , [string] , uninstall_string = uninstall_string ) [EOL] assert None == uk . local_uninstaller_path [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , ] ) def test_uk_local_uninstaller_path_other_uninstallers ( mocker , uninstall_string ) : [EOL] [docstring] [EOL] mocker . patch . dict ( os . environ , { [string] : [string] } ) [EOL] uk = UninstallKey ( [string] , [string] , uninstall_string = uninstall_string ) [EOL] assert None == uk . local_uninstaller_path [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def test_refresh_uks ( uk_annas_quest , uk_windosill , patch_wrc ) : [EOL] subkeys = [ ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] } ) , ( uk_windosill . key_name , { [string] : uk_windosill . display_name , [string] : uk_windosill . install_location , [string] : uk_windosill . uninstall_string } ) ] [EOL] expected = set ( [ uk_annas_quest , uk_windosill ] ) [EOL] with patch_wrc ( subkeys ) : [EOL] finder = WindowsAppFinder ( ) [EOL] finder . _reg . refresh ( ) [EOL] assert finder . _reg . uninstall_keys == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Iterable [EOL] import unittest [EOL] import typing [EOL] import pytest [EOL] from unittest . mock import PropertyMock , MagicMock [EOL] from typing import Iterable [EOL] [EOL] try : [EOL] from local . winappfinder import WindowsAppFinder [EOL] from local . reg_watcher import UninstallKey , WinRegUninstallWatcher [EOL] except ModuleNotFoundError : [EOL] pass [comment] [EOL] [EOL] [EOL] @ pytest . fixture def mock_winreg_watcher ( ) : [EOL] def fn ( uninstall_keys ) : [EOL] watcher = MagicMock ( spec = WinRegUninstallWatcher ) [EOL] type ( watcher ) . uninstall_keys = PropertyMock ( return_value = set ( uninstall_keys ) ) [EOL] return watcher [EOL] return fn [EOL] [EOL] [EOL] @ pytest . fixture def uk_torchlight2 ( ) : [EOL] [docstring] [EOL] return UninstallKey ( key_name = [string] , display_name = [string] , uninstall_string = [string] , install_location = None , display_icon = [string] , ) [EOL] [EOL] [EOL] def test_match_by_key_name ( ) : [EOL] uk = UninstallKey ( [string] , [string] , uninstall_string = [string] ) [EOL] human_name = [string] [EOL] assert True == WindowsAppFinder . _matches ( human_name , uk ) [EOL] [EOL] [EOL] def test_match_with_folder_name ( ) : [EOL] human_name = [string] [EOL] install_location = [string] [EOL] uk = UninstallKey ( key_name = [string] , display_name = [string] , uninstall_string = [string] , install_location = install_location , ) [EOL] assert True == WindowsAppFinder . _matches ( human_name , uk ) [EOL] [EOL] [EOL] def test_match_colon_in_name ( ) : [EOL] human_name = [string] [EOL] install_location = [string] [EOL] uk = UninstallKey ( key_name = [string] , display_name = [string] , uninstall_string = [string] , install_location = install_location , ) [EOL] assert True == WindowsAppFinder . _matches ( human_name , uk ) [EOL] [EOL] [EOL] def test_no_match ( ) : [EOL] human_name = [string] [EOL] uk = UninstallKey ( [string] , [string] , [string] , install_location = [string] , ) [EOL] assert False == WindowsAppFinder . _matches ( human_name , uk ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ pytest . mark . asyncio async def test_find_games_display_icon ( uk_torchlight2 , mock_winreg_watcher ) : [EOL] [docstring] [EOL] human_name , machine_name = [string] , [string] [EOL] owned_games = { human_name : machine_name } [EOL] expected_exe = uk_torchlight2 . display_icon [EOL] [EOL] finder = WindowsAppFinder ( ) [EOL] finder . _reg = mock_winreg_watcher ( uninstall_keys = [ uk_torchlight2 ] ) [EOL] res = await finder ( owned_games ) [EOL] assert machine_name in res [EOL] assert expected_exe == str ( res [ machine_name ] . executable ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_find_game_display_uninstall ( mock_winreg_watcher ) : [EOL] [docstring] [EOL] human_name , machine_name = [string] , [string] [EOL] uninstall = [string] [EOL] uk_game = UninstallKey ( key_name = human_name , display_name = human_name , uninstall_string = uninstall , display_icon = uninstall ) [EOL] owned_games = { human_name : machine_name } [EOL] finder = WindowsAppFinder ( ) [EOL] finder . _reg = mock_winreg_watcher ( uninstall_keys = [ uk_game ] ) [EOL] assert { } == await finder ( owned_games ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0