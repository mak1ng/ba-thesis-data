import codecs [EOL] from os import path [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] __version__ = [string] [EOL] [EOL] BASE_DIR = path . abspath ( path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] def load_require ( name ) : [EOL] with open ( path . join ( BASE_DIR , [string] , name ) ) as p : [EOL] return list ( filter ( lambda l : len ( l ) and not l . startswith ( [string] ) , [ l . strip ( ) for l in p ] ) ) [EOL] [EOL] [EOL] with codecs . open ( path . join ( BASE_DIR , [string] ) , encoding = [string] ) as f : [EOL] LONG_DESCRIPTION = f . read ( ) [EOL] [EOL] setup ( name = [string] , version = __version__ , description = [string] , long_description = LONG_DESCRIPTION , classifiers = [ [string] , [string] , [string] , ] , packages = find_packages ( exclude = [ [string] , [string] ] ) , include_package_data = True , author = [string] , dependency_links = [ ] , author_email = [string] , install_requires = load_require ( [string] ) , extras_require = { [string] : load_require ( [string] ) , [string] : load_require ( [string] ) , [string] : load_require ( [string] ) } , setup_requires = [ [string] ] , tests_require = load_require ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import aio_service [EOL] import peewee as pw [EOL] [EOL] from . db import database_proxy [EOL] [EOL] [EOL] class BaseModel ( pw . Model ) : [EOL] class Meta : [EOL] database = database_proxy [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[aio_service.models.BaseModel.Meta]$ 0 0 0
from typing import Any [EOL] import typing [EOL] import app [EOL] import aio_service [EOL] import peewee_async [EOL] import peewee_asyncext [EOL] from . app import App [EOL] from . config import get_config [EOL] [EOL] import peewee [EOL] import peewee_async [EOL] import peewee_asyncext [EOL] [EOL] from playhouse . db_url import parse [EOL] [EOL] database_proxy = peewee . Proxy ( ) [EOL] [EOL] [EOL] def get_objects ( app ) : [EOL] return app . ctx [ [string] ] [EOL] [EOL] [EOL] def get_database ( app ) : [EOL] return app . ctx [ [string] ] [EOL] [EOL] [EOL] def create_database ( app ) : [EOL] config = get_config ( app ) [EOL] database = peewee_asyncext . PooledPostgresqlExtDatabase ( ** parse ( config . postgres_url ) ) [EOL] database_proxy . initialize ( database ) [EOL] app . ctx [ [string] ] = database_proxy [EOL] objects = peewee_async . Manager ( database_proxy ) [EOL] database . set_allow_sync ( False ) [EOL] app . ctx [ [string] ] = objects [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $peewee_async.Manager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $peewee_asyncext.PooledPostgresqlExtDatabase$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union [EOL] import app [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] from typing import Union , Dict [EOL] from os import environ [EOL] import logging [EOL] [EOL] from . app import App [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def get_env ( env , name , default = [string] , prefix = None ) : [EOL] prefixed_name = name [EOL] if prefix is not None : [EOL] prefixed_name = f'{ prefix } [string] { name }' [EOL] return env . get ( prefixed_name , default ) [EOL] [EOL] [EOL] class Config : [EOL] def __init__ ( self , prefix = None ) : [EOL] self . prefix = prefix [EOL] self . redis_url = self . get_env ( [string] , [string] ) [EOL] self . postgres_url = self . get_env ( [string] , [string] ) [EOL] self . sentry_dsn = self . get_env ( [string] , [string] ) [EOL] self . logging_level = getattr ( logging , self . get_env ( [string] , [string] ) , logging . ERROR ) [EOL] [EOL] def get_env ( self , name , default ) : [EOL] return get_env ( environ , name , default , self . prefix ) [EOL] [EOL] [EOL] def get_config ( app ) : [EOL] return app . ctx [ [string] ] [EOL] [EOL] [EOL] def set_config ( app , config ) : [EOL] app . ctx [ [string] ] = config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Type , Any [EOL] import app [EOL] import typing [EOL] import aio_service [EOL] import logging [EOL] import asyncio [EOL] import json [EOL] import logging [EOL] from collections import namedtuple [EOL] from typing import Callable [EOL] [EOL] from . app import App [EOL] from . redis import get_redis_pool [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] Result = namedtuple ( [string] , [ [string] , [string] ] , ) [EOL] [EOL] [EOL] def create_dispatcher ( app ) : [EOL] pool = get_redis_pool ( app ) [EOL] loop = app . loop [EOL] [EOL] async def dispatcher ( msg , topics = [ ] , * a , ** kw ) : [EOL] packed = json . dumps ( msg ) [EOL] async with pool . get ( ) as conn : [EOL] return await asyncio . gather ( * [ conn . rpush ( topic , packed , * a , ** kw ) for topic in topics ] , loop = loop ) [EOL] [EOL] return dispatcher [EOL] [EOL] [EOL] def create_subscriber ( app ) : [EOL] pool = get_redis_pool ( app ) [EOL] [EOL] async def subscriber ( topics = [ ] , * a , ** kw ) : [EOL] for topic in topics : [EOL] async with pool . get ( ) as conn : [EOL] result = await conn . lpop ( topic , * a , ** kw ) [EOL] if result : [EOL] yield Result ( topic , json . loads ( result ) ) [EOL] [EOL] return subscriber [EOL] [EOL] [EOL] async def add_queues ( app ) : [EOL] app . ctx [ [string] ] = create_subscriber ( app ) [EOL] app . ctx [ [string] ] = create_dispatcher ( app ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[aio_service.communication.Result]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[aio_service.communication.Result]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type [EOL] import typing [EOL] import aio_service [EOL] import logging [EOL] import asyncio [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class App : [EOL] _started = False [EOL] _pending = None [EOL] [EOL] def __init__ ( self , handler , loop ) : [EOL] [docstring] [EOL] self . loop = loop [EOL] self . on_startup = [ ] [EOL] self . on_shutdown = [ ] [EOL] self . _handler = handler [EOL] self . ctx = { } [EOL] [EOL] @ property def started ( self ) : [EOL] return self . _started [EOL] [EOL] @ property def subscribe ( self ) : [EOL] return self . ctx [ [string] ] [EOL] [EOL] @ property def dispatch ( self ) : [EOL] return self . ctx [ [string] ] [EOL] [EOL] async def _process_hook ( self , hook ) : [EOL] for f in hook : [EOL] await f ( self ) [EOL] [EOL] def handler ( self ) : [EOL] return self . _handler ( self ) [EOL] [EOL] async def start ( self , loop_sleep = [number] ) : [EOL] await self . _process_hook ( self . on_startup ) [EOL] self . _started = True [EOL] try : [EOL] while self . started : [EOL] try : [EOL] self . _pending = asyncio . ensure_future ( self . handler ( ) ) [EOL] await self . _pending [EOL] except Exception as e : [EOL] logger . exception ( [string] ) [EOL] await asyncio . sleep ( loop_sleep ) [EOL] finally : [EOL] await self . _process_hook ( self . on_shutdown ) [EOL] [EOL] def stop ( self ) : [EOL] self . _started = False [EOL] if self . _pending : [EOL] self . _pending . cancel ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import aioredis [EOL] import typing [EOL] import urllib [EOL] import app [EOL] import aio_service [EOL] import builtins [EOL] import logging [EOL] from typing import Dict , Any [EOL] [EOL] import urllib . parse as urlparse [EOL] import logging [EOL] [EOL] import aioredis [EOL] [EOL] from . app import App [EOL] from . config import get_config [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] REDIS_POOL_KEY = [string] [EOL] [EOL] [EOL] def parse_redis_url ( url ) : [EOL] config = { } [EOL] [EOL] parsed_url = urlparse . urlparse ( url ) [EOL] [EOL] path = parsed_url . path [ [number] : ] [EOL] path = path . split ( [string] , [number] ) [ [number] ] [EOL] host = parsed_url . hostname or [string] [EOL] port = int ( parsed_url . port or [number] ) [EOL] db = int ( path ) or [number] [EOL] [EOL] config . update ( { [string] : db , [string] : parsed_url . password or None , [string] : ( host , port ) } ) [EOL] [EOL] return config [EOL] [EOL] [EOL] def get_redis_pool ( app ) : [EOL] return app . ctx . get ( REDIS_POOL_KEY ) [EOL] [EOL] [EOL] async def destroy_redis_pool ( app ) : [EOL] pool = get_redis_pool ( app ) [EOL] if pool : [EOL] pool . close ( ) [EOL] await pool . wait_closed ( ) [EOL] del app . ctx [ REDIS_POOL_KEY ] [EOL] logger . info ( [string] ) [EOL] [EOL] [EOL] async def create_redis_pool ( app ) : [EOL] config = get_config ( app ) [EOL] logger . info ( config . redis_url ) [EOL] app . ctx [ REDIS_POOL_KEY ] = await aioredis . create_pool ( loop = app . loop , maxsize = [number] , encoding = [string] , ** parse_redis_url ( config . redis_url ) ) [EOL] logger . info ( f' [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioredis.RedisPool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
from typing import Awaitable , Any , Dict , Type , Callable [EOL] import typing [EOL] import communication [EOL] import app [EOL] import builtins [EOL] import logging [EOL] import logging [EOL] from typing import Any , Awaitable , Callable , Dict [EOL] [EOL] from . app import App [EOL] from . communication import Result [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] IKeyResolver = Callable [ ... , str ] [EOL] IRoute = Callable [ [ Any , Any ] , Awaitable ] [EOL] [EOL] [EOL] async def default_route ( app , result ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def resolve_routing_key ( result ) : [EOL] topic = result . topic [EOL] event_type = result . message . get ( [string] , [string] ) [EOL] return f'{ topic } [string] { event_type }' [EOL] [EOL] [EOL] def create_router ( routes , key_resolver = resolve_routing_key , default = default_route ) : [EOL] async def router ( app , result ) : [EOL] k = key_resolver ( result ) [EOL] logger . info ( f' [string] { k } [string] ' ) [EOL] route = routes . get ( k , default ) [EOL] return await route ( app , result . message ) [EOL] return router [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import app [EOL] import aio_service [EOL] import logging [EOL] import logging [EOL] from . config import get_config [EOL] from . app import App [EOL] [EOL] [EOL] def setup_logger ( app , logger ) : [EOL] config = get_config ( app ) [EOL] handler = logging . StreamHandler ( ) [EOL] formatter = logging . Formatter ( fmt = [string] ) [EOL] handler . setFormatter ( formatter ) [EOL] logger . addHandler ( handler ) [EOL] logger . setLevel ( config . logging_level ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] import uuid [EOL] [EOL] [EOL] @ pytest . fixture def async_val ( request ) : [EOL] def _async_val ( val ) : [EOL] async def __async_val ( * args , ** kwargs ) : [EOL] return val [EOL] return __async_val [EOL] return _async_val [EOL] [EOL] [EOL] @ pytest . fixture def create_random_name ( ) : [EOL] def creator ( prefix = None ) : [EOL] id_ = uuid . uuid4 ( ) . hex [EOL] if prefix is None : [EOL] prefix = __name__ [EOL] return f'{ prefix } [string] { id_ }' [EOL] return creator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import aio_service [EOL] import asyncio [EOL] import pytest [EOL] from contextlib import contextmanager [EOL] [EOL] from aio_service . app import App [EOL] [EOL] [EOL] @ pytest . fixture def q_dispatch ( loop ) : [EOL] return asyncio . Queue ( loop = loop ) [EOL] [EOL] [EOL] @ pytest . fixture def q_subscribe ( loop ) : [EOL] return asyncio . Queue ( loop = loop ) [EOL] [EOL] [EOL] @ pytest . fixture def dispatch ( q_dispatch ) : [EOL] async def d ( msg ) : [EOL] await q_dispatch . put ( msg ) [EOL] return d [EOL] [EOL] [EOL] @ pytest . fixture def subscribe ( q_subscribe ) : [EOL] async def s ( ) : [EOL] yield await q_subscribe . get ( ) [EOL] return s [EOL] [EOL] [EOL] @ pytest . fixture def fake_app_creator ( loop , dispatch , subscribe ) : [EOL] @ contextmanager def app_creator_inner ( handler ) : [EOL] app = App ( handler , loop ) [EOL] app . ctx [ [string] ] = dispatch [EOL] app . ctx [ [string] ] = subscribe [EOL] loop . create_task ( app . start ( ) ) [EOL] yield app [EOL] app . stop ( ) [EOL] return app_creator_inner [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import aio_service [EOL] import pytest [EOL] [EOL] from aio_service . app import App [EOL] [EOL] [EOL] async def handler ( app ) : [EOL] async for msg in app . subscribe ( ) : [EOL] if msg : [EOL] await app . dispatch ( msg ) [EOL] [EOL] [EOL] @ pytest . fixture def app ( fake_app_creator , loop ) : [EOL] with fake_app_creator ( handler ) as app : [EOL] yield app [EOL] [EOL] [EOL] async def test_echo_app ( app , q_subscribe , q_dispatch , loop ) : [EOL] msg = [ [string] ] [EOL] await q_subscribe . put ( msg ) [EOL] assert await q_dispatch . get ( ) == msg [EOL] [EOL] [EOL] async def test_echo_app_with_exception ( app , q_subscribe , q_dispatch ) : [EOL] msg = [ [string] ] [EOL] await q_subscribe . put ( False ) [EOL] await q_subscribe . put ( msg ) [EOL] [comment] [EOL] assert await q_dispatch . get ( ) == msg [EOL] [EOL] [EOL] async def test_app_hooks ( loop ) : [EOL] called_on_startup = [ ] [EOL] called_on_shutdown = [ ] [EOL] [EOL] excepted_on_startup = [ [string] , [string] ] [EOL] excepted_on_shutdown = [ [string] , [string] ] [EOL] [EOL] async def handler ( app , * a , ** kw ) : [EOL] app . stop ( ) [EOL] [EOL] app = App ( handler , loop ) [EOL] [EOL] def make_handler ( x , called ) : [EOL] async def proc ( app ) : [EOL] assert app == app [EOL] called . append ( x ) [EOL] return proc [EOL] [EOL] for i in excepted_on_startup : [EOL] app . on_startup . append ( make_handler ( i , called_on_startup ) ) [EOL] [EOL] for i in excepted_on_shutdown : [EOL] app . on_shutdown . append ( make_handler ( i , called_on_shutdown ) ) [EOL] [EOL] await app . start ( ) [EOL] assert excepted_on_startup == called_on_startup [EOL] assert excepted_on_shutdown == called_on_shutdown [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] from aio_service . app import App [EOL] from aio_service . communication import Result [EOL] from aio_service . routing import create_router , resolve_routing_key [EOL] from asynctest import CoroutineMock [EOL] [EOL] [EOL] class TestResolveRoutingKey : [EOL] @ pytest . fixture def result_message_without_type ( self ) : [EOL] return Result ( topic = [string] , message = { [string] : { } } ) [EOL] [EOL] @ pytest . fixture def expected_key_for_message_without_type ( self ) : [EOL] return [string] [EOL] [EOL] def test_correctly_resolves_for_message_without_type ( self , result_message_without_type , expected_key_for_message_without_type ) : [EOL] key = resolve_routing_key ( result_message_without_type ) [EOL] [EOL] assert key == expected_key_for_message_without_type [EOL] [EOL] @ pytest . fixture def result_message_with_type ( self ) : [EOL] return Result ( topic = [string] , message = { [string] : { } , [string] : [string] } ) [EOL] [EOL] @ pytest . fixture def expected_key_for_message_with_type ( self ) : [EOL] return [string] [EOL] [EOL] def test_correctly_resolves_for_message_with_type ( self , result_message_with_type , expected_key_for_message_with_type ) : [EOL] key = resolve_routing_key ( result_message_with_type ) [EOL] [EOL] assert key == expected_key_for_message_with_type [EOL] [EOL] [EOL] class TestRouter : [EOL] [EOL] @ pytest . fixture def mocked_app ( self ) : [EOL] return Mock ( spec = App ) [EOL] [EOL] @ pytest . fixture def result ( self ) : [EOL] return Result ( topic = [string] , message = { } ) [EOL] [EOL] @ pytest . fixture def routes ( self ) : [EOL] return { [string] : CoroutineMock ( return_value = [string] ) , } [EOL] [EOL] @ pytest . fixture def correct_key_resolver ( self ) : [EOL] return Mock ( return_value = [string] ) [EOL] [EOL] @ pytest . fixture def default_route ( self ) : [EOL] return CoroutineMock ( return_value = [string] ) [EOL] [EOL] @ pytest . fixture def correct_resolver_router ( self , routes , correct_key_resolver , default_route ) : [EOL] return create_router ( routes , correct_key_resolver , default_route ) [EOL] [EOL] async def test_routes_to_correct_key_route ( self , mocked_app , correct_resolver_router , result , correct_key_resolver , default_route , routes ) : [EOL] route_result = await correct_resolver_router ( mocked_app , result ) [EOL] [EOL] assert route_result == [string] [EOL] correct_key_resolver . assert_called_once_with ( result ) [EOL] default_route . assert_not_called ( ) [EOL] routes [ [string] ] . assert_called_once_with ( mocked_app , result . message ) [EOL] [EOL] @ pytest . fixture def missing_key_resolver ( self ) : [EOL] return Mock ( return_value = [string] ) [EOL] [EOL] @ pytest . fixture def missing_resolver_router ( self , routes , missing_key_resolver , default_route ) : [EOL] return create_router ( routes , missing_key_resolver , default_route ) [EOL] [EOL] async def test_routes_to_default_key_route ( self , mocked_app , missing_resolver_router , result , missing_key_resolver , default_route ) : [EOL] route_result = await missing_resolver_router ( mocked_app , result ) [EOL] [EOL] assert route_result == [string] [EOL] missing_key_resolver . assert_called_once_with ( result ) [EOL] default_route . assert_called_once_with ( mocked_app , result . message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import aio_service [EOL] import pytest [EOL] from mock import call [EOL] import logging [EOL] [EOL] from aio_service . config import ( get_env , Config ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( ( { [string] : [string] } , [string] ) , [string] ) , ( ( { [string] : [string] } , [string] ) , [string] ) , ( ( { [string] : [string] } , [string] , [string] ) , [string] ) , ( ( { [string] : [string] } , [string] , [string] , [string] ) , [string] ) , ( ( { [string] : [string] } , [string] , [string] , [string] ) , [string] ) , ( ( { [string] : [string] } , [string] , [string] , [string] ) , [string] ) ] ) def test_get_env ( args , expected ) : [EOL] assert get_env ( * args ) == expected [EOL] [EOL] [EOL] def test_get_env_calls_in_Config_prefix ( mocker ) : [EOL] prefix = [string] [EOL] env = { [string] : [string] } [EOL] get_env = mocker . patch ( [string] , return_value = [string] , autospec = True ) [EOL] mocker . patch ( [string] , env ) [EOL] Config ( prefix ) [EOL] assert get_env . call_args_list == [ call ( env , [string] , [string] , prefix ) , call ( env , [string] , [string] , prefix ) , call ( env , [string] , [string] , prefix ) , call ( env , [string] , [string] , prefix ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , logging . INFO ) , ( [string] , logging . ERROR ) , ( [string] , logging . DEBUG ) ] ) def test_config_leging_level ( value , expected , mocker ) : [EOL] env = { [string] : value } [EOL] mocker . patch ( [string] , env ) [EOL] config = Config ( ) [EOL] assert config . logging_level == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aio_service [EOL] import logging [EOL] from contextlib import contextmanager [EOL] import pytest [EOL] import logging [EOL] [EOL] from aio_service . app import App [EOL] from aio_service . redis import ( create_redis_pool , destroy_redis_pool ) [EOL] [EOL] from aio_service . communication import ( add_queues ) [EOL] [EOL] from aio_service . config import ( Config , set_config ) [EOL] [EOL] [EOL] def create_app ( handler , loop , logger ) : [EOL] app = App ( handler , loop ) [EOL] set_config ( app , Config ( [string] ) ) [EOL] app . on_startup . append ( create_redis_pool ) [EOL] app . on_startup . append ( add_queues ) [EOL] app . on_shutdown . append ( destroy_redis_pool ) [EOL] return app [EOL] [EOL] [EOL] @ pytest . fixture def app_creator ( loop ) : [EOL] [EOL] @ contextmanager def app_creator_inner ( handler ) : [EOL] logger = logging . getLogger ( __name__ ) [EOL] app = create_app ( handler , loop , logger ) [EOL] yield app [EOL] app . stop ( ) [EOL] [EOL] return app_creator_inner [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import typing [EOL] import aio_service [EOL] import inspect [EOL] from aio_service . communication import Result [EOL] [EOL] [EOL] async def handler ( * a , ** k ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] async def test_dispatch_subscribe ( app_creator , create_random_name ) : [EOL] topics = create_random_name ( [string] ) , create_random_name ( [string] ) [EOL] msg = [ [string] , ] [EOL] [EOL] with app_creator ( handler ) as app : [EOL] await app . _process_hook ( app . on_startup ) [EOL] await app . dispatch ( msg , topics ) [EOL] expected = [ Result ( topics [ [number] ] , msg ) , Result ( topics [ [number] ] , msg ) ] [EOL] await assert_subscribe ( app , topics , expected ) [EOL] [EOL] [EOL] async def assert_subscribe ( app , topics , expected ) : [EOL] generator = app . subscribe ( topics ) [EOL] assert inspect . isasyncgen ( generator ) [EOL] result = [ x async for x in generator ] [EOL] assert result == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0