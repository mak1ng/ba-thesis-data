[docstring] [EOL] [EOL] import subprocess [EOL] import random [EOL] import os [EOL] [EOL] from pckr . user import User [EOL] [EOL] [EOL] def gather_user_ip_ports ( ) : [EOL] [docstring] [EOL] [EOL] return { User ( sd ) . username : User ( sd ) . current_ip_port for sd in os . listdir ( os . path . expanduser ( [string] ) ) } [EOL] [EOL] [EOL] def rpk ( user1 , user2 , robustness = [number] ) : [EOL] [docstring] [EOL] [EOL] if user1 == user2 : [EOL] return [EOL] [EOL] if random . randint ( [number] , [number] ) < robustness : [EOL] subprocess . check_call ( [ [string] , [string] , [string] . format ( user1 ) , [string] . format ( user2 ) ] ) [EOL] [EOL] subprocess . check_call ( [ [string] , [string] , [string] . format ( user2 ) ] ) [EOL] [EOL] subprocess . check_call ( [ [string] , [string] , [string] . format ( user1 ) ] ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def aip ( users , user1 , user2 , robustness = [number] ) : [EOL] [docstring] [EOL] [EOL] if user1 == user2 : [EOL] return [EOL] [EOL] if random . randint ( [number] , [number] ) < robustness : [EOL] subprocess . check_call ( [ [string] , [string] , [string] . format ( user1 ) , [string] . format ( user2 ) , [string] . format ( users [ user2 ] [ [string] ] ) , [string] . format ( users [ user2 ] [ [string] ] ) ] ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import random [EOL] import subprocess [EOL] from utils import gather_user_ip_ports [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] users = gather_user_ip_ports ( ) [EOL] [EOL] for i in users . keys ( ) : [EOL] for j in users . keys ( ) : [EOL] if random . randint ( [number] , [number] ) < [number] : [EOL] subprocess . check_call ( [ [string] , [string] , [string] . format ( i ) , [string] . format ( j ) ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from utils import rpk , gather_user_ip_ports [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] users = gather_user_ip_ports ( ) [EOL] [EOL] for i in users . keys ( ) : [EOL] for j in users . keys ( ) : [EOL] rpk ( i , j , robustness = [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from utils import aip , rpk , gather_user_ip_ports [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] users = gather_user_ip_ports ( ) [EOL] [EOL] for i in users . keys ( ) : [EOL] for j in users . keys ( ) : [EOL] aip ( users , i , j , robustness = [number] ) [EOL] [EOL] for i in users . keys ( ) : [EOL] for j in users . keys ( ) : [EOL] rpk ( i , j , robustness = [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from utils import aip , rpk , gather_user_ip_ports [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] users = gather_user_ip_ports ( ) [EOL] [EOL] group1 = list ( users . keys ( ) ) [ [number] : int ( len ( users ) / [number] ) ] [EOL] group2 = list ( users . keys ( ) ) [ int ( len ( users ) / [number] ) : ] [EOL] [EOL] gs = [ group1 , group2 ] [EOL] [EOL] for g in gs : [EOL] for i in g : [EOL] for j in g : [EOL] aip ( users , i , j , robustness = [number] ) [EOL] [EOL] for i in g : [EOL] for j in g : [EOL] rpk ( i , j , robustness = [number] ) [EOL] [EOL] aip ( users , group1 [ - [number] ] , group2 [ [number] ] ) [EOL] aip ( users , group2 [ [number] ] , group1 [ - [number] ] ) [EOL] [EOL] rpk ( group1 [ - [number] ] , group2 [ [number] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import random [EOL] from utils import aip , rpk , gather_user_ip_ports [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] users = gather_user_ip_ports ( ) [EOL] for i in users . keys ( ) : [EOL] for j in users . keys ( ) : [EOL] if random . randint ( [number] , [number] ) > [number] : [EOL] aip ( users , i , j , robustness = [number] ) [EOL] rpk ( i , j , robustness = [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] [EOL] [EOL] import subprocess [EOL] from argparse import ArgumentParser [EOL] from utils import aip , rpk , gather_user_ip_ports [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] argparser = ArgumentParser ( ) [EOL] argparser . add_argument ( [string] , required = True ) [EOL] args = argparser . parse_args ( ) [EOL] [EOL] subprocess . check_call ( [ [string] , [string] , [string] . format ( args . username ) ] ) [EOL] [EOL] users = gather_user_ip_ports ( ) [EOL] [EOL] for i in users . keys ( ) : [EOL] aip ( users , args . username , i ) [EOL] [EOL] for i in users . keys ( ) : [EOL] rpk ( args . username , i ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import pckr [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] import os [EOL] [EOL] from termcolor import colored [EOL] [EOL] from . user import User [EOL] [EOL] [EOL] def _users ( ) : [EOL] [docstring] [EOL] users = [ ] [EOL] root = os . path . expanduser ( [string] ) [EOL] for sd in os . listdir ( root ) : [EOL] path = os . path . join ( root , sd ) [EOL] if os . path . isdir ( path ) : [EOL] users . append ( sd ) [EOL] return sorted ( users ) [EOL] [EOL] [EOL] def analyze_topo ( ) : [EOL] [docstring] [EOL] [EOL] cached_ips = dict ( ) [EOL] for u in _users ( ) : [EOL] user = User ( u ) [EOL] [EOL] path = os . path . join ( user . ipcache_path , [string] ) [EOL] if os . path . exists ( path ) : [EOL] ipcache = json . loads ( open ( path ) . read ( ) ) [EOL] for k in sorted ( ipcache . keys ( ) ) : [EOL] v = ipcache [ k ] [EOL] [EOL] ip_port = [string] . format ( v [ [string] ] , v [ [string] ] ) [EOL] [EOL] if k not in cached_ips : [EOL] cached_ips [ k ] = { ip_port : [ user . username ] } [EOL] else : [EOL] if ip_port in cached_ips [ k ] : [EOL] cached_ips [ k ] [ ip_port ] . append ( user . username ) [EOL] else : [EOL] cached_ips [ k ] [ ip_port ] = [ user . username ] [EOL] [EOL] import pprint [EOL] pprint . pprint ( cached_ips ) [EOL] consistent = True [EOL] for username , cached_ip in cached_ips . items ( ) : [EOL] if len ( set ( cached_ip ) ) > [number] : [EOL] print ( colored ( [string] . format ( username , cached_ip ) ) ) [EOL] consistent = False [EOL] [EOL] if consistent : [EOL] print ( colored ( [string] , [string] ) ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def dump_topo ( ) : [EOL] [docstring] [EOL] [EOL] for u in _users ( ) : [EOL] user = User ( u ) [EOL] print ( colored ( [string] * [number] , [string] ) ) [EOL] print ( [string] . format ( user . username ) ) [EOL] [EOL] path = os . path . join ( user . ipcache_path , [string] ) [EOL] if os . path . exists ( path ) : [EOL] ipcache = json . loads ( open ( path ) . read ( ) ) [EOL] if len ( ipcache . keys ( ) ) : [EOL] print ( [string] ) [EOL] for k in sorted ( ipcache . keys ( ) ) : [EOL] user2 = User ( k ) [EOL] [EOL] v = ipcache [ k ] [EOL] user_has_user2_pk = user . get_contact_public_key ( k ) is not None [EOL] user2_has_user_pk = user2 . get_contact_public_key ( user . username ) is not None [EOL] [EOL] if user2_has_user_pk : [EOL] has_user_pk_message = colored ( [string] . format ( user . username ) , [string] ) [EOL] else : [EOL] has_user_pk_message = colored ( [string] . format ( user . username ) , [string] ) [EOL] print ( k , colored ( v [ [string] ] , [string] ) , colored ( v [ [string] ] , [string] ) , colored ( [string] , [string] ) if user_has_user2_pk else colored ( [string] , [string] ) , has_user_pk_message ) [EOL] [EOL] if len ( user . public_key_requests ) : [EOL] print ( [string] ) [EOL] for ppk_req in user . public_key_requests : [EOL] print ( ppk_req [ [string] ] , ppk_req [ [string] ] ) [EOL] [EOL] if len ( user . public_key_responses ) : [EOL] print ( [string] ) [EOL] for ppk_req in user . public_key_responses : [EOL] print ( ppk_req [ [string] ] , ppk_req [ [string] ] ) [EOL] [EOL] print ( colored ( [string] * [number] , [string] ) ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] dump_topo ( ) [EOL] analyze_topo ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pckr [EOL] import typing [EOL] import io [EOL] [docstring] [EOL] [EOL] import os [EOL] import json [EOL] [EOL] import matplotlib . pyplot as plt [EOL] import networkx as nx [EOL] [EOL] from . user import User [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [EOL] users = [ ] [EOL] root = os . path . expanduser ( [string] ) [EOL] for sd in os . listdir ( root ) : [EOL] path = os . path . join ( root , sd ) [EOL] if os . path . isdir ( path ) : [EOL] users . append ( sd ) [EOL] [EOL] graph = nx . DiGraph ( ) [EOL] [EOL] for u in sorted ( users ) : [EOL] user = User ( u ) [EOL] print ( [string] * [number] ) [EOL] print ( [string] . format ( user . username ) ) [EOL] [EOL] path = os . path . join ( user . ipcache_path , [string] ) [EOL] if os . path . exists ( path ) : [EOL] ipcache = json . loads ( open ( path ) . read ( ) ) [EOL] for k in sorted ( ipcache . keys ( ) ) : [EOL] graph . add_edge ( user . username , k ) [EOL] [EOL] [comment] [EOL] file_handle = open ( [string] , [string] ) [EOL] file_handle . write ( [string] . encode ( [string] ) ) [comment] [EOL] nx . write_multiline_adjlist ( graph , file_handle , delimiter = [string] , encoding = [string] ) [EOL] [EOL] [comment] [EOL] file_handle = open ( [string] , [string] ) [EOL] H = nx . read_multiline_adjlist ( file_handle , delimiter = [string] , encoding = [string] ) [EOL] [EOL] for node in graph . nodes ( ) : [EOL] if node not in H : [EOL] print ( False ) [EOL] [EOL] print ( list ( graph . nodes ( ) ) ) [EOL] [EOL] pos = nx . spring_layout ( graph ) [EOL] nx . draw ( graph , pos , font_size = [number] , with_labels = False ) [EOL] for p in pos : [comment] [EOL] pos [ p ] [ [number] ] += [number] [EOL] nx . draw_networkx_labels ( graph , pos ) [EOL] plt . show ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , List , Type , Any [EOL] import pckr [EOL] import typing [EOL] import json [EOL] import uuid [EOL] import time [EOL] [EOL] from termcolor import colored [EOL] [EOL] from . . utilities import send_frame_users , split_contents , is_binary , encrypt_rsa , encrypt_symmetric , bytes2hexstr [EOL] from . . frame import Frame [EOL] [EOL] [EOL] class Message : [EOL] user = None [EOL] user2 = None [EOL] filename = None [EOL] mime_type = None [EOL] message_id = None [EOL] password = None [EOL] [EOL] def __init__ ( self , user , filename , mime_type , user2 ) : [EOL] self . user = user [EOL] self . user2 = user2 [EOL] self . filename = filename [EOL] self . mime_type = mime_type [EOL] self . message_id = str ( uuid . uuid4 ( ) ) [EOL] self . password = str ( uuid . uuid4 ( ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return json . dumps ( self . __dict__ , default = str ) [EOL] [EOL] def _send_key ( self ) : [EOL] public_key_text = self . user . get_contact_public_key ( self . user2 ) [EOL] if public_key_text is None : [EOL] print ( colored ( [string] . format ( self . user2 ) , [string] ) ) [EOL] return False [EOL] [EOL] key = dict ( password = self . password , message_id = self . message_id , md5 = [string] , length = [number] , filename = self . filename ) [EOL] [EOL] password = str ( uuid . uuid4 ( ) ) [EOL] password_encrypted = bytes2hexstr ( encrypt_rsa ( password , public_key_text ) ) [EOL] [EOL] key_encrypted = bytes2hexstr ( encrypt_symmetric ( json . dumps ( key ) , password ) ) [EOL] [EOL] payload = dict ( key = key_encrypted , password = password_encrypted ) [EOL] [EOL] key_frame = Frame ( action = [string] , payload = payload ) [EOL] response = send_frame_users ( key_frame , self . user , self . user2 ) [EOL] print ( [string] , response ) [EOL] [EOL] return True [EOL] [EOL] def _send_message ( self ) : [EOL] public_key_text = self . user . get_contact_public_key ( self . user2 ) [EOL] if public_key_text is None : [EOL] print ( colored ( [string] . format ( self . user2 ) , [string] ) ) [EOL] return False [EOL] [EOL] meta = dict ( message_id = self . message_id , filename = self . filename , mime_type = self . mime_type ) [EOL] [EOL] password = str ( uuid . uuid4 ( ) ) [EOL] password_encrypted = bytes2hexstr ( encrypt_rsa ( password , public_key_text ) ) [EOL] [EOL] meta_encrypted = bytes2hexstr ( encrypt_symmetric ( json . dumps ( meta ) , password ) ) [EOL] [EOL] if is_binary ( self . mime_type ) : [EOL] content = open ( self . filename , [string] ) . read ( ) [EOL] else : [EOL] content = open ( self . filename , [string] ) . read ( ) [EOL] [EOL] tt = time . time ( ) [EOL] et = time . time ( ) [EOL] print ( [string] , time . time ( ) - et ) [EOL] [EOL] content_splits = split_contents ( content ) [EOL] for index , content_split in enumerate ( content_splits ) : [EOL] encrypted_content = bytes2hexstr ( encrypt_symmetric ( content_split , self . password ) ) [EOL] ft = time . time ( ) [EOL] frame = Frame ( action = [string] , payload = dict ( password = password_encrypted , content = encrypted_content , meta = meta_encrypted ) ) [EOL] [EOL] response = send_frame_users ( frame , self . user , self . user2 ) [EOL] print ( [string] , index , response , time . time ( ) - ft , ( index / len ( content_splits ) * [number] ) ) [EOL] [EOL] print ( [string] , time . time ( ) - tt ) [EOL] return True [EOL] [EOL] def _send_message_term ( self ) : [EOL] public_key_text = self . user . get_contact_public_key ( self . user2 ) [EOL] if public_key_text is None : [EOL] print ( colored ( [string] . format ( self . user2 ) , [string] ) ) [EOL] return False [EOL] [EOL] term = dict ( message_id = self . message_id , filename = self . filename , mime_type = self . mime_type ) [EOL] [EOL] password = str ( uuid . uuid4 ( ) ) [EOL] password_encrypted = bytes2hexstr ( encrypt_rsa ( password , public_key_text ) ) [EOL] [EOL] term_encrypted = bytes2hexstr ( encrypt_symmetric ( json . dumps ( term ) , password ) ) [EOL] [EOL] payload = dict ( term = term_encrypted , password = password_encrypted ) [EOL] [EOL] term_frame = Frame ( action = [string] , payload = payload ) [EOL] [EOL] response = send_frame_users ( term_frame , self . user , self . user2 ) [EOL] print ( [string] , response ) [EOL] [EOL] return True [EOL] [EOL] def send ( self ) : [EOL] self . _send_key ( ) [EOL] self . _send_message ( ) [EOL] self . _send_message_term ( ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from . message import Message [EOL] [EOL] assert Message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Dict , Type , Any [EOL] import pckr [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] import datetime [EOL] import json [EOL] import os [EOL] import uuid [EOL] import pprint [EOL] [EOL] from . . frame import Frame [EOL] from . . utilities import send_frame_users , normalize_path , flatten [EOL] from . . utilities import encrypt_symmetric , encrypt_rsa , decrypt_symmetric , decrypt_rsa , generate_rsa_pub_priv [EOL] from . . utilities import hexstr2bytes , bytes2hexstr , str2hashed_hexstr [EOL] [EOL] [EOL] USER_ROOT = [string] [EOL] [EOL] [EOL] class User : [EOL] username = None [EOL] ipcache_data = None [EOL] [EOL] def __init__ ( self , username ) : [EOL] self . username = username [EOL] [EOL] ipcache_path = os . path . join ( self . ipcache_path , [string] ) [EOL] ipcache_data = dict ( ) [EOL] if os . path . exists ( ipcache_path ) : [EOL] try : [EOL] ipcache_data = json . loads ( open ( ipcache_path ) . read ( ) ) [EOL] except json . decoder . JSONDecodeError : [EOL] pass [EOL] self . ipcache_data = ipcache_data [EOL] [EOL] def __str__ ( self ) : [EOL] return self . username [EOL] [EOL] @ property def exists ( self ) : [EOL] [docstring] [EOL] [EOL] return os . path . exists ( self . path ) [EOL] [EOL] @ property def path ( self ) : [EOL] [docstring] [EOL] [EOL] return normalize_path ( os . path . join ( USER_ROOT , self . username ) ) [EOL] [EOL] @ property def private_key_path ( self ) : [EOL] [docstring] [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] @ property def current_ip_port ( self ) : [EOL] [comment] [EOL] try : [EOL] return json . loads ( open ( os . path . join ( self . path , [string] ) ) . read ( ) ) [EOL] except FileNotFoundError : [EOL] return None [EOL] [EOL] @ property def private_key_text ( self ) : [EOL] [docstring] [EOL] [EOL] return open ( self . private_key_path ) . read ( ) [EOL] [EOL] @ property def message_keys_path ( self ) : [EOL] [docstring] [EOL] [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] def pulse_network ( self , custody_chain = [ ] ) : [EOL] [docstring] [EOL] [EOL] custody_chain . append ( str2hashed_hexstr ( self . username ) ) [EOL] [EOL] for k in self . ipcache . keys ( ) : [EOL] hashed_username = str2hashed_hexstr ( k ) [EOL] if hashed_username not in custody_chain : [EOL] frame = Frame ( payload = dict ( custody_chain = custody_chain ) , action = [string] ) [EOL] [EOL] send_frame_users ( frame , self , k ) [EOL] [EOL] return True [EOL] [EOL] def surface ( self ) : [EOL] for k in self . ipcache . keys ( ) : [EOL] public_key_text = self . get_contact_public_key ( k ) [EOL] if public_key_text is not None : [EOL] password = str ( uuid . uuid4 ( ) ) [EOL] password_encrypted = bytes2hexstr ( encrypt_rsa ( password , public_key_text ) ) [EOL] [EOL] host_info = dict ( user2 = self . username , ip = self . current_ip_port [ [string] ] , port = int ( self . current_ip_port [ [string] ] ) ) [EOL] [EOL] host_info_encrypted = bytes2hexstr ( encrypt_symmetric ( json . dumps ( host_info ) . encode ( ) , password . encode ( ) ) ) [EOL] [EOL] response_frame = Frame ( payload = dict ( password = password_encrypted , host_info = host_info_encrypted ) , action = [string] ) [EOL] [EOL] send_frame_users ( response_frame , self , k ) [EOL] [EOL] return True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ property def messages_path ( self ) : [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] @ property def messages ( self ) : [EOL] messages = [ dict ( message_id = sd , created_at = datetime . datetime . fromtimestamp ( os . path . getmtime ( os . path . join ( self . messages_path , sd ) ) ) , files = flatten ( [ [ os . path . join ( d , f ) for f in files ] for d , sds , files in os . walk ( os . path . join ( self . messages_path , sd ) ) ] ) ) for sd in os . listdir ( self . messages_path ) ] [EOL] return messages [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ property def public_key_path ( self ) : [EOL] [docstring] [EOL] [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] @ property def public_key_text ( self ) : [EOL] [docstring] [EOL] [EOL] return open ( self . public_key_path ) . read ( ) [EOL] [EOL] @ property def public_keys_path ( self ) : [EOL] [docstring] [EOL] [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] @ property def public_keys ( self ) : [EOL] [docstring] [EOL] [EOL] pks = [ dict ( username = sd , modified_at = datetime . datetime . fromtimestamp ( os . path . getmtime ( os . path . join ( self . public_keys_path , sd , [string] ) ) ) ) for sd in os . listdir ( self . public_keys_path ) ] [EOL] return pks [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ property def seek_tokens_path ( self ) : [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] @ property def seek_tokens ( self ) : [EOL] sts = [ ] [EOL] for sd in os . listdir ( self . seek_tokens_path ) : [EOL] path = os . path . join ( self . seek_tokens_path , sd ) [EOL] sts . append ( dict ( username = sd . split ( [string] ) [ [number] ] , modified_at = datetime . datetime . fromtimestamp ( os . path . getmtime ( path ) ) ) ) [EOL] return sts [EOL] [EOL] def seek_user ( self , user2 ) : [EOL] public_key_text = self . get_contact_public_key ( user2 ) [EOL] if public_key_text is None : [EOL] return False [EOL] [EOL] seek_token = str ( uuid . uuid4 ( ) ) [EOL] seek_token_path = os . path . join ( self . seek_tokens_path , [string] . format ( user2 ) ) [EOL] [EOL] current_seek_tokens = [ ] [EOL] if os . path . exists ( seek_token_path ) : [EOL] txt = open ( seek_token_path ) . read ( ) [EOL] if txt != [string] : [EOL] current_seek_tokens = json . loads ( txt ) [EOL] if type ( current_seek_tokens ) == dict : [EOL] current_seek_tokens = [ ] [EOL] [EOL] with open ( seek_token_path , [string] ) as f : [EOL] current_seek_tokens . append ( seek_token ) [EOL] f . write ( json . dumps ( current_seek_tokens ) ) [EOL] [EOL] host_info = dict ( ip = self . current_ip_port [ [string] ] , port = self . current_ip_port [ [string] ] , public_key = self . public_key_text , user2 = self . username , seek_token = seek_token ) [EOL] [EOL] password = str ( uuid . uuid4 ( ) ) [EOL] password_encrypted = bytes2hexstr ( encrypt_rsa ( password , public_key_text ) ) [EOL] [EOL] encrypted_host_info = bytes2hexstr ( encrypt_symmetric ( json . dumps ( host_info ) . encode ( ) , password . encode ( ) ) ) [EOL] [EOL] [comment] [EOL] for k in self . ipcache . keys ( ) : [EOL] response_frame = Frame ( payload = dict ( host_info = encrypted_host_info , password = password_encrypted , custody_chain = [ str2hashed_hexstr ( self . username ) ] ) , action = [string] ) [EOL] [EOL] send_frame_users ( response_frame , self , k ) [EOL] [EOL] return True [EOL] [EOL] def get_contact_public_key ( self , contact ) : [EOL] try : [EOL] path = os . path . join ( self . public_keys_path , contact , [string] ) [EOL] return open ( path ) . read ( ) [EOL] except FileNotFoundError : [EOL] return None [EOL] [EOL] def init_directory_structure ( self ) : [EOL] assert os . path . exists ( self . path ) is False [EOL] os . makedirs ( self . path ) [EOL] [EOL] assert os . path . exists ( self . public_key_requests_path ) is False [EOL] os . makedirs ( self . public_key_requests_path ) [EOL] [EOL] assert os . path . exists ( self . public_key_responses_path ) is False [EOL] os . makedirs ( self . public_key_responses_path ) [EOL] [EOL] assert os . path . exists ( self . public_keys_path ) is False [EOL] os . makedirs ( self . public_keys_path ) [EOL] [EOL] assert os . path . exists ( self . messages_path ) is False [EOL] os . makedirs ( self . messages_path ) [EOL] [EOL] assert os . path . exists ( self . message_keys_path ) is False [EOL] os . makedirs ( self . message_keys_path ) [EOL] [EOL] assert os . path . exists ( self . ipcache_path ) is False [EOL] os . makedirs ( self . ipcache_path ) [EOL] [EOL] assert os . path . exists ( self . seek_tokens_path ) is False [EOL] os . makedirs ( self . seek_tokens_path ) [EOL] [EOL] return True [EOL] [EOL] def init_rsa ( self ) : [EOL] new_key = generate_rsa_pub_priv ( ) [EOL] with open ( self . public_key_path , [string] ) as f : [EOL] f . write ( new_key . publickey ( ) . exportKey ( [string] ) ) [EOL] [EOL] with open ( self . private_key_path , [string] ) as f : [EOL] f . write ( new_key . exportKey ( [string] ) ) [EOL] [EOL] return True [EOL] [EOL] def ping_user ( self , user2 ) : [EOL] frame = Frame ( action = [string] , payload = dict ( ) ) [EOL] response = send_frame_users ( frame , self , user2 ) [EOL] return response [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def challenge_user_pk ( self , user2 ) : [EOL] public_key_text = self . get_contact_public_key ( user2 ) [EOL] if public_key_text is not None : [EOL] challenge_text = str ( uuid . uuid4 ( ) ) [EOL] challenge_text_encrypted = bytes2hexstr ( encrypt_rsa ( challenge_text , public_key_text ) ) [EOL] [EOL] frame = Frame ( payload = dict ( user2 = self . username , challenge_text = challenge_text_encrypted ) , action = [string] ) [EOL] [EOL] response = send_frame_users ( frame , self , user2 ) [EOL] if response [ [string] ] is True and response [ [string] ] == challenge_text : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def challenge_user_has_pk ( self , user2 ) : [EOL] challenge_text = str ( uuid . uuid4 ( ) ) [EOL] [EOL] frame = Frame ( payload = dict ( user2 = self . username , challenge_text = challenge_text ) , action = [string] ) [EOL] [EOL] response = send_frame_users ( frame , self , user2 ) [EOL] print ( response ) [EOL] [EOL] if response [ [string] ] is True : [EOL] decrypted_challenge = decrypt_rsa ( hexstr2bytes ( response [ [string] ] ) , self . private_key_text ) . decode ( ) [EOL] [EOL] if challenge_text == decrypted_challenge : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ property def public_key_requests_path ( self ) : [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] @ property def public_key_requests ( self ) : [EOL] requests = [ ] [EOL] for d , sds , files in os . walk ( self . public_key_requests_path ) : [EOL] for f in files : [EOL] if f [ - [number] : ] == [string] : [EOL] request_path = os . path . join ( d , f ) [EOL] with open ( request_path ) as f : [EOL] request = json . loads ( f . read ( ) ) [EOL] request . update ( modified_at = datetime . datetime . fromtimestamp ( os . path . getmtime ( request_path ) ) ) [EOL] requests . append ( request ) [EOL] return requests [EOL] [EOL] def store_volunteered_public_key ( self , request ) : [EOL] public_keys_path = os . path . join ( self . public_keys_path , request [ [string] ] [ [string] ] ) [EOL] if not os . path . exists ( public_keys_path ) : [EOL] os . makedirs ( public_keys_path ) [EOL] [EOL] public_key_path = os . path . join ( public_keys_path , [string] ) [EOL] with open ( public_key_path , [string] ) as pkf : [EOL] pkf . write ( request [ [string] ] [ [string] ] ) [EOL] [EOL] return True [EOL] [EOL] def store_public_key_request ( self , request ) : [EOL] request_path = os . path . join ( self . public_key_requests_path , request [ [string] ] [ [string] ] ) [EOL] if not os . path . exists ( request_path ) : [EOL] os . makedirs ( request_path ) [EOL] [EOL] with open ( os . path . join ( request_path , [string] ) , [string] ) as f : [EOL] f . write ( json . dumps ( request [ [string] ] ) ) [EOL] [EOL] return True [EOL] [EOL] def process_public_key_request ( self , request ) : [EOL] print ( [string] . format ( request [ [string] ] ) ) [EOL] print ( request ) [EOL] [EOL] password = str ( uuid . uuid4 ( ) ) [EOL] password_rsaed = bytes2hexstr ( encrypt_rsa ( password , request [ [string] ] ) ) [EOL] [EOL] public_key_encrypted = bytes2hexstr ( encrypt_symmetric ( self . public_key_text , password ) ) [EOL] [EOL] frame = Frame ( action = [string] , payload = dict ( public_key = public_key_encrypted , user2 = self . username , password = password_rsaed ) ) [EOL] [EOL] frame_response = send_frame_users ( frame , self , request [ [string] ] ) [EOL] pprint . pprint ( frame_response ) [EOL] [EOL] return True [EOL] [EOL] def remove_public_key_request ( self , request ) : [EOL] request_path = os . path . join ( self . public_key_requests_path , request [ [string] ] , [string] ) [EOL] if os . path . exists ( request_path ) : [EOL] os . remove ( request_path ) [EOL] return True [EOL] else : [EOL] print ( [string] ) [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ property def public_key_responses_path ( self ) : [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] @ property def public_key_responses ( self ) : [EOL] responses = [ ] [EOL] for d , sds , files in os . walk ( self . public_key_responses_path ) : [EOL] for f in files : [EOL] if f [ - [number] : ] == [string] : [EOL] response_path = os . path . join ( d , f ) [EOL] with open ( response_path ) as f : [EOL] response = json . loads ( f . read ( ) ) [EOL] response . update ( modified_at = datetime . datetime . fromtimestamp ( os . path . getmtime ( response_path ) ) ) [EOL] responses . append ( response ) [EOL] [EOL] return responses [EOL] [EOL] def store_public_key_response ( self , frame ) : [EOL] response_path = os . path . join ( self . public_key_responses_path , frame [ [string] ] [ [string] ] ) [EOL] [EOL] if not os . path . exists ( response_path ) : [EOL] os . makedirs ( response_path ) [EOL] [EOL] with open ( os . path . join ( response_path , [string] ) , [string] ) as f : [EOL] f . write ( json . dumps ( frame [ [string] ] ) ) [EOL] [EOL] return True [EOL] [EOL] def process_public_key_response ( self , response ) : [EOL] print ( response ) [EOL] public_keys_path = os . path . join ( self . public_keys_path , response [ [string] ] ) [EOL] if not os . path . exists ( public_keys_path ) : [EOL] os . makedirs ( public_keys_path ) [EOL] [EOL] public_key_path = os . path . join ( public_keys_path , [string] ) [EOL] with open ( public_key_path , [string] ) as pkf : [EOL] password = decrypt_rsa ( hexstr2bytes ( response [ [string] ] ) , self . private_key_text ) [EOL] decrypted_text = decrypt_symmetric ( hexstr2bytes ( response [ [string] ] ) , password ) [EOL] pkf . write ( decrypted_text ) [EOL] [EOL] return True [EOL] [EOL] def remove_public_key_response ( self , response ) : [EOL] response_path = os . path . join ( self . public_key_responses_path , response [ [string] ] , [string] ) [EOL] if os . path . exists ( response_path ) : [EOL] os . remove ( response_path ) [EOL] [EOL] else : [EOL] assert False [EOL] [EOL] return True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ property def ipcache_path ( self ) : [EOL] [docstring] [EOL] [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] @ property def ipcache ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] path = os . path . join ( self . ipcache_path , [string] ) [EOL] return json . loads ( open ( path ) . read ( ) ) [EOL] except json . decoder . JSONDecodeError : [EOL] return dict ( ) [EOL] except FileNotFoundError : [EOL] return dict ( ) [EOL] [EOL] def remove_contact_ip_port ( self , username ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] del self . ipcache_data [ username ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] path = os . path . join ( self . ipcache_path , [string] ) [EOL] with open ( path , [string] ) as f : [EOL] f . write ( json . dumps ( self . ipcache_data ) ) [EOL] [EOL] return True [EOL] [EOL] def get_contact_ip_port ( self , username ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] return ( self . ipcache [ username ] [ [string] ] , self . ipcache [ username ] [ [string] ] ) [EOL] except KeyError : [EOL] return None , None [EOL] [EOL] def set_contact_ip_port ( self , username , ip , port ) : [EOL] [docstring] [EOL] [EOL] self . ipcache_data [ username ] = dict ( ip = ip , port = port ) [EOL] [EOL] path = os . path . join ( self . ipcache_path , [string] ) [EOL] with open ( path , [string] ) as f : [EOL] f . write ( json . dumps ( self . ipcache_data ) ) [EOL] [EOL] return True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def hashed_ipcache ( self ) : [EOL] [docstring] [EOL] [EOL] hips = dict ( ) [EOL] [EOL] for k , v in self . ipcache . items ( ) : [EOL] hips [ str2hashed_hexstr ( k ) ] = str2hashed_hexstr ( json . dumps ( v ) ) [EOL] [EOL] return hips [EOL] [EOL] def flush_inconsistent_user ( self , user2 ) : [EOL] [docstring] [EOL] [EOL] for k in self . ipcache . keys ( ) : [EOL] [comment] [EOL] [comment] [EOL] hashed_username = str2hashed_hexstr ( k ) [EOL] if hashed_username . strip ( ) == user2 . strip ( ) : [EOL] self . remove_contact_ip_port ( user2 ) [EOL] self . seek_user ( user2 ) [EOL] [EOL] return True [EOL] [EOL] def check_net_topo ( self , custody_chain = [ ] , hashed_ipcaches = dict ( ) ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] custody_chain . append ( str2hashed_hexstr ( self . username ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for k , v in self . hashed_ipcache ( ) . items ( ) : [EOL] [EOL] [comment] [EOL] if k in hashed_ipcaches and hashed_ipcaches [ k ] != v : [EOL] [EOL] [comment] [EOL] for notification_user in self . ipcache . keys ( ) : [EOL] frame = Frame ( action = [string] , payload = dict ( inconsistent_user = k ) ) [EOL] [EOL] send_frame_users ( frame , self , notification_user ) [EOL] else : [EOL] hashed_ipcaches [ k ] = v [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for k in self . ipcache . keys ( ) : [EOL] hashed_username = str2hashed_hexstr ( k ) [EOL] if hashed_username not in custody_chain : [EOL] response_frame = Frame ( action = [string] , payload = dict ( custody_chain = custody_chain , hashed_ipcaches = hashed_ipcaches ) ) [EOL] [EOL] send_frame_users ( response_frame , self , k ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pckr.frame.frame.Frame$ 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from . user import User [EOL] [EOL] assert User [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] formatter = logging . Formatter ( [string] ) [EOL] [EOL] [EOL] def setup_logger ( name , log_file , level = logging . INFO ) : [EOL] [docstring] [EOL] [EOL] handler = logging . FileHandler ( log_file ) [EOL] handler . setFormatter ( formatter ) [EOL] [EOL] logger = logging . getLogger ( name ) [EOL] logger . setLevel ( level ) [EOL] logger . addHandler ( handler ) [EOL] [EOL] return logger [EOL] [EOL] [EOL] assert_logger = setup_logger ( [string] , [string] ) [EOL] surface_logger = setup_logger ( [string] , [string] ) [EOL] debug_logger = setup_logger ( [string] , [string] , level = logging . DEBUG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import argparse [EOL] import typing [EOL] import hashlib [EOL] import socket [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from argparse import Namespace [EOL] import binascii [EOL] import hashlib [EOL] import json [EOL] import os [EOL] import socket [EOL] [EOL] from Crypto . Cipher import PKCS1_OAEP [EOL] from Crypto . PublicKey import RSA [EOL] from termcolor import colored [EOL] from typing import Any [EOL] [EOL] import blowfish [EOL] [EOL] [EOL] def flatten ( data_list ) : [EOL] [docstring] [EOL] [EOL] return [ item for sublist in data_list for item in sublist ] [EOL] [EOL] [EOL] def command_header ( action , args ) : [EOL] [docstring] [EOL] [EOL] return colored ( [string] . format ( [string] * [number] , action , [string] . join ( [ [string] . format ( k , v ) for k , v in vars ( args ) . items ( ) ] ) , [string] * [number] ) , [string] ) [EOL] [EOL] [EOL] def split_contents ( contents , split_size = [number] ) : [EOL] [docstring] [EOL] [EOL] splits = [ ] [EOL] index = [number] [EOL] while index < len ( contents ) : [EOL] splits . append ( contents [ index : index + split_size ] ) [EOL] index = index + split_size [EOL] return splits [EOL] [EOL] [EOL] def hexstr2bytes ( hs ) : [EOL] [docstring] [EOL] [EOL] return binascii . unhexlify ( hs ) [EOL] [EOL] [EOL] def bytes2hexstr ( bs ) : [EOL] [docstring] [EOL] [EOL] return binascii . hexlify ( bs ) . decode ( ) [EOL] [EOL] [EOL] def str2hashed_hexstr ( s ) : [EOL] [docstring] [EOL] [EOL] if type ( s ) == str : [EOL] s = s . encode ( ) [EOL] [EOL] m = hashlib . sha256 ( ) [EOL] m . update ( s ) [EOL] return bytes2hexstr ( m . digest ( ) ) [EOL] [EOL] [EOL] def pad_content ( content ) : [EOL] [docstring] [EOL] [EOL] padder = [string] [EOL] if type ( content ) == bytes : [EOL] padder = [string] [EOL] content = content + ( padder * ( [number] - ( len ( content ) % [number] ) ) ) [EOL] return content [EOL] [EOL] [EOL] def generate_rsa_pub_priv ( ) : [EOL] return RSA . generate ( [number] , e = [number] ) [EOL] [EOL] [EOL] def encrypt_rsa ( content , public_key_text ) : [EOL] if type ( content ) == str : [EOL] content = content . encode ( ) [EOL] [EOL] return PKCS1_OAEP . new ( RSA . importKey ( public_key_text ) ) . encrypt ( content ) [EOL] [EOL] [EOL] def decrypt_rsa ( content , private_key_text ) : [EOL] if type ( content ) == str : [EOL] content = content . encode ( ) [EOL] [EOL] return PKCS1_OAEP . new ( RSA . importKey ( private_key_text ) ) . decrypt ( content ) [EOL] [EOL] [EOL] def encrypt_symmetric ( content , password , callback = None ) : [EOL] [docstring] [EOL] [EOL] if type ( password ) is not bytes : [EOL] password = password . encode ( ) [EOL] [EOL] content = pad_content ( content ) [EOL] if type ( content ) is not bytes : [EOL] content = content . encode ( ) [EOL] [EOL] cipher = blowfish . Cipher ( password ) [EOL] data_encrypted = [string] . join ( cipher . encrypt_ecb ( content ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return data_encrypted [EOL] [EOL] [EOL] def decrypt_symmetric ( content , password , decode = True ) : [EOL] [docstring] [EOL] [EOL] if type ( password ) is not bytes : [EOL] password = password . encode ( ) [EOL] [EOL] if type ( content ) is not bytes : [EOL] content = content . encode ( ) [EOL] [EOL] cipher = blowfish . Cipher ( password ) [EOL] data_decrypted = [string] . join ( cipher . decrypt_ecb ( content ) ) [EOL] [EOL] if decode : [EOL] return data_decrypted . decode ( ) [EOL] else : [EOL] return data_decrypted [EOL] [EOL] [EOL] def normalize_path ( path ) : [EOL] [docstring] [EOL] [EOL] return os . path . normpath ( os . path . abspath ( os . path . expanduser ( path ) ) ) [EOL] [EOL] [EOL] def is_binary ( mt ) : [EOL] [docstring] [EOL] [EOL] return mt in [ [string] , [string] ] [EOL] [EOL] [EOL] def send_frame_users ( frame , user1 , user2 ) : [EOL] [docstring] [EOL] [EOL] ip , port = user1 . get_contact_ip_port ( user2 ) [EOL] [EOL] if ip and port : [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] [EOL] try : [EOL] sock . connect ( ( ip . strip ( ) , int ( port ) ) ) [EOL] frame_str = str ( frame ) . encode ( ) [EOL] len_sent = sock . send ( frame_str ) [EOL] assert len_sent == len ( frame_str ) [EOL] response = json . loads ( sock . recv ( [number] ) . decode ( ) ) [EOL] sock . close ( ) [EOL] return response [EOL] except ConnectionRefusedError : [EOL] return dict ( success = False , error = [string] ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] return dict ( success = False , error = [string] . format ( user2 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from . frame import Frame [EOL] [EOL] assert Frame [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import builtins [EOL] import typing [EOL] import pckr [EOL] import json [EOL] import uuid [EOL] [EOL] [EOL] class Frame : [EOL] frame_id = None [EOL] payload = None [EOL] action = None [EOL] [EOL] def __init__ ( self , payload , action ) : [EOL] self . frame_id = str ( uuid . uuid4 ( ) ) [EOL] self . action = action [EOL] self . payload = payload [EOL] [EOL] def __unicode__ ( self ) : [EOL] return str ( self ) [EOL] [EOL] def __str__ ( self ) : [EOL] return json . dumps ( self . __dict__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0