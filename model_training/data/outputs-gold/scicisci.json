[comment] [EOL] [comment] [EOL] [EOL] [EOL] def set_prefs ( prefs ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] prefs [ [string] ] = True [EOL] prefs [ [string] ] = False [EOL] [EOL] [comment] [EOL] prefs [ [string] ] = True [EOL] [comment] [EOL] prefs [ [string] ] = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = True [EOL] [EOL] [comment] [EOL] prefs [ [string] ] = True [EOL] [EOL] [comment] [EOL] prefs [ [string] ] = [number] [EOL] [EOL] [comment] [EOL] prefs [ [string] ] = True [EOL] prefs [ [string] ] = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = [ ] [EOL] [EOL] [comment] [EOL] prefs [ [string] ] = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] prefs [ [string] ] = ( [string] ) [EOL] [EOL] [EOL] def project_opened ( project ) : [EOL] [docstring] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Union , Dict , Any [EOL] import sci [EOL] import tests [EOL] import typing [EOL] import builtins [EOL] from sci . refs import _Ref , _RefInterface , Syringe , ref_from_dict [EOL] from sci import units [EOL] import pytest [EOL] from interface import implements [EOL] [EOL] [EOL] def test_todict ( ) : [EOL] [docstring] [EOL] class ExampleRef ( _Ref , implements ( _RefInterface ) ) : [EOL] def __init__ ( self , name , ** params ) : [EOL] params . update ( { [string] : [string] } ) [EOL] super ( ) . __init__ ( name = name , ** params ) [EOL] [EOL] params = { [string] : [number] , [string] : [number] } [EOL] ex = ExampleRef ( [string] , ** params ) [EOL] actual = ex . to_dict ( ) [EOL] expected = { [string] : [string] , [string] : [string] , [string] : params } [EOL] assert actual == expected [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , { [string] : [string] } ) ] ) def test_fromdict ( inputs ) : [EOL] [docstring] [EOL] input = { [string] : inputs [ [number] ] , [string] : [string] , [string] : inputs [ [number] ] } [EOL] [EOL] test_ref = ref_from_dict ( input = input ) [EOL] assert test_ref . type == inputs [ [number] ] [EOL] assert test_ref . name == [string] [EOL] assert test_ref . params == inputs [ [number] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) @ pytest . mark . parametrize ( [string] , [ [number] * units . milliliters , [number] * units . microliters ] ) def test_syringe ( name , liquid_volume ) : [EOL] [docstring] [EOL] s = Syringe ( name , liquid_volume = liquid_volume ) [EOL] actual = s . to_dict ( ) [EOL] expected = { [string] : name , [string] : [string] , [string] : { [string] : str ( liquid_volume ) } } [EOL] assert actual == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List , Any [EOL] import sci [EOL] import tests [EOL] import typing [EOL] import builtins [EOL] from sci . instruments import _Instrument , _InstrumentInterface , SyringePump [EOL] from sci . refs import _Ref , _RefInterface , ref_type , Syringe [EOL] from sci import units [EOL] [EOL] from interface import implements [EOL] from typing import List , Type , Union [EOL] import pytest [EOL] [EOL] def test_todict ( ) : [EOL] [docstring] [EOL] class ExampleRef ( _Ref , implements ( _RefInterface ) ) : [EOL] def __init__ ( self , name , ** params ) : [EOL] params . update ( { [string] : [string] } ) [EOL] super ( ) . __init__ ( name = name , ** params ) [EOL] [EOL] params = { [string] : [number] , [string] : [number] } [EOL] ref = ExampleRef ( name = [string] ) [EOL] [EOL] class ExampleInstrument ( _Instrument , implements ( _InstrumentInterface ) , ) : [EOL] def __init__ ( self , refs , ** params ) : [EOL] super ( ) . __init__ ( refs = refs , ** params ) [EOL] [EOL] @ staticmethod def instrument_type ( ) : [EOL] return [string] [EOL] [EOL] def status ( self ) : [EOL] pass [EOL] [EOL] params = { [string] : [number] , [string] : [number] } [EOL] ex = ExampleInstrument ( [ ref ] , ** params ) [EOL] actual = ex . to_dict ( ) [EOL] expected = { [string] : [string] , [string] : [ ref ] , [string] : params } [EOL] assert actual [ [string] ] == expected [ [string] ] [EOL] [comment] [EOL] assert actual [ [string] ] == expected [ [string] ] [EOL] [EOL] @ pytest . fixture def sp ( ) : [EOL] syringe = Syringe ( [string] , liquid_volume = [number] * units . milliliters ) [EOL] return SyringePump ( refs = [ syringe ] ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] * units . microliters / units . minute ] ) @ pytest . mark . parametrize ( [string] , [ [number] * units . milliliter ] ) @ pytest . mark . parametrize ( [string] , [ [number] * units . seconds , [number] * units . minutes ] ) def test_sp_infuse ( sp , rate , volume , time ) : [EOL] [docstring] [EOL] [comment] [EOL] sp . infuse ( rate = rate , volume = volume ) [EOL] [comment] [EOL] sp . infuse ( rate = rate , time = time ) [EOL] [comment] [EOL] sp . infuse ( volume = volume , time = time ) [EOL] [comment] [EOL] with pytest . raises ( ValueError ) : [EOL] sp . infuse ( rate = rate , volume = volume , time = time ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] * units . microliters / units . minute ] ) @ pytest . mark . parametrize ( [string] , [ [number] * units . milliliter ] ) @ pytest . mark . parametrize ( [string] , [ [number] * units . seconds , [number] * units . minutes ] ) def test_sp_withdraw ( sp , rate , volume , time ) : [EOL] [docstring] [EOL] [comment] [EOL] sp . withdraw ( rate = rate , volume = volume ) [EOL] [comment] [EOL] sp . withdraw ( rate = rate , time = time ) [EOL] [comment] [EOL] sp . withdraw ( volume = volume , time = time ) [EOL] [comment] [EOL] with pytest . raises ( ValueError ) : [EOL] sp . withdraw ( rate = rate , volume = volume , time = time ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[sci.refs.ref_type],typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[sci.refs.ref_type],typing.List[builtins.str]]$ 0 $typing.Union[typing.List[sci.refs.ref_type],typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Any [EOL] import sci [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from . import sci_path [EOL] from sci . instruments import SyringePump [EOL] [EOL] from typing import Type , Union , List [EOL] from enum import Enum [EOL] from collections import namedtuple [EOL] from abc import ABC , abstractmethod [EOL] [EOL] from tinydb import TinyDB , Query [EOL] [EOL] import serial . tools . list_ports as serial_list [EOL] [EOL] class InstrumentModel : [EOL] [docstring] [EOL] def __init__ ( self , instrument , brand , model ) : [EOL] self . type = instrument . instrument_type ( ) [EOL] self . brand = brand [EOL] self . model = model [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . type , [string] : self . brand , [string] : self . model , } [EOL] [EOL] @ classmethod def from_dict ( cls , ** model_dict ) : [EOL] instance = cls ( instrument = SyringePump , brand = model_dict . get ( [string] ) , model = model_dict . get ( [string] ) ) [EOL] instance . type = model_dict . get ( [string] ) [EOL] return instance [EOL] [EOL] class DriverDefinition : [EOL] def __init__ ( self , name , model , grpc_address , connection_settings , instrument_settings ) : [EOL] self . name = name [EOL] self . model = model [EOL] self . grpc_address = grpc_address [EOL] self . connection_settings = connection_settings [EOL] self . instrument_settings = instrument_settings [EOL] [EOL] @ classmethod def from_dict ( cls , ** driver_dict ) : [EOL] model = InstrumentModel . from_dict ( ** driver_dict . get ( [string] ) ) [EOL] return cls ( name = driver_dict . get ( [string] ) , model = model , grpc_address = driver_dict . get ( [string] ) , connection_settings = driver_dict . get ( [string] ) , instrument_settings = driver_dict . get ( [string] ) ) [EOL] [EOL] class ConnectionSettings ( ABC ) : [EOL] @ abstractmethod def to_dict ( self ) : [EOL] pass [EOL] [EOL] class SerialConnectionSettings ( ConnectionSettings ) : [EOL] def __init__ ( self , hwid = None , baudrate = [number] , address = [number] ) : [EOL] self . hwid = hwid [EOL] self . baudrate = baudrate [EOL] self . address = address [EOL] [EOL] def find_hwid ( self , port ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . hwid , [string] : self . baudrate , [string] : self . address , } [EOL] [EOL] class DriverDB : [EOL] [docstring] [EOL] def __init__ ( self , filepath = sci_path ( [string] ) ) : [EOL] self . db = TinyDB ( filepath ) [EOL] self . instruments = Query ( ) [EOL] [EOL] def add_driver ( self , name , model , grpc_address , connection_settings , instrument_settings ) : [EOL] [docstring] [EOL] if self . db . contains ( self . instruments . name == name ) : [EOL] raise ValueError ( f' [string] { name } [string] ' ) [EOL] update = { [string] : name , [string] : model . to_dict ( ) , [string] : grpc_address , [string] : connection_settings . to_dict ( ) , [string] : instrument_settings , } [EOL] self . db . insert ( update ) [EOL] [EOL] def get_drivers ( self , instrument_type = None ) : [EOL] [docstring] [EOL] if instrument_type : [EOL] results = self . db . search ( self . instruments . model . type == instrument_type . instrument_type ( ) ) [EOL] if results : [EOL] return [ DriverDefinition . from_dict ( ** result ) for result in results ] [EOL] else : [EOL] return [ { [string] : instrument_type . instrument_type ( ) } ] [EOL] else : [EOL] results = self . db . all ( ) [EOL] return [ DriverDefinition . from_dict ( ** result ) for result in results ] [EOL] [EOL] def remove_driver ( self , name ) : [EOL] [docstring] [EOL] self . db . remove ( self . instruments . name == name ) [EOL] [EOL] [EOL] def start_driver ( instrument , ** kwargs ) : [EOL] pass	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $InstrumentModel$ 0 $builtins.str$ 0 $typing.Type[ConnectionSettings]$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $InstrumentModel$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[ConnectionSettings]$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Any , Match , Optional , Dict [EOL] import sci [EOL] import typing [EOL] import builtins [EOL] from sci . definitions import StepDefinition , ProtcolExecutionResult [EOL] from sci . errors import SciExecutionError [EOL] from sci . driver import DriverDB , start_driver [EOL] [EOL] from whaaaaat import ( style_from_dict , Token , prompt , default_style , Separator ) [EOL] [EOL] import re [EOL] from functools import wraps [EOL] from inspect import getargspec [EOL] [EOL] class _Step : [EOL] def __init__ ( self , description , inputs , instruments , outputs , ** kwargs ) : [EOL] self . description = description [EOL] self . inputs = inputs [EOL] self . instruments = instruments [EOL] self . outputs = outputs [EOL] [EOL] [EOL] def __call__ ( self , wrapped ) : [EOL] return StepDefinition ( description = self . description , inputs = self . inputs , instruments = self . instruments , outputs = self . outputs , step_fn = wrapped ) [EOL] [EOL] def step ( * , description , inputs , instruments , outputs ) : [EOL] return _Step ( description = description , inputs = inputs , instruments = instruments , outputs = outputs ) [EOL] [EOL] def check_refs_unique ( steps ) : [EOL] pass [EOL] [EOL] def find_unique_instruments ( instruments ) : [EOL] refs = [ ] [EOL] final_instruments = [ ] [EOL] [EOL] def add_refs_as_json ( instrument , ref_list , instrument_list ) : [EOL] if type ( instrument . refs ) == str : [EOL] if instrument . refs not in ref_list : [EOL] ref_list . append ( instrument . refs ) [EOL] instrument_list . append ( instrument ) [EOL] else : [EOL] for ref in instrument . refs : [EOL] if ref . to_dict ( ) not in ref_list : [EOL] ref_list . append ( ref . to_dict ( ) ) [EOL] instrument_list . append ( instrument ) [EOL] return ref_list , instrument_list [EOL] [EOL] for instrument in instruments : [EOL] refs , final_instruments = add_refs_as_json ( instrument , refs , final_instruments ) [EOL] [EOL] return final_instruments [EOL] [EOL] class InstrumentResolutionDefintion : [EOL] def __init__ ( self , instruments_needed , instruments_available ) : [EOL] self . instruments_needed = instruments_needed [EOL] self . instruments_available = instruments_available [EOL] [EOL] def find_available_instruments_types ( available_instruments ) : [EOL] available_tally = { } [EOL] for db_instrument in available_instruments : [EOL] try : [EOL] available_tally [ db_instrument . model . type ] += [number] [EOL] except KeyError : [EOL] available_tally [ db_instrument . model . type ] = [number] [EOL] return available_tally [EOL] [EOL] def format_driver ( index , instrument ) : [EOL] return f'{ instrument . name } [string] { instrument . model . brand } [string] { instrument . model . model } [string] { instrument . model . type } [string] { str ( index ) } [string] ' [EOL] [EOL] def resolve_instruments ( instruments_by_step , db ) : [EOL] [docstring] [EOL] [comment] [EOL] instruments_needed = [ instrument for instruments in instruments_by_step for instrument in instruments ] [EOL] instruments_needed = find_unique_instruments ( instruments_needed ) [comment] [EOL] [EOL] [comment] [EOL] needed_instrument_types = { } [EOL] for instrument in instruments_needed : [EOL] try : [EOL] needed_instrument_types [ instrument . instrument_type ( ) ] += [number] [EOL] except KeyError : [EOL] needed_instrument_types [ instrument . instrument_type ( ) ] = [number] [EOL] [EOL] [comment] [EOL] instruments_available = db . get_drivers ( ) [EOL] available_instrument_types = find_available_instruments_types ( instruments_available ) [EOL] [EOL] [comment] [EOL] missing_instruments = [ ] [EOL] for instrument in instruments_needed : [EOL] try : [EOL] assert needed_instrument_types [ instrument . instrument_type ( ) ] <= available_instrument_types [ instrument . instrument_type ( ) ] [EOL] except AssertionError : [EOL] missing_instruments . append ( instrument ) [EOL] [EOL] [comment] [EOL] if missing_instruments : [EOL] for missing_instrument in missing_instruments : [EOL] type = missing_instrument . instrument_type ( ) [EOL] print ( f" [string] { type }" ) [EOL] print ( f" [string] { needed_instrument_types [ type ] } [string] { type } [string] { available_instrument_types [ type ] } [string] " ) [EOL] exit ( [number] ) [EOL] [EOL] [comment] [EOL] return InstrumentResolutionDefintion ( instruments_needed , instruments_available ) [EOL] [EOL] style = style_from_dict ( { Token . Separator : [string] , Token . QuestionMark : [string] , Token . Selected : [string] , Token . Pointer : [string] , Token . Instruction : [string] , Token . Answer : [string] , Token . Question : [string] , } ) [EOL] [EOL] def _driver_setup ( instruments_by_step , instrument_db ) : [EOL] [docstring] [EOL] [comment] [EOL] check_refs_unique ( instruments_by_step ) [comment] [EOL] [EOL] [comment] [EOL] resolved_instruments = resolve_instruments ( instruments_by_step , instrument_db ) [EOL] ri = resolved_instruments [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] for instrument in ri . instruments_needed : [EOL] [comment] [EOL] refs = [string] . join ( [ repr ( ref ) + [string] for ref in instrument . refs ] ) [EOL] refs = refs . rstrip ( [string] ) [EOL] if len ( instrument . refs ) == [number] : [EOL] message = f" [string] { instrument . instrument_type ( ) } [string] { refs } [string] " [EOL] else : [EOL] message = f" [string] { instrument . instrument_type ( ) } [string] { refs } [string] " [EOL] [EOL] [comment] [EOL] choices = [ format_driver ( i , available_instrument ) for i , available_instrument in enumerate ( ri . instruments_available ) if available_instrument . model . type == instrument . instrument_type ( ) ] [EOL] choices . append ( [string] ) [EOL] [EOL] question = [ { [string] : [string] , [string] : [string] , [string] : message , [string] : choices } ] [EOL] answer = prompt ( question , style = style ) [EOL] answer = answer [ [string] ] [EOL] match = re . search ( [string] , answer , re . M ) [comment] [EOL] if match : [EOL] index = match . group ( ) [EOL] index = int ( float ( index ) ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] available_instrument = ri . instruments_available [ index ] [EOL] start_driver ( available_instrument ) [EOL] [EOL] [comment] [EOL] return [ [ available_instrument . grpc_address for instrument in instruments if instrument . instrument_type ( ) == available_instrument . model . type ] for instruments in instruments_by_step ] [EOL] [EOL] return addresses [EOL] [EOL] def _start_grpc_clients ( grpc_addresses , steps ) : [EOL] [comment] [EOL] [ instrument [ [number] ] . _start_grpc_client ( grpc_addresses [ i ] [ j ] ) for i , step in enumerate ( steps ) for j , instrument in enumerate ( step . instruments ) ] [EOL] return steps [EOL] [EOL] class Protocol : [EOL] def __init__ ( self , name , description , steps , ** kwargs ) : [EOL] self . name = name [EOL] self . description = description [EOL] self . steps = steps [EOL] filepath = kwargs . get ( [string] ) [EOL] self . db = DriverDB ( filepath ) if filepath else DriverDB ( ) [EOL] [EOL] def __call__ ( self ) : [EOL] [comment] [EOL] instruments_by_step = [ [ instrument_tuple [ [number] ] for instrument_tuple in step . instruments ] for step in self . steps ] [EOL] grpc_addresses = _driver_setup ( instruments_by_step , self . db ) [EOL] self . steps = _start_grpc_clients ( grpc_addresses , self . steps ) [EOL] [EOL] [comment] [EOL] results = [ ] [EOL] for result in _execute_protocol_iterator ( self . steps ) : [EOL] results . append ( result ) [EOL] [EOL] return ProtcolExecutionResult ( results ) [EOL] [EOL] def _execute_protocol_iterator ( steps ) : [EOL] for step in steps : [EOL] try : [EOL] result = _execute_step ( step ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] yield [string] [EOL] [EOL] except SciExecutionError : [EOL] [comment] [EOL] pass [EOL] [EOL] def _compose_args ( inputs , instruments ) : [EOL] inputs = { input [ [number] ] : input [ [number] ] for input in inputs } [EOL] inputs . update ( { instrument [ [number] ] : instrument [ [number] ] for instrument in instruments } ) [EOL] return inputs [EOL] [EOL] def _execute_step ( step ) : [EOL] new_args = _compose_args ( step . inputs , step . instruments ) [EOL] return step . step_fn ( * new_args ) [EOL] [EOL] def _execute_output ( result , step ) : [EOL] return	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $sci.driver.DriverDB$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] class SciExecutionError ( Exception ) : [EOL] pass	0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] __version__ = [string] [EOL] __author__ = [string] [EOL] __all__ = [ ] [EOL] [EOL] from . _units import units [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] def sci_path ( filename = None ) : [EOL] home = str ( Path . home ( ) ) [EOL] if filename : [EOL] return home + [string] + filename [EOL] else : [EOL] return home + [string]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from pint import UnitRegistry [EOL] [EOL] [comment] [EOL] [comment] [EOL] units = UnitRegistry ( ) [EOL] Q_ = units . Quantity	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] from pint . quantity import _Quantity [EOL] from sci import units [EOL] from pint . errors import UndefinedUnitError [EOL] [EOL] def check_units ( value , dimension ) : [EOL] [docstring] [EOL] try : [EOL] if value . check ( dimension ) : [EOL] return True [EOL] else : [EOL] raise ValueError ( f'{ value } [string] { dimension } [string] ' ) [EOL] except AttributeError : [EOL] raise ValueError ( f'{ value } [string] { dimension } [string] ' ) [EOL] [EOL] [EOL] def filter_dict_values ( input , filter ) : [EOL] [docstring] [EOL] for k , v in input . items ( ) : [EOL] if isinstance ( v , dict ) : [EOL] input [ k ] = filter_dict_values ( v , filter ) [EOL] else : [EOL] input [ k ] = filter ( v ) [EOL] return input [EOL] [EOL] def stringify ( input ) : [EOL] [docstring] [EOL] if isinstance ( input , _Quantity ) : [EOL] return str ( input ) [EOL] else : [EOL] return input [EOL] [EOL] def pintify ( input ) : [EOL] [docstring] [EOL] try : [EOL] return units ( input ) [EOL] except UndefinedUnitError : [EOL] return input [EOL] [EOL] def check_kwargs ( key , caller , ** kwargs ) : [EOL] [docstring] [EOL] if not kwargs . get ( key ) : [EOL] raise ValueError ( [string] . format ( key , caller ) ) [EOL] else : [EOL] value = kwargs . pop ( key ) [EOL] return value , kwargs	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] class StepDefinition : [EOL] def __init__ ( self , description , inputs , instruments , outputs , step_fn ) : [EOL] self . description = description [EOL] self . inputs = inputs [EOL] self . instruments = instruments [EOL] self . outputs = outputs [EOL] self . step_fn = step_fn [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class ProtcolExecutionResult : [EOL] def __init__ ( self , results ) : [EOL] self . results = results [EOL] [EOL] @ property def success ( self ) : [EOL] return all ( [ result . success for result in self . results ] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0