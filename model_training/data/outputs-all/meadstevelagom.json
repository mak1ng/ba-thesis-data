from typing import Container [EOL] import scripts [EOL] import lagom [EOL] from lagom import Container , Singleton , magic_bind_to_container , injectable , bind_to_container [EOL] import time [EOL] [EOL] [EOL] class SomeService : [EOL] def do_it ( self ) : [EOL] pass [EOL] [EOL] [EOL] class AThingIMightNeed : [EOL] service = ... [EOL] [EOL] def __init__ ( self , service ) : [EOL] self . service = service [EOL] [EOL] def do_it ( self ) : [EOL] self . service . do_it ( ) [EOL] [EOL] [EOL] container = Container ( ) [EOL] [EOL] [EOL] @ bind_to_container ( container , shared = [ SomeService ] ) def do_work ( thing = injectable ) : [EOL] thing . do_it ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] start = time . perf_counter ( ) [EOL] for i in range ( [number] , [number] ) : [EOL] [comment] [EOL] do_work ( ) [EOL] end = time . perf_counter ( ) [EOL] print ( f" [string] { end - start }" ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SomeService$ 0 0 0 0 0 0 0 0 0 $scripts.simple_timing.SomeService$ 0 0 0 0 0 $scripts.simple_timing.SomeService$ 0 $scripts.simple_timing.SomeService$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0
from typing import Container [EOL] import builtins [EOL] import lagom [EOL] import pytest [EOL] [EOL] from lagom import Container , bind_to_container , injectable [EOL] [EOL] [EOL] class MyDep : [EOL] value = ... [EOL] [EOL] def __init__ ( self , value = [string] ) : [EOL] self . value = value [EOL] [EOL] [EOL] container = Container ( ) [EOL] [EOL] [EOL] @ bind_to_container ( container ) def example_function ( message , resolved = injectable ) : [EOL] return resolved . value + message [EOL] [EOL] [EOL] @ bind_to_container ( container ) async def async_example_function ( message , resolved = injectable ) : [EOL] return resolved . value + message [EOL] [EOL] [EOL] def test_functions_decorated_get_the_correct_argument ( ) : [EOL] assert example_function ( message = [string] ) == [string] [EOL] [EOL] [EOL] def test_injected_arguments_can_over_overridden ( ) : [EOL] assert example_function ( message = [string] , resolved = MyDep ( [string] ) ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_functions_decorated_get_the_correct_argument ( ) : [EOL] assert await async_example_function ( message = [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Container [EOL] import typing [EOL] import tests [EOL] import lagom [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] [EOL] [EOL] class MySimpleDep : [EOL] stuff = ... [EOL] [EOL] def __init__ ( self , stuff ) : [EOL] self . stuff = stuff [EOL] [EOL] [EOL] class MyMoreComplicatedDep : [EOL] complicated_stuff = ... [EOL] [EOL] def __init__ ( self , dep ) : [EOL] self . stuff = [string] + dep . stuff [EOL] [EOL] [EOL] class DepAsAForwardRef : [EOL] def __init__ ( self , dep ) : [EOL] pass [EOL] [EOL] [EOL] class SomethingDefinedLater : [EOL] pass [EOL] [EOL] [EOL] class TypedSelf : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . fixture def container_with_simple_dep ( container ) : [EOL] container . define ( MySimpleDep , lambda : MySimpleDep ( [string] ) ) [EOL] return container [EOL] [EOL] [EOL] def test_works_for_registered_types ( container_with_simple_dep ) : [EOL] resolved = container_with_simple_dep . resolve ( MySimpleDep ) [EOL] assert resolved . stuff == [string] [EOL] [EOL] [EOL] def test_works_if_every_item_in_the_constructor_can_be_figured_out ( container_with_simple_dep , ) : [EOL] resolved = container_with_simple_dep . resolve ( MyMoreComplicatedDep ) [EOL] assert resolved . stuff == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ MySimpleDep , MyMoreComplicatedDep ] ) def test_dependencies_are_built_each_request ( container_with_simple_dep , dep ) : [EOL] first = container_with_simple_dep . resolve ( dep ) [EOL] second = container_with_simple_dep . resolve ( dep ) [EOL] assert first is not second [EOL] [EOL] [EOL] def test_forward_refs_are_fine ( container ) : [EOL] resolved = container . resolve ( DepAsAForwardRef ) [EOL] assert isinstance ( resolved , DepAsAForwardRef ) [EOL] [EOL] [EOL] def test_explicitly_typing_self_doesnt_cause_problems ( container ) : [EOL] resolved = container . resolve ( TypedSelf ) [EOL] assert isinstance ( resolved , TypedSelf ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $MySimpleDep$ 0 0 0 0 0 0 0 0 0 $MySimpleDep$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $"SomethingDefinedLater"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TypedSelf"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Container , Generator [EOL] import typing [EOL] import tests [EOL] import lagom [EOL] from dataclasses import dataclass [EOL] from typing import Generator , Any [EOL] [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] from lagom . decorators import dependency_definition [EOL] from lagom . exceptions import MissingReturnType [EOL] [EOL] global finally_was_executed [EOL] finally_was_executed = False [EOL] [EOL] [EOL] @ dataclass class MyComplexDep : [EOL] some_number = ... [EOL] [EOL] [EOL] @ dataclass class WrapperOfSomeKind : [EOL] inner = ... [EOL] [EOL] [EOL] def test_functions_that_are_typed_can_be_used_by_a_container ( container ) : [EOL] @ dependency_definition ( container ) def my_constructor ( ) : [EOL] return MyComplexDep ( some_number = [number] ) [EOL] [EOL] assert container [ MyComplexDep ] == MyComplexDep ( some_number = [number] ) [EOL] [EOL] [EOL] def test_the_functions_return_new_instances_each_time ( container ) : [EOL] @ dependency_definition ( container ) def my_constructor ( ) : [EOL] return MyComplexDep ( some_number = [number] ) [EOL] [EOL] first = container [ MyComplexDep ] [EOL] second = container [ MyComplexDep ] [EOL] assert first is not second [EOL] [EOL] [EOL] def test_definition_functions_can_yield_instead_of_returning ( container ) : [EOL] @ dependency_definition ( container ) def my_constructor ( ) : [EOL] yield MyComplexDep ( some_number = [number] ) [EOL] [EOL] first = container [ MyComplexDep ] [EOL] assert first . some_number == [number] [EOL] [EOL] [EOL] def test_when_yielding_finally_can_be_used ( container ) : [EOL] global finally_was_executed [EOL] finally_was_executed = False [EOL] [EOL] @ dependency_definition ( container ) def my_constructor ( ) : [EOL] global finally_was_executed [EOL] try : [EOL] yield MyComplexDep ( some_number = [number] ) [EOL] finally : [EOL] finally_was_executed = True [EOL] [EOL] container . resolve ( MyComplexDep ) [EOL] assert finally_was_executed is True [EOL] [EOL] [EOL] def test_functions_can_be_made_into_singletons ( container ) : [EOL] @ dependency_definition ( container , singleton = True ) def my_constructor ( ) : [EOL] return MyComplexDep ( some_number = [number] ) [EOL] [EOL] first = container [ MyComplexDep ] [EOL] second = container [ MyComplexDep ] [EOL] assert first is second [EOL] [EOL] [EOL] def test_definition_functions_get_an_instance_of_the_container ( container ) : [EOL] container [ MyComplexDep ] = MyComplexDep ( some_number = [number] ) [EOL] [EOL] @ dependency_definition ( container ) def my_constructor ( c ) : [EOL] return WrapperOfSomeKind ( c [ MyComplexDep ] ) [EOL] [EOL] assert container [ WrapperOfSomeKind ] . inner == container [ MyComplexDep ] [EOL] [EOL] [EOL] def test_singleton_definition_functions_get_an_instance_of_the_container ( container , ) : [EOL] container [ MyComplexDep ] = MyComplexDep ( some_number = [number] ) [EOL] [EOL] @ dependency_definition ( container , singleton = True ) def my_constructor ( c ) : [EOL] return WrapperOfSomeKind ( c [ MyComplexDep ] ) [EOL] [EOL] assert container [ WrapperOfSomeKind ] . inner == container [ MyComplexDep ] [EOL] [EOL] [EOL] def test_functions_that_are_not_typed_raise_an_error ( container ) : [EOL] with pytest . raises ( MissingReturnType ) : [EOL] [EOL] @ dependency_definition ( container ) def my_constructor ( ) : [EOL] return MyComplexDep ( some_number = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $MyComplexDep$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Optional , Container [EOL] import typing [EOL] import tests [EOL] import lagom [EOL] from typing import Optional [EOL] [EOL] from lagom import Container [EOL] [EOL] [EOL] class MySimpleDep : [EOL] extra_stuff = [string] [EOL] [EOL] [EOL] class MyComplexDep : [EOL] extra_stuff = [string] [EOL] [EOL] def __init__ ( self , something ) : [EOL] pass [EOL] [EOL] [EOL] class MyDepWithAnOptional : [EOL] success = [string] [EOL] [EOL] def __init__ ( self , dep = None ) : [EOL] self . dep = dep [EOL] [EOL] [EOL] class MyDepWithAnOptionalThatCantBeBuilt : [EOL] success = [string] [EOL] [EOL] def __init__ ( self , dep = [string] ) : [comment] [EOL] self . dep = dep [EOL] [EOL] [EOL] def test_missing_optional_dependencies_cause_no_errors ( container ) : [EOL] resolved = container . resolve ( MyDepWithAnOptionalThatCantBeBuilt ) [EOL] assert resolved . success == [string] [comment] [EOL] [EOL] [EOL] def test_defaults_for_optional_types_are_honoured ( container ) : [EOL] resolved = container . resolve ( MyDepWithAnOptionalThatCantBeBuilt ) [EOL] assert resolved . dep == [string] [comment] [EOL] [EOL] [EOL] def test_optional_dependencies_are_understood_and_injected ( container ) : [EOL] resolved = container . resolve ( MyDepWithAnOptional ) [EOL] assert resolved . dep . extra_stuff == [string] [comment] [EOL] [EOL] [EOL] def test_we_can_ask_for_optional_things_that_cant_be_constructed ( container ) : [EOL] assert container . resolve ( Optional [ MyComplexDep ] ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[tests.test_optionals_are_well_handled.MySimpleDep]$ 0 0 0 0 0 0 0 $typing.Optional[tests.test_optionals_are_well_handled.MySimpleDep]$ 0 $typing.Optional[tests.test_optionals_are_well_handled.MySimpleDep]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[tests.test_optionals_are_well_handled.MyComplexDep]$ 0 0 0 0 0 0 0 0 $typing.Optional[tests.test_optionals_are_well_handled.MyComplexDep]$ 0 $typing.Optional[tests.test_optionals_are_well_handled.MyComplexDep]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import lagom [EOL] from lagom import Container , Singleton [EOL] [EOL] [EOL] class InitialDep : [EOL] pass [EOL] [EOL] [EOL] class SomeOtherThing ( InitialDep ) : [EOL] pass [EOL] [EOL] [EOL] def test_container_can_list_the_types_explicitly_defined ( container ) : [EOL] container [ InitialDep ] = InitialDep [EOL] container [ SomeOtherThing ] = Singleton ( SomeOtherThing ) [EOL] [EOL] assert container . defined_types == { InitialDep , SomeOtherThing } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Container [EOL] import lagom [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def container ( ) : [EOL] c = Container ( ) [EOL] return c [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import lagom [EOL] from dataclasses import dataclass [EOL] from typing import Awaitable [EOL] [EOL] import pytest [EOL] [EOL] from lagom import Container , dependency_definition [EOL] [EOL] [EOL] @ dataclass class MyComplexDep : [EOL] some_number = ... [EOL] [EOL] @ classmethod async def asyc_loader ( cls ) : [EOL] return cls ( [number] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_simple_async_component_def ( container ) : [EOL] @ dependency_definition ( container ) async def my_constructor ( ) : [EOL] return MyComplexDep ( some_number = [number] ) [EOL] [EOL] assert ( await container [ Awaitable [ MyComplexDep ] ] ) == MyComplexDep ( some_number = [number] ) [comment] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_alternative_way_of_defining_an_async_dep ( container ) : [EOL] container [ Awaitable [ MyComplexDep ] ] = MyComplexDep . asyc_loader [comment] [EOL] [EOL] assert ( await container [ Awaitable [ MyComplexDep ] ] ) == MyComplexDep ( some_number = [number] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MyComplexDep$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import tests [EOL] import lagom [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] [EOL] [EOL] class A : [EOL] def __init__ ( self , b ) : [EOL] pass [EOL] [EOL] [EOL] class B : [EOL] def __init__ ( self , a ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_definition_loops_return_a_sensible_error ( container ) : [EOL] resolved = container . resolve ( B ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"B"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"A"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import tests [EOL] import builtins [EOL] import lagom [EOL] from abc import ABC [EOL] import pytest [EOL] [EOL] from lagom import Container , Alias [EOL] [EOL] [EOL] class MySimpleAbc ( ABC ) : [EOL] stuff = [string] [EOL] [EOL] def bloop ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class MySimpleDep ( MySimpleAbc ) : [EOL] stuff = ... [EOL] [EOL] def __init__ ( self , stuff ) : [EOL] self . stuff = stuff [EOL] [EOL] [EOL] class MyMoreComplicatedDep : [EOL] complicated_stuff = ... [EOL] [EOL] def __init__ ( self , dep ) : [EOL] self . stuff = dep . stuff [EOL] [EOL] [EOL] class AnotherAbc ( ABC ) : [EOL] stuff = [string] [EOL] [EOL] [EOL] class AnotherConcrete ( AnotherAbc ) : [EOL] stuff = [string] [EOL] [EOL] [EOL] @ pytest . fixture def container_with_abc ( container ) : [EOL] container . define ( MySimpleAbc , lambda : MySimpleDep ( [string] ) ) [EOL] return container [EOL] [EOL] [EOL] def test_registered_concrete_class_is_loaded ( container_with_abc ) : [EOL] resolved = container_with_abc . resolve ( MySimpleAbc ) [EOL] assert resolved . stuff == [string] [EOL] [EOL] [EOL] def test_registered_concrete_class_is_used_for_other_objects ( container_with_abc , ) : [EOL] resolved = container_with_abc . resolve ( MyMoreComplicatedDep ) [EOL] assert resolved . stuff == [string] [EOL] [EOL] [EOL] def test_alias_can_be_defined ( container_with_abc ) : [EOL] container_with_abc . define ( AnotherAbc , Alias ( AnotherConcrete ) ) [EOL] resolved = container_with_abc . resolve ( AnotherAbc ) [EOL] assert resolved . stuff == [string] [EOL] [EOL] [EOL] def test_aliases_can_be_pointless_and_self_referential ( container ) : [EOL] container . define ( AnotherConcrete , Alias ( AnotherConcrete ) ) [EOL] resolved = container . resolve ( AnotherConcrete ) [EOL] assert resolved . stuff == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $MySimpleAbc$ 0 0 0 0 0 0 0 $MySimpleAbc$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import lagom [EOL] from lagom import Container [EOL] [EOL] [EOL] class AThing : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] [EOL] class AnotherThing : [EOL] def __init__ ( self , thing ) : [EOL] pass [EOL] [EOL] [EOL] def test_initially_nothing_has_been_reflected ( container ) : [EOL] assert container . reflection_cache_overview == { } [EOL] [EOL] [EOL] def test_all_reflection_used_is_described ( container ) : [EOL] container . resolve ( AnotherThing ) [EOL] assert container . reflection_cache_overview == { [string] : [string] , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AThing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container , List [EOL] import typing [EOL] import tests [EOL] import builtins [EOL] import lagom [EOL] from typing import NewType , List [EOL] [EOL] try : [EOL] from typing import Protocol [EOL] except ImportError : [EOL] from typing_extensions import Protocol [comment] [EOL] [EOL] from lagom import Container [EOL] [EOL] MyServiceUrl = NewType ( [string] , str ) [EOL] [EOL] [EOL] class ApiClientOfSomeKind : [EOL] def __init__ ( self , url ) : [EOL] pass [EOL] [EOL] [EOL] class LoadBalancePerhaps : [EOL] def __init__ ( self , urls ) : [EOL] pass [EOL] [EOL] [EOL] class BakerProtocol ( Protocol ) : [EOL] def bake ( self ) : [EOL] pass [EOL] [EOL] [EOL] class Bakery : [EOL] def __init__ ( self , baker ) : [EOL] pass [EOL] [EOL] [EOL] class CrumpetBaker : [EOL] def bake ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] def test_newtype_works_well_with_the_container ( container ) : [EOL] container [ MyServiceUrl ] = MyServiceUrl ( [string] ) [EOL] api_client = container [ ApiClientOfSomeKind ] [EOL] assert isinstance ( api_client , ApiClientOfSomeKind ) [EOL] [EOL] [EOL] def test_lists_of_newtype_work_well_with_the_container ( container ) : [EOL] container [ List [ MyServiceUrl ] ] = [ MyServiceUrl ( [string] ) , MyServiceUrl ( [string] ) , ] [EOL] load_balancer = container [ LoadBalancePerhaps ] [EOL] assert isinstance ( load_balancer , LoadBalancePerhaps ) [EOL] [EOL] [EOL] def test_protocols_work_well_with_the_container ( container ) : [EOL] [comment] [EOL] container [ BakerProtocol ] = CrumpetBaker [comment] [EOL] bakery = container [ Bakery ] [EOL] assert isinstance ( bakery , Bakery ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MyServiceUrl$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[MyServiceUrl]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BakerProtocol$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import ClassVar , Container [EOL] import typing [EOL] import tests [EOL] import lagom [EOL] from typing import Optional , ClassVar [EOL] [EOL] from lagom import Container [EOL] from lagom . environment import Env [EOL] [EOL] [EOL] class MyEnv ( Env ) : [EOL] example_value = ... [EOL] [EOL] [EOL] class MyEnvWithPrefix ( Env ) : [EOL] PREFIX = [string] [EOL] example_value = ... [EOL] [EOL] [EOL] def test_env_can_be_loaded ( container ) : [EOL] assert isinstance ( container . resolve ( MyEnv ) , MyEnv ) [EOL] [EOL] [EOL] def test_defined_env_variables_are_loaded_automatically ( monkeypatch , container ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] env = container . resolve ( MyEnv ) [EOL] assert env . example_value == [string] [EOL] [EOL] [EOL] def test_envs_can_have_a_prefix ( monkeypatch , container ) : [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] env = container . resolve ( MyEnvWithPrefix ) [EOL] assert env . example_value == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import builtins [EOL] import lagom [EOL] import inspect [EOL] [EOL] import pytest [EOL] [EOL] from lagom import Container , magic_bind_to_container [EOL] [EOL] [EOL] class Something : [EOL] pass [EOL] [EOL] [EOL] def test_partial_application_async_functions_pass_iscoroutinefunction ( container , ) : [EOL] @ magic_bind_to_container ( container ) async def example_async_function ( message ) : [EOL] return message [EOL] [EOL] assert inspect . iscoroutinefunction ( example_async_function ) [EOL] [EOL] [EOL] def test_partial_application_async_functions_with_shared_pass_iscoroutinefunction ( container , ) : [EOL] @ magic_bind_to_container ( container , shared = [ Something ] ) async def example_async_function ( message ) : [EOL] return message [EOL] [EOL] assert inspect . iscoroutinefunction ( example_async_function ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_calling_async_partials_works_as_expected ( container ) : [EOL] @ magic_bind_to_container ( container ) async def example_async_function ( message ) : [EOL] return message [EOL] [EOL] assert await example_async_function ( [string] ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_calling_async_partials_works_as_expected_with_shared_too ( container , ) : [EOL] @ magic_bind_to_container ( container , shared = [ Something ] ) async def example_async_function ( message ) : [EOL] return message [EOL] [EOL] assert await example_async_function ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import tests [EOL] import lagom [EOL] import pytest [EOL] [EOL] from lagom import Singleton , Container [EOL] [EOL] [EOL] class MyBasicDep : [EOL] pass [EOL] [EOL] [EOL] class MyMoreComplicatedDep : [EOL] def __init__ ( self , some_number ) : [EOL] self . sum_number = some_number [EOL] [EOL] [EOL] class MyCompositeDep : [EOL] def __init__ ( self , a , b ) : [EOL] self . a = a [EOL] self . b = b [EOL] [EOL] [EOL] @ pytest . fixture def container_with_deps ( container ) : [EOL] container . define ( MyBasicDep , Singleton ( MyBasicDep ) ) [EOL] container . define ( MyMoreComplicatedDep , Singleton ( lambda : MyMoreComplicatedDep ( [number] ) ) ) [EOL] container . define ( MyCompositeDep , Singleton ( MyCompositeDep ) ) [EOL] return container [EOL] [EOL] [EOL] def test_singleton_is_only_resolved_once ( container_with_deps ) : [EOL] first = container_with_deps . resolve ( MyBasicDep ) [EOL] second = container_with_deps . resolve ( MyBasicDep ) [EOL] assert first is not None [EOL] assert first is second [EOL] [EOL] [EOL] def test_singleton_can_have_construction_logic ( container_with_deps ) : [EOL] first = container_with_deps . resolve ( MyMoreComplicatedDep ) [EOL] second = container_with_deps . resolve ( MyMoreComplicatedDep ) [EOL] assert first . sum_number == [number] [EOL] assert first is second [EOL] [EOL] [EOL] def test_singleton_can_compose_other_dependencies ( container_with_deps ) : [EOL] first = container_with_deps . resolve ( MyCompositeDep ) [EOL] second = container_with_deps . resolve ( MyCompositeDep ) [EOL] assert type ( first . a ) == MyBasicDep [EOL] assert type ( first . b ) == MyMoreComplicatedDep [EOL] assert first is second [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_singleton.MyBasicDep$ 0 $tests.test_singleton.MyMoreComplicatedDep$ 0 0 0 0 0 $tests.test_singleton.MyBasicDep$ 0 $tests.test_singleton.MyBasicDep$ 0 0 0 $tests.test_singleton.MyMoreComplicatedDep$ 0 $tests.test_singleton.MyMoreComplicatedDep$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import builtins [EOL] import lagom [EOL] from typing import List [EOL] [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] from lagom . exceptions import UnresolvableType , RecursiveDefinitionError [EOL] [EOL] [EOL] class MyMissingDep : [EOL] def __init__ ( self , _stuff ) : [EOL] pass [EOL] [EOL] [EOL] class UnfulfilledDeps : [EOL] def __init__ ( self , _stuff ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ str , int , float , bool ] ) def test_simple_objects_cannot_be_resolved ( container , dep ) : [EOL] with pytest . raises ( UnresolvableType ) : [EOL] container . resolve ( dep ) [EOL] [EOL] [EOL] def test_raises_error_with_the_dep_that_couldnt_be_built ( container ) : [EOL] with pytest . raises ( UnresolvableType ) : [EOL] container . resolve ( MyMissingDep ) [EOL] [EOL] [EOL] def test_raises_error_with_the_dep_that_couldnt_be_built_at_the_top_level ( container ) : [EOL] with pytest . raises ( UnresolvableType ) as e_info : [EOL] container . resolve ( UnfulfilledDeps ) [EOL] assert ( str ( e_info . value ) == [string] [string] ) [EOL] [EOL] [EOL] def test_composite_type_failures_still_throw_sensible_errors ( container ) : [EOL] with pytest . raises ( UnresolvableType ) as e_info : [EOL] container . resolve ( List [ UnfulfilledDeps ] ) [EOL] assert ( str ( e_info . value ) == [string] [string] [string] ) [EOL] [EOL] [EOL] class A : [EOL] def __init__ ( self , b ) : [EOL] pass [EOL] [EOL] [EOL] class B : [EOL] def __init__ ( self , a ) : [EOL] pass [EOL] [EOL] [EOL] def test_circular_imports_raise_a_clear_error ( container ) : [EOL] with pytest . raises ( RecursiveDefinitionError ) as e_info : [EOL] container . resolve ( A ) [EOL] assert ( str ( e_info . value ) == f" [string] " [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MyMissingDep$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"B"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"A"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container , ClassVar , Callable , List , Any , Generator [EOL] import typing [EOL] import builtins [EOL] import lagom [EOL] import inspect [EOL] from typing import Generator , Any , ClassVar [EOL] [EOL] import pytest [EOL] [EOL] from lagom import Container , magic_bind_to_container [EOL] from lagom . exceptions import UnableToInvokeBoundFunction [EOL] [EOL] [EOL] class MyDep : [EOL] loaded = False [EOL] value = ... [EOL] [EOL] def __init__ ( self , value = [string] ) : [EOL] MyDep . loaded = True [EOL] self . value = value [EOL] [EOL] [EOL] class CantBeAutoConstructed : [EOL] def __init__ ( self , something ) : [EOL] pass [EOL] [EOL] [EOL] container = Container ( ) [EOL] [EOL] [EOL] def example_function ( message , resolved ) : [EOL] return resolved . value + message [EOL] [EOL] [EOL] def example_function_with_to_injectables ( one , two ) : [EOL] return one . value + two . value [EOL] [EOL] [EOL] def example_generator ( message , resolved ) : [EOL] yield resolved . value + message [EOL] yield resolved . value + [string] [EOL] [EOL] [EOL] @ magic_bind_to_container ( container ) def another_example_function ( message , resolved ) : [EOL] [docstring] [EOL] return resolved . value + message [EOL] [EOL] [EOL] @ magic_bind_to_container ( container ) def failing_to_construct_function ( try_to_resolve ) : [EOL] return [string] [EOL] [EOL] [EOL] def test_partial_application_can_be_applied_to_functions_with_named_args ( ) : [EOL] partial = container . magic_partial ( example_function ) [EOL] assert partial ( message = [string] ) == [string] [EOL] [EOL] [EOL] def test_partial_application_returns_something_that_is_considered_a_function ( ) : [EOL] partial = container . magic_partial ( example_function ) [EOL] inspect . isfunction ( partial ) [EOL] [EOL] [EOL] def test_partial_application_can_be_applied_to_functions_with_positional_args_first ( ) : [EOL] partial = container . magic_partial ( example_function ) [EOL] assert partial ( [string] ) == [string] [EOL] [EOL] [EOL] def test_passed_in_arguments_are_used_over_container_generated_ones_when_positional ( ) : [EOL] partial = container . magic_partial ( example_function ) [EOL] assert partial ( [string] , MyDep ( [string] ) ) == [string] [EOL] [EOL] [EOL] def test_passed_in_arguments_are_used_over_container_generated_ones_when_named ( ) : [EOL] partial = container . magic_partial ( example_function ) [EOL] assert partial ( message = [string] , resolved = MyDep ( [string] ) ) == [string] [EOL] [EOL] [EOL] def test_injected_arguments_can_be_skipped ( ) : [EOL] partial = container . magic_partial ( example_function_with_to_injectables ) [EOL] assert partial ( two = MyDep ( [string] ) ) == [string] [EOL] [EOL] [EOL] def test_a_decorator_can_be_used_to_bind_as_well ( ) : [EOL] assert another_example_function ( message = [string] ) == [string] [EOL] [EOL] [EOL] def test_a_decorator_can_be_used_to_bind_and_with_positional_arguments ( ) : [EOL] assert another_example_function ( [string] ) == [string] [EOL] [EOL] [EOL] def test_container_values_can_be_overridden ( ) : [EOL] assert ( another_example_function ( resolved = MyDep ( [string] ) , message = [string] ) == [string] ) [EOL] [EOL] [EOL] def test_missing_call_arguments_results_in_sensible_error_messages ( ) : [EOL] with pytest . raises ( TypeError ) as err : [EOL] another_example_function ( ) [EOL] assert [string] in str ( err . value ) [EOL] [EOL] [EOL] def test_incorrect_arguments_are_handled_well ( ) : [EOL] with pytest . raises ( TypeError ) as err : [EOL] another_example_function ( not_the_message = [string] ) [EOL] assert [string] in str ( err . value ) [EOL] [EOL] [EOL] def test_if_a_typed_argument_cant_be_constructed_a_helpful_exception_is_returned ( ) : [EOL] with pytest . raises ( UnableToInvokeBoundFunction ) as err : [EOL] failing_to_construct_function ( ) [EOL] assert ( [string] in str ( err . value ) ) [EOL] [EOL] [EOL] def test_partial_application_can_be_applied_to_generators ( ) : [EOL] partial = container . magic_partial ( example_generator ) [EOL] results = [ ] [EOL] for result in partial ( message = [string] ) : [EOL] results . append ( result ) [EOL] assert results == [ [string] , [string] ] [EOL] [EOL] [EOL] def test_deps_are_loaded_at_call_time_not_definition_time ( ) : [EOL] MyDep . loaded = False [EOL] [EOL] @ magic_bind_to_container ( container ) def some_random_unused_function ( message , resolved ) : [EOL] return resolved . value + message [EOL] [EOL] assert not MyDep . loaded [EOL] [EOL] [EOL] def test_name_and_docs_are_kept ( ) : [EOL] assert another_example_function . __name__ == [string] [EOL] assert another_example_function . __doc__ == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.bool]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.str,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lagom.container.Container$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import tests [EOL] import builtins [EOL] import lagom [EOL] from abc import ABC [EOL] [EOL] from lagom import Container [EOL] [EOL] [EOL] class MySimpleDep : [EOL] stuff = ... [EOL] [EOL] def __init__ ( self , stuff ) : [EOL] self . stuff = stuff [EOL] [EOL] [EOL] class MyMoreComplicatedDep : [EOL] stuff = ... [EOL] [EOL] def __init__ ( self , dep ) : [EOL] self . stuff = dep . stuff [EOL] [EOL] [EOL] class AnotherAbc ( ABC ) : [EOL] stuff = [string] [EOL] [EOL] [EOL] class AnotherConcrete ( AnotherAbc ) : [EOL] stuff = [string] [EOL] [EOL] [EOL] def test_deps_can_be_referenced_by_square_brackets ( container ) : [EOL] container [ MySimpleDep ] = lambda : MySimpleDep ( [string] ) [EOL] resolved = container [ MySimpleDep ] [EOL] assert resolved . stuff == [string] [EOL] [EOL] [EOL] def test_construction_type_can_be_omitted ( container ) : [EOL] container [ MySimpleDep ] = lambda : MySimpleDep ( [string] ) [EOL] resolved = container [ MySimpleDep ] [EOL] assert resolved . stuff == [string] [EOL] [EOL] [EOL] def test_singleton_type_can_be_omitted ( container ) : [EOL] container [ MySimpleDep ] = MySimpleDep ( [string] ) [EOL] one = container [ MySimpleDep ] [EOL] two = container [ MySimpleDep ] [EOL] assert one is not None [EOL] assert one is two [EOL] [EOL] [EOL] def test_alias_can_be_omitted ( container ) : [EOL] container [ AnotherAbc ] = AnotherConcrete [EOL] resolved = container [ AnotherAbc ] [EOL] assert type ( resolved ) == AnotherConcrete [EOL] assert resolved . stuff == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $MySimpleDep$ 0 0 0 0 0 $builtins.str$ 0 $MySimpleDep$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Container [EOL] import lagom [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] from lagom . exceptions import InvalidDependencyDefinition [EOL] [EOL] [EOL] class MyBasicDep : [EOL] basic_value = [number] [EOL] pass [EOL] [EOL] [EOL] class ComplexDep : [EOL] def __init__ ( self , some_dep ) : [EOL] self . value = some_dep . basic_value [EOL] [EOL] [EOL] def test_lambda_arity_zero_works ( container ) : [EOL] container . define ( MyBasicDep , lambda : MyBasicDep ( ) ) [EOL] assert type ( container [ MyBasicDep ] ) == MyBasicDep [EOL] [EOL] [EOL] def test_lambda_arity_one_is_passed_the_container ( container ) : [EOL] container . define ( MyBasicDep , lambda : MyBasicDep ( ) ) [EOL] container . define ( ComplexDep , lambda c : ComplexDep ( c [ MyBasicDep ] ) ) [EOL] assert container [ ComplexDep ] . value == [number] [EOL] [EOL] [EOL] def test_lambda_arity_two_results_in_an_error ( container ) : [EOL] with pytest . raises ( InvalidDependencyDefinition ) : [EOL] container . define ( MyBasicDep , lambda _x , _y : MyBasicDep ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import tests [EOL] import lagom [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] from lagom . exceptions import DuplicateDefinition [EOL] [EOL] [EOL] class InitialDep : [EOL] pass [EOL] [EOL] [EOL] class SomeMockForTesting ( InitialDep ) : [EOL] pass [EOL] [EOL] [EOL] class SomeMockThatDoesntEventExtend : [EOL] pass [EOL] [EOL] [EOL] def test_deps_can_be_overridden_by_a_child_class ( container ) : [EOL] container . define ( InitialDep , lambda : SomeMockForTesting ( ) ) [EOL] resolved = container . resolve ( InitialDep ) [EOL] assert type ( resolved ) == SomeMockForTesting [EOL] [EOL] [EOL] def test_deps_can_be_overridden_by_anything ( container ) : [EOL] container . define ( InitialDep , lambda : SomeMockThatDoesntEventExtend ( ) ) [comment] [EOL] resolved = container . resolve ( InitialDep ) [EOL] assert type ( resolved ) == SomeMockThatDoesntEventExtend [EOL] [EOL] [EOL] def test_explicit_definitions_can_only_be_made_once ( container ) : [EOL] container . define ( InitialDep , lambda : SomeMockForTesting ( ) ) [EOL] [EOL] with pytest . raises ( DuplicateDefinition ) : [EOL] container . define ( InitialDep , lambda : SomeMockThatDoesntEventExtend ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class SomeClass : [EOL] pass [EOL] [EOL] [EOL] class SomeExtendedClass ( SomeClass ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Container [EOL] import typing [EOL] import lagom [EOL] from lagom import Container , Singleton [EOL] [EOL] [EOL] class InitialDep : [EOL] pass [EOL] [EOL] [EOL] class SomeMockForTesting ( InitialDep ) : [EOL] pass [EOL] [EOL] [EOL] class SomeOtherMockForTesting ( InitialDep ) : [EOL] pass [EOL] [EOL] [EOL] def test_container_can_be_cloned_and_maintains_separate_deps ( container ) : [EOL] new_container = container . clone ( ) [EOL] new_container . define ( InitialDep , lambda : SomeMockForTesting ( ) ) [EOL] [EOL] assert isinstance ( new_container [ InitialDep ] , SomeMockForTesting ) [EOL] assert isinstance ( container [ InitialDep ] , InitialDep ) [EOL] [EOL] [EOL] def test_a_cloned_container_can_have_deps_overwritten ( container ) : [EOL] container . define ( InitialDep , lambda : SomeMockForTesting ( ) ) [EOL] new_container = container . clone ( ) [EOL] new_container . define ( InitialDep , lambda : SomeOtherMockForTesting ( ) ) [EOL] [EOL] assert isinstance ( new_container [ InitialDep ] , SomeOtherMockForTesting ) [EOL] [EOL] [EOL] def test_a_clone_shares_the_parents_singleton_instances ( container ) : [EOL] container . define ( InitialDep , Singleton ( InitialDep ) ) [EOL] new_container = container . clone ( ) [EOL] [EOL] assert id ( container [ InitialDep ] ) == id ( new_container [ InitialDep ] ) [EOL] [EOL] [EOL] def test_overwriting_a_singleton_creates_a_new_one ( container ) : [EOL] container . define ( InitialDep , Singleton ( InitialDep ) ) [EOL] new_container = container . clone ( ) [EOL] new_container . define ( InitialDep , Singleton ( InitialDep ) ) [EOL] [EOL] assert id ( container [ InitialDep ] ) != id ( new_container [ InitialDep ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Container , List [EOL] import typing [EOL] import tests [EOL] import lagom [EOL] from typing import List [EOL] [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] [EOL] [EOL] class MySimpleDep : [EOL] stuff = ... [EOL] [EOL] def __init__ ( self , stuff ) : [EOL] self . stuff = stuff [EOL] [EOL] [EOL] class MyMoreComplicatedDep : [EOL] complicated_stuff = ... [EOL] [EOL] def __init__ ( self , dep ) : [EOL] self . stuff = [string] . join ( [ d . stuff for d in dep ] ) [EOL] [EOL] [EOL] @ pytest . fixture def container_with_list ( container ) : [EOL] container . define ( List [ MySimpleDep ] , lambda : [ MySimpleDep ( [string] ) , MySimpleDep ( [string] ) ] , ) [EOL] return container [EOL] [EOL] [EOL] def test_works_for_list_types ( container_with_list ) : [EOL] resolved = container_with_list . resolve ( List [ MySimpleDep ] ) [EOL] assert [ x . stuff for x in resolved ] == [ [string] , [string] ] [EOL] [EOL] [EOL] def test_works_for_inferred_list_types ( container_with_list ) : [EOL] resolved = container_with_list . resolve ( MyMoreComplicatedDep ) [EOL] assert resolved . stuff == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[MySimpleDep]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[MySimpleDep]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import pytest [EOL] [EOL] from lagom . util . functional import arity [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( lambda : [number] , [number] ) , ( lambda x : x , [number] ) , ( lambda x , y : x + y , [number] ) ] , ) def test_we_can_get_arity_from_functions ( test_func , expected_arity ) : [EOL] assert arity ( test_func ) == expected_arity [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Container [EOL] import lagom [EOL] from starlette . routing import Route [EOL] [EOL] from lagom import Container , injectable [EOL] from lagom . integrations . starlette import StarletteContainer [EOL] [EOL] [EOL] class MyDep : [EOL] pass [EOL] [EOL] [EOL] class ComplexDep : [EOL] def __init__ ( self , something ) : [EOL] pass [EOL] [EOL] [EOL] def some_handler ( request , dep = injectable ) : [EOL] return [string] [EOL] [EOL] [EOL] def two_dep_handler ( request , dep_one = injectable , dep_two = injectable ) : [EOL] return [string] if dep_one is dep_two else [string] [EOL] [EOL] [EOL] def test_a_special_starlette_container_can_be_used_and_provides_routes ( ) : [EOL] sc = StarletteContainer ( ) [EOL] route = sc . route ( [string] , some_handler ) [EOL] assert isinstance ( route , Route ) [EOL] assert route . endpoint ( { } ) == [string] [EOL] [EOL] [EOL] def test_the_starlette_container_can_define_request_level_singletons ( ) : [EOL] sc = StarletteContainer ( request_singletons = [ MyDep ] ) [EOL] route = sc . route ( [string] , two_dep_handler ) [EOL] assert route . endpoint ( { } ) == [string] [EOL] [EOL] [EOL] def test_the_starlette_container_can_wrap_an_existing_container ( container ) : [EOL] container [ ComplexDep ] = ComplexDep ( [string] ) [EOL] sc = StarletteContainer ( container = container ) [EOL] assert isinstance ( sc [ ComplexDep ] , ComplexDep ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tests [EOL] import lagom [EOL] from dataclasses import dataclass [EOL] [EOL] from fastapi . params import Depends [EOL] [EOL] from lagom . integrations . fast_api import FastApiContainer [EOL] [EOL] [EOL] @ dataclass class ComplexDep : [EOL] something = ... [EOL] [EOL] [EOL] def test_the_fast_api_container_can_return_a_fastapi_dependency ( ) : [EOL] fac = FastApiContainer ( ) [EOL] fac [ ComplexDep ] = ComplexDep ( [string] ) [EOL] dependency_injection = fac . depends ( ComplexDep ) [EOL] assert isinstance ( dependency_injection , Depends ) [EOL] assert dependency_injection . dependency ( ) == ComplexDep ( [string] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import flask [EOL] import lagom [EOL] from flask import Flask , Response [EOL] [EOL] from lagom import injectable [EOL] from lagom . integrations . flask import FlaskContainer [EOL] [EOL] [EOL] class ComplexDep : [EOL] def __init__ ( self , message ) : [EOL] self . message = message [EOL] [EOL] [EOL] def test_flask_container_provides_a_route_decorator ( ) : [EOL] app = Flask ( __name__ ) [EOL] container = FlaskContainer ( app ) [EOL] container [ ComplexDep ] = ComplexDep ( [string] ) [EOL] [EOL] @ container . route ( [string] ) def _some_handler ( dep = injectable ) : [EOL] return dep . message [EOL] [EOL] with app . test_client ( ) as client : [EOL] resp = client . get ( [string] ) [EOL] assert resp . get_data ( as_text = True ) == [string] [EOL] [EOL] [EOL] def test_the_route_decorator_can_have_request_level_singletons ( ) : [EOL] app = Flask ( __name__ ) [EOL] container = FlaskContainer ( app , request_singletons = [ ComplexDep ] ) [EOL] container [ ComplexDep ] = lambda : ComplexDep ( [string] ) [EOL] [EOL] @ container . route ( [string] ) def _some_handler ( dep_one = injectable , dep_two = injectable ) : [EOL] return [string] if dep_one is dep_two else [string] [EOL] [EOL] with app . test_client ( ) as client : [EOL] resp = client . get ( [string] ) [EOL] assert resp . get_data ( as_text = True ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from lagom . experimental . container import ExplicitContainer [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def explicit_container ( ) : [EOL] return ExplicitContainer ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container [EOL] import tests [EOL] import lagom [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] from lagom . experimental . exceptions import DependencyNotDefined [EOL] [EOL] [EOL] class SomethingToBuild : [EOL] pass [EOL] [EOL] [EOL] class SomethingBiggerToBuild : [EOL] def __init__ ( self , inner ) : [EOL] pass [EOL] [EOL] [EOL] def test_dependencies_must_be_explicitly_defined ( explicit_container ) : [EOL] with pytest . raises ( DependencyNotDefined ) as e_info : [EOL] explicit_container . resolve ( SomethingToBuild ) [EOL] [EOL] assert ( str ( e_info . value ) == [string] ) [EOL] [EOL] [EOL] def test_the_error_suppression_flag_is_honoured ( explicit_container ) : [EOL] assert explicit_container . resolve ( SomethingToBuild , suppress_error = True ) is None [EOL] [EOL] [EOL] def test_an_alias_counts_as_definition ( explicit_container ) : [EOL] explicit_container [ SomethingToBuild ] = SomethingToBuild [EOL] [EOL] built_object = explicit_container . resolve ( SomethingToBuild ) [EOL] assert isinstance ( built_object , SomethingToBuild ) [EOL] [EOL] [EOL] def test_the_explicit_rule_applies_to_inner_objects_too ( explicit_container ) : [EOL] explicit_container [ SomethingBiggerToBuild ] = SomethingBiggerToBuild [EOL] [EOL] with pytest . raises ( DependencyNotDefined ) as e_info : [EOL] explicit_container . resolve ( SomethingBiggerToBuild ) [EOL] [EOL] assert ( str ( e_info . value ) == [string] ) [EOL] [EOL] [EOL] def test_the_inner_dependencies_dont_have_to_be_defined_in_the_container ( explicit_container , ) : [EOL] explicit_container [ SomethingBiggerToBuild ] = lambda : SomethingBiggerToBuild ( SomethingToBuild ( ) ) [EOL] [EOL] built_object = explicit_container . resolve ( SomethingBiggerToBuild ) [EOL] assert isinstance ( built_object , SomethingBiggerToBuild ) [EOL] [EOL] [comment] [EOL] assert explicit_container . resolve ( SomethingToBuild , suppress_error = True ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SomethingToBuild$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Callable , Container [EOL] import typing [EOL] import tests [EOL] import builtins [EOL] import lagom [EOL] from typing import Callable [EOL] [EOL] [EOL] from lagom import Container [EOL] from lagom . experimental . definitions import PlainFunction [EOL] [EOL] [EOL] class ClassNeedingAFunction : [EOL] def __init__ ( self , adder ) : [EOL] self . adder = adder [EOL] [EOL] def trigger ( self , x , y ) : [EOL] adder = self . adder [EOL] return adder ( x , y ) [EOL] [EOL] [EOL] def add_stuff ( x , y ) : [EOL] return x + y [EOL] [EOL] [EOL] def test_ways_of_constructing_functions_can_be_provided ( container ) : [EOL] container [ Callable [ [ int , int ] , int ] ] = PlainFunction ( add_stuff ) [EOL] erm = container [ ClassNeedingAFunction ] [EOL] assert erm . trigger ( [number] , [number] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.int,builtins.int],builtins.int]$ 0 0 0 0 0 $typing.Callable[[builtins.int,builtins.int],builtins.int]$ 0 $typing.Callable[[builtins.int,builtins.int],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.int,builtins.int],builtins.int]$ 0 0 0 $typing.Callable[[builtins.int,builtins.int],builtins.int]$ 0 0 $typing.Callable[[builtins.int,builtins.int],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Container [EOL] import typing [EOL] import lagom [EOL] import pytest [EOL] [EOL] from lagom import Container [EOL] from lagom . experimental . integrations . django import DjangoModel [EOL] from tests . experimental . integrations . conftest import FakeDjangoModel , FakeDjangoManager [EOL] [EOL] [EOL] def test_django_models_can_be_created ( django_container ) : [EOL] models = django_container . resolve ( DjangoModel [ FakeDjangoModel ] ) [EOL] new_model_instance = models . new ( first = [number] , second = [number] ) [EOL] assert isinstance ( new_model_instance , FakeDjangoModel ) [EOL] assert new_model_instance . data == { [string] : [number] , [string] : [number] } [EOL] [EOL] [EOL] def test_django_models_can_be_managed ( django_container ) : [EOL] models = django_container . resolve ( DjangoModel [ FakeDjangoModel ] ) [EOL] assert isinstance ( models . objects , FakeDjangoManager ) [EOL] [EOL] [EOL] def test_django_models_can_be_managed_via_a_custom_manager ( django_container ) : [EOL] models = django_container . resolve ( DjangoModel [ FakeDjangoModel ] ) [EOL] assert isinstance ( models . managers . custom_manager , FakeDjangoManager ) [EOL] [EOL] [EOL] def test_trying_to_load_a_non_existent_manager_throws_a_sensible_error ( django_container , ) : [EOL] models = django_container . resolve ( DjangoModel [ FakeDjangoModel ] ) [EOL] with pytest . raises ( KeyError ) : [EOL] models . managers . lol . all ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import tests [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] [EOL] from lagom . experimental . integrations . django import DjangoContainer [EOL] [EOL] [EOL] class FakeDjangoManager : [EOL] pass [EOL] [EOL] [EOL] class FakeDjangoModel : [EOL] data = ... [EOL] objects = FakeDjangoManager ( ) [EOL] custom_manager = FakeDjangoManager ( ) [EOL] [EOL] def __init__ ( self , ** kwargs ) : [EOL] self . data = kwargs [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def django_container ( ) : [EOL] return DjangoContainer ( models = [ FakeDjangoModel ] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $tests.experimental.integrations.conftest.FakeDjangoManager$ 0 0 0 0 0 $tests.experimental.integrations.conftest.FakeDjangoManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from . version import __version__ [EOL] from . definitions import Singleton , Alias [EOL] from . container import Container [EOL] from . decorators import ( bind_to_container , magic_bind_to_container , dependency_definition , ) [EOL] from . markers import injectable [EOL] from . import integrations , environment , experimental , exceptions [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , TypeVar , Type , Set , Callable [EOL] import typing [EOL] [docstring] [EOL] from abc import ABC , abstractmethod [EOL] from typing import Generic , TypeVar , Type , Any , Callable , Union , List , Set [EOL] [EOL] X = TypeVar ( [string] ) [EOL] [EOL] [EOL] BuildingFunction = Callable [ [ Any ] , Any ] [EOL] [EOL] [EOL] class ReadableContainer ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def resolve ( self , dep_type , suppress_error = False , skip_definitions = False ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ abstractmethod def __getitem__ ( self , dep ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ property @ abstractmethod def defined_types ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class SpecialDepDefinition ( ABC , Generic [ X ] ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def get_instance ( self , container ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] T = TypeVar ( [string] ) [EOL] [EOL] [docstring] [EOL] TypeResolver = Union [ Type [ T ] , Callable [ [ ] , T ] , Callable [ [ ReadableContainer ] , T ] , SpecialDepDefinition [ T ] , T , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $X$ 0 0 0 $typing.Type[X]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $X$ 0 0 0 $typing.Type[X]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $X$ 0 0 0 $ReadableContainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] [EOL] class Injectable : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] injectable = Injectable ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Union , Optional , Callable , TypeVar , Type , Any [EOL] import typing [EOL] import lagom [EOL] import interfaces [EOL] [docstring] [EOL] import inspect [EOL] from typing import Union , Type , Optional , Callable , TypeVar [EOL] [EOL] from . exceptions import InvalidDependencyDefinition [EOL] from . interfaces import SpecialDepDefinition , ReadableContainer , TypeResolver [EOL] from . util . functional import arity [EOL] [EOL] X = TypeVar ( [string] ) [EOL] [EOL] [EOL] class ConstructionWithoutContainer ( SpecialDepDefinition [ X ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , constructor ) : [EOL] self . constructor = constructor [EOL] [EOL] def get_instance ( self , container ) : [EOL] resolver = self . constructor [EOL] return resolver ( ) [EOL] [EOL] [EOL] class ConstructionWithContainer ( SpecialDepDefinition [ X ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , constructor ) : [EOL] self . constructor = constructor [EOL] [EOL] def get_instance ( self , container ) : [EOL] resolver = self . constructor [EOL] return resolver ( container ) [EOL] [EOL] [EOL] def construction ( resolver , ) : [EOL] [docstring] [EOL] func_arity = arity ( resolver ) [EOL] if func_arity == [number] : [EOL] return ConstructionWithoutContainer ( resolver ) [EOL] if func_arity == [number] : [EOL] return ConstructionWithContainer ( resolver ) [EOL] raise InvalidDependencyDefinition ( f" [string] { func_arity } [string] " ) [EOL] [EOL] [EOL] class Alias ( SpecialDepDefinition [ X ] ) : [EOL] [docstring] [EOL] [EOL] alias_type = ... [EOL] [EOL] def __init__ ( self , alias_type ) : [EOL] self . alias_type = alias_type [EOL] [EOL] def get_instance ( self , container ) : [EOL] return container . resolve ( self . alias_type , skip_definitions = True ) [EOL] [EOL] [EOL] class Singleton ( SpecialDepDefinition [ X ] ) : [EOL] [docstring] [EOL] [EOL] singleton_type = ... [EOL] _instance = ... [EOL] [EOL] def __init__ ( self , singleton_type ) : [EOL] self . singleton_type = normalise ( singleton_type ) [EOL] self . _instance = None [EOL] [EOL] def get_instance ( self , container ) : [EOL] if self . _has_instance : [EOL] return self . _instance [comment] [EOL] instance = self . singleton_type . get_instance ( container ) [EOL] return self . _set_instance ( instance ) [EOL] [EOL] @ property def _has_instance ( self ) : [EOL] return self . _instance is not None [EOL] [EOL] def _set_instance ( self , instance ) : [EOL] self . _instance = instance [EOL] return instance [EOL] [EOL] [EOL] def normalise ( resolver ) : [EOL] [docstring] [EOL] if isinstance ( resolver , SpecialDepDefinition ) : [EOL] return resolver [EOL] elif inspect . isfunction ( resolver ) : [EOL] return construction ( resolver ) [EOL] elif inspect . iscoroutinefunction ( resolver ) : [EOL] return construction ( resolver ) [EOL] elif not inspect . isclass ( resolver ) : [EOL] return Singleton ( lambda : resolver ) [EOL] else : [EOL] return Alias ( resolver ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[X]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $interfaces.SpecialDepDefinition$ 0 0 0 $typing.Optional[X]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Variable[lagom.definitions.X]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Type , List [EOL] import typing [EOL] [docstring] [EOL] from abc import ABC [EOL] from typing import Type [EOL] [EOL] import typing [EOL] [EOL] [EOL] class LagomException ( Exception , ABC ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class InvalidDependencyDefinition ( ValueError , LagomException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class MissingReturnType ( SyntaxError , LagomException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class DuplicateDefinition ( ValueError , LagomException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class UnableToInvokeBoundFunction ( TypeError , LagomException ) : [EOL] [docstring] [EOL] [EOL] unresolvable_deps = ... [EOL] [EOL] def __init__ ( self , msg , unresolvable_deps ) : [EOL] self . unresolvable_deps = unresolvable_deps [EOL] unresolvable_string_list = [string] . join ( d . __name__ for d in unresolvable_deps ) [EOL] super ( ) . __init__ ( f"{ msg } [string] { unresolvable_string_list }" ) [EOL] [EOL] [EOL] class UnresolvableType ( ValueError , LagomException ) : [EOL] [docstring] [EOL] [EOL] dep_type = ... [EOL] [EOL] def __init__ ( self , dep_type ) : [EOL] [docstring] [EOL] self . dep_type = _dep_type_as_string ( dep_type ) [EOL] super ( ) . __init__ ( f" [string] { self . dep_type } [string] " [string] ) [EOL] [EOL] [EOL] class RecursiveDefinitionError ( SyntaxError , LagomException ) : [EOL] [docstring] [EOL] [EOL] dep_type = ... [EOL] [EOL] def __init__ ( self , dep_type ) : [EOL] [docstring] [EOL] self . dep_type = _dep_type_as_string ( dep_type ) [EOL] [EOL] super ( ) . __init__ ( f" [string] { self . dep_type } [string] " [string] ) [EOL] [EOL] [EOL] def _dep_type_as_string ( dep_type ) : [EOL] [comment] [EOL] if hasattr ( typing , [string] ) and isinstance ( dep_type , typing . GenericMeta ) : [EOL] return str ( dep_type ) [EOL] elif hasattr ( dep_type , [string] ) : [EOL] return dep_type . __name__ [EOL] [EOL] return str ( dep_type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type[typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Type[typing.Any]]$ 0 $typing.List[typing.Type[typing.Any]]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] __version__ = [string] [EOL] [EOL] if __name__ == [string] : [EOL] print ( __version__ ) [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Container , Tuple , Union , Optional , Callable , TypeVar , Dict , Type , List , Set , Any , Generator [EOL] import util [EOL] import typing [EOL] import builtins [EOL] import lagom [EOL] import interfaces [EOL] import functools [EOL] from copy import copy [EOL] from typing import Dict , Type , Any , TypeVar , Callable , Set , List , Optional [EOL] [EOL] from . interfaces import SpecialDepDefinition , ReadableContainer , TypeResolver [EOL] from . exceptions import ( UnresolvableType , DuplicateDefinition , InvalidDependencyDefinition , RecursiveDefinitionError , ) [EOL] from . markers import injectable [EOL] from . definitions import normalise , Singleton , construction [EOL] from . util . reflection import FunctionSpec , CachingReflector [EOL] from . wrapping import bound_function , wrap_func_in_error_handling [EOL] [EOL] UNRESOLVABLE_TYPES = [ str , int , float , bool ] [EOL] [EOL] X = TypeVar ( [string] ) [EOL] [EOL] [EOL] class Container ( ReadableContainer ) : [EOL] [docstring] [EOL] [EOL] _registered_types = ... [EOL] _explicitly_registered_types = ... [EOL] _reflector = ... [EOL] [EOL] def __init__ ( self , container = None ) : [EOL] [docstring] [EOL] self . _explicitly_registered_types = set ( ) [EOL] [EOL] if container : [EOL] self . _registered_types = copy ( container . _registered_types ) [EOL] self . _reflector = container . _reflector [EOL] else : [EOL] self . _registered_types = { } [EOL] self . _reflector = CachingReflector ( ) [EOL] [EOL] def define ( self , dep , resolver ) : [EOL] [docstring] [EOL] if dep in UNRESOLVABLE_TYPES : [EOL] raise InvalidDependencyDefinition ( ) [EOL] if dep in self . _explicitly_registered_types : [EOL] raise DuplicateDefinition ( ) [EOL] self . _registered_types [ dep ] = normalise ( resolver ) [EOL] self . _explicitly_registered_types . add ( dep ) [EOL] [EOL] @ property def defined_types ( self ) : [EOL] [docstring] [EOL] return set ( self . _registered_types . keys ( ) ) [EOL] [EOL] @ property def reflection_cache_overview ( self ) : [EOL] return self . _reflector . overview_of_cache [EOL] [EOL] def resolve ( self , dep_type , suppress_error = False , skip_definitions = False ) : [EOL] [docstring] [EOL] try : [EOL] optional_dep_type = _remove_optional_type ( dep_type ) [EOL] if optional_dep_type : [EOL] return self . resolve ( optional_dep_type , suppress_error = True ) [EOL] if dep_type in UNRESOLVABLE_TYPES : [EOL] raise UnresolvableType ( dep_type ) [EOL] type_to_build = ( self . _registered_types . get ( dep_type , dep_type ) [EOL] if not skip_definitions [EOL] else dep_type ) [EOL] if isinstance ( type_to_build , SpecialDepDefinition ) : [EOL] return type_to_build . get_instance ( self ) [EOL] return self . _reflection_build ( type_to_build ) [EOL] except UnresolvableType as inner_error : [EOL] if not suppress_error : [EOL] raise UnresolvableType ( dep_type ) from inner_error [EOL] return None [comment] [EOL] except RecursionError as recursion_error : [EOL] raise RecursiveDefinitionError ( dep_type ) from recursion_error [EOL] [EOL] def partial ( self , func , shared = None , ) : [EOL] [docstring] [EOL] spec = self . _reflector . get_function_spec ( func ) [EOL] keys_to_bind = ( key for ( key , arg ) in spec . defaults . items ( ) if arg is injectable ) [EOL] keys_and_types = [ ( key , spec . annotations [ key ] ) for key in keys_to_bind ] [EOL] [EOL] func_with_error_handling = wrap_func_in_error_handling ( func , spec ) [EOL] _container_loader = container_loader ( self , shared ) [EOL] [EOL] def _bind_func ( * _args ) : [EOL] c = _container_loader ( ) [EOL] bindable_deps = { key : c . resolve ( dep_type ) for ( key , dep_type ) in keys_and_types } [EOL] return functools . partial ( func_with_error_handling , ** bindable_deps ) [EOL] [EOL] return bound_function ( _bind_func , func ) [EOL] [EOL] def magic_partial ( self , func , shared = None , keys_to_skip = None , skip_pos_up_to = [number] , ) : [EOL] [docstring] [EOL] [EOL] spec = self . _reflector . get_function_spec ( func ) [EOL] [EOL] func_with_error_handling = wrap_func_in_error_handling ( func , spec ) [EOL] _container_loader = container_loader ( self , shared ) [EOL] [EOL] def _bind_func ( extra_keys_to_skip = None , extra_skip_pos_up_to = [number] ) : [EOL] final_keys_to_skip = ( keys_to_skip or [ ] ) + ( extra_keys_to_skip or [ ] ) [EOL] final_skip_pos_up_to = max ( skip_pos_up_to , extra_skip_pos_up_to ) [EOL] bindable_deps = _container_loader ( ) . _infer_dependencies ( spec , suppress_error = True , keys_to_skip = final_keys_to_skip , skip_pos_up_to = final_skip_pos_up_to , ) [EOL] return functools . partial ( func_with_error_handling , ** bindable_deps ) [EOL] [EOL] return bound_function ( _bind_func , func ) [EOL] [EOL] def clone ( self ) : [EOL] [docstring] [EOL] return Container ( self ) [EOL] [EOL] def __getitem__ ( self , dep ) : [EOL] return self . resolve ( dep ) [EOL] [EOL] def __setitem__ ( self , dep , resolver ) : [EOL] self . define ( dep , resolver ) [EOL] [EOL] def _reflection_build ( self , dep_type ) : [EOL] spec = self . _reflector . get_function_spec ( dep_type . __init__ ) [EOL] sub_deps = self . _infer_dependencies ( spec , types_to_skip = { dep_type } ) [EOL] try : [EOL] return dep_type ( ** sub_deps ) [comment] [EOL] except TypeError as type_error : [EOL] raise UnresolvableType ( dep_type ) from type_error [EOL] [EOL] def _infer_dependencies ( self , spec , suppress_error = False , keys_to_skip = None , skip_pos_up_to = [number] , types_to_skip = None , ) : [EOL] supplied_arguments = spec . args [ [number] : skip_pos_up_to ] [EOL] keys_to_skip = ( keys_to_skip or [ ] ) + supplied_arguments [EOL] types_to_skip = types_to_skip or set ( ) [EOL] sub_deps = { key : self . resolve ( sub_dep_type , suppress_error = suppress_error ) for ( key , sub_dep_type ) in spec . annotations . items ( ) if sub_dep_type != Any [EOL] and ( key not in keys_to_skip ) [EOL] and ( sub_dep_type not in types_to_skip ) } [EOL] filtered_deps = { key : dep for ( key , dep ) in sub_deps . items ( ) if dep is not None } [EOL] return filtered_deps [EOL] [EOL] [EOL] def _remove_optional_type ( dep_type ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] if len ( dep_type . __args__ ) == [number] and dep_type . __args__ [ [number] ] == None . __class__ : [EOL] return dep_type . __args__ [ [number] ] [EOL] except : [EOL] pass [EOL] return None [EOL] [EOL] [EOL] def container_loader ( container , shared ) : [EOL] if shared : [EOL] _container_loader = _container_with_singletons_builder ( container , shared ) [EOL] else : [EOL] [EOL] def _container_loader ( ) : [EOL] return container [EOL] [EOL] return _container_loader [EOL] [EOL] [EOL] def _container_with_singletons_builder ( container , singletons ) : [EOL] loaders = { dep : construction ( lambda : container . resolve ( dep ) ) for dep in singletons } [EOL] [EOL] def _clone_container ( ) : [EOL] temp_container = container . clone ( ) [EOL] [comment] [EOL] [comment] [EOL] for ( dep , loader ) in loaders . items ( ) : [EOL] temp_container [ dep ] = Singleton ( loader ) [EOL] return temp_container [EOL] [EOL] return _clone_container [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Type,interfaces.SpecialDepDefinition]$ 0 0 0 $typing.Set[typing.Type]$ 0 0 0 $util.reflection.CachingReflector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[typing.Type[typing.Any]]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Set[typing.Type[typing.Any]]$ 0 $typing.Set[typing.Type[typing.Any]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[typing.Type[typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import AbstractSet , ClassVar , Optional , Tuple [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import os [EOL] from abc import ABC [EOL] from typing import ClassVar , Optional [EOL] [EOL] try : [EOL] from pydantic . main import BaseModel [EOL] except ImportError as error : [EOL] raise ImportError ( [string] ) from error [EOL] [EOL] [EOL] class Env ( ABC , BaseModel ) : [EOL] [docstring] [EOL] [EOL] PREFIX = None [EOL] [EOL] def __init__ ( self , ** kwargs ) : [EOL] if len ( kwargs ) == [number] : [EOL] prefix = f"{ self . PREFIX } [string] " if self . PREFIX else [string] [EOL] envs = os . environ . items ( ) [EOL] super ( ) . __init__ ( ** { key . replace ( prefix , [string] ) . lower ( ) : value for ( key , value ) in envs if key . startswith ( prefix ) } ) [EOL] else : [EOL] super ( ) . __init__ ( ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Type , List , Callable [EOL] import typing [EOL] import flask [EOL] [docstring] [EOL] from typing import Type , List , Optional [EOL] [EOL] from flask import Flask [EOL] [EOL] from . . container import Container [EOL] [EOL] [EOL] class FlaskContainer ( Container ) : [EOL] [docstring] [EOL] [EOL] flask_app = ... [EOL] _request_singletons = ... [EOL] [EOL] def __init__ ( self , app , request_singletons = None , container = None , ) : [EOL] [docstring] [EOL] self . flask_app = app [EOL] self . _request_singletons = request_singletons or [ ] [EOL] super ( ) . __init__ ( container ) [EOL] [EOL] def route ( self , rule , ** options ) : [EOL] [docstring] [EOL] [EOL] def _decorator ( f ) : [EOL] endpoint = options . pop ( [string] , None ) [EOL] injected_func = self . partial ( f , shared = self . _request_singletons ) [EOL] self . flask_app . add_url_rule ( rule , endpoint , injected_func , ** options ) [EOL] return f [EOL] [EOL] return _decorator [EOL] [EOL] def magic_route ( self , rule , ** options ) : [EOL] [docstring] [EOL] [EOL] def _decorator ( f ) : [EOL] endpoint = options . pop ( [string] , None ) [EOL] injected_func = self . magic_partial ( f , shared = self . _request_singletons ) [EOL] self . flask_app . add_url_rule ( rule , endpoint , injected_func , ** options ) [EOL] return f [EOL] [EOL] return _decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 $typing.List[typing.Type]$ 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 $typing.Optional[typing.List[typing.Type]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 $flask.Flask$ 0 0 0 $typing.List[typing.Type[typing.Any]]$ 0 $typing.Optional[typing.List[typing.Type]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Type , List , Callable [EOL] import typing [EOL] import builtins [EOL] import starlette [EOL] [docstring] [EOL] from typing import List , Type , Callable , Optional [EOL] [EOL] from starlette . routing import Route [EOL] [EOL] from . . import Container [EOL] [EOL] [EOL] class StarletteContainer ( Container ) : [EOL] [docstring] [EOL] [EOL] _request_singletons = ... [EOL] [EOL] def __init__ ( self , request_singletons = None , container = None ) : [EOL] [docstring] [EOL] self . _request_singletons = request_singletons or [ ] [EOL] super ( ) . __init__ ( container ) [EOL] [EOL] def route ( self , path , endpoint , * , methods = None , name = None , include_in_schema = True , ) : [EOL] [docstring] [EOL] wrapped_endpoint = self . partial ( endpoint , shared = self . _request_singletons ) [EOL] return Route ( path , wrapped_endpoint , methods = methods , name = name , include_in_schema = include_in_schema , ) [EOL] [EOL] def magic_route ( self , path , endpoint , * , methods = None , name = None , include_in_schema = True , ) : [EOL] [docstring] [EOL] wrapped_endpoint = self . magic_partial ( endpoint , shared = self . _request_singletons ) [EOL] return Route ( path , wrapped_endpoint , methods = methods , name = name , include_in_schema = include_in_schema , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Callable [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import inspect [EOL] from typing import Callable [EOL] [EOL] [EOL] def arity ( func ) : [EOL] [docstring] [EOL] return len ( inspect . signature ( func ) . parameters ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Optional , Callable , Dict , AbstractSet , Type , List , Any [EOL] import typing [EOL] import inspect [EOL] import builtins [EOL] import lagom [EOL] [docstring] [EOL] import inspect [EOL] from typing import Dict , Type , List , Callable , get_type_hints , Optional , Awaitable , Any [EOL] [EOL] RETURN_ANNOTATION = [string] [EOL] [EOL] [EOL] class FunctionSpec : [EOL] [docstring] [EOL] [EOL] args = ... [EOL] annotations = ... [EOL] defaults = ... [EOL] return_type = ... [EOL] arity = ... [EOL] [EOL] def __init__ ( self , args , annotations , defaults , return_type ) : [EOL] self . args = args [EOL] self . annotations = annotations [EOL] self . defaults = defaults [EOL] self . return_type = return_type [EOL] self . arity = len ( args ) [EOL] [EOL] def __repr__ ( self ) : [EOL] def _arg_type_string ( arg ) : [EOL] return self . annotations [ arg ] . __name__ if arg in self . annotations else [string] [EOL] [EOL] signature = [string] . join ( _arg_type_string ( arg ) for arg in self . args ) [EOL] if self . return_type : [EOL] return f" [string] { signature } [string] { self . return_type . __name__ }" [EOL] else : [EOL] return f" [string] { signature } [string] " [EOL] [EOL] [EOL] class CachingReflector : [EOL] [docstring] [EOL] [EOL] _reflection_cache = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . _reflection_cache = { } [EOL] [EOL] @ property def overview_of_cache ( self ) : [EOL] return { k . __qualname__ : repr ( v ) for ( k , v ) in self . _reflection_cache . items ( ) } [EOL] [EOL] def get_function_spec ( self , func ) : [EOL] [docstring] [EOL] if func not in self . _reflection_cache : [EOL] self . _reflection_cache [ func ] = reflect ( func ) [EOL] return self . _reflection_cache [ func ] [EOL] [EOL] [EOL] def reflect ( func ) : [EOL] spec = inspect . getfullargspec ( func ) [EOL] annotations = get_type_hints ( func ) [EOL] defaults = _get_default_args ( func ) [EOL] ret = annotations . pop ( RETURN_ANNOTATION , None ) [EOL] if ret and inspect . iscoroutinefunction ( func ) : [EOL] ret = Awaitable [ ret ] [comment] [EOL] return FunctionSpec ( spec . args , annotations , defaults , ret ) [EOL] [EOL] [EOL] def _get_default_args ( func ) : [EOL] arguments = inspect . signature ( func ) . parameters . items ( ) [EOL] return { name : argument . default for name , argument in arguments if argument . default is not inspect . Parameter . empty } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 $typing.Dict[builtins.str,typing.Type]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Optional[typing.Type]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Dict[builtins.str,typing.Type[typing.Any]]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Optional[typing.Type[typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Type[typing.Any]]$ 0 $typing.Dict[builtins.str,typing.Type[typing.Any]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Optional[typing.Type[typing.Any]]$ 0 $typing.Optional[typing.Type[typing.Any]]$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Callable,FunctionSpec]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Callable[...,typing.Any],lagom.util.reflection.FunctionSpec]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FunctionSpec$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FunctionSpec$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from . . exceptions import LagomException [EOL] [EOL] [EOL] class DependencyNotDefined ( ValueError , LagomException ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import TypeVar , Type [EOL] import typing [EOL] from typing import Type , TypeVar [EOL] [EOL] from . . import Container [EOL] from . exceptions import DependencyNotDefined [EOL] [EOL] X = TypeVar ( [string] ) [EOL] [EOL] [EOL] class ExplicitContainer ( Container ) : [EOL] def resolve ( self , dep_type , suppress_error = False , skip_definitions = False ) : [EOL] if dep_type not in self . defined_types : [EOL] if suppress_error : [EOL] return None [comment] [EOL] raise DependencyNotDefined ( f"{ dep_type . __name__ } [string] " [string] ) [EOL] return super ( ) . resolve ( dep_type , suppress_error , skip_definitions ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import definitions [EOL] import lagom [EOL] import interfaces [EOL] from . . definitions import X [EOL] from . . interfaces import SpecialDepDefinition , ReadableContainer [EOL] [EOL] [EOL] class PlainFunction ( SpecialDepDefinition [ X ] ) : [EOL] [docstring] [EOL] [EOL] callable_func = ... [EOL] [EOL] def __init__ ( self , callable_func ) : [EOL] [docstring] [EOL] self . callable_func = callable_func [EOL] [EOL] def get_instance ( self , _container ) : [EOL] return self . callable_func [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $definitions.X$ 0 0 0 0 0 0 0 0 0 $Variable[lagom.definitions.X]$ 0 0 0 0 0 0 0 $Variable[lagom.definitions.X]$ 0 $Variable[lagom.definitions.X]$ 0 0 0 $definitions.X$ 0 0 0 $interfaces.ReadableContainer$ 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Container , Optional , Any , TypeVar , Type , List , Callable [EOL] import typing [EOL] import container [EOL] import django [EOL] [docstring] [EOL] import types [EOL] from typing import TypeVar , Generic , List , Type , Optional [EOL] [EOL] from django . db . models import Manager , Model [EOL] from django . views import View [EOL] [EOL] from . . container import Container [EOL] [EOL] M = TypeVar ( [string] , bound = Model ) [EOL] [EOL] [EOL] class _Managers ( Generic [ M ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , model ) : [EOL] self . model = model [EOL] [EOL] def __getattr__ ( self , item ) : [EOL] if not hasattr ( self . model , item ) : [EOL] raise KeyError ( f" [string] { self . model . __name__ } [string] { item }" ) [EOL] return getattr ( self . model , item ) [EOL] [EOL] [EOL] class DjangoModel ( Generic [ M ] ) : [EOL] [docstring] [EOL] [EOL] model = ... [EOL] managers = ... [EOL] [EOL] def __init__ ( self , model ) : [EOL] [docstring] [EOL] self . model = model [EOL] self . managers = _Managers ( self . model ) [EOL] [EOL] @ property def objects ( self ) : [EOL] [docstring] [EOL] return self . managers . objects [EOL] [EOL] def new ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . model ( ** kwargs ) [EOL] [EOL] [EOL] class DjangoContainer ( Container ) : [EOL] [docstring] [EOL] [EOL] _request_singletons = ... [EOL] [EOL] def __init__ ( self , models = None , request_singletons = None , container = None , ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( container ) [EOL] self . _request_singletons = request_singletons or [ ] [EOL] for model in models or [ ] : [EOL] self . define ( DjangoModel [ model ] , DjangoModel ( model ) ) [comment] [EOL] [EOL] def bind_view ( self , view ) : [EOL] [docstring] [EOL] if isinstance ( view , types . FunctionType ) : [EOL] [comment] [EOL] return self . partial ( view , shared = self . _request_singletons ) [EOL] return self . _bind_view_methods_to_container ( view ) [EOL] [EOL] def magic_bind_view ( self , view ) : [EOL] [docstring] [EOL] if isinstance ( view , types . FunctionType ) : [EOL] [comment] [EOL] return self . magic_partial ( view , shared = self . _request_singletons ) [EOL] return self . _bind_view_methods_to_container ( view , magic = True ) [EOL] [EOL] def _bind_view_methods_to_container ( self , view , magic = False ) : [EOL] for method in View . http_method_names : [EOL] if hasattr ( view , method ) : [EOL] if magic : [EOL] bound_func = self . magic_partial ( getattr ( view , method ) , shared = self . _request_singletons ) [EOL] else : [EOL] bound_func = self . partial ( getattr ( view , method ) , shared = self . _request_singletons ) [EOL] setattr ( view , method , bound_func , ) [EOL] return view [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.db.models.Manager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[M]$ 0 0 0 $_Managers[M]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.db.models.Manager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $M$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Type[django.db.models.Model]]]$ 0 0 0 $typing.Optional[typing.List[typing.Type]]$ 0 0 0 $container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $container.Container$ 0 0 0 0 $typing.List[typing.Type[typing.Any]]$ 0 $typing.Optional[typing.List[typing.Type]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Type[django.db.models.Model]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0