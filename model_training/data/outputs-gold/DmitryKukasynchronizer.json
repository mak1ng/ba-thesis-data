from typing import Optional , MutableSet , Callable , Tuple , Any , List [EOL] import typing [EOL] import builtins [EOL] import functools [EOL] import asynchronizer [EOL] import concurrent [EOL] import asyncio [EOL] import threading [EOL] import asyncio [EOL] import concurrent . futures [EOL] import functools [EOL] import threading [EOL] from typing import Any , Callable , Optional , MutableSet , List , Tuple [EOL] [EOL] from _asynchronizer_ext import Thread , IoContext , ErrorCategory , ErrorCode [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class Asynchronizer : [EOL] def __init__ ( self , loop = None , ) : [EOL] [docstring] [EOL] [EOL] if loop is None : [EOL] loop = asyncio . get_event_loop ( ) [EOL] [EOL] self . _loop = loop [EOL] self . _ready_queue = _ReadyQueue ( loop = loop ) [EOL] [EOL] @ property def loop ( self ) : [EOL] return self . _loop [EOL] [EOL] def call_async ( self , start_task , * , default = None , pack_single = False , ) : [EOL] [docstring] [EOL] [EOL] future = self . _loop . create_future ( ) [EOL] start_task ( self . _ready_queue . prepare ( future = future , default = default , pack_single = pack_single ) ) [EOL] return future [EOL] [EOL] [EOL] class _ReadyQueue : [EOL] def __init__ ( self , loop ) : [EOL] self . loop = loop [EOL] self . _lock = threading . Lock ( ) [EOL] self . _ready_callbacks = set ( ) [EOL] self . _ready = [ ] [EOL] self . _set_results_job = None [EOL] [EOL] def prepare ( self , future , default , pack_single ) : [EOL] on_ready = functools . partial ( self . _on_ready , future = future , default = default , pack_single = pack_single ) [EOL] future . add_done_callback ( lambda _future : self . _ready_callbacks . discard ( on_ready ) ) [EOL] self . _ready_callbacks . add ( on_ready ) [EOL] return on_ready [EOL] [EOL] def _on_ready ( self , * result , future , default , pack_single ) : [EOL] if result : [EOL] if not pack_single : [EOL] result = result [ [number] ] [EOL] else : [EOL] result = default [EOL] [EOL] with self . _lock : [EOL] self . _ready . append ( ( future , result ) ) [EOL] if self . _set_results_job is None : [EOL] self . _set_results_job = asyncio . run_coroutine_threadsafe ( self . _set_results ( ) , loop = self . loop ) [EOL] [EOL] async def _set_results ( self ) : [EOL] with self . _lock : [EOL] for future , result in self . _ready : [EOL] future . set_result ( result ) [EOL] [EOL] self . _ready . clear ( ) [EOL] self . _set_results_job = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[concurrent.futures.Future]$ 0 0 0 0 0 $typing.Callable[...,None]$ 0 0 0 $asyncio.Future$ 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 $asyncio.Future$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $asyncio.Future$ 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 0 0 0 0 0 0 $functools.partial[None]$ 0 0 0 $functools.partial[None]$ 0 0 0 $None$ 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 $asyncio.Future$ 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 $builtins.bool$ 0 0 $typing.Tuple[typing.Any,...]$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.Future$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 $typing.Optional[concurrent.futures._base.Future[typing.Any]]$ 0 0 0 0 0 0 $typing.Optional[concurrent.futures._base.Future[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[concurrent.futures._base.Future[typing.Any]]$ 0 0 0
from . asynchronizer import Thread , IoContext , ErrorCategory , ErrorCode , Asynchronizer [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import argparse [EOL] import os [EOL] import subprocess [EOL] from argparse import ArgumentParser [EOL] from os import environ , stat as stat_fn , unlink [EOL] from os . path import abspath , basename , dirname , exists , realpath , splitext [EOL] from shutil import rmtree [EOL] from stat import S_ISDIR [EOL] from subprocess import PIPE , Popen [EOL] from sys import argv , executable , exit , stderr [EOL] from textwrap import indent [EOL] [EOL] [EOL] [comment] [EOL] parser = ArgumentParser ( prog = argv [ [number] ] , description = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , required = True , help = [string] , ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , required = True , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , required = True , help = [string] ) [EOL] args = parser . parse_args ( argv [ [number] : ] ) [EOL] [EOL] output_file = abspath ( args . output ) [EOL] [EOL] [EOL] [comment] [EOL] try : [EOL] s = stat_fn ( output_file ) [EOL] except FileNotFoundError : [EOL] pass [EOL] else : [EOL] if S_ISDIR ( s . st_mode ) : [EOL] rmtree ( output_file ) [EOL] else : [EOL] unlink ( output_file ) [EOL] [EOL] [EOL] [comment] [EOL] module_search_path = realpath ( dirname ( args . input ) ) [EOL] python_path = environ . get ( [string] ) [EOL] if python_path is None : [EOL] python_path = module_search_path [EOL] else : [EOL] python_path = [string] . join ( module_search_path , * ( p for p in python_path . split ( [string] ) if p != module_search_path ) ) [EOL] [EOL] env = { key : value for key , value in environ . items ( ) } [EOL] env [ [string] ] = python_path [EOL] [EOL] [EOL] [comment] [EOL] stubgen_process = Popen ( [ executable , [string] , [string] , args . stubgen , [string] , dirname ( output_file ) , [string] , splitext ( basename ( args . input ) ) [ [number] ] , ] , stdout = PIPE , stderr = PIPE , env = env , ) [EOL] stubgen_stdout , stubgen_stderr = stubgen_process . communicate ( ) [EOL] [EOL] [EOL] [comment] [EOL] return_code = [number] [EOL] if not exists ( output_file ) : [EOL] print ( [string] , file = stderr ) [EOL] return_code = [number] [EOL] [EOL] if stubgen_process . returncode != [number] : [EOL] return_code = stubgen_process . returncode [EOL] print ( f' [string] { return_code } [string] ' , file = stderr ) [EOL] [EOL] if return_code != [number] : [EOL] if stubgen_stderr : [EOL] print ( [string] , file = stderr ) [EOL] print ( indent ( stubgen_stderr . decode ( ) , [string] ) , file = stderr ) [EOL] [EOL] if stubgen_stdout : [EOL] print ( [string] , file = stderr ) [EOL] print ( indent ( stubgen_stdout . decode ( ) , [string] ) , file = stderr ) [EOL] [EOL] exit ( return_code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os.stat_result$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
	0
from typing import Tuple , Any , List [EOL] import typing [EOL] import asyncio [EOL] import asynchronizer [EOL] import asyncio [EOL] import random [EOL] import time [EOL] [EOL] import asynctest [EOL] import test_async_sleep_ext [EOL] [EOL] from asynchronizer import IoContext , ErrorCode , Asynchronizer [EOL] [EOL] [EOL] class TestAsyncSleep ( asynctest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . _io_context = IoContext ( ) [EOL] self . _work_guard = self . _io_context . create_work_guard ( ) [EOL] self . _runner = self . _io_context . start_runner ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . _work_guard . reset ( ) [EOL] self . _runner . join ( ) [EOL] self . _io_context . stop ( ) [EOL] [EOL] def test_runner_is_joinable ( self ) : [EOL] self . assertTrue ( self . _runner . joinable ) [EOL] [EOL] def test_work_guard ( self ) : [EOL] self . assertTrue ( self . _work_guard . owns_work ) [EOL] [EOL] def test_async_wait_lowlevel ( self ) : [EOL] timeout = [number] [EOL] on_ready = asynctest . MagicMock ( ) [EOL] timer = test_async_sleep_ext . SystemTimer ( io_context = self . _io_context , seconds = timeout ) [EOL] timer . async_wait ( on_ready = on_ready ) [EOL] [EOL] time . sleep ( timeout * [number] ) [EOL] [EOL] on_ready . assert_called_once ( ) [EOL] [EOL] args , kwags = on_ready . call_args [EOL] self . assertEqual ( [number] , len ( args ) ) [EOL] self . assertDictEqual ( { } , kwags ) [EOL] [EOL] error_code = args [ [number] ] [EOL] self . assertTrue ( isinstance ( error_code , ErrorCode ) ) [EOL] self . assertEqual ( [number] , error_code . value ) [EOL] [EOL] async def test_async_wait_highlevel ( self ) : [EOL] asynchronizer_ = Asynchronizer ( loop = self . loop ) [EOL] [EOL] timeout = [number] [EOL] timer = test_async_sleep_ext . SystemTimer ( io_context = self . _io_context , seconds = timeout ) [EOL] future = asynchronizer_ . call_async ( timer . async_wait ) [EOL] [EOL] time . sleep ( [number] ) [EOL] error_code = await future [EOL] [EOL] self . assertTrue ( isinstance ( error_code , ErrorCode ) ) [EOL] self . assertEqual ( [number] , error_code . value ) [EOL] [EOL] async def test_async_wait_gather ( self ) : [EOL] asynchronizer_ = Asynchronizer ( loop = self . loop ) [EOL] [EOL] tests = [number] [EOL] timeouts = [ random . uniform ( [number] , [number] ) for _ in range ( tests ) ] [EOL] timers = [ test_async_sleep_ext . SystemTimer ( io_context = self . _io_context , seconds = timeout ) for timeout in timeouts ] [EOL] error_codes = await asyncio . gather ( * ( asynchronizer_ . call_async ( timer . async_wait ) for timer in timers ) ) [EOL] [EOL] for timer_index , ( timeout , error_code ) in enumerate ( zip ( timeouts , error_codes ) ) : [EOL] with self . subTest ( timer = timer_index , timeout = timeout , error_code = error_code ) : [EOL] self . assertEqual ( [number] , error_code . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $asynchronizer.Asynchronizer$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $asyncio.futures.Future[typing.Any]$ 0 $asynchronizer.Asynchronizer$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $asyncio.futures.Future[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $asynchronizer.Asynchronizer$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 $asynchronizer.Asynchronizer$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 $typing.Tuple[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0