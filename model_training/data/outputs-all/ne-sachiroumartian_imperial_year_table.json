[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] import platform [EOL] import subprocess [EOL] [docstring] [EOL] from contextlib import contextmanager [EOL] from shlex import quote [EOL] import os [EOL] import os . path [EOL] import platform [EOL] import re [EOL] import shutil [EOL] import subprocess [EOL] import sys [EOL] import time [EOL] [EOL] tasks = { } [EOL] [EOL] [EOL] def cwd_for_docker_volume ( ) : [EOL] [docstring] [EOL] cwd = os . getcwd ( ) [EOL] if cwd . startswith ( [string] ) : [EOL] cwd = cwd [ [number] : ] [EOL] return cwd [EOL] [EOL] [EOL] @ contextmanager def docker ( ) : [EOL] [docstring] [EOL] if within_docker ( ) : [EOL] yield run [EOL] else : [EOL] yield run_in_docker [EOL] [EOL] [EOL] def docker_compose_exe ( ) : [EOL] [docstring] [EOL] if within_wsl ( ) : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] def docker_exe ( ) : [EOL] [docstring] [EOL] if within_wsl ( ) : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] def kubectl_exe ( ) : [EOL] [docstring] [EOL] if within_wsl ( ) : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] @ contextmanager def powershell ( ) : [EOL] [docstring] [EOL] if within_wsl ( ) : [EOL] yield run_in_powershell [EOL] else : [EOL] yield run [EOL] [EOL] [EOL] def run ( command , capture_output = False , text = None ) : [EOL] [docstring] [EOL] command = command . strip ( ) [EOL] print ( [string] , command ) [EOL] env = os . environ . copy ( ) [EOL] env [ [string] ] = [string] [EOL] env [ [string] ] = [string] [EOL] return subprocess . run ( command , env = env , capture_output = capture_output , check = True , shell = True , text = text , ) [EOL] [EOL] [EOL] def run_in_docker ( command , docker_options = [string] , capture_output = False , text = None ) : [EOL] [docstring] [EOL] command = command . strip ( ) [EOL] print ( [string] , command ) [EOL] env = os . environ . copy ( ) [EOL] env [ [string] ] = cwd_for_docker_volume ( ) [EOL] return subprocess . run ( f"{ docker_compose_exe ( ) } [string] { docker_options } [string] { command }" , env = env , capture_output = capture_output , check = True , shell = True , text = text , ) [EOL] [EOL] [EOL] def run_in_powershell ( command , capture_output = False , text = None ) : [EOL] [docstring] [EOL] command = re . sub ( [string] , [string] , command . strip ( ) ) [EOL] print ( [string] , command ) [EOL] env = os . environ . copy ( ) [EOL] env [ [string] ] = [string] [EOL] return subprocess . run ( f" [string] { quote ( command ) }" , env = env , capture_output = capture_output , check = True , shell = True , text = text , ) [EOL] [EOL] [EOL] def task ( function ) : [EOL] [docstring] [EOL] if function . __doc__ : [EOL] tasks [ function . __name__ ] = function . __doc__ [EOL] [EOL] def wrapper ( ) : [EOL] function ( ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] def within_docker ( ) : [EOL] [docstring] [EOL] return os . path . exists ( [string] ) or os . getenv ( [string] ) == [string] [EOL] [EOL] [EOL] def within_wsl ( ) : [EOL] [docstring] [EOL] uname = platform . uname ( ) [EOL] return uname [ [number] ] == [string] and ( [string] in uname [ [number] ] or [string] in uname [ [number] ] ) [EOL] [EOL] [EOL] @ task def build ( ) : [EOL] [docstring] [EOL] os . makedirs ( [string] , exist_ok = True ) [EOL] os . makedirs ( [string] , exist_ok = True ) [EOL] if not within_docker ( ) : [EOL] run ( f"{ docker_compose_exe ( ) } [string] " ) [EOL] run ( rf""" [string] { docker_compose_exe ( ) } [string] """ ) [EOL] run ( f"{ docker_compose_exe ( ) } [string] " ) [EOL] with docker ( ) as _run : [EOL] _run ( [string] . format ( quote ( [string] ) ) ) [EOL] _run ( [string] ) [EOL] _run ( [string] . format ( quote ( [string] ) ) ) [EOL] [EOL] [EOL] @ task def clean ( ) : [EOL] [docstring] [EOL] if not within_docker ( ) : [EOL] run ( f"{ docker_compose_exe ( ) } [string] " ) [EOL] shutil . rmtree ( [string] , ignore_errors = True ) [EOL] run ( [string] ) [EOL] shutil . rmtree ( [string] , ignore_errors = True ) [EOL] shutil . rmtree ( [string] , ignore_errors = True ) [EOL] shutil . rmtree ( [string] , ignore_errors = True ) [EOL] [EOL] [EOL] @ task def deploy_staging ( ) : [EOL] [docstring] [EOL] run ( [string] ) [EOL] run ( [string] ) [EOL] with powershell ( ) as _run : [EOL] time . sleep ( [number] ) [EOL] builds_filter = [string] . strip ( ) . replace ( [string] , [string] ) [EOL] process = _run ( f" [string] { quote ( builds_filter ) } [string] " , capture_output = True , text = True , ) [EOL] build = process . stdout . split ( [string] ) [ [number] ] . split ( [string] ) [ [number] ] [EOL] _run ( f" [string] { quote ( build ) }" ) [EOL] run ( f""" [string] { kubectl_exe ( ) } [string] """ ) [EOL] [EOL] [EOL] @ task def deploy_production ( ) : [EOL] [docstring] [EOL] run ( [string] ) [EOL] run ( [string] ) [EOL] with powershell ( ) as _run : [EOL] time . sleep ( [number] ) [EOL] builds_filter = [string] . strip ( ) . replace ( [string] , [string] ) [EOL] process = _run ( f" [string] { quote ( builds_filter ) } [string] " , capture_output = True , text = True , ) [EOL] build = process . stdout . split ( [string] ) [ [number] ] . split ( [string] ) [ [number] ] [EOL] _run ( f" [string] { quote ( build ) }" ) [EOL] run ( f""" [string] { kubectl_exe ( ) } [string] """ ) [EOL] [EOL] [EOL] @ task def format ( ) : [EOL] [docstring] [EOL] run ( [string] ) [EOL] with docker ( ) as _run : [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] . format ( quote ( [string] ) ) ) [EOL] [EOL] [EOL] @ task def resync ( ) : [EOL] [docstring] [EOL] if within_docker ( ) : [EOL] return [EOL] run ( f"{ docker_compose_exe ( ) } [string] " ) [EOL] run ( [string] ) [EOL] run ( f"{ docker_compose_exe ( ) } [string] " ) [EOL] run ( f"{ docker_compose_exe ( ) } [string] " ) [EOL] [EOL] [EOL] @ task def sh ( ) : [EOL] [docstring] [EOL] with docker ( ) as _run : [EOL] _run ( [string] ) [EOL] [EOL] [EOL] @ task def start ( ) : [EOL] [docstring] [EOL] run ( f"{ docker_compose_exe ( ) } [string] " ) [EOL] [EOL] [EOL] @ task def test ( ) : [EOL] [docstring] [EOL] if not within_docker ( ) : [EOL] for env in [ [string] , [string] ] : [EOL] run ( fr""" [string] { docker_exe ( ) } [string] { cwd_for_docker_volume ( ) } [string] { env } [string] """ ) [EOL] with docker ( ) as _run : [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] [EOL] [EOL] @ task def upgrade ( ) : [EOL] [docstring] [EOL] with docker ( ) as _run : [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] _run ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) == [number] or sys . argv [ [number] ] == [string] : [EOL] for task_name , describe in tasks . items ( ) : [EOL] print ( f"{ task_name . ljust ( [number] ) } [string] { describe }" ) [EOL] exit ( [number] ) [EOL] for task_name in sys . argv [ [number] : ] : [EOL] locals ( ) [ task_name ] ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] from web_main import app [EOL] import unittest [EOL] import urllib [EOL] [EOL] [EOL] class TestMain ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . app = app . test_client ( ) [EOL] [EOL] def test_heartbeat ( self ) : [EOL] [docstring] [EOL] response = self . app . get ( [string] ) [EOL] self . assertEqual ( [number] , response . status_code ) [EOL] self . assertEqual ( [string] , response . data ) [EOL] [EOL] def test_index ( self ) : [EOL] [docstring] [EOL] response = self . app . get ( [string] ) [EOL] self . assertEqual ( [number] , response . status_code ) [EOL] self . assertIn ( [string] , response . data ) [EOL] [EOL] def test_datetimes ( self ) : [EOL] [docstring] [EOL] params = { [string] : [string] , [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , } [EOL] response = self . app . get ( f" [string] { urllib . parse . quote ( json . dumps ( params ) ) }" ) [EOL] self . assertEqual ( [number] , response . status_code ) [EOL] self . assertTrue ( json . loads ( response . get_data ( as_text = True ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.int],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from imperial_calendar . ImperialYearMonth import ImperialYearMonth [EOL] import unittest [EOL] [EOL] [EOL] class TestImperialYearMonth ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_days ( self ) : [EOL] [docstring] [EOL] for expected , month in [ [ [number] , ImperialYearMonth ( [number] , [number] ) ] , [ [number] , ImperialYearMonth ( [number] , [number] ) ] , ] : [EOL] with self . subTest ( month = month ) : [EOL] self . assertEqual ( expected , month . days ( ) ) [EOL] [EOL] def test_next_month ( self ) : [EOL] [docstring] [EOL] for expected , month in [ [ ImperialYearMonth ( [number] , [number] ) , ImperialYearMonth ( [number] , [number] ) ] , [ ImperialYearMonth ( [number] , [number] ) , ImperialYearMonth ( [number] , [number] ) ] , ] : [EOL] with self . subTest ( month = month ) : [EOL] self . assertEqual ( expected , month . next_month ( ) ) [EOL] [EOL] def test_prev_month ( self ) : [EOL] [docstring] [EOL] for expected , month in [ [ ImperialYearMonth ( [number] , [number] ) , ImperialYearMonth ( [number] , [number] ) ] , [ ImperialYearMonth ( [number] , [number] ) , ImperialYearMonth ( [number] , [number] ) ] , ] : [EOL] with self . subTest ( month = month ) : [EOL] self . assertEqual ( expected , month . prev_month ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import imperial_calendar [EOL] [docstring] [EOL] from imperial_calendar . GregorianDateTime import GregorianDateTime [EOL] import unittest [EOL] [EOL] [EOL] class TestGregorianDateTime ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_from_utc_naive ( self ) : [EOL] [docstring] [EOL] for ( naive_grdt , grdt ) in [ ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) , ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) , ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) , ] : [EOL] with self . subTest ( grdt = grdt ) : [EOL] self . assertEqual ( grdt , GregorianDateTime . from_utc_naive ( naive_grdt , grdt . timezone ) ) [EOL] for ( second , timezone ) in [ ( second , timezone ) for second in range ( [number] , [number] ) for timezone in [ [string] , [string] , [string] ] ] : [EOL] naive_grdt = GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , second , None ) [EOL] grdt = GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , second , timezone ) [EOL] with self . subTest ( grdt = grdt ) : [EOL] self . assertEqual ( grdt , GregorianDateTime . from_utc_naive ( naive_grdt , timezone ) ) [EOL] [EOL] def test_is_holiday ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . is_holiday ) [EOL] self . assertFalse ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . is_holiday ) [EOL] self . assertFalse ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . is_holiday ) [EOL] self . assertTrue ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . is_holiday ) [EOL] self . assertTrue ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . is_holiday ) [EOL] self . assertFalse ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . is_holiday ) [EOL] [EOL] def test_to_utc_naive ( self ) : [EOL] [docstring] [EOL] for ( naive_grdt , grdt ) in [ ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) , ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) , ( GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) , ] : [EOL] with self . subTest ( grdt = grdt ) : [EOL] self . assertEqual ( naive_grdt , grdt . to_utc_naive ( ) ) [EOL] for ( second , timezone ) in [ ( second , timezone ) for second in range ( [number] , [number] ) for timezone in [ [string] , [string] , [string] ] ] : [EOL] naive_grdt = GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , second , None ) [EOL] grdt = GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , second , timezone ) [EOL] with self . subTest ( grdt = grdt ) : [EOL] self . assertEqual ( naive_grdt , grdt . to_utc_naive ( ) ) [EOL] [EOL] def test_weekday ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . weekday ) [EOL] self . assertEqual ( [number] , GregorianDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . weekday ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 $imperial_calendar.GregorianDateTime.GregorianDateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from imperial_calendar . ImperialDateTime import ImperialDateTime [EOL] from imperial_calendar . internal . HolidayMars import HolidayMars [EOL] import math [EOL] import unittest [EOL] [EOL] [EOL] class TestImperialDateTime ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_eq ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) [EOL] self . assertNotEqual ( ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) [EOL] [EOL] def test_lt ( self ) : [EOL] [docstring] [EOL] lhs , rhs = ( ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ) [EOL] with self . subTest ( lhs = lhs , rhs = rhs ) : [EOL] self . assertFalse ( lhs < rhs ) [EOL] for lhs , rhs in [ [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , ] : [EOL] with self . subTest ( lhs = lhs , rhs = rhs ) : [EOL] self . assertTrue ( lhs < rhs ) [EOL] for lhs , rhs in [ [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , [ ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ] , ] : [EOL] with self . subTest ( lhs = lhs , rhs = rhs ) : [EOL] self . assertFalse ( lhs < rhs ) [EOL] lhs , rhs = ( ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) [EOL] with self . subTest ( lhs = lhs , rhs = rhs ) : [EOL] self . assertFalse ( lhs < rhs ) [EOL] lhs , rhs = ( ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) , ) [EOL] with self . subTest ( lhs = lhs , rhs = rhs ) : [EOL] self . assertTrue ( lhs < rhs ) [EOL] [EOL] def test_from_standard_naive ( self ) : [EOL] [docstring] [EOL] for ( hour , minute ) in [ ( hour , minute ) for hour in range ( [number] , [number] ) for minute in [ [number] , [number] , [number] , [number] ] ] : [EOL] timezone = [string] . format ( hour , minute ) [EOL] with self . subTest ( timezone = timezone ) : [EOL] self . assertEqual ( ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , timezone ) , ImperialDateTime . from_standard_naive ( ImperialDateTime ( [number] , [number] , [number] , hour , minute , [number] , None ) , timezone ) , ) [EOL] timezone = [string] . format ( hour , minute ) [EOL] with self . subTest ( timezone = timezone ) : [EOL] self . assertEqual ( ImperialDateTime ( [number] , [number] , [number] , hour , minute , [number] , timezone ) , ImperialDateTime . from_standard_naive ( ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , timezone ) , ) [EOL] [EOL] def test_holiday ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( HolidayMars ( [number] , [number] , [number] ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . holiday , ) [EOL] self . assertIsNone ( ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . holiday ) [EOL] [EOL] def test_japanese_month_name ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [string] , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . japanese_month_name ) [EOL] self . assertEqual ( [string] , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , [string] ) . japanese_month_name ) [EOL] [EOL] def test_offset ( self ) : [EOL] [docstring] [EOL] for ( expected , timezone ) in [ ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( - [number] , [string] ) , ( - [number] , [string] ) , ] : [EOL] with self . subTest ( timezone = timezone ) : [EOL] self . assertTrue ( math . isclose ( expected , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , timezone ) . offset , abs_tol = [number] , ) ) [EOL] for timezone in [ [string] ] : [EOL] with self . subTest ( timezone = timezone ) , self . assertRaises ( Exception ) : [EOL] ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , timezone ) . offset [EOL] [EOL] def test_to_standard_naive ( self ) : [EOL] [docstring] [EOL] for ( hour , minute ) in [ ( hour , minute ) for hour in range ( [number] , [number] ) for minute in [ [number] , [number] , [number] , [number] ] ] : [EOL] timezone = [string] . format ( hour , minute ) [EOL] with self . subTest ( timezone = timezone ) : [EOL] self . assertEqual ( ImperialDateTime ( [number] , [number] , [number] , hour , minute , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , timezone ) . to_standard_naive ( ) , ) [EOL] timezone = [string] . format ( hour , minute ) [EOL] with self . subTest ( timezone = timezone ) : [EOL] self . assertEqual ( ImperialDateTime ( [number] , [number] , [number] , [number] , [number] , [number] , None ) , ImperialDateTime ( [number] , [number] , [number] , hour , minute , [number] , timezone ) . to_standard_naive ( ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from imperial_calendar . internal . ImperialMonth import ImperialMonth [EOL] import unittest [EOL] [EOL] [EOL] class TestImperialMonth ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_days ( self ) : [EOL] [docstring] [EOL] for ( month , days ) in [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] : [EOL] self . assertEqual ( days , ImperialMonth ( month ) . days ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from imperial_calendar . internal . ImperialYear import ImperialYear [EOL] import unittest [EOL] [EOL] [EOL] class TestImperialYear ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_is_leap_year ( self ) : [EOL] [docstring] [EOL] for year in [ [number] , [number] ] : [EOL] self . assertTrue ( ImperialYear ( year ) . is_leap_year ( ) ) [EOL] for year in [ [number] , [number] , [number] ] : [EOL] self . assertFalse ( ImperialYear ( year ) . is_leap_year ( ) ) [EOL] [EOL] def test_days ( self ) : [EOL] [docstring] [EOL] for ( year , days ) in [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] : [EOL] self . assertEqual ( days , ImperialYear ( year ) . days ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from imperial_calendar . internal . HolidayMars import HolidayMars , Holidays , Internal [EOL] import unittest [EOL] [EOL] [EOL] class TestHolidayMars ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def tearDownClass ( cls ) : [EOL] [docstring] [EOL] Holidays . tearDownForTest ( ) [EOL] [EOL] def test_between ( self ) : [EOL] [docstring] [EOL] Holidays . setUpForTest ( { [number] : { [number] : { [number] : Internal ( name = [string] ) , [number] : Internal ( name = [string] ) , [number] : Internal ( name = [string] ) , } } } ) [EOL] for expected , start , end in [ [ [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) , ] , HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) , ] , [ [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) ] , HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) , ] , [ [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) ] , HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) , ] , ] : [EOL] with self . subTest ( start = start , end = end ) : [EOL] self . assertEqual ( expected , HolidayMars . between ( start , end ) ) [EOL] Holidays . setUpForTest ( { [number] : { [number] : { [number] : Internal ( name = [string] ) } , [number] : { [number] : Internal ( name = [string] ) } } } ) [EOL] expected , start , end = ( [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) ] , HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) , ) [EOL] with self . subTest ( start = start , end = end ) : [EOL] self . assertEqual ( expected , HolidayMars . between ( start , end ) ) [EOL] Holidays . setUpForTest ( { [number] : { [number] : { [number] : Internal ( name = [string] ) } } , [number] : { [number] : { [number] : Internal ( name = [string] ) } } } ) [EOL] expected , start , end = ( [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) ] , HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) , ) [EOL] with self . subTest ( start = start , end = end ) : [EOL] self . assertEqual ( expected , HolidayMars . between ( start , end ) ) [EOL] [EOL] def test_is_holiday ( self ) : [EOL] [docstring] [EOL] Holidays . setUpForTest ( { [number] : { [number] : { [number] : Internal ( name = [string] ) } } } ) [EOL] self . assertTrue ( HolidayMars ( [number] , [number] , [number] ) . is_holiday ) [EOL] self . assertFalse ( HolidayMars ( [number] , [number] , [number] ) . is_holiday ) [EOL] Holidays . setUpForTest ( { [number] : { [number] : { [number] : [ Internal ( name = [string] ) , Internal ( name = [string] ) ] } } } ) [EOL] self . assertFalse ( HolidayMars ( [number] , [number] , [number] ) . is_holiday ) [EOL] self . assertTrue ( HolidayMars ( [number] , [number] , [number] ) . is_holiday ) [EOL] [EOL] def test_lt ( self ) : [EOL] [docstring] [EOL] lhs , rhs = HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) [EOL] with self . subTest ( lhs = lhs , rhs = rhs ) : [EOL] self . assertFalse ( lhs < rhs ) [EOL] for lhs , rhs in [ [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) ] , [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) ] , [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) ] , ] : [EOL] with self . subTest ( lhs = lhs , rhs = rhs ) : [EOL] self . assertTrue ( lhs < rhs ) [EOL] for lhs , rhs in [ [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) ] , [ HolidayMars ( [number] , [number] , [number] ) , HolidayMars ( [number] , [number] , [number] ) ] , ] : [EOL] with self . subTest ( lhs = lhs , rhs = rhs ) : [EOL] self . assertFalse ( lhs < rhs ) [EOL] [EOL] def test_names ( self ) : [EOL] [docstring] [EOL] Holidays . setUpForTest ( { [number] : { [number] : { [number] : Internal ( name = [string] ) } } } ) [EOL] self . assertEqual ( [ [string] ] , HolidayMars ( [number] , [number] , [number] ) . names ) [EOL] Holidays . setUpForTest ( { [number] : { [number] : { [number] : [ Internal ( name = [string] ) , Internal ( name = [string] ) ] } } } ) [EOL] self . assertEqual ( [ [string] , [string] ] , HolidayMars ( [number] , [number] , [number] ) . names ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import typing as t [EOL] [EOL] __pragma__ = [number] [comment] [EOL] React = [number] [comment] [EOL] ReactRouterDOM = [number] [comment] [EOL] [EOL] __pragma__ ( [string] , [string] , [string] , ) [EOL] [EOL] [EOL] def GlobalNavigation ( props ) : [EOL] [docstring] [EOL] [ is_active , set_is_active ] = React . useState ( False ) [EOL] return React . createElement ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] } , React . createElement ( [string] , { [string] : [string] } , React . createElement ( [string] , { [string] : [string] } , React . createElement ( [string] , { [string] : [string] , [string] : [string] } ) , ) , React . createElement ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] . format ( [string] if is_active else [string] ) , [string] : lambda event : set_is_active ( not is_active ) , [string] : [string] , } , React . createElement ( [string] , { [string] : [string] } , [string] ) , React . createElement ( [string] , { [string] : [string] } , [string] ) , React . createElement ( [string] , { [string] : [string] } , [string] ) , ) , ) , React . createElement ( [string] , { [string] : [string] . format ( [string] if is_active else [string] ) } , React . createElement ( [string] , { [string] : [string] } , React . createElement ( ReactRouterDOM . NavLink , { [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , } , [string] , ) , React . createElement ( ReactRouterDOM . NavLink , { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] , ) , React . createElement ( ReactRouterDOM . NavLink , { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] , ) , ) , React . createElement ( [string] , { [string] : [string] } , React . createElement ( [string] , { [string] : [string] , [string] : [string] , [string] : [string] , } , React . createElement ( [string] , { [string] : [string] , [string] : [string] , } , ) , ) , ) , ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import typing as t [EOL] [EOL] __pragma__ = [number] [comment] [EOL] console = [number] [comment] [EOL] createReactClass = [number] [comment] [EOL] React = [number] [comment] [EOL] [EOL] __pragma__ ( [string] , [string] , [string] , ) [EOL] [EOL] [EOL] def renderErrorBoundary ( ) : [EOL] [docstring] [EOL] this = [number] [comment] [EOL] if this . state . has_error : [EOL] return React . createElement ( [string] , { [string] : [string] } , [string] ) [EOL] return this . props . children [EOL] [EOL] [EOL] ErrorBoundary = createReactClass ( { [string] : lambda error , errorInfo : console . error ( error , errorInfo ) , [string] : [string] , [string] : lambda : { [string] : False } , [string] : renderErrorBoundary , [string] : { [string] : lambda error : { [string] : True } } , } ) [EOL] [EOL] [EOL] def supervise ( * children ) : [EOL] [docstring] [EOL] return React . createElement ( ErrorBoundary , { } , * children ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0