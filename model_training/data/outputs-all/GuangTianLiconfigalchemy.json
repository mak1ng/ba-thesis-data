from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from setuptools import setup , find_packages [EOL] [EOL] with open ( [string] , encoding = [string] ) as readme_file : [EOL] readme = readme_file . read ( ) [EOL] [EOL] with open ( [string] , encoding = [string] ) as history_file : [EOL] history = history_file . read ( ) [EOL] [EOL] requirements = [ ] [EOL] [EOL] setup_requirements = [ ] [EOL] [EOL] test_requirements = [ [string] ] [EOL] [EOL] [EOL] setup ( author = [string] , author_email = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , ] , description = [string] , install_requires = requirements , long_description = readme + [string] + history , include_package_data = True , keywords = [string] , name = [string] , packages = find_packages ( include = [ [string] ] ) , setup_requires = setup_requirements , test_suite = [string] , tests_require = test_requirements , url = [string] , python_requires = [string] , version = [string] , zip_safe = False , extras_require = { [string] : [ [string] ] , [string] : test_requirements } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0
[docstring] [EOL]	0 0
import tests [EOL] import unittest [EOL] [EOL] from configalchemy import get_current_config , BaseConfig [EOL] [EOL] [EOL] class GlobalAPITestCase ( unittest . TestCase ) : [EOL] def test_get_current_config ( self ) : [EOL] class DefaultConfig ( BaseConfig ) : [EOL] TEST = [string] [EOL] [EOL] with self . assertRaises ( RuntimeError ) : [EOL] get_current_config ( DefaultConfig ) [EOL] [EOL] with self . assertRaises ( RuntimeError ) : [EOL] DefaultConfig ( ) [EOL] get_current_config ( DefaultConfig ) [EOL] config = DefaultConfig ( ) [EOL] config . TEST = [string] [EOL] current_config = get_current_config ( DefaultConfig ) [EOL] self . assertEqual ( [string] , current_config . TEST ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_global.GlobalAPITestCase.test_get_current_config.DefaultConfig$ 0 0 0 0 0 $tests.test_global.GlobalAPITestCase.test_get_current_config.DefaultConfig$ 0 $builtins.str$ 0 0 0 $tests.test_global.GlobalAPITestCase.test_get_current_config.DefaultConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_global.GlobalAPITestCase.test_get_current_config.DefaultConfig$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import unittest [EOL] import tests [EOL] import typing [EOL] import copy [EOL] import time [EOL] import unittest [EOL] from concurrent . futures . thread import ThreadPoolExecutor [EOL] from unittest . mock import MagicMock [EOL] [EOL] from configalchemy . lazy import lazy , proxy , reset_lazy [EOL] [EOL] [EOL] class LazyTestCase ( unittest . TestCase ) : [EOL] def test_lazy_load ( self ) : [EOL] data = { } [EOL] lazy_data = lazy ( lambda : data ) [EOL] lazy_data [ [string] ] = [number] [EOL] self . assertEqual ( dir ( data ) , dir ( lazy_data ) ) [EOL] self . assertEqual ( repr ( data ) , repr ( lazy_data ) ) [EOL] self . assertEqual ( repr ( data ) , repr ( lazy_data ) ) [EOL] self . assertEqual ( bool ( data ) , bool ( lazy_data ) ) [EOL] del lazy_data [ [string] ] [EOL] self . assertNotIn ( [string] , lazy_data ) [EOL] with self . assertRaises ( AttributeError ) : [EOL] lazy_data . attr [EOL] [EOL] def test_lazy_load_load_once ( self ) : [EOL] call_mock = MagicMock ( ) [EOL] [EOL] def get ( ) : [EOL] time . sleep ( [number] ) [EOL] call_mock ( ) [EOL] return [number] [EOL] [EOL] number = lazy ( get ) [EOL] [EOL] def task ( num ) : [EOL] self . assertEqual ( num + [number] , number + num ) [EOL] [EOL] with ThreadPoolExecutor ( max_workers = [number] ) as worker : [EOL] for _ in worker . map ( task , range ( [number] ) ) : [EOL] _ [EOL] [EOL] self . assertEqual ( [number] , call_mock . call_count ) [EOL] object . __setattr__ ( number , [string] , None ) [EOL] [EOL] def test_reset_lazy ( self ) : [EOL] call_mock = MagicMock ( ) [EOL] [EOL] def get ( ) : [EOL] call_mock ( ) [EOL] return [number] [EOL] [EOL] number = lazy ( get ) [EOL] [EOL] self . assertEqual ( [number] + [number] , number + [number] ) [EOL] self . assertEqual ( [number] , call_mock . call_count ) [EOL] reset_lazy ( number ) [EOL] self . assertEqual ( [number] + [number] , number + [number] ) [EOL] self . assertEqual ( [number] , call_mock . call_count ) [EOL] [EOL] def test_lazy_load_operations_math ( self ) : [EOL] call_mock = MagicMock ( ) [EOL] [EOL] def get ( ) : [EOL] call_mock ( ) [EOL] return [number] [EOL] [EOL] number = lazy ( get ) [EOL] [EOL] self . assertEqual ( [number] , number ) [EOL] self . assertNotEqual ( [number] , number ) [EOL] [EOL] self . assertEqual ( [number] , number + [number] ) [EOL] self . assertEqual ( [number] , [number] + number ) [EOL] [EOL] self . assertEqual ( - [number] , [number] - number ) [EOL] self . assertEqual ( [number] , number - [number] ) [EOL] [EOL] self . assertEqual ( [number] , number * [number] ) [EOL] self . assertEqual ( [number] , [number] * number ) [EOL] [EOL] self . assertEqual ( [number] , number / [number] ) [EOL] self . assertEqual ( [number] , [number] / number ) [EOL] [EOL] self . assertEqual ( [number] , number // [number] ) [EOL] self . assertEqual ( [number] , [number] // number ) [EOL] [EOL] self . assertEqual ( [number] , number % [number] ) [EOL] self . assertEqual ( [number] , [number] % number ) [EOL] [EOL] def test_lazy_load_copy ( self ) : [EOL] class Foo : [EOL] def __copy__ ( self ) : [EOL] return self [EOL] [EOL] def __deepcopy__ ( self , memo ) : [EOL] return self [EOL] [EOL] foo = Foo ( ) [EOL] lazy_foo = lazy ( lambda : foo ) [EOL] foo . a = [number] [EOL] self . assertEqual ( foo . __dict__ , lazy_foo . __dict__ ) [EOL] self . assertIs ( foo , copy . copy ( lazy_foo ) ) [EOL] self . assertIs ( foo , copy . deepcopy ( lazy_foo ) ) [EOL] [EOL] def test_proxy_operations_math ( self ) : [EOL] call_mock = MagicMock ( ) [EOL] [EOL] def get ( ) : [EOL] call_mock ( ) [EOL] return [number] [EOL] [EOL] number = proxy ( get ) [EOL] [EOL] self . assertEqual ( [number] , number ) [EOL] self . assertNotEqual ( [number] , number ) [EOL] [EOL] self . assertEqual ( [number] , number + [number] ) [EOL] self . assertEqual ( [number] , [number] + number ) [EOL] [EOL] self . assertEqual ( - [number] , [number] - number ) [EOL] self . assertEqual ( [number] , number - [number] ) [EOL] [EOL] self . assertEqual ( [number] , number * [number] ) [EOL] self . assertEqual ( [number] , [number] * number ) [EOL] [EOL] self . assertEqual ( [number] , number / [number] ) [EOL] self . assertEqual ( [number] , [number] / number ) [EOL] [EOL] self . assertEqual ( [number] , number // [number] ) [EOL] self . assertEqual ( [number] , [number] // number ) [EOL] [EOL] self . assertEqual ( [number] , number % [number] ) [EOL] self . assertEqual ( [number] , [number] % number ) [EOL] [EOL] self . assertEqual ( [number] , call_mock . call_count ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 0 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 0 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 0 0 0 0 0 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 0 0 0 0 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 0 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 0 0 0 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 0 0 0 $tests.test_lazy.LazyTestCase.test_lazy_load_copy.Foo$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , List [EOL] import builtins [EOL] import tests [EOL] import unittest [EOL] import configalchemy [EOL] import typing [EOL] import json [EOL] import unittest [EOL] from typing import Optional , List , Any [EOL] from unittest . mock import Mock [EOL] [EOL] from configalchemy . field import Field , ValidateException [EOL] from configalchemy . types import Json [EOL] from configalchemy import BaseConfig [EOL] [EOL] [EOL] class FieldTestCase ( unittest . TestCase ) : [EOL] def test_validate ( self ) : [EOL] int_field = Field ( name = [string] , default_value = [number] , annotation = None ) [EOL] for value in [ [string] , [string] ] : [EOL] self . assertEqual ( [number] , int_field . validate ( value ) ) [EOL] with self . assertRaises ( ValidateException ) as e : [EOL] int_field . validate ( [string] ) [EOL] self . assertIn ( [string] , str ( e . exception ) ) [EOL] self . assertIn ( str ( type ( [string] ) ) , str ( e . exception ) ) [EOL] self . assertEqual ( [string] , e . exception . name ) [EOL] self . assertEqual ( [string] , e . exception . value ) [EOL] [EOL] def test_bool_validate ( self ) : [EOL] bool_field = Field ( name = [string] , default_value = False , annotation = None ) [EOL] for value in [ [string] , [string] , [string] , [string] , [number] ] : [EOL] self . assertTrue ( bool_field . validate ( value ) ) [EOL] for value in [ [string] , [string] , [string] , [string] , [number] ] : [EOL] self . assertFalse ( bool_field . validate ( value ) ) [EOL] self . assertTrue ( bool_field . validate ( True ) ) [EOL] self . assertFalse ( bool_field . validate ( False ) ) [EOL] [EOL] def test_union_type ( self ) : [EOL] optional_field = Field ( name = [string] , default_value = None , annotation = Optional [ int ] ) [EOL] self . assertEqual ( [number] , optional_field . validate ( [number] ) ) [EOL] self . assertEqual ( [number] , optional_field . validate ( [string] ) ) [EOL] [EOL] def test_json_type ( self ) : [EOL] value_type = Json [ list ] [EOL] self . assertIs ( value_type , Json [ list ] ) [EOL] default_value = [ ] [EOL] json_field = Field ( name = [string] , default_value = default_value , annotation = value_type ) [EOL] self . assertEqual ( [ [number] ] , json_field . validate ( [ [number] ] ) ) [EOL] self . assertEqual ( [ [number] ] , json_field . validate ( json . dumps ( [ [number] ] ) ) ) [EOL] [EOL] default_value = [ [number] , [number] ] [EOL] json_field = Field ( name = [string] , default_value = default_value , annotation = Json [ List [ int ] ] ) [EOL] self . assertEqual ( [ [number] ] , json_field . validate ( json . dumps ( [ [number] ] ) ) ) [EOL] [EOL] def test_generic_field ( unittest_self ) : [EOL] class MyType : [EOL] ... [EOL] [EOL] my_type = MyType ( ) [EOL] generic_field = Field ( name = [string] , default_value = my_type , annotation = None ) [EOL] unittest_self . assertEqual ( my_type , generic_field . validate ( my_type ) ) [EOL] with unittest_self . assertRaises ( ValidateException ) : [EOL] generic_field . validate ( [string] ) [EOL] [EOL] value = [ [string] , [string] ] [EOL] typecast = Mock ( return_value = value ) [EOL] [EOL] class TestGenericConfigMixin : [EOL] @ classmethod def __type_check__ ( cls , instance ) : [EOL] return isinstance ( instance , list ) [EOL] [EOL] @ classmethod def __typecast__ ( cls , value ) : [EOL] return typecast ( value ) [EOL] [EOL] generic_config = TestGenericConfigMixin ( ) [EOL] generic_field = Field ( name = [string] , default_value = generic_config , annotation = None ) [EOL] unittest_self . assertEqual ( value , generic_field . validate ( value ) ) [EOL] unittest_self . assertFalse ( typecast . called ) [EOL] unittest_self . assertEqual ( value , generic_field . validate ( [string] ) ) [EOL] typecast . assert_called_with ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.list]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.list]$ 0 0 0 0 0 0 0 $configalchemy.types.Json[typing.List[builtins.int]]$ 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 $configalchemy.types.Json[typing.List[builtins.int]]$ 0 $configalchemy.types.Json[typing.List[builtins.int]]$ 0 0 0 $typing.Type[builtins.list]$ 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.types.Json[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 $configalchemy.types.Json[typing.List[builtins.int]]$ 0 $configalchemy.types.Json[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.test_field.FieldTestCase.test_generic_field.MyType$ 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 $tests.test_field.FieldTestCase.test_generic_field.MyType$ 0 0 0 0 0 0 0 0 0 0 $tests.test_field.FieldTestCase.test_generic_field.MyType$ 0 $configalchemy.field.Field$ 0 0 0 $tests.test_field.FieldTestCase.test_generic_field.MyType$ 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $tests.test_field.FieldTestCase.test_generic_field.TestGenericConfigMixin$ 0 0 0 0 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 0 0 $tests.test_field.FieldTestCase.test_generic_field.TestGenericConfigMixin$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $configalchemy.field.Field$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $configalchemy.field.Field$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import unittest [EOL] [EOL] from configalchemy import BaseConfig [EOL] from configalchemy . utils import import_reference , find_caller [EOL] [EOL] [EOL] class UtilsTestCase ( unittest . TestCase ) : [EOL] def test_import_reference ( self ) : [EOL] self . assertEqual ( id ( BaseConfig ) , id ( import_reference ( [string] ) ) , ) [EOL] [EOL] def test_find_caller ( self ) : [EOL] stack_info = find_caller ( ) [EOL] stack_str = [string] [EOL] self . assertEqual ( stack_str , stack_info [ - len ( stack_str ) : ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import configalchemy [EOL] import typing [EOL] import json [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from configalchemy . meta import ConfigMeta , ConfigMetaJSONEncoder [EOL] [EOL] [EOL] class MetaTestCase ( unittest . TestCase ) : [EOL] def test_usage ( self ) : [EOL] default_value = [number] [EOL] int_field = Mock ( ) [EOL] config_meta = ConfigMeta ( default_value = default_value , field = int_field ) [EOL] with config_meta : [EOL] priority = [number] [EOL] int_field . validate = Mock ( return_value = priority ) [EOL] config_meta . set ( priority , [number] ) [EOL] self . assertEqual ( [number] , config_meta . value ) [EOL] priority = [number] [EOL] int_field . validate = Mock ( return_value = priority ) [EOL] config_meta . set ( priority , [number] ) [EOL] self . assertEqual ( priority , config_meta . value ) [EOL] priority = [number] [EOL] int_field . validate = Mock ( return_value = priority ) [EOL] config_meta . set ( priority , [number] ) [EOL] self . assertEqual ( [number] , config_meta . value ) [EOL] [EOL] self . assertEqual ( [number] , config_meta . items [ [number] ] . priority ) [EOL] self . assertEqual ( [number] , config_meta . items [ [number] ] . value ) [EOL] self . assertEqual ( [number] , config_meta . items [ [number] ] . priority ) [EOL] self . assertEqual ( [number] , config_meta . items [ [number] ] . value ) [EOL] self . assertEqual ( [number] , config_meta . items [ [number] ] . priority ) [EOL] self . assertEqual ( [number] , config_meta . items [ [number] ] . value ) [EOL] self . assertEqual ( [number] , config_meta . items [ [number] ] . priority ) [EOL] self . assertEqual ( [number] , config_meta . items [ [number] ] . value ) [EOL] [EOL] def test_json_encode ( self ) : [EOL] default_value = [number] [EOL] int_field = Mock ( ) [EOL] config_meta = ConfigMeta ( default_value = default_value , field = int_field ) [EOL] self . assertEqual ( json . dumps ( { [string] : default_value } ) , json . dumps ( { [string] : config_meta } , cls = ConfigMetaJSONEncoder ) , ) [EOL] self . assertEqual ( [string] , str ( config_meta ) ) [EOL] self . assertEqual ( [string] , repr ( config_meta ) ) [EOL] self . assertEqual ( [string] , str ( config_meta . items ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $unittest.mock.Mock$ 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 $builtins.int$ 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , Any [EOL] import builtins [EOL] import typing [EOL] import threading [EOL] import time [EOL] import unittest [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import requests [EOL] [EOL] from configalchemy . contrib . apollo import ApolloBaseConfig , ConfigException , logger [EOL] [EOL] [EOL] class ApolloConfigTestCase ( unittest . TestCase ) : [EOL] @ patch . object ( requests , [string] ) @ patch . object ( ApolloBaseConfig , [string] ) def test_ApolloConfig ( self , start_long_poll , requests_get ) : [EOL] return_value = { [string] : [string] , [string] : { [string] : [string] } , } [EOL] [EOL] requests_get . side_effect = lambda * a , ** kw : Mock ( status_code = [number] , ok = True , json = Mock ( return_value = return_value ) ) [EOL] [EOL] class DefaultConfig ( ApolloBaseConfig ) : [EOL] TEST = [string] [EOL] [comment] [EOL] APOLLO_SERVER_URL = [string] [EOL] APOLLO_APP_ID = [string] [EOL] APOLLO_CLUSTER = [string] [EOL] APOLLO_NAMESPACE = [string] [EOL] [EOL] config = DefaultConfig ( ) [EOL] config . start_long_poll ( ) [EOL] self . assertEqual ( [string] , config [ [string] ] ) [EOL] self . assertEqual ( [number] , start_long_poll . call_count ) [EOL] [EOL] @ patch . object ( requests , [string] ) @ patch . object ( logger , [string] ) @ patch . object ( time , [string] ) def test_long_poll ( self , time_sleep , logging_debug , requests_get ) : [EOL] class DefaultConfig ( ApolloBaseConfig ) : [EOL] TEST = [string] [EOL] CONFIGALCHEMY_ENABLE_FUNCTION = True [EOL] [comment] [EOL] APOLLO_SERVER_URL = [string] [EOL] APOLLO_APP_ID = [string] [EOL] APOLLO_CLUSTER = [string] [EOL] APOLLO_NAMESPACE = [string] [EOL] APOLLO_EXTRA_NAMESPACE = [string] [EOL] [EOL] application_return_value = { [string] : [string] , [string] : { [string] : [string] } , } [EOL] [EOL] def mock_get ( url , ** kwargs ) : [EOL] if [string] in url : [EOL] return Mock ( status_code = [number] , ok = False , json = Mock ( return_value = [ { [string] : [string] , [string] : [number] } ] ) , ) [EOL] elif [string] in url : [EOL] return Mock ( status_code = [number] , ok = True , json = Mock ( return_value = { [string] : [string] , [string] : { [string] : [string] } , } ) , ) [EOL] else : [EOL] return Mock ( status_code = [number] , ok = True , json = Mock ( return_value = application_return_value ) , ) [EOL] [EOL] requests_get . side_effect = mock_get [EOL] config = DefaultConfig ( ) [EOL] self . assertEqual ( [string] , config . TEST ) [EOL] application_return_value [ [string] ] = { [string] : [string] } [EOL] [EOL] count = [number] [EOL] [EOL] def logging_debug_call ( * args , ** kwargs ) : [EOL] nonlocal count [EOL] if count == [number] : [EOL] count += [number] [EOL] return [number] [EOL] elif count == [number] : [EOL] count += [number] [EOL] return [number] [EOL] else : [EOL] raise ConfigException ( [string] ) [EOL] [EOL] logging_debug . side_effect = logging_debug_call [EOL] time_sleep . side_effect = ConfigException ( [string] ) [EOL] [EOL] with self . assertRaises ( ConfigException ) : [EOL] config . long_poll ( ) [EOL] [EOL] self . assertEqual ( [string] , config . TEST ) [EOL] self . assertIn ( [string] , config . apollo_notification_map ) [EOL] self . assertIn ( [string] , config . apollo_notification_map ) [EOL] [EOL] @ patch . object ( threading , [string] ) def test_start_long_poll ( self , thread_mock ) : [EOL] class DefaultConfig ( ApolloBaseConfig ) : [EOL] CONFIGALCHEMY_ENABLE_FUNCTION = False [EOL] [EOL] config = DefaultConfig ( ) [EOL] config . start_long_poll ( ) [EOL] thread_mock . assert_called_with ( target = config . long_poll ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Callable , Any [EOL] import builtins [EOL] import typing [EOL] from typing import Any , Union , Callable [EOL] [EOL] from configalchemy . types import DEFAULT_TYPE_CAST [EOL] [EOL] [EOL] class ValidateException ( Exception ) : [EOL] def __init__ ( self , name , value ) : [EOL] self . name = name [EOL] self . value = value [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"""{ self . name } [string] { self . value } [string] { type ( self . value ) } [string] """ [EOL] [EOL] def __str__ ( self ) : [EOL] return repr ( self ) [EOL] [EOL] [EOL] class Field : [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , * , name , annotation , default_value ) : [EOL] self . name = name [EOL] self . annotation = annotation [EOL] self . default_value = default_value [EOL] self . value_type = type ( default_value ) [EOL] self . type_check = self . _type_check [EOL] self . typecast = self . _typecast [EOL] [EOL] self . prepare ( ) [EOL] [EOL] if self . value_type in DEFAULT_TYPE_CAST : [EOL] self . type_check = DEFAULT_TYPE_CAST [ self . value_type ] . __type_check__ [EOL] self . typecast = DEFAULT_TYPE_CAST [ self . value_type ] . __typecast__ [EOL] [EOL] if getattr ( self . default_value , [string] , None ) : [EOL] self . type_check = self . default_value . __type_check__ [EOL] if getattr ( self . default_value , [string] , None ) : [EOL] self . typecast = self . default_value . __typecast__ [EOL] [EOL] if getattr ( self . annotation , [string] , None ) : [EOL] self . type_check = self . annotation . __type_check__ [EOL] if getattr ( self . annotation , [string] , None ) : [EOL] self . typecast = self . annotation . __typecast__ [EOL] [EOL] def prepare ( self ) : [EOL] origin = getattr ( self . annotation , [string] , None ) [EOL] if origin is None : [EOL] [comment] [EOL] return [EOL] if origin is Union : [EOL] self . value_type = self . annotation . __args__ [EOL] self . typecast = lambda x : self . value_type [ [number] ] ( x ) [EOL] return [EOL] [EOL] def validate ( self , value ) : [EOL] if self . type_check ( value ) : [EOL] return value [EOL] else : [EOL] try : [EOL] return self . typecast ( value ) [EOL] except Exception as e : [EOL] raise ValidateException ( self . name , value ) from e [EOL] [EOL] def _type_check ( self , value ) : [EOL] return isinstance ( value , self . value_type ) [EOL] [EOL] def _typecast ( self , value ) : [EOL] return self . value_type ( value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Callable[[typing.Any],builtins.bool]$ 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],builtins.bool]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],builtins.bool]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any],typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import MutableMapping , Optional , Any , KeysView , TypeVar , Tuple , Type , TextIO , Dict , List [EOL] import builtins [EOL] import configalchemy [EOL] import typing [EOL] import logging [EOL] import asyncio [EOL] import errno [EOL] import inspect [EOL] import json [EOL] import logging [EOL] import os [EOL] from typing import ( Any , KeysView , List , Tuple , MutableMapping , Dict , Optional , TypeVar , Type , TextIO , ) [EOL] from weakref import ref [EOL] from threading import Thread [EOL] from configalchemy . field import Field [EOL] from configalchemy . meta import ConfigMeta , ConfigMetaJSONEncoder [EOL] [EOL] ConfigType = MutableMapping [ str , Any ] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class BaseConfig ( ConfigType ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] CONFIGALCHEMY_ENV_PREFIX = [string] [EOL] CONFIGALCHEMY_ENVIRONMENT_VALUE_PRIORITY = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] CONFIGALCHEMY_ROOT_PATH = [string] [EOL] CONFIGALCHEMY_CONFIG_FILE = [string] [EOL] CONFIGALCHEMY_CONFIG_FILE_VALUE_PRIORITY = [number] [EOL] [comment] [EOL] CONFIGALCHEMY_LOAD_FILE_SILENT = False [EOL] [EOL] [comment] [EOL] CONFIGALCHEMY_ENABLE_FUNCTION = False [EOL] CONFIGALCHEMY_FUNCTION_VALUE_PRIORITY = [number] [EOL] [EOL] CONFIGALCHEMY_DEFAULT_VALUE_PRIORITY = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] CONFIGALCHEMY_SETITEM_PRIORITY = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] self . meta = { } [EOL] [EOL] self . _setup ( ) [EOL] [EOL] [comment] [EOL] if self . CONFIGALCHEMY_ENV_PREFIX : [EOL] self . _from_env ( ) [EOL] [EOL] [comment] [EOL] if self . CONFIGALCHEMY_CONFIG_FILE : [EOL] self . _from_file ( ) [EOL] [EOL] [comment] [EOL] if self . CONFIGALCHEMY_ENABLE_FUNCTION : [EOL] if inspect . iscoroutinefunction ( self . configuration_function ) : [EOL] [comment] [EOL] class TempThread ( Thread ) : [EOL] def run ( thread_self ) : [EOL] loop = asyncio . new_event_loop ( ) [EOL] loop . run_until_complete ( self . access_config_from_coroutine ( priority = self . CONFIGALCHEMY_FUNCTION_VALUE_PRIORITY ) ) [EOL] loop . close ( ) [EOL] [EOL] temp_thread = TempThread ( ) [EOL] temp_thread . start ( ) [EOL] temp_thread . join ( ) [EOL] else : [EOL] self . access_config_from_function ( priority = self . CONFIGALCHEMY_FUNCTION_VALUE_PRIORITY ) [EOL] [EOL] global _current_config_ref [EOL] _current_config_ref = ref ( self ) [EOL] [EOL] def _setup ( self ) : [EOL] [docstring] [EOL] for key in dir ( self ) : [EOL] if key . isupper ( ) and not isinstance ( getattr ( self . __class__ , key ) , property ) : [EOL] self . _set_value ( key , getattr ( self , key ) , priority = self . CONFIGALCHEMY_DEFAULT_VALUE_PRIORITY , ) [EOL] return True [EOL] [EOL] def _from_file ( self ) : [EOL] [docstring] [EOL] filename = os . path . join ( self . CONFIGALCHEMY_ROOT_PATH , self . CONFIGALCHEMY_CONFIG_FILE ) [EOL] try : [EOL] with open ( filename ) as f : [EOL] obj = self . load_file ( f ) [EOL] except IOError as e : [EOL] if self . CONFIGALCHEMY_LOAD_FILE_SILENT and e . errno in ( errno . ENOENT , errno . EISDIR , ) : [EOL] return False [EOL] e . strerror = f" [string] { e . strerror }" [EOL] raise [EOL] else : [EOL] logger . info ( f" [string] { filename }" ) [EOL] return self . from_mapping ( obj , priority = self . CONFIGALCHEMY_CONFIG_FILE_VALUE_PRIORITY ) [EOL] [EOL] def load_file ( self , file ) : [EOL] return json . load ( file ) [EOL] [EOL] def from_mapping ( self , * mappings , priority ) : [EOL] [docstring] [EOL] for mapping in mappings : [EOL] for key , value in mapping . items ( ) : [EOL] if key . isupper ( ) : [EOL] self . _set_value ( key , value , priority = priority ) [EOL] return True [EOL] [EOL] def _from_env ( self ) : [EOL] [docstring] [EOL] for key , value in self . items ( ) : [EOL] env_value = os . getenv ( f"{ self . CONFIGALCHEMY_ENV_PREFIX }{ key }" ) [EOL] if env_value is not None : [EOL] self . _set_value ( key , env_value , priority = self . CONFIGALCHEMY_ENVIRONMENT_VALUE_PRIORITY , ) [EOL] return True [EOL] [EOL] def configuration_function ( self ) : [EOL] return { } [EOL] [EOL] def access_config_from_function ( self , priority ) : [EOL] [docstring] [EOL] self . from_mapping ( self . configuration_function ( ) , priority = priority ) [EOL] return True [EOL] [EOL] async def access_config_from_coroutine ( self , priority ) : [EOL] [docstring] [EOL] self . from_mapping ( await self . configuration_function ( ) , priority = priority ) [comment] [EOL] return True [EOL] [EOL] def _set_value ( self , key , value , priority ) : [EOL] if key not in self . meta : [EOL] [docstring] [EOL] self . meta [ key ] = ConfigMeta ( default_value = value , field = Field ( name = key , default_value = value , annotation = getattr ( self , [string] , { } ) . get ( key ) , ) , priority = priority , ) [EOL] setattr ( self . __class__ , key , _ConfigAttribute ( key , value ) ) [EOL] else : [EOL] self . meta [ key ] . set ( priority = priority , value = value ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] [docstring] [EOL] return self . meta [ key ] . value [EOL] [EOL] def items ( self ) : [comment] [EOL] return [ ( key , config_meta . value ) for key , config_meta in self . meta . items ( ) ] [EOL] [EOL] def keys ( self ) : [EOL] return self . meta . keys ( ) [EOL] [EOL] def __contains__ ( self , key ) : [EOL] return key in self . meta [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . meta ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . meta ) [EOL] [EOL] def __setitem__ ( self , k , v ) : [EOL] self . _set_value ( k , v , priority = self . CONFIGALCHEMY_SETITEM_PRIORITY ) [EOL] [EOL] def __delitem__ ( self , key ) : [EOL] del self . meta [ key ] . items [ - [number] ] [EOL] [EOL] def update ( self , __m , ** kwargs ) : [EOL] self . from_mapping ( __m , kwargs , priority = self . CONFIGALCHEMY_SETITEM_PRIORITY ) [EOL] [EOL] def get ( self , key , default = None ) : [EOL] if key in self . meta : [EOL] return self . meta [ key ] . value [EOL] else : [EOL] return default [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( self . meta ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return repr ( self . meta ) [EOL] [EOL] def __str__ ( self ) : [EOL] return repr ( self ) [EOL] [EOL] def json ( self , skipkeys = False , ensure_ascii = True , check_circular = True , allow_nan = True , sort_keys = False , indent = None , separators = None , cls = ConfigMetaJSONEncoder , ) : [EOL] return json . dumps ( self . meta , cls = cls , skipkeys = skipkeys , ensure_ascii = ensure_ascii , check_circular = check_circular , allow_nan = allow_nan , indent = indent , separators = separators , sort_keys = sort_keys , ) [EOL] [EOL] [EOL] class _ConfigAttribute : [EOL] def __init__ ( self , name , default_value ) : [EOL] self . _name = name [EOL] self . _default_value = default_value [EOL] [EOL] def __get__ ( self , obj , type = None ) : [EOL] if obj is None : [EOL] return self . _default_value [EOL] if self . _name not in obj : [EOL] return self . _default_value [EOL] else : [EOL] return obj [ self . _name ] [EOL] [EOL] def __set__ ( self , instance , value ) : [EOL] instance [ self . _name ] = value [EOL] [EOL] [EOL] _current_config_ref = ref ( object ) [EOL] _CurrentConfigType = TypeVar ( [string] , bound = BaseConfig ) [EOL] [EOL] [EOL] def get_current_config ( config_type ) : [EOL] [comment] [EOL] current_config = _current_config_ref ( ) [EOL] if not isinstance ( current_config , config_type ) : [EOL] raise RuntimeError ( f" [string] { config_type }" ) [EOL] return current_config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ConfigType$ 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $ConfigType$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $ConfigType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ConfigType$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.KeysView[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 $typing.Type[configalchemy.meta.ConfigMetaJSONEncoder]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[configalchemy.meta.ConfigMetaJSONEncoder]$ 0 $typing.Type[configalchemy.meta.ConfigMetaJSONEncoder]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[typing.Tuple[builtins.str,builtins.str]]$ 0 $typing.Optional[typing.Tuple[builtins.str,builtins.str]]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $BaseConfig$ 0 0 0 0 0 0 0 0 $BaseConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BaseConfig$ 0 0 0 0 0 0 0 0 0 0 0 $BaseConfig$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $BaseConfig$ 0 $typing.Any$ 0 0 0 $BaseConfig$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import MutableMapping , Literal , Any , Union , Tuple , Type , List [EOL] import builtins [EOL] import typing_extensions [EOL] import configalchemy [EOL] import typing [EOL] import os [EOL] from json import JSONEncoder [EOL] from typing import Any , List , MutableMapping [EOL] [EOL] from configalchemy . field import Field [EOL] from configalchemy . utils import find_caller [EOL] [EOL] ConfigType = MutableMapping [ str , Any ] [EOL] [EOL] CONFIG_ALCHEMY_VERBOSITY = os . getenv ( [string] , [string] ) [EOL] [EOL] [EOL] class ConfigMetaItem : [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] if CONFIG_ALCHEMY_VERBOSITY : [EOL] [EOL] def __init__ ( self , priority , value ) : [EOL] self . priority = priority [EOL] self . value = value [EOL] try : [EOL] self . setter = find_caller ( ) [EOL] except ValueError : [EOL] self . setter = None [EOL] [EOL] else : [EOL] [EOL] def __init__ ( self , priority , value ) : [EOL] self . priority = priority [EOL] self . value = value [EOL] self . setter = None [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . priority } [string] { self . value } [string] " [EOL] [EOL] __str__ = __repr__ [EOL] [EOL] [EOL] class ConfigMeta : [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , default_value , field , priority = [number] ) : [EOL] self . field = field [EOL] self . items = [ ConfigMetaItem ( priority , default_value ) ] [EOL] [EOL] @ property def value ( self ) : [EOL] return self . items [ - [number] ] . value [EOL] [EOL] def set ( self , priority , value ) : [EOL] value = self . field . validate ( value ) [EOL] length = len ( self . items ) [EOL] item = ConfigMetaItem ( priority , value ) [EOL] for index in range ( length , [number] , - [number] ) : [EOL] if self . items [ index - [number] ] . priority <= priority : [EOL] self . items . insert ( index , item ) [EOL] break [EOL] else : [EOL] self . items . insert ( [number] , ConfigMetaItem ( priority , value ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return repr ( self . value ) [EOL] [EOL] __str__ = __repr__ [EOL] [EOL] def __enter__ ( self ) : [EOL] [docstring] [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] pass [EOL] [EOL] [EOL] class ConfigMetaJSONEncoder ( JSONEncoder ) : [EOL] def default ( self , o ) : [EOL] if isinstance ( o , ConfigMeta ) : [EOL] return o . value [EOL] return super ( ) . default ( o ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $configalchemy.field.Field$ 0 $builtins.int$ 0 0 0 0 0 0 0 $configalchemy.field.Field$ 0 $configalchemy.field.Field$ 0 0 0 $typing.List[ConfigMetaItem]$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMetaItem$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $configalchemy.meta.ConfigMetaItem$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from . configalchemy import BaseConfig , ConfigType , get_current_config [EOL] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Callable , Any , TypeVar , Tuple , Type [EOL] import configalchemy [EOL] import typing [EOL] import copy [EOL] from threading import Lock [EOL] from typing import TypeVar , Callable [EOL] [EOL] LazyLoadType = TypeVar ( [string] ) [EOL] [EOL] [EOL] class LazyObject : [EOL] __slots__ = ( [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , obj , args , kwargs ) : [EOL] object . __setattr__ ( self , [string] , obj ) [EOL] object . __setattr__ ( self , [string] , args ) [EOL] object . __setattr__ ( self , [string] , kwargs ) [EOL] object . __setattr__ ( self , [string] , None ) [EOL] object . __setattr__ ( self , [string] , Lock ( ) ) [EOL] [EOL] def __get_current_object__ ( self ) : [EOL] [comment] [EOL] if self . __attr__ is None : [EOL] with self . __lock__ : [EOL] if self . __attr__ is None : [EOL] object . __setattr__ ( self , [string] , self . __obj__ ( * self . __args__ , ** self . __kwargs__ ) , ) [EOL] else : [EOL] return self . __attr__ [EOL] return self . __attr__ [EOL] [EOL] def __getattr__ ( self , item ) : [EOL] return getattr ( self . __get_current_object__ ( ) , item ) [EOL] [EOL] @ property def __dict__ ( self ) : [EOL] try : [EOL] return self . __get_current_object__ ( ) . __dict__ [EOL] except RuntimeError : [EOL] raise AttributeError ( [string] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] obj = self . __get_current_object__ ( ) [EOL] return repr ( obj ) [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( self . __get_current_object__ ( ) ) [EOL] [EOL] def __dir__ ( self ) : [EOL] return dir ( self . __get_current_object__ ( ) ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] self . __get_current_object__ ( ) [ key ] = value [EOL] [EOL] def __delitem__ ( self , key ) : [EOL] del self . __get_current_object__ ( ) [ key ] [EOL] [EOL] __setattr__ = lambda x , n , v : setattr ( x . __get_current_object__ ( ) , n , v ) [EOL] __delattr__ = lambda x , n : delattr ( x . __get_current_object__ ( ) , n ) [comment] [EOL] __str__ = lambda x : str ( x . __get_current_object__ ( ) ) [comment] [EOL] __lt__ = lambda x , o : x . __get_current_object__ ( ) < o [EOL] __le__ = lambda x , o : x . __get_current_object__ ( ) <= o [EOL] __eq__ = lambda x , o : x . __get_current_object__ ( ) == o [comment] [EOL] __ne__ = lambda x , o : x . __get_current_object__ ( ) != o [comment] [EOL] __gt__ = lambda x , o : x . __get_current_object__ ( ) > o [EOL] __ge__ = lambda x , o : x . __get_current_object__ ( ) >= o [EOL] __hash__ = lambda x : hash ( x . __get_current_object__ ( ) ) [comment] [EOL] __call__ = lambda x , * a , ** kw : x . __get_current_object__ ( ) ( * a , ** kw ) [EOL] __len__ = lambda x : len ( x . __get_current_object__ ( ) ) [EOL] __getitem__ = lambda x , i : x . __get_current_object__ ( ) [ i ] [EOL] __iter__ = lambda x : iter ( x . __get_current_object__ ( ) ) [EOL] __contains__ = lambda x , i : i in x . __get_current_object__ ( ) [EOL] __add__ = lambda x , o : x . __get_current_object__ ( ) + o [EOL] __sub__ = lambda x , o : x . __get_current_object__ ( ) - o [EOL] __mul__ = lambda x , o : x . __get_current_object__ ( ) * o [EOL] __floordiv__ = lambda x , o : x . __get_current_object__ ( ) // o [EOL] __mod__ = lambda x , o : x . __get_current_object__ ( ) % o [EOL] __divmod__ = lambda x , o : x . __get_current_object__ ( ) . __divmod__ ( o ) [EOL] __pow__ = lambda x , o : x . __get_current_object__ ( ) ** o [EOL] __lshift__ = lambda x , o : x . __get_current_object__ ( ) << o [EOL] __rshift__ = lambda x , o : x . __get_current_object__ ( ) >> o [EOL] __and__ = lambda x , o : x . __get_current_object__ ( ) & o [EOL] __xor__ = lambda x , o : x . __get_current_object__ ( ) ^ o [EOL] __or__ = lambda x , o : x . __get_current_object__ ( ) | o [EOL] __div__ = lambda x , o : x . __get_current_object__ ( ) . __div__ ( o ) [EOL] __truediv__ = lambda x , o : x . __get_current_object__ ( ) . __truediv__ ( o ) [EOL] __neg__ = lambda x : - ( x . __get_current_object__ ( ) ) [EOL] __pos__ = lambda x : + ( x . __get_current_object__ ( ) ) [EOL] __abs__ = lambda x : abs ( x . __get_current_object__ ( ) ) [EOL] __invert__ = lambda x : ~ ( x . __get_current_object__ ( ) ) [EOL] __complex__ = lambda x : complex ( x . __get_current_object__ ( ) ) [EOL] __int__ = lambda x : int ( x . __get_current_object__ ( ) ) [EOL] __float__ = lambda x : float ( x . __get_current_object__ ( ) ) [EOL] __oct__ = lambda x : oct ( x . __get_current_object__ ( ) ) [EOL] __hex__ = lambda x : hex ( x . __get_current_object__ ( ) ) [EOL] __index__ = lambda x : x . __get_current_object__ ( ) . __index__ ( ) [EOL] __coerce__ = lambda x , o : x . __get_current_object__ ( ) . __coerce__ ( x , o ) [EOL] __enter__ = lambda x : x . __get_current_object__ ( ) . __enter__ ( ) [EOL] __exit__ = lambda x , * a , ** kw : x . __get_current_object__ ( ) . __exit__ ( * a , ** kw ) [EOL] __radd__ = lambda x , o : o + x . __get_current_object__ ( ) [EOL] __rsub__ = lambda x , o : o - x . __get_current_object__ ( ) [EOL] __rmul__ = lambda x , o : o * x . __get_current_object__ ( ) [EOL] __rdiv__ = lambda x , o : o / x . __get_current_object__ ( ) [EOL] __rtruediv__ = __rdiv__ [EOL] __rfloordiv__ = lambda x , o : o // x . __get_current_object__ ( ) [EOL] __rmod__ = lambda x , o : o % x . __get_current_object__ ( ) [EOL] __rdivmod__ = lambda x , o : x . __get_current_object__ ( ) . __rdivmod__ ( o ) [EOL] __copy__ = lambda x : copy . copy ( x . __get_current_object__ ( ) ) [EOL] __deepcopy__ = lambda x , memo : copy . deepcopy ( x . __get_current_object__ ( ) , memo ) [EOL] [EOL] [EOL] class ProxyLazyObject ( LazyObject ) : [EOL] def __get_current_object__ ( self ) : [EOL] [comment] [EOL] return self . __obj__ ( * self . __args__ , ** self . __kwargs__ ) [EOL] [EOL] [EOL] def lazy ( obj , * args , ** kwargs ) : [EOL] return LazyObject ( obj , args , kwargs ) [comment] [EOL] [EOL] [EOL] def proxy ( obj , * args , ** kwargs ) : [EOL] return ProxyLazyObject ( obj , args , kwargs ) [comment] [EOL] [EOL] [EOL] def reset_lazy ( obj ) : [EOL] object . __setattr__ ( obj , [string] , None ) [EOL] return obj [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,LazyLoadType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,LazyLoadType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Optional , Any [EOL] import builtins [EOL] import io [EOL] import typing [EOL] import types [EOL] import io [EOL] import os . path [EOL] import sys [EOL] import traceback [EOL] from importlib import import_module [EOL] from typing import Any , Optional [EOL] [EOL] currentframe = lambda : sys . _getframe ( [number] ) [EOL] [EOL] _srcfile = os . path . normcase ( __file__ ) [EOL] [EOL] [EOL] def import_reference ( reference ) : [EOL] module_path , class_name = reference . rsplit ( [string] , [number] ) [EOL] backend_cls = getattr ( import_module ( module_path ) , class_name ) [EOL] return backend_cls [EOL] [EOL] [EOL] def find_caller ( ) : [EOL] f = currentframe ( ) [EOL] stack_info = None [EOL] while hasattr ( f , [string] ) : [EOL] co = f . f_code [EOL] filename = os . path . normcase ( co . co_filename ) [EOL] if filename == _srcfile : [EOL] if f . f_back : [EOL] f = f . f_back [EOL] continue [EOL] sio = io . StringIO ( ) [EOL] sio . write ( [string] ) [EOL] traceback . print_stack ( f , file = sio ) [EOL] stack_info = sio . getvalue ( ) [EOL] if stack_info [ - [number] ] == [string] : [EOL] stack_info = stack_info [ : - [number] ] [EOL] sio . close ( ) [EOL] break [EOL] return stack_info [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],types.FrameType]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Callable[[],types.FrameType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Dict , Any , List [EOL] import builtins [EOL] import requests [EOL] import logging [EOL] import threading [EOL] import time [EOL] import configalchemy [EOL] import typing [EOL] import json [EOL] import logging [EOL] import threading [EOL] import time [EOL] from http import HTTPStatus [EOL] from typing import Dict [EOL] [EOL] import requests [EOL] [EOL] from configalchemy import BaseConfig , ConfigType [EOL] [EOL] time_counter = time . time [EOL] [EOL] [EOL] class ConfigException ( Exception ) : [EOL] ... [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ApolloBaseConfig ( BaseConfig ) : [EOL] CONFIGALCHEMY_ENABLE_FUNCTION = True [EOL] [EOL] APOLLO_USING_CACHE = False [EOL] APOLLO_SERVER_URL = [string] [EOL] APOLLO_APP_ID = [string] [EOL] APOLLO_CLUSTER = [string] [EOL] APOLLO_NAMESPACE = [string] [EOL] [EOL] APOLLO_EXTRA_NAMESPACE = [string] [EOL] APOLLO_EXTRA_NAMESPACE_PRIORITY = [number] [EOL] [EOL] APOLLO_LONG_POLL_TIMEOUT = [number] [EOL] [EOL] def __init__ ( self ) : [EOL] self . apollo_notification_map = { } [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def start_long_poll ( self ) : [EOL] logger . info ( [string] ) [EOL] thread = threading . Thread ( target = self . long_poll ) [EOL] thread . daemon = True [EOL] thread . start ( ) [EOL] return thread [EOL] [EOL] def _access_config_by_namespace ( self , namespace ) : [EOL] route = [string] [EOL] if self . APOLLO_USING_CACHE : [EOL] route = [string] [EOL] url = ( f"{ self . APOLLO_SERVER_URL } [string] { route } [string] { self . APOLLO_APP_ID } [string] " f"{ self . APOLLO_CLUSTER } [string] { namespace }" ) [EOL] logger . info ( f" [string] { url }" ) [EOL] response = requests . get ( url ) [EOL] if response . ok : [EOL] data = response . json ( ) [EOL] self . apollo_notification_map . setdefault ( data [ [string] ] , { [string] : - [number] } ) [EOL] self . apollo_notification_map [ data [ [string] ] ] [ [string] ] = data . get ( [string] , { } ) [EOL] logger . debug ( f" [string] { data }" ) [EOL] return data . get ( [string] , { } ) [EOL] else : [EOL] raise ConfigException ( f" [string] { url }" ) [EOL] [EOL] def configuration_function ( self ) : [EOL] self . from_mapping ( self . _access_config_by_namespace ( self . APOLLO_NAMESPACE ) , priority = self . CONFIGALCHEMY_FUNCTION_VALUE_PRIORITY , ) [EOL] for namespace in self . APOLLO_EXTRA_NAMESPACE . split ( [string] ) : [EOL] if namespace : [EOL] self . from_mapping ( self . _access_config_by_namespace ( namespace ) , priority = self . APOLLO_EXTRA_NAMESPACE_PRIORITY , ) [EOL] return { } [EOL] [EOL] def long_poll_from_apollo ( self ) : [EOL] url = f"{ self . APOLLO_SERVER_URL } [string] " [EOL] notifications = [ ] [EOL] for key , value in self . apollo_notification_map . items ( ) : [EOL] notifications . append ( { [string] : key , [string] : value [ [string] ] } ) [EOL] [EOL] r = requests . get ( url = url , params = { [string] : self . APOLLO_APP_ID , [string] : self . APOLLO_CLUSTER , [string] : json . dumps ( notifications , ensure_ascii = False ) , } , timeout = self . APOLLO_LONG_POLL_TIMEOUT , ) [EOL] [EOL] if r . status_code == HTTPStatus . NOT_MODIFIED : [EOL] logger . info ( [string] ) [EOL] elif r . status_code == HTTPStatus . OK : [EOL] data = r . json ( ) [EOL] for entry in data : [EOL] logger . info ( [string] % ( entry [ [string] ] , entry [ [string] ] ) ) [EOL] namespace = entry [ [string] ] [EOL] if namespace == self . APOLLO_NAMESPACE : [EOL] self . from_mapping ( self . _access_config_by_namespace ( namespace ) , priority = self . CONFIGALCHEMY_FUNCTION_VALUE_PRIORITY , ) [EOL] else : [EOL] self . from_mapping ( self . _access_config_by_namespace ( namespace ) , priority = self . APOLLO_EXTRA_NAMESPACE_PRIORITY , ) [EOL] self . apollo_notification_map [ entry [ [string] ] ] [ [string] ] = entry [ [string] ] [EOL] else : [comment] [EOL] raise ConfigException ( f"{ url } [string] { r . status_code }" ) [EOL] [EOL] def long_poll ( self ) : [EOL] while True : [EOL] try : [EOL] logger . debug ( [string] ) [EOL] self . long_poll_from_apollo ( ) [EOL] except ConfigException : [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,configalchemy.ConfigType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 $builtins.bool$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 $threading.Thread$ 0 0 0 $configalchemy.ConfigType$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $configalchemy.ConfigType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0