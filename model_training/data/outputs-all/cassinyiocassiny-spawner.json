from typing import List , Dict , Tuple , Type , Union [EOL] import config [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import os [EOL] from enum import IntEnum [EOL] from uuid import uuid4 [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Status ( IntEnum ) : [EOL] Creating = [number] [EOL] Running = [number] [EOL] Completed = [number] [EOL] Failed = [number] [EOL] Stopped = [number] [EOL] [EOL] [EOL] class Config ( ) : [EOL] [docstring] [EOL] [EOL] DEBUG = False [EOL] TESTING = False [EOL] BASE_DIR = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] TEMP_BUILD_FOLDER = os . path . join ( BASE_DIR , [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] with open ( [string] , mode = [string] ) as f : [EOL] PUBLIC_KEY = f . read ( ) [EOL] except FileNotFoundError : [EOL] log . error ( [string] ) [EOL] raise [EOL] [EOL] [comment] [EOL] STREAM_URI = os . getenv ( [string] , [string] ) [EOL] STREAM_CLIENT_NAME = f" [string] { uuid4 ( ) . hex [ : [number] ] }" [EOL] [EOL] [comment] [EOL] DB_USER = os . getenv ( [string] , [string] ) [EOL] DB_PASSWORD = os . getenv ( [string] , [string] ) [EOL] DB_NAME = os . getenv ( [string] , [string] ) [EOL] DB_HOST = os . getenv ( [string] , [string] ) [EOL] DB_PORT = os . getenv ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] MACHINES = ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] APPS_PUBLIC_URL = [string] [EOL] [EOL] [comment] [EOL] TRAEFIK_RULE = [string] [EOL] [EOL] [comment] [EOL] PROBE_DEFAULT_URL = [string] [EOL] API_DEFAULT_URL = [string] [EOL] CARGO_DEFAULT_URL = [string] [EOL] [EOL] [comment] [EOL] REGISTRY_USER = os . getenv ( [string] , [string] ) [EOL] REGISTRY_PASSWORD = os . getenv ( [string] , [string] ) [EOL] REGISTRY_URI = [string] [EOL] [EOL] [comment] [EOL] DEFAULT_LOGGING = { [string] : [number] , [string] : { [string] : { [string] : [string] , [string] : [string] } } , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , } , [string] : { [string] : { [string] : [string] , [string] : [ [string] ] , [string] : False } , [string] : { [string] : [string] , [string] : [ [string] ] , [string] : False } } , [string] : False } [EOL] [EOL] @ classmethod def make_dsn ( cls ) : [EOL] return f" [string] { cls . DB_USER } [string] { cls . DB_PASSWORD } [string] { cls . DB_HOST } [string] { cls . DB_PORT } [string] { cls . DB_NAME }" [EOL] [EOL] [EOL] class TestingConfig ( Config ) : [EOL] [docstring] [EOL] DEBUG = True [EOL] TESTING = True [EOL] [EOL] DB_USER = os . getenv ( [string] , [string] ) [EOL] DB_PASSWORD = os . getenv ( [string] , [string] ) [EOL] DB_NAME = os . getenv ( [string] , [string] ) [EOL] DB_HOST = os . getenv ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import logging . config [EOL] [EOL] from alembic . config import Config as AlembicConfig [EOL] from alembic import command [EOL] [EOL] from config import Config [EOL] [EOL] logging . config . dictConfig ( Config . DEFAULT_LOGGING ) [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] def make_migration ( ) : [EOL] [docstring] [EOL] try : [EOL] log . info ( [string] ) [EOL] alembic_cfg = AlembicConfig ( [string] ) [EOL] command . upgrade ( alembic_cfg , [string] ) [EOL] except Exception : [EOL] log . exception ( [string] ) [EOL] raise [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] make_migration ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from sqlalchemy import MetaData [EOL] [EOL] metadata = MetaData ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import logging [EOL] import logging . config [EOL] import sys [EOL] [EOL] from aiohttp import web [EOL] from aiopg . sa import create_engine [EOL] from psycopg2 import OperationalError [EOL] from rampante import scheduler , streaming [EOL] [EOL] from apis import routes as api_routes [EOL] from blueprints import routes as blueprint_routes [EOL] from cargos import routes as cargo_routes [EOL] from config import Config as C [EOL] from jobs import routes as job_routes [EOL] from monitoring import routes as monitoring_routes [EOL] from probes import routes as probe_routes [EOL] [EOL] logging . config . dictConfig ( C . DEFAULT_LOGGING ) [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def add_route ( app , * args ) : [EOL] [docstring] [EOL] for route in args : [EOL] app . router . add_route ( route [ [number] ] , route [ [number] ] , route [ [number] ] ) [EOL] [EOL] [EOL] async def start_db_pool ( app ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] engine = await create_engine ( user = C . DB_USER , password = C . DB_PASSWORD , database = C . DB_NAME , host = C . DB_HOST , port = C . DB_PORT , ) [EOL] except OperationalError as err : [EOL] log . error ( [string] ) [EOL] raise err [EOL] app [ [string] ] = engine [EOL] [EOL] [EOL] async def stop_db_pool ( app ) : [EOL] [docstring] [EOL] if [string] in app : [EOL] app [ [string] ] . close ( ) [EOL] await app [ [string] ] . wait_closed ( ) [EOL] [EOL] [EOL] async def start_task_manager ( app ) : [EOL] [docstring] [EOL] await streaming . start ( server = C . STREAM_URI , client_name = C . STREAM_CLIENT_NAME , service_group = [string] , loop = app . loop ) [EOL] app [ [string] ] = asyncio . ensure_future ( scheduler ( loop = app . loop , queue_size = [number] , app = app ) ) [EOL] [EOL] [EOL] async def stop_task_manager ( app ) : [EOL] [docstring] [EOL] await streaming . stop ( ) [EOL] if [string] in app : [EOL] app [ [string] ] . cancel ( ) [EOL] await app [ [string] ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] host = sys . argv [ [number] ] if len ( sys . argv ) > [number] else [string] [EOL] port = int ( sys . argv [ [number] ] ) if len ( sys . argv ) > [number] else [number] [EOL] app = web . Application ( ) [EOL] add_route ( app , * api_routes , * blueprint_routes , * job_routes , * probe_routes , * cargo_routes , * monitoring_routes ) [EOL] [EOL] [comment] [EOL] app . on_startup . append ( start_task_manager ) [EOL] app . on_startup . append ( start_db_pool ) [EOL] [comment] [EOL] app . on_cleanup . append ( stop_task_manager ) [EOL] app . on_cleanup . append ( stop_db_pool ) [EOL] [EOL] web . run_app ( app , host = host , port = port ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import logging . config [EOL] [EOL] from sqlalchemy import create_engine [EOL] [EOL] import blueprints . models [comment] [EOL] import cargos . models [comment] [EOL] import jobs . models [comment] [EOL] import probes . models [comment] [EOL] from apis import mApi [comment] [EOL] from config import Config [EOL] from factory import metadata [EOL] [EOL] logging . config . dictConfig ( Config . DEFAULT_LOGGING ) [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] def create_tables ( ) : [EOL] [docstring] [EOL] try : [EOL] engine = create_engine ( Config . make_dsn ( ) ) [EOL] metadata . create_all ( engine ) [EOL] log . info ( [string] ) [EOL] except Exception : [EOL] log . exception ( [string] ) [EOL] raise [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] create_tables ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import types [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] from types import MappingProxyType [EOL] [EOL] from rampante import subscribe_on [EOL] from sqlalchemy . exc import IntegrityError [EOL] [EOL] from apis import mApi [EOL] from cargos import mCargo [EOL] from jobs . helpers import delete_a_job [EOL] from jobs . models import mJob , update_job_status_with_uuid [EOL] from monitoring . models import add_log , update_service_status [EOL] from probes import mProbe [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] MODEL_TYPE = MappingProxyType ( { [string] : mProbe , [string] : mApi , [string] : mCargo , [string] : mJob , } ) [EOL] [EOL] [EOL] @ subscribe_on ( [string] ) async def service_notification ( queue , event , app ) : [EOL] [docstring] [EOL] log . info ( f" [string] { event }" ) [EOL] [EOL] model = MODEL_TYPE . get ( event [ [string] ] ) [EOL] [EOL] if model is None : [EOL] log . error ( f" [string] { event [ [string] ] }" ) [EOL] return [EOL] [EOL] [comment] [EOL] if event [ [string] ] == [string] and event [ [string] ] == [string] : [EOL] log . info ( f" [string] { event [ [string] ] } [string] { event [ [string] ] } [string] " ) [EOL] await update_job_status_with_uuid ( app [ [string] ] , event [ [string] ] ) [EOL] await delete_a_job ( event [ [string] ] , event [ [string] ] , event [ [string] ] ) [EOL] [EOL] try : [EOL] await add_log ( app [ [string] ] , event ) [EOL] except IntegrityError : [EOL] [comment] [EOL] log . warning ( f" [string] { event [ [string] ] } [string] { event [ [string] ] } [string] " ) [EOL] else : [EOL] await update_service_status ( app [ [string] ] , model , event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $types.MappingProxyType[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $types.MappingProxyType[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import monitoring [EOL] import typing [EOL] from marshmallow import Schema , fields [EOL] [EOL] [EOL] class Logs ( Schema ) : [EOL] id = fields . Int ( dump_only = True ) [EOL] log_type = fields . Str ( ) [EOL] service_type = fields . Str ( ) [EOL] name = fields . Str ( ) [EOL] action = fields . Str ( ) [EOL] usage = fields . Float ( ) [EOL] created = fields . DateTime ( format = [string] ) [EOL] destroyed = fields . DateTime ( format = [string] ) [EOL] user_id = fields . Int ( dump_only = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from monitoring . models import mLog [EOL] from monitoring . routes import routes [EOL] from monitoring . events import service_notification [EOL] [EOL] __all__ = ( [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0
from typing import Pattern , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] from typing import Dict [EOL] [EOL] from sqlalchemy import ( Column , DateTime , Integer , String , Table , UniqueConstraint , ) [EOL] from sqlalchemy . dialects . postgresql import UUID [EOL] from sqlalchemy . sql import func [EOL] [EOL] from factory import metadata [EOL] from utils import query_db [EOL] [EOL] REGEX = re . compile ( [string] ) [EOL] [EOL] mLog = Table ( [string] , metadata , Column ( [string] , Integer , primary_key = True ) , Column ( [string] , UUID ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , DateTime , server_default = func . now ( ) ) , Column ( [string] , Integer , nullable = False ) , UniqueConstraint ( [string] , [string] ) , ) [EOL] [EOL] [EOL] async def add_log ( db , event ) : [EOL] [docstring] [EOL] query = mLog . insert ( ) . values ( uuid = event [ [string] ] , log_type = event [ [string] ] , service_type = event [ [string] ] , name = event [ [string] ] , action = event [ [string] ] , user_id = event [ [string] ] ) [EOL] await query_db ( db , query , get_result = False ) [EOL] [EOL] [EOL] async def update_service_status ( db , model , event ) : [EOL] [docstring] [EOL] if [string] in event and event [ [string] ] is not None : [EOL] query = model . update ( ) . where ( model . c . name == event [ [string] ] ) . values ( status = event [ [string] ] , ) [EOL] await query_db ( db , query , get_result = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Type [EOL] import monitoring [EOL] import typing [EOL] [docstring] [EOL] [EOL] from monitoring . views import Events [EOL] [EOL] routes = ( ( [string] , [string] , Events ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.str,builtins.str,typing.Type[monitoring.views.Events]]]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import monitoring [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] from aiohttp . web import json_response [EOL] from sqlalchemy . sql import select [EOL] [EOL] from monitoring . models import mLog [EOL] from monitoring . serializers import Logs as LogsSchema [EOL] from utils import WebView , verify_token [EOL] [EOL] [EOL] class Events ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def get ( self , payload ) : [EOL] user_id = payload [ [string] ] [EOL] async with self . db . acquire ( ) as conn : [EOL] query = select ( [ mLog . c . name , mLog . c . user_id , mLog . c . uuid , mLog . c . action , mLog . c . created_at , ] ) . where ( ( mLog . c . user_id == user_id ) & ( ( mLog . c . action == [string] ) | ( mLog . c . action == [string] ) ) ) . order_by ( mLog . c . created_at . desc ( ) ) . limit ( [number] ) [EOL] [EOL] result = await conn . execute ( query ) [EOL] logs = await result . fetchall ( ) [EOL] [EOL] log_schema = LogsSchema ( many = True ) [EOL] data , errors = log_schema . dump ( logs ) [EOL] [EOL] return json_response ( { [string] : data } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $monitoring.serializers.Logs$ 0 0 0 0 0 0 0 0 0 0 0 0 $monitoring.serializers.Logs$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] import logging [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class BaseService ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , spawner ) : [EOL] self . _spawner = spawner [EOL] [EOL] async def delete ( self , name ) : [EOL] [docstring] [EOL] response = await self . _spawner . remove ( name = name ) [EOL] return response [EOL] [EOL] async def logs ( self , name , stdout = True , stderr = True ) : [EOL] [docstring] [EOL] response = await self . _spawner . logs ( name = name , stdout = True , stderr = True ) [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import List , Dict , Any , Mapping , Tuple , Type , Union [EOL] import spawner [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import logging [EOL] import shlex [EOL] from typing import Any , Dict , List , Mapping , Tuple [EOL] [EOL] from aiodocker . docker import Docker [EOL] from aiodocker . exceptions import DockerError [EOL] [EOL] from config import Config [EOL] from spawner . api import Api [EOL] from spawner . blueprint import Blueprint [EOL] from spawner . cargo import Cargo [EOL] from spawner . job import Job [EOL] from spawner . probe import Probe [EOL] [EOL] log = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class ServiceManager : [EOL] [docstring] [EOL] _docker = None [EOL] [EOL] def __init__ ( self ) : [EOL] self . api = Api ( self ) [EOL] self . cargo = Cargo ( self ) [EOL] self . job = Job ( self ) [EOL] self . probe = Probe ( self ) [EOL] self . blueprint = Blueprint ( self ) [EOL] [EOL] @ property def docker ( self ) : [EOL] [docstring] [EOL] cls = self . __class__ [EOL] if cls . _docker is None : [EOL] cls . _docker = Docker ( ) [EOL] return cls . _docker [EOL] [EOL] async def get_service ( self , name ) : [EOL] [docstring] [EOL] log . info ( f" [string] { name }" , ) [EOL] try : [EOL] service = await self . docker . services . inspect ( name ) [EOL] except DockerError : [EOL] service = None [EOL] log . warning ( f" [string] { name } [string] " ) [EOL] [EOL] return service [EOL] [EOL] async def create ( self , * , name , service_labels = None , user_id , specs , env ) : [EOL] [docstring] [EOL] networks , task_template = self . create_template ( user_id = user_id , name = name , specs = specs ) [EOL] [EOL] [comment] [EOL] if env is not None : [EOL] task_template [ [string] ] [ [string] ] = env [EOL] [EOL] params = { [string] : networks , [string] : task_template , } [EOL] [EOL] if service_labels is not None : [EOL] params [ [string] ] = service_labels [EOL] [EOL] params [ [string] ] = name [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in specs . get ( [string] ) : [EOL] params [ [string] ] = { [string] : Config . REGISTRY_USER , [string] : Config . REGISTRY_PASSWORD } [EOL] params [ [string] ] = [string] [EOL] [EOL] log . info ( f" [string] { task_template }" ) [EOL] [EOL] try : [EOL] await self . docker . services . create ( ** params ) [EOL] except DockerError as err : [EOL] log . exception ( f" [string] { name } [string] " ) [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] @ staticmethod def get_image ( specs ) : [EOL] [docstring] [EOL] [comment] [EOL] repository = specs . get ( [string] , None ) [EOL] blueprint = specs . get ( [string] , None ) [EOL] if repository is None : [EOL] return blueprint [EOL] return f"{ repository } [string] { blueprint }" [EOL] [EOL] def _add_resources ( self , specs ) : [EOL] [docstring] [EOL] [comment] [EOL] cpu = specs . get ( [string] , False ) [EOL] ram = specs . get ( [string] , False ) [EOL] if cpu and ram : [EOL] resources = { [string] : { [string] : int ( cpu * [number] ) , [string] : int ( ram * [number] ) } , } [EOL] return resources [EOL] return { } [EOL] [EOL] def _add_placement ( self , specs , name ) : [EOL] [docstring] [EOL] placement = specs . get ( [string] , [ ] ) [EOL] [EOL] [comment] [EOL] if specs [ [string] ] == [string] : [EOL] constraint = [string] [EOL] placement . append ( constraint ) [EOL] else : [EOL] instance_name = f" [string] { specs [ [string] ] }" [EOL] placement . append ( f" [string] { instance_name }" ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return placement [EOL] [EOL] def create_template ( self , name , user_id , specs ) : [EOL] [docstring] [EOL] TaskTemplate = { } [EOL] container_spec = { } [EOL] [EOL] [comment] [EOL] container_spec [ [string] ] = self . get_image ( specs ) [EOL] [EOL] networks = [ ] [EOL] if [string] in specs : [EOL] networks = specs [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] container_spec [ [string] ] = { [string] : str ( user_id ) , [string] : specs [ [string] ] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in specs : [EOL] if isinstance ( specs [ [string] ] , list ) : [EOL] container_spec [ [string] ] = specs [ [string] ] [ : [number] ] [EOL] container_spec [ [string] ] = specs [ [string] ] [ [number] : ] [EOL] else : [EOL] command = shlex . split ( specs [ [string] ] ) [EOL] container_spec [ [string] ] = command [ : [number] ] [EOL] container_spec [ [string] ] = command [ [number] : ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] in specs : [EOL] [comment] [EOL] if isinstance ( specs [ [string] ] , list ) : [EOL] container_spec [ [string] ] = specs [ [string] ] [EOL] else : [EOL] command = shlex . split ( specs [ [string] ] ) [EOL] container_spec [ [string] ] = command [EOL] [EOL] [comment] [EOL] if specs [ [string] ] == [string] : [EOL] container_spec [ [string] ] = [ { [string] : specs [ [string] ] , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] [comment] [EOL] TaskTemplate [ [string] ] = { [string] : self . _add_placement ( specs = specs , name = name ) } [EOL] [EOL] [comment] [EOL] if specs [ [string] ] == [string] : [EOL] [comment] [EOL] TaskTemplate [ [string] ] = { [string] : [string] } [EOL] [EOL] resources = self . _add_resources ( specs ) [EOL] if resources : [EOL] TaskTemplate [ [string] ] = resources [EOL] [EOL] [comment] [EOL] TaskTemplate [ [string] ] = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } } [EOL] [EOL] TaskTemplate [ [string] ] = container_spec [EOL] [EOL] return networks , TaskTemplate [EOL] [EOL] async def remove ( self , name = None , uuid = None ) : [EOL] [docstring] [EOL] if name is None : [EOL] name = uuid [EOL] [EOL] if name is None : [EOL] raise KeyError ( [string] ) [EOL] [EOL] log . info ( f" [string] { name }" ) [EOL] [EOL] try : [EOL] resp = await self . docker . services . delete ( name ) [EOL] log . info ( f" [string] { name } [string] " ) [EOL] except DockerError : [EOL] log . exception ( f" [string] { name } [string] " ) [EOL] resp = False [EOL] [EOL] return resp [EOL] [EOL] async def build ( self , name , fileobj ) : [EOL] [docstring] [EOL] building_image = await self . docker . images . build ( fileobj = fileobj , quiet = True , encoding = [string] , tag = name ) [EOL] log . info ( building_image ) [EOL] return building_image [EOL] [EOL] async def push ( self , name , auth ) : [EOL] [docstring] [EOL] pushing_image = await self . docker . images . push ( name = name , auth = auth ) [EOL] log . info ( pushing_image ) [EOL] return pushing_image [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Mapping$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing.List,typing.Mapping]$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Mapping$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 $typing.List[typing.Any]$ 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping$ 0 $typing.Mapping$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Mapping$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Mapping$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0
from typing import Dict , Any [EOL] import logging [EOL] import typing [EOL] import urllib [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] import logging [EOL] from typing import Dict [EOL] from urllib . parse import urlparse [EOL] [EOL] from config import Config as C [EOL] from spawner . base_service import BaseService [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Cargo ( BaseService ) : [EOL] [docstring] [EOL] [EOL] async def create ( self , name , user_id , specs , access_key , secret_key ) : [EOL] [docstring] [EOL] env = self . get_env ( name = name , access_key = access_key , secret_key = secret_key ) [EOL] [EOL] url = urlparse ( C . CARGO_DEFAULT_URL ) [EOL] [EOL] specs . update ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : [string] } ) [EOL] [EOL] service_labels = { [string] : f'{ url . port }' , [string] : [string] , [string] : C . TRAEFIK_RULE . format ( name ) , [string] : specs [ [string] ] [ - [number] ] , } [EOL] [EOL] service_id = await self . _spawner . create ( name = name , user_id = user_id , specs = specs , env = env , service_labels = service_labels ) [EOL] log . info ( f"{ specs [ [string] ] } [string] { name } [string] " ) [EOL] return service_id [EOL] [EOL] @ staticmethod def get_env ( name , access_key , secret_key ) : [EOL] [docstring] [EOL] env = { [string] : [string] , [string] : access_key , [string] : secret_key , [string] : name , } [EOL] return env [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Dict$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Dict$ 0 $typing.Dict$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] from typing import Dict [EOL] [EOL] from spawner . base_service import BaseService [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Job ( BaseService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , spawner ) : [EOL] self . _spawner = spawner [EOL] [EOL] async def create ( self , name , user_id , specs ) : [EOL] [docstring] [EOL] env = self . get_env ( name ) [EOL] specs [ [string] ] = [string] [EOL] [EOL] service_id = await self . _spawner . create ( name = name , user_id = user_id , specs = specs , env = env ) [EOL] log . info ( f"{ specs [ [string] ] } [string] { name } [string] " ) [EOL] return service_id [EOL] [EOL] @ staticmethod def get_env ( name ) : [EOL] [docstring] [EOL] env = { [string] : name } [EOL] return env [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Dict$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Dict$ 0 $typing.Dict$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0
from typing import IO , Dict , Any [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] from typing import IO [EOL] [EOL] from spawner . base_service import BaseService [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Blueprint ( BaseService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , spawner ) : [EOL] self . _spawner = spawner [EOL] [EOL] async def create ( self , name , fileobj ) : [EOL] [docstring] [EOL] service_id = await self . _spawner . build ( name = name , fileobj = fileobj , ) [EOL] return service_id [EOL] [EOL] async def push ( self , name , username , password ) : [EOL] [docstring] [EOL] auth = { [string] : username , [string] : password } [EOL] service_id = await self . _spawner . push ( name = name , auth = auth ) [EOL] return service_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.IO$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.IO$ 0 $typing.IO$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0
from typing import Union , Dict , Any [EOL] import logging [EOL] import typing [EOL] import urllib [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] import logging [EOL] from typing import Any , Dict [EOL] from urllib . parse import urlparse [EOL] [EOL] from config import Config as C [EOL] from spawner . base_service import BaseService [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Probe ( BaseService ) : [EOL] [docstring] [EOL] [EOL] async def create ( self , * , name , user_id , specs , token , ) : [EOL] [docstring] [EOL] env = self . get_env ( name = name , token = token ) [EOL] [EOL] specs . update ( { [string] : [string] , [string] : [ [string] ] , } ) [EOL] [EOL] [comment] [EOL] service_labels = { [string] : f'{ env [ [string] ] }' , [string] : [string] , [string] : C . TRAEFIK_RULE . format ( name ) , [string] : specs [ [string] ] [ - [number] ] , } [EOL] [EOL] service = await self . _spawner . create ( name = name , user_id = user_id , specs = specs , env = env , service_labels = service_labels ) [EOL] log . info ( f"{ specs [ [string] ] } [string] { name } [string] " ) [EOL] return service [EOL] [EOL] @ staticmethod def get_env ( name , token ) : [EOL] [docstring] [EOL] url = urlparse ( C . PROBE_DEFAULT_URL ) [EOL] env = { [string] : [string] , [string] : url . hostname , [string] : url . port , [string] : name , [string] : token , } [EOL] return env [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Dict$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Dict$ 0 $typing.Dict$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str]]$ 0
from typing import Dict , Any [EOL] import logging [EOL] import typing [EOL] import urllib [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] import logging [EOL] from typing import Dict [EOL] from urllib . parse import urlparse [EOL] [EOL] from config import Config as C [EOL] from spawner . base_service import BaseService [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Api ( BaseService ) : [EOL] [docstring] [EOL] [EOL] async def create ( self , name , user_id , specs , ) : [EOL] [docstring] [EOL] env = self . get_env ( name ) [EOL] specs [ [string] ] = [string] [EOL] [EOL] url = urlparse ( C . API_DEFAULT_URL ) [EOL] [EOL] [comment] [EOL] service_labels = { [string] : f"{ url . port }" , [string] : [string] , [string] : C . TRAEFIK_RULE . format ( name ) , [string] : specs [ [string] ] [ - [number] ] , } [EOL] [EOL] service = await self . _spawner . create ( name = name , user_id = user_id , specs = specs , env = env , service_labels = service_labels ) [EOL] log . info ( f"{ specs [ [string] ] } [string] { name } [string] " ) [EOL] return service [EOL] [EOL] @ staticmethod def get_env ( name ) : [EOL] [docstring] [EOL] env = { [string] : name } [EOL] [EOL] return env [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict$ 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Dict$ 0 $typing.Dict$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $logging.Logger$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0
import spawner [EOL] [docstring] [EOL] [EOL] from spawner . manager import ServiceManager [EOL] [EOL] Spawner = ServiceManager ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $spawner.manager.ServiceManager$ 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from probes . routes import routes [EOL] from probes . models import mProbe , mUser_probes [EOL] from probes import events [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Mapping , Dict , Type , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] from typing import Any , Mapping [EOL] [EOL] from aiohttp . web import json_response [EOL] from rampante import streaming [EOL] [EOL] from blueprints . models import join_blueprints_with [EOL] from probes . models import delete_probe , mProbe , select_probe [EOL] from probes . serializers import ProbeSchema [EOL] from spawner import Spawner [EOL] from utils import WebView , get_uuid , verify_token [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] type_payload = Mapping [ str , Any ] [EOL] [EOL] [EOL] class Probe ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def get ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] [EOL] probes = await join_blueprints_with ( model = mProbe , db = self . db , user_id = user_id ) [EOL] probes_schema = ProbeSchema ( many = True ) [EOL] probes_schema . context = { [string] : user_id } [EOL] [EOL] data , errors = probes_schema . dump ( probes ) [EOL] [EOL] if errors : [EOL] return json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] return json_response ( { [string] : data } ) [EOL] [EOL] @ verify_token async def post ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] data = await self . request . json ( ) [EOL] [EOL] data , errors = ProbeSchema ( ) . load ( data ) [EOL] if errors : [EOL] return json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] event = { [string] : get_uuid ( ) . hex , [string] : user_id , [string] : data } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] [EOL] return json_response ( { [string] : event [ [string] ] , [string] : f" [string] { event [ [string] ] } [string] " } ) [EOL] [EOL] @ verify_token async def delete ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] probe_ref = self . request . match_info . get ( [string] ) [EOL] [EOL] deleted_probe = await delete_probe ( self . db , probe_ref = probe_ref , user_id = user_id ) [EOL] [EOL] if deleted_probe is None : [EOL] error = [string] [EOL] return json_response ( { [string] : error } , status = [number] ) [EOL] [EOL] await Spawner . probe . delete ( name = deleted_probe . name ) [EOL] [EOL] event = { [string] : deleted_probe . uuid , [string] : user_id , [string] : deleted_probe . name , } [EOL] await streaming . publish ( [string] , event ) [EOL] message = f" [string] { deleted_probe . name } [string] " [EOL] return json_response ( { [string] : message } ) [EOL] [EOL] [EOL] class Logs ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def get ( self , payload ) : [EOL] user_id = payload [ [string] ] [EOL] probe_ref = self . request . match_info . get ( [string] ) [EOL] [EOL] selected_probe = await select_probe ( db = self . db , probe_ref = probe_ref , user_id = user_id ) [EOL] [EOL] if selected_probe is None : [EOL] user_message = f" [string] " [EOL] return json_response ( { [string] : user_message } , status = [number] ) [EOL] [EOL] logs = await Spawner . probe . logs ( name = selected_probe . name ) [EOL] return json_response ( { [string] : logs } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Tuple , Type [EOL] import typing [EOL] import probes [EOL] [docstring] [EOL] [EOL] from probes . views import Logs , Probe [EOL] [EOL] routes = ( ( [string] , [string] , Probe ) , ( [string] , [string] , Probe ) , ( [string] , [string] , Probe ) , ( [string] , [string] , Probe ) , ( [string] , [string] , Probe ) , ( [string] , [string] , Logs ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.str,builtins.str,typing.Type[probes.views.Probe]],typing.Tuple[builtins.str,builtins.str,typing.Type[probes.views.Probe]],typing.Tuple[builtins.str,builtins.str,typing.Type[probes.views.Probe]],typing.Tuple[builtins.str,builtins.str,typing.Type[probes.views.Probe]],typing.Tuple[builtins.str,builtins.str,typing.Type[probes.views.Probe]],typing.Tuple[builtins.str,builtins.str,typing.Type[probes.views.Logs]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] from secrets import token_urlsafe [EOL] [EOL] from rampante import streaming , subscribe_on [EOL] [EOL] from blueprints . models import get_blueprint [EOL] from probes . models import delete_probe , mProbe [EOL] from spawner import Spawner [EOL] from utils import naminator , query_db [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ subscribe_on ( [string] ) async def create_probe ( queue , event , app ) : [EOL] [docstring] [EOL] user_id = event [ [string] ] [EOL] probe = event [ [string] ] [EOL] uuid = event [ [string] ] [EOL] [EOL] blueprint = await get_blueprint ( app [ [string] ] , blueprint_ref = probe [ [string] ] , user_id = user_id ) [EOL] [EOL] if blueprint is None : [EOL] log . info ( f"{ event [ [string] ] } [string] { probe [ [string] ] } [string] " ) [EOL] [EOL] event = { [string] : user_id , [string] : { [string] : [string] , [string] : f"{ probe [ [string] ] } [string] " , } } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] return [EOL] [EOL] name = naminator ( [string] ) [EOL] token = token_urlsafe ( [number] ) [EOL] [EOL] specs = { [string] : uuid , [string] : blueprint . repository , [string] : f"{ blueprint . name } [string] { blueprint . tag }" , [string] : [ [string] ] , [string] : probe [ [string] ] , [string] : probe [ [string] ] , } [EOL] [EOL] query = mProbe . insert ( ) . values ( uuid = uuid , user_id = user_id , blueprint_uuid = blueprint . uuid , name = name , token = token , description = probe [ [string] ] , specs = specs , ) [EOL] await query_db ( app [ [string] ] , query , get_result = False ) [EOL] [EOL] service = await Spawner . probe . create ( name = name , user_id = user_id , specs = specs , token = token , ) [EOL] [EOL] if not service : [EOL] log . error ( f" [string] { uuid } [string] " ) [EOL] [EOL] await delete_probe ( db = app [ [string] ] , probe_ref = uuid , user_id = user_id ) [EOL] log . info ( f" [string] { uuid } [string] " ) [EOL] [EOL] event = { [string] : user_id , [string] : uuid , [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] return [EOL] [EOL] event = { [string] : user_id , [string] : uuid , [string] : name , [string] : specs } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Pattern [EOL] import typing [EOL] import re [EOL] [EOL] from utils import naminator [EOL] [EOL] [EOL] def test_general_functionality ( ) : [EOL] regex = re . compile ( [string] ) [EOL] name = naminator ( [string] ) [EOL] assert regex . match ( name ) , name [EOL] [EOL] [EOL] def test_wont_return_same_name ( ) : [EOL] assert naminator ( [string] ) != naminator ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] import asyncio [EOL] import logging [EOL] import logging . config [EOL] [EOL] import pytest [EOL] from aiohttp import web [EOL] from aiohttp . test_utils import TestClient , TestServer [EOL] from aiopg . sa import create_engine as aiopg_create_engine [EOL] from psycopg2 import OperationalError [EOL] from sqlalchemy import create_engine [EOL] from sqlalchemy . schema import CreateTable [EOL] from sqlalchemy_utils . functions import ( create_database , database_exists , drop_database , ) [EOL] [EOL] from apis import mApi [EOL] from apis import routes as api_routes [EOL] from app import ( add_route , start_task_manager , stop_db_pool , stop_task_manager , ) [EOL] from blueprints import mBlueprint [EOL] from blueprints import routes as blueprint_routes [EOL] from cargos import mCargo , mUser_cargos [EOL] from cargos import routes as cargo_routes [EOL] from config import Config as C [EOL] from jobs import mJob [EOL] from jobs import routes as job_routes [EOL] from monitoring import mLog [EOL] from monitoring import routes as monitoring_routes [EOL] from probes import mProbe , mUser_probes [EOL] from probes import routes as probe_routes [EOL] from tests . fixtures import _validate_token [EOL] [EOL] logging . config . dictConfig ( C . DEFAULT_LOGGING ) [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def create_tables ( ) : [EOL] [docstring] [EOL] DB_URI = f' [string] { C . DB_USER } [string] { C . DB_PASSWORD } [string] { C . DB_HOST } [string] { C . DB_PORT } [string] { C . DB_NAME }' [EOL] if database_exists ( DB_URI ) : [EOL] drop_database ( DB_URI ) [EOL] create_database ( DB_URI ) [EOL] engine = create_engine ( DB_URI ) [EOL] [EOL] conn = engine . connect ( ) [EOL] models = [ mBlueprint , mCargo , mApi , mProbe , mUser_probes , mJob , mUser_cargos , mLog ] [EOL] for model in models : [EOL] conn . execute ( CreateTable ( model ) . compile ( engine ) . __str__ ( ) ) [EOL] add_blueprint = [string] [EOL] conn . execute ( add_blueprint ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def loop ( ) : [EOL] [docstring] [EOL] [EOL] loop = asyncio . new_event_loop ( ) [EOL] asyncio . set_event_loop ( loop ) [EOL] yield loop [EOL] [EOL] [comment] [EOL] loop . close ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def test_client ( loop ) : [EOL] [docstring] [EOL] clients = [ ] [EOL] [EOL] async def go ( __param , * args , server_kwargs = None , ** kwargs ) : [EOL] [EOL] server_kwargs = server_kwargs or { } [EOL] server = TestServer ( __param , loop = loop , ** server_kwargs ) [EOL] client = TestClient ( server , loop = loop , ** kwargs ) [EOL] [EOL] await client . start_server ( ) [EOL] clients . append ( client ) [EOL] return client [EOL] [EOL] yield go [EOL] [EOL] async def finalize ( ) : [EOL] while clients : [EOL] await clients . pop ( ) . close ( ) [EOL] [EOL] loop . run_until_complete ( finalize ( ) ) [EOL] [EOL] [EOL] async def start_db_pool ( app ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] engine = await aiopg_create_engine ( user = C . DB_USER , password = C . DB_PASSWORD , database = C . DB_NAME , host = C . DB_HOST , port = C . DB_PORT , ) [EOL] except OperationalError as err : [EOL] log . error ( [string] ) [EOL] raise err [EOL] app [ [string] ] = engine [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def cli ( loop , test_client , create_tables ) : [EOL] app = web . Application ( loop = loop ) [EOL] add_route ( app , * api_routes , * blueprint_routes , * job_routes , * probe_routes , * cargo_routes , * monitoring_routes , ) [EOL] app . on_startup . append ( start_task_manager ) [EOL] app . on_startup . append ( start_db_pool ) [EOL] [EOL] app . on_cleanup . append ( stop_task_manager ) [EOL] app . on_cleanup . append ( stop_db_pool ) [EOL] return loop . run_until_complete ( test_client ( app ) ) [EOL] [EOL] [EOL] @ pytest . fixture def valid_token ( monkeypatch ) : [EOL] [docstring] [EOL] monkeypatch . setattr ( [string] , _validate_token ) [EOL] yield [EOL] monkeypatch . undo ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] from types import MappingProxyType [EOL] [EOL] [EOL] def _validate_token ( * args ) : [EOL] [docstring] [EOL] payload = { [string] : [number] , [string] : [string] } [EOL] return MappingProxyType ( payload ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Dict , Any [EOL] import typing [EOL] import asyncio [EOL] from types import MappingProxyType [EOL] from unittest . mock import patch [EOL] [EOL] import msgpack [EOL] [EOL] [EOL] async def _validate_token ( * args ) : [EOL] [docstring] [EOL] return MappingProxyType ( { [string] : [number] } ) [EOL] [EOL] patch ( [string] , _validate_token ) . start ( ) [EOL] [EOL] EVENTS = [ ] [EOL] [comment] [EOL] SERVICES = [number] [EOL] CORRECT_SERVICES = SERVICES * [number] [EOL] COUNTING_FROM = [number] [EOL] [EOL] [EOL] async def _send_event ( * args , ** kwargs ) : [EOL] global EMAILS_SENT [EOL] [docstring] [EOL] body = msgpack . packb ( kwargs [ [string] ] ) [EOL] EVENTS . append ( msgpack . unpackb ( body , encoding = [string] ) ) [EOL] [EOL] patch ( [string] , _send_event ) . start ( ) [EOL] [EOL] [EOL] async def test_create_service ( cli , docker ) : [EOL] [EOL] TaskTemplate = { [string] : { [string] : [string] , [string] : { [string] : [string] , } } , } [EOL] [EOL] services = [ ] [EOL] [comment] [EOL] for i in range ( COUNTING_FROM , COUNTING_FROM + SERVICES ) : [EOL] service = await docker . services . create ( task_template = TaskTemplate , name = f" [string] { i }" ) [EOL] services . append ( service [ [string] ] ) [EOL] [EOL] [comment] [EOL] await asyncio . sleep ( [number] ) [EOL] for service in services : [EOL] await docker . services . delete ( service ) [EOL] [comment] [EOL] await asyncio . sleep ( [number] ) [EOL] await docker . swarm . leave ( force = True ) [EOL] for event in EVENTS : [EOL] assert [string] in event [EOL] assert len ( EVENTS ) == CORRECT_SERVICES [EOL] [EOL] [EOL] async def test_create_wrong_service ( cli , docker ) : [EOL] [EOL] TaskTemplate = { [string] : { [string] : [string] , } , } [EOL] [EOL] service = await docker . services . create ( task_template = TaskTemplate , name = [string] ) [EOL] await asyncio . sleep ( [number] ) [EOL] await docker . services . delete ( service [ [string] ] ) [EOL] await asyncio . sleep ( [number] ) [EOL] await docker . swarm . leave ( force = True ) [EOL] assert len ( EVENTS ) == CORRECT_SERVICES [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0
from typing import Union , Dict , Any [EOL] import typing [EOL] from secrets import token_urlsafe [EOL] [EOL] from spawner import Spawner [EOL] from utils import get_uuid , naminator [EOL] [EOL] [EOL] async def test_create_remove_job ( loop ) : [EOL] name = naminator ( [string] ) [EOL] specs = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : get_uuid ( ) . hex , } [EOL] [EOL] await Spawner . job . create ( name = name , user_id = [number] , specs = specs , ) [EOL] service = await Spawner . get_service ( name = name ) [EOL] assert service is not None [EOL] await Spawner . job . delete ( name = name ) [EOL] service = await Spawner . get_service ( name = name ) [EOL] assert service is None [EOL] [EOL] [EOL] async def create_remove_api ( loop ) : [EOL] name = naminator ( [string] ) [EOL] specs = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : get_uuid ( ) . hex , } [EOL] [EOL] await Spawner . api . create ( name = name , user_id = [number] , specs = specs , cargo = [number] , s3_key = [string] , s3_skey = [string] , ) [EOL] service = await Spawner . get_service ( name = name ) [EOL] assert service is not None [EOL] await Spawner . api . delete ( name = name ) [EOL] service = await Spawner . get_service ( name = name ) [EOL] assert service is None [EOL] [EOL] [EOL] async def test_create_remove_probe ( loop ) : [EOL] name = naminator ( [string] ) [EOL] token = token_urlsafe ( [number] ) [EOL] specs = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : get_uuid ( ) . hex , } [EOL] [EOL] await Spawner . probe . create ( name = name , user_id = [number] , specs = specs , token = token ) [EOL] service = await Spawner . get_service ( name = name ) [EOL] assert service is not None [EOL] await Spawner . probe . delete ( name = name ) [EOL] service = await Spawner . get_service ( name = name ) [EOL] assert service is None [EOL] [EOL] [EOL] async def test_create_remove_cargo ( loop ) : [EOL] name = naminator ( [string] ) [EOL] specs = { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : get_uuid ( ) . hex , } [EOL] [EOL] await Spawner . cargo . create ( name = name , user_id = [number] , access_key = token_urlsafe ( [number] ) . upper ( ) , secret_key = token_urlsafe ( [number] ) , specs = specs , ) [EOL] service = await Spawner . get_service ( name = name ) [EOL] assert service is not None [EOL] await Spawner . cargo . delete ( name = name ) [EOL] service = await Spawner . get_service ( name = name ) [EOL] assert service is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] async def test_get_blueprints ( cli , valid_token ) : [EOL] resp = await cli . get ( [string] ) [EOL] assert resp . status == [number] [EOL] data = await resp . json ( ) [EOL] assert data [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] import tarfile [EOL] import io [EOL] import tarfile [EOL] [EOL] from blueprints . build_from_file import CreateFromFile [EOL] [EOL] [EOL] def test_build_from_file ( ) : [EOL] path = [string] [EOL] with tarfile . open ( path , [string] ) as fp : [EOL] file = [string] [EOL] file_info = tarfile . TarInfo ( [string] ) [EOL] file_info . size = len ( file ) [EOL] fp . addfile ( file_info , io . BytesIO ( file ) ) [EOL] with CreateFromFile ( file_path = path , base_image = [string] ) as fp : [EOL] with tarfile . open ( fileobj = fp , mode = [string] ) as inner_fp : [EOL] files = inner_fp . getnames ( ) [EOL] assert [string] in files [EOL] assert [string] in files [EOL] assert [string] in files [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , Any [EOL] import typing [EOL] import asyncio [EOL] [EOL] [EOL] async def test_get_apis ( cli , valid_token ) : [EOL] resp = await cli . get ( [string] ) [EOL] assert resp . status == [number] [EOL] data = await resp . json ( ) [EOL] assert data [ [string] ] == [ ] [EOL] [EOL] [EOL] async def test_post_apis_error ( cli , valid_token ) : [EOL] resp = await cli . post ( [string] , json = { } ) [EOL] assert resp . status == [number] [EOL] data = await resp . json ( ) [EOL] assert data [ [string] ] [EOL] [EOL] [EOL] async def test_post_apis ( cli , valid_token ) : [EOL] body = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : False } [EOL] resp = await cli . post ( [string] , json = body ) [EOL] assert resp . status == [number] [EOL] data = await resp . json ( ) [EOL] assert data [ [string] ] [EOL] [EOL] [EOL] async def test_delete_apis ( cli , valid_token ) : [EOL] body = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : False } [EOL] resp = await cli . post ( [string] , json = body ) [EOL] assert resp . status == [number] [EOL] data = await resp . json ( ) [EOL] uuid = data [ [string] ] [EOL] await asyncio . sleep ( [number] ) [EOL] resp = await cli . delete ( f' [string] { uuid }' ) [EOL] assert resp . status == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import uuid [EOL] [EOL] from sqlalchemy import ( Column , DateTime , ForeignKey , Integer , String , Table , ) [EOL] from sqlalchemy . dialects . postgresql import JSONB , UUID [EOL] from sqlalchemy . sql import func [EOL] [EOL] from factory import metadata [EOL] [EOL] mCargo = Table ( [string] , metadata , Column ( [string] , UUID , primary_key = True ) , Column ( [string] , String ( [number] ) , unique = True ) , Column ( [string] , JSONB ) , Column ( [string] , Integer , default = [number] ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , Integer , nullable = False ) , ) [EOL] [EOL] mUser_cargos = Table ( [string] , metadata , Column ( [string] , Integer , primary_key = True ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , Integer , nullable = False ) , Column ( [string] , UUID , ForeignKey ( [string] ) , nullable = False ) , ) [EOL] [EOL] [EOL] async def get_cargos ( db , user_id ) : [EOL] query = mCargo . select ( ) . where ( mCargo . c . user_id == user_id ) [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query ) [EOL] row = await result . fetchall ( ) [EOL] return row [EOL] [EOL] [EOL] async def get_cargo ( db , cargo_ref , user_id ) : [EOL] try : [EOL] uuid . UUID ( cargo_ref ) [EOL] except ValueError : [EOL] query = mCargo . select ( ) . where ( ( mCargo . c . user_id == user_id ) & ( mCargo . c . name == cargo_ref ) ) [EOL] else : [EOL] query = mCargo . select ( ) . where ( ( mCargo . c . user_id == user_id ) & ( mCargo . c . uuid == cargo_ref ) ) [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query ) [EOL] row = await result . fetchone ( ) [EOL] return row [EOL] [EOL] [EOL] async def delete_cargo ( db , cargo_ref , user_id ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] uuid . UUID ( cargo_ref ) [EOL] except ValueError : [EOL] query = mCargo . delete ( ) . where ( ( mCargo . c . user_id == user_id ) & ( mCargo . c . name == cargo_ref ) ) [EOL] else : [EOL] query = mCargo . delete ( ) . where ( ( mCargo . c . user_id == user_id ) & ( mCargo . c . uuid == cargo_ref ) ) [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query . returning ( mCargo . c . uuid , mCargo . c . name ) ) [EOL] row = await result . fetchone ( ) [EOL] return row [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Mapping , Dict , Any [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] import logging [EOL] from typing import Any , Mapping [EOL] [EOL] from aiohttp . web import json_response [EOL] from rampante import streaming [EOL] [EOL] from cargos . models import delete_cargo , get_cargos [EOL] from cargos . serializers import CargoSchema [EOL] from spawner import Spawner [EOL] from utils import WebView , get_uuid , verify_token [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Cargo ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def get ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] [EOL] cargos = await get_cargos ( self . db , user_id = user_id ) [EOL] cargos_schema = CargoSchema ( many = True ) [EOL] cargos_schema . context = { [string] : user_id } [EOL] [EOL] data , _ = cargos_schema . dump ( cargos ) [EOL] [EOL] return json_response ( { [string] : data } ) [EOL] [EOL] @ verify_token async def post ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] data = await self . request . json ( ) [EOL] [EOL] data , errors = CargoSchema ( ) . load ( data ) [EOL] if errors : [EOL] log . info ( errors ) [EOL] return json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] event = { [string] : get_uuid ( ) . hex , [string] : user_id , [string] : data } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] [EOL] return json_response ( { [string] : event [ [string] ] , [string] : f" [string] { event [ [string] ] } [string] " } ) [EOL] [EOL] @ verify_token async def delete ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] cargo_ref = self . request . match_info . get ( [string] ) [EOL] [EOL] deleted_cargo = await delete_cargo ( db = self . db , cargo_ref = cargo_ref , user_id = user_id ) [EOL] [EOL] if deleted_cargo is None : [EOL] log . info ( f" [string] { cargo_ref }" ) [EOL] error = [string] [EOL] return json_response ( { [string] : error } , status = [number] ) [EOL] [EOL] await Spawner . cargo . delete ( name = deleted_cargo . name ) [EOL] [EOL] event = { [string] : user_id , [string] : deleted_cargo . name , } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] message = f" [string] { deleted_cargo . name }" [EOL] return json_response ( { [string] : message } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Tuple , Type [EOL] import typing [EOL] import cargos [EOL] [docstring] [EOL] [EOL] from cargos . views import Cargo [EOL] [EOL] routes = ( ( [string] , [string] , Cargo ) , ( [string] , [string] , Cargo ) , ( [string] , [string] , Cargo ) , ( [string] , [string] , Cargo ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.str,builtins.str,typing.Type[cargos.views.Cargo]],typing.Tuple[builtins.str,builtins.str,typing.Type[cargos.views.Cargo]],typing.Tuple[builtins.str,builtins.str,typing.Type[cargos.views.Cargo]],typing.Tuple[builtins.str,builtins.str,typing.Type[cargos.views.Cargo]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from cargos . routes import routes [EOL] from cargos . models import mCargo , mUser_cargos [EOL] from cargos import events [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] from secrets import token_urlsafe [EOL] [EOL] from rampante import streaming , subscribe_on [EOL] [EOL] from cargos . models import delete_cargo , mCargo [EOL] from spawner import Spawner [EOL] from utils import naminator , query_db [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ subscribe_on ( [string] ) async def create_cargo ( queue , event , app ) : [EOL] [docstring] [EOL] uuid = event [ [string] ] [EOL] user_id = event [ [string] ] [EOL] cargo = event [ [string] ] [EOL] [EOL] access_key = token_urlsafe ( [number] ) . upper ( ) [EOL] secret_key = token_urlsafe ( [number] ) [EOL] [EOL] specs = { [string] : uuid , [string] : access_key , [string] : secret_key , [string] : cargo [ [string] ] , [string] : cargo . get ( [string] , [number] ) , [string] : [number] , [string] : [number] , } [EOL] [EOL] name = naminator ( [string] ) [EOL] [EOL] query = mCargo . insert ( ) . values ( uuid = uuid , user_id = user_id , name = name , specs = specs , ) [EOL] await query_db ( app [ [string] ] , query , get_result = False ) [EOL] [EOL] service = await Spawner . cargo . create ( name = name , user_id = user_id , specs = specs , access_key = access_key , secret_key = secret_key , ) [EOL] [EOL] if not service : [EOL] log . error ( f" [string] { uuid } [string] " ) [EOL] [EOL] await delete_cargo ( db = app [ [string] ] , cargo_ref = uuid , user_id = user_id ) [EOL] log . info ( f" [string] { uuid } [string] " ) [EOL] [EOL] event = { [string] : user_id , [string] : uuid , [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] return [EOL] [EOL] event = { [string] : user_id , [string] : uuid , [string] : name , [string] : specs } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import with_statement [EOL] [EOL] from logging . config import fileConfig [EOL] [EOL] from alembic import context [EOL] from sqlalchemy import create_engine [EOL] [EOL] from config import Config [EOL] [EOL] [comment] [EOL] [comment] [EOL] config = context . config [EOL] [EOL] [comment] [EOL] [comment] [EOL] fileConfig ( config . config_file_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] target_metadata = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] version_table = [string] [EOL] [EOL] [EOL] def run_migrations_offline ( ) : [EOL] [docstring] [EOL] context . configure ( url = Config . make_dsn ( ) , target_metadata = target_metadata , literal_binds = True , version_table = version_table ) [EOL] [EOL] with context . begin_transaction ( ) : [EOL] context . run_migrations ( ) [EOL] [EOL] [EOL] def run_migrations_online ( ) : [EOL] [docstring] [EOL] connectable = create_engine ( Config . make_dsn ( ) ) [EOL] with connectable . connect ( ) as connection : [EOL] context . configure ( connection = connection , target_metadata = target_metadata , version_table = version_table ) [EOL] [EOL] with context . begin_transaction ( ) : [EOL] context . run_migrations ( ) [EOL] [EOL] [EOL] if context . is_offline_mode ( ) : [EOL] run_migrations_offline ( ) [EOL] else : [EOL] run_migrations_online ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from alembic import op [EOL] from sqlalchemy import ( Boolean , Column , DateTime , ForeignKey , Integer , String , func , UniqueConstraint , ) [EOL] from sqlalchemy . dialects . postgresql import JSONB , UUID [EOL] [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = None [EOL] branch_labels = None [EOL] depends_on = None [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] [comment] [EOL] op . create_table ( [string] , Column ( [string] , UUID , primary_key = True ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) , nullable = True ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , Boolean , default = False ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , Integer , nullable = True ) , UniqueConstraint ( [string] , [string] , [string] ) , ) [EOL] [EOL] [comment] [EOL] op . create_table ( [string] , Column ( [string] , UUID , primary_key = True ) , Column ( [string] , String ( [number] ) , unique = True ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , JSONB ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , Integer , default = [number] ) , Column ( [string] , Integer , nullable = False ) , Column ( [string] , UUID , ForeignKey ( [string] ) , nullable = False ) , ) [EOL] [EOL] [comment] [EOL] op . create_table ( [string] , Column ( [string] , UUID , primary_key = True ) , Column ( [string] , String ( [number] ) , unique = True ) , Column ( [string] , JSONB ) , Column ( [string] , Integer , default = [number] ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , Integer , nullable = False ) , ) [EOL] [EOL] op . create_table ( [string] , Column ( [string] , Integer , primary_key = True ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , Integer , nullable = False ) , Column ( [string] , UUID , ForeignKey ( [string] ) , nullable = False ) , ) [EOL] [EOL] [comment] [EOL] op . create_table ( [string] , Column ( [string] , UUID , primary_key = True ) , Column ( [string] , String ( [number] ) , unique = True ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , DateTime ( timezone = True ) , nullable = True ) , Column ( [string] , JSONB ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , Integer , default = [number] ) , Column ( [string] , Integer , nullable = False ) , Column ( [string] , UUID ) , ) [EOL] [EOL] [comment] [EOL] op . create_table ( [string] , Column ( [string] , UUID , primary_key = True ) , Column ( [string] , String ( [number] ) , unique = True ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , JSONB ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , Integer , default = [number] ) , Column ( [string] , Integer , nullable = False ) , Column ( [string] , UUID , ForeignKey ( [string] ) , nullable = False ) , ) [EOL] [EOL] op . create_table ( [string] , Column ( [string] , Integer , primary_key = True ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , UUID , ForeignKey ( [string] ) , nullable = False ) , Column ( [string] , Integer , nullable = False ) , ) [EOL] [EOL] op . create_table ( [string] , Column ( [string] , Integer , primary_key = True ) , Column ( [string] , UUID ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , DateTime , server_default = func . now ( ) ) , Column ( [string] , Integer , nullable = False ) , UniqueConstraint ( [string] , [string] ) , ) [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , IO [EOL] import logging [EOL] import typing [EOL] import tarfile [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import io [EOL] import logging [EOL] import os [EOL] import tarfile [EOL] import tempfile [EOL] [EOL] from blueprints . dockerfile import docker_string [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class CreateFromFile : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , file_path , base_image ) : [EOL] self . file_path = file_path [EOL] self . base_image = base_image [EOL] self . tar_tempfile = None [EOL] [EOL] def __enter__ ( self ) : [EOL] [docstring] [EOL] with tarfile . open ( self . file_path , [string] ) as tarobj : [EOL] [EOL] self . tar_tempfile = tempfile . TemporaryFile ( ) [EOL] new_tarobj = tarfile . open ( mode = [string] , fileobj = self . tar_tempfile ) [EOL] [EOL] requirements = False [EOL] [EOL] members = tarobj . getmembers ( ) [EOL] [EOL] log . info ( [string] ) [EOL] [EOL] for member in members : [EOL] [EOL] [comment] [EOL] if member . name == [string] : [EOL] requirements = True [EOL] [EOL] if member . name != [string] : [EOL] try : [EOL] file_inside_tar = tarobj . extractfile ( member . path ) [EOL] new_tarobj . addfile ( member , file_inside_tar ) [EOL] except KeyError : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if requirements is False : [EOL] file = [string] [EOL] file_info = tarfile . TarInfo ( [string] ) [EOL] file_info . size = len ( file ) [EOL] new_tarobj . addfile ( file_info , io . BytesIO ( file ) ) [EOL] [EOL] [comment] [EOL] docker_file = docker_string . format ( image = self . base_image ) . encode ( [string] ) [EOL] docker_file_info = tarfile . TarInfo ( [string] ) [EOL] docker_file_info . size = len ( docker_file ) [EOL] new_tarobj . addfile ( docker_file_info , io . BytesIO ( docker_file ) ) [EOL] [EOL] [comment] [EOL] new_tarobj . close ( ) [EOL] [EOL] log . info ( f" [string] { self . file_path } [string] " ) [EOL] [EOL] self . tar_tempfile . seek ( [number] ) [EOL] return self . tar_tempfile [EOL] [EOL] def __exit__ ( self , exc_type , exc , tb ) : [EOL] [docstring] [EOL] self . tar_tempfile . close ( ) [EOL] os . remove ( self . file_path ) [EOL] log . info ( f" [string] { self . file_path } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[tarfile.TarInfo]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.List[tarfile.TarInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 $typing.Optional[typing.IO[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $tarfile.TarInfo$ 0 0 0 0 0 0 0 0 $tarfile.TarInfo$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 $tarfile.TarFile$ 0 0 0 $tarfile.TarInfo$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarInfo$ 0 0 0 0 0 0 0 0 $tarfile.TarInfo$ 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 $tarfile.TarFile$ 0 0 0 $tarfile.TarInfo$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import aiohttp [EOL] from rampante import streaming , subscribe_on [EOL] [EOL] from blueprints . build_from_file import CreateFromFile [EOL] from blueprints . build_from_s3 import CreateFromS3 [EOL] from blueprints . models import upsert_blueprint [EOL] from config import Config [EOL] from spawner import Spawner [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ subscribe_on ( [string] ) async def create_blueprint ( queue , event , app ) : [EOL] [docstring] [EOL] user_id = event [ [string] ] [EOL] user = event [ [string] ] . replace ( [string] , [string] ) [EOL] blueprint = event [ [string] ] [EOL] registry = [string] [EOL] [EOL] image_name = f"{ registry } [string] { user } [string] { blueprint [ [string] ] } [string] { blueprint [ [string] ] }" [EOL] [EOL] if [string] in event : [EOL] with CreateFromFile ( event [ [string] ] , event [ [string] ] ) as fo : [EOL] await Spawner . blueprint . create ( fileobj = fo , name = image_name , ) [EOL] else : [EOL] s3_key = event [ [string] ] [EOL] s3_skey = event [ [string] ] [EOL] cargo = event [ [string] ] [EOL] [EOL] async with CreateFromS3 ( s3_key = s3_key , s3_skey = s3_skey , cargo = cargo , base_image = event [ [string] ] , bucket = blueprint [ [string] ] , ) as fo : [EOL] await Spawner . blueprint . create ( fileobj = fo , name = image_name , ) [EOL] [EOL] log . info ( f" [string] { image_name } [string] " ) [EOL] await Spawner . blueprint . push ( name = image_name , username = Config . REGISTRY_USER , password = Config . REGISTRY_PASSWORD ) [EOL] [EOL] log . info ( f" [string] { image_name } [string] " ) [EOL] await upsert_blueprint ( db = app [ [string] ] , uuid = event [ [string] ] , repository = f"{ registry } [string] { user }" , name = blueprint [ [string] ] , tag = blueprint [ [string] ] , user_id = user_id , description = blueprint [ [string] ] ) [EOL] [EOL] event = { [string] : user_id , [string] : event [ [string] ] , [string] : image_name , } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] [EOL] [EOL] @ subscribe_on ( [string] ) async def remove_image ( queue , event , app ) : [EOL] [docstring] [EOL] [EOL] repository = event [ [string] ] . replace ( [string] , [string] ) [EOL] tag = event [ [string] ] [EOL] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] url = f"{ Config . REGISTRY_URI } [string] { repository } [string] { tag }" [EOL] headers = { [string] : [string] } [EOL] async with session . head ( url , headers = headers ) as resp : [EOL] digest = resp . headers . get ( [string] ) [EOL] if resp . status // [number] == [number] and digest : [EOL] url = f"{ Config . REGISTRY_URI } [string] { repository } [string] { digest }" [EOL] async with session . delete ( url ) as resp : [EOL] if resp . status // [number] == [number] : [EOL] log . info ( f" [string] { event [ [string] ] } [string] { tag } [string] " ) [EOL] else : [EOL] payload = await resp . json ( ) [EOL] log . info ( f" [string] { repository } [string] { tag } [string] { url } [string] { resp . status } [string] { payload }" ) [EOL] else : [EOL] payload = await resp . json ( ) [EOL] log . info ( f" [string] { repository } [string] { tag } [string] { url } [string] { resp . status } [string] { payload }" ) [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import logging [EOL] import typing [EOL] import tarfile [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import io [EOL] import logging [EOL] import tarfile [EOL] import tempfile [EOL] [EOL] import aiobotocore [EOL] [EOL] from blueprints . dockerfile import docker_string [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class CreateFromS3 : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cargo , s3_key , s3_skey , base_image , bucket ) : [EOL] self . bucket = bucket [EOL] self . s3_key = s3_key [EOL] self . s3_skey = s3_skey [EOL] self . cargo = cargo [EOL] self . base_image = base_image [EOL] [EOL] async def __aenter__ ( self ) : [EOL] session = aiobotocore . get_session ( ) [EOL] [EOL] self . tar_tempfile = tempfile . TemporaryFile ( ) [EOL] tarobj = tarfile . open ( mode = [string] , fileobj = self . tar_tempfile ) [EOL] [EOL] async with session . create_client ( [string] , endpoint_url = f" [string] { self . cargo } [string] " , aws_secret_access_key = self . s3_skey , aws_access_key_id = self . s3_key ) as client : [EOL] [EOL] [comment] [EOL] resp = await client . list_objects ( Bucket = self . bucket ) [EOL] set_objects = { obj [ [string] ] for obj in resp [ [string] ] } [EOL] [EOL] log . info ( f" [string] { len ( set_objects ) } [string] { self . cargo } [string] { self . bucket }" ) [EOL] [comment] [EOL] for obj in set_objects : [EOL] [comment] [EOL] response = await client . get_object ( Bucket = self . bucket , Key = obj ) [EOL] [EOL] [comment] [EOL] async with response [ [string] ] as stream : [EOL] with tempfile . TemporaryFile ( ) as tmp : [EOL] tmp . write ( await stream . read ( ) ) [EOL] tmp . seek ( [number] ) [EOL] dfinfo = tarobj . gettarinfo ( fileobj = tmp , arcname = obj ) [EOL] tarobj . addfile ( dfinfo , tmp ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] not in set_objects : [EOL] file = [string] [EOL] file_info = tarfile . TarInfo ( [string] ) [EOL] file_info . size = len ( file ) [EOL] tarobj . addfile ( file_info , io . BytesIO ( file ) ) [EOL] [EOL] [comment] [EOL] docker_file = docker_string . format ( image = self . base_image ) . encode ( [string] ) [EOL] docker_file_info = tarfile . TarInfo ( [string] ) [EOL] docker_file_info . size = len ( docker_file ) [EOL] tarobj . addfile ( docker_file_info , io . BytesIO ( docker_file ) ) [EOL] [EOL] [comment] [EOL] tarobj . close ( ) [EOL] self . tar_tempfile . seek ( [number] ) [EOL] [EOL] log . info ( [string] ) [EOL] [EOL] return self . tar_tempfile [EOL] [EOL] async def __aexit__ ( self , exc_type , exc , tb ) : [EOL] [docstring] [EOL] self . tar_tempfile . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarInfo$ 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 $tarfile.TarInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $builtins.str$ 0 0 0 $tarfile.TarInfo$ 0 0 0 0 0 0 0 0 $tarfile.TarInfo$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 $tarfile.TarFile$ 0 0 0 $tarfile.TarInfo$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tarfile.TarInfo$ 0 0 0 0 0 0 0 0 $tarfile.TarInfo$ 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 $tarfile.TarFile$ 0 0 0 $tarfile.TarInfo$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $tarfile.TarFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import uuid [EOL] [EOL] from psycopg2 import IntegrityError [EOL] from sqlalchemy import ( Boolean , Column , DateTime , Integer , String , Table , UniqueConstraint , ) [EOL] from sqlalchemy . dialects . postgresql import UUID [EOL] from sqlalchemy . sql import func , select [EOL] [EOL] from factory import metadata [EOL] [EOL] mBlueprint = Table ( [string] , metadata , Column ( [string] , UUID , primary_key = True ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , String ( [number] ) , nullable = True ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , Boolean , default = False ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , Integer , nullable = True ) , UniqueConstraint ( [string] , [string] , [string] ) , ) [EOL] [EOL] [EOL] async def join_blueprints_with ( model , user_id , db ) : [EOL] query = select ( [ model , mBlueprint . c . name . label ( [string] ) , mBlueprint . c . repository . label ( [string] ) , mBlueprint . c . tag . label ( [string] ) , ] ) . where ( model . c . user_id == user_id ) . select_from ( model . outerjoin ( mBlueprint , model . c . blueprint_uuid == mBlueprint . c . uuid ) ) [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query ) [EOL] rows = await result . fetchall ( ) [EOL] return rows [EOL] [EOL] [EOL] async def get_blueprints ( db , user_id ) : [EOL] query = mBlueprint . select ( ) . where ( ( mBlueprint . c . public . is_ ( True ) ) | ( mBlueprint . c . user_id == user_id ) ) [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query ) [EOL] rows = await result . fetchall ( ) [EOL] return rows [EOL] [EOL] [EOL] async def get_blueprint ( db , blueprint_ref , user_id ) : [EOL] try : [EOL] uuid . UUID ( blueprint_ref ) [EOL] except ValueError : [EOL] [comment] [EOL] blueprint_data = blueprint_ref . split ( [string] ) [EOL] tag = [string] [EOL] [EOL] if len ( blueprint_data ) == [number] : [EOL] repository , name = blueprint_data [EOL] [EOL] name_data = name . split ( [string] ) [EOL] if len ( name_data ) == [number] : [EOL] name , tag = name_data [EOL] [EOL] elif len ( blueprint_data ) == [number] : [EOL] repository = [string] . join ( blueprint_data [ : [number] ] ) [EOL] name = blueprint_data [ - [number] ] [EOL] [EOL] name_data = name . split ( [string] ) [EOL] if len ( name_data ) == [number] : [EOL] name , tag = name_data [EOL] [EOL] else : [EOL] return None [EOL] [EOL] query = mBlueprint . select ( ) . where ( ( ( mBlueprint . c . repository == repository ) & ( mBlueprint . c . name == name ) & ( mBlueprint . c . tag == tag ) ) & ( ( mBlueprint . c . user_id == user_id ) | ( mBlueprint . c . public . is_ ( True ) ) ) ) [EOL] else : [EOL] query = mBlueprint . select ( ) . where ( ( mBlueprint . c . uuid == blueprint_ref ) & ( ( mBlueprint . c . user_id == user_id ) | ( mBlueprint . c . public . is_ ( True ) ) ) ) [EOL] [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query ) [EOL] row = await result . fetchone ( ) [EOL] return row [EOL] [EOL] [EOL] async def get_your_blueprint ( db , blueprint_ref , user_id ) : [EOL] [docstring] [EOL] try : [EOL] uuid . UUID ( blueprint_ref ) [EOL] except ValueError : [EOL] [comment] [EOL] blueprint_data = blueprint_ref . split ( [string] ) [EOL] tag = [string] [EOL] [EOL] if len ( blueprint_data ) == [number] : [EOL] repository , name = blueprint_data [EOL] [EOL] name_data = name . split ( [string] ) [EOL] if len ( name_data ) == [number] : [EOL] name , tag = name_data [EOL] [EOL] elif len ( blueprint_data ) == [number] : [EOL] repository = [string] . join ( blueprint_data [ : [number] ] ) [EOL] name = blueprint_data [ - [number] ] [EOL] [EOL] name_data = name . split ( [string] ) [EOL] if len ( name_data ) == [number] : [EOL] name , tag = name_data [EOL] [EOL] else : [EOL] return None [EOL] [EOL] query = mBlueprint . select ( ) . where ( ( ( mBlueprint . c . repository == repository ) & ( mBlueprint . c . name == name ) & ( mBlueprint . c . tag == tag ) ) & ( mBlueprint . c . user_id == user_id ) ) [EOL] else : [EOL] query = mBlueprint . select ( ) . where ( ( mBlueprint . c . uuid == blueprint_ref ) & ( mBlueprint . c . user_id == user_id ) ) [EOL] [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query ) [EOL] row = await result . fetchone ( ) [EOL] return row [EOL] [EOL] [EOL] async def delete_blueprint ( db , blueprint_ref , user_id ) : [EOL] [docstring] [EOL] blueprint = await get_your_blueprint ( db , blueprint_ref , user_id ) [EOL] if blueprint : [EOL] query = mBlueprint . delete ( ) . where ( mBlueprint . c . uuid == blueprint . uuid ) [EOL] async with db . acquire ( ) as conn : [EOL] await conn . execute ( query ) [EOL] return blueprint [EOL] return None [EOL] [EOL] [EOL] async def upsert_blueprint ( db , uuid , repository , user_id , name , tag , description ) : [EOL] [docstring] [EOL] query = mBlueprint . insert ( ) . values ( uuid = uuid , repository = repository , name = name , tag = tag , user_id = user_id , description = description ) [EOL] [EOL] try : [EOL] async with db . acquire ( ) as conn : [EOL] await conn . execute ( query ) [EOL] except IntegrityError : [EOL] query = mBlueprint . update ( ) . where ( ( mBlueprint . c . repository == repository ) & ( mBlueprint . c . name == name ) & ( mBlueprint . c . tag == tag ) ) . values ( uuid = uuid , description = description , created_at = func . now ( ) ) [EOL] [EOL] async with db . acquire ( ) as conn : [EOL] await conn . execute ( query ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from blueprints . routes import routes [EOL] from blueprints . models import mBlueprint [EOL] from blueprints import events [EOL] [EOL] __all__ = ( [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0
from typing import Tuple , Type [EOL] import typing [EOL] import blueprints [EOL] [docstring] [EOL] [EOL] from blueprints . views import ( Blueprint , BlueprintFromFolder , BuildFromS3 , ) [EOL] [EOL] routes = ( ( [string] , [string] , Blueprint ) , ( [string] , [string] , Blueprint ) , ( [string] , [string] , BuildFromS3 ) , ( [string] , [string] , BlueprintFromFolder ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.str,builtins.str,typing.Type[blueprints.views.Blueprint]],typing.Tuple[builtins.str,builtins.str,typing.Type[blueprints.views.Blueprint]],typing.Tuple[builtins.str,builtins.str,typing.Type[blueprints.views.BuildFromS3]],typing.Tuple[builtins.str,builtins.str,typing.Type[blueprints.views.BlueprintFromFolder]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import blueprints [EOL] [docstring] [EOL] [EOL] [EOL] from marshmallow import Schema , fields [EOL] [EOL] [EOL] class BlueprintForProbeSchema ( Schema ) : [EOL] value = fields . Int ( attribute = [string] ) [EOL] text = fields . Str ( attribute = [string] ) [EOL] [EOL] [EOL] class CreateBlueprint ( Schema ) : [EOL] name = fields . Str ( required = True ) [EOL] tag = fields . Str ( required = True ) [EOL] base_image = fields . Str ( required = True ) [EOL] description = fields . Str ( required = True ) [EOL] [EOL] [EOL] class CreateBlueprintFromCargo ( Schema ) : [EOL] name = fields . Str ( required = True ) [EOL] tag = fields . Str ( required = True ) [EOL] base_image = fields . Str ( required = True ) [EOL] description = fields . Str ( required = True ) [EOL] cargo = fields . Str ( required = True ) [EOL] bucket = fields . Str ( required = True ) [EOL] [EOL] [EOL] class BlueprintSchema ( Schema ) : [EOL] uuid = fields . Str ( ) [EOL] repository = fields . Str ( ) [EOL] name = fields . Str ( ) [EOL] tag = fields . Str ( ) [EOL] link = fields . Str ( ) [EOL] description = fields . Str ( ) [EOL] public = fields . Bool ( ) [EOL] created_at = fields . DateTime ( format = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import os [EOL] import tarfile [EOL] [EOL] import aiohttp [EOL] from aiohttp . web import json_response [EOL] from rampante import streaming [EOL] [EOL] from blueprints . models import ( delete_blueprint , get_blueprint , get_blueprints , ) [EOL] from blueprints . serializers import ( BlueprintSchema , CreateBlueprint , CreateBlueprintFromCargo , ) [EOL] from cargos . models import get_cargo [EOL] from config import Config [EOL] from utils import WebView , get_uuid , verify_token [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Blueprint ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def get ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] [EOL] rows = await get_blueprints ( self . db , user_id = user_id ) [EOL] [EOL] blueprints , errors = BlueprintSchema ( many = True ) . dump ( rows ) [EOL] [EOL] if errors : [EOL] json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] return json_response ( { [string] : blueprints } ) [EOL] [EOL] @ verify_token async def delete ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] data = await self . request . json ( ) [EOL] [EOL] if [string] not in data : [EOL] log . info ( f" [string] { data [ [string] ] }" ) [EOL] error = [string] [EOL] return json_response ( { [string] : error } , status = [number] ) [EOL] [EOL] blueprint = await delete_blueprint ( self . db , blueprint_ref = data [ [string] ] , user_id = user_id ) [EOL] if blueprint is None : [EOL] log . info ( f" [string] { data [ [string] ] }" ) [EOL] error = f" [string] { data [ [string] ] } [string] " [EOL] return json_response ( { [string] : error } , status = [number] ) [EOL] [EOL] repository = f"{ blueprint . repository } [string] { blueprint . name }" [EOL] [EOL] event = { [string] : blueprint . uuid , [string] : user_id , [string] : repository , [string] : blueprint . tag } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] message = f" [string] { repository } [string] { blueprint . tag }" [EOL] return json_response ( { [string] : message } ) [EOL] [EOL] [EOL] class BuildFromS3 ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def post ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] data = await self . request . json ( ) [EOL] [EOL] blueprint , errors = CreateBlueprintFromCargo ( ) . load ( data ) [EOL] if errors : [EOL] json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] cargo = await get_cargo ( self . db , user_id = user_id , cargo_ref = blueprint [ [string] ] ) [EOL] if cargo is None : [EOL] error = [string] [EOL] return json_response ( { [string] : error } , status = [number] ) [EOL] [EOL] base_blueprint = await get_blueprint ( self . db , blueprint_ref = blueprint [ [string] ] , user_id = user_id ) [EOL] if base_blueprint is None : [EOL] error = [string] [EOL] return json_response ( { [string] : error } , status = [number] ) [EOL] [EOL] base_image = f"{ base_blueprint . repository } [string] { base_blueprint . name } [string] { base_blueprint . tag }" [EOL] [EOL] uuid = get_uuid ( ) . hex [EOL] event = { [string] : uuid , [string] : user_id , [string] : payload [ [string] ] , [string] : cargo . name , [string] : cargo . specs [ [string] ] , [string] : cargo . specs [ [string] ] , [string] : blueprint , [string] : base_image , } [EOL] await streaming . publish ( [string] , event ) [EOL] [EOL] return json_response ( { [string] : f" [string] { uuid } [string] " } ) [EOL] [EOL] [EOL] class BlueprintFromFolder ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def post ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] uuid = get_uuid ( ) . hex [EOL] [EOL] [comment] [EOL] reader = await self . request . multipart ( ) [EOL] [EOL] while True : [EOL] part = await reader . next ( ) [EOL] [EOL] if part is None : [EOL] break [EOL] [EOL] if part . headers [ aiohttp . hdrs . CONTENT_TYPE ] == [string] : [EOL] data = await part . json ( ) [EOL] blueprint , errors = CreateBlueprint ( ) . load ( data ) [EOL] if errors : [EOL] return json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] base_blueprint = await get_blueprint ( self . db , blueprint_ref = blueprint [ [string] ] , user_id = user_id ) [EOL] if base_blueprint is None : [EOL] error = [string] [EOL] return json_response ( { [string] : error } , status = [number] ) [EOL] [EOL] continue [EOL] [EOL] file_uuid = f"{ uuid } [string] " [EOL] file_path = os . path . join ( Config . TEMP_BUILD_FOLDER , file_uuid ) [EOL] [EOL] await write_file ( file_path = file_path , part = part ) [EOL] [EOL] if tarfile . is_tarfile ( file_path ) is False : [EOL] os . remove ( file_path ) [EOL] return json_response ( { [string] : [string] } , status = [number] ) [EOL] [EOL] base_image = f"{ base_blueprint . repository } [string] { base_blueprint . name } [string] { base_blueprint . tag }" [EOL] [EOL] event = { [string] : uuid , [string] : user_id , [string] : payload [ [string] ] , [string] : file_path , [string] : blueprint , [string] : base_image } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] [EOL] return json_response ( { [string] : f" [string] { uuid } [string] " } ) [EOL] [EOL] [EOL] async def write_file ( file_path , part ) : [EOL] [comment] [EOL] size = [number] [EOL] with open ( file_path , [string] ) as f : [EOL] while True : [EOL] chunk = await part . read_chunk ( ) [EOL] if not chunk : [EOL] break [EOL] size += len ( chunk ) [EOL] f . write ( chunk ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] docker_string = [string] [EOL]	0 $builtins.str$ 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jobs . routes import routes [EOL] from jobs . models import mJob [EOL] from jobs import events [EOL] [EOL] __all__ = ( [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from rampante import streaming [EOL] [EOL] from spawner import Spawner [EOL] [EOL] [EOL] async def delete_a_job ( job_uuid , job_name , user_id ) : [EOL] await Spawner . job . delete ( name = job_name ) [EOL] [EOL] event = { [string] : job_uuid , [string] : user_id , [string] : job_name , } [EOL] await streaming . publish ( [string] , event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Mapping , Dict , Any [EOL] import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import logging [EOL] from typing import Any , Mapping [EOL] [EOL] from aiohttp . web import json_response [EOL] from rampante import streaming [EOL] [EOL] from blueprints . models import join_blueprints_with [EOL] from jobs . helpers import delete_a_job [EOL] from jobs . models import mJob , select_job , update_job_status [EOL] from jobs . serializers import JobSchema [EOL] from spawner import Spawner [EOL] from utils import WebView , get_uuid , verify_token [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Jobs ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def get ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] [EOL] jobs = await join_blueprints_with ( model = mJob , db = self . db , user_id = user_id ) [EOL] job_schema = JobSchema ( many = True ) [EOL] job_schema . context = { [string] : user_id } [EOL] [EOL] data , errors = job_schema . dump ( jobs ) [EOL] [EOL] if errors : [EOL] return json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] return json_response ( { [string] : data } ) [EOL] [EOL] @ verify_token async def post ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] data = await self . request . json ( ) [EOL] [EOL] data , errors = JobSchema ( ) . load ( data ) [EOL] if errors : [EOL] log . debug ( errors ) [EOL] return json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] event = { [string] : get_uuid ( ) . hex , [string] : user_id , [string] : data } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] [EOL] return json_response ( { [string] : event [ [string] ] , [string] : f" [string] { event [ [string] ] } [string] " } ) [EOL] [EOL] @ verify_token async def delete ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] job_ref = self . request . match_info . get ( [string] ) [EOL] [EOL] deleted_job = await update_job_status ( self . db , job_ref = job_ref , user_id = user_id ) [EOL] [EOL] if deleted_job is None : [EOL] error = f" [string] { job_ref } [string] " [EOL] return json_response ( { [string] : error } , status = [number] ) [EOL] [EOL] await delete_a_job ( deleted_job . uuid , deleted_job . name , user_id ) [EOL] [EOL] user_message = f" [string] { deleted_job . name } [string] " [EOL] return json_response ( { [string] : user_message } ) [EOL] [EOL] [EOL] class Logs ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def get ( self , payload ) : [EOL] user_id = payload [ [string] ] [EOL] job_ref = self . request . match_info . get ( [string] ) [EOL] [EOL] selected_job = await select_job ( db = self . db , job_ref = job_ref , user_id = user_id ) [EOL] [EOL] if selected_job is None : [EOL] user_message = f" [string] { job_ref } [string] " [EOL] return json_response ( { [string] : user_message } , status = [number] ) [EOL] [EOL] logs = await Spawner . job . logs ( name = selected_job . name ) [EOL] return json_response ( { [string] : logs } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] from rampante import streaming , subscribe_on [EOL] [EOL] from blueprints . models import get_blueprint [EOL] from jobs . models import mJob [EOL] from spawner import Spawner [EOL] from utils import naminator , query_db [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ subscribe_on ( [string] ) async def create_job ( queue , event , app ) : [EOL] [docstring] [EOL] user_id = event [ [string] ] [EOL] job = event [ [string] ] [EOL] uuid = event [ [string] ] [EOL] [EOL] blueprint = await get_blueprint ( app [ [string] ] , blueprint_ref = job [ [string] ] , user_id = user_id ) [EOL] [EOL] if blueprint is None : [EOL] log . info ( f"{ uuid } [string] { job [ [string] ] } [string] " ) [EOL] [EOL] event = { [string] : user_id , [string] : { [string] : [string] , [string] : f"{ job [ [string] ] } [string] " , } } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] return [EOL] [EOL] name = naminator ( [string] ) [EOL] [EOL] specs = { [string] : uuid , [string] : blueprint . repository , [string] : f"{ blueprint . name } [string] { blueprint . tag }" , [string] : [ [string] ] , [string] : job [ [string] ] , [string] : job [ [string] ] , [string] : job [ [string] ] , } [EOL] [EOL] query = mJob . insert ( ) . values ( uuid = uuid , user_id = user_id , blueprint_uuid = blueprint . uuid , name = name , description = job [ [string] ] , specs = specs , ) [EOL] await query_db ( app [ [string] ] , query , get_result = False ) [EOL] [EOL] service = await Spawner . job . create ( name = name , user_id = user_id , specs = specs , ) [EOL] [EOL] if not service : [EOL] log . error ( f" [string] { uuid } [string] " ) [EOL] return [EOL] [EOL] event = { [string] : user_id , [string] : uuid , [string] : name , [string] : specs } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import uuid [EOL] [EOL] from sqlalchemy import ( Column , DateTime , Integer , String , Table , ) [EOL] from sqlalchemy . dialects . postgresql import JSONB , UUID [EOL] from sqlalchemy . sql import func , select [EOL] [EOL] from factory import metadata [EOL] [EOL] mJob = Table ( [string] , metadata , Column ( [string] , UUID , primary_key = True ) , Column ( [string] , String ( [number] ) , unique = True ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , DateTime ( timezone = True ) , nullable = True ) , Column ( [string] , JSONB ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , Integer , default = [number] ) , Column ( [string] , Integer , nullable = False ) , Column ( [string] , UUID ) , ) [EOL] [EOL] [EOL] async def update_job_status ( db , job_ref , user_id ) : [EOL] [docstring] [EOL] try : [EOL] uuid . UUID ( job_ref ) [EOL] except ValueError : [EOL] query = mJob . update ( ) . where ( ( mJob . c . user_id == user_id ) & ( mJob . c . name == job_ref ) ) [EOL] else : [EOL] query = mJob . update ( ) . where ( ( mJob . c . user_id == user_id ) & ( mJob . c . uuid == job_ref ) ) [EOL] [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query . values ( deleted_at = func . now ( ) ) . returning ( mJob . c . uuid , mJob . c . name ) ) [EOL] row = await result . fetchone ( ) [EOL] return row [EOL] [EOL] [EOL] async def update_job_status_with_uuid ( db , job_uuid ) : [EOL] [docstring] [EOL] [EOL] query = mJob . update ( ) . where ( mJob . c . uuid == job_uuid ) . values ( deleted_at = func . now ( ) ) [EOL] [EOL] async with db . acquire ( ) as conn : [EOL] await conn . execute ( query ) [EOL] [EOL] [EOL] async def select_job ( db , job_ref , user_id ) : [EOL] [docstring] [EOL] try : [EOL] uuid . UUID ( job_ref ) [EOL] except ValueError : [EOL] query = select ( [ mJob ] ) . where ( ( mJob . c . user_id == user_id ) & ( mJob . c . name == job_ref ) ) [EOL] else : [EOL] query = select ( [ mJob ] ) . where ( ( mJob . c . user_id == user_id ) & ( mJob . c . uuid == job_ref ) ) [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query ) [EOL] row = await result . fetchone ( ) [EOL] return row [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Type [EOL] import jobs [EOL] import typing [EOL] [docstring] [EOL] [EOL] from jobs . views import Jobs , Logs [EOL] [EOL] routes = ( ( [string] , [string] , Jobs ) , ( [string] , [string] , Jobs ) , ( [string] , [string] , Jobs ) , ( [string] , [string] , Jobs ) , ( [string] , [string] , Logs ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.str,builtins.str,typing.Type[jobs.views.Jobs]],typing.Tuple[builtins.str,builtins.str,typing.Type[jobs.views.Jobs]],typing.Tuple[builtins.str,builtins.str,typing.Type[jobs.views.Jobs]],typing.Tuple[builtins.str,builtins.str,typing.Type[jobs.views.Jobs]],typing.Tuple[builtins.str,builtins.str,typing.Type[jobs.views.Logs]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Mapping , Dict , Any [EOL] import logging [EOL] import types [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import functools [EOL] import logging [EOL] from types import MappingProxyType [EOL] from typing import Any , Mapping , Optional [EOL] [EOL] import jwt [EOL] from aiohttp import web [EOL] from aiohttp . abc import AbstractView [EOL] from jwt . exceptions import ( DecodeError , ExpiredSignatureError , ) [EOL] [EOL] from config import Config as C [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def _validate_token ( headers , key = C . PUBLIC_KEY ) : [EOL] [docstring] [EOL] payload = None [EOL] if [string] in headers : [EOL] try : [EOL] encoded = headers [ [string] ] . split ( [string] ) [ [number] ] [EOL] data = jwt . decode ( encoded , key ) [EOL] payload = { ** data , [string] : encoded } [EOL] except ( IndexError , DecodeError , ExpiredSignatureError ) : [EOL] log . info ( f" [string] " ) [EOL] return payload [EOL] [EOL] [EOL] def verify_token ( func ) : [EOL] [docstring] [EOL] @ functools . wraps ( func ) async def wrapped ( * args , ** kwargs ) : [EOL] [EOL] [comment] [EOL] if isinstance ( args [ [number] ] , AbstractView ) : [EOL] request = args [ [number] ] . request [EOL] else : [EOL] request = args [ - [number] ] [EOL] [EOL] [comment] [EOL] payload = _validate_token ( request . headers ) [EOL] [EOL] if payload is None : [EOL] message = [string] [EOL] return web . json_response ( { [string] : message } , status = [number] ) [EOL] else : [EOL] payload = MappingProxyType ( payload ) [EOL] response = await func ( * args , payload = payload , ** kwargs ) [EOL] return response [EOL] return wrapped [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Mapping[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from aiohttp import web [EOL] [EOL] from config import Config [EOL] [EOL] [EOL] async def query_db ( db , query , many = False , get_result = True ) : [EOL] [docstring] [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query ) [EOL] if get_result : [EOL] if not many : [EOL] row = await result . fetchone ( ) [EOL] return row [EOL] rows = await result . fetchall ( ) [EOL] return rows [EOL] [EOL] [EOL] class WebView ( web . View ) : [EOL] [docstring] [EOL] [EOL] @ property def config ( self ) : [EOL] [docstring] [EOL] return Config [EOL] [EOL] @ property def db ( self ) : [EOL] [docstring] [EOL] return self . request . app [ [string] ] [EOL] [EOL] async def query_db ( self , query , many = False , get_result = True ) : [EOL] [docstring] [EOL] return await query_db ( self . db , query = query , many = many , get_result = get_result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from utils . server import WebView , query_db [EOL] from utils . random_generator import get_uuid , naminator [EOL] from utils . auth import verify_token [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence , Set , Tuple [EOL] import typing [EOL] import uuid [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import random [EOL] import secrets [EOL] from typing import Sequence [EOL] from uuid import UUID , uuid1 [EOL] [EOL] [comment] [EOL] _adjectives = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] _nouns = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def naminator ( name_type , * , delimiter = [string] , token_length = [number] , token_hex = False ) : [EOL] [docstring] [EOL] [EOL] correct_type = { [string] , [string] , [string] , [string] } [EOL] if name_type not in correct_type : [EOL] raise TypeError ( f" [string] { name_type }" ) [EOL] [EOL] token_chars = [string] [EOL] [EOL] if token_hex : [EOL] token_chars = [string] [EOL] [EOL] [comment] [EOL] values = _random_element ( _adjectives ) , _random_element ( _nouns ) [EOL] name = [string] . join ( values ) [EOL] token = [string] . join ( _random_element ( token_chars ) for _ in range ( token_length ) ) [EOL] [EOL] sections = ( name_type , name , token ) [EOL] return delimiter . join ( filter ( None , sections ) ) [EOL] [EOL] [EOL] def _random_element ( strings ) : [EOL] [docstring] [EOL] [EOL] return secrets . choice ( strings ) [EOL] [EOL] [EOL] def get_uuid ( ) : [EOL] [docstring] [EOL] return uuid1 ( ( random . getrandbits ( [number] ) | [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Type [EOL] import typing [EOL] import apis [EOL] [docstring] [EOL] [EOL] from apis . views import APIs , Logs [EOL] [EOL] routes = ( ( [string] , [string] , APIs ) , ( [string] , [string] , APIs ) , ( [string] , [string] , APIs ) , ( [string] , [string] , APIs ) , ( [string] , [string] , Logs ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.str,builtins.str,typing.Type[apis.views.APIs]],typing.Tuple[builtins.str,builtins.str,typing.Type[apis.views.APIs]],typing.Tuple[builtins.str,builtins.str,typing.Type[apis.views.APIs]],typing.Tuple[builtins.str,builtins.str,typing.Type[apis.views.APIs]],typing.Tuple[builtins.str,builtins.str,typing.Type[apis.views.Logs]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import uuid [EOL] [EOL] from sqlalchemy import ( Column , DateTime , ForeignKey , Integer , String , Table , ) [EOL] from sqlalchemy . dialects . postgresql import JSONB , UUID [EOL] from sqlalchemy . sql import func , select [EOL] [EOL] from factory import metadata [EOL] [EOL] mApi = Table ( [string] , metadata , Column ( [string] , UUID , primary_key = True ) , Column ( [string] , String ( [number] ) , unique = True ) , Column ( [string] , DateTime ( timezone = True ) , server_default = func . now ( ) ) , Column ( [string] , JSONB ) , Column ( [string] , String ( [number] ) ) , Column ( [string] , Integer , default = [number] ) , Column ( [string] , Integer , nullable = False ) , Column ( [string] , UUID , ForeignKey ( [string] ) , nullable = False ) , ) [EOL] [EOL] [EOL] async def delete_api ( db , api_ref , user_id ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] uuid . UUID ( api_ref ) [EOL] except ValueError : [EOL] query = mApi . delete ( ) . where ( ( mApi . c . user_id == user_id ) & ( mApi . c . name == api_ref ) ) [EOL] else : [EOL] query = mApi . delete ( ) . where ( ( mApi . c . user_id == user_id ) & ( mApi . c . uuid == api_ref ) ) [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query . returning ( mApi . c . uuid , mApi . c . name ) ) [EOL] row = await result . fetchone ( ) [EOL] return row [EOL] [EOL] [EOL] async def select_api ( db , api_ref , user_id ) : [EOL] [docstring] [EOL] try : [EOL] uuid . UUID ( api_ref ) [EOL] except ValueError : [EOL] query = select ( [ mApi ] ) . where ( ( mApi . c . user_id == user_id ) & ( mApi . c . name == api_ref ) ) [EOL] else : [EOL] query = select ( [ mApi ] ) . where ( ( mApi . c . user_id == user_id ) & ( mApi . c . uuid == api_ref ) ) [EOL] async with db . acquire ( ) as conn : [EOL] result = await conn . execute ( query ) [EOL] row = await result . fetchone ( ) [EOL] return row [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from apis . routes import routes [EOL] from apis . models import mApi [EOL] from apis import events [EOL] [EOL] __all__ = ( [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] from rampante import streaming , subscribe_on [EOL] [EOL] from apis . models import delete_api , mApi [EOL] from blueprints . models import get_blueprint [EOL] from spawner import Spawner [EOL] from utils import naminator , query_db [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ subscribe_on ( [string] ) async def create_api ( queue , event , app ) : [EOL] [docstring] [EOL] user_id = event [ [string] ] [EOL] api = event [ [string] ] [EOL] uuid = event [ [string] ] [EOL] [EOL] blueprint = await get_blueprint ( app [ [string] ] , blueprint_ref = api [ [string] ] , user_id = user_id ) [EOL] [EOL] if blueprint is None : [EOL] log . info ( f"{ uuid } [string] { api [ [string] ] } [string] " ) [EOL] [EOL] event = { [string] : user_id , [string] : { [string] : [string] , [string] : f"{ api [ [string] ] } [string] " , } } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] return [EOL] [EOL] name = naminator ( [string] ) [EOL] [EOL] specs = { [string] : uuid , [string] : blueprint . repository , [string] : f"{ blueprint . name } [string] { blueprint . tag }" , [string] : [ [string] ] , [string] : api [ [string] ] , [string] : api [ [string] ] , [string] : api [ [string] ] , } [EOL] [EOL] query = mApi . insert ( ) . values ( uuid = uuid , user_id = user_id , blueprint_uuid = blueprint . uuid , name = name , description = api [ [string] ] , specs = specs , ) [EOL] await query_db ( app [ [string] ] , query , get_result = False ) [EOL] [EOL] service = await Spawner . api . create ( name = name , user_id = user_id , specs = specs ) [EOL] [EOL] if not service : [EOL] log . error ( f" [string] { uuid } [string] " ) [EOL] [EOL] await delete_api ( db = app [ [string] ] , api_ref = uuid , user_id = user_id ) [EOL] log . info ( f" [string] { uuid } [string] " ) [EOL] [EOL] event = { [string] : user_id , [string] : uuid , [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] return [EOL] [EOL] event = { [string] : user_id , [string] : uuid , [string] : name , [string] : specs } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Mapping , Dict , Any [EOL] import logging [EOL] import typing [EOL] import apis [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import logging [EOL] from typing import Any , Mapping [EOL] [EOL] from aiohttp . web import json_response [EOL] from rampante import streaming [EOL] [EOL] from apis . models import delete_api , mApi , select_api [EOL] from apis . serializers import APIs as ApiSchema [EOL] from blueprints . models import join_blueprints_with [EOL] from spawner import Spawner [EOL] from utils import WebView , get_uuid , verify_token [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class APIs ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def get ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] [EOL] apis = await join_blueprints_with ( model = mApi , db = self . db , user_id = user_id ) [EOL] apis_schema = ApiSchema ( many = True ) [EOL] apis_schema . context = { [string] : user_id } [EOL] [EOL] data , errors = apis_schema . dump ( apis ) [EOL] [EOL] if errors : [EOL] return json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] return json_response ( { [string] : data } ) [EOL] [EOL] @ verify_token async def post ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] data = await self . request . json ( ) [EOL] [EOL] data , errors = ApiSchema ( ) . load ( data ) [EOL] if errors : [EOL] log . debug ( errors ) [EOL] return json_response ( { [string] : errors } , status = [number] ) [EOL] [EOL] event = { [string] : get_uuid ( ) . hex , [string] : user_id , [string] : data } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] [EOL] return json_response ( { [string] : event [ [string] ] , [string] : f" [string] { event [ [string] ] } [string] " } ) [EOL] [EOL] @ verify_token async def delete ( self , payload ) : [EOL] [docstring] [EOL] user_id = payload [ [string] ] [EOL] api_ref = self . request . match_info . get ( [string] ) [EOL] [EOL] deleted_api = await delete_api ( db = self . db , api_ref = api_ref , user_id = user_id ) [EOL] [EOL] if deleted_api is None : [EOL] log . info ( f" [string] { api_ref }" ) [EOL] user_message = f" [string] " [EOL] return json_response ( { [string] : user_message } , status = [number] ) [EOL] [EOL] await Spawner . api . delete ( name = deleted_api . name ) [EOL] [EOL] event = { [string] : deleted_api . uuid , [string] : user_id , [string] : deleted_api . name , } [EOL] [EOL] await streaming . publish ( [string] , event ) [EOL] user_message = f" [string] { deleted_api . name }" [EOL] return json_response ( { [string] : user_message } ) [EOL] [EOL] [EOL] class Logs ( WebView ) : [EOL] [docstring] [EOL] [EOL] @ verify_token async def get ( self , payload ) : [EOL] user_id = payload [ [string] ] [EOL] api_ref = self . request . match_info . get ( [string] ) [EOL] [EOL] selected_api = await select_api ( db = self . db , api_ref = api_ref , user_id = user_id ) [EOL] [EOL] if selected_api is None : [EOL] user_message = f" [string] " [EOL] return json_response ( { [string] : user_message } , status = [number] ) [EOL] [EOL] logs = await Spawner . api . logs ( name = selected_api . name ) [EOL] return json_response ( { [string] : logs } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Type [EOL] import typing [EOL] import apis [EOL] [docstring] [EOL] [EOL] from marshmallow import Schema , fields , post_dump [EOL] from marshmallow . validate import OneOf [EOL] [EOL] from config import Config , Status [EOL] [EOL] [EOL] class APIs ( Schema ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] description = fields . Str ( required = True , allow_none = False ) [EOL] blueprint = fields . Str ( required = True ) [EOL] machine_type = fields . Str ( required = True , validate = OneOf ( Config . MACHINES ) ) [EOL] command = fields . Str ( required = True , allow_none = False ) [EOL] gpu = fields . Bool ( required = True , allow_none = False ) [EOL] [EOL] [comment] [EOL] created_at = fields . DateTime ( format = [string] ) [EOL] [EOL] [comment] [EOL] id = fields . Int ( dump_only = True ) [EOL] name = fields . Str ( dump_only = True ) [EOL] user_id = fields . Int ( dump_only = True ) [EOL] blueprint_name = fields . Str ( dump_only = True ) [EOL] blueprint_repository = fields . Str ( dump_only = True ) [EOL] status = fields . Int ( dump_only = True ) [EOL] specs = fields . Raw ( ) [EOL] [EOL] @ post_dump def translate_status ( self , data ) : [EOL] data [ [string] ] = Status ( data [ [string] ] ) . name [EOL] [EOL] @ post_dump def url ( self , data ) : [EOL] data [ [string] ] = Config . APPS_PUBLIC_URL . format ( subdomain = data [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0