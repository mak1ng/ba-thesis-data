from typing import Dict , Any , List [EOL] import typing [EOL] import random [EOL] [EOL] import pytest [EOL] from faker import Faker [EOL] [EOL] fake = Faker ( ) [EOL] [EOL] [EOL] @ pytest . fixture def fake_default_config_name ( ) : [EOL] return fake . word ( ) [EOL] [EOL] [EOL] @ pytest . fixture def fake_section_name ( ) : [EOL] return fake . word ( ) [EOL] [EOL] [EOL] @ pytest . fixture def fake_custom_path_config_file ( fake_default_config_name , tmpdir ) : [EOL] config = tmpdir . mkdir ( [string] ) . join ( fake_default_config_name ) [EOL] config . write ( fake . word ( ) ) [EOL] return config [EOL] [EOL] [EOL] @ pytest . fixture def fake_base_directory ( fake_default_config_name , tmpdir ) : [EOL] base_directory = tmpdir . mkdir ( [string] ) [EOL] config = base_directory . join ( fake_default_config_name ) [EOL] config . write ( fake . word ( ) ) [EOL] return base_directory [EOL] [EOL] [EOL] def get_temp_file_path ( remove_file , return_empty , temp_file ) : [EOL] if return_empty : [EOL] return [string] [EOL] if remove_file : [EOL] temp_file . remove ( ) [EOL] return str ( temp_file ) [EOL] [EOL] [EOL] @ pytest . fixture def fake_config_params ( ) : [EOL] return { [string] : fake . pyint ( ) , [string] : [ fake . uri_path ( ) , fake . uri_path ( ) ] , [string] : random . choice ( [ True , False ] ) , [string] : random . choice ( [ True , False ] ) , [string] : random . choice ( [ True , False ] ) , [string] : fake . pyint ( ) , } [EOL] [EOL] [EOL] @ pytest . fixture def fake_config_file ( fake_section_name , fake_config_params , tmpdir ) : [EOL] lines = [ f' [string] { fake_section_name } [string] ' ] [EOL] [EOL] for name , value in fake_config_params . items ( ) : [EOL] if isinstance ( value , list ) : [EOL] value = [string] . join ( value ) [EOL] lines . append ( f'{ name } [string] { value }' ) [EOL] file_contents = [string] . join ( lines ) [EOL] [EOL] config_file = tmpdir . join ( [string] ) [EOL] config_file . write ( file_contents ) [EOL] return str ( config_file ) [EOL] [EOL] [EOL] @ pytest . fixture def randomized_fake_argv ( ) : [EOL] argv = [ [string] ] [comment] [EOL] argv . append ( fake . uri_path ( ) ) [comment] [EOL] [EOL] string_arguments = { [string] : fake . uri_path ( ) , [string] : [string] . join ( [ fake . uri_path ( ) ] ) , [string] : fake . uri_path ( ) , [string] : str ( fake . pyint ( ) ) , } [EOL] for name , value in string_arguments . items ( ) : [EOL] argv . append ( name ) [EOL] argv . append ( value ) [EOL] [EOL] boolean_arguments = { [string] : random . choice ( [ True , False ] ) , [string] : random . choice ( [ True , False ] ) , [string] : random . choice ( [ True , False ] ) , [string] : random . choice ( [ True , False ] ) , } [EOL] for name , is_true in boolean_arguments . items ( ) : [EOL] if is_true : [EOL] argv . append ( name ) [EOL] [EOL] return argv [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import os [EOL] [EOL] import rozental_as_a_service . strings_extractors as extr [EOL] [EOL] [EOL] def _load_src_file ( filename ) : [EOL] cur_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] td_dir = os . path . join ( cur_dir , [string] , [string] ) [EOL] with open ( os . path . join ( td_dir , filename ) , encoding = [string] ) as f : [EOL] return f . read ( ) [EOL] [EOL] [EOL] def test_extract_from_python_src ( ) : [EOL] src = _load_src_file ( [string] ) [EOL] actual_res = sorted ( extr . extract_from_python_src ( src ) ) [EOL] assert actual_res == [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def test_extract_from_html_src ( ) : [EOL] src = _load_src_file ( [string] ) [EOL] actual_res = sorted ( extr . extract_from_html ( src ) ) [EOL] assert actual_res == [ [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def test_extract_from_markdown_src ( ) : [EOL] src = _load_src_file ( [string] ) [EOL] actual_res = extr . extract_from_markdown ( src ) [EOL] assert actual_res == [ [string] , [string] , [string] , [string] [string] , ] [EOL] [EOL] [EOL] def test_extract_from_js ( ) : [EOL] src = _load_src_file ( [string] ) [EOL] actual_res = sorted ( extr . extract_from_js ( src ) ) [EOL] assert actual_res == [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def test_extract_from_po ( ) : [EOL] src = _load_src_file ( [string] ) [EOL] actual_res = sorted ( extr . extract_from_po ( src ) ) [EOL] assert actual_res == [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] import pytest [EOL] from unittest . mock import patch [EOL] [EOL] from conftest import get_temp_file_path [EOL] from rozental_as_a_service . files_utils import get_config_path [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] [string] , [ ( False , False , False , False , False , False , ) , ( True , False , False , True , False , False , ) , ( True , True , True , False , False , False , ) , ( True , True , True , True , True , False , ) , ( True , False , False , True , True , True , ) , ] , ) def test_get_config_path ( custom_path_provided , custom_path_exists , custom_path_matches , default_path_provided , default_path_exists , default_path_matches , fake_custom_path_config_file , fake_base_directory , fake_default_config_name , ) : [EOL] custom_path = get_temp_file_path ( remove_file = not custom_path_exists , return_empty = not custom_path_provided , temp_file = fake_custom_path_config_file , ) [EOL] base_path = get_temp_file_path ( remove_file = not default_path_exists , return_empty = not default_path_provided , temp_file = fake_base_directory , ) [EOL] [EOL] with patch ( [string] , fake_default_config_name ) : [EOL] result_path = get_config_path ( base_path , custom_path ) [EOL] [EOL] assert ( result_path is None ) == ( custom_path_matches is False and default_path_matches is False ) [EOL] assert ( result_path == custom_path ) == ( custom_path_matches is True ) [EOL] if result_path and base_path : [EOL] assert ( result_path . startswith ( base_path ) ) == ( default_path_matches is True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from rozental_as_a_service . text_utils import is_camel_case_word , split_camel_case_words [EOL] [EOL] [EOL] def test_is_camel_case_word ( ) : [EOL] assert is_camel_case_word ( [string] ) is False [EOL] assert is_camel_case_word ( [string] ) is True [EOL] [EOL] [EOL] def test_split_camel_case_words ( ) : [EOL] assert split_camel_case_words ( [string] ) == [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from rozental_as_a_service . list_utils import chunks , flat [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( ( [ [number] , [number] , [number] ] , [number] ) , [ [ [number] , [number] ] , [ [number] ] ] ) , ( ( [ ] , [number] ) , [ ] ) , ( ( range ( [number] ) , [number] ) , [ range ( [number] ) , range ( [number] , [number] ) ] ) , ] ) def test_calculate_age_works_fine ( test_value , expected_result ) : [EOL] assert list ( chunks ( * test_value ) ) == expected_result [EOL] [EOL] [EOL] def test_flat ( ) : [EOL] assert flat ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) == list ( range ( [number] , [number] ) ) [EOL] assert flat ( [ [ [string] , [string] ] , [ [string] , [string] ] ] ) == [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Mapping [EOL] import typing [EOL] from unittest . mock import patch [EOL] [EOL] from rozental_as_a_service . config_utils import get_params_from_config [EOL] [EOL] [EOL] def test_get_params_from_config ( fake_section_name , fake_config_params , fake_config_file ) : [EOL] with patch ( [string] , fake_section_name ) : [EOL] params = get_params_from_config ( fake_config_file ) [EOL] assert params == fake_config_params [EOL] [EOL] [EOL] def test_get_params_from_config_empty_section ( fake_section_name , fake_config_params , fake_config_file ) : [EOL] different_section_name = f'{ fake_section_name } [string] ' [EOL] with patch ( [string] , different_section_name ) : [EOL] params = get_params_from_config ( fake_config_file ) [EOL] assert params == { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import rozental_as_a_service [EOL] import pytest [EOL] [EOL] from rozental_as_a_service . rozental import extract_all_constants_from_path , fetch_typos_info [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( None , [ [string] , [string] , [string] ] ) , ( [string] , [ [string] , [string] ] ) , ] ) def test_finds_correct_py_files_typos ( vocabulary_path , expected_typos ) : [EOL] unique_words = extract_all_constants_from_path ( [string] , [ ] , process_dots = False , processes_amount = [number] ) [EOL] typos_info = fetch_typos_info ( unique_words , vocabulary_path , None ) [EOL] assert sorted ( t [ [string] ] for t in typos_info ) == expected_typos [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] from unittest . mock import patch [EOL] [EOL] from rozental_as_a_service . args_utils import parse_args [EOL] [EOL] [EOL] def test_parse_args ( randomized_fake_argv ) : [EOL] with patch ( [string] , randomized_fake_argv ) : [EOL] args = parse_args ( ) [EOL] assert args [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import builtins [EOL] def start_ad_company ( company ) : [EOL] [docstring] [EOL] if company . owner . total_budget < company . budget : [EOL] company . owner . send_message ( [string] ) [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import os [EOL] [EOL] [EOL] DEFAULT_WORDS_CHUNK_SIZE = [number] [EOL] DEFAULT_VOCABULARY_FILENAME = [string] [EOL] DEFAULT_SQLITE_DB_FILENAME = [string] [EOL] DEFAULT_CONFIG_FILENAME = [string] [EOL] CONFIG_SECTION_NAME = [string] [EOL] GOOGLE_DOC_URL_REGEXP = [string] [EOL] YA_SPELLER_REQUEST_TIMEOUTS = ( [number] , [number] ) [comment] [EOL] YA_SPELLER_RETRIES_COUNT = [number] [EOL] OBSCENE_BASE_TABLE_NAME = [string] [EOL] OBSCENE_CORPUS_HTTP_PATH = [string] [EOL] SENTRY_ENABLED = os . environ . get ( [string] , None ) == [string] [EOL] SENTRY_URL = [string] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Match , Any , List , Optional [EOL] import builtins [EOL] import _ast [EOL] import typing [EOL] import ast [EOL] import io [EOL] import re [EOL] [EOL] from typing import List [EOL] import tokenize [EOL] [EOL] from bs4 import BeautifulSoup [EOL] from markdown import markdown [EOL] from esprima import tokenize as esprima_tokenize , Error [EOL] [EOL] from rozental_as_a_service . ast_utils import extract_all_constants_from_ast [EOL] [EOL] [EOL] def extract_from_python_src ( raw_content ) : [EOL] return list ( set ( _extract_from_python_ast ( raw_content ) + _extract_from_python_code_comments ( raw_content ) , ) ) [EOL] [EOL] [EOL] def extract_from_html ( raw_content ) : [EOL] return [ n . strip ( ) for n in BeautifulSoup ( raw_content , [string] ) . find_all ( text = True ) if n . strip ( ) ] [EOL] [EOL] [EOL] def extract_from_markdown ( raw_content ) : [EOL] html = markdown ( raw_content ) [EOL] html = re . sub ( [string] , [string] , html ) [EOL] html = re . sub ( [string] , [string] , html ) [EOL] html = re . sub ( [string] , [string] , html ) [EOL] html = re . sub ( [string] , [string] , html ) [EOL] return extract_from_html ( html ) [EOL] [EOL] [EOL] def extract_from_js ( raw_content ) : [EOL] try : [EOL] tokens = esprima_tokenize ( raw_content ) [EOL] except Error : [EOL] return [ ] [EOL] return list ( { t . value for t in tokens if t . type == [string] } ) [EOL] [EOL] [EOL] def extract_from_po ( raw_content ) : [EOL] text_regexp = [string] [EOL] extracted_text = [ ] [EOL] for line in raw_content . split ( [string] ) : [EOL] match = re . match ( text_regexp , line ) [EOL] if match : [EOL] extracted_text . append ( match . groups ( ) [ [number] ] ) [EOL] return extracted_text [EOL] [EOL] [EOL] def _extract_from_python_ast ( raw_content ) : [EOL] try : [EOL] ast_tree = ast . parse ( raw_content ) [EOL] except SyntaxError : [EOL] return [ ] [EOL] return extract_all_constants_from_ast ( ast_tree ) [EOL] [EOL] [EOL] def _extract_from_python_code_comments ( raw_content ) : [EOL] string_constants = [ ] [EOL] for line in tokenize . generate_tokens ( io . StringIO ( raw_content ) . readline ) : [EOL] if line . type == tokenize . COMMENT : [EOL] string_constants . append ( line . string ) [EOL] return string_constants [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Mapping [EOL] import typing [EOL] from mypy_extensions import TypedDict [EOL] from typing import List , Optional , Mapping , Any [EOL] [EOL] [EOL] class TypoInfo ( TypedDict ) : [EOL] original = ... [EOL] possible_options = ... [EOL] [EOL] [EOL] class BackendsConfig ( TypedDict ) : [EOL] speller_chunk_size = ... [EOL] vocabulary_path = ... [EOL] db_path = ... [EOL] [EOL] [EOL] class RozentalOptions ( TypedDict ) : [EOL] path = ... [EOL] vocabulary_path = ... [EOL] exclude = ... [EOL] db_path = ... [EOL] exit_zero = ... [EOL] reorder_vocabulary = ... [EOL] process_dots = ... [EOL] processes_amount = ... [EOL] verbosity = ... [EOL] ban_obscene_words = ... [EOL] [EOL] [EOL] GoogleDocumentContent = Mapping [ str , Any ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Mapping , Optional [EOL] import typing [EOL] import argparse [EOL] import rozental_as_a_service [EOL] import argparse [EOL] import multiprocessing [EOL] import os [EOL] from typing import Any , Mapping [EOL] [EOL] from rozental_as_a_service . common_types import RozentalOptions [EOL] from rozental_as_a_service . config import DEFAULT_SQLITE_DB_FILENAME , DEFAULT_VOCABULARY_FILENAME [EOL] from rozental_as_a_service . config_utils import get_params_from_config [EOL] from rozental_as_a_service . files_utils import get_config_path [EOL] [EOL] [EOL] def parse_args ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , metavar = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = int , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] [EOL] return parser . parse_args ( ) [EOL] [EOL] [EOL] def prepare_arguments ( argparse_args ) : [EOL] config_path = get_config_path ( argparse_args . path , argparse_args . config ) [EOL] config = { } [EOL] if config_path : [EOL] config = get_params_from_config ( config_path ) [EOL] [EOL] default_processors_amount = multiprocessing . cpu_count ( ) if os . path . isdir ( argparse_args . path ) else [number] [EOL] processes_amount = argparse_args . processes or config . get ( [string] ) or default_processors_amount [EOL] if not os . path . exists ( argparse_args . path ) : [EOL] base_path = [string] [EOL] else : [EOL] base_path = ( argparse_args . path [EOL] if os . path . isdir ( argparse_args . path ) [EOL] else os . path . dirname ( os . path . abspath ( argparse_args . path ) ) ) [EOL] vocabulary_path = ( argparse_args . vocabulary_path or config . get ( [string] ) or os . path . join ( base_path , DEFAULT_VOCABULARY_FILENAME ) ) [EOL] db_path = ( argparse_args . db_path or config . get ( [string] ) or os . path . join ( base_path , DEFAULT_SQLITE_DB_FILENAME ) ) [EOL] exclude = argparse_args . exclude . split ( [string] ) if argparse_args . exclude else config . get ( [string] , [ ] ) [EOL] exit_zero = argparse_args . exit_zero or config . get ( [string] ) or False [EOL] verbosity = argparse_args . verbose or config . get ( [string] ) or [number] [EOL] process_dots = argparse_args . process_dots or config . get ( [string] ) or False [EOL] reorder_vocabulary = argparse_args . reorder_vocabulary or config . get ( [string] ) or False [EOL] ban_obscene_words = argparse_args . ban_obscene_words or config . get ( [string] ) or False [EOL] [EOL] return { [string] : argparse_args . path , [string] : vocabulary_path , [string] : exclude , [string] : db_path , [string] : exit_zero , [string] : reorder_vocabulary , [string] : process_dots , [string] : processes_amount , [string] : verbosity , [string] : ban_obscene_words , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rozental_as_a_service.common_types.RozentalOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import requests [EOL] import typing [EOL] import os [EOL] [EOL] from typing import List [EOL] [EOL] import requests [EOL] [EOL] from rozental_as_a_service . config import OBSCENE_BASE_TABLE_NAME , OBSCENE_CORPUS_HTTP_PATH [EOL] from rozental_as_a_service . db_utils import ( is_table_exists , is_obscene_table_has_data , create_db , create_obscene_base_table , save_obscene_words_to_db ) [EOL] [EOL] [EOL] def fetch_obscene_words_base_if_necessary ( db_path ) : [EOL] if ( os . path . exists ( db_path ) [EOL] and is_table_exists ( db_path , OBSCENE_BASE_TABLE_NAME ) [EOL] and is_obscene_table_has_data ( db_path ) ) : [EOL] return None [EOL] if not os . path . exists ( db_path ) : [EOL] create_db ( db_path ) [EOL] if not is_table_exists ( db_path , OBSCENE_BASE_TABLE_NAME ) : [EOL] create_obscene_base_table ( db_path ) [EOL] obscene_words = fetch_obscene_words_from_github ( ) [EOL] save_obscene_words_to_db ( db_path , obscene_words ) [EOL] [EOL] [EOL] def fetch_obscene_words_from_github ( ) : [EOL] response = requests . get ( OBSCENE_CORPUS_HTTP_PATH ) [EOL] return list ( { w . lower ( ) . strip ( ) for w in response . text . strip ( ) . split ( [string] ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import logging [EOL] import logging [EOL] [EOL] [EOL] def set_logging_level ( verbosity , logger , max_logging = [number] ) : [EOL] logger . setLevel ( max ( max_logging - verbosity , [number] ) * [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import ast [EOL] import builtins [EOL] import typing [EOL] import ast [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] def extract_all_constants_from_ast ( ast_tree ) : [EOL] return list ( { n . s for n in ast . walk ( ast_tree ) if isinstance ( n , ast . Str ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Mapping [EOL] import builtins [EOL] import configparser [EOL] import typing [EOL] import configparser [EOL] from typing import Any , Mapping [EOL] [EOL] from rozental_as_a_service . config import CONFIG_SECTION_NAME [EOL] [EOL] [EOL] def get_params_from_config ( config_path ) : [EOL] config = configparser . ConfigParser ( ) [EOL] config . read ( config_path ) [EOL] if not config . has_section ( CONFIG_SECTION_NAME ) : [EOL] return { } [EOL] params = dict ( config [ CONFIG_SECTION_NAME ] ) [EOL] if [string] in params : [EOL] params [ [string] ] = int ( params [ [string] ] ) [comment] [EOL] if [string] in params : [EOL] params [ [string] ] = params [ [string] ] . split ( [string] ) [comment] [EOL] if [string] in params : [EOL] params [ [string] ] = params [ [string] ] == [string] [comment] [EOL] if [string] in params : [EOL] params [ [string] ] = params [ [string] ] == [string] [comment] [EOL] if [string] in params : [EOL] params [ [string] ] = params [ [string] ] == [string] [comment] [EOL] if [string] in params : [EOL] params [ [string] ] = int ( params [ [string] ] ) [comment] [EOL] return params [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Generator [EOL] import builtins [EOL] import typing [EOL] from typing import List , Generator [EOL] [EOL] [EOL] def chunks ( some_list , chunk_size ) : [EOL] for chunk_num in range ( [number] , len ( some_list ) , chunk_size ) : [EOL] yield some_list [ chunk_num : chunk_num + chunk_size ] [EOL] [EOL] [EOL] def flat ( some_list ) : [EOL] return [ item for sublist in some_list for item in sublist ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import re [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] def is_camel_case_word ( word ) : [EOL] uppercase_letters_amount = re . subn ( [string] , [string] , word ) [ [number] ] [EOL] lowercase_letters_amount = re . subn ( [string] , [string] , word ) [ [number] ] [EOL] return bool ( ( lowercase_letters_amount and uppercase_letters_amount >= [number] ) or re . findall ( [string] , word ) , ) [EOL] [EOL] [EOL] def split_camel_case_words ( camel_cased_word ) : [EOL] words_start_indexes = [ m . start ( [number] ) for m in re . finditer ( [string] , camel_cased_word ) ] [EOL] if words_start_indexes [ [number] ] > [number] : [EOL] words_start_indexes . insert ( [number] , [number] ) [EOL] if words_start_indexes [ - [number] ] < len ( camel_cased_word ) : [EOL] words_start_indexes . append ( len ( camel_cased_word ) ) [EOL] words = [ ] [EOL] for word_start_index , word_end_index in zip ( words_start_indexes , words_start_indexes [ [number] : ] ) : [EOL] words . append ( camel_cased_word [ word_start_index : word_end_index ] . lower ( ) ) [EOL] return words [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Literal , Optional , Match , Union , List , Tuple [EOL] import builtins [EOL] import typing_extensions [EOL] import typing [EOL] import re [EOL] from typing import List , Tuple [EOL] [EOL] from rozental_as_a_service . text_utils import split_camel_case_words , is_camel_case_word [EOL] [EOL] [EOL] def extract_words ( raw_constants , min_word_length = [number] , only_russian = True , strip_urls = True , ) : [EOL] common_replacements = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] url_regexp = [string] [EOL] processed_words = [ ] [EOL] raw_camelcase_words = [ ] [EOL] for constant in raw_constants : [EOL] if strip_urls : [EOL] constant = re . sub ( url_regexp , [string] , constant ) [EOL] [EOL] for replace_from , replace_to in common_replacements : [EOL] constant = constant . replace ( replace_from , replace_to ) [EOL] [EOL] new_processed_words , new_camelcase_words = process_raw_constant ( constant , min_word_length ) [EOL] processed_words += new_processed_words [EOL] raw_camelcase_words += new_camelcase_words [EOL] processed_words += process_camelcased_words ( raw_camelcase_words ) [EOL] [EOL] processed_words = list ( set ( processed_words ) ) [EOL] [EOL] word_regexp = [string] if only_russian else [string] [EOL] filtered_words = [ ] [EOL] for word in processed_words : [EOL] match = re . match ( word_regexp , word ) [EOL] if match : [EOL] word = match . group ( ) [EOL] if [string] not in word and [string] not in word : [comment] [EOL] filtered_words . append ( word ) [EOL] processed_words = filtered_words [EOL] return processed_words [EOL] [EOL] [EOL] def process_raw_constant ( constant , min_word_length ) : [EOL] processed_words = [ ] [EOL] raw_camelcase_words = [ ] [EOL] for raw_word in re . findall ( [string] , constant ) : [EOL] word = raw_word . strip ( ) [EOL] if ( len ( word ) >= min_word_length [EOL] and not ( word . startswith ( [string] ) or word . endswith ( [string] ) ) ) : [EOL] if is_camel_case_word ( word ) : [EOL] raw_camelcase_words . append ( word ) [EOL] else : [EOL] processed_words . append ( word . lower ( ) ) [EOL] return processed_words , raw_camelcase_words [EOL] [EOL] [EOL] def process_camelcased_words ( raw_camelcase_words ) : [EOL] processed_words = [ ] [EOL] for camel_case_words in raw_camelcase_words : [EOL] splitted_words = split_camel_case_words ( camel_case_words ) [EOL] if splitted_words : [EOL] processed_words += splitted_words [EOL] return processed_words [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.str],typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , Set , Dict , List , Tuple [EOL] import builtins [EOL] import requests [EOL] import typing [EOL] import rozental_as_a_service [EOL] import os [EOL] from typing import List , Tuple [EOL] [EOL] from requests import Response , get [EOL] from sentry_sdk import capture_exception [EOL] [EOL] from rozental_as_a_service . common_types import TypoInfo , BackendsConfig [EOL] from rozental_as_a_service . config import YA_SPELLER_REQUEST_TIMEOUTS , YA_SPELLER_RETRIES_COUNT [EOL] from rozental_as_a_service . db_utils import save_ya_speller_results_to_db , get_ya_speller_cache_from_db [EOL] [EOL] [EOL] def process_with_vocabulary ( words , config , ) : [EOL] if config [ [string] ] is None or not os . path . exists ( config [ [string] ] ) : [EOL] return [ ] , [ ] , words [EOL] with open ( config [ [string] ] , encoding = [string] ) as file_handler : [EOL] raw_vocabulary = file_handler . readlines ( ) [EOL] vocabulary = { w . strip ( ) . lower ( ) for w in raw_vocabulary if not w . strip ( ) . startswith ( [string] ) } [EOL] correct_words = { w for w in words if w in vocabulary } [EOL] return list ( correct_words ) , [ ] , [ w for w in words if w not in correct_words ] [EOL] [EOL] [EOL] def process_with_db_with_cache ( words , config , ) : [EOL] if config [ [string] ] is None : [EOL] return [ ] , [ ] , words [EOL] words_cache = get_ya_speller_cache_from_db ( words , config [ [string] ] ) [EOL] sure_correct_words = [ ] [EOL] incorrect_typos_info = [ ] [EOL] for word in words : [EOL] if word not in words_cache : [EOL] continue [EOL] cached_value = words_cache [ word ] [EOL] if cached_value is None : [EOL] sure_correct_words . append ( word ) [EOL] else : [EOL] incorrect_typos_info . append ( { [string] : word , [string] : cached_value , } ) [EOL] known_words = set ( sure_correct_words + [ t [ [string] ] for t in incorrect_typos_info ] ) [EOL] return sure_correct_words , incorrect_typos_info , list ( set ( words ) - known_words ) [EOL] [EOL] [EOL] def process_with_ya_speller ( words , config , ) : [EOL] if not words : [EOL] return [ ] , [ ] , words [EOL] for _ in range ( YA_SPELLER_RETRIES_COUNT ) : [EOL] try : [EOL] response = get ( [string] , params = { [string] : words } , timeout = YA_SPELLER_REQUEST_TIMEOUTS , ) [EOL] except TimeoutError as e : [EOL] capture_exception ( e ) [EOL] else : [EOL] break [EOL] [EOL] return ( [ ] , * _process_ya_speller_response ( response , words , config ) ) [EOL] [EOL] [EOL] def _process_ya_speller_response ( response , words , config , ) : [EOL] typos_info = [ ] [EOL] speller_result = response . json ( ) [EOL] if speller_result : [EOL] for word_info in speller_result : [EOL] if word_info and word_info [ [number] ] [ [string] ] : [EOL] typos_info . append ( { [string] : word_info [ [number] ] [ [string] ] , [string] : word_info [ [number] ] [ [string] ] , } ) [EOL] if config [ [string] ] is not None : [EOL] save_ya_speller_results_to_db ( speller_result , words , config [ [string] ] ) [EOL] typo_words = { t [ [string] ] for t in typos_info } [EOL] return typos_info , [ w for w in words if w not in typo_words ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.str],typing.List[rozental_as_a_service.common_types.TypoInfo],typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.str],typing.List[rozental_as_a_service.common_types.TypoInfo],typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.str],typing.List[rozental_as_a_service.common_types.TypoInfo],typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[rozental_as_a_service.common_types.TypoInfo],typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Mapping , Optional , Set , Dict , List , Tuple [EOL] import builtins [EOL] import sqlite3 [EOL] import typing [EOL] import json [EOL] import os [EOL] import sqlite3 [EOL] from typing import List , Mapping , Any , Tuple , Optional , Dict , Set [EOL] [EOL] from rozental_as_a_service . config import OBSCENE_BASE_TABLE_NAME [EOL] from rozental_as_a_service . list_utils import flat [EOL] [EOL] [EOL] def save_ya_speller_results_to_db ( speller_result , words , db_path , ) : [EOL] if not os . path . exists ( db_path ) : [EOL] create_db ( db_path ) [EOL] connection = sqlite3 . connect ( db_path ) [EOL] existing_words = get_existing_words_in_db ( words , connection ) [EOL] [EOL] new_results = [ ( w , r [ [number] ] if r else None ) for w , r in zip ( words , speller_result ) if w not in existing_words ] [EOL] insert_db_words_info ( new_results , connection ) [EOL] [EOL] [EOL] def get_ya_speller_cache_from_db ( words , db_path , ) : [EOL] if not os . path . exists ( db_path ) : [EOL] return { } [EOL] connection = sqlite3 . connect ( db_path ) [EOL] return fetch_words_info_from_db ( words , connection ) [EOL] [EOL] [EOL] def create_db ( db_path ) : [EOL] connection = sqlite3 . connect ( db_path ) [EOL] cursor = connection . cursor ( ) [EOL] cursor . execute ( [string] ) [EOL] cursor . execute ( f' [string] { OBSCENE_BASE_TABLE_NAME } [string] ' ) [EOL] connection . commit ( ) [EOL] [EOL] [EOL] def get_existing_words_in_db ( words , connection ) : [EOL] cursor = connection . cursor ( ) [EOL] raw_result = cursor . execute ( [string] . format ( [string] . join ( [string] * len ( words ) ) ) , words , ) . fetchall ( ) [EOL] return [ r [ [number] ] for r in raw_result ] [EOL] [EOL] [EOL] def fetch_words_info_from_db ( words , connection ) : [EOL] cursor = connection . cursor ( ) [EOL] raw_result = cursor . execute ( [string] . format ( [string] . join ( [string] * len ( words ) ) ) , words , ) . fetchall ( ) [EOL] return { r : json . loads ( info ) for r , info in raw_result } [EOL] [EOL] [EOL] def insert_db_words_info ( data , connection ) : [EOL] cursor = connection . cursor ( ) [EOL] cursor . executemany ( [string] , [ ( d [ [number] ] , json . dumps ( d [ [number] ] [ [string] ] if d [ [number] ] else None ) ) for d in data ] , ) [EOL] connection . commit ( ) [EOL] [EOL] [EOL] def is_table_exists ( db_path , table_name ) : [EOL] connection = sqlite3 . connect ( db_path ) [EOL] cursor = connection . cursor ( ) [EOL] raw_result = cursor . execute ( f" [string] { table_name } [string] " , ) . fetchall ( ) [EOL] return bool ( raw_result ) [EOL] [EOL] [EOL] def is_obscene_table_has_data ( db_path ) : [EOL] connection = sqlite3 . connect ( db_path ) [EOL] cursor = connection . cursor ( ) [EOL] raw_result = cursor . execute ( f' [string] { OBSCENE_BASE_TABLE_NAME }' , ) . fetchall ( ) [EOL] return bool ( raw_result [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] def create_obscene_base_table ( db_path ) : [EOL] connection = sqlite3 . connect ( db_path ) [EOL] cursor = connection . cursor ( ) [EOL] cursor . execute ( f' [string] { OBSCENE_BASE_TABLE_NAME } [string] ' ) [EOL] connection . commit ( ) [EOL] [EOL] [EOL] def save_obscene_words_to_db ( db_path , obscene_words ) : [EOL] connection = sqlite3 . connect ( db_path ) [EOL] cursor = connection . cursor ( ) [EOL] cursor . executemany ( f' [string] { OBSCENE_BASE_TABLE_NAME } [string] ' , [ [ w ] for w in obscene_words ] , ) [EOL] connection . commit ( ) [EOL] [EOL] [EOL] def load_obscene_words ( db_path ) : [EOL] connection = sqlite3 . connect ( db_path ) [EOL] cursor = connection . cursor ( ) [EOL] return set ( flat ( cursor . execute ( f' [string] { OBSCENE_BASE_TABLE_NAME }' , ) . fetchall ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0