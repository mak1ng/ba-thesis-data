[comment] [EOL] [EOL] from distutils . core import setup [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , author = [string] , author_email = [string] , packages = [ [string] ] , scripts = [ [string] ] , ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Set , Any [EOL] import harmony [EOL] import typing [EOL] import logging [EOL] import pathlib [EOL] import os [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] from harmony import hashers [EOL] from harmony . serialization import Serializable [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] class FileState ( Serializable ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path = None , digest = None , size = None , mtime = None , wipe = False ) : [EOL] self . path = Path ( path ) [EOL] self . digest = digest [EOL] self . size = size [EOL] self . mtime = mtime [EOL] self . wipe = wipe [EOL] [EOL] def __deepcopy__ ( self , memo ) : [EOL] return self . __class__ ( self . path , self . digest , self . size , self . mtime , self . wipe , ) [EOL] [EOL] def exists ( self ) : [EOL] return self . size is not None [EOL] [EOL] def contents_different ( self , other ) : [EOL] return self . size != other . size or self . digest != other . digest [EOL] [EOL] class WorkingDirectory : [EOL] [EOL] def __init__ ( self , path , ruleset ) : [EOL] self . path = Path ( path ) . resolve ( ) [EOL] self . ruleset = ruleset [EOL] [EOL] def normalize ( self , relpath ) : [EOL] abspath = ( self . path / relpath ) [EOL] try : [EOL] abspath = abspath . resolve ( ) [EOL] except FileNotFoundError : [EOL] pass [EOL] return abspath . relative_to ( self . path ) [EOL] [EOL] def get_filenames ( self ) : [EOL] r = set ( ) [EOL] for file_info in self . ruleset . iterate_committable_files ( self . path ) : [EOL] r . add ( self . normalize ( file_info . relative_filename ) ) [EOL] return r [EOL] [EOL] def __contains__ ( self , path ) : [EOL] return ( self . path / self . normalize ( path ) ) . exists ( ) [EOL] [EOL] def file_maybe_modified ( self , file_state ) : [EOL] [docstring] [EOL] path = self . path / file_state . path [EOL] [EOL] exists_before = file_state . size is not None [EOL] exists_now = path . exists ( ) [EOL] [EOL] if not exists_before and not exists_now : [EOL] [comment] [EOL] [comment] [EOL] return False [EOL] [EOL] if exists_before != exists_now : [EOL] [comment] [EOL] [comment] [EOL] return True [EOL] [EOL] assert exists_before and exists_now [EOL] [EOL] mtime = path . stat ( ) . st_mtime [EOL] size = path . stat ( ) . st_size [EOL] [EOL] if file_state . mtime > mtime : [EOL] logger . warn ( [string] . format ( file_state . path ) ) [EOL] [comment] [EOL] [comment] [EOL] return True [EOL] [EOL] return mtime > file_state . mtime or size != file_state . size [EOL] [EOL] def generate_file_state ( self , path ) : [EOL] hasher = hashers . get_hasher ( [string] ) [EOL] full_path = self . path / path [EOL] exists = full_path . exists ( ) [EOL] [EOL] if exists : [EOL] mtime = full_path . stat ( ) . st_mtime [EOL] size = full_path . stat ( ) . st_size [EOL] with full_path . open ( [string] ) as f : [EOL] digest = hasher ( f ) [EOL] [EOL] else : [EOL] mtime = size = digest = None [EOL] [EOL] r = FileState ( path = self . normalize ( path ) , mtime = mtime , size = size , digest = digest , ) [EOL] return r [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $harmony.working_directory.FileState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $harmony.working_directory.FileState$ 0 0
[EOL] from typing import Set , Any [EOL] import logging [EOL] import typing [EOL] import logging [EOL] [EOL] from harmony . serialization import Serializable [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] def cmp_ ( a , b ) : [EOL] return ( a > b ) - ( a < b ) [EOL] [EOL] class Clock ( Serializable ) : [EOL] [EOL] @ classmethod def from_dict ( class_ , d ) : [EOL] return class_ ( ** d ) [EOL] [EOL] def to_dict ( self ) : [EOL] return self . values [EOL] [EOL] def __init__ ( self , ** kws ) : [EOL] self . values = dict ( kws ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( [string] . join ( [string] . format ( k , v ) for k , v in self . values . items ( ) ) ) [EOL] [EOL] def compare ( self , other ) : [EOL] [docstring] [EOL] keys = set ( self . values . keys ( ) ) . union ( other . values . keys ( ) ) [EOL] [EOL] sign = [number] [EOL] for k in keys : [EOL] new_sign = cmp_ ( self . values . get ( k , [number] ) , other . values . get ( k , [number] ) ) [EOL] if sign == [number] : [EOL] sign = new_sign [EOL] elif new_sign == - sign : [EOL] return None [EOL] [EOL] return sign [EOL] [EOL] def update ( self , other ) : [EOL] [docstring] [EOL] for k in set ( self . values . keys ( ) ) | set ( other . values . keys ( ) ) : [EOL] self . values [ k ] = max ( self . values . get ( k , [number] ) , other . values . get ( k , [number] ) ) [EOL] [EOL] def increase ( self , k ) : [EOL] self . values [ k ] = self . values . get ( k , [number] ) + [number] [EOL] [EOL] def comparable ( self , other ) : [EOL] return self . compare ( other ) is not None [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . compare ( other ) == - [number] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . compare ( other ) == [number] [EOL] [EOL] def __gt__ ( self , other ) : [EOL] return other < self [EOL] [EOL] def __le__ ( self , other ) : [EOL] return ( self < other ) or ( self == other ) [EOL] [EOL] def __ge__ ( self , other ) : [EOL] return ( self > other ) or ( self == other ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Iterable , Any , ChainMap [EOL] import harmony [EOL] import collections [EOL] import pathlib [EOL] import logging [EOL] import typing [EOL] import logging [EOL] from copy import deepcopy [EOL] from pathlib import Path [EOL] from collections import ChainMap [EOL] from typing import Iterable [EOL] [EOL] from harmony . serialization import FileSerializable , Serializable [EOL] from harmony . clock import Clock [EOL] from harmony import serialization [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] class RepositoryStateException ( Exception ) : [EOL] pass [EOL] [EOL] class RepositoryFileState ( Serializable ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path = None , digest = None , clock = Clock ( ) , wipe = False ) : [EOL] self . digest = digest [EOL] self . path = Path ( path ) if path is not None else None [EOL] self . clock = clock [EOL] self . wipe = wipe [EOL] [EOL] @ classmethod def from_dict ( class_ , d ) : [EOL] d = ChainMap ( { [string] : Clock ( ** d [ [string] ] ) } , d ) [EOL] r = super ( ) . from_dict ( d ) [EOL] return r [EOL] [EOL] def contents_different ( self , other ) : [EOL] return self . digest != other . digest [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self . __dict__ ) [EOL] [EOL] class RepositoryState ( FileSerializable ) : [EOL] [EOL] RELATIVE_PATH = [string] [EOL] [EOL] def __init__ ( self , path , files = None ) : [EOL] super ( ) . __init__ ( path ) [EOL] self . files = files if files else { } [EOL] [EOL] @ classmethod def from_dict ( class_ , d ) : [EOL] return class_ ( d [ [string] ] , files = { f : RepositoryFileState . from_dict ( v ) for f , v in d [ [string] ] . items ( ) } ) [EOL] [EOL] def get_paths ( self ) : [EOL] return tuple ( Path ( p ) for p in self . files . keys ( ) ) [EOL] [EOL] def get ( self , path , default = None ) : [EOL] return self . files . get ( str ( path ) , default ) [EOL] [EOL] def __getitem__ ( self , path ) : [EOL] return deepcopy ( self . files . get ( str ( path ) , RepositoryFileState ( path = path ) ) ) [EOL] [EOL] def __setitem__ ( self , path , v ) : [EOL] self . files [ str ( path ) ] = v [EOL] [EOL] def overwrite ( self , other ) : [EOL] self . files = deepcopy ( other . files ) [EOL] [EOL] def update_file_state ( self , new_state , id_ , clock_value ) : [EOL] path = new_state . path [EOL] entry = deepcopy ( self [ str ( path ) ] ) [EOL] [EOL] if new_state . digest == entry . digest and new_state . wipe == entry . wipe : [EOL] [comment] [EOL] return [EOL] [EOL] entry . wipe = new_state . wipe [EOL] entry . digest = new_state . digest [EOL] entry . clock . values [ id_ ] = clock_value [EOL] self [ path ] = entry [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.ChainMap[builtins.str,harmony.clock.Clock]$ 0 0 0 $collections.ChainMap[builtins.str,harmony.clock.Clock]$ 0 0 0 0 0 0 0 0 0 $collections.ChainMap[builtins.str,harmony.clock.Clock]$ 0 0 0 0 0 0 $collections.ChainMap[builtins.str,harmony.clock.Clock]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $collections.ChainMap[builtins.str,harmony.clock.Clock]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[pathlib.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[EOL] from typing import Any , Dict [EOL] import typing [EOL] import os . path [EOL] from harmony import serialization [EOL] from harmony . serialization import FileSerializable , Serializable [EOL] [EOL] class Remotes ( FileSerializable ) : [EOL] [EOL] RELATIVE_PATH = [string] [EOL] [EOL] class Remote ( Serializable ) : [EOL] def __init__ ( self , id_ = None , name = None , location = None ) : [EOL] self . id = id_ [EOL] self . name = name [EOL] self . location = str ( location ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . id == other . id \ [EOL] and self . name == other . name \ [EOL] and self . location == other . location [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . id < other . id or self . name < other . name or self . location < other . location [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . id ) ^ hash ( self . name ) ^ hash ( self . location ) [EOL] [EOL] [EOL] def __init__ ( self , path , by_name = None , by_id = None ) : [EOL] super ( ) . __init__ ( path ) [EOL] self . by_name = by_name if by_name else { } [EOL] self . by_id = by_id if by_id else { } [EOL] [EOL] @ classmethod def from_dict ( class_ , d ) : [EOL] by_name = { x [ [string] ] : class_ . Remote . from_dict ( x ) for x in d [ [string] ] } [EOL] by_id = { x [ [string] ] : class_ . Remote . from_dict ( x ) for x in d [ [string] ] } [EOL] return class_ ( d [ [string] ] , by_name , by_id ) [EOL] [EOL] def to_dict ( self ) : [EOL] l = self . get_remotes ( ) [EOL] return { [string] : sorted ( [ x . to_dict ( ) for x in l ] , key = lambda d : ( d [ [string] ] , d [ [string] ] , d [ [string] ] ) ) , } [EOL] [EOL] def add ( self , location , name , id_ = None ) : [EOL] if name in self . by_name : [EOL] raise ValueError ( [string] . format ( name ) ) [EOL] [EOL] if id_ is not None and id_ in self . by_id : [EOL] raise ValueError ( [string] . format ( id_ ) ) [EOL] [EOL] self . by_name [ name ] = self . Remote ( id_ = id_ , name = name , location = location ) [EOL] if id_ is not None : [EOL] self . by_id [ id_ ] = self . Remote ( id_ = id_ , name = name , location = location ) [EOL] [EOL] def get_location_any ( self , s ) : [EOL] [docstring] [EOL] r = self . get_location ( s , s ) [EOL] if r is None : [EOL] return s [EOL] [EOL] def get_location ( self , id_ = None , name = None ) : [EOL] if id_ is not None and id_ in self . by_id : [EOL] return self . by_id [ id_ ] . location [EOL] if name is not None and name in self . by_name : [EOL] return self . by_name [ name ] . location [EOL] return None [EOL] [EOL] def get_remotes ( self ) : [EOL] return list ( set ( self . by_name . values ( ) ) | set ( self . by_id . values ( ) ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] DATETIME_FORMAT = [string] [EOL] [EOL] def datetime_to_iso ( d ) : [EOL] [comment] [EOL] return d . strftime ( DATETIME_FORMAT ) [EOL] [EOL] def iso_to_datetime ( s ) : [EOL] [comment] [EOL] return d . strptime ( s , DATETIME_FORMAT ) [EOL] [EOL] def shortened_id ( id_ ) : [EOL] return id_ [ [number] : [number] ] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Set , Any , Dict [EOL] import harmony [EOL] import typing [EOL] import logging [EOL] import pathlib [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] import yaml [EOL] from pathlib import Path , PosixPath [EOL] [EOL] def read ( filename ) : [EOL] filename = str ( filename ) [EOL] r = None [EOL] with open ( filename , [string] ) as f : [EOL] s = f . read ( ) [EOL] r = yaml . safe_load ( s ) [EOL] return r [EOL] [EOL] def write ( d , filename ) : [EOL] filename = str ( filename ) [EOL] with open ( filename , [string] ) as f : [EOL] logger . debug ( [string] . format ( filename , d ) ) [EOL] yaml . safe_dump ( d , f ) [EOL] [EOL] def dump ( d ) : [EOL] return yaml . safe_dump ( d ) [EOL] [EOL] [EOL] class Serializable ( object ) : [EOL] [EOL] @ classmethod def get_path ( class_ , harmony_directory ) : [EOL] return Path ( harmony_directory ) / class_ . RELATIVE_PATH [EOL] [EOL] @ classmethod def init ( class_ , path ) : [EOL] [docstring] [EOL] r = class_ ( path ) [EOL] r . save ( ) [EOL] return r [EOL] [EOL] @ classmethod def from_dict ( class_ , d ) : [EOL] [docstring] [EOL] r = class_ ( ** d ) [EOL] return r [EOL] [EOL] @ classmethod def prepare_value_for_dict ( class_ , k , v ) : [EOL] if isinstance ( v , Path ) or isinstance ( v , PosixPath ) : [EOL] v = str ( v ) [EOL] [EOL] if isinstance ( k , Path ) or isinstance ( k , PosixPath ) : [EOL] k = str ( k ) [EOL] [EOL] if hasattr ( v , [string] ) : [EOL] v = v . to_dict ( ) [EOL] elif isinstance ( v , dict ) : [EOL] v = dict ( class_ . prepare_value_for_dict ( k_ , v_ ) for k_ , v_ in v . items ( ) ) [EOL] return k , v [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def to_dict ( self , skip = ( ) ) : [EOL] if hasattr ( self , [string] ) : [EOL] keys = set ( self . _state ) [EOL] elif hasattr ( self , [string] ) : [EOL] keys = set ( k for k in self . __slots__ if not k . startswith ( [string] ) ) [EOL] else : [EOL] keys = set ( k for k in self . __dict__ . keys ( ) if not k . startswith ( [string] ) ) [EOL] [EOL] keys = keys - set ( skip ) [EOL] [EOL] return dict ( self . prepare_value_for_dict ( k , getattr ( self , k ) ) for k in keys ) [EOL] [EOL] def __init__ ( self , path ) : [EOL] self . path = Path ( path ) if path is not None else None [EOL] [EOL] [EOL] class DirectorySerializable ( Serializable ) : [EOL] [EOL] @ classmethod def init ( class_ , path ) : [EOL] path = Path ( path ) [EOL] path . mkdir ( ) [EOL] return super ( ) . init ( path ) [EOL] [EOL] @ classmethod def load ( class_ , path ) : [EOL] path = Path ( path ) [EOL] items = { filename . name : read ( filename ) for filename in path . iterdir ( ) if not str ( filename ) . startswith ( [string] ) } [EOL] return class_ . from_dict ( { [string] : path , [string] : items , } ) [EOL] [EOL] @ classmethod def from_dict ( class_ , d ) : [EOL] items = { k : class_ . item_from_dict ( v ) for k , v in d [ [string] ] . items ( ) } [EOL] d [ [string] ] = items [EOL] return super ( ) . from_dict ( d ) [EOL] [EOL] def to_dict ( self ) : [EOL] d = super ( ) . to_dict ( skip = ( [string] , ) ) [EOL] d [ [string] ] = { k : self . item_to_dict ( v ) for k , v in self . items . items ( ) } [EOL] return d [EOL] [EOL] @ classmethod def item_from_dict ( class_ , d ) : [EOL] return class_ . Item . from_dict ( d ) [EOL] [EOL] def item_to_dict ( self , item ) : [EOL] return item . to_dict ( ) [EOL] [EOL] def __init__ ( self , path , items ) : [EOL] super ( ) . __init__ ( path ) [EOL] self . items = items [EOL] [EOL] def save ( self ) : [EOL] d = self . to_dict ( ) [EOL] for k , v in d [ [string] ] . items ( ) : [EOL] p = Path ( self . path ) / k [EOL] logger . debug ( [string] . format ( v , p ) ) [EOL] write ( v , p ) [EOL] [EOL] class FileSerializable ( Serializable ) : [EOL] [EOL] @ classmethod def load ( class_ , path ) : [EOL] path = Path ( path ) [EOL] d = read ( path ) [EOL] d [ [string] ] = Path ( path ) [EOL] return class_ . from_dict ( d ) [EOL] [EOL] def __init__ ( self , path ) : [EOL] super ( ) . __init__ ( path ) [EOL] [EOL] def save ( self ) : [EOL] d = self . to_dict ( ) [EOL] if [string] in d : [EOL] del d [ [string] ] [EOL] write ( d , self . path ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $harmony.serialization.Serializable$ 0 0 0 0 0 0 $harmony.serialization.Serializable$ 0 0 0 0 0 0 $harmony.serialization.Serializable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $harmony.serialization.Serializable$ 0 0 0 0 0 0 0 0 $harmony.serialization.Serializable$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 $typing.Any$ 0 0 0 $pathlib.Path$ 0 0 $typing.Any$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import hashlib [EOL] import warnings [EOL] [EOL] DEFAULT = [string] [EOL] BLOCKSIZE = [number] ** [number] [EOL] [EOL] def get_hasher ( h ) : [EOL] if h == [string] : [EOL] h = DEFAULT [EOL] [EOL] try : [EOL] hashlib_hasher = getattr ( hashlib , h ) ( ) [EOL] except AttributeError : [EOL] raise ValueError ( [string] . format ( h ) ) [EOL] [EOL] [EOL] def hasher ( s ) : [EOL] if hasattr ( s , [string] ) : [EOL] for block in iter ( lambda : s . read ( BLOCKSIZE ) , [string] ) : [EOL] hashlib_hasher . update ( block ) [EOL] digest = hashlib_hasher . hexdigest ( ) [EOL] else : [EOL] warnings . warn ( [string] , DeprecationWarning ) [EOL] hashlib_hasher . update ( s ) [EOL] digest = hashlib_hasher . hexdigest ( ) [EOL] [EOL] return [string] . format ( h , digest ) [EOL] [EOL] return hasher [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Any , Tuple , Dict [EOL] import harmony [EOL] import typing [EOL] import os [EOL] import re [EOL] import fnmatch [EOL] [EOL] from harmony import hashers [EOL] from harmony import serialization [EOL] from harmony . serialization import FileSerializable [EOL] [EOL] class Ruleset ( FileSerializable ) : [EOL] [EOL] RELATIVE_PATH = [string] [EOL] _state = ( [string] , ) [EOL] [EOL] class FileInfo : [EOL] pass [EOL] [EOL] @ classmethod def init ( class_ , path ) : [EOL] r = super ( ) . init ( path ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] r . add_rule ( match = { } , hasher = hashers . DEFAULT , commit = True , action = [string] ) [EOL] [EOL] r . add_rule ( match = { [string] : [string] } , commit = False , action = [string] ) [EOL] [EOL] r . add_rule ( match = { [string] : [ [string] , [string] , [string] , [string] ] } , commit = False , action = [string] ) [EOL] r . save ( ) [EOL] return r [EOL] [EOL] @ classmethod def load ( class_ , path ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] r = super ( ) . load ( path ) [EOL] assert len ( r . rules ) > [number] [EOL] return r [EOL] [EOL] @ staticmethod def match_path ( path , pattern ) : [EOL] [EOL] anchored = pattern . startswith ( [string] ) [EOL] if anchored : [EOL] pattern = pattern [ [number] : ] [EOL] [EOL] path_elements = path . split ( os . path . sep ) [EOL] pattern_elements = pattern . split ( os . path . sep ) [EOL] [EOL] def match_recursive ( i_pattern , i_path ) : [EOL] if i_pattern >= len ( pattern_elements ) : [EOL] return i_path >= len ( path_elements ) [EOL] e_pattern = pattern_elements [ i_pattern ] [EOL] [EOL] if i_path >= len ( path_elements ) : [EOL] return e_pattern != [string] [EOL] [EOL] e_path = path_elements [ i_path ] [EOL] [EOL] if e_pattern == [string] : [EOL] [comment] [EOL] [comment] [EOL] if i_pattern == len ( pattern_elements ) - [number] : [EOL] return True [EOL] [EOL] [comment] [EOL] i = i_path [EOL] while i < len ( path_elements ) : [EOL] if match_recursive ( i_pattern + [number] , i ) : [EOL] return True [EOL] i += [number] [EOL] return False [EOL] [EOL] else : [EOL] match = fnmatch . fnmatch ( e_path , e_pattern ) [EOL] if not match : [EOL] return False [EOL] return match_recursive ( i_pattern + [number] , i_path + [number] ) [EOL] [EOL] return match_recursive ( [number] , [number] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ staticmethod def match_directory ( path , pattern ) : [EOL] path_elements = path . split ( os . path . sep ) [EOL] for e in path_elements [ : - [number] ] : [EOL] if fnmatch . fnmatch ( e , pattern ) : [EOL] return True [EOL] return False [EOL] [EOL] @ staticmethod def match_filename ( path , pattern ) : [EOL] path_elements = path . split ( os . path . sep ) [EOL] [EOL] if not isinstance ( pattern , list ) : [EOL] pattern = [ pattern ] [EOL] [EOL] for p in pattern : [EOL] if fnmatch . fnmatch ( path_elements [ - [number] ] , p ) : [EOL] return True [EOL] return False [EOL] [EOL] def __init__ ( self , path , rules = None ) : [EOL] super ( ) . __init__ ( path ) [EOL] self . rules = rules if rules else [ ] [EOL] self . matchers = { [string] : Ruleset . match_path , [string] : Ruleset . match_directory , [string] : Ruleset . match_filename , } [EOL] [EOL] def iterate_committable_files ( self , working_directory ) : [EOL] for file_info in self . iterate_files ( working_directory ) : [EOL] if file_info . rule [ [string] ] : [EOL] yield file_info [EOL] [EOL] def iterate_files ( self , working_directory ) : [EOL] [comment] [EOL] working_directory = str ( working_directory ) [EOL] [EOL] for root , dirs , files in os . walk ( working_directory ) : [EOL] for filename in files : [EOL] absfn = os . path . join ( root , filename ) [EOL] relfn = os . path . relpath ( absfn , working_directory ) [EOL] rule = self . get_rule ( relfn ) [EOL] [EOL] file_info = Ruleset . FileInfo ( ) [EOL] file_info . absolute_filename = absfn [EOL] file_info . relative_filename = relfn [EOL] file_info . rule = rule [EOL] [EOL] yield file_info [EOL] [EOL] def get_rule ( self , relfn ) : [EOL] result = { [string] : True } [EOL] for rule in self . rules : [EOL] matches = True [EOL] for matcher , parameters in rule [ [string] ] . items ( ) : [EOL] if not self . matchers [ matcher ] ( relfn , parameters ) : [EOL] matches = False [EOL] break [EOL] [EOL] if matches : [EOL] result . update ( rule ) [EOL] if rule [ [string] ] == [string] : [EOL] continue [EOL] break [EOL] return result [EOL] [EOL] [EOL] def add_rule ( self , ** kws ) : [EOL] self . rules . append ( kws ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $harmony.ruleset.Ruleset.FileInfo$ 0 0 0 0 0 0 0 $harmony.ruleset.Ruleset.FileInfo$ 0 0 0 $builtins.str$ 0 $harmony.ruleset.Ruleset.FileInfo$ 0 0 0 $builtins.str$ 0 $harmony.ruleset.Ruleset.FileInfo$ 0 0 0 0 0 0 0 $harmony.ruleset.Ruleset.FileInfo$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Set , Any , Dict [EOL] import harmony [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import os [EOL] from copy import deepcopy [EOL] [EOL] from harmony . util import shortened_id [EOL] from harmony . repository_state import RepositoryState [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] def commit ( local_location_id , working_directory , location_states , repository_state ) : [EOL] [docstring] [EOL] [EOL] id_ = local_location_id [EOL] short_id = shortened_id ( id_ ) [EOL] [EOL] paths = set ( working_directory . get_filenames ( ) ) | set ( location_states . get_all_paths ( id_ ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] wd_states = { path : working_directory . generate_file_state ( path ) for path in paths if working_directory . file_maybe_modified ( location_states . get_file_state ( id_ , path ) ) } [EOL] [EOL] location_state_cache = { path : location_states . get_file_state ( id_ , path ) for path in paths } [EOL] [EOL] [EOL] any_change = False [EOL] for path in paths : [EOL] [EOL] if path in wd_states : [EOL] file_state = location_state_cache [ path ] [EOL] new_file_state = wd_states [ path ] [EOL] changed = location_states . update_file_state ( id_ , new_file_state ) [EOL] if changed : [EOL] any_change = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not new_file_state . exists ( ) : [EOL] logger . debug ( [string] . format ( new_file_state . path ) ) [EOL] [EOL] [comment] [EOL] for path2 in paths : [EOL] [comment] [EOL] [comment] [EOL] if path2 == path or path2 not in wd_states : [EOL] continue [EOL] [EOL] path2_state = location_state_cache [ path2 ] [EOL] new_path2_state = wd_states [ path2 ] [EOL] logger . debug ( [string] . format ( path , path2 , path2_state . exists ( ) , new_path2_state . exists ( ) , file_state . digest , new_path2_state . digest ) ) [EOL] [EOL] if not path2_state . exists ( ) \ [EOL] and new_path2_state . exists ( ) \ [EOL] and new_path2_state . digest == file_state . digest : [EOL] logger . info ( [string] . format ( path , path2 ) ) [EOL] new_file_state . wipe = True [EOL] new_file_state . digest = file_state . digest [EOL] break [EOL] [EOL] repository_state . update_file_state ( new_file_state , id_ , location_states . get_clock ( id_ ) + [number] , ) [EOL] logger . debug ( [string] . format ( short_id , new_file_state . path , location_states . get_clock ( id_ ) + [number] ) ) [EOL] else : [EOL] logger . debug ( [string] . format ( short_id , path ) ) [EOL] else : [EOL] logger . debug ( [string] . format ( short_id , path ) ) [EOL] [EOL] return any_change [EOL] [EOL] [EOL] def merge ( local_state , remote_state , merger_id ) : [EOL] [docstring] [EOL] local_paths = set ( local_state . get_paths ( ) ) [EOL] remote_paths = set ( remote_state . get_paths ( ) ) [EOL] [EOL] merged = RepositoryState ( None ) [EOL] conflicts = { } [EOL] [EOL] for p in local_paths - remote_paths : [EOL] merged [ p ] = local_state [ p ] [EOL] [EOL] for p in remote_paths - local_paths : [EOL] merged [ p ] = remote_state [ p ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] paths = set ( local_state . get_paths ( ) ) & set ( remote_state . get_paths ( ) ) [EOL] [EOL] for path in paths : [EOL] local = local_state [ path ] [EOL] remote = remote_state [ path ] [EOL] [EOL] c = local . clock . compare ( remote . clock ) [EOL] if c is None : [EOL] if local . contents_different ( remote ) : [EOL] logger . debug ( [string] . format ( path , local . clock , remote . clock ) ) [EOL] conflicts [ path ] = ( local , remote ) [EOL] else : [EOL] logger . debug ( [string] . format ( path ) ) [EOL] m = deepcopy ( local ) [EOL] m . clock . update ( remote . clock ) [EOL] m . clock . increase ( merger_id ) [EOL] merged [ path ] = m [EOL] [EOL] elif c < [number] : [EOL] logger . debug ( [string] . format ( path ) ) [EOL] merged [ path ] = remote [EOL] [EOL] else : [comment] [EOL] logger . debug ( [string] . format ( path ) ) [EOL] merged [ path ] = local [EOL] [EOL] return conflicts , merged [EOL] [EOL] [EOL] [EOL] def auto_rename ( working_directory , repository_state ) : [EOL] from harmony . working_directory import WorkingDirectory [EOL] [EOL] assert isinstance ( working_directory , WorkingDirectory ) [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] for path , entry in repository_state . files . items ( ) : [EOL] logger . debug ( [string] . format ( path , entry . path , entry . wipe , ( entry . path in working_directory ) ) ) [EOL] if entry . wipe and ( entry . path in working_directory ) : [EOL] possible_targets = { e . path for e in repository_state . files . values ( ) if e . path != path and e . digest == entry . digest and not e . wipe } [EOL] logger . info ( [string] . format ( path , possible_targets ) ) [EOL] if possible_targets : [EOL] ( working_directory . path / path ) . rename ( working_directory . path / possible_targets . pop ( ) ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Set , Any , Type , Tuple [EOL] import logging [EOL] import typing [EOL] import pathlib [EOL] import harmony [EOL] import datetime [EOL] from copy import deepcopy [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] from harmony . working_directory import FileState [EOL] from harmony . serialization import Serializable , DirectorySerializable [EOL] from harmony . util import datetime_to_iso , iso_to_datetime , shortened_id [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] class LocationState ( Serializable ) : [EOL] [EOL] _state = ( [string] , [string] , [string] , [string] , ) [EOL] [EOL] def __init__ ( self , files = None , clock = None , last_modification = None , modified = False , location = None ) : [EOL] self . files = files if files else { } [EOL] self . clock = clock if clock else [number] [EOL] self . last_modification = last_modification [EOL] self . modified = modified [EOL] self . location = location [EOL] [EOL] @ classmethod def from_dict ( class_ , d ) : [EOL] r = super ( ) . from_dict ( d ) [EOL] r . files = { Path ( k ) : FileState . from_dict ( v ) for k , v in r . files . items ( ) } [EOL] return r [EOL] [EOL] [EOL] class LocationStates ( DirectorySerializable ) : [EOL] [EOL] RELATIVE_PATH = [string] [EOL] Item = LocationState [EOL] [EOL] @ staticmethod def now ( ) : [EOL] return datetime_to_iso ( datetime . datetime . now ( ) ) [EOL] [EOL] def __init__ ( self , path , items = None ) : [EOL] super ( LocationStates , self ) . __init__ ( path , items if items else { } ) [EOL] assert not items or type ( list ( items . values ( ) ) [ [number] ] ) is not dict [EOL] [EOL] def get_clock ( self , id_ ) : [EOL] return self . items [ id_ ] . clock [EOL] [EOL] def item_to_dict ( self , item ) : [EOL] if item . modified : [EOL] item . clock += [number] [EOL] r = super ( ) . item_to_dict ( item ) [EOL] item . modified = False [EOL] return r [EOL] [EOL] def get_file_state ( self , id_ , path ) : [EOL] [docstring] [EOL] path = Path ( path ) [EOL] [EOL] r = self . items . get ( id_ , LocationState ( ) ) . files . get ( path , FileState ( path = path ) ) [EOL] return r [EOL] [EOL] def get_all_paths ( self , id_ = None ) : [EOL] if id_ is None : [EOL] r = set ( ) [EOL] for d in self . items . values ( ) : [EOL] r . update ( set ( d [ [string] ] . keys ( ) ) ) [EOL] return r [EOL] [EOL] else : [EOL] return self . items [ id_ ] . files . keys ( ) if id_ in self . items else ( ) [EOL] [EOL] def get_locations ( self ) : [EOL] return self . items . keys ( ) [EOL] [EOL] def iterate_file_states ( self , id_ ) : [EOL] return self . items . get ( id_ , LocationState ( ) ) . files . values ( ) [EOL] [EOL] [EOL] def update ( self , other ) : [EOL] logger . debug ( [string] ) [EOL] for id_ , d in other . items . items ( ) : [EOL] assert isinstance ( d , LocationState ) [EOL] [EOL] if id_ not in self . items or self . items [ id_ ] . clock < d . clock : [EOL] logger . debug ( [string] . format ( shortened_id ( id_ ) , id_ ) ) [EOL] self . items [ id_ ] = deepcopy ( d ) [EOL] else : [EOL] logger . debug ( [string] . format ( id_ ) ) [EOL] logger . debug ( [string] . format ( self . items [ id_ ] . clock , self . items [ id_ ] . last_modification ) ) [EOL] logger . debug ( [string] . format ( self . items [ id_ ] . files ) ) [EOL] logger . debug ( [string] . format ( d . clock , d . last_modification ) ) [EOL] logger . debug ( [string] . format ( d . files ) ) [EOL] [EOL] def update_file_state ( self , id_ , file_state_ ) : [EOL] file_state = deepcopy ( file_state_ ) [EOL] [EOL] assert file_state . path == file_state_ . path [EOL] assert file_state . digest == file_state_ . digest [EOL] [EOL] if id_ not in self . items : [EOL] self . items [ id_ ] = LocationState ( last_modification = self . now ( ) , location = id_ ) [EOL] [EOL] p = file_state . path [EOL] files = self . items [ id_ ] . files [EOL] if p not in files or file_state . contents_different ( files [ p ] ) : [EOL] files [ p ] = file_state [EOL] self . items [ id_ ] . modified = True [EOL] self . items [ id_ ] . last_modification = self . now ( ) [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] def was_modified ( self , id_ ) : [EOL] return self . items [ id_ ] . modified [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[harmony.location_states.LocationState]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL]	0 0
[EOL] from typing import List , Any , TextIO [EOL] import typing [EOL] import sys [EOL] [EOL] def write_table ( rows , headers = None ) : [EOL] [docstring] [EOL] [EOL] spacer = [string] [EOL] filler = [string] [EOL] [EOL] out = sys . stdout [EOL] [EOL] if headers is not None : [EOL] max_column_widths = [ len ( str ( s ) ) for s in headers ] [EOL] else : [EOL] max_column_widths = [ len ( str ( s ) ) for s in rows [ [number] ] ] [EOL] [EOL] for row in rows : [EOL] max_column_widths = [ max ( c , len ( str ( s ) ) ) for c , s in zip ( max_column_widths , row ) ] [EOL] [EOL] def print_row ( row ) : [EOL] for s , w in zip ( row , max_column_widths ) : [EOL] ss = str ( s ) [EOL] out . write ( ss + filler * ( w - len ( ss ) ) ) [EOL] out . write ( spacer ) [EOL] out . write ( [string] ) [EOL] [EOL] if headers is not None : [EOL] print_row ( headers ) [EOL] out . write ( [string] * ( sum ( max_column_widths ) + len ( spacer ) * len ( headers ) ) + [string] ) [EOL] [EOL] for row in rows : [EOL] print_row ( row ) [EOL] [EOL] def write_list ( elements ) : [EOL] out = sys . stdout [EOL] [EOL] for e in elements : [EOL] out . write ( e + [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] from harmony . repository import Repository [EOL] [EOL] class Command : [EOL] aliases = ( ) [EOL] [EOL] def add_to_parser ( self , subparsers ) : [EOL] p = subparsers . add_parser ( self . command , aliases = self . aliases , help = self . help ) [EOL] self . parser = p [EOL] p . set_defaults ( obj = self ) [EOL] self . setup_parser ( p ) [EOL] [EOL] def setup_parser ( self , p ) : [EOL] pass [EOL] [EOL] def make_repository ( self , ns ) : [EOL] return Repository . find ( ns . cwd ) [EOL] [EOL] def run ( self , parser , ns ) : [EOL] return self . execute ( ns ) [EOL] [EOL] class CommandGroup : [EOL] aliases = ( ) [EOL] commands = ( ) [EOL] [EOL] def add_to_parser ( self , subparsers ) : [EOL] for cmd in [ self . command ] + list ( self . aliases ) : [EOL] p = subparsers . add_parser ( cmd , help = self . help ) [EOL] self . parser = p [EOL] p . set_defaults ( obj = self ) [EOL] self . setup_parser ( p ) [EOL] [EOL] def setup_parser ( self , p ) : [EOL] subparsers = p . add_subparsers ( title = [string] ) [EOL] for command in self . commands : [EOL] command . add_to_parser ( subparsers ) [EOL] [EOL] def make_repository ( self , ns ) : [EOL] return Repository . find ( ns . cwd ) [EOL] [EOL] def run ( self , parser , ns ) : [EOL] obj = None [EOL] [EOL] if hasattr ( ns , [string] ) : [EOL] if isinstance ( ns . obj , list ) : [EOL] obj = ns . obj . pop ( ) [EOL] if not ns . obj : [EOL] del ns . obj [EOL] else : [EOL] obj = ns . obj [EOL] del ns . obj [EOL] [EOL] if obj is not None : [EOL] return obj . run ( parser , ns ) [EOL] else : [EOL] print ( self . parser . format_help ( ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import argparse [EOL] import os [EOL] import sys [EOL] import argparse [EOL] import logging [EOL] [EOL] from harmony . cli . commands import COMMANDS [EOL] [EOL] def run_command ( args ) : [EOL] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] , default = os . getcwd ( ) ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] , default = [string] ) [EOL] [EOL] subparsers = parser . add_subparsers ( title = [string] ) [EOL] for command in COMMANDS : [EOL] command . add_to_parser ( subparsers ) [EOL] [EOL] ns = parser . parse_args ( args ) [EOL] [EOL] logging . getLogger ( ) . setLevel ( getattr ( logging , ns . loglevel ) ) [EOL] [EOL] if hasattr ( ns , [string] ) : [EOL] [EOL] ns . obj . run ( parser , ns ) [EOL] if [number] : [EOL] try : [EOL] ns . obj . run ( parser , ns ) [EOL] except Exception as e : [EOL] logging . error ( type ( e ) ) [EOL] logging . error ( e ) [EOL] sys . exit ( [number] ) [EOL] [EOL] else : [EOL] print ( parser . format_help ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] logging . basicConfig ( level = logging . WARN , format = [string] , style = [string] ) [EOL] run_command ( sys . argv [ [number] : ] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import harmony [EOL] import logging [EOL] import logging [EOL] from harmony . clock import Clock [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] def test_clock_construction ( ) : [EOL] [comment] [EOL] c1 = Clock ( a = [number] , b = [number] , c = - [number] ) [EOL] c2 = Clock ( ) [EOL] [EOL] def test_clock_compare_equal ( ) : [EOL] [EOL] assert Clock ( ) == Clock ( ) [EOL] assert Clock ( a = [number] ) == Clock ( ) [EOL] assert Clock ( ) == Clock ( a = [number] ) [EOL] assert Clock ( ) == Clock ( a = [number] , b = [number] ) [EOL] assert Clock ( ) == Clock ( z = [number] , cc = [number] , b = [number] ) [EOL] assert Clock ( a = [number] ) == Clock ( b = [number] ) [EOL] assert Clock ( a = [number] ) == Clock ( a = [number] ) [EOL] assert Clock ( a = [number] ) == Clock ( a = [number] ) [EOL] assert Clock ( a = [number] ) == Clock ( a = [number] , b = [number] ) [EOL] assert Clock ( a = [number] , x = [number] , c = [number] , b = [number] ) == Clock ( c = [number] , x = [number] , a = [number] , zz = [number] , ya = [number] ) [EOL] [EOL] [EOL] def test_clock_compare_lower ( ) : [EOL] [EOL] assert Clock ( ) < Clock ( a = [number] ) [EOL] assert Clock ( a = [number] ) < Clock ( a = [number] , b = [number] ) [EOL] assert Clock ( a = [number] ) < Clock ( a = [number] ) [EOL] assert Clock ( a = [number] ) < Clock ( a = [number] , b = [number] ) [EOL] [EOL] def test_clock_compare_greater ( ) : [EOL] [EOL] assert Clock ( a = [number] ) > Clock ( ) [EOL] assert Clock ( a = [number] , b = [number] ) > Clock ( a = [number] ) [EOL] assert Clock ( a = [number] ) > Clock ( a = [number] ) [EOL] assert Clock ( a = [number] , b = [number] ) > Clock ( a = [number] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from typing import Any [EOL] import logging [EOL] import typing [EOL] import logging [EOL] from harmony . serialization import Serializable [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Dummy ( Serializable ) : [EOL] def __init__ ( self , i , s , l , d ) : [EOL] self . i = i [EOL] self . s = s [EOL] self . l = l [EOL] self . d = d [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . i == other . i \ [EOL] and self . s == other . s \ [EOL] and self . l == other . l \ [EOL] and self . d == other . d [EOL] [EOL] def test_dict_conversion ( ) : [EOL] [EOL] t1 = Dummy ( i = [number] , s = [string] , l = [ [ ] , [ [number] , [ ] ] , [ [number] , [ [number] , [ ] ] ] ] , d = { [string] : [string] , [number] : [number] , [string] : [ [number] , [number] , [number] ] , } , ) [EOL] [EOL] d = t1 . to_dict ( ) [EOL] t2 = Dummy . from_dict ( d ) [EOL] [EOL] assert t1 == t2 [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Set , Any , List [EOL] import typing [EOL] import pathlib [EOL] import tempfile [EOL] import shutil [EOL] import os [EOL] import os . path [EOL] import unittest [EOL] import warnings [EOL] [EOL] from pathlib import Path [EOL] [EOL] KEEP_TEMPDIRS = True [EOL] [EOL] class TempDir : [EOL] def __init__ ( self ) : [EOL] self . path = Path ( tempfile . mkdtemp ( prefix = [string] ) ) . resolve ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] return self . path [EOL] [EOL] def __exit__ ( self , exc , value , tb ) : [EOL] if not KEEP_TEMPDIRS : [EOL] shutil . rmtree ( self . name ) [EOL] [EOL] [EOL] def directories_equal ( dir1 , dir2 , msg = [string] , failure_base = None ) : [EOL] [EOL] dir1 = Path ( dir1 ) [EOL] dir2 = Path ( dir2 ) [EOL] [EOL] if failure_base is None : [EOL] failure_base = [string] . format ( dir1 , dir2 ) [EOL] [EOL] if not dir1 . is_dir ( ) or not dir2 . is_dir ( ) : [EOL] return False [EOL] [EOL] files_dir1 = set ( f . name for f in dir1 . iterdir ( ) ) [EOL] files_dir2 = set ( f . name for f in dir2 . iterdir ( ) ) [EOL] [EOL] if files_dir1 != files_dir2 : [EOL] s = [string] . format ( failure_base , dir1 , dir2 , [string] + ( [string] . join ( str ( f ) for f in ( files_dir1 & files_dir2 ) ) or [string] ) , [string] + ( [string] . join ( str ( f ) for f in ( files_dir1 - files_dir2 ) ) or [string] ) , [string] + ( [string] . join ( str ( f ) for f in ( files_dir2 - files_dir1 ) ) or [string] ) , ) [EOL] warnings . warn ( s ) [EOL] return False [EOL] [EOL] directories = [ f for f in files_dir1 if ( dir1 / f ) . is_dir ( ) ] [EOL] for directory in directories : [EOL] r = directories_equal ( dir1 / directory , dir2 / directory , msg = msg , failure_base = failure_base ) [EOL] if not r : [EOL] return False [EOL] [EOL] files = [ f for f in files_dir1 if ( dir1 / f ) . is_file ( ) ] [EOL] for filename in files : [EOL] if ( dir1 / filename ) . read_bytes ( ) != ( dir2 / filename ) . read_bytes ( ) : [EOL] s = [string] . format ( failure_base , dir1 / filename , dir2 / filename , ( dir1 / filename ) , ( dir1 / filename ) . read_text ( ) , ( dir2 / filename ) , ( dir2 / filename ) . read_text ( ) , ) [EOL] warnings . warn ( s ) [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] class TestCase ( unittest . TestCase ) : [EOL] [EOL] def assertFilesEqual ( self , a , b ) : [EOL] self . assertFileExists ( a ) [EOL] self . assertFileExists ( b ) [EOL] with open ( a , [string] ) as f : [EOL] sa = f . read ( ) [EOL] with open ( b , [string] ) as f : [EOL] sb = f . read ( ) [EOL] self . assertEqual ( sa , sb ) [EOL] [EOL] def assertFileNotExists ( self , * args , ** kws ) : [EOL] msg = kws . get ( [string] , [string] ) [EOL] filename = os . path . join ( * args ) [EOL] if os . path . exists ( filename ) : [EOL] self . fail ( [string] . format ( filename , msg ) ) [EOL] [EOL] def assertFileExists ( self , * args , ** kws ) : [EOL] msg = kws . get ( [string] , [string] ) [EOL] filename = os . path . join ( * args ) [EOL] if not os . path . exists ( filename ) : [EOL] self . fail ( [string] . format ( filename , msg ) ) [EOL] [EOL] def assertDirectoriesEqual ( self , dir1 , dir2 , msg = [string] , failure_base = None ) : [EOL] [EOL] if failure_base is None : [EOL] failure_base = [string] . format ( dir1 , dir2 ) [EOL] [EOL] if not os . path . isdir ( dir1 ) : [EOL] self . fail ( [string] . format ( failure_base , dir1 ) ) [EOL] if not os . path . isdir ( dir2 ) : [EOL] self . fail ( [string] . format ( failure_base , dir2 ) ) [EOL] [EOL] files_dir1 = set ( os . listdir ( dir1 ) ) [EOL] files_dir2 = set ( os . listdir ( dir2 ) ) [EOL] [EOL] if files_dir1 != files_dir2 : [EOL] s = [string] . format ( failure_base , dir1 , dir2 , [string] + ( [string] . join ( f for f in ( files_dir1 & files_dir2 ) ) or [string] ) , [string] + ( [string] . join ( f for f in ( files_dir1 - files_dir2 ) ) or [string] ) , [string] + ( [string] . join ( f for f in ( files_dir2 - files_dir1 ) ) or [string] ) , ) [EOL] self . fail ( s ) [EOL] [EOL] directories = [ f for f in files_dir1 if os . path . isdir ( os . path . join ( dir1 , f ) ) ] [EOL] for directory in directories : [EOL] self . assertDirectoriesEqual ( os . path . join ( dir1 , directory ) , os . path . join ( dir2 , directory ) , msg = msg , failure_base = failure_base ) [EOL] [EOL] files = [ f for f in files_dir1 if os . path . isfile ( os . path . join ( dir1 , f ) ) ] [EOL] for filename in files : [EOL] self . assertFileContentsEqual ( os . path . join ( dir1 , filename ) , os . path . join ( dir2 , filename ) , ) [EOL] [EOL] [EOL] def assertFileContentsEqual ( self , filename1 , filename2 , msg = [string] ) : [EOL] with open ( filename1 , [string] ) as f1 , open ( filename2 , [string] ) as f2 : [EOL] s1 = f1 . read ( ) [EOL] s2 = f2 . read ( ) [EOL] self . assertEqual ( s1 , s2 , msg ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import logging [EOL] import typing [EOL] import io [EOL] import sys [EOL] [EOL] import os [EOL] from pathlib import Path [EOL] import logging [EOL] from io import BytesIO [EOL] from pytest import raises [EOL] [EOL] from tests . utils import * [EOL] from harmony . hashers import get_hasher [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] def test_throw_on_incorrect_hasher_name ( ) : [EOL] with raises ( ValueError ) : [EOL] get_hasher ( [string] ) [EOL] [EOL] def test_has_sha1 ( ) : [EOL] hasher = get_hasher ( [string] ) [EOL] assert hasher is not None [EOL] [EOL] def test_sha1_of_empty ( ) : [EOL] empty = BytesIO ( ) [EOL] hasher = get_hasher ( [string] ) [EOL] [EOL] digest = hasher ( empty ) [EOL] assert digest == [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Set , Any , Dict [EOL] import logging [EOL] import typing [EOL] import harmony [EOL] import sys [EOL] [EOL] import os [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] from tests . utils import * [EOL] from harmony . working_directory import WorkingDirectory [EOL] from harmony . ruleset import Ruleset [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] def make_mess ( d ) : [EOL] [docstring] [EOL] real_filenames = set ( ) [EOL] [EOL] ( d / [string] ) . write_text ( [string] ) [EOL] real_filenames . add ( Path ( [string] ) ) [EOL] [EOL] foobar = d / [string] / [string] [EOL] yyy_txt = foobar / [string] [EOL] [EOL] foobar . mkdir ( parents = True ) [EOL] yyy_txt . write_text ( [string] ) [EOL] real_filenames . add ( Path ( [string] ) / [string] / [string] ) [EOL] [EOL] ( d / [string] ) . symlink_to ( foobar ) [EOL] ( d / [string] ) . symlink_to ( yyy_txt ) [EOL] [EOL] symlinks = { [string] : [string] , [string] : [string] , } [EOL] [EOL] return real_filenames , symlinks [EOL] [EOL] [EOL] def ruleset_all ( d ) : [EOL] return Ruleset ( d ) [EOL] [EOL] def test_get_filenames_normalized ( ) : [EOL] with TempDir ( ) as d : [EOL] real_filenames , _ = make_mess ( d ) [EOL] wd = WorkingDirectory ( d , ruleset_all ( d ) ) [EOL] [EOL] filenames = wd . get_filenames ( ) [EOL] assert set ( real_filenames ) == set ( filenames ) [EOL] [EOL] def test_contains_normalized ( ) : [EOL] with TempDir ( ) as d : [EOL] real_filenames , symlinks = make_mess ( d ) [EOL] wd = WorkingDirectory ( d , ruleset_all ( d ) ) [EOL] [EOL] for fn in real_filenames : [EOL] assert fn in wd [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for fn in symlinks : [EOL] assert fn in wd [EOL] [EOL] def test_generate_file_state_normalized ( ) : [EOL] [docstring] [EOL] [EOL] with TempDir ( ) as d : [EOL] real_filenames , symlinks = make_mess ( d ) [EOL] wd = WorkingDirectory ( d , ruleset_all ( d ) ) [EOL] [EOL] for fn in real_filenames : [EOL] state = wd . generate_file_state ( fn ) [EOL] assert Path ( state . path ) == Path ( fn ) [EOL] [EOL] for fn , real_fn in symlinks . items ( ) : [EOL] state = wd . generate_file_state ( fn ) [EOL] assert Path ( state . path ) == Path ( real_fn ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0