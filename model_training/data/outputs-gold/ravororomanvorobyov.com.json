import builtins [EOL] from typing import Type , List [EOL] import config [EOL] import typing [EOL] import os [EOL] [EOL] [EOL] class BaseConfig : [EOL] DEBUG = False [EOL] TESTING = False [EOL] [EOL] [comment] [EOL] BASE_DIR = os . path . dirname ( __file__ ) [EOL] [EOL] [comment] [EOL] ARTICLES_DIR = os . path . join ( BASE_DIR , [string] , [string] ) [EOL] [EOL] [EOL] class ProdConfig ( BaseConfig ) : [EOL] pass [EOL] [EOL] [EOL] class DevConfig ( BaseConfig ) : [EOL] DEBUG = True [EOL] PROFILE = False [EOL] PROFILE_RESTRICTIONS = [ [number] ] [EOL] [EOL] [EOL] class TestConfig ( BaseConfig ) : [EOL] TESTING = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Optional , Type , List [EOL] import app [EOL] import builtins [EOL] import typing [EOL] import os [EOL] from collections import namedtuple [EOL] from typing import Optional , List [EOL] [EOL] from flask import current_app [EOL] [EOL] from . utils import list_without_nones [EOL] from . utils . markdown import read_markdown_file [EOL] [EOL] Article = namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] class ArticleRepo : [EOL] @ staticmethod def all ( ) : [EOL] [docstring] [EOL] basenames_unsorted = os . listdir ( current_app . config [ [string] ] ) [EOL] basenames = sorted ( basenames_unsorted , reverse = True ) [EOL] return list_without_nones ( [ ArticleRepo . get ( b ) for b in basenames ] ) [EOL] [EOL] @ staticmethod def get ( basename ) : [EOL] [docstring] [EOL] path = os . path . join ( current_app . config [ [string] ] , basename ) [EOL] if not os . path . isfile ( path ) : [EOL] return None [EOL] html , meta = read_markdown_file ( path ) [EOL] slug = os . path . splitext ( basename ) [ [number] ] [EOL] return Article ( title = meta . get ( [string] ) , url = [string] . format ( slug ) , body = html ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[app.repositories.Article]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Article]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[Article]$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Type[app.repositories.Article]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
import flask [EOL] from flask import Config , Flask [EOL] [EOL] [EOL] def create_app ( config ) : [EOL] app = Flask ( __name__ ) [EOL] app . config . from_object ( config ) [EOL] [EOL] from . _handle_errors import app_handle_errors [EOL] app = app_handle_errors ( app ) [EOL] [EOL] from . _url_trailing_slash import app_url_trailing_slash [EOL] app = app_url_trailing_slash ( app ) [EOL] [EOL] from . controllers import bp as controllers [EOL] app . register_blueprint ( controllers ) [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import flask [EOL] [docstring] [EOL] [EOL] from flask import Flask , redirect , request [EOL] [EOL] [EOL] [comment] [EOL] def app_url_trailing_slash ( app ) : [EOL] app . url_map . strict_slashes = False [EOL] [EOL] @ app . before_request def remove_trailing_slash ( ) : [EOL] path = request . path [EOL] if path != [string] and path . endswith ( [string] ) : [EOL] return redirect ( path . rstrip ( [string] ) ) [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import werkzeug [EOL] import flask [EOL] [docstring] [EOL] [EOL] from flask import Flask , Response , render_template [EOL] from werkzeug . exceptions import HTTPException [EOL] from werkzeug . http import HTTP_STATUS_CODES [EOL] [EOL] [EOL] [comment] [EOL] def app_handle_errors ( app ) : [EOL] def handle_error ( e ) : [EOL] return render_template ( [string] , code = e . code , description = e . description ) , e . code [EOL] [EOL] for code in HTTP_STATUS_CODES : [EOL] try : [EOL] app . register_error_handler ( code , handle_error ) [EOL] except KeyError : [EOL] pass [comment] [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List [EOL] import app [EOL] import builtins [EOL] import flask [EOL] import typing [EOL] from flask import abort , Blueprint , redirect , render_template , Response , url_for [EOL] from functools import lru_cache [EOL] [EOL] from . repositories import ArticleRepo [EOL] from . utils import slug_regex [EOL] [EOL] bp = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ bp . route ( [string] ) @ lru_cache ( ) def home ( ) : [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] [EOL] @ bp . route ( [string] ) @ lru_cache ( ) def about ( ) : [EOL] return render_template ( [string] ) [EOL] [EOL] [EOL] @ bp . route ( [string] ) @ lru_cache ( ) def contact ( ) : [EOL] return render_template ( [string] ) [EOL] [EOL] [EOL] @ bp . route ( [string] ) @ lru_cache ( ) def blog_index ( ) : [EOL] articles = ArticleRepo . all ( ) [EOL] return render_template ( [string] , articles = articles ) [EOL] [EOL] [EOL] @ bp . route ( [string] ) @ lru_cache ( ) def blog_article ( slug ) : [EOL] if not slug_regex . match ( slug ) : [EOL] return abort ( [number] ) [EOL] basename = [string] . format ( slug ) [EOL] article = ArticleRepo . get ( basename ) [EOL] if not article : [EOL] return abort ( [number] ) [EOL] return render_template ( [string] , ** article . _asdict ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Union , Tuple [EOL] import typing [EOL] import builtins [EOL] import markdown [EOL] from typing import Dict , List , Tuple , Union [EOL] [EOL] from markdown import Markdown [EOL] [EOL] md = Markdown ( extensions = [ [string] , [string] ] ) [EOL] [EOL] [EOL] def read_markdown_file ( path ) : [EOL] [docstring] [EOL] with open ( path , encoding = [string] ) as f : [EOL] text = f . read ( ) [EOL] html_raw = md . convert ( text ) [EOL] html = _convert_html ( html_raw ) [EOL] meta_raw = md . Meta [EOL] meta = { k : _convert_meta_value ( v ) for k , v in meta_raw . items ( ) } [EOL] return html , meta [EOL] [EOL] [EOL] def _convert_html ( html ) : [EOL] [docstring] [EOL] return html . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def _convert_meta_value ( v ) : [EOL] [docstring] [EOL] if len ( v ) == [number] : [EOL] if len ( v [ [number] ] ) == [number] : [EOL] return None [EOL] return v [ [number] ] [EOL] return v [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] from werkzeug . exceptions import abort [EOL] [EOL] from tests import BaseCase , response_html [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] [EOL] [comment] [EOL] @ self . app . route ( [string] ) def f ( code ) : [EOL] abort ( code ) [EOL] [EOL] def test_errors_common ( self ) : [EOL] [docstring] [EOL] common_errors = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] for code in common_errors : [EOL] response = self . http . get ( [string] . format ( code ) ) [EOL] html = response_html ( response ) [EOL] assert response . status_code == code [EOL] assert [string] == html . select_one ( [string] ) . text [EOL] assert str ( code ) in html . select_one ( [string] ) . text [EOL] [EOL] def test_errors_rare ( self ) : [EOL] [docstring] [EOL] rare_errors = [ [number] , [number] , [number] , [number] ] [EOL] for code in rare_errors : [EOL] with self . assertRaises ( LookupError ) : [EOL] self . http . get ( [string] . format ( code ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import bs4 [EOL] import flask [EOL] from unittest import TestCase [EOL] [EOL] from bs4 import BeautifulSoup [EOL] from flask import Response [EOL] [EOL] import config [EOL] from app import create_app [EOL] [EOL] [EOL] class BaseCase ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . app = create_app ( config . TestConfig ) [EOL] self . http = self . app . test_client ( ) [EOL] [EOL] [EOL] def response_html ( response ) : [EOL] [docstring] [EOL] return BeautifulSoup ( response . get_data ( as_text = True ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.BeautifulSoup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from tests import BaseCase [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] [EOL] def test_no_slash ( self ) : [EOL] [docstring] [EOL] [EOL] @ self . app . route ( [string] ) def f ( ) : [EOL] return [string] , [number] [EOL] [EOL] response = self . http . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] assert response . status_code not in range ( [number] , [number] ) [EOL] assert response . headers . get ( [string] ) is None [EOL] [EOL] def test_end_slash ( self ) : [EOL] [docstring] [EOL] [EOL] @ self . app . route ( [string] ) def f ( ) : [EOL] return [string] , [number] [EOL] [EOL] response = self . http . get ( [string] ) [EOL] assert response . status_code != [number] [EOL] assert response . status_code in range ( [number] , [number] ) [EOL] assert response . headers . get ( [string] ) . endswith ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Optional [EOL] import app [EOL] import unittest [EOL] import typing [EOL] import os [EOL] from unittest . mock import patch , Mock [EOL] [EOL] from app . repositories import ArticleRepo , Article [EOL] from tests import BaseCase [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] @ patch ( [string] ) @ patch . object ( os . path , [string] ) def test_ok ( self , mock_isfile , mock_read ) : [EOL] [docstring] [EOL] mock_article = Article ( title = [string] , url = [string] , body = [string] ) [EOL] mock_isfile . return_value = True [EOL] mock_read . return_value = ( mock_article . body , { [string] : mock_article . title } ) [EOL] [EOL] with self . app . app_context ( ) : [EOL] result = ArticleRepo . get ( [string] ) [EOL] [EOL] assert result == mock_article [EOL] [EOL] @ patch . object ( os . path , [string] ) def test_not_found ( self , mock_isfile ) : [EOL] [docstring] [EOL] mock_isfile . return_value = False [EOL] [EOL] with self . app . app_context ( ) : [EOL] result = ArticleRepo . get ( [string] ) [EOL] [EOL] assert result is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[app.repositories.Article]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[app.repositories.Article]$ 0 0 0
from typing import Any , Dict , List [EOL] import app [EOL] import unittest [EOL] import typing [EOL] import os [EOL] from unittest . mock import patch , Mock [EOL] [EOL] from app . repositories import ArticleRepo , Article [EOL] from tests import BaseCase [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] self . mock_articles_map = { [string] : Article ( title = [string] , url = [string] , body = [string] ) , [string] : Article ( title = [string] , url = [string] , body = [string] ) , [string] : Article ( title = [string] , url = [string] , body = [string] ) , } [EOL] [EOL] @ patch . object ( ArticleRepo , [string] ) @ patch . object ( os , [string] ) def test_all ( self , mock_listdir , mock_get ) : [EOL] [docstring] [EOL] mock_listdir . return_value = [ [string] , [string] , [string] ] [EOL] mock_get . side_effect = lambda x : self . mock_articles_map [ x ] [EOL] [EOL] with self . app . app_context ( ) : [EOL] result = ArticleRepo . all ( ) [EOL] [EOL] assert len ( result ) == [number] [EOL] [EOL] @ patch . object ( ArticleRepo , [string] ) @ patch . object ( os , [string] ) def test_order ( self , mock_listdir , mock_get ) : [EOL] [docstring] [EOL] unordered_basenames = [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] [EOL] for basenames in unordered_basenames : [EOL] mock_listdir . return_value = basenames [EOL] mock_get . side_effect = lambda x : self . mock_articles_map [ x ] [EOL] [EOL] with self . app . app_context ( ) : [EOL] result = ArticleRepo . all ( ) [EOL] [EOL] assert result [ [number] ] . title == [string] [EOL] assert result [ [number] ] . title == [string] [EOL] assert result [ [number] ] . title == [string] [EOL] [EOL] @ patch . object ( ArticleRepo , [string] ) @ patch . object ( os , [string] ) def test_none ( self , mock_listdir , mock_get ) : [EOL] [docstring] [EOL] mock_listdir . return_value = [ ] [EOL] mock_get . side_effect = lambda x : self . mock_articles_map [ x ] [EOL] [EOL] with self . app . app_context ( ) : [EOL] result = ArticleRepo . all ( ) [EOL] [EOL] assert len ( result ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[app.repositories.Article]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[app.repositories.Article]$ 0 0 0 0
from unittest . mock import patch , mock_open [EOL] [EOL] from app . utils . markdown import read_markdown_file [EOL] from tests import BaseCase [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] def test_convert_file ( self ) : [EOL] [docstring] [EOL] mock_markdown = [string] . format ( [string] , [string] ) [EOL] [EOL] with patch ( [string] , mock_open ( read_data = mock_markdown ) ) as _ : [EOL] html , meta = read_markdown_file ( [string] ) [EOL] [EOL] assert html == [string] [EOL] assert meta == { [string] : [string] } [EOL] [EOL] def test_convert_table ( self ) : [EOL] [docstring] [EOL] mock_markdown = [string] . format ( [string] , [string] , [string] , [string] ) [EOL] [EOL] with patch ( [string] , mock_open ( read_data = mock_markdown ) ) as _ : [EOL] html , _ = read_markdown_file ( [string] ) [EOL] [EOL] assert [string] not in html [EOL] assert [string] in html [EOL] [EOL] def test_convert_meta_empty ( self ) : [EOL] [docstring] [EOL] mock_markdown = [string] . format ( [string] , [string] ) [EOL] [EOL] with patch ( [string] , mock_open ( read_data = mock_markdown ) ) as _ : [EOL] _ , meta = read_markdown_file ( [string] ) [EOL] [EOL] assert meta [ [string] ] != [ ] [EOL] assert meta [ [string] ] is None [EOL] [EOL] def test_convert_meta_single ( self ) : [EOL] [docstring] [EOL] mock_markdown = [string] . format ( [string] , [string] ) [EOL] [EOL] with patch ( [string] , mock_open ( read_data = mock_markdown ) ) as _ : [EOL] _ , meta = read_markdown_file ( [string] ) [EOL] [EOL] assert meta [ [string] ] != [ [string] ] [EOL] assert meta [ [string] ] == [string] [EOL] [EOL] def test_convert_meta_multiple ( self ) : [EOL] [docstring] [EOL] mock_markdown = [string] . format ( [string] , [string] ) [EOL] [EOL] with patch ( [string] , mock_open ( read_data = mock_markdown ) ) as _ : [EOL] _ , meta = read_markdown_file ( [string] ) [EOL] [EOL] assert meta [ [string] ] != [ [string] ] [EOL] assert meta [ [string] ] == [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List , Optional [EOL] import typing [EOL] from app . utils import list_without_nones [EOL] from tests import BaseCase [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] def test_remove_nones ( self ) : [EOL] [docstring] [EOL] lst = [ [number] , None , [number] , [number] , None , None , [number] , [number] ] [EOL] assert list_without_nones ( lst ) == [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] def test_no_nones ( self ) : [EOL] [docstring] [EOL] lst = [ [number] , [number] , [number] , [number] , [number] ] [EOL] assert list_without_nones ( lst ) == lst [EOL] [EOL] def test_only_nones ( self ) : [EOL] [docstring] [EOL] lst = [ None , None , None ] [EOL] assert list_without_nones ( lst ) == [ ] [EOL] [EOL] def test_empty ( self ) : [EOL] [docstring] [EOL] lst = [ ] [EOL] assert list_without_nones ( lst ) == [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0
from typing import Any , List [EOL] import app [EOL] import unittest [EOL] import typing [EOL] from unittest . mock import patch , Mock [EOL] [EOL] from app . controllers import blog_index [EOL] from app . repositories import ArticleRepo , Article [EOL] from tests import BaseCase , response_html [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] blog_index . cache_clear ( ) [EOL] [EOL] @ patch . object ( ArticleRepo , [string] ) def test_ok ( self , mock_all ) : [EOL] [docstring] [EOL] mock_result = [ Article ( title = [string] , url = [string] , body = [string] ) , Article ( title = [string] , url = [string] , body = [string] ) , Article ( title = [string] , url = [string] , body = [string] ) , ] [EOL] mock_all . return_value = mock_result [EOL] [EOL] response = self . http . get ( [string] ) [EOL] html = response_html ( response ) [EOL] links = html . select ( [string] ) [EOL] [EOL] assert response . status_code == [number] [EOL] for i , _ in enumerate ( links ) : [EOL] assert links [ i ] . text == mock_result [ i ] . title [EOL] assert links [ i ] . attrs [ [string] ] == mock_result [ i ] . url [EOL] [EOL] @ patch . object ( ArticleRepo , [string] ) def test_empty ( self , mock_all ) : [EOL] [docstring] [EOL] mock_all . return_value = [ ] [EOL] [EOL] response = self . http . get ( [string] ) [EOL] html = response_html ( response ) [EOL] links = html . select ( [string] ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert len ( links ) == [number] [EOL] assert [string] in html . select_one ( [string] ) . text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from tests import BaseCase , response_html [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] def test_ok ( self ) : [EOL] [docstring] [EOL] response = self . http . get ( [string] ) [EOL] html = response_html ( response ) [EOL] assert response . status_code == [number] [EOL] assert html . select_one ( [string] ) . text == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from flask import url_for [EOL] [EOL] from tests import BaseCase [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] def test_ok ( self ) : [EOL] [docstring] [EOL] response = self . http . get ( [string] ) [EOL] assert response . status_code == [number] [EOL] with self . app . test_request_context ( ) : [EOL] assert response . headers [ [string] ] . endswith ( url_for ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import app [EOL] import unittest [EOL] import typing [EOL] from unittest . mock import patch , Mock [EOL] [EOL] from app . controllers import blog_article [EOL] from app . repositories import ArticleRepo , Article [EOL] from tests import BaseCase , response_html [EOL] [EOL] [EOL] class Test ( BaseCase ) : [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( ) [EOL] blog_article . cache_clear ( ) [EOL] [EOL] @ patch . object ( ArticleRepo , [string] ) def test_ok ( self , mock_get ) : [EOL] [docstring] [EOL] mock_result = Article ( title = [string] , url = [string] , body = [string] ) [EOL] mock_get . return_value = mock_result [EOL] [EOL] response = self . http . get ( [string] ) [EOL] html = response_html ( response ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert html . select_one ( [string] ) . text == mock_result . title [EOL] assert mock_result . body in html . select_one ( [string] ) . text [EOL] [EOL] @ patch . object ( ArticleRepo , [string] ) def test_not_found ( self , mock_get ) : [EOL] [docstring] [EOL] mock_get . return_value = None [EOL] [EOL] response = self . http . get ( [string] ) [EOL] html = response_html ( response ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert [string] in html . select_one ( [string] ) . text [EOL] assert [string] in html . select_one ( [string] ) . text [EOL] [EOL] def test_invalid_slug ( self ) : [EOL] [docstring] [EOL] response = self . http . get ( [string] ) [EOL] html = response_html ( response ) [EOL] [EOL] assert response . status_code == [number] [EOL] assert [string] in html . select_one ( [string] ) . text [EOL] assert [string] in html . select_one ( [string] ) . text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0