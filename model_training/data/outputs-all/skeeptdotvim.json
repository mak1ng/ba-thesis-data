[comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] __doc__ = [string] [EOL] [EOL] [comment] [EOL] [EOL] import os [EOL] import sys [EOL] import glob [EOL] import errno [EOL] import textwrap [EOL] from os . path import join , realpath , abspath , isdir , isfile [EOL] [EOL] [EOL] def force_symlink ( file1 , file2 ) : [EOL] try : [EOL] os . symlink ( file1 , file2 ) [EOL] except OSError as e : [EOL] if e . errno == errno . EEXIST : [EOL] os . remove ( file2 ) [EOL] os . symlink ( file1 , file2 ) [EOL] [EOL] [EOL] def usage ( ) : [EOL] sys . stdout . write ( textwrap . dedent ( [string] ) ) [EOL] [EOL] [EOL] def do_recursion ( origin , dirname ) : [EOL] AlternatePrefix = [string] [EOL] dirlist = glob . glob ( dirname + os . sep + [string] ) [EOL] for name in dirlist : [EOL] newName = name . replace ( origin , [string] ) [EOL] newName = AlternatePrefix + os . sep + newName [EOL] if os . path . isdir ( name ) : [EOL] [comment] [EOL] if not isdir ( newName ) : [EOL] [comment] [EOL] print ( [string] , newName ) [EOL] os . mkdir ( newName ) [EOL] do_recursion ( origin , name ) [EOL] else : [EOL] print ( name , [string] , newName ) [EOL] if not isfile ( newName ) : [EOL] force_symlink ( os . getcwd ( ) + os . sep + name , os . getcwd ( ) + os . sep + newName ) [EOL] [EOL] [EOL] def create_symlinks ( origin , destin , display_passage = True ) : [EOL] [docstring] [EOL] origin = realpath ( origin ) [EOL] destin = abspath ( destin ) [EOL] os . chdir ( origin ) [EOL] [comment] [EOL] if display_passage is False and os . path . isdir ( destin ) is False : [EOL] os . makedirs ( destin ) [EOL] for root , dirs , files in os . walk ( os . curdir ) : [EOL] for dirn in dirs : [EOL] [comment] [EOL] dir_dest = join ( join ( destin , root ) , dirn ) [EOL] if os . path . exists ( dir_dest ) is False : [EOL] if display_passage is True : [EOL] sys . stdout . write ( [string] % dir_dest ) [EOL] else : [EOL] os . makedirs ( dir_dest ) [EOL] for filen in files : [EOL] file_orig = realpath ( join ( join ( origin , root ) , filen ) ) [EOL] file_dest = abspath ( join ( join ( destin , root ) , filen ) ) [EOL] if display_passage is True : [EOL] msg = [string] % ( file_orig , file_dest ) [EOL] sys . stdout . write ( msg ) [EOL] else : [EOL] force_symlink ( file_orig , file_dest ) [EOL] [EOL] if display_passage : [EOL] msg = [string] [EOL] input ( msg ) [EOL] create_symlinks ( origin , destin , display_passage = False ) [EOL] [EOL] [EOL] [comment] [EOL] prefixDir = [string] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def main ( ) : [EOL] if len ( sys . argv ) < [number] : [EOL] usage ( ) [EOL] sys . exit ( - [number] ) [EOL] origin = sys . argv [ [number] ] [EOL] destin = [string] [EOL] if len ( sys . argv ) > [number] : [EOL] destin = sys . argv [ [number] ] [EOL] [comment] [EOL] create_symlinks ( origin , destin ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import argparse [EOL] import os [EOL] import subprocess [EOL] import argparse [EOL] from os . path import basename , join , isdir [EOL] [EOL] [EOL] def get_individual_files ( pathn ) : [EOL] for root , _ , files in os . walk ( pathn ) : [EOL] for fn in files : [EOL] if basename ( fn ) == [string] : [EOL] continue [EOL] [comment] [EOL] yield join ( root , fn ) [EOL] [EOL] [EOL] def git_force_add ( pathn ) : [EOL] if isdir ( pathn ) : [EOL] files = [ f for f in get_individual_files ( pathn ) ] [EOL] else : [EOL] files = [ pathn ] [EOL] [EOL] if not files : [EOL] return [EOL] files = [string] . join ( files ) [EOL] [EOL] cmd = f" [string] { files }" . split ( ) [EOL] subprocess . run ( cmd ) [EOL] [EOL] [EOL] def add_path ( pathn ) : [EOL] path_is_plugged = basename ( pathn ) == [string] [EOL] packages = os . listdir ( pathn ) if path_is_plugged else [ pathn ] [EOL] if not path_is_plugged : [EOL] pathn = [string] [EOL] for dirn in packages : [EOL] curdir = join ( pathn , dirn ) [EOL] for fn in os . listdir ( curdir ) : [EOL] if fn == [string] : [EOL] continue [EOL] fn = join ( curdir , fn ) [EOL] print ( [string] , fn ) [EOL] git_force_add ( fn ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , default = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] add_path ( args . path ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import os [EOL] [EOL] input_locations = [string] . split ( ) [EOL] output_locations = input_locations [ : ] + [ os . path . join ( [string] , [string] ) ] [EOL] [EOL] def analyze ( input , output ) : [EOL] for loc in input_locations : [EOL] for fd_ in os . listdir ( os . path . join ( input , loc ) ) : [EOL] fd = os . path . join ( input , loc , fd_ ) [EOL] if os . path . isdir ( fd ) : [EOL] locs = [ ] [EOL] for loc2 in output_locations : [EOL] fd2 = os . path . join ( output , loc2 , fd_ ) [EOL] if os . path . isdir ( fd2 ) : [EOL] locs . append ( ( fd , fd2 , loc , loc2 ) ) [EOL] if len ( locs ) == [number] : [EOL] print ( [string] , fd ) [EOL] else : [EOL] if len ( locs ) > [number] : [EOL] print ( [string] ) [EOL] for l in locs : [EOL] print ( l ) [EOL] else : [EOL] l1 , l2 = locs [ [number] ] [ [number] : [number] ] [EOL] if l1 != l2 : [EOL] print ( [string] ) [EOL] print ( locs ) [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] analyze ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pack [EOL] import klen [EOL] [docstring] [EOL] [EOL] def a_decorator ( func ) : [EOL] print ( [string] ) [EOL] def wrapped ( * args , ** kw ) : [EOL] return func ( * args , ** kw ) [EOL] print ( [string] ) [EOL] return wrapped [EOL] [EOL] def b_decorator ( func ) : [EOL] print ( [string] ) [EOL] def wrapped ( * args , ** kw ) : [EOL] return func ( * args , ** kw ) [EOL] print ( [string] ) [EOL] return wrapped [EOL] [EOL] @ b_decorator @ a_decorator def teste ( ) : [EOL] print ( [string] ) [EOL] [EOL] class Teste : [EOL] @ a_decorator @ b_decorator def metodo ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] teste ( ) [EOL] [EOL] testinho = Teste ( ) [EOL] testinho . metodo ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] a = [number] [EOL] for z in range ( a ) : [EOL] print ( z ) [EOL]	0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import math [EOL] [EOL] [EOL] def top_function ( a , b , c ) : [EOL] [docstring] [EOL] print ( a ) [EOL] print ( b ) [EOL] print ( c ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] top_function ( math . e , [number] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Union , Literal , Dict , List [EOL] import typing [EOL] import typing_extensions [EOL] import math , sys ; [EOL] [EOL] def example1 ( ) : [EOL] [comment] [EOL] some_tuple = ( [number] , [number] , [number] , [string] ) [EOL] some_variable = { [string] : [string] , [string] : [ math . pi , [number] , [number] , [number] , [number] , [string] ] , [string] : { [string] : [string] , some_tuple : [ [number] , [number] , [number] , [number] , [number] , [number] ] } } [EOL] return ( some_tuple , some_variable ) [EOL] def example2 ( ) : return { [string] : True } . has_key ( { [string] : [number] } . has_key ( [string] ) ) ; [EOL] class Example3 ( object ) : [EOL] def __init__ ( self , bar ) : [EOL] [comment] [EOL] if bar : bar += [number] ; bar = bar * bar ; return bar [EOL] else : [EOL] some_string = [string] [EOL] return ( sys . path , some_string ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import math [EOL] import functools [EOL] [EOL] [EOL] def dec_logger ( func ) : [EOL] [docstring] [EOL] @ functools . wraps ( func ) def wrapper ( * arg , ** kargs ) : [EOL] [docstring] [EOL] result = func ( * arg , ** kargs ) [EOL] print ( result ) [EOL] return result [EOL] return wrapper [EOL] [EOL] [EOL] def n1 ( x ) : [comment] [EOL] [docstring] [EOL] a = x + [number] [EOL] [EOL] def n2 ( y ) : [EOL] [docstring] [EOL] @ dec_logger def n3 ( z ) : [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] return str ( z ) + [string] [EOL] [EOL] b = y + [number] [EOL] n3 ( b ) [EOL] return b [EOL] n2 ( a ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] n1 ( math . pi ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import platform [EOL] [EOL] try : [EOL] import unidecode [EOL] [EOL] UNIDECODE_IMPORTED = True [EOL] except ImportError : [EOL] UNIDECODE_IMPORTED = False [EOL] [EOL] [EOL] def running_on_windows ( ) : [EOL] if platform . system ( ) == [string] : [EOL] return [string] [EOL] [EOL] [EOL] def no_unidecode_available ( ) : [EOL] if not UNIDECODE_IMPORTED : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] import sys [EOL] [EOL] DUMP_FILENAME = ( [string] [EOL] if not sys . platform . lower ( ) . startswith ( [string] ) [EOL] else [string] ) [EOL] with open ( DUMP_FILENAME , [string] ) : [EOL] pass [comment] [EOL] [EOL] [EOL] def echo_to_hierarchy ( text_object ) : [EOL] [docstring] [EOL] [comment] [EOL] parent = text_object [EOL] while parent . _parent : [EOL] parent = parent . _parent [EOL] [EOL] def _do_print ( text_object , indent = [string] ) : [EOL] [docstring] [EOL] debug ( indent + text_object ) [EOL] try : [EOL] for child in text_object . _children : [EOL] _do_print ( child , indent = indent + [string] ) [EOL] except AttributeError : [EOL] pass [EOL] [EOL] _do_print ( parent ) [EOL] [EOL] [EOL] def debug ( msg ) : [EOL] [docstring] [EOL] with open ( DUMP_FILENAME , [string] ) as dump_file : [EOL] dump_file . write ( ( msg + [string] ) . encode ( [string] ) ) [EOL] [EOL] [EOL] def print_stack ( ) : [EOL] [docstring] [EOL] import traceback [EOL] [EOL] with open ( DUMP_FILENAME , [string] ) as dump_file : [EOL] traceback . print_stack ( file = dump_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Sized [EOL] import typing [EOL] import pack [EOL] [docstring] [EOL] [EOL] from contextlib import contextmanager [EOL] import os [EOL] import platform [EOL] [EOL] from UltiSnips . snippet . source . file . common import normalize_file_path [EOL] from UltiSnips . compatibility import col2byte , byte2col [EOL] from UltiSnips . position import Position [EOL] from vim import error [comment] [EOL] import vim [comment] [EOL] [EOL] [EOL] class VimBuffer : [EOL] [EOL] [docstring] [EOL] [EOL] def __getitem__ ( self , idx ) : [EOL] return vim . current . buffer [ idx ] [EOL] [EOL] def __setitem__ ( self , idx , text ) : [EOL] vim . current . buffer [ idx ] = text [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( vim . current . buffer ) [EOL] [EOL] @ property def line_till_cursor ( self ) : [comment] [EOL] [docstring] [EOL] _ , col = self . cursor [EOL] return vim . current . line [ : col ] [EOL] [EOL] @ property def number ( self ) : [comment] [EOL] [docstring] [EOL] return vim . current . buffer . number [EOL] [EOL] @ property def filetypes ( self ) : [EOL] return [ ft for ft in vim . eval ( [string] ) . split ( [string] ) if ft ] [EOL] [EOL] @ property def cursor ( self ) : [comment] [EOL] [docstring] [EOL] line , nbyte = vim . current . window . cursor [EOL] col = byte2col ( line , nbyte ) [EOL] return Position ( line - [number] , col ) [EOL] [EOL] @ cursor . setter def cursor ( self , pos ) : [comment] [EOL] [docstring] [EOL] nbyte = col2byte ( pos . line + [number] , pos . col ) [EOL] vim . current . window . cursor = pos . line + [number] , nbyte [EOL] [EOL] [EOL] buf = VimBuffer ( ) [comment] [EOL] [EOL] [EOL] @ contextmanager def option_set_to ( name , new_value ) : [EOL] old_value = vim . eval ( [string] + name ) [EOL] command ( [string] . format ( name , new_value ) ) [EOL] try : [EOL] yield [EOL] finally : [EOL] command ( [string] . format ( name , old_value ) ) [EOL] [EOL] [EOL] @ contextmanager def save_mark ( name ) : [EOL] old_pos = get_mark_pos ( name ) [EOL] try : [EOL] yield [EOL] finally : [EOL] if _is_pos_zero ( old_pos ) : [EOL] delete_mark ( name ) [EOL] else : [EOL] set_mark_from_pos ( name , old_pos ) [EOL] [EOL] [EOL] def escape ( inp ) : [EOL] [docstring] [EOL] [EOL] def conv ( obj ) : [EOL] [docstring] [EOL] if isinstance ( obj , list ) : [EOL] rv = [string] + [string] . join ( conv ( o ) for o in obj ) + [string] [EOL] elif isinstance ( obj , dict ) : [EOL] rv = ( [string] + [string] . join ( [ [string] % ( conv ( key ) , conv ( value ) ) for key , value in obj . iteritems ( ) ] ) + [string] ) [EOL] else : [EOL] rv = [string] % obj . replace ( [string] , [string] ) [EOL] return rv [EOL] [EOL] return conv ( inp ) [EOL] [EOL] [EOL] def command ( cmd ) : [EOL] [docstring] [EOL] return vim . command ( cmd ) [EOL] [EOL] [EOL] def eval ( text ) : [EOL] [docstring] [EOL] return vim . eval ( text ) [EOL] [EOL] [EOL] def bindeval ( text ) : [EOL] [docstring] [EOL] rv = vim . bindeval ( text ) [EOL] if not isinstance ( rv , ( dict , list ) ) : [EOL] return rv . decode ( vim . eval ( [string] ) , [string] ) [EOL] return rv [EOL] [EOL] [EOL] def feedkeys ( keys , mode = [string] ) : [EOL] [docstring] [EOL] if eval ( [string] ) == [string] : [EOL] if keys == [string] : [EOL] cursor_pos = get_cursor_pos ( ) [EOL] cursor_pos [ [number] ] = int ( cursor_pos [ [number] ] ) + [number] [EOL] set_cursor_from_pos ( cursor_pos ) [EOL] if keys in [string] : [EOL] keys = [string] [EOL] [EOL] if keys == [string] : [EOL] command ( [string] ) [EOL] else : [EOL] command ( [string] % ( keys , mode ) ) [EOL] [EOL] [EOL] def new_scratch_buffer ( text ) : [EOL] [docstring] [EOL] vim . command ( [string] ) [EOL] vim . command ( [string] ) [EOL] vim . command ( [string] ) [EOL] [EOL] vim . current . buffer [ : ] = text . splitlines ( ) [EOL] [EOL] feedkeys ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] feedkeys ( [string] ) [EOL] [EOL] [EOL] def virtual_position ( line , col ) : [EOL] [docstring] [EOL] nbytes = col2byte ( line , col ) [EOL] return line , int ( eval ( [string] % ( line , nbytes ) ) ) [EOL] [EOL] [EOL] def select ( start , end ) : [EOL] [docstring] [EOL] _unmap_select_mode_mapping ( ) [EOL] [EOL] selection = eval ( [string] ) [EOL] [EOL] col = col2byte ( start . line + [number] , start . col ) [EOL] buf . cursor = start [EOL] [EOL] mode = eval ( [string] ) [EOL] [EOL] move_cmd = [string] [EOL] if mode != [string] : [EOL] move_cmd += [string] [EOL] [EOL] if start == end : [EOL] [comment] [EOL] if col == [number] or mode not in [string] and col < len ( buf [ start . line ] ) : [EOL] move_cmd += [string] [EOL] else : [EOL] move_cmd += [string] [EOL] else : [EOL] [comment] [EOL] move_cmd += [string] [EOL] if [string] in selection : [EOL] if end . col == [number] : [EOL] move_cmd += [string] % end . line [EOL] else : [EOL] move_cmd += [string] % virtual_position ( end . line + [number] , end . col ) [EOL] elif [string] in selection : [EOL] move_cmd += [string] % virtual_position ( end . line + [number] , end . col ) [EOL] else : [EOL] move_cmd += [string] % virtual_position ( end . line + [number] , end . col + [number] ) [EOL] move_cmd += [string] % virtual_position ( start . line + [number] , start . col + [number] ) [EOL] feedkeys ( move_cmd ) [EOL] [EOL] [EOL] def get_dot_vim ( ) : [EOL] [docstring] [EOL] home = vim . eval ( [string] ) [EOL] candidates = [ ] [EOL] if platform . system ( ) == [string] : [EOL] candidates . append ( os . path . join ( home , [string] ) ) [EOL] if vim . eval ( [string] ) == [string] : [EOL] xdg_home_config = vim . eval ( [string] ) or os . path . join ( home , [string] ) [EOL] candidates . append ( os . path . join ( xdg_home_config , [string] ) ) [EOL] [EOL] candidates . append ( os . path . join ( home , [string] ) ) [EOL] [EOL] if [string] in os . environ : [EOL] my_vimrc = os . path . expandvars ( os . environ [ [string] ] ) [EOL] candidates . append ( normalize_file_path ( os . path . dirname ( my_vimrc ) ) ) [EOL] for candidate in candidates : [EOL] if os . path . isdir ( candidate ) : [EOL] return normalize_file_path ( candidate ) [EOL] raise RuntimeError ( [string] % candidates ) [EOL] [EOL] [EOL] def set_mark_from_pos ( name , pos ) : [EOL] return _set_pos ( [string] + name , pos ) [EOL] [EOL] [EOL] def get_mark_pos ( name ) : [EOL] return _get_pos ( [string] + name ) [EOL] [EOL] [EOL] def set_cursor_from_pos ( pos ) : [EOL] return _set_pos ( [string] , pos ) [EOL] [EOL] [EOL] def get_cursor_pos ( ) : [EOL] return _get_pos ( [string] ) [EOL] [EOL] [EOL] def delete_mark ( name ) : [EOL] try : [EOL] return command ( [string] + name ) [EOL] except : [EOL] return False [EOL] [EOL] [EOL] def _set_pos ( name , pos ) : [EOL] return eval ( [string] . format ( name , pos ) ) [EOL] [EOL] [EOL] def _get_pos ( name ) : [EOL] return eval ( [string] . format ( name ) ) [EOL] [EOL] [EOL] def _is_pos_zero ( pos ) : [EOL] return [ [string] ] * [number] == pos or [ [number] ] == pos [EOL] [EOL] [EOL] def _unmap_select_mode_mapping ( ) : [EOL] [docstring] [EOL] if int ( eval ( [string] ) ) : [EOL] ignores = eval ( [string] ) + [ [string] ] [EOL] [EOL] for option in ( [string] , [string] ) : [EOL] [comment] [EOL] command ( [string] % option + [string] ) [EOL] [EOL] [comment] [EOL] if hasattr ( vim , [string] ) : [EOL] [comment] [EOL] [comment] [EOL] all_maps = bindeval ( [string] ) [EOL] else : [EOL] all_maps = eval ( [string] ) [EOL] all_maps = list ( filter ( len , all_maps . splitlines ( ) ) ) [EOL] if len ( all_maps ) == [number] and all_maps [ [number] ] [ [number] ] not in [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] [EOL] [comment] [EOL] maps = [ m for m in all_maps if not any ( i in m for i in ignores ) and len ( m . strip ( ) ) ] [EOL] [EOL] for map in maps : [EOL] [comment] [EOL] [comment] [EOL] trig = map [ [number] : ] . split ( ) [ [number] ] if len ( map [ [number] : ] . split ( ) ) != [number] else None [EOL] [EOL] if trig is None : [EOL] continue [EOL] [EOL] [comment] [EOL] if trig [ - [number] ] == [string] : [EOL] trig = trig [ : - [number] ] + [string] [EOL] [EOL] [comment] [EOL] if trig [ [number] ] == [string] : [EOL] add = False [EOL] [comment] [EOL] for valid in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] if trig == [string] % valid : [EOL] add = True [EOL] if not add : [EOL] continue [EOL] [EOL] [comment] [EOL] if trig == [string] : [EOL] continue [EOL] [EOL] [comment] [EOL] try : [EOL] command ( [string] % ( option , trig ) ) [EOL] except : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.UltiSnips.pythonx.UltiSnips.vim_helper.VimBuffer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.UltiSnips.pythonx.UltiSnips.vim_helper.VimBuffer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.UltiSnips.pythonx.UltiSnips.vim_helper.VimBuffer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any , Tuple [EOL] import typing [EOL] import unittest [EOL] [EOL] from position import Position [EOL] [EOL] [EOL] class _MPBase : [EOL] def runTest ( self ) : [EOL] obj = Position ( * self . obj ) [EOL] for pivot , delta , wanted in self . steps : [EOL] obj . move ( Position ( * pivot ) , Position ( * delta ) ) [EOL] self . assertEqual ( Position ( * wanted ) , obj ) [EOL] [EOL] [EOL] class MovePosition_DelSameLine ( _MPBase , unittest . TestCase ) : [EOL] [comment] [EOL] obj = ( [number] , [number] ) [EOL] steps = ( ( ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) ) [EOL] [EOL] [EOL] class MovePosition_DelSameLine1 ( _MPBase , unittest . TestCase ) : [EOL] [comment] [EOL] obj = ( [number] , [number] ) [EOL] steps = ( ( ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ) ) [EOL] [EOL] [EOL] class MovePosition_InsSameLine1 ( _MPBase , unittest . TestCase ) : [EOL] [comment] [EOL] obj = ( [number] , [number] ) [EOL] steps = ( ( ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ) , ) [EOL] [EOL] [EOL] class MovePosition_InsSameLine2 ( _MPBase , unittest . TestCase ) : [EOL] [comment] [EOL] obj = ( [number] , [number] ) [EOL] steps = ( ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ) [EOL] [EOL] [EOL] class MovePosition_DelSecondLine ( _MPBase , unittest . TestCase ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] obj = ( [number] , [number] ) [EOL] steps = ( ( ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( - [number] , [number] ) , ( [number] , [number] ) ) ) [EOL] [EOL] [EOL] class MovePosition_DelSecondLine1 ( _MPBase , unittest . TestCase ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] obj = ( [number] , [number] ) [EOL] steps = ( ( ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( - [number] , [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ) , ( ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ) , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]],typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]],typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]],typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]],typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]],typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]],typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]],typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]],typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import vim [EOL] [EOL] [EOL] def _vim_dec ( string ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return string . decode ( vim . eval ( [string] ) , [string] ) [EOL] [EOL] [EOL] def _vim_enc ( bytearray ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return bytearray . encode ( vim . eval ( [string] ) , [string] ) [EOL] [EOL] [EOL] def col2byte ( line , col ) : [EOL] [docstring] [EOL] [comment] [EOL] pre_chars = ( vim . current . buffer [ line - [number] ] + [string] ) [ : col ] [EOL] return len ( _vim_enc ( pre_chars ) ) [EOL] [EOL] [EOL] def byte2col ( line , nbyte ) : [EOL] [docstring] [EOL] line = vim . current . buffer [ line - [number] ] [EOL] raw_bytes = _vim_enc ( line ) [ : nbyte ] [EOL] return len ( _vim_dec ( raw_bytes ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import pack [EOL] import vim [EOL] from UltiSnips import vim_helper [EOL] from UltiSnips . position import Position [EOL] from UltiSnips . diff import diff [EOL] [EOL] from contextlib import contextmanager [EOL] [EOL] [EOL] @ contextmanager def use_proxy_buffer ( snippets_stack , vstate ) : [EOL] [docstring] [EOL] buffer_proxy = VimBufferProxy ( snippets_stack , vstate ) [EOL] old_buffer = vim_helper . buf [EOL] try : [EOL] vim_helper . buf = buffer_proxy [EOL] yield [EOL] finally : [EOL] vim_helper . buf = old_buffer [EOL] buffer_proxy . validate_buffer ( ) [EOL] [EOL] [EOL] @ contextmanager def suspend_proxy_edits ( ) : [EOL] [docstring] [EOL] if not isinstance ( vim_helper . buf , VimBufferProxy ) : [EOL] yield [EOL] else : [EOL] try : [EOL] vim_helper . buf . _disable_edits ( ) [EOL] yield [EOL] finally : [EOL] vim_helper . buf . _enable_edits ( ) [EOL] [EOL] [EOL] class VimBufferProxy ( vim_helper . VimBuffer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , snippets_stack , vstate ) : [EOL] [docstring] [EOL] self . _snippets_stack = snippets_stack [EOL] self . _buffer = vim . current . buffer [EOL] self . _change_tick = int ( vim . eval ( [string] ) ) [EOL] self . _forward_edits = True [EOL] self . _vstate = vstate [EOL] [EOL] def is_buffer_changed_outside ( self ) : [EOL] [docstring] [EOL] return self . _change_tick < int ( vim . eval ( [string] ) ) [EOL] [EOL] def validate_buffer ( self ) : [EOL] [docstring] [EOL] if self . is_buffer_changed_outside ( ) : [EOL] raise RuntimeError ( [string] + [string] + [string] [string] + [string] ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] [docstring] [EOL] if isinstance ( key , slice ) : [EOL] value = [ line for line in value ] [EOL] changes = list ( self . _get_diff ( key . start , key . stop , value ) ) [EOL] self . _buffer [ key . start : key . stop ] = [ line . strip ( [string] ) for line in value ] [EOL] else : [EOL] value = value [EOL] changes = list ( self . _get_line_diff ( key , self . _buffer [ key ] , value ) ) [EOL] self . _buffer [ key ] = value [EOL] [EOL] self . _change_tick += [number] [EOL] [EOL] if self . _forward_edits : [EOL] for change in changes : [EOL] self . _apply_change ( change ) [EOL] if self . _snippets_stack : [EOL] self . _vstate . remember_buffer ( self . _snippets_stack [ [number] ] ) [EOL] [EOL] def __setslice__ ( self , i , j , text ) : [EOL] [docstring] [EOL] self . __setitem__ ( slice ( i , j ) , text ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] [docstring] [EOL] return self . _buffer [ key ] [EOL] [EOL] def __getslice__ ( self , i , j ) : [EOL] [docstring] [EOL] return self . __getitem__ ( slice ( i , j ) ) [EOL] [EOL] def __len__ ( self ) : [EOL] [docstring] [EOL] return len ( self . _buffer ) [EOL] [EOL] def append ( self , line , line_number = - [number] ) : [EOL] [docstring] [EOL] if line_number < [number] : [EOL] line_number = len ( self ) [EOL] if not isinstance ( line , list ) : [EOL] line = [ line ] [EOL] self [ line_number : line_number ] = [ l for l in line ] [EOL] [EOL] def __delitem__ ( self , key ) : [EOL] if isinstance ( key , slice ) : [EOL] self . __setitem__ ( key , [ ] ) [EOL] else : [EOL] self . __setitem__ ( slice ( key , key + [number] ) , [ ] ) [EOL] [EOL] def _get_diff ( self , start , end , new_value ) : [EOL] [docstring] [EOL] for line_number in range ( start , end ) : [EOL] if line_number < [number] : [EOL] line_number = len ( self . _buffer ) + line_number [EOL] yield ( [string] , line_number , [number] , self . _buffer [ line_number ] , True ) [EOL] [EOL] if start < [number] : [EOL] start = len ( self . _buffer ) + start [EOL] for line_number in range ( [number] , len ( new_value ) ) : [EOL] yield ( [string] , start + line_number , [number] , new_value [ line_number ] , True ) [EOL] [EOL] def _get_line_diff ( self , line_number , before , after ) : [EOL] [docstring] [EOL] if before == [string] : [EOL] for change in self . _get_diff ( line_number , line_number + [number] , [ after ] ) : [EOL] yield change [EOL] else : [EOL] for change in diff ( before , after ) : [EOL] yield ( change [ [number] ] , line_number , change [ [number] ] , change [ [number] ] ) [EOL] [EOL] def _apply_change ( self , change ) : [EOL] [docstring] [EOL] if not self . _snippets_stack : [EOL] return [EOL] [EOL] change_type , line_number , column_number , change_text = change [ [number] : [number] ] [EOL] [EOL] line_before = line_number <= self . _snippets_stack [ [number] ] . _start . line [EOL] column_before = column_number <= self . _snippets_stack [ [number] ] . _start . col [EOL] if line_before and column_before : [EOL] direction = [number] [EOL] if change_type == [string] : [EOL] direction = - [number] [EOL] [EOL] diff = Position ( direction , [number] ) [EOL] if len ( change ) != [number] : [EOL] diff = Position ( [number] , direction * len ( change_text ) ) [EOL] [EOL] self . _snippets_stack [ [number] ] . _move ( Position ( line_number , column_number ) , diff ) [EOL] else : [EOL] if line_number > self . _snippets_stack [ [number] ] . _end . line : [EOL] return [EOL] if column_number >= self . _snippets_stack [ [number] ] . _end . col : [EOL] return [EOL] self . _snippets_stack [ [number] ] . _do_edit ( change [ [number] : [number] ] ) [EOL] [EOL] def _disable_edits ( self ) : [EOL] [docstring] [EOL] self . _forward_edits = False [EOL] [EOL] def _enable_edits ( self ) : [EOL] [docstring] [EOL] self . _forward_edits = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from UltiSnips . snippet_manager import UltiSnips_Manager [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from UltiSnips . text_objects . base import EditableTextObject [EOL] [EOL] [EOL] class TabStop ( EditableTextObject ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , parent , token , start = None , end = None ) : [EOL] if start is not None : [EOL] self . _number = token [EOL] EditableTextObject . __init__ ( self , parent , start , end ) [EOL] else : [EOL] self . _number = token . number [EOL] EditableTextObject . __init__ ( self , parent , token ) [EOL] parent . _tabstops [ self . _number ] = self [comment] [EOL] [EOL] @ property def number ( self ) : [EOL] [docstring] [EOL] return self . _number [EOL] [EOL] @ property def is_killed ( self ) : [EOL] [docstring] [EOL] return self . _parent is None [EOL] [EOL] def __repr__ ( self ) : [EOL] try : [EOL] text = self . current_text [EOL] except IndexError : [EOL] text = [string] [EOL] return [string] % ( self . number , self . _start , self . _end , text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from UltiSnips import vim_helper [EOL] from UltiSnips . text_objects . base import NoneditableTextObject [EOL] [EOL] [EOL] class VimLCode ( NoneditableTextObject ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , parent , token ) : [EOL] self . _code = token . code . replace ( [string] , [string] ) . strip ( ) [EOL] [EOL] NoneditableTextObject . __init__ ( self , parent , token ) [EOL] [EOL] def _update ( self , done , buf ) : [EOL] self . overwrite ( buf , vim_helper . eval ( self . _code ) ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Set , Any [EOL] import typing [EOL] import pack [EOL] import UltiSnips [EOL] [docstring] [EOL] [EOL] from UltiSnips import vim_helper [EOL] from UltiSnips . position import Position , JumpDirection [EOL] from UltiSnips . text_objects . base import EditableTextObject , NoneditableTextObject [EOL] from UltiSnips . text_objects . tabstop import TabStop [EOL] [EOL] [EOL] class SnippetInstance ( EditableTextObject ) : [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def __init__ ( self , snippet , parent , initial_text , start , end , visual_content , last_re , globals , context , ) : [EOL] if start is None : [EOL] start = Position ( [number] , [number] ) [EOL] if end is None : [EOL] end = Position ( [number] , [number] ) [EOL] self . snippet = snippet [EOL] self . _cts = [number] [EOL] [EOL] self . context = context [EOL] self . locals = { [string] : last_re , [string] : context } [EOL] self . globals = globals [EOL] self . visual_content = visual_content [EOL] self . current_placeholder = None [EOL] [EOL] EditableTextObject . __init__ ( self , parent , start , end , initial_text ) [EOL] [EOL] def replace_initial_text ( self , buf ) : [EOL] [docstring] [EOL] [EOL] def _place_initial_text ( obj ) : [EOL] [docstring] [EOL] obj . overwrite_with_initial_text ( buf ) [EOL] if isinstance ( obj , EditableTextObject ) : [EOL] for child in obj . _children : [EOL] _place_initial_text ( child ) [EOL] [EOL] _place_initial_text ( self ) [EOL] [EOL] def replay_user_edits ( self , cmds , ctab = None ) : [EOL] [docstring] [EOL] for cmd in cmds : [EOL] self . _do_edit ( cmd , ctab ) [EOL] [EOL] def update_textobjects ( self , buf ) : [EOL] [docstring] [EOL] vc = _VimCursor ( self ) [EOL] done = set ( ) [EOL] not_done = set ( ) [EOL] [EOL] def _find_recursive ( obj ) : [EOL] [docstring] [EOL] if isinstance ( obj , EditableTextObject ) : [EOL] for child in obj . _children : [EOL] _find_recursive ( child ) [EOL] not_done . add ( obj ) [EOL] [EOL] _find_recursive ( self ) [EOL] [EOL] counter = [number] [EOL] while ( done != not_done ) and counter : [EOL] [comment] [EOL] for obj in sorted ( not_done - done ) : [EOL] if obj . _update ( done , buf ) : [EOL] done . add ( obj ) [EOL] counter -= [number] [EOL] if not counter : [EOL] raise RuntimeError ( [string] [string] [string] [string] ) [EOL] vc . to_vim ( ) [EOL] self . _del_child ( vc ) [EOL] [EOL] def select_next_tab ( self , jump_direction ) : [EOL] [docstring] [EOL] if self . _cts is None : [EOL] return [EOL] [EOL] if jump_direction == JumpDirection . BACKWARD : [EOL] cts_bf = self . _cts [EOL] [EOL] res = self . _get_prev_tab ( self . _cts ) [EOL] if res is None : [EOL] self . _cts = cts_bf [EOL] return self . _tabstops . get ( self . _cts , None ) [EOL] self . _cts , ts = res [EOL] return ts [EOL] elif jump_direction == JumpDirection . FORWARD : [EOL] res = self . _get_next_tab ( self . _cts ) [EOL] if res is None : [EOL] self . _cts = None [EOL] [EOL] ts = self . _get_tabstop ( self , [number] ) [EOL] if ts : [EOL] return ts [EOL] [EOL] [comment] [EOL] [comment] [EOL] start = Position ( self . end . line , self . end . col ) [EOL] end = Position ( self . end . line , self . end . col ) [EOL] return TabStop ( self , [number] , start , end ) [EOL] else : [EOL] self . _cts , ts = res [EOL] return ts [EOL] else : [EOL] assert False , [string] % jump_direction [EOL] [EOL] return self . _tabstops [ self . _cts ] [EOL] [EOL] def _get_tabstop ( self , requester , no ) : [EOL] [comment] [EOL] [comment] [EOL] cached_parent = self . _parent [EOL] self . _parent = None [EOL] rv = EditableTextObject . _get_tabstop ( self , requester , no ) [EOL] self . _parent = cached_parent [EOL] return rv [EOL] [EOL] def get_tabstops ( self ) : [EOL] return self . _tabstops [EOL] [EOL] [EOL] class _VimCursor ( NoneditableTextObject ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , parent ) : [EOL] NoneditableTextObject . __init__ ( self , parent , vim_helper . buf . cursor , vim_helper . buf . cursor , tiebreaker = Position ( - [number] , - [number] ) , ) [EOL] [EOL] def to_vim ( self ) : [EOL] [docstring] [EOL] assert self . _start == self . _end [EOL] vim_helper . buf . cursor = self . _start [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.UltiSnips.pythonx.UltiSnips.text_objects.snippet_instance._VimCursor$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.UltiSnips.pythonx.UltiSnips.text_objects.snippet_instance._VimCursor$ 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.UltiSnips.pythonx.UltiSnips.text_objects.snippet_instance._VimCursor$ 0 0 0 0 0 0 0 0 $UltiSnips.position.JumpDirection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $UltiSnips.position.JumpDirection$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $UltiSnips.position.JumpDirection$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $UltiSnips.position.JumpDirection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from UltiSnips . text_objects . base import NoneditableTextObject [EOL] [EOL] [EOL] class Mirror ( NoneditableTextObject ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , parent , tabstop , token ) : [EOL] NoneditableTextObject . __init__ ( self , parent , token ) [EOL] self . _ts = tabstop [EOL] [EOL] def _update ( self , done , buf ) : [EOL] if self . _ts . is_killed : [EOL] self . overwrite ( buf , [string] ) [EOL] self . _parent . _del_child ( self ) [comment] [EOL] return True [EOL] [EOL] if self . _ts not in done : [EOL] return False [EOL] [EOL] self . overwrite ( buf , self . _get_text ( ) ) [EOL] return True [EOL] [EOL] def _get_text ( self ) : [EOL] [docstring] [EOL] return self . _ts . current_text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import UltiSnips [EOL] [docstring] [EOL] [EOL] from UltiSnips import vim_helper [EOL] from UltiSnips . position import Position [EOL] from UltiSnips . text_objects . tabstop import TabStop [EOL] from UltiSnips . snippet . parsing . lexer import ChoicesToken [EOL] [EOL] [EOL] class Choices ( TabStop ) : [EOL] [docstring] [EOL] def __init__ ( self , parent , token ) : [EOL] self . _number = token . number [comment] [EOL] self . _initial_text = token . initial_text [EOL] [EOL] [comment] [EOL] self . _choice_list = [ s for s in token . choice_list if len ( s ) > [number] ] [EOL] self . _done = False [EOL] self . _input_chars = list ( self . _initial_text ) [EOL] self . _has_been_updated = False [EOL] [EOL] TabStop . __init__ ( self , parent , token ) [EOL] [EOL] def _get_choices_placeholder ( self ) : [EOL] [comment] [EOL] [comment] [EOL] text_segs = [ ] [EOL] index = [number] [EOL] for choice in self . _choice_list : [EOL] text_segs . append ( [string] % ( index , choice ) ) [EOL] index += [number] [EOL] text = [string] . join ( text_segs ) [EOL] return text [EOL] [EOL] def _update ( self , done , buf ) : [EOL] if self . _done : [EOL] return True [EOL] [EOL] [comment] [EOL] if not self . _has_been_updated : [EOL] [comment] [EOL] are_choices_valid = len ( self . _choice_list ) > [number] [EOL] if are_choices_valid : [EOL] text = self . _get_choices_placeholder ( ) [EOL] self . overwrite ( buf , text ) [EOL] else : [EOL] self . _done = True [EOL] self . _has_been_updated = True [EOL] return True [EOL] [EOL] def _do_edit ( self , cmd , ctab = None ) : [EOL] if self . _done : [EOL] [comment] [EOL] TabStop . _do_edit ( self , cmd , ctab ) [EOL] return [EOL] [EOL] ctype , line , col , cmd_text = cmd [EOL] [EOL] cursor = vim_helper . get_cursor_pos ( ) [EOL] [ buf_num , cursor_line ] = map ( int , cursor [ [number] : [number] ] ) [EOL] [EOL] [comment] [EOL] if ctype == [string] : [EOL] self . _input_chars . append ( cmd_text ) [EOL] elif ctype == [string] : [EOL] line_text = vim_helper . buf [ cursor_line - [number] ] [EOL] self . _input_chars = list ( line_text [ self . _start . col : col ] ) [EOL] [EOL] inputted_text = [string] . join ( self . _input_chars ) [EOL] [EOL] if not self . _input_chars : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] is_all_digits = True [EOL] [EOL] for s in self . _input_chars : [EOL] if not s . isdigit ( ) : [EOL] is_all_digits = False [EOL] [EOL] should_continue_input = False [EOL] index_strs = [ str ( index ) for index in list ( range ( [number] , len ( self . _choice_list ) + [number] ) ) ] [EOL] if is_all_digits : [EOL] matched_index_strs = list ( filter ( lambda s : s . startswith ( inputted_text ) , index_strs ) ) [EOL] if len ( matched_index_strs ) == [number] : [EOL] remained_choice_list = [ ] [EOL] elif len ( matched_index_strs ) == [number] : [EOL] num = int ( inputted_text ) [EOL] remained_choice_list = list ( self . _choice_list ) [ num - [number] : num ] [EOL] else : [EOL] should_continue_input = True [EOL] else : [EOL] remained_choice_list = [ ] [EOL] [EOL] if should_continue_input : [EOL] [comment] [EOL] return [EOL] [EOL] buf = vim_helper . buf [EOL] if len ( remained_choice_list ) == [number] : [EOL] [comment] [EOL] overwrite_text = inputted_text [EOL] self . _done = True [EOL] elif len ( remained_choice_list ) == [number] : [EOL] [comment] [EOL] matched_choice = remained_choice_list [ [number] ] [EOL] overwrite_text = matched_choice [EOL] self . _done = True [EOL] [EOL] if overwrite_text is not None : [EOL] old_end_col = self . _end . col [EOL] [EOL] [comment] [EOL] displayed_text_end_col = self . _start . col + len ( inputted_text ) [EOL] self . _end . col = displayed_text_end_col [EOL] self . overwrite ( buf , overwrite_text ) [EOL] [EOL] [comment] [EOL] pivot = Position ( line , old_end_col ) [EOL] diff_col = displayed_text_end_col - old_end_col [EOL] self . _parent . _child_has_moved ( self . _parent . children . index ( self ) , pivot , Position ( [number] , diff_col ) ) [EOL] [EOL] vim_helper . set_cursor_from_pos ( [ buf_num , cursor_line , self . _end . col + [number] ] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( self . _number , self . _start , self . _end , self . _initial_text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $UltiSnips.snippet.parsing.lexer.ChoicesToken$ 0 0 0 0 0 0 0 $UltiSnips.snippet.parsing.lexer.ChoicesToken$ 0 0 0 0 0 0 0 0 $UltiSnips.snippet.parsing.lexer.ChoicesToken$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $UltiSnips.snippet.parsing.lexer.ChoicesToken$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $UltiSnips.snippet.parsing.lexer.ChoicesToken$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] import textwrap [EOL] [EOL] from UltiSnips . indent_util import IndentUtil [EOL] from UltiSnips . text_objects . transformation import TextObjectTransformation [EOL] from UltiSnips . text_objects . base import NoneditableTextObject [EOL] [EOL] _REPLACE_NON_WS = re . compile ( [string] ) [EOL] [EOL] [EOL] class Visual ( NoneditableTextObject , TextObjectTransformation ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , parent , token ) : [EOL] [comment] [EOL] snippet = parent [EOL] while snippet : [EOL] try : [EOL] self . _text = snippet . visual_content . text [EOL] self . _mode = snippet . visual_content . mode [EOL] break [EOL] except AttributeError : [EOL] snippet = snippet . _parent [comment] [EOL] if not self . _text : [EOL] self . _text = token . alternative_text [EOL] self . _mode = [string] [EOL] [EOL] NoneditableTextObject . __init__ ( self , parent , token ) [EOL] TextObjectTransformation . __init__ ( self , token ) [EOL] [EOL] def _update ( self , done , buf ) : [EOL] if self . _mode == [string] : [comment] [EOL] text = self . _text [EOL] else : [comment] [EOL] text_before = buf [ self . start . line ] [ : self . start . col ] [EOL] indent = _REPLACE_NON_WS . sub ( [string] , text_before ) [EOL] iu = IndentUtil ( ) [EOL] indent = iu . indent_to_spaces ( indent ) [EOL] indent = iu . spaces_to_indent ( indent ) [EOL] text = [string] [EOL] for idx , line in enumerate ( textwrap . dedent ( self . _text ) . splitlines ( True ) ) : [EOL] if idx != [number] : [EOL] text += indent [EOL] text += line [EOL] text = text [ : - [number] ] [comment] [EOL] [EOL] text = self . _transform ( text ) [EOL] self . overwrite ( buf , text ) [EOL] self . _parent . _del_child ( self ) [comment] [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from UltiSnips . text_objects . base import NoneditableTextObject [EOL] [EOL] [EOL] class EscapedChar ( NoneditableTextObject ) : [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [EOL] import typing [EOL] [docstring] [EOL] [EOL] from UltiSnips . snippet . parsing . base import ( tokenize_snippet_text , finalize , resolve_ambiguity , ) [EOL] from UltiSnips . snippet . parsing . lexer import ( EscapeCharToken , VisualToken , TransformationToken , ChoicesToken , TabStopToken , MirrorToken , PythonCodeToken , VimLCodeToken , ShellCodeToken , ) [EOL] from UltiSnips . text_objects import ( EscapedChar , Mirror , PythonCode , ShellCode , TabStop , Transformation , VimLCode , Visual , Choices , ) [EOL] [EOL] _TOKEN_TO_TEXTOBJECT = { EscapeCharToken : EscapedChar , VisualToken : Visual , ShellCodeToken : ShellCode , PythonCodeToken : PythonCode , VimLCodeToken : VimLCode , ChoicesToken : Choices , } [EOL] [EOL] __ALLOWED_TOKENS = [ EscapeCharToken , VisualToken , TransformationToken , ChoicesToken , TabStopToken , MirrorToken , PythonCodeToken , VimLCodeToken , ShellCodeToken , ] [EOL] [EOL] [EOL] def _create_transformations ( all_tokens , seen_ts ) : [EOL] [docstring] [EOL] for parent , token in all_tokens : [EOL] if isinstance ( token , TransformationToken ) : [EOL] if token . number not in seen_ts : [EOL] raise RuntimeError ( [string] % token . number ) [EOL] Transformation ( parent , seen_ts [ token . number ] , token ) [EOL] [EOL] [EOL] def parse_and_instantiate ( parent_to , text , indent ) : [EOL] [docstring] [EOL] all_tokens , seen_ts = tokenize_snippet_text ( parent_to , text , indent , __ALLOWED_TOKENS , __ALLOWED_TOKENS , _TOKEN_TO_TEXTOBJECT , ) [EOL] resolve_ambiguity ( all_tokens , seen_ts ) [EOL] _create_transformations ( all_tokens , seen_ts ) [EOL] finalize ( all_tokens , seen_ts , parent_to ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from collections import defaultdict [EOL] [EOL] from UltiSnips . snippet . source . snippet_dictionary import SnippetDictionary [EOL] [EOL] [EOL] class SnippetSource : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _snippets = defaultdict ( SnippetDictionary ) [EOL] self . _extends = defaultdict ( set ) [EOL] [EOL] def ensure ( self , filetypes ) : [EOL] [docstring] [EOL] [EOL] def refresh ( self ) : [EOL] [docstring] [EOL] [EOL] def _get_existing_deep_extends ( self , base_filetypes ) : [EOL] [docstring] [EOL] deep_extends = self . get_deep_extends ( base_filetypes ) [EOL] return [ ft for ft in deep_extends if ft in self . _snippets ] [EOL] [EOL] def get_snippets ( self , filetypes , before , possible , autotrigger_only , visual_content ) : [EOL] [docstring] [EOL] result = [ ] [EOL] for ft in self . _get_existing_deep_extends ( filetypes ) : [EOL] snips = self . _snippets [ ft ] [EOL] result . extend ( snips . get_matching_snippets ( before , possible , autotrigger_only , visual_content ) ) [EOL] return result [EOL] [EOL] def get_clear_priority ( self , filetypes ) : [EOL] [docstring] [EOL] pri = None [EOL] for ft in self . _get_existing_deep_extends ( filetypes ) : [EOL] snippets = self . _snippets [ ft ] [EOL] if pri is None or snippets . _clear_priority > pri : [EOL] pri = snippets . _clear_priority [EOL] return pri [EOL] [EOL] def get_cleared ( self , filetypes ) : [EOL] [docstring] [EOL] cleared = { } [EOL] for ft in self . _get_existing_deep_extends ( filetypes ) : [EOL] snippets = self . _snippets [ ft ] [EOL] for key , value in snippets . _cleared . items ( ) : [EOL] if key not in cleared or value > cleared [ key ] : [EOL] cleared [ key ] = value [EOL] return cleared [EOL] [EOL] def update_extends ( self , child_ft , parent_fts ) : [EOL] [docstring] [EOL] self . _extends [ child_ft ] . update ( parent_fts ) [EOL] [EOL] def get_deep_extends ( self , base_filetypes ) : [EOL] [docstring] [EOL] seen = set ( base_filetypes ) [EOL] todo_fts = list ( set ( base_filetypes ) ) [EOL] while todo_fts : [EOL] todo_ft = todo_fts . pop ( ) [EOL] unseen_extends = set ( ft for ft in self . _extends [ todo_ft ] if ft not in seen ) [EOL] seen . update ( unseen_extends ) [EOL] todo_fts . extend ( unseen_extends ) [EOL] return seen [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Set[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Set[typing.Any]$ 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from UltiSnips . snippet . source . base import SnippetSource [EOL] [EOL] [EOL] class AddedSnippetsSource ( SnippetSource ) : [EOL] [EOL] [docstring] [EOL] [EOL] def add_snippet ( self , ft , snippet ) : [EOL] [docstring] [EOL] self . _snippets [ ft ] . add_snippet ( snippet ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os . path [EOL] [EOL] [EOL] def normalize_file_path ( path ) : [EOL] [docstring] [EOL] return os . path . normcase ( os . path . normpath ( path ) ) [EOL] [EOL] [EOL] def handle_extends ( tail , line_index ) : [EOL] [docstring] [EOL] if tail : [EOL] return [string] , ( [ p . strip ( ) for p in tail . split ( [string] ) ] , ) [EOL] else : [EOL] return [string] , ( [string] , line_index ) [EOL] [EOL] [EOL] def handle_action ( head , tail , line_index ) : [EOL] if tail : [EOL] action = tail . strip ( [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] return head , ( action , ) [EOL] else : [EOL] return [string] , ( [string] . format ( head ) , line_index ) [EOL] [EOL] [EOL] def handle_context ( tail , line_index ) : [EOL] if tail : [EOL] return [string] , tail . strip ( [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] else : [EOL] return [string] , ( [string] , line_index ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , Dict , DefaultDict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] from collections import defaultdict [EOL] import glob [EOL] import os [EOL] [EOL] from UltiSnips import vim_helper [EOL] from UltiSnips . snippet . definition import UltiSnipsSnippetDefinition [EOL] from UltiSnips . snippet . source . file . base import SnippetFileSource [EOL] from UltiSnips . snippet . source . file . common import ( handle_action , handle_context , handle_extends , normalize_file_path , ) [EOL] from UltiSnips . text import LineIterator , head_tail [EOL] [EOL] [EOL] def find_snippet_files ( ft , directory ) : [EOL] [docstring] [EOL] patterns = [ [string] , [string] , os . path . join ( [string] , [string] ) ] [EOL] ret = set ( ) [EOL] directory = os . path . expanduser ( str ( directory ) ) [EOL] for pattern in patterns : [EOL] for fn in glob . glob ( os . path . join ( directory , pattern % ft ) ) : [EOL] ret . add ( normalize_file_path ( fn ) ) [EOL] return ret [EOL] [EOL] [EOL] def find_all_snippet_directories ( ) : [EOL] [docstring] [EOL] [EOL] if vim_helper . eval ( [string] ) == [string] : [EOL] snippet_dirs = vim_helper . eval ( [string] ) [EOL] else : [EOL] snippet_dirs = vim_helper . eval ( [string] ) [EOL] [EOL] if len ( snippet_dirs ) == [number] : [EOL] [comment] [EOL] [comment] [EOL] full_path = os . path . expanduser ( str ( snippet_dirs [ [number] ] ) ) [EOL] if os . path . isabs ( full_path ) : [EOL] return [ full_path ] [EOL] [EOL] all_dirs = [ ] [EOL] check_dirs = vim_helper . eval ( [string] ) . split ( [string] ) [EOL] for rtp in check_dirs : [EOL] for snippet_dir in snippet_dirs : [EOL] if snippet_dir == [string] : [EOL] raise RuntimeError ( [string] [string] [string] ) [EOL] pth = normalize_file_path ( os . path . expanduser ( str ( os . path . join ( rtp , snippet_dir ) ) ) ) [EOL] all_dirs . append ( pth ) [EOL] return all_dirs [EOL] [EOL] [EOL] def find_all_snippet_files ( ft ) : [EOL] [docstring] [EOL] patterns = [ [string] , [string] , os . path . join ( [string] , [string] ) ] [EOL] ret = set ( ) [EOL] for directory in find_all_snippet_directories ( ) : [EOL] if not os . path . isdir ( directory ) : [EOL] continue [EOL] for pattern in patterns : [EOL] for fn in glob . glob ( os . path . join ( directory , pattern % ft ) ) : [EOL] ret . add ( fn ) [EOL] return ret [EOL] [EOL] [EOL] def _handle_snippet_or_global ( filename , line , lines , python_globals , priority , pre_expand , context ) : [EOL] [docstring] [EOL] start_line_index = lines . line_index [EOL] descr = [string] [EOL] opts = [string] [EOL] [EOL] [comment] [EOL] snip = line . split ( ) [ [number] ] [EOL] [EOL] [comment] [EOL] remain = line [ len ( snip ) : ] . strip ( ) [EOL] words = remain . split ( ) [EOL] [EOL] if len ( words ) > [number] : [EOL] [comment] [EOL] if [string] not in words [ - [number] ] and words [ - [number] ] [ - [number] ] == [string] : [EOL] opts = words [ - [number] ] [EOL] remain = remain [ : - len ( opts ) - [number] ] . rstrip ( ) [EOL] [EOL] if [string] in opts and not context : [EOL] left = remain [ : - [number] ] . rfind ( [string] ) [EOL] if left != - [number] and left != [number] : [EOL] context , remain = remain [ left : ] . strip ( [string] ) , remain [ : left ] [EOL] [EOL] [comment] [EOL] remain = remain . strip ( ) [EOL] if len ( remain . split ( ) ) > [number] and remain [ - [number] ] == [string] : [EOL] left = remain [ : - [number] ] . rfind ( [string] ) [EOL] if left != - [number] and left != [number] : [EOL] descr , remain = remain [ left : ] , remain [ : left ] [EOL] [EOL] [comment] [EOL] trig = remain . strip ( ) [EOL] if len ( trig . split ( ) ) > [number] or [string] in opts : [EOL] if trig [ [number] ] != trig [ - [number] ] : [EOL] return [string] , ( [string] % trig , lines . line_index ) [EOL] trig = trig [ [number] : - [number] ] [EOL] end = [string] + snip [EOL] content = [string] [EOL] [EOL] found_end = False [EOL] for line in lines : [EOL] if line . rstrip ( ) == end : [EOL] content = content [ : - [number] ] [comment] [EOL] found_end = True [EOL] break [EOL] content += line [EOL] [EOL] if not found_end : [EOL] return [string] , ( [string] % trig , lines . line_index ) [EOL] [EOL] if snip == [string] : [EOL] python_globals [ trig ] . append ( content ) [EOL] elif snip == [string] : [EOL] definition = UltiSnipsSnippetDefinition ( priority , trig , content , descr , opts , python_globals , [string] % ( filename , start_line_index ) , context , pre_expand , ) [EOL] return [string] , ( definition , ) [EOL] else : [EOL] return [string] , ( [string] % snip , lines . line_index ) [EOL] [EOL] [EOL] def _parse_snippets_file ( data , filename ) : [EOL] [docstring] [EOL] [EOL] python_globals = defaultdict ( list ) [EOL] lines = LineIterator ( data ) [EOL] current_priority = [number] [EOL] actions = { } [EOL] context = None [EOL] for line in lines : [EOL] if not line . strip ( ) : [EOL] continue [EOL] [EOL] head , tail = head_tail ( line ) [EOL] if head in ( [string] , [string] ) : [EOL] snippet = _handle_snippet_or_global ( filename , line , lines , python_globals , current_priority , actions , context , ) [EOL] [EOL] actions = { } [EOL] context = None [EOL] if snippet is not None : [EOL] yield snippet [EOL] elif head == [string] : [EOL] yield handle_extends ( tail , lines . line_index ) [EOL] elif head == [string] : [EOL] yield [string] , ( current_priority , tail . split ( ) ) [EOL] elif head == [string] : [EOL] head , context , = handle_context ( tail , lines . line_index ) [EOL] if head == [string] : [EOL] yield ( head , tail ) [EOL] elif head == [string] : [EOL] try : [EOL] current_priority = int ( tail . split ( ) [ [number] ] ) [EOL] except ( ValueError , IndexError ) : [EOL] yield [string] , ( [string] % tail , lines . line_index ) [EOL] elif head in [ [string] , [string] , [string] ] : [EOL] head , tail = handle_action ( head , tail , lines . line_index ) [EOL] if head == [string] : [EOL] yield ( head , tail ) [EOL] else : [EOL] ( actions [ head ] , ) = tail [EOL] elif head and not head . startswith ( [string] ) : [EOL] yield [string] , ( [string] % line . rstrip ( ) , lines . line_index ) [EOL] [EOL] [EOL] class UltiSnipsFileSource ( SnippetFileSource ) : [EOL] [EOL] [docstring] [EOL] [EOL] def _get_all_snippet_files_for ( self , ft ) : [EOL] return find_all_snippet_files ( ft ) [EOL] [EOL] def _parse_snippet_file ( self , filedata , filename ) : [EOL] for event , data in _parse_snippets_file ( filedata , filename ) : [EOL] yield event , data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , List , Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import glob [EOL] [EOL] from UltiSnips import vim_helper [EOL] from UltiSnips . snippet . definition import SnipMateSnippetDefinition [EOL] from UltiSnips . snippet . source . file . base import SnippetFileSource [EOL] from UltiSnips . snippet . source . file . common import handle_extends , normalize_file_path [EOL] from UltiSnips . text import LineIterator , head_tail [EOL] [EOL] [EOL] def _splitall ( path ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] allparts = [ ] [EOL] while True : [EOL] parts = os . path . split ( path ) [EOL] if parts [ [number] ] == path : [comment] [EOL] allparts . insert ( [number] , parts [ [number] ] ) [EOL] break [EOL] elif parts [ [number] ] == path : [comment] [EOL] allparts . insert ( [number] , parts [ [number] ] ) [EOL] break [EOL] else : [EOL] path = parts [ [number] ] [EOL] allparts . insert ( [number] , parts [ [number] ] ) [EOL] return allparts [EOL] [EOL] [EOL] def _snipmate_files_for ( ft ) : [EOL] [docstring] [EOL] if ft == [string] : [EOL] ft = [string] [EOL] patterns = [ [string] % ft , os . path . join ( ft , [string] ) , os . path . join ( ft , [string] ) , os . path . join ( ft , [string] ) , ] [EOL] ret = set ( ) [EOL] for rtp in vim_helper . eval ( [string] ) . split ( [string] ) : [EOL] path = normalize_file_path ( os . path . expanduser ( os . path . join ( rtp , [string] ) ) ) [EOL] for pattern in patterns : [EOL] for fn in glob . glob ( os . path . join ( path , pattern ) ) : [EOL] ret . add ( fn ) [EOL] return ret [EOL] [EOL] [EOL] def _parse_snippet_file ( content , full_filename ) : [EOL] [docstring] [EOL] filename = full_filename [ : - len ( [string] ) ] [comment] [EOL] segments = _splitall ( filename ) [EOL] segments = segments [ segments . index ( [string] ) + [number] : ] [EOL] assert len ( segments ) in ( [number] , [number] ) [EOL] [EOL] trigger = segments [ [number] ] [EOL] description = segments [ [number] ] if [number] < len ( segments ) else [string] [EOL] [EOL] [comment] [EOL] if content and content . endswith ( os . linesep ) : [EOL] content = content [ : - len ( os . linesep ) ] [EOL] yield [string] , ( SnipMateSnippetDefinition ( trigger , content , description , full_filename ) , ) [EOL] [EOL] [EOL] def _parse_snippet ( line , lines , filename ) : [EOL] [docstring] [EOL] start_line_index = lines . line_index [EOL] trigger , description = head_tail ( line [ len ( [string] ) : ] . lstrip ( ) ) [EOL] content = [string] [EOL] while True : [EOL] next_line = lines . peek ( ) [EOL] if next_line is None : [EOL] break [EOL] if next_line . strip ( ) and not next_line . startswith ( [string] ) : [EOL] break [EOL] line = next ( lines ) [EOL] if line [ [number] ] == [string] : [EOL] line = line [ [number] : ] [EOL] content += line [EOL] content = content [ : - [number] ] [comment] [EOL] return ( [string] , ( SnipMateSnippetDefinition ( trigger , content , description , [string] % ( filename , start_line_index ) ) , ) , ) [EOL] [EOL] [EOL] def _parse_snippets_file ( data , filename ) : [EOL] [docstring] [EOL] lines = LineIterator ( data ) [EOL] for line in lines : [EOL] if not line . strip ( ) : [EOL] continue [EOL] [EOL] head , tail = head_tail ( line ) [EOL] if head == [string] : [EOL] yield handle_extends ( tail , lines . line_index ) [EOL] elif head in [string] : [EOL] snippet = _parse_snippet ( line , lines , filename ) [EOL] if snippet is not None : [EOL] yield snippet [EOL] elif head and not head . startswith ( [string] ) : [EOL] yield [string] , ( [string] % line . rstrip ( ) , lines . line_index ) [EOL] [EOL] [EOL] class SnipMateFileSource ( SnippetFileSource ) : [EOL] [EOL] [docstring] [EOL] [EOL] def _get_all_snippet_files_for ( self , ft ) : [EOL] return _snipmate_files_for ( ft ) [EOL] [EOL] def _parse_snippet_file ( self , filedata , filename ) : [EOL] if filename . lower ( ) . endswith ( [string] ) : [EOL] for event , data in _parse_snippet_file ( filedata , filename ) : [EOL] yield event , data [EOL] else : [EOL] for event , data in _parse_snippets_file ( filedata , filename ) : [EOL] yield event , data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from UltiSnips . snippet . definition . ulti_snips import UltiSnipsSnippetDefinition [EOL] from UltiSnips . snippet . definition . snipmate import SnipMateSnippetDefinition [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from UltiSnips . snippet . definition . base import SnippetDefinition [EOL] from UltiSnips . snippet . parsing . ulti_snips import parse_and_instantiate [EOL] [EOL] [EOL] class UltiSnipsSnippetDefinition ( SnippetDefinition ) : [EOL] [EOL] [docstring] [EOL] [EOL] def instantiate ( self , snippet_instance , initial_text , indent ) : [EOL] return parse_and_instantiate ( snippet_instance , initial_text , indent ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Pattern , Any , Iterator , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import string , vim , re [EOL] [EOL] def complete ( tab , opts ) : [EOL] [docstring] [EOL] el = [ x for x in tab ] [EOL] pat = [string] . join ( list ( map ( lambda x : x + [string] if re . match ( [string] , x ) else x , el ) ) ) [EOL] try : [EOL] opts = [ x for x in opts if re . search ( pat , x , re . IGNORECASE ) ] [EOL] except : [EOL] opts = [ x for x in opts if x . startswith ( tab ) ] [EOL] if not len ( opts ) or str . lower ( tab ) in list ( map ( str . lower , opts ) ) : [EOL] return [string] [EOL] cads = [string] . join ( opts [ : [number] ] ) [EOL] if len ( opts ) > [number] : cads += [string] [EOL] return [string] . format ( cads ) [EOL] [EOL] def _parse_comments ( s ) : [EOL] [docstring] [EOL] i = iter ( s . split ( [string] ) ) [EOL] [EOL] rv = [ ] [EOL] try : [EOL] while True : [EOL] [comment] [EOL] flags , text = next ( i ) . split ( [string] , [number] ) [EOL] [EOL] if len ( flags ) == [number] : [EOL] rv . append ( ( [string] , text , text , text , [string] ) ) [EOL] [comment] [EOL] elif [string] in flags and [string] not in flags : [EOL] ctriple = [ [string] ] [EOL] indent = [string] [EOL] [EOL] if flags [ - [number] ] in string . digits : [EOL] indent = [string] * int ( flags [ - [number] ] ) [EOL] ctriple . append ( text ) [EOL] [EOL] flags , text = next ( i ) . split ( [string] , [number] ) [EOL] assert flags [ [number] ] == [string] [EOL] ctriple . append ( text ) [EOL] [EOL] flags , text = next ( i ) . split ( [string] , [number] ) [EOL] assert flags [ [number] ] == [string] [EOL] ctriple . append ( text ) [EOL] ctriple . append ( indent ) [EOL] [EOL] rv . append ( ctriple ) [EOL] elif [string] in flags : [EOL] if len ( text ) == [number] : [EOL] rv . insert ( [number] , ( [string] , text , text , text , [string] ) ) [EOL] except StopIteration : [EOL] return rv [EOL] [EOL] def get_comment_format ( ) : [EOL] [docstring] [EOL] commentstring = vim . eval ( [string] ) [EOL] if commentstring . endswith ( [string] ) : [EOL] c = commentstring [ : - [number] ] [EOL] return ( c . rstrip ( ) , c . rstrip ( ) , c . rstrip ( ) , [string] ) [EOL] comments = _parse_comments ( vim . eval ( [string] ) ) [EOL] for c in comments : [EOL] if c [ [number] ] == [string] : [EOL] return c [ [number] : ] [EOL] return comments [ [number] ] [ [number] : ] [EOL] [EOL] [EOL] def make_box ( twidth , bwidth = None ) : [EOL] b , m , e , i = ( s . strip ( ) for s in get_comment_format ( ) ) [EOL] bwidth_inner = bwidth - [number] - max ( len ( b ) , len ( i + e ) ) if bwidth else twidth + [number] [EOL] sline = b + m + bwidth_inner * m [ [number] ] + [number] * m [ [number] ] [EOL] nspaces = ( bwidth_inner - twidth ) // [number] [EOL] mlines = i + m + [string] + [string] * nspaces [EOL] mlinee = [string] + [string] * ( bwidth_inner - twidth - nspaces ) + m [EOL] eline = i + m + bwidth_inner * m [ [number] ] + [number] * m [ [number] ] + e [EOL] return sline , mlines , mlinee , eline [EOL] [EOL] def foldmarker ( ) : [EOL] [docstring] [EOL] return vim . eval ( [string] ) . split ( [string] ) [EOL] [EOL] [EOL] def display_width ( str ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] return vim . strdisplaywidth ( str ) [EOL] except AttributeError : [EOL] [comment] [EOL] from unicodedata import east_asian_width [EOL] result = [number] [EOL] for c in str : [EOL] result += [number] if east_asian_width ( c ) in ( [string] , [string] ) else [number] [EOL] return result [EOL] [EOL] [comment] [EOL] def has_cjk ( s ) : [EOL] [docstring] [EOL] cjk_re = re . compile ( [string] , re . UNICODE ) [EOL] [EOL] return cjk_re . search ( s ) is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] from . base import Base [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] Base . __init__ ( self , vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = [string] [EOL] self . sorters = [ ] [EOL] self . vars = { [string] : [string] , } [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] candidates = self . vim . call ( [string] ) [EOL] [EOL] def time_format ( x ) : [EOL] return self . vim . call ( [string] , x ) [EOL] [EOL] def path_format ( x ) : [EOL] return self . vim . call ( [string] , x , self . vars [ [string] ] ) [EOL] [EOL] if self . vim . vars [ [string] ] == [string] : [EOL] return [ { [string] : path_format ( x ) , [string] : path_format ( x ) , [string] : x } for x in candidates ] [EOL] else : [EOL] return [ { [string] : path_format ( x ) , [string] : self . vim . call ( [string] , path_format ( x ) , time_format ( x ) ) , [string] : x } for x in candidates ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from . base import Base [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] Base . __init__ ( self , vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = [string] [EOL] self . default_action = [string] [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] return [ { [string] : x , [string] : x } for x in self . vim . call ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] import asyncio [EOL] import typing [EOL] [EOL] [EOL] class Process ( asyncio . SubprocessProtocol ) : [EOL] [EOL] def __init__ ( self , plugin ) : [EOL] self . _plugin = plugin [EOL] self . _vim = plugin . _vim [EOL] [EOL] def connection_made ( self , transport ) : [EOL] self . _unpacker = self . _plugin . _connect_stdin ( transport . get_pipe_transport ( [number] ) ) [EOL] [EOL] def pipe_data_received ( self , fd , data ) : [EOL] if fd == [number] : [EOL] [comment] [EOL] self . _plugin . _queue_err . put ( f' [string] { data }' ) [EOL] return [EOL] [EOL] unpacker = self . _unpacker [EOL] unpacker . feed ( data ) [EOL] for child_out in unpacker : [EOL] self . _plugin . _queue_out . put ( child_out ) [EOL] [EOL] def process_exited ( self ) : [EOL] self . _plugin . _queue_err . put ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class SourceInitError ( Exception ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import deoplete [EOL] from deoplete . base . source import Base as _Base [EOL] from deoplete . util import Nvim [EOL] [EOL] [EOL] class Base ( _Base ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 0 0 0 0 $deoplete.util.Nvim$ 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Set , Any , Dict [EOL] import builtins [EOL] import typing [EOL] import deoplete [EOL] import re [EOL] import typing [EOL] [EOL] from deoplete . base . filter import Base [EOL] from deoplete . util import getlines [EOL] from deoplete . util import Nvim , UserContext , Candidates , Candidate [EOL] [EOL] [EOL] LINES_MAX = [number] [EOL] [EOL] [EOL] class Filter ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . description = [string] [EOL] self . _cache = { } [EOL] [EOL] def on_event ( self , context ) : [EOL] self . _cache = { } [EOL] start = max ( [ [number] , context [ [string] ] [ [number] ] - LINES_MAX ] ) [EOL] linenr = start [EOL] for line in getlines ( self . vim , start , start + LINES_MAX ) : [EOL] for m in re . finditer ( context [ [string] ] , line ) : [EOL] k = m . group ( [number] ) [EOL] if k not in self . _cache : [EOL] self . _cache [ k ] = set ( ) [EOL] self . _cache [ k ] . add ( linenr ) [EOL] linenr += [number] [EOL] [EOL] def filter ( self , context ) : [EOL] complete_str = context [ [string] ] . lower ( ) [EOL] linenr = context [ [string] ] [ [number] ] [EOL] [EOL] def compare ( x ) : [EOL] word = x [ [string] ] [EOL] matched = int ( complete_str in word . lower ( ) ) [EOL] score = - matched * [number] [EOL] if word in self . _cache : [EOL] mru = min ( [ abs ( x - linenr ) for x in self . _cache [ word ] ] ) [EOL] mru -= LINES_MAX [EOL] score += mru * [number] [EOL] return score [EOL] return sorted ( context [ [string] ] , key = compare ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 0 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.int]]$ 0 0 0 0 0 0 $None$ 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.int]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.int]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Set[builtins.int]]$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $deoplete.util.Candidate.s$ 0 0 0 $deoplete.util.UserContext$ 0 0 0 $typing.Any$ 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $deoplete.util.Candidate$ 0 0 0 $typing.Any$ 0 $deoplete.util.Candidate$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $deoplete.util.Candidate$ 0 0 0 0 $deoplete.util.Candidate$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Any [EOL] import deoplete [EOL] import typing [EOL] import re [EOL] [EOL] from deoplete . base . filter import Base [EOL] from deoplete . util import ( fuzzy_escape , binary_search_begin , binary_search_end ) [EOL] from deoplete . util import Nvim , UserContext , Candidates [EOL] [EOL] [EOL] class Filter ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . description = [string] [EOL] [EOL] def filter ( self , context ) : [EOL] complete_str = context [ [string] ] [EOL] if context [ [string] ] : [EOL] complete_str = complete_str . lower ( ) [EOL] if not complete_str : [EOL] return context [ [string] ] [comment] [EOL] [EOL] if context [ [string] ] : [EOL] begin = binary_search_begin ( context [ [string] ] , complete_str [ [number] ] ) [EOL] end = binary_search_end ( context [ [string] ] , complete_str [ [number] ] ) [EOL] if begin < [number] or end < [number] : [EOL] return [ ] [EOL] candidates = context [ [string] ] [ begin : end + [number] ] [EOL] else : [EOL] candidates = context [ [string] ] [EOL] [EOL] p = re . compile ( fuzzy_escape ( complete_str , context [ [string] ] ) ) [EOL] if context [ [string] ] : [EOL] return [ x for x in candidates if p . match ( x [ [string] ] . lower ( ) ) ] [EOL] else : [EOL] return [ x for x in candidates if p . match ( x [ [string] ] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 0 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $deoplete.util.Candidates$ 0 0 0 $deoplete.util.UserContext$ 0 0 0 $typing.Any$ 0 $deoplete.util.UserContext$ 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 $typing.Any$ 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $deoplete.util.UserContext$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $deoplete.util.UserContext$ 0 0 0 0 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 $deoplete.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[typing.Any]$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import deoplete [EOL] from deoplete . base . filter import Base as _Base [EOL] from deoplete . util import Nvim [EOL] [EOL] [EOL] class Base ( _Base ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $deoplete.util.Nvim$ 0 0 0 0 0 0 0 0 0 $deoplete.util.Nvim$ 0 0
	0
import os [EOL] import sys [EOL] [EOL] BASE_DIR = os . path . dirname ( os . path . dirname ( __file__ ) ) [EOL] sys . path . insert ( [number] , os . path . join ( BASE_DIR , [string] ) ) [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Type , Any , Dict , List [EOL] import builtins [EOL] import typing [EOL] import denite [EOL] import typing [EOL] [EOL] from denite . context import Context [EOL] from denite . util import Nvim [EOL] [EOL] Args = typing . List [ typing . Any ] [EOL] [EOL] [EOL] class Rplugin : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] self . _vim = vim [EOL] self . _uis = { } [EOL] [EOL] def init_channel ( self , args ) : [EOL] self . _vim . vars [ [string] ] = self . _vim . channel_id [EOL] [EOL] def start ( self , args ) : [EOL] try : [EOL] context = Context ( self . _vim ) . get ( args [ [number] ] ) [EOL] ui = self . get_ui ( context [ [string] ] ) [EOL] return ui . start ( args [ [number] ] , context ) [EOL] except NameError as ex : [EOL] import denite . util [EOL] denite . util . error ( self . _vim , str ( ex ) ) [EOL] except Exception : [EOL] import traceback [EOL] import denite . util [EOL] for line in traceback . format_exc ( ) . splitlines ( ) : [EOL] denite . util . error ( self . _vim , line ) [EOL] denite . util . error ( self . _vim , [string] ) [EOL] [EOL] def do_action ( self , args ) : [EOL] try : [EOL] ui = self . get_ui ( args [ [number] ] [ [string] ] ) [EOL] ui . _cursor = self . _vim . call ( [string] , [string] ) [EOL] return ui . _denite . do_action ( args [ [number] ] , args [ [number] ] , args [ [number] ] ) [EOL] except Exception : [EOL] import traceback [EOL] import denite . util [EOL] for line in traceback . format_exc ( ) . splitlines ( ) : [EOL] denite . util . error ( self . _vim , line ) [EOL] denite . util . error ( self . _vim , [string] ) [EOL] [EOL] def do_map ( self , args ) : [EOL] from denite . ui . map import do_map [EOL] bufnr = args [ [number] ] [EOL] if not self . _vim . call ( [string] , bufnr ) : [EOL] return [EOL] bufvars = self . _vim . buffers [ bufnr ] . vars [EOL] if [string] not in bufvars : [EOL] return [EOL] [EOL] try : [EOL] ui = self . get_ui ( bufvars [ [string] ] [ [string] ] ) [EOL] ui . _cursor = self . _vim . call ( [string] , [string] ) [EOL] return do_map ( ui , args [ [number] ] , args [ [number] ] ) [EOL] except Exception : [EOL] import traceback [EOL] import denite . util [EOL] for line in traceback . format_exc ( ) . splitlines ( ) : [EOL] denite . util . error ( self . _vim , line ) [EOL] denite . util . error ( self . _vim , [string] ) [EOL] [EOL] def get_ui ( self , buffer_name ) : [EOL] from denite . ui . default import Default [EOL] if buffer_name not in self . _uis : [EOL] self . _uis [ buffer_name ] = Default ( self . _vim ) [EOL] return self . _uis [ buffer_name ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $None$ 0 0 0 $Args$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $Args$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $Args$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $Args$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $Args$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $Args$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $Args$ 0 0 0 0 $Args$ 0 0 0 0 $Args$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $Args$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $Args$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $Args$ 0 0 0 0 $Args$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import denite [EOL] import typing [EOL] [EOL] import denite . util [EOL] from denite . util import Nvim , UserContext [EOL] [EOL] [EOL] class Base ( object ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] self . vim = vim [EOL] self . name = [string] [EOL] self . default_action = [string] [EOL] self . persist_actions = [ [string] , [string] ] [EOL] self . redraw_actions = [ ] [EOL] [EOL] def debug ( self , expr ) : [EOL] denite . util . debug ( self . vim , expr ) [EOL] [EOL] def action_echo ( self , context ) : [EOL] self . vim . command ( [string] ) [EOL] for target in context [ [string] ] : [EOL] self . debug ( target ) [EOL] self . vim . call ( [string] ) [EOL] [EOL] def action_yank ( self , context ) : [EOL] _yank ( self . vim , [string] . join ( [ x [ [string] ] for x in context [ [string] ] ] ) ) [EOL] [EOL] def action_ex ( self , context ) : [EOL] _ex ( self . vim , [string] . join ( [ x [ [string] ] for x in context [ [string] ] ] ) ) [EOL] [EOL] def action_replace ( self , context ) : [EOL] self . vim . command ( [string] ) [EOL] self . action_append ( context ) [EOL] [EOL] def action_append ( self , context ) : [EOL] for target in context [ [string] ] : [EOL] _paste ( self . vim , target . get ( [string] , target [ [string] ] ) , [string] , [string] ) [EOL] [EOL] def get_action_names ( self ) : [EOL] return [ [string] ] + [ x . replace ( [string] , [string] ) for x in dir ( self ) if x . find ( [string] ) == [number] ] [EOL] [EOL] def action_preview ( self , context ) : [EOL] pass [EOL] [EOL] def action_defx ( self , context ) : [EOL] if not self . vim . call ( [string] , [string] ) : [EOL] return [EOL] [EOL] self . vim . call ( [string] , [ x . get ( [string] , x [ [string] ] ) for x in context [ [string] ] ] , { } ) [EOL] [EOL] [EOL] class Kind ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] [EOL] def _yank ( vim , word ) : [EOL] vim . call ( [string] , [string] , word , [string] ) [EOL] if vim . call ( [string] , [string] ) : [EOL] vim . call ( [string] , vim . eval ( [string] ) , word , [string] ) [EOL] [EOL] [EOL] def _ex ( vim , word ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] expr = vim . call ( [string] , [string] , [string] % word , [string] ) [EOL] if expr : [EOL] vim . command ( expr ) [EOL] [EOL] [EOL] def _paste ( vim , word , command , regtype ) : [EOL] if regtype == [string] : [EOL] regtype = [string] [EOL] [EOL] [comment] [EOL] old_reg = [ vim . call ( [string] , [string] ) , vim . call ( [string] , [string] ) ] [EOL] [EOL] vim . call ( [string] , [string] , word , regtype ) [EOL] try : [EOL] vim . command ( [string] + command ) [EOL] finally : [EOL] vim . call ( [string] , [string] , old_reg [ [number] ] , old_reg [ [number] ] ) [EOL] [EOL] [comment] [EOL] vim . command ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type , Dict , Callable , List [EOL] import builtins [EOL] import typing [EOL] import denite [EOL] import typing [EOL] [EOL] from denite . util import debug , clear_cmdline [EOL] from denite . ui . default import Default [EOL] from os . path import dirname [EOL] [EOL] Params = typing . List [ str ] [EOL] Action = typing . Callable [ [ Default , Params ] , typing . Any ] [EOL] [EOL] [EOL] def do_map ( denite , name , params ) : [EOL] if name not in MAPPINGS : [EOL] return [EOL] return MAPPINGS [ name ] ( denite , params ) [EOL] [EOL] [EOL] def _auto_action ( denite , params ) : [EOL] if not denite . _context [ [string] ] : [EOL] return [EOL] return denite . do_action ( denite . _context [ [string] ] ) [EOL] [EOL] [EOL] def _change_path ( denite , params ) : [EOL] path = denite . _vim . call ( [string] , [string] , denite . _context [ [string] ] , [string] ) [EOL] denite . _context [ [string] ] = path [EOL] return denite . _restart ( ) [EOL] [EOL] [EOL] def _change_sorters ( denite , params ) : [EOL] sorters = [string] . join ( params ) [EOL] context = denite . _context [EOL] if context [ [string] ] != sorters : [EOL] context [ [string] ] = sorters [EOL] else : [EOL] context [ [string] ] = [string] [EOL] return denite . redraw ( ) [EOL] [EOL] [EOL] def _choose_action ( denite , params ) : [EOL] candidates = denite . _get_selected_candidates ( ) [EOL] if not candidates or not denite . _denite : [EOL] return [EOL] [EOL] action_names = denite . _denite . get_action_names ( denite . _context , candidates ) [EOL] denite . _vim . vars [ [string] ] = action_names [EOL] clear_cmdline ( denite . _vim ) [EOL] action = str ( denite . _vim . call ( [string] , [string] , [string] , [string] ) ) [EOL] if action == [string] : [EOL] return [EOL] return denite . do_action ( action , is_manual = True ) [EOL] [EOL] [EOL] def _do_action ( denite , params ) : [EOL] name = params [ [number] ] if params else [string] [EOL] return denite . do_action ( name , is_manual = True ) [EOL] [EOL] [EOL] def _do_previous_action ( denite , params ) : [EOL] return denite . do_action ( denite . _prev_action , is_manual = True ) [EOL] [EOL] [EOL] def _filter ( denite , params ) : [EOL] text = params [ [number] ] if params else [string] [EOL] [EOL] if denite . _previous_text == text and not denite . is_async : [EOL] [comment] [EOL] return [EOL] [EOL] denite . _context [ [string] ] = text [EOL] [EOL] denite . _update_candidates ( ) [EOL] _update_buffer ( denite , params ) [EOL] [EOL] [EOL] def _filter_async ( denite , params ) : [EOL] text = params [ [number] ] if params else [string] [EOL] [EOL] if denite . _previous_text == text and not denite . is_async : [EOL] [comment] [EOL] return [EOL] [EOL] denite . _context [ [string] ] = text [EOL] [EOL] denite . _update_candidates ( ) [EOL] [EOL] [EOL] def _move_up_path ( denite , params ) : [EOL] denite . _context [ [string] ] = dirname ( denite . _context [ [string] ] ) [EOL] return denite . _restart ( ) [EOL] [EOL] [EOL] def _nop ( denite , params ) : [EOL] pass [EOL] [EOL] [EOL] def _open_filter_buffer ( denite , params ) : [EOL] denite . _vim . call ( [string] , denite . _context , denite . _bufnr , denite . _entire_len , denite . is_async ) [EOL] [EOL] [EOL] def _print_messages ( denite , params ) : [EOL] for mes in denite . _context [ [string] ] : [EOL] debug ( denite . _vim , mes ) [EOL] denite . _vim . call ( [string] ) [EOL] [EOL] [EOL] def _quick_move ( denite , params ) : [EOL] vim = denite . _vim [EOL] context = denite . _context [EOL] [EOL] def get_quick_move_table ( ) : [EOL] table = { } [EOL] base = vim . call ( [string] , [string] ) [EOL] for [ key , number ] in context [ [string] ] . items ( ) : [EOL] number = int ( number ) [EOL] pos = ( ( base - number ) if context [ [string] ] [EOL] else ( number + base ) ) [EOL] if pos > [number] : [EOL] table [ key ] = pos [EOL] return table [EOL] [EOL] def quick_move_redraw ( table , is_define ) : [EOL] bufnr = vim . current . buffer . number [EOL] for [ key , number ] in table . items ( ) : [EOL] signid = [number] + number [EOL] name = [string] + str ( number ) [EOL] if is_define : [EOL] if vim . call ( [string] , [string] ) : [EOL] vim . call ( [string] , name , { [string] : key , [string] : [string] } ) [EOL] vim . call ( [string] , signid , [string] , name , bufnr , { [string] : number } ) [EOL] else : [EOL] vim . command ( f' [string] { name } [string] { key } [string] ' ) [EOL] vim . command ( f' [string] { signid } [string] { name } [string] ' f' [string] { number } [string] { bufnr }' ) [EOL] else : [EOL] if vim . call ( [string] , [string] ) : [EOL] vim . call ( [string] , [string] , { [string] : signid , [string] : bufnr } ) [EOL] vim . call ( [string] , name ) [EOL] else : [EOL] vim . command ( f' [string] { signid } [string] { bufnr }' ) [EOL] vim . command ( [string] + name ) [EOL] [EOL] quick_move_table = get_quick_move_table ( ) [EOL] vim . command ( [string] ) [EOL] quick_move_redraw ( quick_move_table , True ) [EOL] vim . command ( [string] ) [EOL] [EOL] char = [string] [EOL] while char == [string] : [EOL] char = vim . call ( [string] , vim . call ( [string] ) ) [EOL] [EOL] quick_move_redraw ( quick_move_table , False ) [EOL] [EOL] if char not in quick_move_table : [EOL] return [EOL] [EOL] denite . _move_to_pos ( int ( quick_move_table [ char ] ) ) [EOL] [EOL] if context [ [string] ] == [string] : [EOL] if context [ [string] ] : [EOL] context [ [string] ] . pop ( [number] ) [EOL] denite . do_action ( [string] , is_manual = True ) [EOL] return True [EOL] [EOL] [EOL] def _quit ( denite , params ) : [EOL] return denite . quit ( ) [EOL] [EOL] [EOL] def _redraw ( denite , params ) : [EOL] return denite . redraw ( ) [EOL] [EOL] [EOL] def _restart ( denite , params ) : [EOL] return denite . _restart ( ) [EOL] [EOL] [EOL] def _restore_sources ( denite , params ) : [EOL] if len ( denite . _sources_history ) < [number] : [EOL] return [EOL] [EOL] history = denite . _sources_history [ - [number] ] [EOL] denite . _context [ [string] ] . append ( history [ [string] ] ) [EOL] denite . _context [ [string] ] = history [ [string] ] [EOL] [EOL] [comment] [EOL] denite . _sources_history . pop ( ) [EOL] denite . _sources_history . pop ( ) [EOL] [EOL] denite . _context [ [string] ] = [string] [EOL] denite . _quit_buffer ( ) [EOL] denite . _start_sources_queue ( denite . _context ) [EOL] [EOL] [EOL] def _toggle_matchers ( denite , params ) : [EOL] matchers = [string] . join ( params ) [EOL] context = denite . _context [EOL] if context [ [string] ] != matchers : [EOL] context [ [string] ] = matchers [EOL] else : [EOL] context [ [string] ] = [string] [EOL] return denite . redraw ( ) [EOL] [EOL] [EOL] def _toggle_select ( denite , params ) : [EOL] index = denite . _vim . call ( [string] , [string] ) - [number] [EOL] _toggle_select_candidate ( denite , index ) [EOL] denite . _update_displayed_texts ( ) [EOL] return denite . _update_buffer ( ) [EOL] [EOL] [EOL] def _toggle_select_candidate ( denite , index ) : [EOL] if index in denite . _selected_candidates : [EOL] denite . _selected_candidates . remove ( index ) [EOL] else : [EOL] denite . _selected_candidates . append ( index ) [EOL] [EOL] [EOL] def _toggle_select_all ( denite , params ) : [EOL] for index in range ( [number] , len ( denite . _candidates ) ) : [EOL] _toggle_select_candidate ( denite , index ) [EOL] denite . _update_displayed_texts ( ) [EOL] return denite . _update_buffer ( ) [EOL] [EOL] [EOL] def _update_buffer ( denite , params ) : [EOL] if denite . _updated : [EOL] try : [EOL] denite . _update_buffer ( ) [EOL] except Exception : [EOL] pass [EOL] else : [EOL] denite . _update_status ( ) [EOL] [EOL] [EOL] def _update_candidates ( denite , params ) : [EOL] if not denite . _is_async : [EOL] return [EOL] denite . _update_candidates ( ) [EOL] [EOL] [EOL] MAPPINGS = { [string] : _auto_action , [string] : _change_path , [string] : _change_sorters , [string] : _choose_action , [string] : _do_action , [string] : _do_previous_action , [string] : _filter , [string] : _filter_async , [string] : _move_up_path , [string] : _nop , [string] : _open_filter_buffer , [string] : _print_messages , [string] : _quick_move , [string] : _quit , [string] : _redraw , [string] : _restart , [string] : _restore_sources , [string] : _toggle_matchers , [string] : _toggle_select , [string] : _toggle_select_all , [string] : _update_buffer , [string] : _update_candidates , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Action]$ 0 0 0 0 0 $typing.Dict[builtins.str,Action]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Action]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import denite [EOL] from denite . base . kind import Base [EOL] from denite . util import Nvim [EOL] [EOL] [EOL] class Kind ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . default_action = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] import denite [EOL] from denite . base . kind import Base [EOL] from denite . util import Nvim , UserContext [EOL] [EOL] [EOL] class Kind ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . default_action = [string] [EOL] [EOL] def action_execute ( self , context ) : [EOL] target = context [ [string] ] [ [number] ] [EOL] self . _execute ( context , target [ [string] ] , target . get ( [string] , False ) ) [EOL] [EOL] def action_edit ( self , context ) : [EOL] target = context [ [string] ] [ [number] ] [EOL] self . vim . call ( [string] , f" [string] { target [ [string] ] }" ) [EOL] [EOL] def _execute ( self , context , command , histadd ) : [EOL] if not command : [EOL] return [EOL] if context [ [string] ] != context [ [string] ] : [EOL] command = [string] . format ( context [ [string] ] , context [ [string] ] , command ) [EOL] self . vim . call ( [string] , command , False ) [EOL] if histadd : [EOL] self . vim . call ( [string] , [string] , command ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import denite [EOL] from denite . base . kind import Base [EOL] from denite . util import Nvim , UserContext [EOL] [EOL] [EOL] class Kind ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . default_action = [string] [EOL] [EOL] def action_start ( self , context ) : [EOL] context [ [string] ] . append ( [ { [string] : x [ [string] ] [ [number] ] , [string] : x [ [string] ] [ [number] : ] } for x in context [ [string] ] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import denite [EOL] from denite . base . kind import Base [EOL] from denite . util import Nvim , UserContext [EOL] [EOL] [EOL] class Kind ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . default_action = [string] [EOL] [EOL] def action_cd ( self , context ) : [EOL] target = context [ [string] ] [ [number] ] [EOL] self . vim . call ( [string] , target [ [string] ] ) [EOL] [EOL] def action_narrow ( self , context ) : [EOL] target = context [ [string] ] [ [number] ] [EOL] context [ [string] ] . append ( [ { [string] : [string] , [string] : [ ] } , { [string] : [string] , [string] : [ [string] ] } , ] ) [EOL] context [ [string] ] = target [ [string] ] [EOL] [EOL] def action_open ( self , context ) : [EOL] for target in context [ [string] ] : [EOL] path = target [ [string] ] [EOL] match_path = f' [string] { path } [string] ' [EOL] [EOL] if self . vim . call ( [string] , match_path ) <= [number] : [EOL] self . vim . call ( [string] , [string] , path ) [EOL] elif self . vim . call ( [string] , match_path ) != self . vim . current . buffer : [EOL] self . vim . call ( [string] , [string] , path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import denite [EOL] from denite . base . kind import Base as _Base [EOL] from denite . util import Nvim [EOL] [EOL] [EOL] class Base ( _Base ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0
[EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import builtins [EOL] import typing [EOL] import pack [EOL] import denite [EOL] import typing [EOL] [EOL] from denite . base . source import Base [EOL] from denite . kind . file import Kind as File [EOL] from denite . util import Nvim , UserContext , Candidates , Candidate [EOL] [EOL] [EOL] MARK_HIGHLIGHT_SYNTAX = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] self . name = [string] [EOL] self . kind = Kind ( vim ) [EOL] [EOL] def highlight ( self ) : [EOL] for syn in MARK_HIGHLIGHT_SYNTAX : [EOL] self . vim . command ( [string] . format ( self . syntax_name , syn [ [string] ] , syn [ [string] ] ) ) [EOL] self . vim . command ( [string] . format ( self . syntax_name , syn [ [string] ] , syn [ [string] ] ) ) [EOL] [EOL] def _get_marks ( self , context ) : [EOL] [comment] [EOL] [comment] [EOL] lower_marks = [ chr ( c ) for c in range ( ord ( [string] ) , ord ( [string] ) ) ] [EOL] upper_marks = [ chr ( c ) for c in range ( ord ( [string] ) , ord ( [string] ) ) ] [EOL] num_marks = [ str ( n ) for n in range ( [number] , [number] ) ] [EOL] others_marks = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] mark_list = [ ] [EOL] [EOL] [comment] [EOL] for m in [ others_marks [ [number] ] ] + lower_marks + upper_marks + num_marks + others_marks [ [number] : ] : [EOL] [EOL] mark_info = [ bufnum , lnum , col , off ] = self . vim . call ( [string] , [string] + m ) [EOL] if self . empty_mark ( mark_info ) : [EOL] continue [EOL] [EOL] bufname = self . vim . call ( [string] , bufnum if bufnum != [number] else [string] ) [EOL] path = self . vim . call ( [string] , bufname , [string] ) [EOL] if bufnum == [number] : [EOL] file_or_text = [string] + self . vim . call ( [string] , lnum ) [EOL] else : [EOL] file_or_text = [string] + path [EOL] [EOL] mark_list . append ( { [string] : [string] . format ( m , lnum , col , file_or_text ) , [string] : path , [string] : lnum , [string] : col , [string] : m , } ) [EOL] return mark_list [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] return self . _get_marks ( context ) [EOL] [EOL] def empty_mark ( self , mark_info ) : [EOL] return mark_info [ [number] ] == [number] and mark_info [ [number] ] == [number] and mark_info [ [number] ] == [number] [EOL] [EOL] [EOL] class Kind ( File ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . _previewed_target = { } [EOL] [EOL] def action_delete ( self , context ) : [EOL] mark = context [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] [comment] [EOL] if mark == [string] : [EOL] return [EOL] [EOL] self . vim . command ( [string] + mark ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pack.bundle.opt.denite.rplugin.python3.denite.source.mark.Kind$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.Candidate.s$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.Candidate.s$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $denite.util.Candidate.s$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.Candidate.s$ 0 0 0 $denite.util.Candidate.s$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $denite.util.Candidate$ 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any , Match , Dict , List [EOL] import builtins [EOL] import typing [EOL] import denite [EOL] import re [EOL] import typing [EOL] from os . path import exists [EOL] from pathlib import Path [EOL] [EOL] from denite . base . source import Base [EOL] from denite . util import ( parse_tagline , Nvim , UserContext , Candidates , Candidate ) [EOL] [EOL] TAG_HIGHLIGHT_SYNTAX = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . vim = vim [EOL] self . name = [string] [EOL] self . kind = [string] [EOL] [EOL] def on_init ( self , context ) : [EOL] self . _tags = self . _get_tagfiles ( context ) [EOL] [EOL] def highlight ( self ) : [EOL] for syn in TAG_HIGHLIGHT_SYNTAX : [EOL] self . vim . command ( [string] . format ( self . syntax_name , syn [ [string] ] , syn [ [string] ] ) ) [EOL] self . vim . command ( [string] . format ( self . syntax_name , syn [ [string] ] , syn [ [string] ] ) ) [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] candidates = [ ] [EOL] for filename in self . _tags : [EOL] with open ( filename , [string] , encoding = context [ [string] ] , errors = [string] ) as ins : [EOL] for line in ins : [EOL] candidate = self . _get_candidate ( filename , line ) [EOL] if candidate : [EOL] candidates . append ( candidate ) [EOL] [EOL] return sorted ( candidates , key = lambda value : value [ [string] ] ) [EOL] [EOL] def _get_candidate ( self , filename , line ) : [EOL] if re . match ( [string] , line ) or not line : [EOL] return { } [EOL] [EOL] info = parse_tagline ( line . rstrip ( ) , filename ) [EOL] candidate = { [string] : info [ [string] ] , [string] : info [ [string] ] } [EOL] [EOL] info [ [string] ] = ( ( info [ [string] ] [ : [number] ] + [string] ) [EOL] if len ( info [ [string] ] ) >= [number] [EOL] else info [ [string] ] ) [EOL] info [ [string] ] = Path ( info [ [string] ] ) . name [EOL] fmt = [string] [EOL] if info [ [string] ] : [EOL] candidate [ [string] ] = info [ [string] ] [EOL] fmt += [string] [EOL] else : [EOL] candidate [ [string] ] = info [ [string] ] [EOL] m = re . search ( [string] , info [ [string] ] ) [EOL] if m : [EOL] info [ [string] ] = [string] + m . group ( [number] ) . lstrip ( ) [EOL] fmt += [string] [EOL] candidate [ [string] ] = fmt . format ( ** info ) [EOL] return candidate [EOL] [EOL] def _get_tagfiles ( self , context ) : [EOL] if ( context [ [string] ] [EOL] and context [ [string] ] [ [number] ] == [string] [EOL] and self . vim . call ( [string] , [string] ) ) : [EOL] tagfiles = self . vim . call ( [string] ) [EOL] else : [EOL] tagfiles = self . vim . call ( [string] ) [EOL] return [ x for x in self . vim . call ( [string] , tagfiles , [string] ) if exists ( x ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.Candidate.s$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.Candidate$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import pack [EOL] import denite [EOL] from os import path [EOL] [EOL] from denite . base . source import Base [EOL] from denite . kind . command import Kind as Command [EOL] [EOL] from denite . util import globruntime , Nvim , UserContext , Candidates [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = Kind ( vim ) [EOL] [EOL] def on_init ( self , context ) : [EOL] context [ [string] ] = ( self . vim . vars [ [string] ] [EOL] if [string] in self . vim . vars else [string] ) [EOL] [EOL] def on_close ( self , context ) : [EOL] self . vim . command ( f' [string] { context [ [string] ] }' ) [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] colorschemes = { } [EOL] [EOL] for filename in globruntime ( context [ [string] ] , [string] ) : [EOL] colorscheme = path . splitext ( path . basename ( filename ) ) [ [number] ] [EOL] colorschemes [ colorscheme ] = { [string] : colorscheme , [string] : [string] + colorscheme } [EOL] [EOL] return sorted ( colorschemes . values ( ) , key = lambda value : value [ [string] ] ) [EOL] [EOL] [EOL] class Kind ( Command ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] self . vim = vim [EOL] self . name = [string] [EOL] [EOL] def action_preview ( self , context ) : [EOL] target = context [ [string] ] [ [number] ] [EOL] self . vim . command ( f' [string] { target [ [string] ] }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pack.bundle.opt.denite.rplugin.python3.denite.source.colorscheme.Kind$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 $denite.util.Candidates$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import pack [EOL] import denite [EOL] import re [EOL] [EOL] from denite . base . source import Base [EOL] from denite . kind . command import Kind as Command [EOL] from denite . util import globruntime , Nvim , UserContext , Candidates [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = Kind ( vim ) [EOL] self . commands = [ ] [EOL] [EOL] self . _re_command = re . compile ( [string] ) [EOL] self . _re_tokens = re . compile ( [string] ) [EOL] [EOL] def on_init ( self , context ) : [EOL] runtimepath = self . vim . eval ( [string] ) [EOL] self . _helpfiles = globruntime ( runtimepath , [string] ) [EOL] self . _commands = globruntime ( runtimepath , [string] ) [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] context [ [string] ] = True [EOL] [EOL] has_cmdline = self . vim . call ( [string] ) [EOL] if [string] not in context [ [string] ] or not has_cmdline : [EOL] if not self . commands : [EOL] self . _init_commands ( ) [EOL] return self . commands + [ { [string] : x , [string] : x , } for x in self . vim . call ( [string] , [string] , [string] ) ] [EOL] [EOL] prefix = re . sub ( [string] , [string] , context [ [string] ] ) [EOL] [EOL] candidates = [ { [string] : prefix + x , [string] : prefix + x , [string] : True , } for x in self . vim . call ( [string] , context [ [string] ] , [string] ) ] [EOL] if not candidates : [EOL] candidates = [ { [string] : context [ [string] ] , [string] : context [ [string] ] , [string] : True , } ] [EOL] return candidates [EOL] [EOL] def _init_commands ( self ) : [EOL] for helpfile in self . _helpfiles : [EOL] with open ( helpfile ) as doc : [EOL] for line in [ x for x in doc . readlines ( ) if self . _re_command . match ( x ) ] : [EOL] m = self . _re_tokens . match ( line ) [EOL] if not m : [EOL] continue [EOL] tokens = m . groups ( ) [EOL] command = f" [string] { tokens [ [number] ] } [string] " [EOL] self . commands . append ( { [string] : command , [string] : [string] . format ( tokens [ [number] ] , tokens [ [number] ] , ) , } ) [EOL] [EOL] [EOL] class Kind ( Command ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] [EOL] def action_edit ( self , context ) : [EOL] return super ( ) . action_execute ( context ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pack.bundle.opt.denite.rplugin.python3.denite.source.command.Kind$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 $denite.util.Candidates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $denite.util.Candidates$ 0 0 0 $denite.util.UserContext$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import denite [EOL] from denite . base . source import Base as _Base [EOL] from denite . util import Nvim [EOL] [EOL] [EOL] class Base ( _Base ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import denite [EOL] import re [EOL] import typing [EOL] [EOL] from denite . base . source import Base [EOL] from denite . util import Nvim , UserContext , Candidates [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] self . name = [string] [EOL] self . default_action = [string] [EOL] self . kind = [string] [EOL] [EOL] def define_syntax ( self ) : [EOL] if not self . context [ [string] ] : [EOL] return [EOL] cmd = self . context [ [string] ] [ [number] ] [EOL] if re . fullmatch ( [string] , cmd ) : [EOL] self . define_syntax_for_highlight ( cmd ) [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] args = context [ [string] ] [EOL] [EOL] if not args : [EOL] return [ ] [EOL] [EOL] first = args [ [number] ] [EOL] output = [ ] [EOL] if first [ [number] ] != [string] : [EOL] cmdline = [string] . join ( args ) [EOL] output = self . vim . call ( [string] , cmdline ) . splitlines ( ) [ [number] : ] [EOL] else : [EOL] cmdline = [string] . join ( [ first [ [number] : ] ] + args [ [number] : ] ) [EOL] output = self . vim . call ( [string] , cmdline ) . splitlines ( ) [EOL] return [ { [string] : x } for x in output ] [EOL] [EOL] def define_syntax_for_highlight ( self , cmd ) : [EOL] self . vim . command ( [string] ) [EOL] hi_list = self . vim . call ( [string] , cmd ) . splitlines ( ) [ [number] : ] [EOL] for hi in ( h . split ( ) [ [number] ] for h in hi_list ) : [EOL] syn_hi_name = ( [string] + [string] + hi + [string] + [string] + hi + [string] ) [EOL] syn_hi_xxx = ( [string] + hi + [string] + [string] + [string] + [string] ) [EOL] self . vim . command ( syn_hi_name ) [EOL] self . vim . command ( syn_hi_xxx ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $denite.util.Candidates$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import argparse [EOL] import typing [EOL] import denite [EOL] import builtins [EOL] import pathlib [EOL] import argparse [EOL] import shutil [EOL] import typing [EOL] [EOL] from pathlib import Path [EOL] [EOL] from denite . base . source import Base [EOL] from denite . process import Process [EOL] from denite . util import parse_command , abspath , Nvim , UserContext , Candidates [EOL] from denite . util import get_python_exe [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = [string] [EOL] self . vars = { [string] : [ ] , [string] : [number] , } [EOL] self . converters = [ [string] ] [EOL] [EOL] self . _cache = { } [EOL] [EOL] def on_init ( self , context ) : [EOL] [docstring] [EOL] [EOL] if self . vars [ [string] ] : [EOL] if self . vars [ [string] ] [ [number] ] == [string] : [EOL] self . vars [ [string] ] = self . parse_command_for_scantree ( self . vars [ [string] ] ) [EOL] else : [EOL] if not context [ [string] ] : [EOL] self . vars [ [string] ] = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] else : [EOL] self . vars [ [string] ] = self . parse_command_for_scantree ( [ [string] , [string] , [string] ] ) [EOL] [EOL] context [ [string] ] = None [EOL] directory = context [ [string] ] [ [number] ] if len ( context [ [string] ] ) > [number] else context [ [string] ] [EOL] context [ [string] ] = abspath ( self . vim , directory ) [EOL] [EOL] def on_close ( self , context ) : [EOL] if context [ [string] ] : [EOL] context [ [string] ] . kill ( ) [EOL] context [ [string] ] = None [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] if not self . vars [ [string] ] : [EOL] return [ ] [EOL] [EOL] directory = context [ [string] ] [EOL] if not Path ( directory ) . is_dir ( ) : [EOL] return [ ] [EOL] [EOL] if context [ [string] ] and directory in self . _cache : [EOL] self . _cache . pop ( directory ) [EOL] if directory in self . _cache : [EOL] return self . _cache [ directory ] [EOL] [EOL] if context [ [string] ] : [EOL] return self . _async_gather_candidates ( context , context [ [string] ] ) [EOL] [EOL] if [string] in self . vars [ [string] ] : [EOL] args = parse_command ( self . vars [ [string] ] , directory = directory ) [EOL] else : [EOL] args = self . vars [ [string] ] + [ directory ] [EOL] if shutil . which ( args [ [number] ] ) is None : [EOL] self . error_message ( context , args [ [number] ] + [string] ) [EOL] return [ ] [EOL] self . print_message ( context , args ) [EOL] context [ [string] ] = Process ( args , context , directory ) [EOL] context [ [string] ] = [ ] [EOL] return self . _async_gather_candidates ( context , [number] ) [EOL] [EOL] def _async_gather_candidates ( self , context , timeout ) : [EOL] outs , errs = context [ [string] ] . communicate ( timeout = timeout ) [EOL] if errs : [EOL] self . error_message ( context , errs ) [EOL] if not context [ [string] ] : [EOL] return [ ] [EOL] [EOL] context [ [string] ] = not context [ [string] ] . eof ( ) [EOL] if context [ [string] ] . eof ( ) : [EOL] context [ [string] ] = None [EOL] if not outs : [EOL] return [ ] [EOL] directory = context [ [string] ] [EOL] if outs and Path ( outs [ [number] ] ) . is_absolute ( ) : [EOL] candidates = [ { [string] : str ( Path ( x ) . relative_to ( directory ) ) , [string] : x , } for x in outs if x != [string] and directory in x ] [EOL] else : [EOL] candidates = [ { [string] : x , [string] : str ( Path ( directory ) . joinpath ( x ) ) , } for x in outs if x != [string] ] [EOL] context [ [string] ] += candidates [EOL] [EOL] threshold = int ( self . vars [ [string] ] ) [EOL] if ( not context [ [string] ] and threshold > [number] and len ( context [ [string] ] ) > threshold ) : [EOL] self . _cache [ directory ] = context [ [string] ] [EOL] [EOL] return candidates [EOL] [EOL] def parse_command_for_scantree ( self , cmd ) : [EOL] [docstring] [EOL] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , type = str , default = None ) [EOL] parser . add_argument ( [string] , type = str , default = None ) [EOL] [EOL] [comment] [EOL] ( args , rest ) = parser . parse_known_args ( cmd [ [number] : ] if cmd and cmd [ [number] ] == [string] else cmd ) [EOL] if args . ignore is None : [EOL] ignore = self . vim . options [ [string] ] [EOL] else : [EOL] ignore = args . ignore [EOL] if args . path is None : [EOL] path = [string] [EOL] else : [EOL] path = args . path [EOL] [EOL] scantree_py = Path ( __file__ ) . parent . parent . parent . joinpath ( [string] ) [EOL] [EOL] return [ get_python_exe ( ) , str ( scantree_py ) , [string] , ignore , [string] , path , * rest ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 $denite.util.Candidates$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 $typing.Any$ 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 $typing.Any$ 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $denite.util.Candidates$ 0 0 0 $denite.util.UserContext$ 0 $builtins.float$ 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import denite [EOL] from denite . base . filter import Base as _Base [EOL] from denite . util import Nvim [EOL] [EOL] [EOL] class Base ( _Base ) : [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import denite [EOL] import math [EOL] [EOL] from denite . base . filter import Base [EOL] from denite . util import expand , Nvim , UserContext , Candidates [EOL] [EOL] [EOL] class Filter ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . description = [string] [EOL] [EOL] def on_init ( self , context ) : [EOL] [comment] [EOL] if self . vim . call ( [string] , [string] ) : [EOL] self . vim . command ( [string] ) [EOL] [EOL] def filter ( self , context ) : [EOL] oldfiles = { expand ( x ) : i for i , x in enumerate ( self . vim . call ( [string] ) ) } [EOL] return sorted ( context [ [string] ] , key = lambda x : oldfiles . get ( x [ [string] ] , math . inf ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.Candidates$ 0 0 0 $denite.util.UserContext$ 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import denite [EOL] from os . path import basename [EOL] from re import match [EOL] [EOL] from denite . base . filter import Base [EOL] from denite . util import Nvim , UserContext , Candidates [EOL] [EOL] [EOL] class Filter ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . description = [string] [EOL] [EOL] def filter ( self , context ) : [EOL] if [string] in context [ [string] ] : [EOL] return context [ [string] ] [comment] [EOL] [EOL] return [ x for x in context [ [string] ] if not match ( [string] , basename ( x [ [string] ] ) ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 0 0 0 0 $denite.util.Nvim$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $denite.util.Candidates$ 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.UserContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Any , Literal , Union [EOL] import typing_extensions [EOL] import typing [EOL] import denite [EOL] import builtins [EOL] import pathlib [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] from denite . base . filter import Base [EOL] from denite . util import Nvim , UserContext , Candidates , convert2fuzzy_pattern [EOL] [EOL] [EOL] class Filter ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . description = [string] [EOL] self . vars = { [string] : [string] , } [EOL] [EOL] self . _initialized = False [EOL] self . _disabled = False [EOL] [EOL] def filter ( self , context ) : [EOL] if not context [ [string] ] or not context [ [string] ] or self . _disabled or not self . vars [ [string] ] : [EOL] return context [ [string] ] [comment] [EOL] [EOL] if not self . _initialized : [EOL] [comment] [EOL] ext = [string] if context [ [string] ] else [string] [EOL] clap_path = Path ( [string] . format ( self . vars [ [string] ] , ext ) ) [EOL] if clap_path . exists ( ) : [EOL] [comment] [EOL] sys . path . append ( str ( clap_path . parent ) ) [EOL] self . _initialized = True [EOL] else : [EOL] self . error_message ( context , [string] + str ( clap_path ) + [string] ) [EOL] self . _disabled = True [EOL] return [ ] [EOL] [EOL] result = self . _get_clap_result ( context [ [string] ] , context [ [string] ] , context [ [string] ] ) [EOL] d = { x [ [string] ] : x for x in context [ [string] ] } [EOL] return [ d [ x ] for x in result [ [number] ] if x in d ] [EOL] [EOL] def convert_pattern ( self , input_str ) : [EOL] return convert2fuzzy_pattern ( input_str ) [EOL] [EOL] def _get_clap_result ( self , candidates , pattern , winwidth ) : [EOL] import fuzzymatch_rs [EOL] return fuzzymatch_rs . fuzzy_match ( pattern , tuple ( ( d [ [string] ] for d in candidates ) ) , winwidth , False , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $denite.util.Candidates$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $denite.util.Candidates$ 0 0 0 $denite.util.Candidates$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $denite.util.Candidates$ 0 0 0 $builtins.int$ 0 0 0 0 0 0
import os [EOL] import sys [EOL] [EOL] BASE_DIR = os . path . dirname ( os . path . dirname ( __file__ ) ) [EOL] sys . path . insert ( [number] , os . path . join ( BASE_DIR , [string] ) ) [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import os [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] import denite . util as util [EOL] [EOL] [EOL] def test_convert2fuzzy_pattern ( ) : [EOL] assert util . convert2fuzzy_pattern ( [string] ) == [string] [EOL] assert util . convert2fuzzy_pattern ( [string] ) == [string] [EOL] [EOL] [EOL] def test_convert2regex_pattern ( ) : [EOL] assert util . convert2regex_pattern ( [string] ) == [string] [EOL] assert util . convert2regex_pattern ( [string] ) == [string] [EOL] [EOL] def test_regex_convert_py_vim ( ) : [EOL] assert util . regex_convert_py_vim ( [string] ) == [string] [EOL] assert util . regex_convert_py_vim ( [string] ) == [string] [EOL] [EOL] def test_regex_convert_str_vim ( ) : [EOL] assert util . regex_convert_str_vim ( [string] ) == [string] [EOL] [EOL] def test_parse_jump_line ( ) : [EOL] assert util . parse_jump_line ( [string] , [string] ) == [ ] [EOL] assert util . parse_jump_line ( [string] , [string] ) == [ [string] , [string] , [string] , [string] ] [EOL] assert util . parse_jump_line ( [string] , [string] ) == [ [string] , [string] , [string] , [string] ] [EOL] assert util . parse_jump_line ( [string] , [string] ) == [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def test_parse_tag_line ( ) : [EOL] assert util . parse_tagline ( [string] , [string] ) == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert util . parse_tagline ( [string] , [string] ) == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert util . parse_tagline ( [string] , [string] ) == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert util . parse_tagline ( [string] , [string] ) == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert util . parse_tagline ( [string] , [string] ) == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert util . parse_tagline ( [string] , [string] ) == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] @ patch ( [string] ) def test_find_rplugins_kind ( walk ) : [EOL] walk . side_effect = _walk_side_effect [EOL] [EOL] context = { [string] : [string] } [EOL] source = [string] [EOL] prefix = os . path . normpath ( [string] % source ) [EOL] loaded_paths = [ os . path . normpath ( x % prefix ) for x in ( [string] , [string] , [string] , [string] , [string] , [string] , ) ] [EOL] [EOL] it = util . find_rplugins ( context , source , loaded_paths ) [EOL] walk . assert_not_called ( ) [EOL] [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] walk . assert_called_once_with ( os . path . normpath ( [string] % prefix ) , ) [EOL] walk . reset_mock ( ) [EOL] [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] assert next ( it ) == ( [string] % prefix , [string] ) [EOL] walk . assert_called_once_with ( os . path . normpath ( [string] % prefix ) , ) [EOL] walk . reset_mock ( ) [EOL] [EOL] with pytest . raises ( StopIteration ) : [EOL] next ( it ) [EOL] walk . assert_not_called ( ) [EOL] [EOL] [EOL] def _walk_side_effect ( top , topdown = True , onerror = None , followlinks = False ) : [EOL] yield ( top , [ [string] ] , [ [string] , [string] , [string] , [string] ] , ) [EOL] yield ( os . path . join ( top , [string] ) , [ [string] ] , [ [string] , [string] , [string] , [string] ] , ) [EOL] yield ( os . path . join ( top , [string] , [string] ) , [ [string] ] , [ [string] , [string] , [string] , [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import warnings [EOL] import sys [EOL] [EOL] [EOL] def main ( argv ) : [EOL] if len ( argv ) != [number] : [EOL] exit ( [number] ) [EOL] [EOL] with open ( argv [ [number] ] ) as fp : [EOL] contents = fp . read ( ) [EOL] [EOL] exitcode = [number] [EOL] syntax_err = None [EOL] with warnings . catch_warnings ( record = True ) as wc : [EOL] try : [EOL] compile ( contents , argv [ [number] ] , [string] , [number] , [number] ) [EOL] except SyntaxError as exc : [EOL] syntax_err = exc [EOL] [EOL] [comment] [EOL] [comment] [EOL] for wm in wc : [EOL] print ( [string] % ( wm . filename , wm . lineno , wm . message , wm . category . __name__ ) ) [EOL] exitcode |= [number] [EOL] [EOL] [comment] [EOL] if syntax_err : [EOL] print ( [string] % ( syntax_err . filename , syntax_err . lineno , syntax_err . offset , syntax_err . msg , ) ) [EOL] exitcode |= [number] [EOL] return exitcode [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import pstats [EOL] from time import sleep [EOL] import cProfile [EOL] import pstats [EOL] [EOL] import vim [EOL] [EOL] def conque_profile ( ) : [EOL] [EOL] terminal = ConqueTerm_1 [EOL] [EOL] [comment] [EOL] conque_profile_idle ( terminal , [number] ) [EOL] [EOL] [comment] [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] conque_profile_idle ( terminal , [number] ) [EOL] terminal . write ( [string] ) [EOL] conque_profile_idle ( terminal , [number] ) [EOL] [EOL] [comment] [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] conque_profile_idle ( terminal , [number] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] conque_profile_idle ( terminal , [number] ) [EOL] [EOL] [comment] [EOL] terminal . write ( [string] ) [EOL] conque_profile_idle ( terminal , [number] ) [EOL] terminal . write ( [string] ) [EOL] conque_profile_idle ( terminal , [number] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] conque_profile_idle ( terminal , [number] ) [EOL] terminal . write ( [string] ) [EOL] terminal . write ( [string] ) [EOL] conque_profile_idle ( terminal , [number] ) [EOL] [EOL] [comment] [EOL] conque_profile_idle ( terminal , [number] ) [EOL] [EOL] [EOL] [EOL] def conque_profile_idle ( terminal , seconds ) : [EOL] [EOL] loops = seconds * [number] [EOL] [EOL] for i in range ( [number] , int ( loops ) ) : [EOL] terminal . auto_read ( ) [EOL] sleep ( [number] ) [EOL] [EOL] [EOL] cProfile . run ( [string] , [string] ) [EOL] p = pstats . Stats ( [string] ) [EOL] p . sort_stats ( [string] ) . print_stats ( [number] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pstats.Stats$ 0 0 0 0 0 0 0 0 $pstats.Stats$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import time [EOL] import sys [EOL] [EOL] from conque_globals import * [EOL] from conque_win32_util import * [EOL] from conque_sole_subprocess import * [EOL] from conque_sole_shared_memory import * [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] [comment] [EOL] try : [EOL] [EOL] [comment] [EOL] logging . debug ( str ( sys . argv ) ) [EOL] if len ( sys . argv ) < [number] : [EOL] logging . info ( [string] ) [EOL] exit ( ) [EOL] [EOL] [comment] [EOL] max_loops = [number] [EOL] [EOL] [comment] [EOL] sleep_time = [number] [EOL] [EOL] [comment] [EOL] idle_sleep_time = [number] [EOL] [EOL] [comment] [EOL] is_idle = False [EOL] [EOL] [comment] [EOL] mem_key = sys . argv [ [number] ] [EOL] [EOL] [comment] [EOL] console_width = int ( sys . argv [ [number] ] ) [EOL] [EOL] [comment] [EOL] console_height = int ( sys . argv [ [number] ] ) [EOL] [EOL] [comment] [EOL] code_page = int ( sys . argv [ [number] ] ) [EOL] [EOL] [comment] [EOL] fast_mode = int ( sys . argv [ [number] ] ) [EOL] [EOL] [comment] [EOL] cmd_line = [string] . join ( sys . argv [ [number] : ] ) [EOL] logging . info ( [string] + cmd_line ) [EOL] [EOL] [comment] [EOL] options = { [string] : console_height , [string] : console_width , [string] : code_page , [string] : fast_mode } [EOL] [EOL] logging . info ( [string] + str ( options ) ) [EOL] [EOL] [comment] [EOL] shm_command = ConqueSoleSharedMemory ( CONQUE_SOLE_COMMANDS_SIZE , [string] , mem_key , serialize = True ) [EOL] shm_command . create ( [string] ) [EOL] [EOL] cmd = shm_command . read ( ) [EOL] if cmd : [EOL] logging . info ( [string] ) [EOL] if cmd [ [string] ] == [string] : [EOL] is_idle = True [EOL] shm_command . clear ( ) [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] proc = ConqueSoleSubprocess ( ) [EOL] res = proc . open ( cmd_line , mem_key , options ) [EOL] [EOL] if not res : [EOL] logging . info ( [string] ) [EOL] exit ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] loops = [number] [EOL] [EOL] while True : [EOL] [EOL] [comment] [EOL] if is_idle or loops % [number] == [number] : [EOL] [EOL] [comment] [EOL] if not proc . is_alive ( ) : [EOL] logging . info ( [string] ) [EOL] proc . close ( ) [EOL] break [EOL] [EOL] [comment] [EOL] cmd = shm_command . read ( ) [EOL] if cmd : [EOL] logging . info ( [string] ) [EOL] if cmd [ [string] ] == [string] : [EOL] is_idle = True [EOL] shm_command . clear ( ) [EOL] logging . info ( [string] ) [EOL] elif cmd [ [string] ] == [string] : [EOL] is_idle = False [EOL] shm_command . clear ( ) [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] if sleep_time > [number] : [EOL] if is_idle : [EOL] time . sleep ( idle_sleep_time ) [EOL] else : [EOL] time . sleep ( sleep_time ) [EOL] [EOL] [comment] [EOL] proc . write ( ) [EOL] proc . read ( ) [EOL] [EOL] [comment] [EOL] loops += [number] [EOL] if max_loops and loops >= max_loops : [EOL] logging . debug ( [string] ) [EOL] break [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] logging . debug ( proc . get_screen_text ( ) ) [EOL] [EOL] proc . close ( ) [EOL] [EOL] [comment] [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] proc . close ( ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Type , Any , Union [EOL] import typing [EOL] import pack [EOL] [docstring] [EOL] [EOL] import mmap [EOL] import sys [EOL] [EOL] [comment] [EOL] CONQUE_PYTHON_VERSION = sys . version_info [ [number] ] [EOL] [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] import cPickle as pickle [EOL] else : [EOL] import pickle [EOL] [EOL] [EOL] class ConqueSoleSharedMemory ( ) : [EOL] [EOL] [comment] [EOL] fixed_length = False [EOL] [EOL] [comment] [EOL] char_width = [number] [EOL] [EOL] [comment] [EOL] FILL_CHAR = None [EOL] [EOL] [comment] [EOL] serialize = False [EOL] [EOL] [comment] [EOL] mem_size = None [EOL] [EOL] [comment] [EOL] mem_type = None [EOL] [EOL] [comment] [EOL] mem_key = None [EOL] [EOL] [comment] [EOL] shm = None [EOL] [EOL] [comment] [EOL] encoding = [string] [EOL] [EOL] [comment] [EOL] TERMINATOR = None [EOL] [EOL] [EOL] def __init__ ( self , mem_size , mem_type , mem_key , fixed_length = False , fill_char = [string] , serialize = False , encoding = [string] ) : [EOL] [docstring] [EOL] self . mem_size = mem_size [EOL] self . mem_type = mem_type [EOL] self . mem_key = mem_key [EOL] self . fixed_length = fixed_length [EOL] self . fill_char = fill_char [EOL] self . serialize = serialize [EOL] self . encoding = encoding [EOL] self . TERMINATOR = str ( chr ( [number] ) ) . encode ( self . encoding ) [EOL] [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] self . FILL_CHAR = fill_char [EOL] else : [EOL] self . FILL_CHAR = unicode ( fill_char ) [EOL] [EOL] if fixed_length and encoding == [string] : [EOL] self . char_width = [number] [EOL] [EOL] [EOL] def create ( self , access = [string] ) : [EOL] [docstring] [EOL] [EOL] if access == [string] : [EOL] mmap_access = mmap . ACCESS_WRITE [EOL] else : [EOL] mmap_access = mmap . ACCESS_READ [EOL] [EOL] name = [string] % ( self . mem_type , self . mem_key ) [EOL] [EOL] self . shm = mmap . mmap ( [number] , self . mem_size * self . char_width , name , mmap_access ) [EOL] [EOL] if not self . shm : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] [EOL] def read ( self , chars = [number] , start = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] self . shm . seek ( start * self . char_width ) [EOL] [EOL] if self . fixed_length : [EOL] chars = chars * self . char_width [EOL] else : [EOL] chars = self . shm . find ( self . TERMINATOR ) [EOL] [EOL] if chars == [number] : [EOL] return [string] [EOL] [EOL] shm_str = self . shm . read ( chars ) [EOL] [EOL] [comment] [EOL] if self . serialize : [EOL] return pickle . loads ( shm_str ) [EOL] [EOL] [comment] [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] return str ( shm_str , self . encoding ) [EOL] [EOL] [comment] [EOL] if self . encoding != [string] : [EOL] shm_str = unicode ( shm_str , self . encoding ) [EOL] [EOL] return shm_str [EOL] [EOL] [EOL] def write ( self , text , start = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . serialize : [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] tb = pickle . dumps ( text , [number] ) [EOL] else : [EOL] tb = pickle . dumps ( text , [number] ) . encode ( self . encoding ) [EOL] [EOL] else : [EOL] tb = text . encode ( self . encoding , [string] ) [EOL] [EOL] [comment] [EOL] self . shm . seek ( start * self . char_width ) [EOL] [EOL] if self . fixed_length : [EOL] self . shm . write ( tb ) [EOL] else : [EOL] self . shm . write ( tb + self . TERMINATOR ) [EOL] [EOL] [EOL] def clear ( self , start = [number] ) : [EOL] [docstring] [EOL] [EOL] self . shm . seek ( start ) [EOL] [EOL] if self . fixed_length : [EOL] self . shm . write ( str ( self . fill_char * self . mem_size * self . char_width ) . encode ( self . encoding ) ) [EOL] else : [EOL] self . shm . write ( self . TERMINATOR ) [EOL] [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] [EOL] self . shm . close ( ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Type , Any [EOL] import typing [EOL] import pack [EOL] [docstring] [EOL] [EOL] import vim [EOL] [EOL] [EOL] class ConqueScreen ( object ) : [EOL] [EOL] [comment] [EOL] buffer = None [EOL] [EOL] [comment] [EOL] screen_top = [number] [EOL] [EOL] [comment] [EOL] screen_width = [number] [EOL] screen_height = [number] [EOL] [EOL] [comment] [EOL] screen_encoding = [string] [EOL] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] self . buffer = vim . current . buffer [EOL] [EOL] [comment] [EOL] self . screen_top = [number] [EOL] self . screen_width = vim . current . window . width [EOL] self . screen_height = vim . current . window . height [EOL] [EOL] [comment] [EOL] self . screen_encoding = vim . eval ( [string] ) [EOL] [EOL] [EOL] def __len__ ( self ) : [EOL] [docstring] [EOL] return len ( self . buffer ) [EOL] [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] [docstring] [EOL] buffer_line = self . get_real_idx ( key ) [EOL] [EOL] [comment] [EOL] if buffer_line >= len ( self . buffer ) : [EOL] for i in range ( len ( self . buffer ) , buffer_line + [number] ) : [EOL] self . append ( [string] ) [EOL] [EOL] return u ( self . buffer [ buffer_line ] , [string] ) [EOL] [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] [docstring] [EOL] buffer_line = self . get_real_idx ( key ) [EOL] [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] val = value . encode ( self . screen_encoding ) [EOL] else : [EOL] [comment] [EOL] val = str ( value ) [EOL] [EOL] [comment] [EOL] if buffer_line == len ( self . buffer ) : [EOL] self . buffer . append ( val ) [EOL] else : [EOL] self . buffer [ buffer_line ] = val [EOL] [EOL] [EOL] def __delitem__ ( self , key ) : [EOL] [docstring] [EOL] del self . buffer [ self . screen_top + key - [number] ] [EOL] [EOL] [EOL] def append ( self , value ) : [EOL] [docstring] [EOL] [EOL] if len ( self . buffer ) > self . screen_top + self . screen_height - [number] : [EOL] self . buffer [ len ( self . buffer ) - [number] ] = value [EOL] else : [EOL] self . buffer . append ( value ) [EOL] [EOL] if len ( self . buffer ) > self . screen_top + self . screen_height - [number] : [EOL] self . screen_top += [number] [EOL] [EOL] if vim . current . buffer . number == self . buffer . number : [EOL] vim . command ( [string] ) [EOL] [EOL] [EOL] def insert ( self , line , value ) : [EOL] [docstring] [EOL] logging . debug ( [string] + str ( self . screen_top + line - [number] ) ) [EOL] l = self . screen_top + line - [number] [EOL] try : [EOL] self . buffer . append ( value , l ) [EOL] except : [EOL] self . buffer [ l : l ] = [ value ] [EOL] [EOL] [EOL] def get_top ( self ) : [EOL] [docstring] [EOL] return self . screen_top [EOL] [EOL] [EOL] def get_real_idx ( self , line ) : [EOL] [docstring] [EOL] return ( self . screen_top + line - [number] ) [EOL] [EOL] [EOL] def get_buffer_line ( self , line ) : [EOL] [docstring] [EOL] return ( self . screen_top + line - [number] ) [EOL] [EOL] [EOL] def set_screen_width ( self , width ) : [EOL] [docstring] [EOL] self . screen_width = width [EOL] [EOL] [EOL] def clear ( self ) : [EOL] [docstring] [EOL] [EOL] self . screen_width = width [EOL] self . buffer . append ( [string] ) [EOL] vim . command ( [string] ) [EOL] self . screen_top = len ( self . buffer ) [EOL] [EOL] [EOL] def set_cursor ( self , line , column ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] buffer_line = self . screen_top + line - [number] [EOL] if buffer_line > len ( self . buffer ) : [EOL] for l in range ( len ( self . buffer ) - [number] , buffer_line ) : [EOL] self . buffer . append ( [string] ) [EOL] [EOL] [comment] [EOL] real_column = column [EOL] if len ( self . buffer [ buffer_line - [number] ] ) < real_column : [EOL] self . buffer [ buffer_line - [number] ] = self . buffer [ buffer_line - [number] ] + [string] * ( real_column - len ( self . buffer [ buffer_line - [number] ] ) ) [EOL] [EOL] if not CONQUE_FAST_MODE : [EOL] [comment] [EOL] vim . command ( [string] + str ( buffer_line ) + [string] + str ( buffer_line ) + [string] + str ( real_column ) + [string] ) [EOL] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] vim . current . window . cursor = ( buffer_line , real_column - [number] ) [EOL] except : [EOL] vim . command ( [string] + str ( buffer_line ) + [string] + str ( real_column ) + [string] ) [EOL] [EOL] [EOL] def reset_size ( self , line ) : [EOL] [docstring] [EOL] [EOL] logging . debug ( [string] + str ( len ( self . buffer ) ) ) [EOL] logging . debug ( [string] + str ( vim . current . window . height ) ) [EOL] logging . debug ( [string] + str ( self . screen_top ) ) [EOL] [EOL] [comment] [EOL] buffer_line = self . screen_top + line [EOL] [EOL] [comment] [EOL] self . screen_width = vim . current . window . width [EOL] self . screen_height = vim . current . window . height [EOL] self . screen_top = len ( self . buffer ) - vim . current . window . height + [number] [EOL] if self . screen_top < [number] : [EOL] self . screen_top = [number] [EOL] logging . debug ( [string] + str ( self . screen_top ) ) [EOL] [EOL] [comment] [EOL] vim . command ( [string] + str ( self . screen_height ) + [string] ) [EOL] [EOL] [comment] [EOL] return ( buffer_line - self . screen_top ) [EOL] [EOL] [EOL] def align ( self ) : [EOL] [docstring] [EOL] vim . command ( [string] + str ( self . screen_height ) + [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Type , Any , List [EOL] import typing [EOL] import pack [EOL] [docstring] [EOL] [EOL] import os [EOL] import signal [EOL] import pty [EOL] import tty [EOL] import select [EOL] import fcntl [EOL] import termios [EOL] import struct [EOL] import shlex [EOL] [EOL] [EOL] class ConqueSubprocess : [EOL] [EOL] [comment] [EOL] pid = [number] [EOL] [EOL] [comment] [EOL] fd = None [EOL] [EOL] [EOL] def open ( self , command , env = { } ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] command_arr = shlex . split ( command ) [EOL] executable = command_arr [ [number] ] [EOL] args = command_arr [EOL] [EOL] [comment] [EOL] try : [EOL] self . pid , self . fd = pty . fork ( ) [EOL] logging . info ( self . pid ) [EOL] except : [EOL] logging . info ( [string] ) [EOL] return False [EOL] [EOL] [comment] [EOL] if self . pid == [number] : [EOL] [EOL] [comment] [EOL] for k in env . keys ( ) : [EOL] os . environ [ k ] = env [ k ] [EOL] [EOL] [comment] [EOL] try : [EOL] attrs = tty . tcgetattr ( [number] ) [EOL] attrs [ [number] ] = attrs [ [number] ] ^ tty . IGNBRK [EOL] attrs [ [number] ] = attrs [ [number] ] | tty . BRKINT | tty . IXANY | tty . IMAXBEL [EOL] attrs [ [number] ] = attrs [ [number] ] | tty . HUPCL [EOL] attrs [ [number] ] = attrs [ [number] ] | tty . ICANON | tty . ECHO | tty . ISIG | tty . ECHOKE [EOL] attrs [ [number] ] [ tty . VMIN ] = [number] [EOL] attrs [ [number] ] [ tty . VTIME ] = [number] [EOL] tty . tcsetattr ( [number] , tty . TCSANOW , attrs ) [EOL] except : [EOL] logging . info ( [string] ) [EOL] pass [EOL] [EOL] [comment] [EOL] os . execvp ( executable , args ) [EOL] [EOL] [comment] [EOL] else : [EOL] pass [EOL] [EOL] [EOL] def read ( self , timeout = [number] ) : [EOL] [docstring] [EOL] [EOL] output = [string] [EOL] read_timeout = float ( timeout ) / [number] [EOL] read_ct = [number] [EOL] [EOL] try : [EOL] [comment] [EOL] while [number] : [EOL] s_read , s_write , s_error = select . select ( [ self . fd ] , [ ] , [ ] , read_timeout ) [EOL] [EOL] lines = [string] [EOL] for s_fd in s_read : [EOL] try : [EOL] [comment] [EOL] if read_ct < [number] : [EOL] lines = os . read ( self . fd , [number] ) [EOL] elif read_ct < [number] : [EOL] lines = os . read ( self . fd , [number] ) [EOL] else : [EOL] lines = os . read ( self . fd , [number] ) [EOL] read_ct += [number] [EOL] except : [EOL] pass [EOL] output = output + lines . decode ( [string] ) [EOL] [EOL] if lines == [string] or read_ct > [number] : [EOL] break [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] [EOL] return output [EOL] [EOL] [EOL] def write ( self , input ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] os . write ( self . fd , input . encode ( [string] , [string] ) ) [EOL] else : [EOL] os . write ( self . fd , bytes ( input , [string] ) ) [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] [EOL] [EOL] def signal ( self , signum ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] os . kill ( self . pid , signum ) [EOL] except : [EOL] pass [EOL] [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] [EOL] self . signal ( [number] ) [EOL] [EOL] [EOL] def is_alive ( self ) : [EOL] [docstring] [EOL] [EOL] p_status = True [EOL] try : [EOL] if os . waitpid ( self . pid , os . WNOHANG ) [ [number] ] : [EOL] p_status = False [EOL] except : [EOL] p_status = False [EOL] [EOL] return p_status [EOL] [EOL] [EOL] def window_resize ( self , lines , columns ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] fcntl . ioctl ( self . fd , termios . TIOCSWINSZ , struct . pack ( [string] , lines , columns , [number] , [number] ) ) [EOL] os . kill ( self . pid , signal . SIGWINCH ) [EOL] except : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Type , Any , Dict , List [EOL] import typing [EOL] import pack [EOL] [docstring] [EOL] [EOL] import vim [EOL] import re [EOL] import math [EOL] import time [comment] [EOL] [EOL] class Conque : [EOL] [EOL] [comment] [EOL] screen = None [EOL] [EOL] [comment] [EOL] proc = None [EOL] [EOL] [comment] [EOL] columns = [number] [comment] [EOL] lines = [number] [comment] [EOL] working_columns = [number] [comment] [EOL] working_lines = [number] [comment] [EOL] [EOL] [comment] [EOL] top = [number] [comment] [EOL] bottom = [number] [comment] [EOL] [EOL] [comment] [EOL] l = [number] [comment] [EOL] c = [number] [comment] [EOL] [EOL] [comment] [EOL] autowrap = True [EOL] [EOL] [comment] [EOL] absolute_coords = True [EOL] [EOL] [comment] [EOL] tabstops = [ ] [EOL] [EOL] [comment] [EOL] enable_colors = True [EOL] [EOL] [comment] [EOL] color_changes = { } [EOL] [EOL] [comment] [EOL] color_history = { } [EOL] [EOL] [comment] [EOL] highlight_groups = { } [EOL] [EOL] [comment] [EOL] color_pruning = True [EOL] [EOL] [comment] [EOL] unwrap_tables = True [EOL] [EOL] [comment] [EOL] wrap_cursor = False [EOL] [EOL] [comment] [EOL] cursor_set = False [EOL] [EOL] [comment] [EOL] character_set = [string] [EOL] [EOL] [comment] [EOL] read_count = [number] [EOL] [EOL] [comment] [EOL] input_buffer = [ ] [EOL] [EOL] def open ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] command = vim . eval ( [string] ) [EOL] options = vim . eval ( [string] ) [EOL] [EOL] [comment] [EOL] self . screen = ConqueScreen ( ) [EOL] [EOL] [comment] [EOL] self . columns = vim . current . window . width [EOL] self . lines = vim . current . window . height [EOL] self . working_columns = vim . current . window . width [EOL] self . working_lines = vim . current . window . height [EOL] self . bottom = vim . current . window . height [EOL] [EOL] [comment] [EOL] if int ( options [ [string] ] ) > [number] : [EOL] self . l = int ( options [ [string] ] ) [EOL] [EOL] [comment] [EOL] self . enable_colors = options [ [string] ] and not CONQUE_FAST_MODE [EOL] [EOL] [comment] [EOL] self . init_tabstops ( ) [EOL] [EOL] [comment] [EOL] self . proc = ConqueSubprocess ( ) [EOL] self . proc . open ( command , { [string] : options [ [string] ] , [string] : [string] , [string] : str ( self . lines ) , [string] : str ( self . columns ) } ) [EOL] [EOL] [comment] [EOL] self . update_window_size ( True ) [EOL] [EOL] [EOL] def write ( self , input , set_cursor = True , read = True ) : [EOL] [docstring] [EOL] [comment] [EOL] self . proc . write ( input ) [EOL] [EOL] [comment] [EOL] if read : [EOL] self . read ( [number] , set_cursor ) [EOL] [EOL] [EOL] [EOL] def write_ord ( self , input , set_cursor = True , read = True ) : [EOL] [docstring] [EOL] [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] self . write ( unichr ( input ) , set_cursor , read ) [EOL] else : [EOL] self . write ( chr ( input ) , set_cursor , read ) [EOL] [EOL] [EOL] [EOL] def write_expr ( self , expr , set_cursor = True , read = True ) : [EOL] [docstring] [EOL] [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] try : [EOL] val = vim . eval ( expr ) [EOL] self . write ( unicode ( val , CONQUE_VIM_ENCODING , [string] ) , set_cursor , read ) [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] else : [EOL] try : [EOL] [comment] [EOL] self . write ( vim . eval ( expr ) , set_cursor , read ) [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] [EOL] [EOL] def write_latin1 ( self , input , set_cursor = True , read = True ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] try : [EOL] input_unicode = input . decode ( [string] , [string] ) [EOL] self . write ( input_unicode . encode ( [string] , [string] ) , set_cursor , read ) [EOL] except : [EOL] return [EOL] else : [EOL] self . write ( input , set_cursor , read ) [EOL] [EOL] [EOL] def write_buffered_ord ( self , chr ) : [EOL] [docstring] [EOL] self . input_buffer . append ( chr ) [EOL] [EOL] [EOL] def read ( self , timeout = [number] , set_cursor = True , return_output = False , update_buffer = True ) : [EOL] [docstring] [EOL] output = [string] [EOL] [EOL] [comment] [EOL] try : [EOL] [EOL] [comment] [EOL] output = self . proc . read ( timeout ) [EOL] [EOL] if output == [string] : [EOL] return [EOL] [EOL] [comment] [EOL] if not update_buffer : [EOL] return output [EOL] [EOL] logging . debug ( output ) [EOL] [EOL] [comment] [EOL] output = output . replace ( chr ( [number] ) , [string] ) [EOL] [EOL] [comment] [EOL] chunks = CONQUE_SEQ_REGEX . split ( output ) [EOL] [EOL] logging . debug ( str ( chunks ) ) [EOL] [EOL] [comment] [EOL] if len ( chunks ) == [number] : [EOL] self . plain_text ( chunks [ [number] ] ) [EOL] [EOL] [comment] [EOL] else : [EOL] for s in chunks : [EOL] if s == [string] : [EOL] continue [EOL] [EOL] [comment] [EOL] logging . debug ( [string] + str ( self . l ) + [string] + str ( self . c ) ) [EOL] [EOL] [comment] [EOL] if CONQUE_SEQ_REGEX_CTL . match ( s [ [number] ] ) : [EOL] logging . debug ( [string] ) [EOL] nr = ord ( s [ [number] ] ) [EOL] if nr in CONQUE_CTL : [EOL] getattr ( self , [string] + CONQUE_CTL [ nr ] ) ( ) [EOL] else : [EOL] logging . info ( [string] + str ( s ) ) [EOL] pass [EOL] [EOL] [comment] [EOL] elif CONQUE_SEQ_REGEX_CSI . match ( s ) : [EOL] logging . debug ( [string] ) [EOL] if s [ - [number] ] in CONQUE_ESCAPE : [EOL] csi = self . parse_csi ( s [ [number] : ] ) [EOL] logging . debug ( str ( csi ) ) [EOL] getattr ( self , [string] + CONQUE_ESCAPE [ s [ - [number] ] ] ) ( csi ) [EOL] else : [EOL] logging . info ( [string] + str ( s ) ) [EOL] pass [EOL] [EOL] [comment] [EOL] elif CONQUE_SEQ_REGEX_TITLE . match ( s ) : [EOL] logging . debug ( [string] ) [EOL] self . change_title ( s [ [number] ] , s [ [number] : - [number] ] ) [EOL] [EOL] [comment] [EOL] elif CONQUE_SEQ_REGEX_HASH . match ( s ) : [EOL] logging . debug ( [string] ) [EOL] if s [ - [number] ] in CONQUE_ESCAPE_HASH : [EOL] getattr ( self , [string] + CONQUE_ESCAPE_HASH [ s [ - [number] ] ] ) ( ) [EOL] else : [EOL] logging . info ( [string] + str ( s ) ) [EOL] pass [EOL] [EOL] [comment] [EOL] elif CONQUE_SEQ_REGEX_CHAR . match ( s ) : [EOL] logging . debug ( [string] ) [EOL] if s [ - [number] ] in CONQUE_ESCAPE_CHARSET : [EOL] getattr ( self , [string] + CONQUE_ESCAPE_CHARSET [ s [ - [number] ] ] ) ( ) [EOL] else : [EOL] logging . info ( [string] + str ( s ) ) [EOL] pass [EOL] [EOL] [comment] [EOL] elif CONQUE_SEQ_REGEX_ESC . match ( s ) : [EOL] logging . debug ( [string] ) [EOL] if s [ - [number] ] in CONQUE_ESCAPE_PLAIN : [EOL] getattr ( self , [string] + CONQUE_ESCAPE_PLAIN [ s [ - [number] ] ] ) ( ) [EOL] else : [EOL] logging . info ( [string] + str ( s ) ) [EOL] pass [EOL] [EOL] [comment] [EOL] else : [EOL] self . plain_text ( s ) [EOL] [EOL] [comment] [EOL] if set_cursor : [EOL] self . screen . set_cursor ( self . l , self . c ) [EOL] [EOL] [comment] [EOL] self . cursor_set = False [EOL] [EOL] except : [EOL] logging . info ( [string] ) [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] [EOL] if return_output : [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] return output [EOL] else : [EOL] return output . encode ( CONQUE_VIM_ENCODING , [string] ) [EOL] [EOL] [EOL] def auto_read ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if len ( self . input_buffer ) : [EOL] for chr in self . input_buffer : [EOL] self . write_ord ( chr , set_cursor = False , read = False ) [EOL] self . input_buffer = [ ] [EOL] self . read ( [number] ) [EOL] [EOL] [comment] [EOL] if self . read_count % [number] == [number] : [EOL] if not self . proc . is_alive ( ) : [EOL] vim . command ( [string] ) [EOL] return [EOL] [EOL] if self . read_count > [number] : [EOL] self . read_count = [number] [EOL] [EOL] [comment] [EOL] if self . enable_colors and self . color_pruning : [EOL] self . prune_colors ( ) [EOL] [EOL] [comment] [EOL] self . read_count += [number] [EOL] [EOL] [comment] [EOL] self . read ( [number] ) [EOL] [EOL] [comment] [EOL] if self . c == [number] : [EOL] vim . command ( [string] ) [EOL] else : [EOL] vim . command ( [string] ) [EOL] [EOL] [comment] [EOL] if self . cursor_set : [EOL] return [EOL] [EOL] [comment] [EOL] if not CONQUE_FAST_MODE : [EOL] self . update_window_size ( ) [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] self . set_cursor ( self . l , self . c ) [EOL] except : [EOL] logging . info ( [string] ) [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] [EOL] self . cursor_set = True [EOL] [EOL] [EOL] def plain_text ( self , input ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . character_set == [string] : [EOL] old_input = input [EOL] input = u ( [string] ) [EOL] for i in range ( [number] , len ( old_input ) ) : [EOL] chrd = ord ( old_input [ i ] ) [EOL] logging . debug ( [string] + old_input [ i ] ) [EOL] logging . debug ( [string] + str ( chrd ) ) [EOL] try : [EOL] if chrd > [number] : [EOL] logging . info ( [string] ) [EOL] input = input + old_input [ i ] [EOL] else : [EOL] input = input + uchr ( CONQUE_GRAPHICS_SET [ chrd ] ) [EOL] except : [EOL] logging . info ( [string] ) [EOL] pass [EOL] [EOL] logging . debug ( [string] + str ( self . color_changes ) ) [EOL] [EOL] [comment] [EOL] current_line = self . screen [ self . l ] [EOL] [EOL] [comment] [EOL] if len ( current_line ) < self . c : [EOL] current_line = current_line + [string] * ( self . c - len ( current_line ) ) [EOL] [EOL] [comment] [EOL] if self . c + len ( input ) - [number] > self . working_columns : [EOL] [EOL] [comment] [EOL] if self . unwrap_tables and CONQUE_TABLE_OUTPUT . match ( input ) : [EOL] self . screen [ self . l ] = current_line [ : self . c - [number] ] + input + current_line [ self . c + len ( input ) - [number] : ] [EOL] self . apply_color ( self . c , self . c + len ( input ) ) [EOL] self . c += len ( input ) [EOL] return [EOL] [EOL] logging . debug ( [string] ) [EOL] diff = self . c + len ( input ) - self . working_columns - [number] [EOL] [EOL] [comment] [EOL] if self . autowrap : [EOL] self . screen [ self . l ] = current_line [ : self . c - [number] ] + input [ : - [number] * diff ] [EOL] self . apply_color ( self . c , self . working_columns ) [EOL] self . ctl_nl ( ) [EOL] self . ctl_cr ( ) [EOL] remaining = input [ - [number] * diff : ] [EOL] logging . debug ( [string] + remaining + [string] ) [EOL] self . plain_text ( remaining ) [EOL] else : [EOL] self . screen [ self . l ] = current_line [ : self . c - [number] ] + input [ : - [number] * diff - [number] ] + input [ - [number] ] [EOL] self . apply_color ( self . c , self . working_columns ) [EOL] self . c = self . working_columns [EOL] [EOL] [comment] [EOL] else : [EOL] self . screen [ self . l ] = current_line [ : self . c - [number] ] + input + current_line [ self . c + len ( input ) - [number] : ] [EOL] self . apply_color ( self . c , self . c + len ( input ) ) [EOL] self . c += len ( input ) [EOL] [EOL] [EOL] [EOL] def apply_color ( self , start , end , line = [number] ) : [EOL] [docstring] [EOL] logging . debug ( [string] + str ( self . color_changes ) ) [EOL] [EOL] [comment] [EOL] if not self . enable_colors : [EOL] return [EOL] [EOL] [comment] [EOL] if line : [EOL] buffer_line = line [EOL] else : [EOL] buffer_line = self . get_buffer_line ( self . l ) [EOL] [EOL] [comment] [EOL] logging . debug ( [string] + str ( start ) + [string] + str ( end ) ) [EOL] to_del = [ ] [EOL] if buffer_line in self . color_history : [EOL] for i in range ( len ( self . color_history [ buffer_line ] ) ) : [EOL] syn = self . color_history [ buffer_line ] [ i ] [EOL] logging . debug ( [string] + str ( syn ) ) [EOL] if syn [ [string] ] >= start and syn [ [string] ] < end : [EOL] logging . debug ( [string] ) [EOL] vim . command ( [string] + syn [ [string] ] ) [EOL] to_del . append ( i ) [EOL] [comment] [EOL] if syn [ [string] ] > end : [EOL] logging . debug ( [string] ) [EOL] self . exec_highlight ( buffer_line , end , syn [ [string] ] , syn [ [string] ] ) [EOL] elif syn [ [string] ] > start and syn [ [string] ] <= end : [EOL] logging . debug ( [string] ) [EOL] vim . command ( [string] + syn [ [string] ] ) [EOL] to_del . append ( i ) [EOL] [comment] [EOL] if syn [ [string] ] < start : [EOL] logging . debug ( [string] ) [EOL] self . exec_highlight ( buffer_line , syn [ [string] ] , start , syn [ [string] ] ) [EOL] [EOL] [comment] [EOL] if len ( to_del ) > [number] : [EOL] to_del . reverse ( ) [EOL] for di in to_del : [EOL] del self . color_history [ buffer_line ] [ di ] [EOL] [EOL] [comment] [EOL] if len ( self . color_changes ) == [number] : [EOL] return [EOL] [EOL] [comment] [EOL] highlight = [string] [EOL] for attr in self . color_changes . keys ( ) : [EOL] highlight = highlight + [string] + attr + [string] + self . color_changes [ attr ] [EOL] [EOL] [comment] [EOL] self . exec_highlight ( buffer_line , start , end , highlight ) [EOL] [EOL] [EOL] def exec_highlight ( self , buffer_line , start , end , highlight ) : [EOL] [docstring] [EOL] [EOL] syntax_name = [string] % ( self . proc . pid , self . l , start , len ( self . color_history ) + [number] ) [EOL] syntax_options = [string] [EOL] syntax_region = [string] % ( syntax_name , buffer_line , start - [number] , end - start , end + [number] , syntax_options ) [EOL] [EOL] [comment] [EOL] hgroup = [string] % ( abs ( hash ( highlight ) ) ) [EOL] if hgroup not in self . highlight_groups : [EOL] syntax_group = [string] % ( hgroup , highlight ) [EOL] self . highlight_groups [ hgroup ] = hgroup [EOL] vim . command ( syntax_group ) [EOL] [EOL] [comment] [EOL] syntax_highlight = [string] % ( syntax_name , self . highlight_groups [ hgroup ] ) [EOL] [EOL] logging . debug ( syntax_region ) [EOL] [EOL] vim . command ( syntax_region ) [EOL] vim . command ( syntax_highlight ) [EOL] [EOL] [comment] [EOL] if not buffer_line in self . color_history : [EOL] self . color_history [ buffer_line ] = [ ] [EOL] [EOL] self . color_history [ buffer_line ] . append ( { [string] : syntax_name , [string] : start , [string] : end , [string] : highlight } ) [EOL] [EOL] [EOL] def prune_colors ( self ) : [EOL] [docstring] [EOL] logging . info ( [string] + str ( len ( self . color_history . keys ( ) ) ) ) [EOL] [EOL] buffer_line = self . get_buffer_line ( self . l ) [EOL] ks = list ( self . color_history . keys ( ) ) [EOL] [EOL] for line in ks : [EOL] if line < buffer_line - CONQUE_MAX_SYNTAX_LINES : [EOL] for syn in self . color_history [ line ] : [EOL] vim . command ( [string] + syn [ [string] ] ) [EOL] del self . color_history [ line ] [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def ctl_nl ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . lines != self . working_lines and self . l == self . bottom : [EOL] del self . screen [ self . top ] [EOL] self . screen . insert ( self . bottom , [string] ) [EOL] elif self . l == self . bottom : [EOL] self . screen . append ( [string] ) [EOL] else : [EOL] self . l += [number] [EOL] [EOL] self . color_changes = { } [EOL] [EOL] def ctl_cr ( self ) : [EOL] [docstring] [EOL] self . c = [number] [EOL] [EOL] self . color_changes = { } [EOL] [EOL] def ctl_bs ( self ) : [EOL] [docstring] [EOL] if self . c > [number] : [EOL] self . c += - [number] [EOL] [EOL] def ctl_soh ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def ctl_stx ( self ) : [EOL] pass [EOL] [EOL] def ctl_bel ( self ) : [EOL] [docstring] [EOL] vim . command ( [string] ) [EOL] [EOL] def ctl_tab ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] ts = self . working_columns [EOL] [EOL] [comment] [EOL] for i in range ( self . c , len ( self . tabstops ) ) : [EOL] if self . tabstops [ i ] : [EOL] ts = i + [number] [EOL] break [EOL] [EOL] logging . debug ( [string] + str ( self . c ) + [string] + str ( ts ) ) [EOL] [EOL] self . c = ts [EOL] [EOL] def ctl_so ( self ) : [EOL] [docstring] [EOL] self . character_set = [string] [EOL] [EOL] def ctl_si ( self ) : [EOL] [docstring] [EOL] self . character_set = [string] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def csi_font ( self , csi ) : [EOL] [docstring] [EOL] if not self . enable_colors : [EOL] return [EOL] [EOL] [comment] [EOL] if len ( csi [ [string] ] ) == [number] : [EOL] csi [ [string] ] = [ [number] ] [EOL] [EOL] [comment] [EOL] if len ( csi [ [string] ] ) == [number] and csi [ [string] ] [ [number] ] == [number] and csi [ [string] ] [ [number] ] == [number] : [EOL] self . color_changes [ [string] ] = str ( csi [ [string] ] [ [number] ] ) [EOL] self . color_changes [ [string] ] = [string] + self . xterm_to_rgb ( csi [ [string] ] [ [number] ] ) [EOL] [EOL] [comment] [EOL] elif len ( csi [ [string] ] ) == [number] and csi [ [string] ] [ [number] ] == [number] and csi [ [string] ] [ [number] ] == [number] : [EOL] self . color_changes [ [string] ] = str ( csi [ [string] ] [ [number] ] ) [EOL] self . color_changes [ [string] ] = [string] + self . xterm_to_rgb ( csi [ [string] ] [ [number] ] ) [EOL] [EOL] [comment] [EOL] else : [EOL] for val in csi [ [string] ] : [EOL] if val in CONQUE_FONT : [EOL] logging . debug ( [string] + str ( CONQUE_FONT [ val ] ) ) [EOL] [comment] [EOL] if CONQUE_FONT [ val ] [ [string] ] and len ( self . color_changes ) == [number] : [EOL] logging . debug ( [string] ) [EOL] continue [EOL] [comment] [EOL] elif CONQUE_FONT [ val ] [ [string] ] : [EOL] logging . debug ( [string] ) [EOL] self . color_changes = { } [EOL] [comment] [EOL] else : [EOL] logging . debug ( [string] ) [EOL] for attr in CONQUE_FONT [ val ] [ [string] ] . keys ( ) : [EOL] if attr in self . color_changes and ( attr == [string] or attr == [string] ) : [EOL] self . color_changes [ attr ] += [string] + CONQUE_FONT [ val ] [ [string] ] [ attr ] [EOL] else : [EOL] self . color_changes [ attr ] = CONQUE_FONT [ val ] [ [string] ] [ attr ] [EOL] [EOL] [EOL] def csi_clear_line ( self , csi ) : [EOL] [docstring] [EOL] logging . debug ( str ( csi ) ) [EOL] [EOL] [comment] [EOL] if len ( csi [ [string] ] ) == [number] : [EOL] csi [ [string] ] = [number] [EOL] [EOL] logging . debug ( [string] + str ( csi [ [string] ] ) ) [EOL] logging . debug ( [string] + self . screen [ self . l ] ) [EOL] [EOL] [comment] [EOL] if csi [ [string] ] == [number] : [EOL] self . screen [ self . l ] = self . screen [ self . l ] [ [number] : self . c - [number] ] [EOL] [EOL] [comment] [EOL] elif csi [ [string] ] == [number] : [EOL] self . screen [ self . l ] = [string] * ( self . c ) + self . screen [ self . l ] [ self . c : ] [EOL] [EOL] [comment] [EOL] elif csi [ [string] ] == [number] : [EOL] self . screen [ self . l ] = [string] [EOL] [EOL] [comment] [EOL] if csi [ [string] ] == [number] or ( csi [ [string] ] == [number] and self . c == [number] ) : [EOL] buffer_line = self . get_buffer_line ( self . l ) [EOL] if buffer_line in self . color_history : [EOL] for syn in self . color_history [ buffer_line ] : [EOL] vim . command ( [string] + syn [ [string] ] ) [EOL] [EOL] logging . debug ( str ( self . color_changes ) ) [EOL] logging . debug ( [string] + self . screen [ self . l ] ) [EOL] [EOL] [EOL] def csi_cursor_right ( self , csi ) : [EOL] [docstring] [EOL] [comment] [EOL] if csi [ [string] ] == [number] : [EOL] csi [ [string] ] = [number] [EOL] [EOL] logging . debug ( [string] + str ( self . working_columns ) ) [EOL] logging . debug ( [string] + str ( self . c + csi [ [string] ] ) ) [EOL] [EOL] if self . wrap_cursor and self . c + csi [ [string] ] > self . working_columns : [EOL] self . l += int ( math . floor ( ( self . c + csi [ [string] ] ) / self . working_columns ) ) [EOL] self . c = ( self . c + csi [ [string] ] ) % self . working_columns [EOL] return [EOL] [EOL] self . c = self . bound ( self . c + csi [ [string] ] , [number] , self . working_columns ) [EOL] [EOL] [EOL] def csi_cursor_left ( self , csi ) : [EOL] [docstring] [EOL] [comment] [EOL] if csi [ [string] ] == [number] : [EOL] csi [ [string] ] = [number] [EOL] [EOL] if self . wrap_cursor and csi [ [string] ] >= self . c : [EOL] self . l += int ( math . floor ( ( self . c - csi [ [string] ] ) / self . working_columns ) ) [EOL] self . c = self . working_columns - ( csi [ [string] ] - self . c ) % self . working_columns [EOL] return [EOL] [EOL] self . c = self . bound ( self . c - csi [ [string] ] , [number] , self . working_columns ) [EOL] [EOL] [EOL] def csi_cursor_to_column ( self , csi ) : [EOL] [docstring] [EOL] self . c = self . bound ( csi [ [string] ] , [number] , self . working_columns ) [EOL] [EOL] [EOL] def csi_cursor_up ( self , csi ) : [EOL] [docstring] [EOL] self . l = self . bound ( self . l - csi [ [string] ] , self . top , self . bottom ) [EOL] [EOL] self . color_changes = { } [EOL] [EOL] [EOL] def csi_cursor_down ( self , csi ) : [EOL] [docstring] [EOL] self . l = self . bound ( self . l + csi [ [string] ] , self . top , self . bottom ) [EOL] [EOL] self . color_changes = { } [EOL] [EOL] [EOL] def csi_clear_screen ( self , csi ) : [EOL] [docstring] [EOL] [comment] [EOL] if len ( csi [ [string] ] ) == [number] : [EOL] csi [ [string] ] = [number] [EOL] [EOL] [comment] [EOL] if csi [ [string] ] == [number] : [EOL] self . l = [number] [EOL] self . c = [number] [EOL] self . screen . clear ( ) [EOL] [EOL] [comment] [EOL] elif csi [ [string] ] == [number] : [EOL] for l in range ( self . bound ( self . l + [number] , [number] , self . lines ) , self . lines + [number] ) : [EOL] self . screen [ l ] = [string] [EOL] [EOL] [comment] [EOL] self . csi_clear_line ( self . parse_csi ( [string] ) ) [EOL] [EOL] [comment] [EOL] elif csi [ [string] ] == [number] : [EOL] for l in range ( [number] , self . bound ( self . l , [number] , self . lines + [number] ) ) : [EOL] self . screen [ l ] = [string] [EOL] [EOL] [comment] [EOL] self . csi_clear_line ( self . parse_csi ( [string] ) ) [EOL] [EOL] [comment] [EOL] if csi [ [string] ] == [number] or csi [ [string] ] == [number] : [EOL] buffer_line = self . get_buffer_line ( self . l ) [EOL] for line in self . color_history . keys ( ) : [EOL] if line >= buffer_line : [EOL] for syn in self . color_history [ line ] : [EOL] vim . command ( [string] + syn [ [string] ] ) [EOL] [EOL] self . color_changes = { } [EOL] [EOL] [EOL] def csi_delete_chars ( self , csi ) : [EOL] self . screen [ self . l ] = self . screen [ self . l ] [ : self . c ] + self . screen [ self . l ] [ self . c + csi [ [string] ] : ] [EOL] [EOL] [EOL] def csi_add_spaces ( self , csi ) : [EOL] self . screen [ self . l ] = self . screen [ self . l ] [ : self . c - [number] ] + [string] * csi [ [string] ] + self . screen [ self . l ] [ self . c : ] [EOL] [EOL] [EOL] def csi_cursor ( self , csi ) : [EOL] if len ( csi [ [string] ] ) == [number] : [EOL] new_line = csi [ [string] ] [ [number] ] [EOL] new_col = csi [ [string] ] [ [number] ] [EOL] else : [EOL] new_line = [number] [EOL] new_col = [number] [EOL] [EOL] if self . absolute_coords : [EOL] self . l = self . bound ( new_line , [number] , self . lines ) [EOL] else : [EOL] self . l = self . bound ( self . top + new_line - [number] , self . top , self . bottom ) [EOL] [EOL] self . c = self . bound ( new_col , [number] , self . working_columns ) [EOL] if self . c > len ( self . screen [ self . l ] ) : [EOL] self . screen [ self . l ] = self . screen [ self . l ] + [string] * ( self . c - len ( self . screen [ self . l ] ) ) [EOL] [EOL] [EOL] [EOL] def csi_set_coords ( self , csi ) : [EOL] if len ( csi [ [string] ] ) == [number] : [EOL] new_start = csi [ [string] ] [ [number] ] [EOL] new_end = csi [ [string] ] [ [number] ] [EOL] else : [EOL] new_start = [number] [EOL] new_end = vim . current . window . height [EOL] [EOL] self . top = new_start [EOL] self . bottom = new_end [EOL] self . working_lines = new_end - new_start + [number] [EOL] [EOL] [comment] [EOL] if self . l < self . top : [EOL] self . l = self . top [EOL] elif self . l > self . bottom : [EOL] self . l = self . bottom [EOL] [EOL] self . color_changes = { } [EOL] [EOL] [EOL] def csi_tab_clear ( self , csi ) : [EOL] [comment] [EOL] if len ( csi [ [string] ] ) == [number] : [EOL] csi [ [string] ] = [number] [EOL] [EOL] logging . debug ( [string] + str ( csi [ [string] ] ) ) [EOL] [EOL] if csi [ [string] ] == [number] : [EOL] self . tabstops [ self . c - [number] ] = False [EOL] elif csi [ [string] ] == [number] : [EOL] for i in range ( [number] , self . columns + [number] ) : [EOL] self . tabstops [ i ] = False [EOL] [EOL] [EOL] def csi_set ( self , csi ) : [EOL] [comment] [EOL] if csi [ [string] ] == [number] : [EOL] self . csi_clear_screen ( self . parse_csi ( [string] ) ) [EOL] self . working_columns = [number] [EOL] [EOL] [comment] [EOL] elif csi [ [string] ] == [number] : [EOL] self . absolute_coords = False [EOL] [EOL] [comment] [EOL] elif csi [ [string] ] == [number] : [EOL] self . autowrap = True [EOL] [EOL] [EOL] self . color_changes = { } [EOL] [EOL] [EOL] def csi_reset ( self , csi ) : [EOL] [comment] [EOL] if csi [ [string] ] == [number] : [EOL] self . csi_clear_screen ( self . parse_csi ( [string] ) ) [EOL] self . working_columns = [number] [EOL] [EOL] [comment] [EOL] elif csi [ [string] ] == [number] : [EOL] self . absolute_coords = True [EOL] [EOL] [comment] [EOL] elif csi [ [string] ] == [number] : [EOL] self . autowrap = False [EOL] [EOL] [EOL] self . color_changes = { } [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def esc_scroll_up ( self ) : [EOL] self . ctl_nl ( ) [EOL] [EOL] self . color_changes = { } [EOL] [EOL] [EOL] def esc_next_line ( self ) : [EOL] self . ctl_nl ( ) [EOL] self . c = [number] [EOL] [EOL] [EOL] def esc_set_tab ( self ) : [EOL] logging . debug ( [string] + str ( self . c ) ) [EOL] if self . c <= len ( self . tabstops ) : [EOL] self . tabstops [ self . c - [number] ] = True [EOL] [EOL] [EOL] def esc_scroll_down ( self ) : [EOL] if self . l == self . top : [EOL] del self . screen [ self . bottom ] [EOL] self . screen . insert ( self . top , [string] ) [EOL] else : [EOL] self . l += - [number] [EOL] [EOL] self . color_changes = { } [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def hash_screen_alignment_test ( self ) : [EOL] self . csi_clear_screen ( self . parse_csi ( [string] ) ) [EOL] self . working_lines = self . lines [EOL] for l in range ( [number] , self . lines + [number] ) : [EOL] self . screen [ l ] = [string] * self . working_columns [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def charset_us ( self ) : [EOL] self . character_set = [string] [EOL] [EOL] def charset_uk ( self ) : [EOL] self . character_set = [string] [EOL] [EOL] def charset_graphics ( self ) : [EOL] self . character_set = [string] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def set_cursor ( self , line , col ) : [EOL] [docstring] [EOL] self . screen . set_cursor ( line , col ) [EOL] [EOL] def change_title ( self , key , val ) : [EOL] [docstring] [EOL] logging . debug ( key ) [EOL] logging . debug ( val ) [EOL] if key == [string] or key == [string] : [EOL] logging . debug ( [string] + re . escape ( val ) ) [EOL] vim . command ( [string] + re . escape ( val ) ) [EOL] try : [EOL] vim . command ( [string] + re . escape ( val ) ) [EOL] except : [EOL] pass [EOL] [EOL] def update_window_size ( self , force = False ) : [EOL] [docstring] [EOL] [comment] [EOL] if force or vim . current . window . width != self . columns or vim . current . window . height != self . lines : [EOL] [EOL] [comment] [EOL] self . columns = vim . current . window . width [EOL] self . lines = vim . current . window . height [EOL] self . working_columns = vim . current . window . width [EOL] self . working_lines = vim . current . window . height [EOL] self . bottom = vim . current . window . height [EOL] [EOL] [comment] [EOL] self . l = self . screen . reset_size ( self . l ) [EOL] [EOL] [comment] [EOL] self . init_tabstops ( ) [EOL] [EOL] logging . debug ( [string] ) [EOL] [EOL] [comment] [EOL] self . proc . window_resize ( self . lines , self . columns ) [EOL] [EOL] def insert_enter ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] self . update_window_size ( ) [EOL] [EOL] [comment] [EOL] self . cursor_set = False [EOL] [EOL] def init_tabstops ( self ) : [EOL] [docstring] [EOL] for i in range ( [number] , self . columns + [number] ) : [EOL] if i % [number] == [number] : [EOL] self . tabstops . append ( True ) [EOL] else : [EOL] self . tabstops . append ( False ) [EOL] [EOL] def idle ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def resume ( self ) : [EOL] [docstring] [EOL] pass [EOL] pass [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] self . proc . close ( ) [EOL] [EOL] def abort ( self ) : [EOL] [docstring] [EOL] self . proc . signal ( [number] ) [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def parse_csi ( self , s ) : [EOL] [docstring] [EOL] [EOL] attr = { [string] : s [ - [number] ] , [string] : [string] , [string] : [number] , [string] : [ ] } [EOL] [EOL] if len ( s ) == [number] : [EOL] return attr [EOL] [EOL] full = s [ [number] : - [number] ] [EOL] [EOL] if full [ [number] ] == [string] : [EOL] full = full [ [number] : ] [EOL] attr [ [string] ] = [string] [EOL] [EOL] if full != [string] : [EOL] vals = full . split ( [string] ) [EOL] for val in vals : [EOL] logging . debug ( val ) [EOL] val = re . sub ( [string] , [string] , val ) [EOL] logging . debug ( val ) [EOL] if val != [string] : [EOL] attr [ [string] ] . append ( int ( val ) ) [EOL] [EOL] if len ( attr [ [string] ] ) == [number] : [EOL] attr [ [string] ] = int ( attr [ [string] ] [ [number] ] ) [EOL] [EOL] return attr [EOL] [EOL] [EOL] def bound ( self , val , min , max ) : [EOL] [docstring] [EOL] if val > max : [EOL] return max [EOL] [EOL] if val < min : [EOL] return min [EOL] [EOL] return val [EOL] [EOL] [EOL] def xterm_to_rgb ( self , color_code ) : [EOL] [docstring] [EOL] if color_code < [number] : [EOL] ascii_colors = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] return ascii_colors [ color_code ] [EOL] [EOL] elif color_code < [number] : [EOL] cc = int ( color_code ) - [number] [EOL] [EOL] p1 = [string] % ( math . floor ( cc / [number] ) * ( [number] / [number] ) ) [EOL] p2 = [string] % ( math . floor ( ( cc % [number] ) / [number] ) * ( [number] / [number] ) ) [EOL] p3 = [string] % ( math . floor ( cc % [number] ) * ( [number] / [number] ) ) [EOL] [EOL] return p1 + p2 + p3 [EOL] else : [EOL] grey_tone = [string] % math . floor ( ( [number] / [number] ) * ( color_code - [number] ) ) [EOL] return grey_tone + grey_tone + grey_tone [EOL] [EOL] [EOL] [EOL] [EOL] def get_buffer_line ( self , line ) : [EOL] [docstring] [EOL] return self . screen . get_buffer_line ( line ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Type , Any , List [EOL] import typing [EOL] import pack [EOL] [docstring] [EOL] [EOL] import ctypes [EOL] import time [EOL] [EOL] [EOL] class ConqueSoleWrapper ( ) : [EOL] [EOL] [comment] [EOL] shm_key = [string] [EOL] [EOL] [comment] [EOL] handle = None [EOL] pid = None [EOL] [EOL] [comment] [EOL] bucket = None [EOL] [EOL] [comment] [EOL] lines = [number] [EOL] columns = [number] [EOL] [EOL] [comment] [EOL] shm_input = None [EOL] shm_output = None [EOL] shm_attributes = None [EOL] shm_stats = None [EOL] shm_command = None [EOL] shm_rescroll = None [EOL] shm_resize = None [EOL] [EOL] [comment] [EOL] proc = None [EOL] [EOL] [EOL] def open ( self , cmd , lines , columns , python_exe = [string] , communicator_py = [string] , options = { } ) : [EOL] [docstring] [EOL] self . lines = lines [EOL] self . columns = columns [EOL] self . bucket = u ( [string] ) [EOL] [EOL] [comment] [EOL] self . shm_key = [string] + str ( time . time ( ) ) [EOL] [EOL] [comment] [EOL] cmd_line = [string] % ( python_exe , communicator_py , self . shm_key , int ( self . columns ) , int ( self . lines ) , int ( options [ [string] ] ) , int ( CONQUE_FAST_MODE ) , cmd ) [EOL] logging . info ( [string] + cmd_line ) [EOL] [EOL] [comment] [EOL] flags = NORMAL_PRIORITY_CLASS | DETACHED_PROCESS | CREATE_UNICODE_ENVIRONMENT [EOL] si = STARTUPINFO ( ) [EOL] pi = PROCESS_INFORMATION ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] res = ctypes . windll . kernel32 . CreateProcessW ( None , u ( cmd_line ) , None , None , [number] , flags , None , u ( [string] ) , ctypes . byref ( si ) , ctypes . byref ( pi ) ) [EOL] except : [EOL] logging . info ( [string] % cmd_line ) [EOL] raise [EOL] [EOL] [comment] [EOL] self . pid = pi . dwProcessId [EOL] [EOL] logging . info ( [string] + str ( self . pid ) ) [EOL] [EOL] [comment] [EOL] self . init_shared_memory ( self . shm_key ) [EOL] [EOL] [EOL] def read ( self , start_line , num_lines , timeout = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] if timeout > [number] : [EOL] read_timeout = float ( timeout ) / [number] [EOL] [comment] [EOL] time . sleep ( read_timeout ) [EOL] [EOL] output = [ ] [EOL] attributes = [ ] [EOL] [EOL] [comment] [EOL] for i in range ( start_line , start_line + num_lines + [number] ) : [EOL] output . append ( self . shm_output . read ( self . columns , i * self . columns ) ) [EOL] if not CONQUE_FAST_MODE : [EOL] attributes . append ( self . shm_attributes . read ( self . columns , i * self . columns ) ) [EOL] [EOL] return ( output , attributes ) [EOL] [EOL] [EOL] def get_stats ( self ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] rescroll = self . shm_rescroll . read ( ) [EOL] if rescroll != [string] and rescroll != None : [EOL] logging . debug ( [string] ) [EOL] logging . debug ( str ( rescroll ) ) [EOL] [EOL] self . shm_rescroll . clear ( ) [EOL] [EOL] [comment] [EOL] self . shm_output . close ( ) [EOL] self . shm_output = None [EOL] [EOL] if not CONQUE_FAST_MODE : [EOL] self . shm_attributes . close ( ) [EOL] self . shm_attributes = None [EOL] [EOL] [comment] [EOL] logging . debug ( [string] + str ( CONQUE_SOLE_BUFFER_LENGTH * self . columns * rescroll [ [string] ] [ [string] ] ) + [string] + rescroll [ [string] ] [ [string] ] ) [EOL] self . shm_output = ConqueSoleSharedMemory ( CONQUE_SOLE_BUFFER_LENGTH * self . columns * rescroll [ [string] ] [ [string] ] , [string] , rescroll [ [string] ] [ [string] ] , True ) [EOL] self . shm_output . create ( [string] ) [EOL] [EOL] if not CONQUE_FAST_MODE : [EOL] self . shm_attributes = ConqueSoleSharedMemory ( CONQUE_SOLE_BUFFER_LENGTH * self . columns * rescroll [ [string] ] [ [string] ] , [string] , rescroll [ [string] ] [ [string] ] , True , encoding = [string] ) [EOL] self . shm_attributes . create ( [string] ) [EOL] [EOL] stats_str = self . shm_stats . read ( ) [EOL] if stats_str != [string] : [EOL] self . stats = stats_str [EOL] else : [EOL] return False [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] return False [EOL] [EOL] return self . stats [EOL] [EOL] [EOL] def is_alive ( self ) : [EOL] [docstring] [EOL] [EOL] if not self . shm_stats : [EOL] return True [EOL] [EOL] stats_str = self . shm_stats . read ( ) [EOL] if stats_str : [EOL] return ( stats_str [ [string] ] ) [EOL] else : [EOL] return True [EOL] [EOL] [EOL] def write ( self , text ) : [EOL] [docstring] [EOL] [EOL] self . bucket += text [EOL] [EOL] istr = self . shm_input . read ( ) [EOL] [EOL] if istr == [string] : [EOL] logging . debug ( [string] ) [EOL] self . shm_input . write ( self . bucket [ : [number] ] ) [EOL] self . bucket = self . bucket [ [number] : ] [EOL] [EOL] [EOL] def write_vk ( self , vk_code ) : [EOL] [docstring] [EOL] [EOL] seq = u ( [string] ) + u ( str ( vk_code ) ) + u ( [string] ) [EOL] self . write ( seq ) [EOL] [EOL] [EOL] def idle ( self ) : [EOL] [docstring] [EOL] [EOL] logging . info ( [string] ) [EOL] self . shm_command . write ( { [string] : [string] , [string] : { } } ) [EOL] [EOL] [EOL] def resume ( self ) : [EOL] [docstring] [EOL] [EOL] self . shm_command . write ( { [string] : [string] , [string] : { } } ) [EOL] [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] [EOL] self . shm_command . write ( { [string] : [string] , [string] : { } } ) [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def window_resize ( self , lines , columns ) : [EOL] [docstring] [EOL] [EOL] self . lines = lines [EOL] [EOL] [comment] [EOL] if columns > self . columns : [EOL] self . columns = columns [EOL] [EOL] self . shm_resize . write ( { [string] : [string] , [string] : { [string] : columns , [string] : lines } } ) [EOL] [EOL] [EOL] def init_shared_memory ( self , mem_key ) : [EOL] [docstring] [EOL] [EOL] self . shm_input = ConqueSoleSharedMemory ( CONQUE_SOLE_INPUT_SIZE , [string] , mem_key ) [EOL] self . shm_input . create ( [string] ) [EOL] self . shm_input . clear ( ) [EOL] [EOL] self . shm_output = ConqueSoleSharedMemory ( CONQUE_SOLE_BUFFER_LENGTH * self . columns , [string] , mem_key , True ) [EOL] self . shm_output . create ( [string] ) [EOL] [EOL] if not CONQUE_FAST_MODE : [EOL] self . shm_attributes = ConqueSoleSharedMemory ( CONQUE_SOLE_BUFFER_LENGTH * self . columns , [string] , mem_key , True , encoding = [string] ) [EOL] self . shm_attributes . create ( [string] ) [EOL] [EOL] self . shm_stats = ConqueSoleSharedMemory ( CONQUE_SOLE_STATS_SIZE , [string] , mem_key , serialize = True ) [EOL] self . shm_stats . create ( [string] ) [EOL] self . shm_stats . clear ( ) [EOL] [EOL] self . shm_command = ConqueSoleSharedMemory ( CONQUE_SOLE_COMMANDS_SIZE , [string] , mem_key , serialize = True ) [EOL] self . shm_command . create ( [string] ) [EOL] self . shm_command . clear ( ) [EOL] [EOL] self . shm_resize = ConqueSoleSharedMemory ( CONQUE_SOLE_RESIZE_SIZE , [string] , mem_key , serialize = True ) [EOL] self . shm_resize . create ( [string] ) [EOL] self . shm_resize . clear ( ) [EOL] [EOL] self . shm_rescroll = ConqueSoleSharedMemory ( CONQUE_SOLE_RESCROLL_SIZE , [string] , mem_key , serialize = True ) [EOL] self . shm_rescroll . create ( [string] ) [EOL] self . shm_rescroll . clear ( ) [EOL] [EOL] return True [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Tuple , Union , Pattern , Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import re [EOL] import os [comment] [EOL] import logging [comment] [EOL] import traceback [comment] [EOL] [EOL] [comment] [EOL] CONQUE_PYTHON_VERSION = sys . version_info [ [number] ] [EOL] [EOL] [comment] [EOL] [EOL] try : [EOL] [comment] [EOL] import vim [EOL] CONQUE_VIM_ENCODING = vim . eval ( [string] ) [EOL] [EOL] except : [EOL] CONQUE_VIM_ENCODING = [string] [EOL] [EOL] [EOL] def u ( str_val , str_encoding = [string] , errors = [string] ) : [EOL] [docstring] [EOL] [EOL] if not str_val : [EOL] str_val = [string] [EOL] [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] return str_val [EOL] [EOL] else : [EOL] return unicode ( str_val , str_encoding , errors ) [EOL] [EOL] def uchr ( str ) : [EOL] [docstring] [EOL] [EOL] if CONQUE_PYTHON_VERSION == [number] : [EOL] return chr ( str ) [EOL] [EOL] else : [EOL] return unichr ( str ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] CONQUE_LOG_FILENAME = None [comment] [EOL] if os . path . exists ( [string] ) : [comment] [EOL] CONQUE_LOG_FILENAME = [string] [comment] [EOL] elif os . path . exists ( [string] ) : [comment] [EOL] CONQUE_LOG_FILENAME = [string] [comment] [EOL] elif os . path . exists ( [string] ) : [comment] [EOL] CONQUE_LOG_FILENAME = [string] [comment] [EOL] [EOL] CONQUE_LOG_LEVEL = logging . INFO [comment] [EOL] [EOL] if CONQUE_LOG_FILENAME : [comment] [EOL] logging . basicConfig ( filename = CONQUE_LOG_FILENAME , level = CONQUE_LOG_LEVEL ) [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] CONQUE_CTL = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] CONQUE_ESCAPE = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] CONQUE_ESCAPE_PLAIN = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] CONQUE_ESCAPE_CHARSET = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [comment] [EOL] CONQUE_ESCAPE_QUESTION = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] CONQUE_ESCAPE_HASH = { [string] : [string] } [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] CONQUE_GRAPHICS_SET = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] [comment] [EOL] CONQUE_FONT = { [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : True } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : True } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : True } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : True } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : True } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , [string] : True } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : True } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : True } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } , [number] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : False } } [EOL] [EOL] [EOL] [comment] [EOL] CONQUE_SEQ_REGEX = re . compile ( [string] ) [EOL] CONQUE_SEQ_REGEX_CTL = re . compile ( [string] ) [EOL] CONQUE_SEQ_REGEX_CSI = re . compile ( [string] ) [EOL] CONQUE_SEQ_REGEX_TITLE = re . compile ( [string] ) [EOL] CONQUE_SEQ_REGEX_HASH = re . compile ( [string] ) [EOL] CONQUE_SEQ_REGEX_ESC = re . compile ( [string] ) [EOL] CONQUE_SEQ_REGEX_CHAR = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] CONQUE_TABLE_OUTPUT = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] CONQUE_COLOR_SEQUENCE = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] CONQUE_SOLE_BUFFER_LENGTH = [number] [EOL] CONQUE_SOLE_INPUT_SIZE = [number] [EOL] CONQUE_SOLE_STATS_SIZE = [number] [EOL] CONQUE_SOLE_COMMANDS_SIZE = [number] [EOL] CONQUE_SOLE_RESCROLL_SIZE = [number] [EOL] CONQUE_SOLE_RESIZE_SIZE = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] CONQUE_SOLE_SCREEN_REDRAW = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] CONQUE_SOLE_BUFFER_REDRAW = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] CONQUE_SOLE_MEM_REDRAW = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] CONQUE_MAX_SYNTAX_LINES = [number] [EOL] [EOL] [comment] [EOL] CONQUE_WIN32_REGEX_VK = re . compile ( [string] ) [EOL] [EOL] [comment] [EOL] CONQUE_WIN32_REGEX_ATTR = re . compile ( [string] , re . DOTALL ) [EOL] [EOL] [comment] [EOL] CONQUE_VK_ATTR_CTRL_PRESSED = u ( [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Type , Any , Dict [EOL] import typing [EOL] import pack [EOL] import ctypes [EOL] [docstring] [EOL] [EOL] import time [EOL] import re [EOL] import os [EOL] import ctypes [EOL] [EOL] from conque_globals import * [EOL] from conque_win32_util import * [EOL] from conque_sole_shared_memory import * [EOL] [EOL] [EOL] class ConqueSoleSubprocess ( ) : [EOL] [EOL] [comment] [EOL] handle = None [EOL] pid = None [EOL] [EOL] [comment] [EOL] stdin = None [EOL] stdout = None [EOL] [EOL] [comment] [EOL] window_width = [number] [EOL] window_height = [number] [EOL] [EOL] [comment] [EOL] buffer_width = [number] [EOL] buffer_height = [number] [EOL] [EOL] [comment] [EOL] top = [number] [EOL] line_offset = [number] [EOL] [EOL] [comment] [EOL] output_blocks = [number] [EOL] [EOL] [comment] [EOL] cursor_line = [number] [EOL] cursor_col = [number] [EOL] [EOL] [comment] [EOL] data = [ ] [EOL] [EOL] [comment] [EOL] attributes = [ ] [EOL] attribute_cache = { } [EOL] [EOL] [comment] [EOL] default_attribute = [number] [EOL] [EOL] [comment] [EOL] shm_input = None [EOL] shm_output = None [EOL] shm_attributes = None [EOL] shm_stats = None [EOL] shm_command = None [EOL] shm_rescroll = None [EOL] shm_resize = None [EOL] [EOL] [comment] [EOL] is_alive = True [EOL] [EOL] [comment] [EOL] fast_mode = [number] [EOL] [EOL] [comment] [EOL] screen_redraw_ct = [number] [EOL] mem_redraw_ct = [number] [EOL] [EOL] [EOL] def open ( self , cmd , mem_key , options = { } ) : [EOL] [docstring] [EOL] [EOL] logging . debug ( [string] + cmd ) [EOL] [EOL] self . reset = True [EOL] [EOL] try : [EOL] [comment] [EOL] try : [EOL] ctypes . windll . kernel32 . FreeConsole ( ) [EOL] except : [EOL] pass [EOL] [EOL] [comment] [EOL] self . buffer_height = CONQUE_SOLE_BUFFER_LENGTH [EOL] logging . info ( str ( options ) ) [EOL] if [string] in options and [string] in options : [EOL] self . window_width = options [ [string] ] [EOL] self . window_height = options [ [string] ] [EOL] self . buffer_width = options [ [string] ] [EOL] [EOL] [comment] [EOL] self . fast_mode = options [ [string] ] [EOL] [EOL] [comment] [EOL] si = STARTUPINFO ( ) [EOL] [EOL] [comment] [EOL] si . dwFlags |= STARTF_USESHOWWINDOW [EOL] si . wShowWindow = SW_HIDE [EOL] [comment] [EOL] [EOL] [comment] [EOL] flags = NORMAL_PRIORITY_CLASS | CREATE_NEW_PROCESS_GROUP | CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE [EOL] [EOL] [comment] [EOL] pi = PROCESS_INFORMATION ( ) [EOL] [EOL] logging . debug ( [string] + os . path . abspath ( [string] ) ) [EOL] [EOL] [comment] [EOL] res = ctypes . windll . kernel32 . CreateProcessW ( None , u ( cmd ) , None , None , [number] , flags , None , u ( [string] ) , ctypes . byref ( si ) , ctypes . byref ( pi ) ) [EOL] [EOL] logging . info ( str ( res ) ) [EOL] logging . info ( str ( ctypes . GetLastError ( ) ) ) [EOL] logging . info ( str ( ctypes . FormatError ( ctypes . GetLastError ( ) ) ) ) [EOL] [EOL] [comment] [EOL] self . pid = pi . dwProcessId [EOL] self . handle = pi . hProcess [EOL] [EOL] logging . info ( [string] + str ( self . pid ) ) [EOL] logging . debug ( str ( self . handle ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] time . sleep ( [number] ) [EOL] try : [EOL] logging . debug ( [string] + str ( i ) ) [EOL] res = ctypes . windll . kernel32 . AttachConsole ( self . pid ) [EOL] [EOL] logging . debug ( [string] ) [EOL] logging . debug ( str ( res ) ) [EOL] logging . debug ( str ( ctypes . GetLastError ( ) ) ) [EOL] logging . debug ( str ( ctypes . FormatError ( ctypes . GetLastError ( ) ) ) ) [EOL] [EOL] break [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] [EOL] [comment] [EOL] self . stdout = ctypes . windll . kernel32 . GetStdHandle ( STD_OUTPUT_HANDLE ) [EOL] self . stdin = ctypes . windll . kernel32 . GetStdHandle ( STD_INPUT_HANDLE ) [EOL] [EOL] [comment] [EOL] size = COORD ( self . buffer_width , self . buffer_height ) [EOL] res = ctypes . windll . kernel32 . SetConsoleScreenBufferSize ( self . stdout , size ) [EOL] logging . debug ( [string] + str ( size . to_str ( ) ) ) [EOL] [EOL] logging . debug ( [string] ) [EOL] logging . debug ( str ( res ) ) [EOL] logging . debug ( str ( ctypes . GetLastError ( ) ) ) [EOL] logging . debug ( str ( ctypes . FormatError ( ctypes . GetLastError ( ) ) ) ) [EOL] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] self . set_window_size ( self . window_width , self . window_height ) [EOL] [EOL] [comment] [EOL] if [string] in options and options [ [string] ] > [number] : [EOL] if ctypes . windll . kernel32 . IsValidCodePage ( ctypes . c_uint ( options [ [string] ] ) ) : [EOL] logging . info ( [string] + str ( options [ [string] ] ) ) [EOL] ctypes . windll . kernel32 . SetConsoleCP ( ctypes . c_uint ( options [ [string] ] ) ) [EOL] ctypes . windll . kernel32 . SetConsoleOutputCP ( ctypes . c_uint ( options [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] self . init_shared_memory ( mem_key ) [EOL] [EOL] [comment] [EOL] self . tc = ctypes . create_unicode_buffer ( self . buffer_width ) [EOL] self . ac = ctypes . create_unicode_buffer ( self . buffer_width ) [EOL] [EOL] return True [EOL] [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] return False [EOL] [EOL] [EOL] def init_shared_memory ( self , mem_key ) : [EOL] [docstring] [EOL] [EOL] self . shm_input = ConqueSoleSharedMemory ( CONQUE_SOLE_INPUT_SIZE , [string] , mem_key ) [EOL] self . shm_input . create ( [string] ) [EOL] self . shm_input . clear ( ) [EOL] [EOL] self . shm_output = ConqueSoleSharedMemory ( self . buffer_height * self . buffer_width , [string] , mem_key , True ) [EOL] self . shm_output . create ( [string] ) [EOL] self . shm_output . clear ( ) [EOL] [EOL] if not self . fast_mode : [EOL] buf_info = self . get_buffer_info ( ) [EOL] self . shm_attributes = ConqueSoleSharedMemory ( self . buffer_height * self . buffer_width , [string] , mem_key , True , chr ( buf_info . wAttributes ) , encoding = [string] ) [EOL] self . shm_attributes . create ( [string] ) [EOL] self . shm_attributes . clear ( ) [EOL] [EOL] self . shm_stats = ConqueSoleSharedMemory ( CONQUE_SOLE_STATS_SIZE , [string] , mem_key , serialize = True ) [EOL] self . shm_stats . create ( [string] ) [EOL] self . shm_stats . clear ( ) [EOL] [EOL] self . shm_command = ConqueSoleSharedMemory ( CONQUE_SOLE_COMMANDS_SIZE , [string] , mem_key , serialize = True ) [EOL] self . shm_command . create ( [string] ) [EOL] self . shm_command . clear ( ) [EOL] [EOL] self . shm_resize = ConqueSoleSharedMemory ( CONQUE_SOLE_RESIZE_SIZE , [string] , mem_key , serialize = True ) [EOL] self . shm_resize . create ( [string] ) [EOL] self . shm_resize . clear ( ) [EOL] [EOL] self . shm_rescroll = ConqueSoleSharedMemory ( CONQUE_SOLE_RESCROLL_SIZE , [string] , mem_key , serialize = True ) [EOL] self . shm_rescroll . create ( [string] ) [EOL] self . shm_rescroll . clear ( ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def check_commands ( self ) : [EOL] [docstring] [EOL] [EOL] cmd = self . shm_command . read ( ) [EOL] [EOL] if cmd : [EOL] [EOL] [comment] [EOL] if cmd [ [string] ] == [string] : [EOL] [EOL] [comment] [EOL] self . shm_command . clear ( ) [EOL] [EOL] self . close ( ) [EOL] return [EOL] [EOL] cmd = self . shm_resize . read ( ) [EOL] [EOL] if cmd : [EOL] [EOL] [comment] [EOL] self . shm_resize . clear ( ) [EOL] [EOL] [comment] [EOL] if cmd [ [string] ] == [string] : [EOL] [EOL] logging . info ( [string] + str ( cmd [ [string] ] [ [string] ] ) + [string] + str ( cmd [ [string] ] [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] if cmd [ [string] ] [ [string] ] > self . buffer_width : [EOL] self . buffer_width = cmd [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] self . window_width = cmd [ [string] ] [ [string] ] [EOL] self . window_height = cmd [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] buf_info = self . get_buffer_info ( ) [EOL] self . reset_console ( buf_info , add_block = False ) [EOL] [EOL] [EOL] def read ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if self . screen_redraw_ct == [number] and not self . is_alive ( ) : [EOL] stats = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : self . cursor_line , [string] : [number] } [EOL] logging . info ( [string] ) [EOL] self . shm_stats . write ( stats ) [EOL] return [EOL] [EOL] [comment] [EOL] self . check_commands ( ) [EOL] [EOL] [comment] [EOL] buf_info = self . get_buffer_info ( ) [EOL] curs_line = buf_info . dwCursorPosition . Y [EOL] curs_col = buf_info . dwCursorPosition . X [EOL] [EOL] [comment] [EOL] if curs_line != self . cursor_line or self . top != buf_info . srWindow . Top or self . screen_redraw_ct == CONQUE_SOLE_SCREEN_REDRAW : [EOL] self . screen_redraw_ct = [number] [EOL] logging . info ( [string] ) [EOL] read_start = self . top [EOL] read_end = max ( [ buf_info . srWindow . Bottom + [number] , curs_line + [number] ] ) [EOL] else : [EOL] logging . info ( [string] ) [EOL] read_start = curs_line [EOL] read_end = curs_line + [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] coord = COORD ( [number] , [number] ) [EOL] chars_read = ctypes . c_int ( [number] ) [EOL] [EOL] [comment] [EOL] for i in range ( read_start , read_end ) : [EOL] [EOL] coord . Y = i [EOL] [EOL] res = ctypes . windll . kernel32 . ReadConsoleOutputCharacterW ( self . stdout , ctypes . byref ( self . tc ) , self . buffer_width , coord , ctypes . byref ( chars_read ) ) [EOL] if not self . fast_mode : [EOL] ctypes . windll . kernel32 . ReadConsoleOutputAttribute ( self . stdout , ctypes . byref ( self . ac ) , self . buffer_width , coord , ctypes . byref ( chars_read ) ) [EOL] [EOL] t = self . tc . value [EOL] if not self . fast_mode : [EOL] a = self . ac . value [EOL] [EOL] [comment] [EOL] if i >= len ( self . data ) : [EOL] for j in range ( len ( self . data ) , i + [number] ) : [EOL] self . data . append ( [string] ) [EOL] if not self . fast_mode : [EOL] self . attributes . append ( [string] ) [EOL] [EOL] self . data [ i ] = t [EOL] if not self . fast_mode : [EOL] self . attributes [ i ] = a [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] try : [EOL] if self . mem_redraw_ct == CONQUE_SOLE_MEM_REDRAW : [EOL] self . mem_redraw_ct = [number] [EOL] logging . debug ( [string] ) [EOL] for i in range ( [number] , len ( self . data ) ) : [EOL] self . shm_output . write ( text = self . data [ i ] , start = self . buffer_width * i ) [EOL] if not self . fast_mode : [EOL] self . shm_attributes . write ( text = self . attributes [ i ] , start = self . buffer_width * i ) [EOL] else : [EOL] logging . debug ( [string] ) [EOL] for i in range ( read_start , read_end ) : [EOL] self . shm_output . write ( text = self . data [ i ] , start = self . buffer_width * i ) [EOL] if not self . fast_mode : [EOL] self . shm_attributes . write ( text = self . attributes [ i ] , start = self . buffer_width * i ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] stats = { [string] : buf_info . srWindow . Top , [string] : buf_info . wAttributes , [string] : curs_col , [string] : curs_line , [string] : [number] } [EOL] self . shm_stats . write ( stats ) [EOL] [EOL] [comment] [EOL] self . top = buf_info . srWindow . Top [EOL] self . cursor_line = curs_line [EOL] [EOL] [comment] [EOL] if curs_line > buf_info . dwSize . Y - [number] : [EOL] self . reset_console ( buf_info ) [EOL] [EOL] except : [EOL] logging . info ( [string] + str ( read_start ) ) [EOL] logging . info ( [string] + str ( read_end ) ) [EOL] logging . info ( [string] + str ( len ( self . data ) ) ) [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] [EOL] [comment] [EOL] self . screen_redraw_ct += [number] [EOL] self . mem_redraw_ct += [number] [EOL] [EOL] return None [EOL] [EOL] [EOL] def reset_console ( self , buf_info , add_block = True ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if add_block : [EOL] self . output_blocks += [number] [EOL] [EOL] [comment] [EOL] self . shm_output . close ( ) [EOL] self . shm_output = None [EOL] [EOL] if not self . fast_mode : [EOL] self . shm_attributes . close ( ) [EOL] self . shm_attributes = None [EOL] [EOL] [comment] [EOL] mem_key = [string] + str ( time . time ( ) ) [EOL] [EOL] [comment] [EOL] self . shm_output = ConqueSoleSharedMemory ( self . buffer_height * self . buffer_width * self . output_blocks , [string] , mem_key , True ) [EOL] self . shm_output . create ( [string] ) [EOL] self . shm_output . clear ( ) [EOL] [EOL] [comment] [EOL] if len ( self . data [ [number] ] ) < self . buffer_width : [EOL] for i in range ( [number] , len ( self . data ) ) : [EOL] self . data [ i ] = self . data [ i ] + [string] * ( self . buffer_width - len ( self . data [ i ] ) ) [EOL] self . shm_output . write ( [string] . join ( self . data ) ) [EOL] [EOL] if not self . fast_mode : [EOL] self . shm_attributes = ConqueSoleSharedMemory ( self . buffer_height * self . buffer_width * self . output_blocks , [string] , mem_key , True , chr ( buf_info . wAttributes ) , encoding = [string] ) [EOL] self . shm_attributes . create ( [string] ) [EOL] self . shm_attributes . clear ( ) [EOL] [EOL] [comment] [EOL] if len ( self . attributes [ [number] ] ) < self . buffer_width : [EOL] for i in range ( [number] , len ( self . attributes ) ) : [EOL] self . attributes [ i ] = self . attributes [ i ] + chr ( buf_info . wAttributes ) * ( self . buffer_width - len ( self . attributes [ i ] ) ) [EOL] if not self . fast_mode : [EOL] self . shm_attributes . write ( [string] . join ( self . attributes ) ) [EOL] [EOL] [comment] [EOL] self . shm_rescroll . write ( { [string] : [string] , [string] : { [string] : self . output_blocks , [string] : mem_key } } ) [EOL] [EOL] [comment] [EOL] size = COORD ( X = self . buffer_width , Y = self . buffer_height * self . output_blocks ) [EOL] logging . debug ( [string] + str ( size ) ) [EOL] res = ctypes . windll . kernel32 . SetConsoleScreenBufferSize ( self . stdout , size ) [EOL] [EOL] logging . debug ( [string] ) [EOL] logging . debug ( str ( res ) ) [EOL] logging . debug ( str ( ctypes . GetLastError ( ) ) ) [EOL] logging . debug ( str ( ctypes . FormatError ( ctypes . GetLastError ( ) ) ) ) [EOL] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] self . set_window_size ( self . window_width , self . window_height ) [EOL] [EOL] [comment] [EOL] self . tc = ctypes . create_unicode_buffer ( self . buffer_width ) [EOL] self . ac = ctypes . create_unicode_buffer ( self . buffer_width ) [EOL] [EOL] [EOL] [EOL] def write ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] text = self . shm_input . read ( ) [EOL] [EOL] [comment] [EOL] if text == u ( [string] ) : [EOL] return [EOL] [EOL] logging . info ( u ( [string] ) + text ) [EOL] [EOL] [comment] [EOL] self . shm_input . clear ( ) [EOL] [EOL] [comment] [EOL] chunks = CONQUE_WIN32_REGEX_VK . split ( text ) [EOL] [EOL] [comment] [EOL] if len ( chunks ) == [number] : [EOL] self . write_plain ( text ) [EOL] return [EOL] [EOL] logging . debug ( [string] + str ( chunks ) ) [EOL] [EOL] [comment] [EOL] for t in chunks : [EOL] [EOL] if t == [string] : [EOL] continue [EOL] [EOL] if CONQUE_WIN32_REGEX_VK . match ( t ) : [EOL] logging . debug ( [string] + str ( t [ [number] : - [number] ] ) ) [EOL] self . write_vk ( t [ [number] : - [number] ] ) [EOL] else : [EOL] self . write_plain ( t ) [EOL] [EOL] [EOL] def write_plain ( self , text ) : [EOL] [docstring] [EOL] [EOL] li = INPUT_RECORD * len ( text ) [EOL] list_input = li ( ) [EOL] [EOL] for i in range ( [number] , len ( text ) ) : [EOL] [EOL] [comment] [EOL] ke = KEY_EVENT_RECORD ( ) [EOL] ke . bKeyDown = ctypes . c_byte ( [number] ) [EOL] ke . wRepeatCount = ctypes . c_short ( [number] ) [EOL] [EOL] cnum = ord ( text [ i ] ) [EOL] logging . debug ( [string] + str ( cnum ) ) [EOL] ke . wVirtualKeyCode = ctypes . windll . user32 . VkKeyScanW ( cnum ) [EOL] ke . wVirtualScanCode = ctypes . c_short ( ctypes . windll . user32 . MapVirtualKeyW ( int ( cnum ) , [number] ) ) [EOL] [EOL] if cnum > [number] : [EOL] ke . uChar . UnicodeChar = uchr ( cnum ) [EOL] elif cnum == [number] : [EOL] ctypes . windll . kernel32 . GenerateConsoleCtrlEvent ( [number] , self . pid ) [EOL] ke . uChar . UnicodeChar = uchr ( cnum ) [EOL] ke . wVirtualKeyCode = ctypes . windll . user32 . VkKeyScanW ( cnum + [number] ) [EOL] ke . dwControlKeyState |= LEFT_CTRL_PRESSED [EOL] else : [EOL] ke . uChar . UnicodeChar = uchr ( cnum ) [EOL] if cnum in CONQUE_WINDOWS_VK_INV : [EOL] ke . wVirtualKeyCode = cnum [EOL] else : [EOL] ke . wVirtualKeyCode = ctypes . windll . user32 . VkKeyScanW ( cnum + [number] ) [EOL] ke . dwControlKeyState |= LEFT_CTRL_PRESSED [EOL] [EOL] logging . info ( str ( ord ( text [ i ] ) ) + [string] + text [ i ] ) [EOL] logging . info ( ke . dwControlKeyState ) [EOL] [EOL] kc = INPUT_RECORD ( KEY_EVENT ) [EOL] kc . Event . KeyEvent = ke [EOL] list_input [ i ] = kc [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] events_written = ctypes . c_int ( ) [EOL] res = ctypes . windll . kernel32 . WriteConsoleInputW ( self . stdin , list_input , len ( text ) , ctypes . byref ( events_written ) ) [EOL] [EOL] logging . debug ( [string] ) [EOL] logging . debug ( [string] + str ( events_written ) ) [EOL] logging . debug ( str ( res ) ) [EOL] logging . debug ( str ( ctypes . GetLastError ( ) ) ) [EOL] logging . debug ( str ( ctypes . FormatError ( ctypes . GetLastError ( ) ) ) ) [EOL] [EOL] [EOL] def write_vk ( self , vk_code ) : [EOL] [docstring] [EOL] [EOL] logging . debug ( [string] + str ( vk_code ) ) [EOL] [EOL] code = None [EOL] ctrl_pressed = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] vk_attributes = vk_code . split ( [string] ) [EOL] logging . debug ( vk_attributes ) [EOL] for attr in vk_attributes : [EOL] if attr == CONQUE_VK_ATTR_CTRL_PRESSED : [EOL] ctrl_pressed = True [EOL] else : [EOL] code = attr [EOL] [EOL] li = INPUT_RECORD * [number] [EOL] [EOL] [comment] [EOL] ke = KEY_EVENT_RECORD ( ) [EOL] ke . uChar . UnicodeChar = uchr ( [number] ) [EOL] ke . wVirtualKeyCode = ctypes . c_short ( int ( code ) ) [EOL] ke . wVirtualScanCode = ctypes . c_short ( ctypes . windll . user32 . MapVirtualKeyW ( int ( code ) , [number] ) ) [EOL] ke . bKeyDown = ctypes . c_byte ( [number] ) [EOL] ke . wRepeatCount = ctypes . c_short ( [number] ) [EOL] [EOL] [comment] [EOL] if code in CONQUE_WINDOWS_VK_ENHANCED : [EOL] logging . debug ( [string] ) [EOL] ke . dwControlKeyState |= ENHANCED_KEY [EOL] [EOL] if ctrl_pressed : [EOL] ke . dwControlKeyState |= LEFT_CTRL_PRESSED [EOL] [EOL] kc = INPUT_RECORD ( KEY_EVENT ) [EOL] kc . Event . KeyEvent = ke [EOL] list_input = li ( kc ) [EOL] [EOL] [comment] [EOL] events_written = ctypes . c_int ( ) [EOL] res = ctypes . windll . kernel32 . WriteConsoleInputW ( self . stdin , list_input , [number] , ctypes . byref ( events_written ) ) [EOL] [EOL] logging . debug ( [string] + str ( events_written ) ) [EOL] logging . debug ( str ( res ) ) [EOL] logging . debug ( str ( ctypes . GetLastError ( ) ) ) [EOL] logging . debug ( str ( ctypes . FormatError ( ctypes . GetLastError ( ) ) ) ) [EOL] [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] self . is_alive = False [EOL] try : [EOL] stats = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : self . cursor_line , [string] : [number] } [EOL] self . shm_stats . write ( stats ) [EOL] except : [EOL] pass [EOL] [EOL] pid_list = ( ctypes . c_int * [number] ) ( ) [EOL] num = ctypes . windll . kernel32 . GetConsoleProcessList ( pid_list , [number] ) [EOL] [EOL] logging . debug ( [string] . join ( self . data ) ) [EOL] [EOL] current_pid = os . getpid ( ) [EOL] [EOL] logging . info ( [string] ) [EOL] logging . info ( str ( self . pid ) ) [EOL] logging . info ( str ( pid_list ) ) [EOL] [EOL] [comment] [EOL] for pid in pid_list [ [number] : num ] : [EOL] if not pid : [EOL] break [EOL] [EOL] [comment] [EOL] if pid == current_pid : [EOL] continue [EOL] try : [EOL] self . close_pid ( pid ) [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] [EOL] [comment] [EOL] try : [EOL] self . close_pid ( current_pid ) [EOL] except : [EOL] logging . info ( traceback . format_exc ( ) ) [EOL] pass [EOL] [EOL] [EOL] def close_pid ( self , pid ) : [EOL] [docstring] [EOL] [EOL] logging . info ( [string] + str ( pid ) ) [EOL] handle = ctypes . windll . kernel32 . OpenProcess ( PROCESS_TERMINATE , [number] , pid ) [EOL] ctypes . windll . kernel32 . TerminateProcess ( handle , - [number] ) [EOL] ctypes . windll . kernel32 . CloseHandle ( handle ) [EOL] [EOL] [EOL] def is_alive ( self ) : [EOL] [docstring] [EOL] [EOL] status = ctypes . windll . kernel32 . WaitForSingleObject ( self . handle , [number] ) [EOL] [EOL] if status == [number] : [EOL] logging . info ( [string] ) [EOL] self . is_alive = False [EOL] [EOL] return self . is_alive [EOL] [EOL] [EOL] def get_screen_text ( self ) : [EOL] [docstring] [EOL] [EOL] return [string] . join ( self . data ) [EOL] [EOL] [EOL] def set_window_size ( self , width , height ) : [EOL] [docstring] [EOL] [EOL] logging . debug ( [string] ) [EOL] [EOL] [comment] [EOL] window_size = SMALL_RECT ( [number] , [number] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] buf_info = self . get_buffer_info ( ) [EOL] logging . debug ( str ( buf_info . to_str ( ) ) ) [EOL] [EOL] [comment] [EOL] window_size . Top = [number] [EOL] window_size . Left = [number] [EOL] [EOL] [comment] [EOL] if buf_info . dwMaximumWindowSize . X < width : [EOL] logging . debug ( str ( buf_info . dwMaximumWindowSize . X ) + [string] + str ( width ) ) [EOL] window_size . Right = buf_info . dwMaximumWindowSize . X - [number] [EOL] else : [EOL] window_size . Right = width - [number] [EOL] [EOL] if buf_info . dwMaximumWindowSize . Y < height : [EOL] logging . debug ( [string] ) [EOL] window_size . Bottom = buf_info . dwMaximumWindowSize . Y - [number] [EOL] else : [EOL] window_size . Bottom = height - [number] [EOL] [EOL] logging . debug ( [string] + str ( window_size . to_str ( ) ) ) [EOL] [EOL] [comment] [EOL] res = ctypes . windll . kernel32 . SetConsoleWindowInfo ( self . stdout , ctypes . c_bool ( True ) , ctypes . byref ( window_size ) ) [EOL] [EOL] logging . debug ( [string] ) [EOL] logging . debug ( str ( res ) ) [EOL] logging . debug ( str ( ctypes . GetLastError ( ) ) ) [EOL] logging . debug ( str ( ctypes . FormatError ( ctypes . GetLastError ( ) ) ) ) [EOL] [EOL] [comment] [EOL] buf_info = self . get_buffer_info ( ) [EOL] logging . debug ( [string] + str ( buf_info ) ) [EOL] self . window_width = buf_info . srWindow . Right + [number] [EOL] self . window_height = buf_info . srWindow . Bottom + [number] [EOL] [EOL] [EOL] def get_buffer_info ( self ) : [EOL] [docstring] [EOL] [EOL] buf_info = CONSOLE_SCREEN_BUFFER_INFO ( ) [EOL] ctypes . windll . kernel32 . GetConsoleScreenBufferInfo ( self . stdout , ctypes . byref ( buf_info ) ) [EOL] [EOL] return buf_info [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $ctypes.c_int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $ctypes.c_int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $ctypes.c_int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $ctypes.c_int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $ctypes.c_int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ctypes.c_int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $ctypes.c_int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $ctypes.c_int$ 0 0 0 0 0 0 0 0 0 0 0 0 $ctypes.c_int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0
import io [EOL] import glob [EOL] import os [EOL] import re [EOL] import string [EOL] [EOL] [EOL] import vim [EOL] [EOL] [EOL] def catFile ( filename ) : [EOL] [docstring] [EOL] try : [EOL] fp = open ( filename ) [EOL] lines = fp . read ( ) [EOL] fp . close ( ) [EOL] except FileNotFoundError : [EOL] lines = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] vim . command ( [string] % re . sub ( [string] , [string] , lines ) ) [EOL] return lines [EOL] [EOL] [EOL] def isPresentInFile ( regexp , filename ) : [EOL] [docstring] [EOL] try : [EOL] fp = open ( filename ) [EOL] fcontents = fp . read ( ) [EOL] fp . close ( ) [EOL] if re . search ( regexp , fcontents ) : [EOL] vim . command ( [string] ) [EOL] return [number] [EOL] else : [EOL] vim . command ( [string] ) [EOL] return None [EOL] except FileNotFoundError : [EOL] vim . command ( [string] ) [EOL] return None [EOL] [EOL] [EOL] def deleteFile ( filepattern ) : [EOL] [docstring] [EOL] try : [EOL] if os . path . isfile ( filepattern ) : [EOL] os . remove ( filepattern ) [EOL] else : [EOL] if glob . glob ( filepattern ) : [EOL] for filename in glob . glob ( filepattern ) : [EOL] os . remove ( filename ) [EOL] else : [EOL] vim . command ( [string] ) [EOL] except : [EOL] vim . command ( [string] ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any , Pattern , Match , List [EOL] import typing [EOL] import io [EOL] import re [EOL] import os [EOL] import sys [EOL] if sys . version_info <= ( [number] , [number] ) : [EOL] from StringIO import StringIO [EOL] else : [EOL] from io import StringIO [EOL] [EOL] [EOL] def getFileContents ( fname ) : [EOL] if type ( fname ) is not str : [EOL] fname = fname . group ( [number] ) [EOL] [EOL] [comment] [EOL] if not os . path . isfile ( fname ) : [EOL] if os . path . isfile ( fname + [string] ) : [EOL] fname += [string] [EOL] else : [EOL] return [string] [EOL] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] contents = [string] . join ( open ( fname ) . read ( ) . splitlines ( ) ) [EOL] except IOError : [EOL] return [string] [EOL] [EOL] [comment] [EOL] pat = re . compile ( [string] , re . M ) [EOL] contents = re . sub ( pat , getFileContents , contents ) [EOL] [EOL] return ( [string] % fname ) + [string] + contents [EOL] [EOL] [EOL] def stripComments ( contents ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] uncomm = [ re . sub ( [string] , [string] , line ) for line in contents . splitlines ( ) ] [EOL] [comment] [EOL] nonempty = [ line for line in uncomm if line . strip ( ) ] [EOL] [EOL] return nonempty [EOL] [EOL] [EOL] def addFileNameAndNumber ( lines ) : [EOL] filename = [string] [EOL] retval = [string] [EOL] for line in lines : [EOL] if re . match ( [string] , line ) : [EOL] filename = line . split ( [string] ) [ [number] ] [EOL] else : [EOL] retval += [string] % ( filename , line ) [EOL] [EOL] return retval [EOL] [EOL] [EOL] def getSectionLabels_Root ( lineinfo , section_prefix , label_prefix ) : [EOL] prev_txt = [string] [EOL] inside_env = [number] [EOL] prev_env = [string] [EOL] outstr = StringIO ( [string] ) [EOL] pres_depth = len ( section_prefix ) [EOL] indent = [string] * ( [number] * pres_depth + [number] ) [EOL] [EOL] [comment] [EOL] for line in lineinfo . splitlines ( ) : [EOL] if not line : [EOL] continue [EOL] [EOL] [comment] [EOL] m = re . search ( [string] , line ) [EOL] [EOL] fname = m . group ( [number] ) [EOL] line = m . group ( [number] ) . lstrip ( ) [EOL] [EOL] [comment] [EOL] m = re . search ( [string] % label_prefix , line ) [EOL] if m : [EOL] [comment] [EOL] label = m . group ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] prev_txt += re . search ( [string] , line ) . group ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if prev_env == [string] : [EOL] cm = re . search ( [string] , prev_txt ) [EOL] if cm : [EOL] prev_txt = cm . group ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] outstr . write ( [string] % ( indent , label , fname ) ) [EOL] outstr . write ( [string] % ( indent , prev_txt ) ) [EOL] [EOL] prev_txt = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if re . search ( [string] , line ) : [EOL] prev_txt = [string] [EOL] prev_env = re . search ( [string] , line ) . group ( [number] ) [EOL] inside_env = [number] [EOL] [EOL] elif re . search ( [string] , line ) : [EOL] prev_txt = [string] [EOL] [EOL] elif re . search ( [string] , line ) : [EOL] inside_env = [number] [EOL] prev_env = [string] [EOL] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if inside_env : [EOL] prev_txt += line [EOL] else : [EOL] prev_txt = line [EOL] [EOL] return outstr . getvalue ( ) [EOL] [EOL] [EOL] def getSectionLabels ( lineinfo , sectypes = [ [string] , [string] , [string] , [string] ] , section_prefix = [string] , label_prefix = [string] ) : [EOL] [EOL] if not sectypes : [EOL] return getSectionLabels_Root ( lineinfo , section_prefix , label_prefix ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] sections = re . split ( [string] % sectypes [ [number] ] , lineinfo ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] rettext = getSectionLabels ( sections [ [number] ] , sectypes [ [number] : ] , section_prefix , label_prefix ) [EOL] [EOL] for i in range ( [number] , len ( sections ) , [number] ) : [EOL] sec_num = ( i + [number] ) / [number] [EOL] section_name = re . search ( [string] % sectypes [ [number] ] , sections [ i ] ) . group ( [number] ) [EOL] section_label_text = getSectionLabels ( sections [ i ] + sections [ i + [number] ] , sectypes [ [number] : ] , section_prefix + ( [string] % sec_num ) , label_prefix ) [EOL] [EOL] if section_label_text : [EOL] sec_heading = [number] * [string] * len ( section_prefix ) + section_prefix [EOL] sec_heading += [string] % ( sec_num , section_name ) [EOL] sec_heading += [string] % ( len ( section_prefix ) / [number] + [number] ) [EOL] [EOL] rettext += sec_heading + section_label_text [EOL] [EOL] return rettext [EOL] [EOL] [EOL] def main ( fname , label_prefix ) : [EOL] [ head , tail ] = os . path . split ( fname ) [EOL] if head : [EOL] os . chdir ( head ) [EOL] [EOL] contents = getFileContents ( fname ) [EOL] nonempty = stripComments ( contents ) [EOL] lineinfo = addFileNameAndNumber ( nonempty ) [EOL] [EOL] return getSectionLabels ( lineinfo , label_prefix = label_prefix ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) > [number] : [EOL] prefix = sys . argv [ [number] ] [EOL] else : [EOL] prefix = [string] [EOL] [EOL] print ( main ( sys . argv [ [number] ] , prefix ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Any , Iterator , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import random [EOL] import re [EOL] import string [EOL] [EOL] [EOL] def JustifyLine ( line , width ) : [EOL] [docstring] [EOL] i = [ ] [EOL] while [number] : [EOL] [comment] [EOL] if len ( [string] . join ( line ) ) < width : [EOL] if not i : [EOL] [comment] [EOL] [comment] [EOL] i = range ( max ( [number] , len ( line ) - [number] ) ) [EOL] [comment] [EOL] random . shuffle ( i ) [EOL] [comment] [EOL] line [ i . pop ( [number] ) ] += [string] [EOL] else : [EOL] [comment] [EOL] return [string] . join ( line ) [EOL] [EOL] [EOL] def FillParagraphs ( text , width = [number] , justify = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] paragraphs = re . split ( [string] , text ) [EOL] for i in range ( len ( paragraphs ) ) : [EOL] [comment] [EOL] words = paragraphs [ i ] . strip ( ) . split ( ) [EOL] line = [ ] [EOL] new_par = [ ] [EOL] while [number] : [EOL] if words : [EOL] if len ( [string] . join ( line + [ words [ [number] ] ] ) ) > width and line : [EOL] [comment] [EOL] if justify : [EOL] [comment] [EOL] new_par . append ( JustifyLine ( line , width ) ) [EOL] else : [EOL] new_par . append ( [string] . join ( line ) ) [EOL] line = [ ] [EOL] else : [EOL] [comment] [EOL] line . append ( words . pop ( [number] ) ) [EOL] else : [EOL] [comment] [EOL] new_par . append ( [string] . join ( line ) ) [EOL] line = [ ] [EOL] break [EOL] [comment] [EOL] paragraphs [ i ] = [string] . join ( new_par ) [EOL] [comment] [EOL] return [string] . join ( paragraphs ) [EOL] [EOL] [EOL] def IndentParagraphs ( text , width = [number] , indent = [number] , justify = [number] ) : [EOL] [docstring] [EOL] retText = re . sub ( [string] , [string] + [string] * indent , FillParagraphs ( text , width , justify ) ) [EOL] retText = re . sub ( [string] , [string] , retText ) [EOL] return retText [EOL] [EOL] [EOL] def OffsetText ( text , indent ) : [EOL] return re . sub ( [string] , [string] + [string] * indent , text ) [EOL] [EOL] [EOL] def RightJustify ( lines , width ) : [EOL] if width == [number] : [EOL] width = TextWidth ( lines ) [EOL] text = [string] [EOL] for line in lines . split ( [string] ) : [EOL] text += [string] * ( width - len ( line ) ) + line + [string] [EOL] [EOL] text = re . sub ( [string] , [string] , text ) [EOL] return text [EOL] [EOL] [EOL] def CenterText ( lines , width ) : [EOL] text = [string] [EOL] for line in lines . split ( [string] ) : [EOL] text += [string] * ( width / [number] - len ( line ) / [number] ) + line + [string] [EOL] return text [EOL] [EOL] [EOL] def TextWidth ( text ) : [EOL] [docstring] [EOL] return max ( map ( len , text . split ( [string] ) ) ) [EOL] [EOL] [EOL] def FormatTable ( tableText , ROW_SPACE = [number] , COL_SPACE = [number] , COL_WIDTH = [number] , justify = [number] , widths = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if widths is None : [EOL] widths = { } [EOL] for row in tableText : [EOL] cellwidths = map ( TextWidth , row ) [EOL] for i in range ( len ( cellwidths ) ) : [EOL] [comment] [EOL] widths [ i ] = max ( cellwidths [ i ] , widths . get ( i , - [number] ) ) [EOL] [EOL] [comment] [EOL] for i in range ( [number] , len ( widths ) ) : [EOL] widths [ i ] = min ( widths [ i ] , COL_WIDTH ) [EOL] [EOL] if justify : [EOL] formattedTable = [ ] [EOL] [EOL] for row in tableText : [EOL] formattedTable . append ( map ( FillParagraphs , row , [ COL_WIDTH ] * len ( row ) ) ) [EOL] else : [EOL] formattedTable = tableText [EOL] [EOL] retTableText = [string] [EOL] for row in formattedTable : [EOL] rowtext = row [ [number] ] [EOL] width = widths [ [number] ] [EOL] for i in range ( [number] , len ( row ) ) : [EOL] rowtext = VertCatString ( rowtext , width , [string] * COL_SPACE ) [EOL] rowtext = VertCatString ( rowtext , width + COL_SPACE , row [ i ] ) [EOL] [EOL] width = width + COL_SPACE + widths [ i ] [EOL] [EOL] retTableText += string . join ( rowtext , [string] ) [EOL] retTableText += [string] * ROW_SPACE [EOL] [EOL] return re . sub ( [string] , [string] , retTableText ) [EOL] [EOL] [EOL] def VertCatString ( string1 , width1 , string2 ) : [EOL] [docstring] [EOL] lines1 = string1 . split ( [string] ) [EOL] lines2 = string2 . split ( [string] ) [EOL] [EOL] if width1 is None : [EOL] width1 = - [number] [EOL] for line in lines1 : [EOL] width1 = max ( width1 , len ( line ) ) [EOL] [EOL] retlines = [ ] [EOL] for i in range ( [number] , max ( len ( lines1 ) , len ( lines2 ) ) ) : [EOL] if i >= len ( lines1 ) : [EOL] lines1 . append ( [string] * width1 ) [EOL] [EOL] lines1 [ i ] = lines1 [ i ] + [string] * ( width1 - len ( lines1 [ i ] ) ) [EOL] [EOL] if i >= len ( lines2 ) : [EOL] lines2 . append ( [string] ) [EOL] [EOL] retlines . append ( lines1 [ i ] + lines2 [ i ] ) [EOL] [EOL] return string . join ( retlines , [string] ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import vim [EOL] [EOL] import sys [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] from orgmode . py3compat . unicode_compatibility import * [EOL] [EOL] SCOPE_ALL = [number] [EOL] [EOL] [comment] [EOL] SCOPE_GLOBAL = [number] [EOL] [EOL] [comment] [EOL] SCOPE_BUFFER = [number] [EOL] [EOL] VARIABLE_LEADER = { SCOPE_GLOBAL : [string] , SCOPE_BUFFER : [string] } [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def get ( setting , default = None , scope = SCOPE_ALL ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if ( scope & SCOPE_ALL | SCOPE_BUFFER ) and int ( vim . eval ( u_encode ( [string] % setting ) ) ) : [EOL] res = vim . eval ( u_encode ( [string] % setting ) ) [EOL] if type ( res ) in ( unicode , str ) : [EOL] return u_decode ( res ) [EOL] return res [EOL] [EOL] elif ( scope & SCOPE_ALL | SCOPE_GLOBAL ) and int ( vim . eval ( u_encode ( [string] % setting ) ) ) : [EOL] res = vim . eval ( u_encode ( [string] % setting ) ) [EOL] if type ( res ) in ( unicode , str ) : [EOL] return u_decode ( res ) [EOL] return res [EOL] return default [EOL] [EOL] [EOL] def set ( setting , value , scope = SCOPE_GLOBAL , overwrite = False ) : [EOL] [docstring] [EOL] if ( not overwrite ) and ( int ( vim . eval ( u_encode ( [string] % ( VARIABLE_LEADER [ scope ] , setting ) ) ) ) ) : [EOL] res = vim . eval ( u_encode ( [string] % ( VARIABLE_LEADER [ scope ] , setting ) ) ) [EOL] if type ( res ) in ( unicode , str ) : [EOL] return u_decode ( res ) [EOL] return res [EOL] v = repr ( value ) [EOL] if type ( value ) == unicode and sys . version_info < ( [number] , ) : [EOL] [comment] [EOL] v = v [ [number] : ] [EOL] [EOL] cmd = [string] % ( VARIABLE_LEADER [ scope ] , setting , v ) [EOL] vim . command ( u_encode ( cmd ) ) [EOL] return value [EOL] [EOL] [EOL] def unset ( setting , scope = SCOPE_GLOBAL ) : [EOL] [docstring] [EOL] value = get ( setting , scope = scope ) [EOL] cmd = [string] % ( VARIABLE_LEADER [ scope ] , setting ) [EOL] vim . command ( u_encode ( cmd ) ) [EOL] return value [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] class PluginError ( BaseException ) : [EOL] def __init__ ( self , message ) : [EOL] BaseException . __init__ ( self , message ) [EOL] [EOL] [EOL] class BufferNotFound ( BaseException ) : [EOL] def __init__ ( self , message ) : [EOL] BaseException . __init__ ( self , message ) [EOL] [EOL] [EOL] class BufferNotInSync ( BaseException ) : [EOL] def __init__ ( self , message ) : [EOL] BaseException . __init__ ( self , message ) [EOL] [EOL] [EOL] class HeadingDomError ( BaseException ) : [EOL] def __init__ ( self , message ) : [EOL] BaseException . __init__ ( self , message ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Pattern , Any , List [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [EOL] import datetime [EOL] import re [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] [comment] [EOL] _DATE_REGEX = re . compile ( [string] , re . UNICODE ) [EOL] [comment] [EOL] _DATE_PASSIVE_REGEX = re . compile ( [string] , re . UNICODE ) [EOL] [EOL] [comment] [EOL] _DATETIME_REGEX = re . compile ( [string] , re . UNICODE ) [EOL] [comment] [EOL] _DATETIME_PASSIVE_REGEX = re . compile ( [string] , re . UNICODE ) [EOL] [EOL] [comment] [EOL] _DATERANGE_REGEX = re . compile ( [string] [string] , re . UNICODE ) [EOL] [comment] [EOL] _DATETIMERANGE_REGEX = re . compile ( [string] [string] , re . UNICODE ) [EOL] [comment] [EOL] _DATETIMERANGE_SAME_DAY_REGEX = re . compile ( [string] , re . UNICODE ) [EOL] [EOL] [EOL] def get_orgdate ( data ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( data , list ) : [EOL] return _findfirst ( _text2orgdate , data ) [EOL] else : [EOL] return _text2orgdate ( data ) [EOL] [comment] [EOL] return None [EOL] [EOL] [EOL] def _findfirst ( f , seq ) : [EOL] [docstring] [EOL] for found in ( f ( item ) for item in seq if f ( item ) ) : [EOL] return found [EOL] [EOL] [EOL] def _text2orgdate ( string ) : [EOL] [docstring] [EOL] [comment] [EOL] result = _DATETIMERANGE_SAME_DAY_REGEX . search ( string ) [EOL] if result : [EOL] try : [EOL] ( syear , smonth , sday , shour , smin , ehour , emin ) = [ int ( m ) for m in result . groups ( ) ] [EOL] start = datetime . datetime ( syear , smonth , sday , shour , smin ) [EOL] end = datetime . datetime ( syear , smonth , sday , ehour , emin ) [EOL] return OrgTimeRange ( True , start , end ) [EOL] except BaseException : [EOL] return None [EOL] [EOL] [comment] [EOL] result = _DATETIMERANGE_REGEX . search ( string ) [EOL] if result : [EOL] try : [EOL] tmp = [ int ( m ) for m in result . groups ( ) ] [EOL] ( syear , smonth , sday , shour , smin , eyear , emonth , eday , ehour , emin ) = tmp [EOL] start = datetime . datetime ( syear , smonth , sday , shour , smin ) [EOL] end = datetime . datetime ( eyear , emonth , eday , ehour , emin ) [EOL] return OrgTimeRange ( True , start , end ) [EOL] except BaseException : [EOL] return None [EOL] [EOL] [comment] [EOL] result = _DATERANGE_REGEX . search ( string ) [EOL] if result : [EOL] try : [EOL] tmp = [ int ( m ) for m in result . groups ( ) ] [EOL] syear , smonth , sday , eyear , emonth , ehour = tmp [EOL] start = datetime . date ( syear , smonth , sday ) [EOL] end = datetime . date ( eyear , emonth , ehour ) [EOL] return OrgTimeRange ( True , start , end ) [EOL] except BaseException : [EOL] return None [EOL] [EOL] [comment] [EOL] result = _DATETIME_REGEX . search ( string ) [EOL] if result : [EOL] try : [EOL] year , month , day , hour , minutes = [ int ( m ) for m in result . groups ( ) ] [EOL] return OrgDateTime ( True , year , month , day , hour , minutes ) [EOL] except BaseException : [EOL] return None [EOL] [EOL] [comment] [EOL] result = _DATETIME_PASSIVE_REGEX . search ( string ) [EOL] if result : [EOL] try : [EOL] year , month , day , hour , minutes = [ int ( m ) for m in result . groups ( ) ] [EOL] return OrgDateTime ( False , year , month , day , hour , minutes ) [EOL] except BaseException : [EOL] return None [EOL] [EOL] [comment] [EOL] result = _DATE_PASSIVE_REGEX . search ( string ) [EOL] if result : [EOL] try : [EOL] year , month , day = [ int ( m ) for m in result . groups ( ) ] [EOL] return OrgDate ( False , year , month , day ) [EOL] except BaseException : [EOL] return None [EOL] [EOL] [comment] [EOL] result = _DATE_REGEX . search ( string ) [EOL] if result : [EOL] try : [EOL] year , month , day = [ int ( m ) for m in result . groups ( ) ] [EOL] return OrgDate ( True , year , month , day ) [EOL] except BaseException : [EOL] return None [EOL] [EOL] [EOL] class OrgDate ( datetime . date ) : [EOL] [docstring] [EOL] def __init__ ( self , active , year , month , day ) : [EOL] self . active = active [EOL] pass [EOL] [EOL] def __new__ ( cls , active , year , month , day ) : [EOL] return datetime . date . __new__ ( cls , year , month , day ) [EOL] [EOL] def __unicode__ ( self ) : [EOL] [docstring] [EOL] if self . active : [EOL] return self . strftime ( [string] ) [EOL] else : [EOL] return self . strftime ( [string] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return u_encode ( self . __unicode__ ( ) ) [EOL] [EOL] def strftime ( self , fmt ) : [EOL] return u_decode ( datetime . date . strftime ( self , u_encode ( fmt ) ) ) [EOL] [EOL] [EOL] class OrgDateTime ( datetime . datetime ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , active , year , month , day , hour , mins ) : [EOL] self . active = active [EOL] [EOL] def __new__ ( cls , active , year , month , day , hour , minute ) : [EOL] return datetime . datetime . __new__ ( cls , year , month , day , hour , minute ) [EOL] [EOL] def __unicode__ ( self ) : [EOL] [docstring] [EOL] if self . active : [EOL] return self . strftime ( [string] ) [EOL] else : [EOL] return self . strftime ( [string] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return u_encode ( self . __unicode__ ( ) ) [EOL] [EOL] def strftime ( self , fmt ) : [EOL] return u_decode ( datetime . datetime . strftime ( self , u_encode ( fmt ) ) ) [EOL] [EOL] [EOL] class OrgTimeRange ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , active , start , end ) : [EOL] [docstring] [EOL] super ( OrgTimeRange , self ) . __init__ ( ) [EOL] self . start = start [EOL] self . end = end [EOL] self . active = active [EOL] [EOL] def __unicode__ ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . active : [EOL] [comment] [EOL] if isinstance ( self . start , datetime . datetime ) : [EOL] [comment] [EOL] if self . start . year == self . end . year and self . start . month == self . end . month and self . start . day == self . end . day : [EOL] return [string] % ( self . start . strftime ( [string] ) , self . end . strftime ( [string] ) ) [EOL] else : [EOL] return [string] % ( self . start . strftime ( [string] ) , self . end . strftime ( [string] ) ) [EOL] [comment] [EOL] if isinstance ( self . start , datetime . date ) : [EOL] return [string] % ( self . start . strftime ( [string] ) , self . end . strftime ( [string] ) ) [EOL] [comment] [EOL] else : [EOL] if isinstance ( self . start , datetime . datetime ) : [EOL] [comment] [EOL] if self . start . year == self . end . year and self . start . month == self . end . month and self . start . day == self . end . day : [EOL] return [string] % ( self . start . strftime ( [string] ) , self . end . strftime ( [string] ) ) [EOL] else : [EOL] return [string] % ( self . start . strftime ( [string] ) , self . end . strftime ( [string] ) ) [EOL] if isinstance ( self . start , datetime . date ) : [EOL] return [string] % ( self . start . strftime ( [string] ) , self . end . strftime ( [string] ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return u_encode ( self . __unicode__ ( ) ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Dict , Tuple [EOL] import typing [EOL] import sys [EOL] import os [EOL] import mock [EOL] [EOL] [comment] [EOL] MOCK_MODULES = [ [string] ] [EOL] for m in MOCK_MODULES : [EOL] sys . modules [ m ] = mock . Mock ( ) [EOL] [EOL] import vim [EOL] vim . eval = mock . MagicMock ( return_value = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] napoleon_google_docstring = True [EOL] napoleon_numpy_docstring = True [EOL] napoleon_include_private_with_doc = True [EOL] napoleon_include_special_with_doc = True [EOL] napoleon_use_admonition_for_examples = False [EOL] napoleon_use_admonition_for_notes = False [EOL] napoleon_use_admonition_for_references = False [EOL] napoleon_use_ivar = False [EOL] napoleon_use_param = True [EOL] napoleon_use_rtype = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = [string] [EOL] [comment] [EOL] release = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] add_function_parentheses = True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] todo_include_todos = True [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] html_title = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] [EOL] [EOL] [comment] [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_title = project [EOL] epub_author = author [EOL] epub_publisher = author [EOL] epub_copyright = copyright [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] epub_exclude_files = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
try : [EOL] from __builtin__ import xrange as range [EOL] except : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
try : [EOL] unicode [EOL] except NameError : [EOL] basestring = unicode = str [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import sys [EOL] if sys . version_info < ( [number] , ) : [EOL] def u_encode ( string ) : [EOL] return string . encode ( [string] ) [EOL] def u_decode ( string ) : [EOL] return string . decode ( [string] ) [EOL] else : [EOL] def u_encode ( string ) : [EOL] return string [EOL] def u_decode ( string ) : [EOL] return string [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
import sys [EOL] [EOL] if sys . version_info < ( [number] , ) : [EOL] VIM_PY_CALL = [string] [EOL] else : [EOL] VIM_PY_CALL = [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [EOL] [EOL] from typing import Any , List , Tuple , Union [EOL] import typing [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import unittest [EOL] from orgmode . liborgmode . base import Direction [EOL] from orgmode . vimbuffer import VimBuffer [EOL] from orgmode . plugins . Todo import Todo [EOL] [EOL] import vim [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] counter = [number] [EOL] [EOL] class TodoTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [comment] [EOL] global counter [EOL] counter += [number] [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] % counter ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] [EOL] [comment] [EOL] def test_toggle_todo_with_no_heading ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [comment] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] def test_todo_toggle_NOTODO ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . current . buffer [ [number] ] = u_encode ( [string] ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_toggle_todo_in_heading_with_no_todo_state_different_levels ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( ( [number] , [number] ) , vim . current . window . cursor ) [EOL] [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( ( [number] , [number] ) , vim . current . window . cursor ) [EOL] [EOL] def test_circle_through_todo_states ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( ( [number] , [number] ) , vim . current . window . cursor ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( ( [number] , [number] ) , vim . current . window . cursor ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( ( [number] , [number] ) , vim . current . window . cursor ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( ( [number] , [number] ) , vim . current . window . cursor ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( ( [number] , [number] ) , vim . current . window . cursor ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( ( [number] , [number] ) , vim . current . window . cursor ) [EOL] [EOL] def test_circle_through_todo_states_with_more_states ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] def test_toggle_todo_with_cursor_in_text_not_heading ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] Todo . toggle_todo_state ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] def test_get_states_without_seperator ( self ) : [EOL] [docstring] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] states_todo , states_done = VimBuffer ( ) . get_todo_states ( ) [ [number] ] [EOL] expected_todo , expected_done = [ [string] ] , [ [string] ] [EOL] self . assertEqual ( states_todo , expected_todo ) [EOL] self . assertEqual ( states_done , expected_done ) [EOL] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] states_todo , states_done = VimBuffer ( ) . get_todo_states ( ) [ [number] ] [EOL] expected_todo = [ [string] , [string] ] [EOL] expected_done = [ [string] ] [EOL] self . assertEqual ( states_todo , expected_todo ) [EOL] self . assertEqual ( states_done , expected_done ) [EOL] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] states_todo , states_done = VimBuffer ( ) . get_todo_states ( ) [ [number] ] [EOL] expected_todo = [ [string] , [string] , [string] ] [EOL] expected_done = [ [string] ] [EOL] self . assertEqual ( states_todo , expected_todo ) [EOL] self . assertEqual ( states_done , expected_done ) [EOL] [EOL] def test_get_states_with_seperator ( self ) : [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] states_todo , states_done = VimBuffer ( ) . get_todo_states ( ) [ [number] ] [EOL] expected_todo = [ [string] ] [EOL] expected_done = [ [string] ] [EOL] self . assertEqual ( states_todo , expected_todo ) [EOL] self . assertEqual ( states_done , expected_done ) [EOL] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] states_todo , states_done = VimBuffer ( ) . get_todo_states ( ) [ [number] ] [EOL] expected_todo = [ [string] , [string] ] [EOL] expected_done = [ [string] ] [EOL] self . assertEqual ( states_todo , expected_todo ) [EOL] self . assertEqual ( states_done , expected_done ) [EOL] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] states_todo , states_done = VimBuffer ( ) . get_todo_states ( ) [ [number] ] [EOL] expected_todo = [ [string] , [string] , [string] ] [EOL] expected_done = [ [string] ] [EOL] self . assertEqual ( states_todo , expected_todo ) [EOL] self . assertEqual ( states_done , expected_done ) [EOL] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] states_todo , states_done = VimBuffer ( ) . get_todo_states ( ) [ [number] ] [EOL] expected_todo = [ [string] , [string] , [string] ] [EOL] expected_done = [ [string] , [string] ] [EOL] self . assertEqual ( states_todo , expected_todo ) [EOL] self . assertEqual ( states_done , expected_done ) [EOL] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] states_todo , states_done = VimBuffer ( ) . get_todo_states ( ) [ [number] ] [EOL] expected_todo = [ [string] ] [EOL] expected_done = [ [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( states_todo , expected_todo ) [EOL] self . assertEqual ( states_done , expected_done ) [EOL] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] ] [EOL] states_todo , states_done = VimBuffer ( ) . get_todo_states ( ) [ [number] ] [EOL] expected_todo = [ [string] ] [EOL] expected_done = [ [string] ] [EOL] self . assertEqual ( states_todo , expected_todo ) [EOL] self . assertEqual ( states_done , expected_done ) [EOL] [EOL] [comment] [EOL] def test_get_next_state_with_no_current_state ( self ) : [EOL] states = [ ( ( [string] , ) , ( [string] , ) ) ] [EOL] current_state = [string] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , [string] ) [EOL] [EOL] states = [ ( ( [string] , [string] ) , ( [string] , [string] ) ) ] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , [string] ) [EOL] [EOL] states = [ ( ( [string] , ) , ( [string] , [string] ) ) ] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , [string] ) [EOL] [EOL] def test_get_next_state_backward_with_no_current_state ( self ) : [EOL] states = [ ( ( [string] , ) , ( [string] , ) ) ] [EOL] current_state = [string] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) , [string] ) [EOL] [EOL] states = [ ( ( [string] , [string] ) , ( [string] , [string] ) ) ] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) , [string] ) [EOL] [EOL] states = [ ( ( [string] , ) , ( [string] , [string] ) ) ] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) , [string] ) [EOL] [EOL] def test_get_next_state_with_invalid_current_state ( self ) : [EOL] states = [ ( ( [string] , ) , ( [string] , ) ) ] [EOL] current_state = [string] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , [string] ) [EOL] [EOL] states = [ ( ( [string] , [string] ) , ( [string] , [string] ) ) ] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , [string] ) [EOL] [EOL] states = [ ( ( [string] , ) , ( [string] , [string] ) ) ] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , [string] ) [EOL] [EOL] def test_get_next_state_backward_with_invalid_current_state ( self ) : [EOL] states = [ ( ( [string] , ) , ( [string] , ) ) ] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] states = [ ( ( [string] , [string] ) , ( [string] , [string] ) ) ] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] states = [ ( ( [string] , ) , ( [string] , [string] ) ) ] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] def test_get_next_state_with_current_state_equals_todo_state ( self ) : [EOL] states = [ ( ( [string] , [string] , [string] ) , ( [string] , [string] ) ) ] [EOL] current_state = [string] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , [string] ) [EOL] [EOL] current_state = [string] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , [string] ) [EOL] [EOL] def test_get_next_state_backward_with_current_state_equals_todo_state ( self ) : [EOL] states = [ ( ( [string] , [string] , [string] ) , ( [string] , [string] ) ) ] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , None ) [EOL] [EOL] def test_get_next_state_backward_misc ( self ) : [EOL] states = [ ( ( [string] , [string] , [string] ) , ( [string] , [string] ) ) ] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , None ) [EOL] [EOL] current_state = None [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] def test_get_next_state_with_jump_from_todo_to_done ( self ) : [EOL] states = [ ( ( [string] , [string] , [string] ) , ( [string] , [string] ) ) ] [EOL] current_state = [string] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , [string] ) [EOL] [EOL] def test_get_next_state_with_jump_from_done_to_todo ( self ) : [EOL] states = [ ( ( [string] , [string] , [string] ) , ( [string] , [string] ) ) ] [EOL] current_state = [string] [EOL] self . assertEquals ( Todo . _get_next_state ( current_state , states ) , None ) [EOL] [EOL] def test_get_next_state_in_current_sequence ( self ) : [EOL] states = [ ( ( [string] , [string] , [string] ) , ( [string] , [string] ) ) , ( ( [string] , ) , ( [string] , ) ) ] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . FORWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] def test_get_next_state_in_current_sequence_with_access_keys ( self ) : [EOL] states = [ ( ( [string] , [string] , [string] ) , ( [string] , [string] ) ) , ( ( [string] , ) , ( [string] , ) ) ] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . FORWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . FORWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , None ) [EOL] [EOL] current_state = None [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] def test_get_next_keyword_sequence ( self ) : [EOL] states = [ ( ( [string] , [string] , [string] ) , ( [string] , [string] ) ) , ( ( [string] , ) , ( [string] , ) ) ] [EOL] current_state = None [EOL] result = Todo . _get_next_state ( current_state , states , Direction . FORWARD , next_set = True ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = None [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD , next_set = True ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD , next_set = True ) [EOL] self . assertEquals ( result , None ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . FORWARD , next_set = True ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . FORWARD , next_set = True ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . FORWARD , next_set = True ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD , next_set = True ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . FORWARD , next_set = True ) [EOL] self . assertEquals ( result , None ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . FORWARD , next_set = True ) [EOL] self . assertEquals ( result , None ) [EOL] [EOL] current_state = [string] [EOL] result = Todo . _get_next_state ( current_state , states , Direction . BACKWARD , next_set = True ) [EOL] self . assertEquals ( result , [string] ) [EOL] [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( TodoTestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Tuple[builtins.str,builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.str]],typing.Union[typing.Tuple[builtins.str],typing.Tuple[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import unittest [EOL] import orgmode . settings [EOL] from orgmode . exceptions import PluginError [EOL] from orgmode . _vim import ORGMODE [EOL] from orgmode . keybinding import MODE_ALL , Plug [EOL] [EOL] import vim [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] ORG_PLUGINS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class MappingTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] def test_non_overlapping_plug_mappings ( self ) : [EOL] def find_overlapping_mappings ( kb , all_keybindings ) : [EOL] found_overlapping_mapping = False [EOL] for tkb in all_keybindings : [EOL] if kb . mode == tkb . mode or MODE_ALL in ( kb . mode , tkb . mode ) : [EOL] if isinstance ( kb . _action , Plug ) and isinstance ( tkb . _action , Plug ) : [EOL] akb = kb . action [EOL] atkb = tkb . action [EOL] if ( akb . startswith ( atkb ) or atkb . startswith ( akb ) ) and akb != atkb : [EOL] print ( [string] % ( kb . key , akb , tkb . key , atkb ) ) [EOL] found_overlapping_mapping = True [EOL] [EOL] if all_keybindings : [EOL] res = find_overlapping_mappings ( all_keybindings [ [number] ] , all_keybindings [ [number] : ] ) [EOL] if not found_overlapping_mapping : [EOL] return res [EOL] return found_overlapping_mapping [EOL] [EOL] if self . keybindings : [EOL] self . assertFalse ( find_overlapping_mappings ( self . keybindings [ [number] ] , self . keybindings [ [number] : ] ) ) [EOL] [EOL] def setUp ( self ) : [EOL] self . keybindings = [ ] [EOL] [EOL] vim . EVALRESULTS = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , u_encode ( [string] ) : [number] , u_encode ( [string] ) : [number] , u_encode ( [string] ) : ORG_PLUGINS , } [EOL] for plugin in filter ( lambda p : p != [string] , ORG_PLUGINS ) : [EOL] try : [EOL] ORGMODE . register_plugin ( plugin ) [EOL] except PluginError : [EOL] pass [EOL] if plugin in ORGMODE . _plugins : [EOL] self . keybindings . extend ( ORGMODE . _plugins [ plugin ] . keybindings ) [EOL] [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( MappingTestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import vim [EOL] [EOL] from orgmode . _vim import ORGMODE [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] START = True [EOL] END = False [EOL] [EOL] def set_visual_selection ( visualmode , line_start , line_end , col_start = [number] , col_end = [number] , cursor_pos = START ) : [EOL] [EOL] if visualmode not in ( [string] , [string] , [string] ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] vim . EVALRESULTS [ [string] ] = visualmode [EOL] [EOL] [comment] [EOL] vim . EVALRESULTS [ [string] ] = ( [string] , [string] % line_start , [string] % col_start , [string] ) [EOL] vim . EVALRESULTS [ [string] ] = ( [string] , [string] % line_end , [string] % col_end , [string] ) [EOL] if cursor_pos == START : [EOL] vim . current . window . cursor = ( line_start , col_start ) [EOL] else : [EOL] vim . current . window . cursor = ( line_end , col_end ) [EOL] [EOL] [EOL] counter = [number] [EOL] class NavigatorTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] global counter [EOL] counter += [number] [EOL] vim . CMDHISTORY = [ ] [EOL] vim . CMDRESULTS = { } [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] % counter ) , u_encode ( [string] ) : u_encode ( [string] ) , } [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] [EOL] if not [string] in ORGMODE . plugins : [EOL] ORGMODE . register_plugin ( [string] ) [EOL] self . navigator = ORGMODE . plugins [ [string] ] [EOL] [EOL] def test_movement ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_forward_movement ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . next ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] [EOL] def test_backward_movement ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_parent_movement ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertEqual ( self . navigator . parent ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_next_parent_movement ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . navigator . parent_next_sibling ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_forward_movement_visual ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_forward_movement_visual_to_the_end_of_the_file ( self ) : [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertEqual ( self . navigator . next ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_backward_movement_visual ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertNotEqual ( self . navigator . previous ( mode = [string] ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . navigator . previous ( mode = [string] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_parent_movement_visual ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . assertEqual ( self . navigator . parent ( mode = [string] ) , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = START ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . assertEqual ( self . navigator . parent ( mode = [string] ) , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] set_visual_selection ( [string] , [number] , [number] , cursor_pos = END ) [EOL] self . navigator . parent ( mode = [string] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( NavigatorTestCase ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import vim [EOL] [EOL] from orgmode . _vim import ORGMODE [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] PLUGIN_NAME = [string] [EOL] [EOL] bufnr = [number] [EOL] [EOL] def set_vim_buffer ( buf = None , cursor = ( [number] , [number] ) , bufnr = [number] ) : [EOL] if buf is None : [EOL] buf = [ ] [EOL] vim . current . buffer [ : ] = buf [EOL] vim . current . window . cursor = cursor [EOL] vim . current . buffer . number = bufnr [EOL] [EOL] [EOL] counter = [number] [EOL] class EditCheckboxTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] if PLUGIN_NAME not in ORGMODE . plugins : [EOL] ORGMODE . register_plugin ( PLUGIN_NAME ) [EOL] self . editcheckbox = ORGMODE . plugins [ PLUGIN_NAME ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] % counter ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] [EOL] self . c1 = [string] . split ( [string] ) [EOL] [EOL] self . c2 = [string] . split ( [string] ) [EOL] [EOL] self . c3 = [string] . split ( [string] ) [EOL] [EOL] self . c4 = [string] . split ( [string] ) [EOL] [EOL] self . c5 = [string] . split ( [string] ) [EOL] [EOL] def test_toggle ( self ) : [EOL] global bufnr [EOL] bufnr += [number] [EOL] [comment] [EOL] set_vim_buffer ( buf = self . c1 , cursor = ( [number] , [number] ) , bufnr = bufnr ) [EOL] [comment] [EOL] self . editcheckbox . update_checkboxes_status ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [comment] [EOL] self . editcheckbox . toggle ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] bufnr += [number] [EOL] set_vim_buffer ( buf = self . c1 , cursor = ( [number] , [number] ) , bufnr = bufnr ) [EOL] [comment] [EOL] self . editcheckbox . toggle ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] [comment] [EOL] bufnr += [number] [EOL] set_vim_buffer ( buf = self . c1 , cursor = ( [number] , [number] ) , bufnr = bufnr ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . editcheckbox . new_checkbox ( below = True ) [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . editcheckbox . update_checkboxes_status ( ) [EOL] [EOL] def test_no_status_checkbox ( self ) : [EOL] global bufnr [EOL] bufnr += [number] [EOL] [comment] [EOL] set_vim_buffer ( buf = self . c2 , bufnr = bufnr ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . toggle ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] def test_number_list ( self ) : [EOL] global bufnr [EOL] bufnr += [number] [EOL] set_vim_buffer ( buf = self . c3 , bufnr = bufnr ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . toggle ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] def test_new_checkbox ( self ) : [EOL] global bufnr [EOL] bufnr += [number] [EOL] set_vim_buffer ( buf = self . c4 , bufnr = bufnr ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] def test_item_decrement ( self ) : [EOL] global bufnr [EOL] bufnr += [number] [EOL] set_vim_buffer ( buf = self . c5 , bufnr = bufnr ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = False , plain = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = False , plain = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = False , plain = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = False , plain = True ) [EOL] [comment] [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] def test_item_decrementA ( self ) : [EOL] global bufnr [EOL] bufnr += [number] [EOL] set_vim_buffer ( buf = self . c5 , bufnr = bufnr ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = False , plain = True ) [EOL] [comment] [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] def test_item_increment ( self ) : [EOL] global bufnr [EOL] bufnr += [number] [EOL] set_vim_buffer ( buf = self . c5 , bufnr = bufnr ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = True , plain = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = True , plain = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] def test_item_incrementz ( self ) : [EOL] global bufnr [EOL] bufnr += [number] [EOL] set_vim_buffer ( buf = self . c5 , bufnr = bufnr ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = True , plain = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = True , plain = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = True , plain = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . editcheckbox . new_checkbox ( below = True , plain = True ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , [string] ) [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( EditCheckboxTestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List , Tuple [EOL] import typing [EOL] import datetime [EOL] from __future__ import print_function [EOL] [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] from datetime import date [EOL] from datetime import datetime [EOL] [EOL] from orgmode . plugins . Date import Date [EOL] [EOL] [EOL] class DateTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . d = date ( [number] , [number] , [number] ) [EOL] [EOL] def test_modify_time_with_None ( self ) : [EOL] [comment] [EOL] res = Date . _modify_time ( self . d , None ) [EOL] self . assertEquals ( self . d , res ) [EOL] [EOL] def test_modify_time_with_dot ( self ) : [EOL] [comment] [EOL] res = Date . _modify_time ( self . d , [string] ) [EOL] self . assertEquals ( self . d , res ) [EOL] [EOL] def test_modify_time_with_given_relative_days ( self ) : [EOL] [comment] [EOL] test_data = [ ( [string] , self . d ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , self . d ) ] [comment] [EOL] [EOL] for modifier , expected in test_data : [EOL] self . assertEquals ( expected , Date . _modify_time ( self . d , modifier ) ) [EOL] [EOL] def test_modify_time_with_given_relative_days_without_d ( self ) : [EOL] [comment] [EOL] test_data = [ ( [string] , self . d ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) ] [EOL] [EOL] for modifier , expected in test_data : [EOL] result = Date . _modify_time ( self . d , modifier ) [EOL] self . assertEquals ( expected , result ) [EOL] [EOL] def test_modify_time_with_given_relative_weeks ( self ) : [EOL] [comment] [EOL] test_data = [ ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , self . d ) , ( [string] , self . d ) , ( [string] , self . d ) ] [comment] [EOL] [EOL] for modifier , expected in test_data : [EOL] self . assertEquals ( expected , Date . _modify_time ( self . d , modifier ) ) [EOL] [EOL] def test_modify_time_with_given_relative_months ( self ) : [EOL] test_data = [ ( [string] , self . d ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) ] [EOL] [EOL] for modifier , expected in test_data : [EOL] self . assertEquals ( expected , Date . _modify_time ( self . d , modifier ) ) [EOL] [EOL] def test_modify_time_with_given_relative_years ( self ) : [EOL] test_data = [ ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , self . d ) ] [EOL] [EOL] for modifier , expected in test_data : [EOL] self . assertEquals ( expected , Date . _modify_time ( self . d , modifier ) ) [EOL] [EOL] [EOL] def test_modify_time_with_given_weekday ( self ) : [EOL] [comment] [EOL] cust_day = date ( [number] , [number] , [number] ) [comment] [EOL] [comment] [EOL] test_data = [ ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) ] [EOL] [EOL] for modifier , expected in test_data : [EOL] self . assertEquals ( expected , Date . _modify_time ( cust_day , modifier ) ) [EOL] [EOL] def test_modify_time_with_month_and_day ( self ) : [EOL] cust_date = date ( [number] , [number] , [number] ) [EOL] test_data = [ ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ] [EOL] [EOL] for modifier , expected in test_data : [EOL] self . assertEquals ( expected , Date . _modify_time ( cust_date , modifier ) ) [EOL] [EOL] def test_modify_time_with_time ( self ) : [EOL] cust_date = date ( [number] , [number] , [number] ) [EOL] test_data = [ ( [string] , datetime ( [number] , [number] , [number] , [number] , [number] ) ) , ( [string] , datetime ( [number] , [number] , [number] , [number] , [number] ) ) , ( [string] , datetime ( [number] , [number] , [number] , [number] , [number] ) ) , ] [EOL] [EOL] for modifier , expected in test_data : [EOL] res = Date . _modify_time ( cust_date , modifier ) [EOL] self . assertTrue ( isinstance ( res , datetime ) ) [EOL] self . assertEquals ( expected , res ) [EOL] [EOL] def test_modify_time_with_full_dates ( self ) : [EOL] result = Date . _modify_time ( self . d , [string] ) [EOL] expected = date ( [number] , [number] , [number] ) [EOL] self . assertEquals ( expected , result ) [EOL] [EOL] reults = Date . _modify_time ( self . d , [string] ) [EOL] expected = date ( [number] , [number] , [number] ) [EOL] self . assertEquals ( expected , reults ) [EOL] [EOL] cust_date = date ( [number] , [number] , [number] ) [EOL] test_data = [ ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ] [EOL] [EOL] for modifier , expected in test_data : [EOL] self . assertEquals ( expected , Date . _modify_time ( cust_date , modifier ) ) [EOL] [EOL] def test_modify_time_with_only_days ( self ) : [EOL] cust_date = date ( [number] , [number] , [number] ) [EOL] test_data = [ ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ( [string] , date ( [number] , [number] , [number] ) ) , ] [EOL] for modifier , expected in test_data : [EOL] self . assertEquals ( expected , Date . _modify_time ( cust_date , modifier ) ) [EOL] [EOL] def test_modify_time_with_day_and_time ( self ) : [EOL] cust_date = date ( [number] , [number] , [number] ) [EOL] test_data = [ ( [string] , datetime ( [number] , [number] , [number] , [number] , [number] ) ) , ( [string] , datetime ( [number] , [number] , [number] , [number] , [number] ) ) , ( [string] , datetime ( [number] , [number] , [number] , [number] , [number] ) ) , ( [string] , datetime ( [number] , [number] , [number] , [number] , [number] ) ) ] [EOL] for modifier , expected in test_data : [EOL] result = Date . _modify_time ( cust_date , modifier ) [EOL] self . assertEquals ( expected , result ) [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( DateTestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime]]$ 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 $typing.Any$ 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime.date]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,datetime.datetime]]$ 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import vim [EOL] [EOL] from orgmode . _vim import ORGMODE [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] counter = [number] [EOL] class ShowHideTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] global counter [EOL] counter += [number] [EOL] vim . CMDHISTORY = [ ] [EOL] vim . CMDRESULTS = { } [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] % counter ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] if not [string] in ORGMODE . plugins : [EOL] ORGMODE . register_plugin ( [string] ) [EOL] self . showhide = ORGMODE . plugins [ [string] ] [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] [EOL] def test_no_heading_toggle_folding ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( vim . EVALHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_first_heading_with_no_children ( self ) : [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_close_one ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_one ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_close_multiple_all_open ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_all_closed ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_first_level_open ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_second_level_half_open ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_other_second_level_half_open ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_third_level_half_open ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_other_third_level_half_open ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_other_third_level_half_open_second_level_half_closed ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_no_heading_toggle_folding_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( vim . EVALHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_first_heading_with_no_children_reverse ( self ) : [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_close_one_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_one_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_close_multiple_all_open_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_all_closed_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_first_level_open_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_second_level_half_open_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_other_second_level_half_open_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_third_level_half_open_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_other_third_level_half_open_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_toggle_folding_open_multiple_other_third_level_half_open_second_level_half_closed_reverse ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS . update ( { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , } ) [EOL] self . assertNotEqual ( self . showhide . toggle_folding ( reverse = True ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( ShowHideTestCase ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] from orgmode . liborgmode . base import Direction , get_domobj_range [EOL] from orgmode . liborgmode . headings import Heading [EOL] [EOL] [EOL] class LibBaseTestCase ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . case1 = [string] . split ( [string] ) [EOL] [EOL] def test_base_functions ( self ) : [EOL] [comment] [EOL] ( start , end ) = get_domobj_range ( content = self . case1 , position = [number] , identify_fun = Heading . identify_heading ) [EOL] self . assertEqual ( ( start , end ) , ( [number] , [number] ) ) [EOL] ( start , end ) = get_domobj_range ( content = self . case1 , position = [number] , direction = Direction . BACKWARD , identify_fun = Heading . identify_heading ) [EOL] self . assertEqual ( ( start , end ) , ( [number] , [number] ) ) [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( LibBaseTestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import unittest [EOL] import test_vimbuffer [EOL] [EOL] import test_libagendafilter [EOL] import test_libcheckbox [EOL] import test_libbase [EOL] import test_libheading [EOL] import test_liborgdate [EOL] import test_liborgdate_utf8 [EOL] import test_liborgdate_parsing [EOL] import test_liborgdatetime [EOL] import test_liborgtimerange [EOL] [EOL] import test_plugin_date [EOL] import test_plugin_edit_structure [EOL] import test_plugin_edit_checkbox [EOL] import test_plugin_misc [EOL] import test_plugin_navigator [EOL] import test_plugin_show_hide [EOL] import test_plugin_tags_properties [EOL] import test_plugin_todo [EOL] import test_plugin_mappings [EOL] [EOL] import unittest [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] tests = unittest . TestSuite ( ) [EOL] [EOL] tests . addTests ( test_vimbuffer . suite ( ) ) [EOL] [EOL] [comment] [EOL] tests . addTests ( test_libbase . suite ( ) ) [EOL] tests . addTests ( test_libcheckbox . suite ( ) ) [EOL] tests . addTests ( test_libagendafilter . suite ( ) ) [EOL] tests . addTests ( test_libheading . suite ( ) ) [EOL] tests . addTests ( test_liborgdate . suite ( ) ) [EOL] tests . addTests ( test_liborgdate_utf8 . suite ( ) ) [EOL] tests . addTests ( test_liborgdate_parsing . suite ( ) ) [EOL] tests . addTests ( test_liborgdatetime . suite ( ) ) [EOL] tests . addTests ( test_liborgtimerange . suite ( ) ) [EOL] [EOL] [comment] [EOL] tests . addTests ( test_plugin_date . suite ( ) ) [EOL] tests . addTests ( test_plugin_edit_structure . suite ( ) ) [EOL] tests . addTests ( test_plugin_edit_checkbox . suite ( ) ) [EOL] tests . addTests ( test_plugin_misc . suite ( ) ) [EOL] tests . addTests ( test_plugin_navigator . suite ( ) ) [EOL] tests . addTests ( test_plugin_show_hide . suite ( ) ) [EOL] tests . addTests ( test_plugin_tags_properties . suite ( ) ) [EOL] tests . addTests ( test_plugin_todo . suite ( ) ) [EOL] tests . addTests ( test_plugin_mappings . suite ( ) ) [EOL] [EOL] runner = unittest . TextTestRunner ( ) [EOL] runner . run ( tests ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 0 0 0 0 $unittest.runner.TextTestRunner$ 0 0 0 $unittest.suite.TestSuite$ 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import vim [EOL] [EOL] from orgmode . _vim import ORGMODE [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] counter = [number] [EOL] class EditStructureTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] global counter [EOL] counter += [number] [EOL] vim . CMDHISTORY = [ ] [EOL] vim . CMDRESULTS = { } [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] % counter ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] if not [string] in ORGMODE . plugins : [EOL] ORGMODE . register_plugin ( [string] ) [EOL] self . editstructure = ORGMODE . plugins [ [string] ] [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] [EOL] def test_new_heading_below_normal_behavior ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_above_normal_behavior ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = False ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . current . buffer [ [number] ] = u_encode ( [string] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True , insert_mode = False ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below_insert_mode ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below_split_text_at_the_end ( self ) : [EOL] vim . current . buffer [ [number] ] = u_encode ( [string] ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below_split_text_at_the_end_insert_parts ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below_in_the_middle ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below_in_the_middle2 ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below_in_the_middle3 ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below_at_the_end ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( len ( vim . current . buffer ) , [number] ) [EOL] [EOL] def test_new_heading_above ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = False , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_above_in_the_middle ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = False , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_above_in_the_middle2 ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = False , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_above_in_the_middle3 ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = False , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_above_at_the_end ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = False , insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below_split_heading_title ( self ) : [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_new_heading_below_split_heading_title_with_todo ( self ) : [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( insert_mode = True ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_demote_heading ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . demote_heading ( ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [comment] [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_demote_newly_created_level_one_heading ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . demote_heading ( ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_demote_newly_created_level_two_heading ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . new_heading ( below = True ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . demote_heading ( including_children = False , on_heading = True ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_demote_last_heading ( self ) : [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = ORGMODE . get_document ( ) . current_heading ( ) [EOL] self . assertNotEqual ( self . editstructure . demote_heading ( ) , None ) [EOL] self . assertEqual ( h . end , [number] ) [EOL] self . assertFalse ( vim . CMDHISTORY ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_promote_heading ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . promote_heading ( ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [comment] [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , - [number] ) ) [EOL] [EOL] def test_promote_level_one_heading ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertEqual ( self . editstructure . promote_heading ( ) , None ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_demote_parent_heading ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . demote_heading ( ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_promote_parent_heading ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . assertNotEqual ( self . editstructure . promote_heading ( ) , None ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , - [number] ) ) [EOL] [EOL] [comment] [EOL] def test_demote_parent_heading_count ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ [string] ] = u_encode ( [string] ) [EOL] self . assertNotEqual ( self . editstructure . demote_heading ( ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , [number] ) ) [EOL] [EOL] def test_promote_parent_heading ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ [string] ] = u_encode ( [string] ) [EOL] self . assertNotEqual ( self . editstructure . promote_heading ( ) , None ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . window . cursor , ( [number] , - [number] ) ) [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( EditStructureTestCase ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import datetime [EOL] import sys [EOL] import unittest [EOL] from datetime import date [EOL] [EOL] sys . path . append ( [string] ) [EOL] from orgmode . liborgmode . orgdate import OrgDate [EOL] [EOL] from orgmode . py3compat . unicode_compatibility import * [EOL] [EOL] class OrgDateTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . date = date ( [number] , [number] , [number] ) [EOL] self . year = [number] [EOL] self . month = [number] [EOL] self . day = [number] [EOL] self . text = [string] [EOL] self . textinactive = [string] [EOL] [EOL] def test_OrgDate_ctor_active ( self ) : [EOL] [docstring] [EOL] today = date . today ( ) [EOL] od = OrgDate ( True , today . year , today . month , today . day ) [EOL] self . assertTrue ( isinstance ( od , OrgDate ) ) [EOL] self . assertTrue ( od . active ) [EOL] [EOL] def test_OrgDate_ctor_inactive ( self ) : [EOL] [docstring] [EOL] today = date . today ( ) [EOL] od = OrgDate ( False , today . year , today . month , today . day ) [EOL] self . assertTrue ( isinstance ( od , OrgDate ) ) [EOL] self . assertFalse ( od . active ) [EOL] [EOL] def test_OrdDate_str_active ( self ) : [EOL] [docstring] [EOL] od = OrgDate ( True , self . year , self . month , self . day ) [EOL] self . assertEqual ( self . text , unicode ( od ) ) [EOL] [EOL] def test_OrdDate_str_inactive ( self ) : [EOL] od = OrgDate ( False , self . year , self . month , self . day ) [EOL] self . assertEqual ( self . textinactive , unicode ( od ) ) [EOL] [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( OrgDateTestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import datetime [EOL] import sys [EOL] import unittest [EOL] from datetime import date [EOL] from datetime import datetime [EOL] [EOL] sys . path . append ( [string] ) [EOL] from orgmode . liborgmode . orgdate import OrgTimeRange [EOL] [EOL] [EOL] class OrgTimeRangeTestCase ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . date = date ( [number] , [number] , [number] ) [EOL] self . year = [number] [EOL] self . month = [number] [EOL] self . day = [number] [EOL] self . text = [string] [EOL] self . textinactive = [string] [EOL] [EOL] def test_OrgTimeRange_ctor_active ( self ) : [EOL] [docstring] [EOL] start = date ( [number] , [number] , [number] ) [EOL] end = date ( [number] , [number] , [number] ) [EOL] timerange = OrgTimeRange ( True , start , end ) [EOL] self . assertTrue ( isinstance ( timerange , OrgTimeRange ) ) [EOL] self . assertTrue ( timerange . active ) [EOL] [EOL] def test_OrgTimeRange_ctor_inactive ( self ) : [EOL] [docstring] [EOL] start = date ( [number] , [number] , [number] ) [EOL] end = date ( [number] , [number] , [number] ) [EOL] timerange = OrgTimeRange ( False , start , end ) [EOL] self . assertTrue ( isinstance ( timerange , OrgTimeRange ) ) [EOL] self . assertFalse ( timerange . active ) [EOL] [EOL] def test_OrdDate_str_active ( self ) : [EOL] [docstring] [EOL] start = date ( [number] , [number] , [number] ) [EOL] end = date ( [number] , [number] , [number] ) [EOL] timerange = OrgTimeRange ( True , start , end ) [EOL] expected = [string] [EOL] self . assertEqual ( str ( timerange ) , expected ) [EOL] [EOL] start = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] end = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] timerange = OrgTimeRange ( True , start , end ) [EOL] expected = [string] [EOL] self . assertEqual ( str ( timerange ) , expected ) [EOL] [EOL] start = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] end = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] timerange = OrgTimeRange ( True , start , end ) [EOL] expected = [string] [EOL] self . assertEqual ( str ( timerange ) , expected ) [EOL] [EOL] def test_OrdDate_str_inactive ( self ) : [EOL] [docstring] [EOL] start = date ( [number] , [number] , [number] ) [EOL] end = date ( [number] , [number] , [number] ) [EOL] timerange = OrgTimeRange ( False , start , end ) [EOL] expected = [string] [EOL] self . assertEqual ( str ( timerange ) , expected ) [EOL] [EOL] start = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] end = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] timerange = OrgTimeRange ( False , start , end ) [EOL] expected = [string] [EOL] self . assertEqual ( str ( timerange ) , expected ) [EOL] [EOL] start = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] end = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] timerange = OrgTimeRange ( False , start , end ) [EOL] expected = [string] [EOL] self . assertEqual ( str ( timerange ) , expected ) [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( OrgTimeRangeTestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime.date$ 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime.date$ 0 $datetime.datetime.date$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import vim [EOL] [EOL] from orgmode . liborgmode . headings import Heading [EOL] from orgmode . vimbuffer import VimBuffer [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] from orgmode . py3compat . unicode_compatibility import * [EOL] [EOL] counter = [number] [EOL] class VimBufferTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] global counter [EOL] counter += [number] [EOL] vim . CMDHISTORY = [ ] [EOL] vim . CMDRESULTS = { } [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] % counter ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] self . document = VimBuffer ( ) . init_dom ( ) [EOL] [EOL] def test_write_heading_tags ( self ) : [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] h = self . document . find_heading ( ) [EOL] self . assertEqual ( h . _orig_start , [number] ) [EOL] self . assertEqual ( h . title , [string] ) [EOL] h . tags = [ [string] , [string] ] [EOL] self . assertEqual ( h . tags [ [number] ] , [string] ) [EOL] self . document . write_heading ( h ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] h2 = self . document . find_heading ( ) [EOL] self . assertEqual ( d . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . tags [ [number] ] , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] [EOL] def test_write_multi_heading_bodies ( self ) : [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] h = self . document . headings [ [number] ] . copy ( ) [EOL] self . assertEqual ( h . _orig_start , [number] ) [EOL] self . assertEqual ( h . title , [string] ) [EOL] h . body . append ( [string] ) [EOL] h . children [ [number] ] . body . append ( [string] ) [EOL] self . document . write_heading ( h ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] h2 = self . document . find_heading ( ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . body ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children [ [number] ] . body ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children [ [number] ] . body ) , [number] ) [EOL] [EOL] def test_meta_information_assign_directly ( self ) : [EOL] [comment] [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] [EOL] [comment] [EOL] self . document . meta_information [ [number] ] = [string] [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . is_dirty_meta_information , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] [EOL] def test_meta_information_assign_string ( self ) : [EOL] [comment] [EOL] self . document . meta_information = [string] [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . is_dirty_meta_information , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] [EOL] def test_meta_information_assign_multi_line_string ( self ) : [EOL] [comment] [EOL] self . document . meta_information = [string] [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . is_dirty_meta_information , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] [EOL] def test_meta_information_assign_one_element_array ( self ) : [EOL] [comment] [EOL] self . document . meta_information = [string] . split ( [string] ) [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . is_dirty_meta_information , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] [EOL] def test_meta_information_assign_multi_element_array ( self ) : [EOL] [comment] [EOL] self . document . meta_information = [string] . split ( [string] ) [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . is_dirty_meta_information , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] [EOL] def test_meta_information_read_no_meta_information ( self ) : [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] self . document = VimBuffer ( ) . init_dom ( ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( self . document . meta_information , [ ] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] [EOL] [comment] [EOL] self . document . meta_information = [string] . split ( [string] ) [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] [EOL] def test_meta_information_assign_empty_array ( self ) : [EOL] [comment] [EOL] self . document . meta_information = [ ] [EOL] self . assertEqual ( self . document . meta_information , [ ] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] [EOL] def test_meta_information_assign_empty_string ( self ) : [EOL] [comment] [EOL] self . document . meta_information = [string] [EOL] self . assertEqual ( self . document . meta_information , [ [string] ] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] [EOL] def test_bufnr ( self ) : [EOL] self . assertEqual ( self . document . bufnr , vim . current . buffer . number ) [EOL] [comment] [EOL] [EOL] def test_write_meta_information ( self ) : [EOL] [comment] [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . write ( ) , False ) [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . document . meta_information = [string] . split ( [string] ) [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( [string] . join ( VimBuffer ( ) . init_dom ( ) . meta_information ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . document . meta_information = [string] . split ( [string] ) [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( [string] . join ( VimBuffer ( ) . init_dom ( ) . meta_information ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . document . meta_information = [string] [EOL] self . assertEqual ( [string] . join ( self . document . meta_information ) , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( [string] . join ( VimBuffer ( ) . init_dom ( ) . meta_information ) , [string] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . document . meta_information = [ ] [EOL] self . assertEqual ( self . document . meta_information , [ ] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( VimBuffer ( ) . init_dom ( ) . meta_information , [ ] ) [EOL] [EOL] def test_write_changed_title ( self ) : [EOL] [comment] [EOL] self . document . headings [ [number] ] . title = [string] [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . is_dirty_meta_information , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_body , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_heading , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( VimBuffer ( ) . init_dom ( ) . headings [ [number] ] . title , [string] ) [EOL] [EOL] def test_write_changed_body ( self ) : [EOL] [comment] [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . document . headings [ [number] ] . body [ [number] ] = [string] [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . is_dirty_meta_information , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_body , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_heading , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . body , [ [string] , [string] , [string] ] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( VimBuffer ( ) . init_dom ( ) . headings [ [number] ] . body , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_write_shortened_body ( self ) : [EOL] [comment] [EOL] self . document . headings [ [number] ] . body = [string] [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . is_dirty_meta_information , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_body , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_heading , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . body , [ [string] ] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( VimBuffer ( ) . init_dom ( ) . headings [ [number] ] . body , [ [string] ] ) [EOL] [EOL] def test_write_lengthened_body ( self ) : [EOL] [comment] [EOL] self . document . headings [ [number] ] . body = [ [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . is_dirty_meta_information , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_body , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_heading , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . body , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( VimBuffer ( ) . init_dom ( ) . headings [ [number] ] . body , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_write_delete_heading ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] del self . document . headings [ [number] ] . children [ [number] ] [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_len , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_len , [number] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . _orig_len , [number] ) [EOL] [EOL] def test_write_delete_first_heading ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] del self . document . headings [ [number] ] [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_len , [number] ) [EOL] [EOL] def test_write_delete_last_heading ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] del self . document . headings [ - [number] ] [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end_of_last_child , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . end , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . end_of_last_child , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end_of_last_child , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . end , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . end_of_last_child , [number] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . end_of_last_child , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . _orig_len , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . end , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . end_of_last_child , [number] ) [EOL] [EOL] def test_write_delete_multiple_headings ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] del self . document . headings [ [number] ] [EOL] del self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] [EOL] del self . document . headings [ [number] ] . children [ [number] ] [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end_of_last_child , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . start , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . end_of_last_child , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . title , [string] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . end , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . end_of_last_child , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . title , [string] ) [EOL] [EOL] [EOL] def test_write_add_heading ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] h = Heading ( ) [EOL] h . title = [string] [EOL] h . level = [number] [EOL] h . body = [string] [EOL] self . document . headings [ [number] ] . children . append ( h ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ - [number] ] . title , [string] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ - [number] ] . title , [string] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ - [number] ] . title , [string] ) [EOL] [EOL] def test_write_add_heading_before_first_heading ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] h = Heading ( ) [EOL] h . title = [string] [EOL] h . level = [number] [EOL] h . body = [string] [EOL] self . assertEqual ( h . start , None ) [EOL] self . document . headings [ [number] : [number] ] = h [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] ) , [number] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( d . headings ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . start , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] ) , [number] ) [EOL] [EOL] def test_write_add_heading_after_last_heading_toplevel ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] h = Heading ( ) [EOL] h . title = [string] [EOL] h . body = [string] [EOL] self . assertEqual ( h . start , None ) [EOL] [comment] [EOL] self . document . headings . append ( h ) [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ - [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ - [number] ] ) , [number] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( d . headings ) , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( len ( d . headings [ - [number] ] ) , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( len ( d . headings [ - [number] ] ) , [number] ) [EOL] [EOL] def test_write_add_heading_after_last_heading_subheading ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] h = Heading ( ) [EOL] h . title = [string] [EOL] h . level = [number] [EOL] h . body = [string] [EOL] self . assertEqual ( h . start , None ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . document . headings [ - [number] ] . children . append ( h ) [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ - [number] ] ) , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . children [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . children [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . children [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ - [number] ] . children [ - [number] ] ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ - [number] ] ) , [number] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( d . headings ) , [number] ) [EOL] self . assertEqual ( len ( d . headings [ - [number] ] ) , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . children [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . children [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . children [ - [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( len ( d . headings [ - [number] ] . children [ - [number] ] ) , [number] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ - [number] ] . start , [number] ) [EOL] self . assertEqual ( len ( d . headings [ - [number] ] ) , [number] ) [EOL] [EOL] def test_write_replace_one_heading ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] h = Heading ( ) [EOL] h . title = [string] [EOL] h . level = [number] [EOL] h . body = [string] [EOL] self . assertEqual ( h . start , None ) [EOL] self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] = h [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ - [number] ] . start , [number] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( d . headings ) , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . _orig_start , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] ) , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children [ [number] ] ) , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ - [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ - [number] ] . start , [number] ) [EOL] [EOL] def test_write_replace_multiple_headings_with_one_heading ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] h = Heading ( ) [EOL] h . title = [string] [EOL] h . level = [number] [EOL] h . body = [string] [EOL] [EOL] self . assertEqual ( h . start , None ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . document . headings [ [number] ] . children [ [number] ] . children [ : ] = h [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . is_dirty , False ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] [EOL] def test_write_replace_multiple_headings_with_a_multiple_heading_structure ( self ) : [EOL] [comment] [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] h = Heading ( ) [EOL] h . title = [string] [EOL] h . level = [number] [EOL] h . body = [string] [EOL] h1 = Heading ( ) [EOL] h1 . title = [string] [EOL] h1 . level = [number] [EOL] h1 . body = [string] [EOL] h . children . append ( h1 ) [EOL] h2 = Heading ( ) [EOL] h2 . title = [string] [EOL] h2 . level = [number] [EOL] h2 . body = [string] [EOL] [EOL] self . assertEqual ( h . start , None ) [EOL] self . document . headings [ [number] ] . children [ [number] ] . children [ : ] = ( h , h2 ) [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( h1 . start , [number] ) [EOL] self . assertEqual ( h2 . start , [number] ) [EOL] self . assertEqual ( self . document . is_dirty , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . is_dirty , False ) [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] self . assertEqual ( self . document . is_dirty , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . children [ [number] ] . children [ [number] ] . start , [number] ) [EOL] [EOL] def test_dom ( self ) : [EOL] self . assertEqual ( len ( self . document . headings ) , [number] ) [EOL] for h in self . document . headings : [EOL] self . assertEqual ( h . level , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertEqual ( h , None ) [EOL] [EOL] def test_index_boundaries ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( - [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertEqual ( h , None ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . level , [number] ) [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertNotEqual ( h . previous_sibling , None ) [EOL] self . assertEqual ( h . previous_sibling . level , [number] ) [EOL] self . assertEqual ( h . parent , None ) [EOL] self . assertEqual ( h . next_sibling , None ) [EOL] self . assertEqual ( len ( h . children ) , [number] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertEqual ( h , None ) [EOL] [EOL] def test_heading_start_and_end ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( h . end , [number] ) [EOL] self . assertEqual ( h . end_of_last_child , [number] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( h . end , [number] ) [EOL] self . assertEqual ( h . end_of_last_child , [number] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( h . end , [number] ) [EOL] self . assertEqual ( h . end_of_last_child , [number] ) [EOL] [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] self . document = VimBuffer ( ) . init_dom ( ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . parent , None ) [EOL] self . assertEqual ( h . level , [number] ) [EOL] self . assertEqual ( h . title , [string] ) [EOL] self . assertEqual ( len ( h . children ) , [number] ) [EOL] self . assertEqual ( h . children [ [number] ] . start , [number] ) [EOL] self . assertEqual ( h . children [ [number] ] . children , [ ] ) [EOL] self . assertEqual ( h . children [ [number] ] . next_sibling , None ) [EOL] self . assertEqual ( h . children [ [number] ] . end , [number] ) [EOL] self . assertEqual ( h . start , [number] ) [EOL] self . assertEqual ( h . end , [number] ) [EOL] self . assertEqual ( h . end_of_last_child , [number] ) [EOL] [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] self . document = VimBuffer ( ) . init_dom ( ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . end , [number] ) [EOL] self . assertEqual ( h . end_of_last_child , [number] ) [EOL] self . assertEqual ( h . title , [string] ) [EOL] [EOL] def test_first_heading ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . parent , None ) [EOL] self . assertEqual ( h . level , [number] ) [EOL] self . assertEqual ( len ( h . children ) , [number] ) [EOL] self . assertEqual ( h . previous_sibling , None ) [EOL] [EOL] self . assertEqual ( h . children [ [number] ] . level , [number] ) [EOL] self . assertEqual ( h . children [ [number] ] . children , [ ] ) [EOL] self . assertEqual ( h . children [ [number] ] . level , [number] ) [EOL] self . assertEqual ( len ( h . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( h . children [ [number] ] . children [ [number] ] . level , [number] ) [EOL] self . assertEqual ( h . children [ [number] ] . children [ [number] ] . level , [number] ) [EOL] [EOL] self . assertEqual ( h . next_sibling . level , [number] ) [EOL] [EOL] self . assertEqual ( h . next_sibling . next_sibling . level , [number] ) [EOL] [EOL] self . assertEqual ( h . next_sibling . next_sibling . next_sibling , None ) [EOL] self . assertEqual ( h . next_sibling . next_sibling . parent , None ) [EOL] [EOL] def test_heading_in_the_middle ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . level , [number] ) [EOL] self . assertEqual ( h . parent . level , [number] ) [EOL] self . assertNotEqual ( h . next_sibling , None ) [EOL] self . assertNotEqual ( h . next_sibling . previous_sibling , None ) [EOL] self . assertEqual ( h . next_sibling . level , [number] ) [EOL] self . assertEqual ( h . previous_sibling , None ) [EOL] [EOL] def test_previous_headings ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . level , [number] ) [EOL] self . assertNotEqual ( h . previous_sibling , None ) [EOL] self . assertEqual ( h . parent . level , [number] ) [EOL] self . assertNotEqual ( h . parent . previous_sibling , None ) [EOL] self . assertNotEqual ( h . previous_sibling . parent , None ) [EOL] self . assertEqual ( h . previous_sibling . parent . start , [number] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertNotEqual ( h . parent , None ) [EOL] self . assertEqual ( h . parent . start , [number] ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertNotEqual ( h , None ) [EOL] self . assertEqual ( h . level , [number] ) [EOL] self . assertNotEqual ( h . previous_sibling , None ) [EOL] self . assertEqual ( h . previous_sibling . level , [number] ) [EOL] self . assertNotEqual ( h . previous_sibling . previous_sibling , None ) [EOL] self . assertEqual ( h . previous_sibling . previous_sibling . level , [number] ) [EOL] self . assertEqual ( h . previous_sibling . previous_sibling . previous_sibling , None ) [EOL] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] h = self . document . current_heading ( ) [EOL] self . assertEqual ( h , None ) [EOL] [EOL] class VimBufferTagsTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] global counter [EOL] counter += [number] [EOL] vim . CMDHISTORY = [ ] [EOL] vim . CMDRESULTS = { } [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] self . document = VimBuffer ( ) . init_dom ( ) [EOL] [EOL] def test_tag_read_no_word_with_tags ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . tags [ [number] ] , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , None ) [EOL] [EOL] def test_tag_read_one_word_with_tags ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . tags [ [number] ] , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , None ) [EOL] [EOL] def test_tag_read_TODO_with_tags ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . tags [ [number] ] , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] [EOL] def test_tag_read_one ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . tags [ [number] ] , [string] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_tag_read_multiple ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . tags , [ [string] , [string] ] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] . children [ [number] ] ) , [string] ) [EOL] [EOL] def test_tag_no_tags ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children [ [number] ] . children [ [number] ] . tags ) , [number] ) [EOL] [EOL] def test_tag_read_space_and_tab_separated ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . tags , [ [string] , [string] ] ) [EOL] [EOL] def test_tag_read_tab_separated ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . tags , [ [string] , [string] ] ) [EOL] [EOL] def test_tag_read_long_title ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . tags , [ [string] , [string] ] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_tag_read_long_title_plus_todo_state ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . children ) , [number] ) [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . level , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . tags , [ [string] ] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_tag_del_tags ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] del self . document . headings [ [number] ] . tags [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_heading , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_body , False ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( d . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_tag_replace_one_tag ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . document . headings [ [number] ] . tags = [ [string] ] [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_heading , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_body , False ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . tags , [ [string] ] ) [EOL] self . assertEqual ( d . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( d . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_tag_replace_multiple_tags ( self ) : [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . document . headings [ [number] ] . tags = [ [string] , [string] , [string] ] [EOL] self . assertEqual ( len ( self . document . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_heading , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_body , False ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( len ( d . headings [ [number] ] . tags ) , [number] ) [EOL] self . assertEqual ( d . headings [ [number] ] . tags , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( d . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( d . headings [ [number] ] ) , [string] ) [EOL] [EOL] class VimBufferTodoTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] global counter [EOL] counter += [number] [EOL] vim . CMDHISTORY = [ ] [EOL] vim . CMDRESULTS = { } [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] self . document = VimBuffer ( ) . init_dom ( ) [EOL] [EOL] def test_no_space_after_upper_case_single_word_heading ( self ) : [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( unicode ( d . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_todo_read_TODO ( self ) : [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_todo_read_TODO_NOTODO ( self ) : [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . children [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] . children [ [number] ] ) , [string] ) [EOL] [EOL] def test_todo_read_WAITING ( self ) : [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_todo_read_DONE ( self ) : [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_todo_read_special ( self ) : [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , None ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] [EOL] def test_todo_del_todo ( self ) : [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] del self . document . headings [ [number] ] . todo [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_body , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_heading , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , None ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( d . headings [ [number] ] . todo , None ) [EOL] self . assertEqual ( d . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( d . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_todo_write_todo_uppercase ( self ) : [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . document . headings [ [number] ] . todo = [string] [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_body , False ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . is_dirty_heading , True ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( self . document . headings [ [number] ] ) , [string] ) [EOL] self . assertEqual ( self . document . write ( ) , True ) [EOL] [EOL] [comment] [EOL] d = VimBuffer ( ) . init_dom ( ) [EOL] self . assertEqual ( d . headings [ [number] ] . todo , [string] ) [EOL] self . assertEqual ( d . headings [ [number] ] . title , [string] ) [EOL] self . assertEqual ( unicode ( d . headings [ [number] ] ) , [string] ) [EOL] [EOL] def test_todo_set_illegal_todo ( self ) : [EOL] def set_todo ( todo ) : [EOL] self . document . headings [ [number] ] . todo = todo [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] self . assertRaises ( ValueError , set_todo , [string] ) [EOL] self . assertRaises ( ValueError , set_todo , [string] ) [EOL] self . assertRaises ( ValueError , set_todo , [string] ) [EOL] self . assertRaises ( ValueError , set_todo , [string] ) [EOL] self . assertEqual ( self . document . headings [ [number] ] . todo , [string] ) [EOL] [EOL] def suite ( ) : [EOL] return ( unittest . TestLoader ( ) . loadTestsFromTestCase ( VimBufferTestCase ) , unittest . TestLoader ( ) . loadTestsFromTestCase ( VimBufferTagsTestCase ) , unittest . TestLoader ( ) . loadTestsFromTestCase ( VimBufferTodoTestCase ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import vim [EOL] from orgmode . liborgmode . checkboxes import Checkbox [EOL] from orgmode . _vim import ORGMODE [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] def set_vim_buffer ( buf = None , cursor = ( [number] , [number] ) , bufnr = [number] ) : [EOL] if buf is None : [EOL] buf = [ ] [EOL] vim . current . buffer [ : ] = buf [EOL] vim . current . window . cursor = cursor [EOL] vim . current . buffer . number = bufnr [EOL] [EOL] [EOL] class CheckboxTestCase ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] counter = [number] [EOL] vim . CMDHISTORY = [ ] [EOL] vim . CMDRESULTS = { } [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] % counter ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] [EOL] self . c1 = [string] . split ( [string] ) [EOL] [EOL] self . c2 = [string] . split ( [string] ) [EOL] [EOL] def test_init ( self ) : [EOL] [comment] [EOL] c = Checkbox ( level = [number] , title = [string] ) [EOL] self . assertEqual ( str ( c ) , [string] ) [EOL] c = Checkbox ( level = [number] , title = [string] , status = [string] ) [EOL] self . assertEqual ( str ( c ) , [string] ) [EOL] [EOL] def test_basic ( self ) : [EOL] bufnr = [number] [EOL] set_vim_buffer ( buf = self . c1 , bufnr = bufnr ) [EOL] h = ORGMODE . get_document ( bufnr = bufnr ) . current_heading ( ) [EOL] h . init_checkboxes ( ) [EOL] [EOL] c = h . current_checkbox ( position = [number] ) [EOL] self . assertEqual ( str ( c ) , self . c1 [ [number] ] ) [EOL] self . assertFalse ( c . are_children_all ( Checkbox . STATUS_ON ) ) [EOL] self . assertTrue ( c . is_child_one ( Checkbox . STATUS_OFF ) ) [EOL] self . assertFalse ( c . are_siblings_all ( Checkbox . STATUS_ON ) ) [EOL] [EOL] for child in c . all_children ( ) : [EOL] pass [EOL] for sibling in c . all_siblings ( ) : [EOL] pass [EOL] c = h . current_checkbox ( position = [number] ) [EOL] new_checkbox = c . copy ( ) [EOL] self . assertEqual ( str ( c ) , self . c1 [ [number] ] ) [EOL] c . get_parent_list ( ) [EOL] c . get_index_in_parent_list ( ) [EOL] [EOL] def test_identify ( self ) : [EOL] [comment] [EOL] self . assertEqual ( Checkbox . identify_checkbox ( self . c1 [ [number] ] ) , [number] ) [EOL] self . assertEqual ( Checkbox . identify_checkbox ( self . c1 [ [number] ] ) , [number] ) [EOL] [comment] [EOL] self . assertEqual ( Checkbox . identify_checkbox ( [string] ) , [number] ) [EOL] [EOL] def test_toggle ( self ) : [EOL] bufnr = [number] [EOL] [comment] [EOL] set_vim_buffer ( buf = self . c1 , bufnr = bufnr ) [EOL] h = ORGMODE . get_document ( bufnr = bufnr ) . current_heading ( ) [EOL] h . init_checkboxes ( ) [EOL] [EOL] [comment] [EOL] c = h . current_checkbox ( position = [number] ) [EOL] c . toggle ( ) [EOL] self . assertEqual ( str ( c ) , [string] ) [EOL] c . toggle ( ) [EOL] self . assertEqual ( str ( c ) , [string] ) [EOL] [EOL] ( total , on ) = c . all_siblings_status ( ) [EOL] self . assertEqual ( ( total , on ) , ( [number] , [number] ) ) [EOL] [EOL] def test_subtasks ( self ) : [EOL] bufnr = [number] [EOL] set_vim_buffer ( buf = self . c1 , bufnr = bufnr ) [EOL] h = ORGMODE . get_document ( bufnr = bufnr ) . current_heading ( ) [EOL] h . init_checkboxes ( ) [EOL] c = h . current_checkbox ( position = [number] ) [EOL] c . toggle ( ) [EOL] c = h . current_checkbox ( position = [number] ) [EOL] ( total , on ) = c . all_siblings_status ( ) [EOL] c . update_subtasks ( total = total , on = on ) [EOL] self . assertEqual ( str ( c ) , [string] ) [EOL] [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( CheckboxTestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import sys [EOL] import unittest [EOL] [EOL] sys . path . append ( [string] ) [EOL] from orgmode . liborgmode . orgdate import get_orgdate [EOL] from orgmode . liborgmode . orgdate import OrgDate [EOL] from orgmode . liborgmode . orgdate import OrgDateTime [EOL] from orgmode . liborgmode . orgdate import OrgTimeRange [EOL] [EOL] from orgmode . py3compat . unicode_compatibility import * [EOL] [EOL] class OrgDateParsingTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . text = [string] [EOL] self . textinactive = [string] [EOL] [EOL] def test_get_orgdate_parsing_active ( self ) : [EOL] [docstring] [EOL] result = get_orgdate ( self . text ) [EOL] self . assertNotEqual ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDate ) ) [EOL] self . assertTrue ( isinstance ( get_orgdate ( [string] ) , OrgDate ) ) [EOL] self . assertEqual ( get_orgdate ( [string] ) . year , [number] ) [EOL] self . assertEqual ( get_orgdate ( [string] ) . month , [number] ) [EOL] self . assertEqual ( get_orgdate ( [string] ) . day , [number] ) [EOL] self . assertTrue ( get_orgdate ( [string] ) . active ) [EOL] [EOL] datestr = [string] [EOL] self . assertTrue ( isinstance ( get_orgdate ( datestr ) , OrgDate ) ) [EOL] [EOL] [EOL] def test_get_orgdatetime_parsing_active ( self ) : [EOL] [docstring] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertNotEqual ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDateTime ) ) [EOL] self . assertEqual ( result . year , [number] ) [EOL] self . assertEqual ( result . month , [number] ) [EOL] self . assertEqual ( result . day , [number] ) [EOL] self . assertEqual ( result . hour , [number] ) [EOL] self . assertEqual ( result . minute , [number] ) [EOL] self . assertTrue ( result . active ) [EOL] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertTrue ( isinstance ( result , OrgDateTime ) ) [EOL] [EOL] [EOL] def test_get_orgtimerange_parsing_active ( self ) : [EOL] [docstring] [EOL] daterangestr = [string] [EOL] result = get_orgdate ( daterangestr ) [EOL] self . assertNotEqual ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgTimeRange ) ) [EOL] self . assertEqual ( unicode ( result ) , daterangestr ) [EOL] self . assertTrue ( result . active ) [EOL] [EOL] daterangestr = [string] [EOL] result = get_orgdate ( daterangestr ) [EOL] self . assertNotEqual ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgTimeRange ) ) [EOL] self . assertEqual ( unicode ( result ) , daterangestr ) [EOL] self . assertTrue ( result . active ) [EOL] [EOL] daterangestr = [string] [EOL] result = get_orgdate ( daterangestr ) [EOL] self . assertNotEqual ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgTimeRange ) ) [EOL] self . assertEqual ( unicode ( result ) , daterangestr ) [EOL] self . assertTrue ( result . active ) [EOL] [EOL] def test_get_orgdate_parsing_inactive ( self ) : [EOL] [docstring] [EOL] result = get_orgdate ( self . textinactive ) [EOL] self . assertNotEqual ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDate ) ) [EOL] self . assertTrue ( isinstance ( get_orgdate ( [string] ) , OrgDate ) ) [EOL] self . assertEqual ( get_orgdate ( [string] ) . year , [number] ) [EOL] self . assertEqual ( get_orgdate ( [string] ) . month , [number] ) [EOL] self . assertEqual ( get_orgdate ( [string] ) . day , [number] ) [EOL] self . assertFalse ( get_orgdate ( [string] ) . active ) [EOL] [EOL] datestr = [string] [EOL] self . assertTrue ( isinstance ( get_orgdate ( datestr ) , OrgDate ) ) [EOL] [EOL] def test_get_orgdatetime_parsing_passive ( self ) : [EOL] [docstring] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertNotEqual ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDateTime ) ) [EOL] self . assertEqual ( result . year , [number] ) [EOL] self . assertEqual ( result . month , [number] ) [EOL] self . assertEqual ( result . day , [number] ) [EOL] self . assertEqual ( result . hour , [number] ) [EOL] self . assertEqual ( result . minute , [number] ) [EOL] self . assertFalse ( result . active ) [EOL] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertTrue ( isinstance ( result , OrgDateTime ) ) [EOL] [EOL] def test_get_orgdate_parsing_with_list_of_texts ( self ) : [EOL] [docstring] [EOL] datelist = [ [string] ] [EOL] result = get_orgdate ( datelist ) [EOL] self . assertNotEquals ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDate ) ) [EOL] self . assertEqual ( result . year , [number] ) [EOL] self . assertEqual ( result . month , [number] ) [EOL] self . assertEqual ( result . day , [number] ) [EOL] [EOL] datelist = [ [string] , [string] ] [EOL] result = get_orgdate ( datelist ) [EOL] self . assertNotEquals ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDate ) ) [EOL] self . assertEqual ( result . year , [number] ) [EOL] self . assertEqual ( result . month , [number] ) [EOL] self . assertEqual ( result . day , [number] ) [EOL] [EOL] datelist = [ [string] , [string] ] [EOL] result = get_orgdate ( datelist ) [EOL] self . assertNotEquals ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDate ) ) [EOL] self . assertEqual ( result . year , [number] ) [EOL] self . assertEqual ( result . month , [number] ) [EOL] self . assertEqual ( result . day , [number] ) [EOL] [EOL] datelist = [ [string] , [string] , [string] ] [EOL] result = get_orgdate ( datelist ) [EOL] self . assertNotEquals ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDate ) ) [EOL] self . assertEqual ( result . year , [number] ) [EOL] self . assertEqual ( result . month , [number] ) [EOL] self . assertEqual ( result . day , [number] ) [EOL] [EOL] datelist = [ [string] , [string] , [string] ] [EOL] result = get_orgdate ( datelist ) [EOL] self . assertNotEquals ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDateTime ) ) [EOL] self . assertEqual ( result . year , [number] ) [EOL] self . assertEqual ( result . month , [number] ) [EOL] self . assertEqual ( result . day , [number] ) [EOL] self . assertEqual ( result . hour , [number] ) [EOL] self . assertEqual ( result . minute , [number] ) [EOL] [EOL] def test_get_orgdate_parsing_with_invalid_input ( self ) : [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] self . assertEquals ( get_orgdate ( [string] ) , None ) [EOL] [EOL] def test_get_orgdate_parsing_with_invalid_dates ( self ) : [EOL] [docstring] [EOL] datestr = [string] [EOL] self . assertEqual ( get_orgdate ( datestr ) , None ) [EOL] [EOL] datestr = [string] [EOL] self . assertEqual ( get_orgdate ( datestr ) , None ) [EOL] [EOL] datestr = [string] [EOL] self . assertEqual ( get_orgdate ( datestr ) , None ) [EOL] [EOL] def test_get_orgdate_parsing_with_utf8 ( self ) : [EOL] [docstring] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertNotEqual ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDate ) ) [EOL] self . assertEqual ( result . year , [number] ) [EOL] self . assertEqual ( result . month , [number] ) [EOL] self . assertEqual ( result . day , [number] ) [EOL] self . assertTrue ( result . active ) [EOL] [EOL] datestr = [string] [EOL] self . assertTrue ( isinstance ( get_orgdate ( datestr ) , OrgDate ) ) [EOL] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertFalse ( result . active ) [EOL] [EOL] datestr = [string] [EOL] self . assertTrue ( isinstance ( get_orgdate ( datestr ) , OrgDate ) ) [EOL] [EOL] def test_get_orgdatetime_parsing_with_utf8 ( self ) : [EOL] [docstring] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertNotEqual ( result , None ) [EOL] self . assertTrue ( isinstance ( result , OrgDateTime ) ) [EOL] self . assertEqual ( result . year , [number] ) [EOL] self . assertEqual ( result . month , [number] ) [EOL] self . assertEqual ( result . day , [number] ) [EOL] self . assertEqual ( result . hour , [number] ) [EOL] self . assertEqual ( result . minute , [number] ) [EOL] self . assertTrue ( result . active ) [EOL] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertTrue ( isinstance ( result , OrgDateTime ) ) [EOL] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertFalse ( result . active ) [EOL] [EOL] result = get_orgdate ( [string] ) [EOL] self . assertTrue ( isinstance ( result , OrgDateTime ) ) [EOL] [EOL] [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( OrgDateParsingTestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import threading [EOL] import typing [EOL] import sys [EOL] import unittest [EOL] import locale [EOL] import threading [EOL] [EOL] from datetime import date [EOL] from contextlib import contextmanager [EOL] [EOL] from orgmode . py3compat . unicode_compatibility import * [EOL] [EOL] sys . path . append ( [string] ) [EOL] from orgmode . liborgmode . orgdate import OrgDate [EOL] [EOL] class OrgDateUtf8TestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] LOCALE_LOCK = threading . Lock ( ) [EOL] UTF8_LOCALE = [string] [EOL] [EOL] @ contextmanager def setlocale ( self , name ) : [EOL] with self . LOCALE_LOCK : [EOL] saved = locale . setlocale ( locale . LC_ALL ) [EOL] try : [EOL] yield locale . setlocale ( locale . LC_ALL , name ) [EOL] finally : [EOL] locale . setlocale ( locale . LC_ALL , saved ) [EOL] [EOL] def setUp ( self ) : [EOL] self . year = [number] [EOL] self . month = [number] [EOL] self . day = [number] [EOL] self . text = [string] [EOL] self . textinactive = [string] [EOL] [EOL] def test_OrdDate_str_unicode_active ( self ) : [EOL] with self . setlocale ( self . UTF8_LOCALE ) : [EOL] od = OrgDate ( True , self . year , self . month , self . day ) [EOL] self . assertEqual ( self . text , unicode ( od ) ) [EOL] [EOL] def test_OrdDate_str_unicode_inactive ( self ) : [EOL] with self . setlocale ( self . UTF8_LOCALE ) : [EOL] od = OrgDate ( False , self . year , self . month , self . day ) [EOL] self . assertEqual ( self . textinactive , unicode ( od ) ) [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( OrgDateUtf8TestCase ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import datetime [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import unittest [EOL] from datetime import date [EOL] from datetime import timedelta [EOL] [EOL] from orgmode . liborgmode . headings import Heading [EOL] from orgmode . liborgmode . orgdate import OrgDate [EOL] from orgmode . liborgmode . agendafilter import contains_active_todo [EOL] from orgmode . liborgmode . agendafilter import contains_active_date [EOL] from orgmode . liborgmode . orgdate import OrgDateTime [EOL] from orgmode . liborgmode . agendafilter import is_within_week [EOL] from orgmode . liborgmode . agendafilter import is_within_week_and_active_todo [EOL] from orgmode . liborgmode . agendafilter import filter_items [EOL] [EOL] import vim [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] counter = [number] [EOL] [EOL] class AgendaFilterTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] global counter [EOL] counter += [number] [EOL] [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] % counter ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] [EOL] def test_contains_active_todo ( self ) : [EOL] heading = Heading ( title = [string] , todo = [string] ) [EOL] self . assertTrue ( contains_active_todo ( heading ) ) [EOL] [EOL] heading = Heading ( title = [string] , todo = [string] ) [EOL] self . assertFalse ( contains_active_todo ( heading ) ) [EOL] [EOL] heading = Heading ( title = [string] , todo = None ) [EOL] self . assertFalse ( contains_active_todo ( heading ) ) [EOL] [EOL] def test_contains_active_date ( self ) : [EOL] heading = Heading ( title = [string] , active_date = None ) [EOL] self . assertFalse ( contains_active_date ( heading ) ) [EOL] [EOL] odate = OrgDate ( True , [number] , [number] , [number] ) [EOL] heading = Heading ( title = [string] , active_date = odate ) [EOL] self . assertTrue ( contains_active_date ( heading ) ) [EOL] [EOL] def test_is_within_week_with_orgdate ( self ) : [EOL] [comment] [EOL] tmpdate = date . today ( ) + timedelta ( days = [number] ) [EOL] odate = OrgDate ( True , tmpdate . year , tmpdate . month , tmpdate . day ) [EOL] heading = Heading ( title = [string] , active_date = odate ) [EOL] self . assertFalse ( is_within_week ( heading ) ) [EOL] [EOL] [comment] [EOL] tmpdate = date . today ( ) + timedelta ( days = [number] ) [EOL] odate = OrgDate ( True , tmpdate . year , tmpdate . month , tmpdate . day ) [EOL] heading = Heading ( title = [string] , active_date = odate ) [EOL] self . assertTrue ( is_within_week ( heading ) ) [EOL] [EOL] [comment] [EOL] tmpdate = date . today ( ) - timedelta ( days = [number] ) [EOL] odate = OrgDate ( True , tmpdate . year , tmpdate . month , tmpdate . day ) [EOL] heading = Heading ( title = [string] , active_date = odate ) [EOL] self . assertTrue ( is_within_week ( heading ) ) [EOL] [EOL] def test_is_within_week_with_orgdatetime ( self ) : [EOL] [comment] [EOL] tmp = date . today ( ) + timedelta ( days = [number] ) [EOL] odate = OrgDateTime ( True , tmp . year , tmp . month , tmp . day , [number] , [number] ) [EOL] heading = Heading ( title = [string] , active_date = odate ) [EOL] self . assertFalse ( is_within_week ( heading ) ) [EOL] [EOL] [comment] [EOL] tmpdate = date . today ( ) + timedelta ( days = [number] ) [EOL] odate = OrgDateTime ( True , tmpdate . year , tmpdate . month , tmpdate . day , [number] , [number] ) [EOL] heading = Heading ( title = [string] , active_date = odate ) [EOL] self . assertTrue ( is_within_week ( heading ) ) [EOL] [EOL] [comment] [EOL] tmpdate = date . today ( ) - timedelta ( days = [number] ) [EOL] odate = OrgDateTime ( True , tmpdate . year , tmpdate . month , tmpdate . day , [number] , [number] ) [EOL] heading = Heading ( title = [string] , active_date = odate ) [EOL] self . assertTrue ( is_within_week ( heading ) ) [EOL] [EOL] def test_filter_items ( self ) : [EOL] [comment] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] [EOL] tmpdate = date . today ( ) [EOL] odate = OrgDate ( True , tmpdate . year , tmpdate . month , tmpdate . day ) [EOL] tmp_head = Heading ( title = [string] , todo = [string] , active_date = odate ) [EOL] tmp_head_01 = Heading ( title = [string] , todo = [string] , active_date = odate ) [EOL] [comment] [EOL] headings = [ tmp_head , tmp_head_01 ] [EOL] filtered = list ( filter_items ( headings , [ contains_active_date , contains_active_todo ] ) ) [EOL] [EOL] self . assertEqual ( len ( filtered ) , [number] ) [EOL] self . assertEqual ( filtered , headings ) [EOL] [EOL] [comment] [EOL] headings = headings * [number] [EOL] filtered = list ( filter_items ( headings , [ contains_active_date , contains_active_todo ] ) ) [EOL] [EOL] self . assertEqual ( len ( filtered ) , [number] ) [EOL] self . assertEqual ( filtered , headings ) [EOL] [EOL] [comment] [EOL] tmpdate = date . today ( ) [EOL] odate = OrgDate ( True , tmpdate . year , tmpdate . month , tmpdate . day ) [EOL] tmp_head = Heading ( title = [string] , active_date = odate ) [EOL] headings = [ tmp_head ] [EOL] filtered = list ( filter_items ( headings , [ contains_active_date , contains_active_todo ] ) ) [EOL] self . assertEqual ( [ ] , filtered ) [EOL] [EOL] def test_filter_items_with_some_todos_and_dates ( self ) : [EOL] [docstring] [EOL] tmp = [ [string] [string] ] [EOL] headings = [ Heading . parse_heading_from_data ( tmp , [ [string] ] ) ] [EOL] filtered = list ( filter_items ( headings , [ is_within_week_and_active_todo ] ) ) [EOL] self . assertEqual ( len ( filtered ) , [number] ) [EOL] self . assertEqual ( headings , filtered ) [EOL] [EOL] tmp = [ Heading . parse_heading_from_data ( [ [string] ] , [ [string] ] ) , Heading . parse_heading_from_data ( [ [string] ] , [ [string] ] ) , Heading . parse_heading_from_data ( [ [string] ] , [ [string] ] ) , Heading . parse_heading_from_data ( [ [string] ] , [ [string] ] ) , Heading . parse_heading_from_data ( [ [string] ] , [ [string] ] ) ] [EOL] for h in tmp : [EOL] headings . append ( h ) [EOL] [EOL] filtered = list ( filter_items ( headings , [ is_within_week_and_active_todo ] ) ) [EOL] self . assertEqual ( len ( filtered ) , [number] ) [EOL] self . assertEqual ( filtered , [ headings [ [number] ] , headings [ [number] ] , headings [ [number] ] ] ) [EOL] [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( AgendaFilterTestCase ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 $datetime.date$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Literal , Tuple [EOL] import typing [EOL] import datetime [EOL] import typing_extensions [EOL] import sys [EOL] import unittest [EOL] from datetime import datetime [EOL] [EOL] sys . path . append ( [string] ) [EOL] from orgmode . liborgmode . orgdate import OrgDateTime [EOL] [EOL] from orgmode . py3compat . unicode_compatibility import * [EOL] [EOL] class OrgDateTimeTestCase ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_OrgDateTime_ctor_active ( self ) : [EOL] [docstring] [EOL] today = datetime . today ( ) [EOL] odt = OrgDateTime ( True , today . year , today . month , today . day , today . hour , today . minute ) [EOL] self . assertTrue ( isinstance ( odt , OrgDateTime ) ) [EOL] self . assertTrue ( odt . active ) [EOL] [EOL] def test_OrgDateTime_ctor_inactive ( self ) : [EOL] [docstring] [EOL] today = datetime . today ( ) [EOL] odt = OrgDateTime ( False , today . year , today . month , today . day , today . hour , today . minute ) [EOL] self . assertTrue ( isinstance ( odt , OrgDateTime ) ) [EOL] self . assertFalse ( odt . active ) [EOL] [EOL] def test_OrdDateTime_str_active ( self ) : [EOL] [docstring] [EOL] t = [number] , [number] , [number] , [number] , [number] [EOL] odt = OrgDateTime ( False , t [ [number] ] , t [ [number] ] , t [ [number] ] , t [ [number] ] , t [ [number] ] ) [EOL] self . assertEqual ( [string] , unicode ( odt ) ) [EOL] [EOL] def test_OrdDateTime_str_inactive ( self ) : [EOL] [docstring] [EOL] t = [number] , [number] , [number] , [number] , [number] [EOL] odt = OrgDateTime ( True , t [ [number] ] , t [ [number] ] , t [ [number] ] , t [ [number] ] , t [ [number] ] ) [EOL] self . assertEqual ( [string] , unicode ( odt ) ) [EOL] [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( OrgDateTimeTestCase ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pack [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] from orgmode . liborgmode . headings import Heading [EOL] from orgmode . liborgmode . orgdate import OrgDate [EOL] from orgmode . liborgmode . orgdate import OrgDateTime [EOL] [EOL] [EOL] class TestHeadingRecognizeDatesInHeading ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . allowed_todo_states = [ [string] ] [EOL] [EOL] tmp = [ [string] ] [EOL] self . h1 = Heading . parse_heading_from_data ( tmp , self . allowed_todo_states ) [EOL] [EOL] tmp = [ [string] ] [EOL] self . h2 = Heading . parse_heading_from_data ( tmp , self . allowed_todo_states ) [EOL] [EOL] tmp = [ [string] ] [EOL] self . h2_datetime = Heading . parse_heading_from_data ( tmp , self . allowed_todo_states ) [EOL] [EOL] tmp = [ [string] ] [EOL] self . h3 = Heading . parse_heading_from_data ( tmp , self . allowed_todo_states ) [EOL] [EOL] tmp = [ [string] ] [EOL] self . h_no_date = Heading . parse_heading_from_data ( tmp , self . allowed_todo_states ) [EOL] [EOL] def test_heading_parsing_no_date ( self ) : [EOL] [docstring] [EOL] text = [ [string] ] [EOL] h = Heading . parse_heading_from_data ( text , self . allowed_todo_states ) [EOL] self . assertEqual ( None , h . active_date ) [EOL] [EOL] text = [ [string] ] [EOL] h = Heading . parse_heading_from_data ( text , self . allowed_todo_states ) [EOL] self . assertEqual ( None , h . active_date ) [EOL] [EOL] text = [ [string] ] [EOL] h = Heading . parse_heading_from_data ( text , self . allowed_todo_states ) [EOL] self . assertEqual ( None , h . active_date ) [EOL] [EOL] text = [ [string] ] [EOL] h = Heading . parse_heading_from_data ( text , self . allowed_todo_states ) [EOL] self . assertEqual ( None , h . active_date ) [EOL] [EOL] def test_heading_parsing_with_date ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] text = [ [string] ] [EOL] odate = OrgDate ( True , [number] , [number] , [number] ) [EOL] h = Heading . parse_heading_from_data ( text , self . allowed_todo_states ) [EOL] self . assertEqual ( odate , h . active_date ) [EOL] [EOL] [comment] [EOL] text = [ [string] ] [EOL] odate = OrgDateTime ( True , [number] , [number] , [number] , [number] , [number] ) [EOL] h = Heading . parse_heading_from_data ( text , self . allowed_todo_states ) [EOL] self . assertEqual ( odate , h . active_date ) [EOL] [EOL] def test_heading_parsing_with_date_and_body ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] text = [ [string] , [string] , [string] ] [EOL] h = Heading . parse_heading_from_data ( text , self . allowed_todo_states ) [EOL] self . assertTrue ( isinstance ( h . active_date , OrgDateTime ) ) [EOL] self . assertEqual ( [string] , str ( h . active_date ) ) [EOL] [EOL] text = [ [string] , [string] , [string] ] [EOL] h = Heading . parse_heading_from_data ( text , self . allowed_todo_states ) [EOL] self . assertTrue ( isinstance ( h . active_date , OrgDateTime ) ) [EOL] self . assertEqual ( [string] , str ( h . active_date ) ) [EOL] [EOL] text = [ [string] , [string] , [string] ] [EOL] h = Heading . parse_heading_from_data ( text , self . allowed_todo_states ) [EOL] odate = OrgDate ( True , [number] , [number] , [number] ) [EOL] self . assertEqual ( odate , h . active_date ) [EOL] [EOL] def test_less_than_for_dates_in_heading ( self ) : [EOL] self . assertTrue ( self . h1 < self . h2 ) [EOL] self . assertTrue ( self . h1 < self . h3 ) [EOL] self . assertTrue ( self . h1 < self . h_no_date ) [EOL] self . assertTrue ( self . h2 < self . h_no_date ) [EOL] self . assertTrue ( self . h2 < self . h3 ) [EOL] self . assertTrue ( self . h3 < self . h_no_date ) [EOL] [EOL] self . assertFalse ( self . h2 < self . h1 ) [EOL] self . assertFalse ( self . h3 < self . h2 ) [EOL] [EOL] def test_less_equal_for_dates_in_heading ( self ) : [EOL] self . assertTrue ( self . h1 <= self . h2 ) [EOL] self . assertTrue ( self . h1 <= self . h_no_date ) [EOL] self . assertTrue ( self . h2 <= self . h_no_date ) [EOL] self . assertTrue ( self . h2 <= self . h2_datetime ) [EOL] self . assertTrue ( self . h2 <= self . h3 ) [EOL] [EOL] def test_greate_than_for_dates_in_heading ( self ) : [EOL] self . assertTrue ( self . h2 > self . h1 ) [EOL] self . assertTrue ( self . h_no_date > self . h1 ) [EOL] self . assertTrue ( self . h_no_date > self . h2 ) [EOL] [EOL] self . assertFalse ( self . h2 > self . h2_datetime ) [EOL] [EOL] def test_greate_equal_for_dates_in_heading ( self ) : [EOL] self . assertTrue ( self . h2 >= self . h1 ) [EOL] self . assertTrue ( self . h_no_date >= self . h1 ) [EOL] self . assertTrue ( self . h_no_date >= self . h2 ) [EOL] self . assertTrue ( self . h2 >= self . h2_datetime ) [EOL] [EOL] def test_sorting_of_headings ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [ self . h1 , self . h2 ] , sorted ( [ self . h2 , self . h1 ] ) ) [EOL] [EOL] self . assertEqual ( [ self . h1 , self . h2_datetime ] , sorted ( [ self . h2_datetime , self . h1 ] ) ) [EOL] [EOL] self . assertEqual ( [ self . h2_datetime , self . h2 ] , sorted ( [ self . h2_datetime , self . h2 ] ) ) [EOL] [EOL] self . assertEqual ( [ self . h1 , self . h2 ] , sorted ( [ self . h1 , self . h2 ] ) ) [EOL] [EOL] self . assertEqual ( [ self . h1 , self . h_no_date ] , sorted ( [ self . h1 , self . h_no_date ] ) ) [EOL] [EOL] self . assertEqual ( [ self . h1 , self . h_no_date ] , sorted ( [ self . h_no_date , self . h1 ] ) ) [EOL] [EOL] self . assertEqual ( [ self . h1 , self . h2 , self . h_no_date ] , sorted ( [ self . h2 , self . h_no_date , self . h1 ] ) ) [EOL] [EOL] self . assertEqual ( [ self . h1 , self . h2_datetime , self . h2 , self . h3 , self . h_no_date ] , sorted ( [ self . h2_datetime , self . h3 , self . h2 , self . h_no_date , self . h1 ] ) ) [EOL] [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( TestHeadingRecognizeDatesInHeading ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pack.bundle.opt.orgmode.tests.test_libheading.TestHeadingRecognizeDatesInHeading$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import vim [EOL] [EOL] from orgmode . _vim import indent_orgmode , fold_orgmode , ORGMODE [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] ORGMODE . debug = True [EOL] [EOL] START = True [EOL] END = False [EOL] [EOL] counter = [number] [EOL] class TagsPropertiesTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] global counter [EOL] counter += [number] [EOL] vim . CMDHISTORY = [ ] [EOL] vim . CMDRESULTS = { } [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : ( u_encode ( [string] % counter ) ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] if not [string] in ORGMODE . plugins : [EOL] ORGMODE . register_plugin ( [string] ) [EOL] self . tagsproperties = ORGMODE . plugins [ [string] ] [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] [EOL] def test_new_property ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def test_set_tags ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_parse_tags_no_colons_single_tag ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_parse_tags_no_colons_multiple_tags ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_parse_tags_single_colon_left_single_tag ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_parse_tags_single_colon_left_multiple_tags ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_parse_tags_single_colon_right_single_tag ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_parse_tags_single_colon_right_multiple_tags ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_filter_empty_tags ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_delete_tags ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_realign_tags_noop ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . tagsproperties . realign_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_realign_tags_remove_spaces ( self ) : [EOL] [comment] [EOL] vim . current . buffer [ [number] ] = u_encode ( [string] ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . tagsproperties . realign_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [comment] [EOL] vim . current . buffer [ [number] ] = u_encode ( [string] ) [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] self . tagsproperties . realign_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_realign_tags ( self ) : [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] self . tagsproperties . set_tags ( ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] d = ORGMODE . get_document ( ) [EOL] heading = d . find_current_heading ( ) [EOL] self . assertEqual ( str ( heading ) , u_encode ( [string] ) ) [EOL] self . tagsproperties . realign_tags ( ) [EOL] heading = d . find_current_heading ( ) [EOL] self . assertEqual ( str ( heading ) , u_encode ( [string] ) ) [EOL] self . assertEqual ( vim . current . buffer [ [number] ] , u_encode ( [string] ) ) [EOL] [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( TagsPropertiesTestCase ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import unittest [EOL] import sys [EOL] sys . path . append ( [string] ) [EOL] [EOL] import vim [EOL] [EOL] from orgmode . _vim import indent_orgmode , fold_orgmode , ORGMODE [EOL] [EOL] from orgmode . py3compat . encode_compatibility import * [EOL] [EOL] ORGMODE . debug = True [EOL] [EOL] START = True [EOL] END = False [EOL] [EOL] counter = [number] [EOL] class MiscTestCase ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] global counter [EOL] counter += [number] [EOL] vim . CMDHISTORY = [ ] [EOL] vim . CMDRESULTS = { } [EOL] vim . EVALHISTORY = [ ] [EOL] vim . EVALRESULTS = { u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : [ u_encode ( [string] ) , u_encode ( [string] ) , u_encode ( [string] ) ] , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] ) , u_encode ( [string] ) : u_encode ( [string] % counter ) , u_encode ( [string] ) : u_encode ( [string] ) } [EOL] vim . current . buffer [ : ] = [ u_encode ( i ) for i in [string] . split ( [string] ) ] [EOL] [EOL] def test_indent_noheading ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] indent_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] [EOL] def test_indent_heading ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] indent_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] [EOL] def test_indent_heading_middle ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] indent_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_indent_heading_middle2 ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] indent_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_indent_heading_end ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] indent_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_fold_heading_start ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] fold_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_fold_heading_middle ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] fold_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_fold_heading_end ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] fold_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_fold_heading_end_of_last_child ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] fold_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] [comment] [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_fold_heading_end_of_last_child_next_heading ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] fold_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_fold_middle_subheading ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] fold_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_fold_middle_subheading2 ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] fold_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def test_fold_middle_subheading3 ( self ) : [EOL] [comment] [EOL] vim . current . window . cursor = ( [number] , [number] ) [EOL] vim . EVALRESULTS [ u_encode ( [string] ) ] = u_encode ( [string] ) [EOL] fold_orgmode ( ) [EOL] self . assertEqual ( len ( vim . CMDHISTORY ) , [number] ) [EOL] self . assertEqual ( vim . CMDHISTORY [ - [number] ] , u_encode ( [string] ) ) [EOL] [EOL] def suite ( ) : [EOL] return unittest . TestLoader ( ) . loadTestsFromTestCase ( MiscTestCase ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from orgmode import echo , echom , echoe , ORGMODE , apply_count , repeat [EOL] from orgmode . menu import Submenu , Separator , ActionEntry [EOL] from orgmode . keybinding import Keybinding , Plug , Command [EOL] [EOL] import vim [EOL] [EOL] [EOL] class Example ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] object . __init__ ( self ) [EOL] [comment] [EOL] self . menu = ORGMODE . orgmenu + Submenu ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . keybindings = [ ] [EOL] [EOL] [comment] [EOL] self . commands = [ ] [EOL] [EOL] @ classmethod def action ( cls ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def register ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . commands . append ( Command ( [string] , [string] ) ) [EOL] self . keybindings . append ( Keybinding ( [string] , Plug ( [string] , self . commands [ - [number] ] ) ) ) [EOL] self . menu + ActionEntry ( [string] , self . keybindings [ - [number] ] ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def findBase ( line , col ) : [EOL] index = col [EOL] [comment] [EOL] [comment] [EOL] while index > [number] : [EOL] index -= [number] [EOL] if line [ index ] in [string] : [EOL] index += [number] [EOL] break [EOL] return index [comment] [EOL] [EOL] def findWord ( vim , origCol , origLine ) : [EOL] [comment] [EOL] [comment] [EOL] index = origCol [EOL] while index > [number] : [EOL] index -= [number] [EOL] if origLine [ index ] == [string] : [EOL] index += [number] [EOL] break [EOL] cword = origLine [ index : origCol ] [EOL] return cword [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import IO , Any , Dict , List [EOL] import typing [EOL] hl_bundles = { } [EOL] hl_menus = [ ] [EOL] hl_errors = [ ] [EOL] hl_start_time = [number] [EOL] [EOL] [comment] [EOL] hl_vim_execution_time = [number] [EOL] hl_scriptnames = [string] [EOL] hl_categories = [ ] [EOL] [EOL] def run_headlights ( vim_time , vim_scriptnames , ** vim_categories ) : [EOL] [docstring] [EOL] [EOL] global hl_start_time , hl_vim_execution_time , hl_scriptnames , hl_categories [EOL] [EOL] hl_start_time = time . time ( ) [EOL] hl_vim_execution_time = vim_time [EOL] hl_scriptnames = vim_scriptnames [EOL] hl_categories = vim_categories [EOL] [EOL] try : [EOL] parse_scriptnames ( ) [EOL] parse_categories ( ) [EOL] gen_menus ( ) [EOL] attach_menus ( ) [EOL] [EOL] [comment] [EOL] except : [EOL] import traceback [EOL] hl_errors . insert ( [number] , traceback . format_exc ( ) ) [EOL] [comment] [EOL] log_name = do_debug ( ) [EOL] sys . stdout . write ( [string] % traceback . format_exc ( ) ) [EOL] sys . stdout . write ( [string] % log_name ) [EOL] [EOL] def parse_scriptnames ( ) : [EOL] [docstring] [EOL] [EOL] global hl_scriptnames [EOL] [EOL] hl_scriptnames = hl_scriptnames . strip ( ) . split ( [string] ) [EOL] [EOL] for line in hl_scriptnames : [EOL] [comment] [EOL] matches = HL_SCRIPTNAME_PATTERN . match ( line ) [EOL] [EOL] order = matches . group ( [string] ) [EOL] path = matches . group ( [string] ) [EOL] [EOL] init_bundle ( expand_home ( path ) , order ) [EOL] [EOL] def init_bundle ( path , order ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] name = os . path . splitext ( os . path . basename ( path ) ) [ [number] ] [EOL] [EOL] [comment] [EOL] root = os . path . dirname ( path ) [EOL] [EOL] if HL_SMART_MENUS : [EOL] [comment] [EOL] if [string] not in root . lower ( ) : [EOL] for pattern in HL_VIM_DIR_PATTERNS : [EOL] if re . match ( pattern , root ) : [EOL] parent = re . sub ( [string] , [string] , root ) [EOL] [comment] [EOL] while re . match ( pattern , parent ) : [EOL] parent = re . sub ( [string] , [string] , parent ) [EOL] [EOL] [comment] [EOL] if parent != os . getenv ( [string] ) : [EOL] [comment] [EOL] root = parent [EOL] [comment] [EOL] name = os . path . splitext ( os . path . basename ( parent ) ) [ [number] ] [EOL] [EOL] break [EOL] [EOL] [comment] [EOL] [comment] [EOL] if [string] not in path and not name . endswith ( [string] ) : [EOL] for key in iter ( list ( hl_bundles . keys ( ) ) ) : [EOL] if root == hl_bundles [ key ] [ [string] ] : [EOL] [comment] [EOL] name = hl_bundles [ key ] [ [string] ] [EOL] break [EOL] [EOL] [comment] [EOL] if name . startswith ( [string] ) : [EOL] name = name [ [number] : ] [EOL] [EOL] [comment] [EOL] if name . endswith ( [string] ) : [EOL] name = name [ : - [number] ] [EOL] [EOL] hl_bundles [ path ] = { [string] : order , [string] : name , [string] : root , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : False } [EOL] [EOL] return hl_bundles [ path ] [EOL] [EOL] def parse_categories ( ) : [EOL] [docstring] [EOL] [EOL] for key in iter ( list ( hl_categories . keys ( ) ) ) : [EOL] if hl_categories [ key ] : [EOL] function = globals ( ) [ [string] + key ] [EOL] function ( hl_categories [ key ] . strip ( ) . split ( [string] ) ) [EOL] [EOL] def gen_menus ( ) : [EOL] [docstring] [EOL] [EOL] root = HL_MENU_ROOT [EOL] [EOL] for path , properties in iter ( list ( hl_bundles . items ( ) ) ) : [EOL] name = properties [ [string] ] [EOL] [EOL] spillover = get_spillover ( name , path ) [EOL] [EOL] name = sanitise_menu ( name ) [EOL] [EOL] prefix = [string] % locals ( ) [EOL] [EOL] gen_menu_categories ( name , prefix , path , properties ) [EOL] [EOL] [comment] [EOL] if hl_bundles [ path ] [ [string] ] : [EOL] prefix = [string] % locals ( ) [EOL] gen_menu_categories ( name , prefix , path , properties ) [EOL] [EOL] [comment] [EOL] hl_menus . sort ( key = lambda menu : menu . lower ( ) ) [EOL] [EOL] def attach_menus ( ) : [EOL] [docstring] [EOL] [EOL] root = HL_MENU_ROOT [EOL] new_line = os . linesep [EOL] [EOL] if HL_DEBUG_MODE : [EOL] [comment] [EOL] do_debug ( ) [EOL] [EOL] [comment] [EOL] for menu_command in hl_menus : [EOL] try : [EOL] vim . command ( [string] % locals ( ) ) [EOL] except vim . error : [EOL] menu_error = [string] % locals ( ) [EOL] hl_errors . insert ( [number] , menu_error ) [EOL] [comment] [EOL] log_name = do_debug ( ) [EOL] sys . stdout . write ( [string] % locals ( ) ) [EOL] sys . stdout . write ( HL_MENU_ERROR ) [EOL] continue [EOL] [EOL] [comment] [EOL] else : [EOL] try : [EOL] [ vim . command ( [string] % locals ( ) ) for menu_command in hl_menus ] [EOL] except vim . error : [EOL] sys . stdout . write ( HL_MENU_ERROR ) [EOL] [EOL] def parse_commands ( commands ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] commands = commands [ [number] : ] [EOL] [EOL] for i , line in enumerate ( commands ) : [EOL] [comment] [EOL] if HL_SOURCE_LINE not in line : [EOL] matches = HL_COMMAND_PATTERN . match ( line ) [EOL] [EOL] try : [EOL] command = matches . group ( [string] ) [EOL] except AttributeError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] [EOL] definition = matches . group ( [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] definition = definition . strip ( ) [EOL] except AttributeError : [EOL] definition = [string] [EOL] [EOL] [comment] [EOL] try : [EOL] source_script = get_source_script ( commands [ i + [number] ] ) [EOL] [EOL] if matches . group ( [string] ) : [EOL] source_script [ [string] ] = True [EOL] [EOL] source_script [ [string] ] . append ( [ command , definition ] ) [EOL] [EOL] except IndexError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] except TypeError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] [EOL] def parse_modes ( mode ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if not mode : [EOL] mode = [string] [EOL] [EOL] [comment] [EOL] modes = list ( mode ) [EOL] [EOL] [comment] [EOL] modes = [ HL_MODE_MAP . get ( mode ) for mode in modes ] [EOL] [EOL] return modes [EOL] [EOL] def parse_mappings ( mappings ) : [EOL] [docstring] [EOL] [EOL] for i , line in enumerate ( mappings ) : [EOL] [comment] [EOL] if HL_SOURCE_LINE not in line : [EOL] matches = HL_MAPPING_PATTERN . match ( line ) [EOL] [EOL] try : [EOL] lhs = matches . group ( [string] ) [EOL] except AttributeError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] [EOL] try : [EOL] rhs = matches . group ( [string] ) . strip ( ) [EOL] except AttributeError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] [EOL] modes = parse_modes ( matches . group ( [string] ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] source_script = get_source_script ( mappings [ i + [number] ] ) [EOL] [EOL] [comment] [EOL] if matches . group ( [string] ) : [EOL] source_script [ [string] ] = True [EOL] [EOL] [comment] [EOL] for mode in modes : [EOL] source_script [ [string] ] . append ( [ mode , lhs , rhs ] ) [EOL] [EOL] except IndexError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] except TypeError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] [EOL] def parse_abbreviations ( abbreviations ) : [EOL] [docstring] [EOL] [EOL] for i , line in enumerate ( abbreviations ) : [EOL] [comment] [EOL] if HL_SOURCE_LINE not in line : [EOL] matches = HL_ABBREV_PATTERN . match ( line ) [EOL] [EOL] try : [EOL] lhs = matches . group ( [string] ) [EOL] except AttributeError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] [EOL] try : [EOL] rhs = matches . group ( [string] ) . strip ( ) [EOL] except AttributeError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] [EOL] modes = parse_modes ( matches . group ( [string] ) ) [EOL] [EOL] [comment] [EOL] try : [EOL] source_script = get_source_script ( abbreviations [ i + [number] ] ) [EOL] [EOL] [comment] [EOL] if matches . group ( [string] ) : [EOL] source_script [ [string] ] = True [EOL] [EOL] [comment] [EOL] for mode in modes : [EOL] source_script [ [string] ] . append ( [ mode , lhs , rhs ] ) [EOL] [EOL] except IndexError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] except TypeError : [EOL] hl_errors . append ( [string] % locals ( ) ) [EOL] continue [EOL] [EOL] def parse_functions ( functions ) : [EOL] [docstring] [EOL] [EOL] for i , line in enumerate ( functions ) : [EOL] [comment] [EOL] if HL_SOURCE_LINE not in line : [EOL] function = line . split ( [string] ) [ [number] ] [EOL] [EOL] [comment] [EOL] source_script = get_source_script ( functions [ i + [number] ] ) [EOL] [EOL] [comment] [EOL] if not function . startswith ( [string] ) and [string] not in function : [EOL] source_script [ [string] ] . append ( function ) [EOL] [EOL] def parse_highlights ( highlights ) : [EOL] [docstring] [EOL] [EOL] for i , line in enumerate ( highlights ) : [EOL] [comment] [EOL] if HL_SOURCE_LINE not in line : [EOL] matches = HL_HIGHLIGHT_PATTERN . match ( line ) [EOL] [EOL] try : [EOL] group = matches . group ( [string] ) [EOL] except AttributeError : [EOL] [comment] [EOL] continue [EOL] [EOL] arguments = matches . group ( [string] ) [EOL] [EOL] if not arguments . startswith ( [string] ) and not arguments . startswith ( [string] ) : [EOL] [comment] [EOL] source_script = get_source_script ( highlights [ i + [number] ] ) [EOL] [EOL] terminal_list = { } [EOL] [EOL] for argument in arguments . split ( [string] ) : [EOL] terminal , attributes = argument . split ( [string] ) [EOL] [EOL] attribute_list = attributes . split ( [string] ) [EOL] [EOL] terminal_list [ terminal ] = attribute_list [EOL] [EOL] [comment] [EOL] try : [EOL] source_script [ [string] ] . append ( [ group , terminal_list ] ) [EOL] except TypeError : [EOL] continue [EOL] [EOL] def get_source_script ( line ) : [EOL] [docstring] [EOL] [EOL] script_path = line . replace ( HL_SOURCE_LINE , [string] ) . strip ( ) [EOL] [EOL] return hl_bundles . get ( expand_home ( script_path ) ) [EOL] [EOL] def expand_home ( path ) : [EOL] [docstring] [EOL] return os . getenv ( [string] ) + path [ [number] : ] if path . startswith ( [string] ) else path [EOL] [EOL] def sanitise_menu ( menu ) : [EOL] [docstring] [EOL] return menu . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] def get_spillover ( name , path ) : [EOL] [docstring] [EOL] [EOL] name = name . strip ( ) [EOL] [EOL] if hl_bundles [ path ] [ [string] ] . endswith ( [string] ) : [EOL] spillover = [string] [EOL] elif [string] in path . lower ( ) : [EOL] spillover = [string] [EOL] elif HL_SPILLOVER : [EOL] [comment] [EOL] [comment] [EOL] for pattern , category in list ( HL_MENU_SPILLOVER_PATTERNS . items ( ) ) : [EOL] if pattern . match ( name ) : [EOL] spillover = sanitise_menu ( category ) + [string] [EOL] break [EOL] else : [EOL] spillover = [string] [EOL] [EOL] return spillover [EOL] [EOL] def gen_menu_categories ( name , prefix , path , properties ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] gen_help_menu ( name , prefix ) [EOL] [EOL] if HL_SHOW_FILES : [EOL] gen_files_menu ( path , prefix , properties [ [string] ] ) [EOL] [EOL] if len ( properties [ [string] ] ) > [number] : [EOL] gen_commands_menu ( properties [ [string] ] , prefix ) [EOL] [EOL] if len ( properties [ [string] ] ) > [number] : [EOL] gen_mappings_menu ( properties [ [string] ] , prefix ) [EOL] [EOL] if len ( properties [ [string] ] ) > [number] : [EOL] gen_abbreviations_menu ( properties [ [string] ] , prefix ) [EOL] [EOL] if len ( properties [ [string] ] ) > [number] : [EOL] gen_functions_menu ( properties [ [string] ] , prefix ) [EOL] [EOL] if len ( properties [ [string] ] ) > [number] : [EOL] gen_highlights_menu ( properties [ [string] ] , prefix ) [EOL] [EOL] def gen_help_menu ( name , prefix ) : [EOL] [docstring] [EOL] [EOL] help_priority = [string] [EOL] sep_priority = [string] [EOL] [EOL] help_item = [string] % locals ( ) [EOL] hl_menus . append ( help_item ) [EOL] [EOL] sep_item = [string] % locals ( ) [EOL] hl_menus . append ( sep_item ) [EOL] [EOL] def gen_files_menu ( path , prefix , load_order ) : [EOL] [docstring] [EOL] [EOL] item_priority = [string] [EOL] [EOL] file_path = trunc_file_path = sanitise_menu ( path ) [EOL] file_dir_path = sanitise_menu ( os . path . dirname ( path ) ) [EOL] [EOL] [comment] [EOL] file_path_cmd = file_path . replace ( [string] , [string] ) [EOL] file_dir_path_cmd = file_dir_path . replace ( [string] , [string] ) [EOL] [EOL] if len ( file_path ) > HL_MENU_TRUNC_LIMIT : [EOL] trunc_file_path = [string] + sanitise_menu ( path [ - HL_MENU_TRUNC_LIMIT : ] ) [EOL] [EOL] if sys . platform == [string] : [EOL] reveal_cmd = [string] [EOL] [EOL] open_item = [string] % locals ( ) [EOL] hl_menus . append ( open_item ) [EOL] [EOL] explore_item = [string] % locals ( ) [EOL] hl_menus . append ( explore_item ) [EOL] [EOL] try : [EOL] reveal_item = [string] % locals ( ) [EOL] hl_menus . append ( reveal_item ) [EOL] except KeyError : [EOL] pass [comment] [EOL] [EOL] if HL_SHOW_LOAD_ORDER : [EOL] sep_item = [string] % locals ( ) [EOL] hl_menus . append ( sep_item ) [EOL] [EOL] order_item = [string] % locals ( ) [EOL] hl_menus . append ( order_item ) [EOL] disabled_item = [string] % locals ( ) [EOL] hl_menus . append ( disabled_item ) [EOL] [EOL] def gen_commands_menu ( commands , prefix ) : [EOL] [docstring] [EOL] [EOL] item_priority = [string] [EOL] [EOL] for command in commands : [EOL] name = sanitise_menu ( command [ [number] ] ) [EOL] definition = sanitise_menu ( command [ [number] ] ) [EOL] [EOL] command_item = [string] % locals ( ) [EOL] hl_menus . append ( command_item ) [EOL] [EOL] def gen_mappings_menu ( mappings , prefix ) : [EOL] [docstring] [EOL] [EOL] item_priority = [string] [EOL] [EOL] for mode , lhs , rhs in mappings : [EOL] mode = sanitise_menu ( mode ) [EOL] lhs = sanitise_menu ( lhs ) [EOL] rhs = sanitise_menu ( rhs ) [EOL] [EOL] mapping_item = [string] % locals ( ) [EOL] hl_menus . append ( mapping_item ) [EOL] disabled_item = [string] % locals ( ) [EOL] hl_menus . append ( disabled_item ) [EOL] [EOL] def gen_abbreviations_menu ( abbreviations , prefix ) : [EOL] [docstring] [EOL] [EOL] item_priority = [string] [EOL] [EOL] for mode , lhs , rhs in abbreviations : [EOL] mode = sanitise_menu ( mode ) [EOL] lhs = trunc_lhs = sanitise_menu ( lhs ) [EOL] rhs = sanitise_menu ( rhs ) [EOL] [EOL] if len ( lhs ) > HL_MENU_TRUNC_LIMIT : [EOL] trunc_lhs = lhs [ : HL_MENU_TRUNC_LIMIT ] + [string] [EOL] [EOL] [comment] [EOL] abbr_item = [string] % locals ( ) [EOL] hl_menus . append ( abbr_item ) [EOL] disabled_item = [string] % locals ( ) [EOL] hl_menus . append ( disabled_item ) [EOL] [EOL] def gen_functions_menu ( functions , prefix ) : [EOL] [docstring] [EOL] [EOL] item_priority = [string] [EOL] [EOL] for function in functions : [EOL] trunc_function = sanitise_menu ( function ) [EOL] function_label = [string] [EOL] [EOL] [comment] [EOL] if len ( function ) > HL_MENU_TRUNC_LIMIT : [EOL] function_label = trunc_function [EOL] trunc_function = trunc_function [ : HL_MENU_TRUNC_LIMIT ] + [string] [EOL] [EOL] function_item = [string] % locals ( ) [EOL] hl_menus . append ( function_item ) [EOL] disabled_item = [string] % locals ( ) [EOL] hl_menus . append ( disabled_item ) [EOL] [EOL] def gen_highlights_menu ( highlights , prefix ) : [EOL] [docstring] [EOL] [EOL] item_priority = [string] [EOL] [EOL] for group , terminal_list in highlights : [EOL] group = sanitise_menu ( group ) [EOL] [EOL] for terminal , attribute_list in iter ( list ( terminal_list . items ( ) ) ) : [EOL] terminal = sanitise_menu ( terminal ) [EOL] [EOL] for attribute in attribute_list : [EOL] attribute = sanitise_menu ( attribute ) [EOL] highlight_item = [string] % locals ( ) [EOL] hl_menus . append ( highlight_item ) [EOL] [EOL] def gen_debug_menu ( log_name ) : [EOL] [docstring] [EOL] [EOL] sep_priority = [string] [EOL] open_priority = [string] [EOL] texplore_priority = [string] [EOL] explore_priority = [string] [EOL] [EOL] log_name_label = sanitise_menu ( log_name ) [EOL] log_dir = os . path . dirname ( log_name ) [EOL] [EOL] root = HL_MENU_ROOT [EOL] [EOL] sep_item = [string] % locals ( ) [EOL] hl_menus . append ( sep_item ) [EOL] [EOL] if sys . platform == [string] : [EOL] reveal_log_cmd = [string] [EOL] [EOL] open_item = [string] % locals ( ) [EOL] hl_menus . append ( open_item ) [EOL] [EOL] explore_item = [string] % locals ( ) [EOL] hl_menus . append ( explore_item ) [EOL] [EOL] try : [EOL] reveal_item = [string] % locals ( ) [EOL] hl_menus . append ( reveal_item ) [EOL] except KeyError : [EOL] pass [comment] [EOL] [EOL] def do_debug ( ) : [EOL] [docstring] [EOL] [EOL] import tempfile [EOL] import platform [EOL] [EOL] log_file = tempfile . NamedTemporaryFile ( prefix = HL_LOGNAME_PREFIX , suffix = HL_LOGNAME_SUFFIX , delete = False ) [EOL] [EOL] gen_debug_menu ( log_file . name ) [EOL] [EOL] date = time . ctime ( ) [EOL] platform = platform . platform ( ) [EOL] errors = [string] . join ( hl_errors ) [EOL] scriptnames = [string] . join ( hl_scriptnames ) [EOL] categories = [string] . join ( [string] % ( key . upper ( ) , hl_categories [ key ] ) for key in iter ( list ( hl_categories . keys ( ) ) ) ) [EOL] menus = [string] . join ( hl_menus ) [EOL] vim_time = hl_vim_execution_time [EOL] python_time = time . time ( ) - hl_start_time [EOL] [EOL] log_file . write ( [string] % locals ( ) ) [EOL] [EOL] log_file . close ( ) [EOL] [EOL] return log_file . name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Union , Type , List [EOL] import typing [EOL] import types [EOL] [docstring] [EOL] import sys [EOL] [EOL] import vim [EOL] from jedi_vim import PythonToVimStr [EOL] [EOL] [EOL] def echo ( msg ) : [EOL] vim . command ( [string] % PythonToVimStr ( msg ) ) [EOL] [EOL] [EOL] def echo_error ( msg ) : [EOL] vim . command ( [string] ) [EOL] echo ( msg ) [EOL] vim . command ( [string] ) [EOL] [EOL] [EOL] def format_exc_info ( exc_info = None , tb_indent = [number] ) : [EOL] import traceback [EOL] [EOL] if exc_info is None : [EOL] exc_info = sys . exc_info ( ) [EOL] [EOL] exc_msg = traceback . format_exception_only ( exc_info [ [number] ] , exc_info [ [number] ] ) [EOL] lines = [string] . join ( exc_msg ) . rstrip ( [string] ) . split ( [string] ) [EOL] [EOL] lines . append ( [string] ) [EOL] tb = traceback . format_tb ( exc_info [ [number] ] ) [EOL] lines . extend ( [string] . join ( tb ) . rstrip ( [string] ) . split ( [string] ) ) [EOL] [EOL] indent = [string] * tb_indent [EOL] return [string] . format ( ( [string] + indent ) . join ( lines ) ) [EOL] [EOL] [EOL] def display_debug_info ( ) : [EOL] echo ( [string] . format ( sys . executable ) ) [EOL] echo ( [string] . format ( [string] . join ( [ x . strip ( ) for x in sys . version . split ( [string] ) ] ) ) ) [EOL] echo ( [string] . format ( __import__ ( [string] ) . __file__ ) ) [EOL] [EOL] try : [EOL] import jedi_vim [EOL] except Exception : [EOL] echo_error ( [string] . format ( format_exc_info ( ) ) ) [EOL] return [EOL] [EOL] if jedi_vim . jedi is None : [EOL] if hasattr ( jedi_vim , [string] ) : [EOL] error_msg = format_exc_info ( jedi_vim . jedi_import_error ) [EOL] else : [EOL] error_msg = [string] [EOL] echo_error ( [string] . format ( error_msg ) ) [EOL] else : [EOL] echo ( [string] . format ( jedi_vim . jedi . __file__ ) ) [EOL] echo ( [string] . format ( jedi_vim . jedi . __version__ ) ) [EOL] [EOL] try : [EOL] environment = jedi_vim . get_environment ( use_cache = False ) [EOL] except AttributeError : [EOL] script_evaluator = jedi_vim . jedi . Script ( [string] ) . _evaluator [EOL] try : [EOL] sys_path = script_evaluator . project . sys_path [EOL] except AttributeError : [EOL] sys_path = script_evaluator . sys_path [EOL] else : [EOL] echo ( [string] . format ( environment ) ) [EOL] echo ( [string] . format ( environment . executable ) ) [EOL] try : [EOL] sys_path = environment . get_sys_path ( ) [EOL] except Exception : [EOL] echo_error ( [string] . format ( format_exc_info ( ) ) ) [EOL] return [EOL] [EOL] echo ( [string] ) [EOL] for p in sys_path : [EOL] echo ( [string] . format ( p ) ) [EOL] [EOL] if environment : [EOL] echo ( [string] ) [EOL] for environment in jedi_vim . get_known_environments ( ) : [EOL] echo ( [string] . format ( environment , environment . executable , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import re [EOL] import deoplete . util [EOL] [EOL] from . base import Base [EOL] [EOL] class Source ( Base ) : [EOL] def __init__ ( self , vim ) : [EOL] Base . __init__ ( self , vim ) [EOL] [EOL] self . name = [string] [EOL] self . mark = [string] [EOL] self . filetypes = [ [string] ] [EOL] self . is_bytepos = True [EOL] self . rank = [number] [EOL] [EOL] def get_complete_position ( self , context ) : [EOL] return self . vim . call ( [string] ) [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] return self . vim . call ( [string] , context [ [string] ] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] def regular_func ( bar , baz ) : [EOL] print ( bar ) [EOL] [EOL] print ( baz ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def multiline_func_def ( baz , quux ) : [EOL] print ( baz ) [EOL] print ( quux ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] [EOL] def oneliner ( ) : pass [EOL] [EOL] [EOL] def multiline_def_oneliner ( asdf , qwer ) : pass [EOL] [EOL] [EOL] def nested_func ( ) : [EOL] print ( [string] ) [EOL] [EOL] def the_inner_func ( ) : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] class TrySomething ( ) : [EOL] def foo ( self ) : [EOL] try : [EOL] print ( [string] ) [EOL] except Exception as e : [EOL] print ( e ) [EOL] finally : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class RegularClass ( ) : [EOL] def __init__ ( self ) : [EOL] print ( [string] ) [EOL] pass [EOL] [EOL] def bar ( self ) : [EOL] print ( self . bar ) [EOL] [EOL] [EOL] class NestedClass ( ) : [EOL] class InHere ( ) : [EOL] pass [EOL] [EOL] [EOL] def this_func_has_a_func ( ) : [EOL] def foo ( ) : [EOL] pass [EOL] [EOL] class InsideFunc ( ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def foo ( self ) : [EOL] print ( foo ) [EOL] [EOL] [EOL] def one_stmt ( ) : [EOL] pass [EOL] [EOL] [EOL] class no_defs ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class NoAncestor : [EOL] def foo ( self ) : [EOL] pass [EOL] [EOL] def bar ( self ) : [EOL] pass [EOL] [EOL] [EOL] def decorator ( f , * args ) : [EOL] pass [EOL] [EOL] @ decorator class ClassWithDecorator : [EOL] pass [EOL] [EOL] [EOL] @ decorator @ decorator ( [number] , [number] ) class ClassWithDecorators : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] @ decorator def function_with_decorator ( ) : [EOL] pass [EOL] [EOL] [EOL] @ decorator @ decorator ( [number] , [number] ) def function_with_decorators ( ) : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] async def function_name ( foo ) : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] @ decorator @ decorator ( [string] , [string] ) @ decorator ( [number] , [number] ) @ decorator ( [number] , [number] , ) @ decorator ( [number] , [number] , ) def function_with_multiline_decorators ( ) : [EOL] [comment] [EOL] pass [EOL] [EOL] @ decorator @ decorator ( [string] , [string] ) @ decorator ( [number] , [number] ) @ decorator ( [number] , [number] , ) @ decorator ( [number] , [number] , ) class ClassWithMultilineDecorators : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] class RegularClass ( ) : [EOL] def foo ( self ) : [EOL] pass [EOL] [EOL] @ decorator def method_with_decorator ( self ) : [EOL] pass [EOL] [EOL] [EOL] def at_end_of_file ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] import sys [EOL] import time [EOL] [EOL] [comment] [EOL] pid = os . fork ( ) [EOL] [EOL] [comment] [EOL] c = [string] if pid == [number] else [string] [EOL] [EOL] if pid == [number] : [EOL] sys . exit ( [number] ) [EOL] [EOL] while True : [EOL] time . sleep ( [number] ) [EOL] sys . stderr . write ( c ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] from typing import Dict [EOL] import typing [EOL] kinds = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] TokenKinds = [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Pattern , Any [EOL] import typing [EOL] import re [EOL] import vim [EOL] [EOL] def snippetsInit ( ) : [EOL] vim . command ( [string] ) [EOL] vim . command ( [string] ) [EOL] if int ( vim . eval ( [string] ) ) == [number] : [EOL] vim . command ( [string] ) [EOL] vim . command ( [string] ) [EOL] vim . command ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def snippetsFormatPlaceHolder ( word ) : [EOL] return [string] % word [EOL] [EOL] def snippetsAddSnippet ( fullname , word , abbr ) : [EOL] return word [EOL] [EOL] r = re . compile ( [string] ) [EOL] [EOL] def snippetsTrigger ( ) : [EOL] if r . search ( vim . current . line ) is None : [EOL] return [EOL] vim . command ( [string] ) [EOL] [EOL] def snippetsReset ( ) : [EOL] pass [EOL] [EOL] def updateSnips ( ) : [EOL] line = vim . current . line [EOL] row , col = vim . current . window . cursor [EOL] [EOL] result = r . search ( line , col ) [EOL] if result is None : [EOL] result = r . search ( line ) [EOL] if result is None : [EOL] vim . command ( [string] ) [EOL] return [EOL] [EOL] start , end = result . span ( ) [EOL] vim . current . window . cursor = row , start [EOL] isInclusive = vim . eval ( [string] ) == [string] [EOL] vim . command ( [string] % ( end - start - isInclusive ) ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def snippetsInit ( ) : [EOL] pass [EOL] [EOL] def snippetsFormatPlaceHolder ( word ) : [EOL] return [string] [EOL] [EOL] def snippetsAddSnippet ( fullname , word , abbr ) : [EOL] return abbr [EOL] [EOL] def snippetsTrigger ( ) : [EOL] pass [EOL] [EOL] def snippetsReset ( ) : [EOL] pass [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] __all__ = [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from __future__ import print_function [EOL] from sys import argv , exit [EOL] [EOL] [EOL] if len ( argv ) != [number] : [EOL] exit ( [number] ) [EOL] [EOL] try : [EOL] compile ( open ( argv [ [number] ] ) . read ( ) , argv [ [number] ] , [string] , [number] , [number] ) [EOL] except SyntaxError as err : [EOL] print ( [string] % ( err . filename , err . lineno , err . offset , err . msg ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import socket [EOL] [docstring] [EOL] import os [EOL] import socket [EOL] import sys [EOL] [EOL] [EOL] def main ( ) : [EOL] if len ( sys . argv ) < [number] or not sys . argv [ [number] ] . isdigit ( ) : [EOL] sys . exit ( [string] ) [EOL] [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] sock . bind ( ( [string] , int ( sys . argv [ [number] ] ) ) ) [EOL] sock . listen ( [number] ) [EOL] [EOL] pid = os . fork ( ) [EOL] [EOL] if pid : [EOL] print ( pid ) [EOL] sys . exit ( ) [EOL] [EOL] while True : [EOL] connection = sock . accept ( ) [ [number] ] [EOL] connection . settimeout ( [number] ) [EOL] [EOL] while True : [EOL] try : [EOL] connection . send ( connection . recv ( [number] ) ) [EOL] except socket . timeout : [EOL] break [EOL] [EOL] connection . close ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
from typing import Any , Dict , Union [EOL] import typing [EOL] import _importlib_modulespec [EOL] import unittest [EOL] import imp [EOL] [EOL] ale_module = imp . load_source ( [string] , [string] , ) [EOL] [EOL] [EOL] class VimMock ( object ) : [EOL] def __init__ ( self , call_list , call_results , commands ) : [EOL] self . __call_list = call_list [EOL] self . __call_results = call_results [EOL] [EOL] self . __commands = commands [EOL] [EOL] def call ( self , function , * args ) : [EOL] self . __call_list . append ( ( function , args ) ) [EOL] [EOL] return self . __call_results . get ( function , [number] ) [EOL] [EOL] def command ( self , command ) : [EOL] self . __commands . append ( command ) [EOL] [EOL] [EOL] class DeopleteSourceTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] super ( DeopleteSourceTest , self ) . setUp ( ) [EOL] [EOL] self . call_list = [ ] [EOL] self . call_results = { [string] : [number] } [EOL] self . commands = [ ] [EOL] self . source = ale_module . Source ( [string] ) [EOL] self . source . vim = VimMock ( self . call_list , self . call_results , self . commands ) [EOL] [EOL] def test_attributes ( self ) : [EOL] [docstring] [EOL] attributes = dict ( ( key , getattr ( self . source , key ) ) for key in dir ( self . source ) if not key . startswith ( [string] ) [EOL] and key != [string] [EOL] and not hasattr ( getattr ( self . source , key ) , [string] ) ) [EOL] [EOL] self . assertEqual ( attributes , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : True , [string] : True , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [number] , } ) [EOL] [EOL] def test_complete_position ( self ) : [EOL] self . call_results [ [string] ] = [number] [EOL] context = { [string] : [string] } [EOL] [EOL] self . assertEqual ( self . source . get_complete_position ( context ) , [number] ) [EOL] self . assertEqual ( self . call_list , [ ( [string] , ( [string] , ) ) , ] ) [EOL] [EOL] def test_request_completion_results ( self ) : [EOL] context = { [string] : [string] , [string] : True } [EOL] [EOL] self . assertEqual ( self . source . gather_candidates ( context ) , [ ] ) [EOL] self . assertEqual ( self . call_list , [ ( [string] , ( ) ) , ] ) [EOL] self . assertEqual ( self . commands , [ [string] + [string] ] ) [EOL] [EOL] def test_request_completion_results_from_buffer_without_providers ( self ) : [EOL] self . call_results [ [string] ] = [number] [EOL] context = { [string] : [string] , [string] : True } [EOL] [EOL] self . assertIsNone ( self . source . gather_candidates ( context ) , [ ] ) [EOL] self . assertEqual ( self . call_list , [ ( [string] , ( ) ) , ] ) [EOL] [EOL] def test_async_event ( self ) : [EOL] context = { [string] : [string] , [string] : True } [EOL] self . call_results [ [string] ] = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , } , ] [EOL] [EOL] self . assertEqual ( self . source . gather_candidates ( context ) , [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , } , ] ) [EOL] [EOL] self . assertEqual ( self . call_list , [ ( [string] , ( ) ) , ( [string] , ( ) ) , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] __author__ = [string] [EOL] [EOL] try : [EOL] from deoplete . source . base import Base [EOL] except ImportError : [EOL] [comment] [EOL] [comment] [EOL] class Base ( object ) : [EOL] def __init__ ( self , vim ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( Source , self ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . mark = [string] [EOL] self . rank = [number] [EOL] self . is_bytepos = True [EOL] self . min_pattern_length = [number] [EOL] self . is_volatile = True [EOL] [comment] [EOL] [comment] [EOL] self . input_patterns = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [comment] [EOL] def get_complete_position ( self , context ) : [EOL] return self . vim . call ( [string] , context [ [string] ] ) [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] [comment] [EOL] if not self . vim . call ( [string] ) : [EOL] return None [EOL] [EOL] event = context . get ( [string] ) [EOL] [EOL] if event == [string] : [EOL] result = self . vim . call ( [string] ) [EOL] [EOL] return result or [ ] [EOL] [EOL] if context . get ( [string] ) : [EOL] self . vim . command ( [string] + [string] ) [EOL] [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Pattern , Any , Dict , List [EOL] import typing [EOL] import re , sys [EOL] [EOL] def code_points ( text ) : [EOL] import struct [EOL] utf32 = text . encode ( [string] ) [EOL] return struct . unpack ( [string] . format ( len ( utf32 ) // [number] ) , utf32 ) [EOL] [EOL] def does_support ( enc , font , chars ) : [EOL] import fontconfig [EOL] fonts = fontconfig . query ( ) [EOL] font_re = re . compile ( sys . argv [ [number] ] ) [EOL] [comment] [EOL] fonts = [ path for path in fonts if re . search ( font_re , path ) ] [EOL] if len ( fonts ) == [number] : [EOL] return { [string] : [string] + font } [EOL] [comment] [EOL] res = { } [EOL] [EOL] for c in chars : [EOL] if c . startswith ( [string] ) : [EOL] if ( sys . version_info > ( [number] , [number] ) ) : [comment] [EOL] c_dec = chr ( int ( c [ [number] : ] , [number] ) ) [EOL] else : [comment] [EOL] c_dec = ( [string] % int ( c [ [number] : ] , [number] ) ) . decode ( [string] ) [EOL] elif isinstance ( c , bytes ) : [EOL] c_dec = c . decode ( enc ) [EOL] else : [EOL] c_dec = c [EOL] [comment] [EOL] [comment] [EOL] cp = code_points ( c_dec ) [EOL] [comment] [EOL] if sys . maxunicode < cp [ [number] ] : [EOL] [comment] [EOL] [comment] [EOL] res . update ( { c : [number] } ) [EOL] continue [EOL] for path in fonts : [EOL] font = fontconfig . FcFont ( path ) [EOL] [comment] [EOL] if font . has_char ( c_dec ) : [EOL] [comment] [EOL] res . update ( { c_dec : [number] } ) [EOL] break [EOL] else : [EOL] res . update ( { c_dec : [number] } ) [EOL] [EOL] return res [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] enc = sys . argv [ [number] ] [EOL] font = sys . argv [ [number] ] [EOL] chars = sys . argv [ [number] : ] [EOL] res = does_support ( enc , font , chars ) [EOL] [EOL] print ( res ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from . base import Base [EOL] import re [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] Base . __init__ ( self , vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = [string] [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] self . vim . call ( [string] ) [EOL] candidates = [ ] [EOL] for [ register , history ] in self . vim . call ( [string] ) . items ( ) : [EOL] candidates += [ { [string] : register + [string] + re . sub ( [string] , [string] , x [ [number] ] ) [ : [number] ] , [string] : x [ [number] ] , } for x in history ] [EOL] return candidates [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[comment] [EOL] from typing import Any , Dict , List , Union [EOL] import typing [EOL] API_INFO = { [string] : { [string] : [number] , [string] : [number] , [string] : False , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : { [string] : { [string] : [number] , [string] : [string] } , [string] : { [string] : [number] , [string] : [string] } , [string] : { [string] : [number] , [string] : [string] } } , [string] : [ { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : False , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } , { [string] : True , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [number] } ] , [string] : { [string] : { [string] : [number] } , [string] : { [string] : [number] } } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Pattern , Any , Dict [EOL] import typing [EOL] import urllib [EOL] import re [EOL] import json [EOL] import os [EOL] [EOL] dcregex = re . compile ( [string] ) [EOL] [EOL] def getdrchip ( ) : [EOL] return urllib . urlopen ( [string] ) [EOL] [EOL] def drchip_to_source ( s ) : [EOL] sources = s . strip ( ) . split ( [string] ) [EOL] if len ( sources ) != [number] : [EOL] return None , None [EOL] name , url , version = sources [EOL] name = dcregex . subn ( [string] , name ) [ [number] ] + [string] [EOL] return name , { [string] : [string] , [string] : url , [string] : version , [string] : [string] , } [EOL] [EOL] def create_db ( ) : [EOL] result = { } [EOL] for line in getdrchip ( ) : [EOL] name , source = drchip_to_source ( line ) [EOL] if name : [EOL] result [ name ] = source [EOL] return result [EOL] [EOL] def write_db ( db ) : [EOL] with open ( os . path . join ( [string] , [string] ) , [string] ) as F : [EOL] json . dump ( db , F , indent = [number] , sort_keys = True , separators = ( [string] , [string] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] write_db ( create_db ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Tuple [EOL] import pi [EOL] import typing [EOL] import pack [EOL] import logging [EOL] from github import Github , GithubException [EOL] import logging [EOL] [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [EOL] class GithubLazy ( object ) : [EOL] [docstring] [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . args = args [EOL] self . kwargs = kwargs [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] if attr == [string] : [EOL] self . gh = Github ( * self . args , ** self . kwargs ) [EOL] return self . gh [EOL] else : [EOL] return getattr ( self . gh , attr ) [EOL] [EOL] def _list_github_files ( repo , dir = None , attempt = [number] ) : [EOL] try : [EOL] for f in repo . get_dir_contents ( dir or [string] ) : [EOL] name = ( dir + [string] + f . name if dir else f . name ) [EOL] if f . type == [string] : [EOL] yield name [EOL] elif f . type == [string] : [EOL] for subf in _list_github_files ( repo , name ) : [EOL] yield subf [EOL] except GithubException as e : [EOL] if [number] <= e . status : [EOL] if attempt < MAX_ATTEMPTS : [EOL] logger . error ( [string] % repr ( e ) ) [EOL] for fname in _list_github_files ( repo , dir , attempt + [number] ) : [EOL] yield fname [EOL] else : [EOL] raise [EOL] else : [EOL] raise [EOL] [EOL] [EOL] gh = None [EOL] [EOL] def init_gh ( user , password ) : [EOL] [docstring] [EOL] global gh [EOL] gh = GithubLazy ( user , password ) [EOL] [EOL] [EOL] def list_github_files ( repo_path ) : [EOL] [docstring] [EOL] return _list_github_files ( gh . get_repo ( repo_path ) ) [EOL] [EOL] [EOL] def list_gist_files ( name ) : [EOL] [docstring] [EOL] return gh . get_gist ( name ) . files [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] from subvertpy . ra import RemoteAccess , DIRENT_KIND [EOL] from subvertpy import NODE_DIR [EOL] [EOL] class NoFilesError ( Exception ) : [EOL] pass [EOL] [EOL] def _list_svn_files ( conn , path = [string] , only_trunk = True ) : [EOL] dirents , frev , props = conn . get_dir ( path , - [number] , DIRENT_KIND ) [EOL] if not path and only_trunk and [string] in dirents : [EOL] dirents = { [string] : dirents [ [string] ] } [EOL] for fname , props in dirents . items ( ) : [EOL] new_path = ( path + [string] if path else [string] ) + fname [EOL] contains = False [EOL] if props [ [string] ] == NODE_DIR : [EOL] for full_fname in _list_svn_files ( conn , new_path ) : [EOL] yield full_fname [EOL] else : [EOL] yield new_path [EOL] [EOL] def list_svn_files ( url , only_trunk = True ) : [EOL] [docstring] [EOL] conn = RemoteAccess ( url ) [EOL] try : [EOL] return _list_svn_files ( conn , only_trunk = only_trunk ) [EOL] except NoFilesError : [EOL] return [ ] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from tempfile import mkdtemp [EOL] from subprocess import check_call , check_output [EOL] import os [EOL] from shutil import rmtree [EOL] import sys [EOL] [EOL] [EOL] def list_git_files ( url , allow_depth = True ) : [EOL] [docstring] [EOL] tmpdir = mkdtemp ( suffix = [string] ) [EOL] try : [EOL] check_call ( [ [string] , [string] ] + ( [ [string] ] if allow_depth else [ ] ) + [ [string] , url , tmpdir ] , stdout = sys . stderr ) [EOL] if os . path . isdir ( tmpdir ) : [EOL] return check_output ( [ [string] , [string] + os . path . join ( tmpdir , [string] ) , [string] + tmpdir , [string] , [string] ] ) . split ( [string] ) [EOL] else : [EOL] raise IOError ( [string] . format ( url , tmpdir ) ) [EOL] finally : [EOL] if os . path . isdir ( tmpdir ) : [EOL] rmtree ( tmpdir ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Match , Any , List [EOL] import typing [EOL] import re [EOL] from deoplete . base . source import Base [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] def __init__ ( self , vim ) : [EOL] Base . __init__ ( self , vim ) [EOL] [EOL] self . name = [string] [EOL] self . mark = [string] [EOL] self . rank = [number] [EOL] self . __cache = { } [EOL] [EOL] def on_event ( self , context ) : [EOL] self . __cache [ context [ [string] ] ] = self . vim . eval ( [string] ) [EOL] for candidate in self . __cache [ context [ [string] ] ] : [EOL] candidate [ [string] ] = [number] [EOL] candidate [ [string] ] = candidate [ [string] ] [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] candidates = self . __cache . get ( context [ [string] ] , [ ] ) [EOL] if context [ [string] ] not in self . __cache : [EOL] self . on_event ( context ) [EOL] m1 = re . match ( [string] , context [ [string] ] ) [EOL] m2 = re . match ( [string] , context [ [string] ] ) [EOL] if m1 and m2 and m1 . group ( [number] ) != m2 . group ( [number] ) : [EOL] candidates = [ x for x in candidates if x [ [string] ] [ [string] ] ] [EOL] return candidates [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from . base import Base [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = [string] [EOL] [EOL] self . _snippets = [ ] [EOL] [EOL] def on_init ( self , context ) : [EOL] self . _snippets = self . vim . eval ( [string] ) [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] candidates = [ ] [EOL] for snippet in self . _snippets : [EOL] candidates . append ( { [string] : snippet [ [string] ] , [string] : [string] . format ( snippet [ [string] ] , snippet [ [string] ] ) , [string] : snippet [ [string] ] , } ) [EOL] return candidates [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import Any [EOL] import typing [EOL] import sys [EOL] from os . path import normpath , join [EOL] import vim [EOL] plugin_root_dir = vim . eval ( [string] ) [EOL] python_root_dir = normpath ( join ( plugin_root_dir , [string] , [string] ) ) [EOL] sys . path . insert ( [number] , python_root_dir ) [EOL] import clap [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] lines = [ [string] , [string] , [string] , ] [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] disordered = json . load ( f ) [EOL] sorted_dict = { k : disordered [ k ] for k in sorted ( disordered ) } [EOL] [EOL] joined_tuples = [string] . join ( map ( lambda kv : [string] % ( kv [ [number] ] , kv [ [number] ] ) , sorted_dict . items ( ) ) ) [EOL] lines . append ( [string] % joined_tuples ) [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] disordered = json . load ( f ) [EOL] sorted_dict = { k : disordered [ k ] for k in sorted ( disordered ) } [EOL] [EOL] joined_tuples = [string] . join ( map ( lambda kv : [string] % ( kv [ [number] ] , kv [ [number] ] ) , sorted_dict . items ( ) ) ) [EOL] lines . append ( [string] % joined_tuples ) [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] disordered = json . load ( f ) [EOL] sorted_dict = { k : disordered [ k ] for k in sorted ( disordered ) } [EOL] [EOL] joined_tuples = [string] . join ( map ( lambda kv : [string] % ( kv [ [number] ] , kv [ [number] ] ) , sorted_dict . items ( ) ) ) [EOL] lines . append ( [string] % joined_tuples ) [EOL] [EOL] lines . append ( [string] ) [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( [string] . join ( lines ) ) [EOL] [EOL] os . system ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import io [EOL] import datetime [EOL] import datetime [EOL] import sys [EOL] [EOL] if len ( sys . argv ) != [number] : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] exit ( [number] ) [EOL] [EOL] next_tag = sys . argv [ [number] ] [EOL] if next_tag . startswith ( [string] ) : [EOL] next_tag = next_tag [ [number] : ] [EOL] next_maple_version = sys . argv [ [number] ] [EOL] [EOL] [EOL] def write_back ( lines , f ) : [EOL] with open ( f , [string] ) as writer : [EOL] writer . writelines ( lines ) [EOL] [EOL] [EOL] def read_file ( fname ) : [EOL] f = open ( fname ) [EOL] return f . readlines ( ) [EOL] [EOL] [EOL] [comment] [EOL] fname = [string] [EOL] lines = read_file ( fname ) [EOL] lines [ [number] ] = [string] . format ( version = next_tag ) [EOL] write_back ( lines , fname ) [EOL] [EOL] [comment] [EOL] fname = [string] [EOL] lines = read_file ( fname ) [EOL] lines [ [number] ] = [string] . format ( version = next_tag ) [EOL] write_back ( lines , fname ) [EOL] [EOL] [comment] [EOL] fname = [string] [EOL] lines = read_file ( fname ) [EOL] lines [ [number] ] = [string] . format ( version = next_tag ) [EOL] write_back ( lines , fname ) [EOL] [EOL] [comment] [EOL] fname = [string] [EOL] lines = read_file ( fname ) [EOL] now = datetime . datetime . now ( ) [EOL] today = now . strftime ( [string] ) [EOL] release_header = [string] . format ( version = next_tag , today = today ) [EOL] lines . insert ( [number] , [string] ) [EOL] lines . insert ( [number] , release_header ) [EOL] lines . insert ( [number] , [string] ) [EOL] write_back ( lines , fname ) [EOL] [EOL] [comment] [EOL] fname = [string] [EOL] lines = read_file ( fname ) [EOL] lines [ [number] ] = [string] . format ( version = next_maple_version ) [EOL] write_back ( lines , fname ) [EOL] [EOL] [comment] [EOL] fname = [string] [EOL] lines = read_file ( fname ) [EOL] lines [ [number] ] = [string] . format ( version = next_tag ) [EOL] write_back ( lines , fname ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.str$ 0 $datetime.datetime$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import functools [EOL] from functools import partial [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] SCORE_MIN = float ( [string] ) [EOL] SCORE_MAX = float ( [string] ) [EOL] SCORE_GAP_LEADING = - [number] [EOL] SCORE_GAP_TRAILING = - [number] [EOL] SCORE_GAP_INNER = - [number] [EOL] SCORE_MATCH_CONSECUTIVE = [number] [EOL] [EOL] [EOL] def char_range_with ( c_start , c_stop , v , d ) : [EOL] d = d . copy ( ) [EOL] d . update ( ( chr ( c ) , v ) for c in range ( ord ( c_start ) , ord ( c_stop ) + [number] ) ) [EOL] return d [EOL] [EOL] [EOL] lower_with = partial ( char_range_with , [string] , [string] ) [EOL] upper_with = partial ( char_range_with , [string] , [string] ) [EOL] digit_with = partial ( char_range_with , [string] , [string] ) [EOL] [EOL] SCORE_MATCH_SLASH = [number] [EOL] SCORE_MATCH_WORD = [number] [EOL] SCORE_MATCH_CAPITAL = [number] [EOL] SCORE_MATCH_DOT = [number] [EOL] BONUS_MAP = { [string] : SCORE_MATCH_SLASH , [string] : SCORE_MATCH_WORD , [string] : SCORE_MATCH_WORD , [string] : SCORE_MATCH_WORD , [string] : SCORE_MATCH_DOT , } [EOL] BONUS_STATES = [ { } , BONUS_MAP , lower_with ( SCORE_MATCH_CAPITAL , BONUS_MAP ) ] [EOL] BONUS_INDEX = digit_with ( [number] , lower_with ( [number] , upper_with ( [number] , { } ) ) ) [EOL] [EOL] [EOL] def bonus ( haystack ) : [EOL] [docstring] [EOL] c_prev = [string] [EOL] bonus = [ ] [EOL] for c in haystack : [EOL] bonus . append ( BONUS_STATES [ BONUS_INDEX . get ( c , [number] ) ] . get ( c_prev , [number] ) ) [EOL] c_prev = c [EOL] return bonus [EOL] [EOL] [EOL] def subsequence ( niddle , haystack ) : [EOL] [docstring] [EOL] niddle , haystack = niddle . lower ( ) , haystack . lower ( ) [EOL] if not niddle : [EOL] return True [EOL] offset = [number] [EOL] for char in niddle : [EOL] offset = haystack . find ( char , offset ) + [number] [EOL] if offset <= [number] : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def compute ( niddle , haystack ) : [EOL] [docstring] [EOL] n , m = len ( niddle ) , len ( haystack ) [EOL] bonus_score = bonus ( haystack ) [EOL] niddle , haystack = niddle . lower ( ) , haystack . lower ( ) [EOL] [EOL] if n == [number] or n == m : [EOL] return SCORE_MAX , list ( range ( n ) ) [EOL] [EOL] D = [ [ [number] ] * m for _ in range ( n ) ] [comment] [EOL] M = [ [ [number] ] * m for _ in range ( n ) ] [comment] [EOL] [EOL] for i in range ( n ) : [EOL] prev_score = SCORE_MIN [EOL] gap_score = SCORE_GAP_TRAILING if i == n - [number] else SCORE_GAP_INNER [EOL] [EOL] for j in range ( m ) : [EOL] if niddle [ i ] == haystack [ j ] : [EOL] score = SCORE_MIN [EOL] if i == [number] : [EOL] score = j * SCORE_GAP_LEADING + bonus_score [ j ] [EOL] elif j != [number] : [EOL] score = max ( M [ i - [number] ] [ j - [number] ] + bonus_score [ j ] , D [ i - [number] ] [ j - [number] ] + SCORE_MATCH_CONSECUTIVE , ) [EOL] D [ i ] [ j ] = score [EOL] M [ i ] [ j ] = prev_score = max ( score , prev_score + gap_score ) [EOL] else : [EOL] D [ i ] [ j ] = SCORE_MIN [EOL] M [ i ] [ j ] = prev_score = prev_score + gap_score [EOL] [EOL] return D , M [EOL] [EOL] [EOL] def positions ( niddle , haystack ) : [EOL] n , m = len ( niddle ) , len ( haystack ) [EOL] [EOL] positions = [ [number] ] * n [EOL] [EOL] if n == [number] or m == [number] : [EOL] return positions [EOL] [EOL] if n == m : [EOL] return positions [EOL] [EOL] if m > [number] : [EOL] return positions [EOL] [EOL] match_required = False [EOL] [EOL] D , M = compute ( niddle , haystack ) [EOL] [EOL] i , j = n - [number] , m - [number] [EOL] [EOL] while i >= [number] : [EOL] while j >= [number] : [EOL] if ( match_required or D [ i ] [ j ] == M [ i ] [ j ] ) and D [ i ] [ j ] != SCORE_MIN : [EOL] match_required = ( i > [number] and j > [number] [EOL] and M [ i ] [ j ] == D [ i - [number] ] [ j - [number] ] + SCORE_MATCH_CONSECUTIVE ) [EOL] positions [ i ] = j [EOL] j -= [number] [EOL] break [EOL] else : [EOL] j -= [number] [EOL] i -= [number] [EOL] [EOL] return M [ n - [number] ] [ m - [number] ] , positions [EOL] [EOL] [EOL] def score ( niddle , haystack ) : [EOL] [docstring] [EOL] n , m = len ( niddle ) , len ( haystack ) [EOL] bonus_score = bonus ( haystack ) [EOL] niddle , haystack = niddle . lower ( ) , haystack . lower ( ) [EOL] [EOL] if n == [number] or n == m : [EOL] return SCORE_MAX , list ( range ( n ) ) [EOL] D = [ [ [number] ] * m for _ in range ( n ) ] [comment] [EOL] M = [ [ [number] ] * m for _ in range ( n ) ] [comment] [EOL] for i in range ( n ) : [EOL] prev_score = SCORE_MIN [EOL] gap_score = SCORE_GAP_TRAILING if i == n - [number] else SCORE_GAP_INNER [EOL] [EOL] for j in range ( m ) : [EOL] if niddle [ i ] == haystack [ j ] : [EOL] score = SCORE_MIN [EOL] if i == [number] : [EOL] score = j * SCORE_GAP_LEADING + bonus_score [ j ] [EOL] elif j != [number] : [EOL] score = max ( M [ i - [number] ] [ j - [number] ] + bonus_score [ j ] , D [ i - [number] ] [ j - [number] ] + SCORE_MATCH_CONSECUTIVE , ) [EOL] D [ i ] [ j ] = score [EOL] M [ i ] [ j ] = prev_score = max ( score , prev_score + gap_score ) [EOL] else : [EOL] D [ i ] [ j ] = SCORE_MIN [EOL] M [ i ] [ j ] = prev_score = prev_score + gap_score [EOL] [EOL] match_required = False [EOL] positions = [ [number] ] * n [EOL] i , j = n - [number] , m - [number] [EOL] while i >= [number] : [EOL] while j >= [number] : [EOL] if ( match_required or D [ i ] [ j ] == M [ i ] [ j ] ) and D [ i ] [ j ] != SCORE_MIN : [EOL] match_required = ( i > [number] and j > [number] [EOL] and M [ i ] [ j ] == D [ i - [number] ] [ j - [number] ] + SCORE_MATCH_CONSECUTIVE ) [EOL] positions [ i ] = j [EOL] j -= [number] [EOL] break [EOL] else : [EOL] j -= [number] [EOL] i -= [number] [EOL] [EOL] return M [ n - [number] ] [ m - [number] ] , positions [EOL] [EOL] [EOL] def fzy_scorer ( niddle , haystack ) : [EOL] if subsequence ( niddle , haystack ) : [EOL] return score ( niddle , haystack ) [EOL] else : [EOL] return SCORE_MIN , None [EOL] [EOL] [EOL] def substr_scorer ( niddle , haystack ) : [EOL] positions , offset = [ ] , [number] [EOL] niddle , haystack = niddle . lower ( ) , haystack . lower ( ) [EOL] for niddle in niddle . split ( [string] ) : [EOL] if not niddle : [EOL] continue [EOL] offset = haystack . find ( niddle , offset ) [EOL] if offset < [number] : [EOL] return float ( [string] ) , None [EOL] niddle_len = len ( niddle ) [EOL] positions . extend ( range ( offset , offset + niddle_len ) ) [EOL] offset += niddle_len [EOL] if not positions : [EOL] return [number] , positions [EOL] match_len = positions [ - [number] ] + [number] - positions [ [number] ] [EOL] return - match_len + [number] / ( positions [ [number] ] + [number] ) + [number] / ( positions [ - [number] ] + [number] ) , positions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 $functools.partial[typing.Any]$ 0 $builtins.float$ 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 $typing.Any$ 0 $functools.partial[typing.Any]$ 0 0 0 $functools.partial[typing.Any]$ 0 0 0 $functools.partial[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import itertools [EOL] import random [EOL] import re [EOL] import string [EOL] [EOL] import fuzzymatch_rs [EOL] from fzy_impl import fzy_scorer [EOL] [EOL] [EOL] def fuzzy_match_py ( query , candidates ) : [EOL] scored = [ ] [EOL] [EOL] for c in candidates : [EOL] score , indices = fzy_scorer ( query , c ) [EOL] if score != float ( [string] ) : [EOL] scored . append ( { [string] : score , [string] : indices , [string] : c } ) [EOL] [EOL] ranked = sorted ( scored , key = lambda x : x [ [string] ] , reverse = True ) [EOL] [EOL] indices = [ ] [EOL] filtered = [ ] [EOL] for r in ranked : [EOL] filtered . append ( r [ [string] ] ) [EOL] indices . append ( r [ [string] ] ) [EOL] [EOL] return ( indices , filtered ) [EOL] [EOL] [EOL] query = [string] [EOL] candidates = open ( [string] , [string] ) . read ( ) . split ( [string] ) [EOL] [EOL] print ( fuzzy_match_py ( query , candidates ) ) [EOL] print ( fuzzymatch_rs . fuzzy_match ( query , candidates ) ) [EOL] [EOL] [EOL] def test_pure_python_10000 ( benchmark ) : [EOL] print ( benchmark ( fuzzy_match_py , query , candidates [ : [number] ] ) ) [EOL] [EOL] [EOL] def test_rust_10000 ( benchmark ) : [EOL] print ( benchmark ( fuzzymatch_rs . fuzzy_match , query , candidates [ : [number] ] ) ) [EOL] [EOL] [EOL] def test_pure_python_100000 ( benchmark ) : [EOL] print ( benchmark ( fuzzy_match_py , query , candidates [ : [number] ] ) ) [EOL] [EOL] [EOL] def test_rust_100000 ( benchmark ) : [EOL] print ( benchmark ( fuzzymatch_rs . fuzzy_match , query , candidates [ : [number] ] ) ) [EOL] [EOL] [EOL] def test_pure_python_200000 ( benchmark ) : [EOL] print ( benchmark ( fuzzy_match_py , query , candidates [ : [number] ] ) ) [EOL] [EOL] [EOL] def test_rust_200000 ( benchmark ) : [EOL] print ( benchmark ( fuzzymatch_rs . fuzzy_match , query , candidates [ : [number] ] ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import vim [EOL] from clap . scorer import fzy_scorer , substr_scorer [EOL] [EOL] [EOL] def str2bool ( v ) : [EOL] [comment] [EOL] [comment] [EOL] if isinstance ( v , bool ) : [EOL] return v [EOL] else : [EOL] return v . lower ( ) in ( [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def apply_score ( scorer , query , candidates , enable_icon ) : [EOL] scored = [ ] [EOL] [EOL] for c in candidates : [EOL] [comment] [EOL] if enable_icon : [EOL] candidate = c [ [number] : ] [EOL] else : [EOL] candidate = c [EOL] score , indices = scorer ( query , candidate ) [EOL] if score != float ( [string] ) : [EOL] if enable_icon : [EOL] indices = [ x + [number] for x in indices ] [EOL] scored . append ( { [string] : score , [string] : indices , [string] : c } ) [EOL] [EOL] return scored [EOL] [EOL] [EOL] def fuzzy_match_py ( query , candidates , enable_icon ) : [EOL] if [string] in query : [EOL] scorer = substr_scorer [EOL] else : [EOL] scorer = fzy_scorer [EOL] [EOL] scored = apply_score ( scorer , query , candidates , enable_icon ) [EOL] ranked = sorted ( scored , key = lambda x : x [ [string] ] , reverse = True ) [EOL] [EOL] indices = [ ] [EOL] filtered = [ ] [EOL] for r in ranked : [EOL] filtered . append ( r [ [string] ] ) [EOL] indices . append ( r [ [string] ] ) [EOL] [EOL] return ( indices , filtered ) [EOL] [EOL] [EOL] def clap_fzy_py ( ) : [EOL] return fuzzy_match_py ( vim . eval ( [string] ) , vim . eval ( [string] ) , str2bool ( vim . eval ( [string] ) ) ) [EOL] [EOL] [EOL] try : [EOL] from clap . fuzzymatch_rs import fuzzy_match as fuzzy_match_rs [EOL] [EOL] def clap_fzy_rs ( ) : [EOL] return fuzzy_match_rs ( vim . eval ( [string] ) , vim . eval ( [string] ) , int ( vim . eval ( [string] ) ) , str2bool ( vim . eval ( [string] ) ) , vim . eval ( [string] ) ) [EOL] except Exception : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] from . base import Base [EOL] from time import strftime [EOL] from denite . util import expand [EOL] import os [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = [string] [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] self . vim . call ( [string] ) [EOL] base = expand ( self . vim . vars [ [string] ] ) [EOL] [EOL] candidates = [ ] [EOL] if context [ [string] ] and context [ [string] ] [ [number] ] == [string] : [EOL] context [ [string] ] = True [EOL] filename = strftime ( [string] ) + context [ [string] ] [EOL] candidates . append ( { [string] : os . path . basename ( filename ) , [string] : [string] + os . path . basename ( filename ) , [string] : os . path . join ( base , filename ) , } ) [EOL] else : [EOL] for root , dirs , files in os . walk ( base ) : [EOL] for f in files : [EOL] candidates . append ( { [string] : f , [string] : os . path . join ( root , f ) , } ) [EOL] candidates = sorted ( candidates , key = lambda x : os . path . getmtime ( x [ [string] ] ) , reverse = True ) [EOL] return candidates [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import Any , Tuple [EOL] import typing [EOL] [docstring] [EOL] import vim [EOL] import string [EOL] BOUNDARY_CHARS = string . punctuation + string . whitespace [EOL] [EOL] [EOL] def score ( ) : [EOL] score = get_score ( vim . eval ( [string] ) , vim . eval ( [string] ) ) [EOL] if score : [EOL] vim . command ( [string] % score ) [EOL] [EOL] [EOL] def get_score ( string , query_chars ) : [EOL] [comment] [EOL] best_score , best_range = len ( string ) , None [EOL] head , tail = query_chars [ [number] ] , query_chars [ [number] : ] [EOL] [EOL] [comment] [EOL] for first_index in ( idx for idx , val in enumerate ( string ) if val == head ) : [EOL] [comment] [EOL] score , last_index = find_end_of_match ( string , tail , first_index ) [EOL] [EOL] if last_index and score < best_score : [EOL] best_score = score [EOL] best_range = ( first_index , last_index ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] best_score = best_score * ( len ( string ) ** [number] ) [EOL] return best_score [EOL] [EOL] [EOL] def find_end_of_match ( to_match , chars , first_index ) : [EOL] score , last_index , last_type = [number] , first_index , None [EOL] [EOL] for char in chars : [EOL] try : [EOL] index = to_match . index ( char , last_index + [number] ) [EOL] except ValueError : [EOL] return None , None [EOL] if not index : [EOL] return None , None [EOL] [EOL] [comment] [EOL] if index == last_index + [number] : [EOL] if last_type != [string] : [EOL] last_type = [string] [EOL] score += [number] [EOL] [comment] [EOL] elif to_match [ index - [number] ] in BOUNDARY_CHARS : [EOL] if last_type != [string] : [EOL] last_type = [string] [EOL] score += [number] [EOL] [comment] [EOL] elif char in string . ascii_uppercase and to_match [ index - [number] ] in string . ascii_lowercase : [EOL] if last_type != [string] : [EOL] last_type = [string] [EOL] score += [number] [EOL] else : [EOL] last_type = [string] [EOL] score += index - last_index [EOL] last_index = index [EOL] return ( score , last_index ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from . base import Base [EOL] [EOL] [EOL] class Kind ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] super ( ) . __init__ ( vim ) [EOL] [EOL] self . name = [string] [EOL] self . default_action = [string] [EOL] [EOL] def action_do ( self , context ) : [EOL] self . vim . call ( [string] , [string] , [ x [ [string] ] for x in context [ [string] ] ] ) [EOL] [EOL] def action_preview ( self , context ) : [EOL] self . vim . call ( [string] , [string] , [ x [ [string] ] for x in context [ [string] ] ] ) [EOL] [EOL] def action_delete ( self , context ) : [EOL] self . vim . call ( [string] , [string] , [ x [ [string] ] for x in context [ [string] ] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from . base import Base [EOL] from copy import copy [EOL] from re import sub [EOL] [EOL] [EOL] class Source ( Base ) : [EOL] [EOL] def __init__ ( self , vim ) : [EOL] Base . __init__ ( self , vim ) [EOL] [EOL] self . name = [string] [EOL] self . kind = [string] [EOL] [EOL] def gather_candidates ( self , context ) : [EOL] if not context [ [string] ] : [EOL] return [ ] [EOL] candidates = self . vim . call ( [string] , [ context [ [string] ] ] ) [EOL] [comment] [EOL] for candidate in candidates : [EOL] candidate [ [string] ] = copy ( candidate ) [EOL] candidate [ [string] ] = [string] [EOL] candidate [ [string] ] = sub ( [string] , [string] , candidate [ [string] ] ) [EOL] candidate [ [string] ] = candidate [ [string] ] + [string] + sub ( [string] , [string] , candidate . get ( [string] , candidate [ [string] ] ) ) [EOL] return candidates [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0