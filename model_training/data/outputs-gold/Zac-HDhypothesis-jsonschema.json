import builtins [EOL] import os [EOL] [EOL] import setuptools [EOL] [EOL] [EOL] def local_file ( name ) : [EOL] [docstring] [EOL] return os . path . relpath ( os . path . join ( os . path . dirname ( __file__ ) , name ) ) [EOL] [EOL] [EOL] SOURCE = local_file ( [string] ) [EOL] README = local_file ( [string] ) [EOL] [EOL] with open ( local_file ( [string] ) ) as o : [EOL] for line in o : [EOL] if line . startswith ( [string] ) : [EOL] _ , __version__ , _ = line . split ( [string] ) [EOL] [EOL] [EOL] setuptools . setup ( name = [string] , version = __version__ , author = [string] , author_email = [string] , packages = setuptools . find_packages ( SOURCE ) , package_dir = { [string] : SOURCE } , package_data = { [string] : [ [string] ] } , url = [string] , project_urls = { [string] : [string] } , license = [string] , description = [string] , zip_safe = False , install_requires = [ [string] , [string] ] , python_requires = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , long_description = open ( README ) . read ( ) , long_description_content_type = [string] , keywords = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] __version__ = [string] [EOL] __all__ = [ [string] ] [EOL] [EOL] from . _from_schema import from_schema [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict , Any , Callable , NoReturn , List , Union , Tuple , Optional [EOL] import _canonicalise [EOL] import _encode [EOL] import typing [EOL] import builtins [EOL] import jsonschema [EOL] import hypothesis [EOL] [docstring] [EOL] [EOL] import itertools [EOL] import math [EOL] import operator [EOL] import re [EOL] from fractions import Fraction [EOL] from functools import partial [EOL] from typing import Any , Callable , Dict , List , NoReturn , Optional , Set , Union [EOL] [EOL] import jsonschema [EOL] from hypothesis import assume , provisional as prov , strategies as st [EOL] from hypothesis . errors import InvalidArgument [EOL] from hypothesis . internal . conjecture import utils as cu [EOL] [EOL] from . _canonicalise import ( FALSEY , TRUTHY , TYPE_STRINGS , HypothesisRefResolutionError , Schema , canonicalish , get_integer_bounds , get_number_bounds , get_type , make_validator , merged , resolve_all_refs , ) [EOL] from . _encode import JSONType , encode_canonical_json [EOL] [EOL] JSON_STRATEGY = st . recursive ( st . none ( ) | st . booleans ( ) | st . integers ( ) | st . floats ( allow_nan = False , allow_infinity = False ) . map ( lambda x : x or [number] ) | st . text ( ) , lambda strategy : st . lists ( strategy , max_size = [number] ) | st . dictionaries ( st . text ( ) , strategy , max_size = [number] ) , ) [EOL] _FORMATS_TOKEN = object ( ) [EOL] [EOL] [EOL] def merged_as_strategies ( schemas , custom_formats ) : [EOL] assert schemas , [string] [EOL] if len ( schemas ) == [number] : [EOL] return from_schema ( schemas [ [number] ] , custom_formats = custom_formats ) [EOL] [comment] [EOL] strats = [ ] [EOL] combined = set ( ) [EOL] inputs = { encode_canonical_json ( s ) : s for s in schemas } [EOL] for group in itertools . chain . from_iterable ( itertools . combinations ( inputs , n ) for n in range ( len ( inputs ) , [number] , - [number] ) ) : [EOL] if combined . issuperset ( group ) : [EOL] continue [EOL] s = merged ( [ inputs [ g ] for g in group ] ) [EOL] if s is not None and s != FALSEY : [EOL] validators = [ make_validator ( s ) for s in schemas ] [EOL] strats . append ( from_schema ( s , custom_formats = custom_formats ) . filter ( lambda obj : all ( v . is_valid ( obj ) for v in validators ) ) ) [EOL] combined . update ( group ) [EOL] return st . one_of ( strats ) [EOL] [EOL] [EOL] def from_schema ( schema , * , custom_formats = None , ) : [EOL] [docstring] [EOL] try : [EOL] return __from_schema ( schema , custom_formats = custom_formats ) [EOL] except Exception as err : [EOL] error = err [EOL] [EOL] def error_raiser ( ) : [EOL] raise error [EOL] [EOL] return st . builds ( error_raiser ) [EOL] [EOL] [EOL] def _get_format_filter ( format_name , checker , strategy , ) : [EOL] def check_valid ( string ) : [EOL] try : [EOL] assert isinstance ( string , str ) [EOL] checker . check ( string , format = format_name ) [EOL] except ( AssertionError , jsonschema . FormatError ) as err : [EOL] raise InvalidArgument ( f" [string] { string !r} [string] { strategy !r} [string] " f" [string] { format_name !r} [string] " ) from err [EOL] return string [EOL] [EOL] return strategy . map ( check_valid ) [EOL] [EOL] [EOL] def __from_schema ( schema , * , custom_formats = None , ) : [EOL] try : [EOL] schema = resolve_all_refs ( schema ) [EOL] except RecursionError : [EOL] raise HypothesisRefResolutionError ( f" [string] { schema !r}" ) from None [EOL] [comment] [EOL] if custom_formats is not None and _FORMATS_TOKEN not in custom_formats : [EOL] assert isinstance ( custom_formats , dict ) [EOL] for name , strat in custom_formats . items ( ) : [EOL] if not isinstance ( name , str ) : [EOL] raise InvalidArgument ( f" [string] { name !r} [string] " ) [EOL] if name in STRING_FORMATS : [EOL] raise InvalidArgument ( f" [string] { name !r}" ) [EOL] if not isinstance ( strat , st . SearchStrategy ) : [EOL] raise InvalidArgument ( f" [string] { name !r} [string] { strat !r} [string] " [string] ) [EOL] format_checker = jsonschema . FormatChecker ( ) [EOL] custom_formats = { name : _get_format_filter ( name , format_checker , strategy ) [EOL] if name in format_checker . checkers [EOL] else strategy for name , strategy in custom_formats . items ( ) } [EOL] custom_formats [ _FORMATS_TOKEN ] = None [comment] [EOL] [EOL] schema = canonicalish ( schema ) [EOL] [comment] [EOL] if schema == FALSEY : [EOL] return st . nothing ( ) [EOL] if schema == TRUTHY : [EOL] return JSON_STRATEGY [EOL] [comment] [EOL] if [string] in schema : [EOL] jsonschema . validators . validator_for ( schema ) . check_schema ( schema ) [EOL] if schema [ [string] ] == [string] : [EOL] raise InvalidArgument ( [string] ) [EOL] [EOL] assert isinstance ( schema , dict ) [EOL] [comment] [EOL] [comment] [EOL] if [string] in schema : [EOL] not_ = schema . pop ( [string] ) [EOL] assert isinstance ( not_ , dict ) [EOL] validator = make_validator ( not_ ) . is_valid [EOL] return from_schema ( schema , custom_formats = custom_formats ) . filter ( lambda v : not validator ( v ) ) [EOL] if [string] in schema : [EOL] tmp = schema . copy ( ) [EOL] ao = tmp . pop ( [string] ) [EOL] assert isinstance ( ao , list ) [EOL] return st . one_of ( [ merged_as_strategies ( [ tmp , s ] , custom_formats ) for s in ao ] ) [EOL] if [string] in schema : [EOL] tmp = schema . copy ( ) [EOL] ao = tmp . pop ( [string] ) [EOL] assert isinstance ( ao , list ) [EOL] return merged_as_strategies ( [ tmp ] + ao , custom_formats ) [EOL] if [string] in schema : [EOL] tmp = schema . copy ( ) [EOL] oo = tmp . pop ( [string] ) [EOL] assert isinstance ( oo , list ) [EOL] schemas = [ merged ( [ tmp , s ] ) for s in oo ] [EOL] return st . one_of ( [ from_schema ( s , custom_formats = custom_formats ) for s in schemas if s is not None ] ) . filter ( make_validator ( schema ) . is_valid ) [EOL] [comment] [EOL] if [string] in schema : [EOL] assert schema [ [string] ] , [string] [EOL] return st . sampled_from ( schema [ [string] ] ) [EOL] if [string] in schema : [EOL] return st . just ( schema [ [string] ] ) [EOL] [comment] [EOL] map_ = { [string] : lambda _ : st . none ( ) , [string] : lambda _ : st . booleans ( ) , [string] : number_schema , [string] : integer_schema , [string] : partial ( string_schema , custom_formats ) , [string] : partial ( array_schema , custom_formats ) , [string] : partial ( object_schema , custom_formats ) , } [EOL] assert set ( map_ ) == set ( TYPE_STRINGS ) [EOL] return st . one_of ( [ map_ [ t ] ( schema ) for t in get_type ( schema ) ] ) [EOL] [EOL] [EOL] def _numeric_with_multiplier ( min_value , max_value , schema ) : [EOL] [docstring] [EOL] multiple_of = schema [ [string] ] [EOL] assert isinstance ( multiple_of , ( int , float ) ) [EOL] if min_value is not None : [EOL] min_value = math . ceil ( Fraction ( min_value ) / Fraction ( multiple_of ) ) [EOL] if max_value is not None : [EOL] max_value = math . floor ( Fraction ( max_value ) / Fraction ( multiple_of ) ) [EOL] if min_value is not None and max_value is not None and min_value > max_value : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return st . nothing ( ) [EOL] return ( st . integers ( min_value , max_value ) . map ( lambda x : x * multiple_of ) . filter ( make_validator ( schema ) . is_valid ) ) [EOL] [EOL] [EOL] def integer_schema ( schema ) : [EOL] [docstring] [EOL] min_value , max_value = get_integer_bounds ( schema ) [EOL] if [string] in schema : [EOL] return _numeric_with_multiplier ( min_value , max_value , schema ) [EOL] return st . integers ( min_value , max_value ) [EOL] [EOL] [EOL] def number_schema ( schema ) : [EOL] [docstring] [EOL] min_value , max_value , exclude_min , exclude_max = get_number_bounds ( schema ) [EOL] if [string] in schema : [EOL] return _numeric_with_multiplier ( min_value , max_value , schema ) [EOL] return st . floats ( min_value = min_value , max_value = max_value , allow_nan = False , allow_infinity = False , exclude_min = exclude_min , exclude_max = exclude_max , ) . filter ( lambda n : n != [number] or math . copysign ( [number] , n ) == [number] ) [EOL] [EOL] [EOL] def rfc3339 ( name ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] assert name in RFC3339_FORMATS [EOL] [EOL] def zfill ( width ) : [EOL] return lambda v : str ( v ) . zfill ( width ) [EOL] [EOL] simple = { [string] : st . integers ( [number] , [number] ) . map ( zfill ( [number] ) ) , [string] : st . integers ( [number] , [number] ) . map ( zfill ( [number] ) ) , [string] : st . integers ( [number] , [number] ) . map ( zfill ( [number] ) ) , [string] : st . integers ( [number] , [number] ) . map ( zfill ( [number] ) ) , [string] : st . integers ( [number] , [number] ) . map ( zfill ( [number] ) ) , [string] : st . integers ( [number] , [number] ) . map ( zfill ( [number] ) ) , [string] : st . from_regex ( [string] ) , } [EOL] if name in simple : [EOL] return simple [ name ] [EOL] if name == [string] : [EOL] return st . tuples ( st . sampled_from ( [ [string] , [string] ] ) , rfc3339 ( [string] ) , rfc3339 ( [string] ) ) . map ( [string] . __mod__ ) [EOL] if name == [string] : [EOL] return st . one_of ( st . just ( [string] ) , rfc3339 ( [string] ) ) [EOL] if name == [string] : [EOL] return st . times ( ) . map ( str ) [EOL] if name == [string] or name == [string] : [EOL] return st . dates ( ) . map ( str ) [EOL] if name == [string] or name == [string] : [EOL] return st . tuples ( rfc3339 ( [string] ) , rfc3339 ( [string] ) ) . map ( [string] . join ) [EOL] assert name == [string] [EOL] return st . tuples ( rfc3339 ( [string] ) , rfc3339 ( [string] ) ) . map ( [string] . join ) [EOL] [EOL] [EOL] @ st . composite def regex_patterns ( draw ) : [EOL] [docstring] [EOL] fragments = st . one_of ( st . just ( [string] ) , st . from_regex ( [string] ) , REGEX_PATTERNS . map ( [string] . format ) , REGEX_PATTERNS . map ( [string] . format ) , REGEX_PATTERNS . map ( [string] . format ) , ) [EOL] result = draw ( st . lists ( fragments , min_size = [number] , max_size = [number] ) . map ( [string] . join ) ) [EOL] assert isinstance ( result , str ) [EOL] try : [EOL] re . compile ( result ) [EOL] except ( re . error , FutureWarning ) : [EOL] assume ( False ) [EOL] return result [EOL] [EOL] [EOL] REGEX_PATTERNS = regex_patterns ( ) [EOL] [EOL] [EOL] def json_pointers ( ) : [EOL] [docstring] [EOL] return st . lists ( st . text ( st . characters ( ) ) . map ( lambda p : [string] + p . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) ) . map ( [string] . join ) [EOL] [EOL] [EOL] def relative_json_pointers ( ) : [EOL] [docstring] [EOL] return st . builds ( operator . add , st . from_regex ( [string] , fullmatch = True ) , st . just ( [string] ) | json_pointers ( ) , ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] _WEBCOLOR_REGEX = [string] [EOL] _CSS21_COLOR_NAMES = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] RFC3339_FORMATS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] STRING_FORMATS = { ** { name : rfc3339 ( name ) for name in RFC3339_FORMATS } , [string] : st . from_regex ( _WEBCOLOR_REGEX ) | st . sampled_from ( _CSS21_COLOR_NAMES ) , [string] : st . emails ( ) , [string] : st . emails ( ) , [string] : prov . domains ( ) , [string] : prov . domains ( ) , [string] : st . ip_addresses ( v = [number] ) . map ( str ) , [string] : st . ip_addresses ( v = [number] ) . map ( str ) , ** { name : prov . domains ( ) . map ( [string] . format ) for name in [ [string] , [string] , [string] , [string] , [string] ] } , [string] : json_pointers ( ) , [string] : relative_json_pointers ( ) , [string] : REGEX_PATTERNS , } [EOL] [EOL] [EOL] def string_schema ( custom_formats , schema ) : [EOL] [docstring] [EOL] [comment] [EOL] min_size = schema . get ( [string] , [number] ) [EOL] max_size = schema . get ( [string] ) [EOL] strategy = st . text ( min_size = min_size , max_size = max_size ) [EOL] known_formats = { ** ( custom_formats or { } ) , ** STRING_FORMATS } [EOL] if schema . get ( [string] ) in known_formats : [EOL] [comment] [EOL] [comment] [EOL] strategy = known_formats [ schema [ [string] ] ] [EOL] if [string] in schema : [EOL] [comment] [EOL] strategy = strategy . filter ( re . compile ( schema [ [string] ] ) . search ) [EOL] elif [string] in schema : [EOL] try : [EOL] re . compile ( schema [ [string] ] ) [EOL] strategy = st . from_regex ( schema [ [string] ] ) [EOL] except re . error : [EOL] [comment] [EOL] return st . nothing ( ) [EOL] [comment] [EOL] [comment] [EOL] if ( [string] in schema or [string] in schema ) and ( min_size != [number] or max_size is not None ) : [EOL] max_size = math . inf if max_size is None else max_size [EOL] strategy = strategy . filter ( lambda s : min_size <= len ( s ) <= max_size ) [EOL] return strategy [EOL] [EOL] [EOL] def array_schema ( custom_formats , schema ) : [EOL] [docstring] [EOL] _from_schema_ = partial ( from_schema , custom_formats = custom_formats ) [EOL] items = schema . get ( [string] , { } ) [EOL] additional_items = schema . get ( [string] , { } ) [EOL] min_size = schema . get ( [string] , [number] ) [EOL] max_size = schema . get ( [string] ) [EOL] unique = schema . get ( [string] ) [EOL] if isinstance ( items , list ) : [EOL] min_size = max ( [number] , min_size - len ( items ) ) [EOL] if max_size is not None : [EOL] max_size -= len ( items ) [EOL] [EOL] items_strats = [ _from_schema_ ( s ) for s in items ] [EOL] additional_items_strat = _from_schema_ ( additional_items ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if [string] in schema : [EOL] for i , mrgd in enumerate ( merged ( [ schema [ [string] ] , s ] ) for s in items ) : [EOL] if mrgd is not None : [EOL] items_strats [ i ] |= _from_schema_ ( mrgd ) [EOL] contains_additional = merged ( [ schema [ [string] ] , additional_items ] ) [EOL] if contains_additional is not None : [EOL] additional_items_strat |= _from_schema_ ( contains_additional ) [EOL] [EOL] if unique : [EOL] [EOL] @ st . composite def compose_lists_with_filter ( draw ) : [EOL] elems = [ ] [EOL] seen = set ( ) [EOL] [EOL] def not_seen ( elem ) : [EOL] return encode_canonical_json ( elem ) not in seen [EOL] [EOL] for strat in items_strats : [EOL] elems . append ( draw ( strat . filter ( not_seen ) ) ) [EOL] seen . add ( encode_canonical_json ( elems [ - [number] ] ) ) [EOL] extra_items = st . lists ( additional_items_strat . filter ( not_seen ) , min_size = min_size , max_size = max_size , unique_by = encode_canonical_json , ) [EOL] more_elems = draw ( extra_items ) [EOL] return elems + more_elems [EOL] [EOL] strat = compose_lists_with_filter ( ) [EOL] else : [EOL] strat = st . builds ( operator . add , st . tuples ( * items_strats ) . map ( list ) , st . lists ( additional_items_strat , min_size = min_size , max_size = max_size ) , ) [EOL] else : [EOL] items_strat = _from_schema_ ( items ) [EOL] if [string] in schema : [EOL] contains_strat = _from_schema_ ( schema [ [string] ] ) [EOL] if merged ( [ items , schema [ [string] ] ] ) != schema [ [string] ] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] contains_strat = contains_strat . filter ( make_validator ( items ) . is_valid ) [EOL] items_strat |= contains_strat [EOL] [EOL] strat = st . lists ( items_strat , min_size = min_size , max_size = max_size , unique_by = encode_canonical_json if unique else None , ) [EOL] if [string] not in schema : [EOL] return strat [EOL] contains = make_validator ( schema [ [string] ] ) . is_valid [EOL] return strat . filter ( lambda val : any ( contains ( x ) for x in val ) ) [EOL] [EOL] [EOL] def object_schema ( custom_formats , schema ) : [EOL] [docstring] [EOL] required = schema . get ( [string] , [ ] ) [comment] [EOL] min_size = max ( len ( required ) , schema . get ( [string] , [number] ) ) [EOL] max_size = schema . get ( [string] , math . inf ) [EOL] assert min_size <= max_size , ( min_size , max_size ) [EOL] [EOL] names = schema . get ( [string] , { } ) [comment] [EOL] if names == FALSEY : [EOL] assert min_size == [number] , schema [EOL] return st . builds ( dict ) [EOL] names [ [string] ] = [string] [EOL] [EOL] properties = schema . get ( [string] , { } ) [comment] [EOL] patterns = schema . get ( [string] , { } ) [comment] [EOL] [comment] [EOL] additional = schema . get ( [string] , { } ) [EOL] additional_allowed = additional != FALSEY [EOL] [EOL] dependencies = schema . get ( [string] , { } ) [EOL] dep_names = { k : v for k , v in dependencies . items ( ) if isinstance ( v , list ) } [EOL] dep_schemas = { k : v for k , v in dependencies . items ( ) if k not in dep_names } [EOL] del dependencies [EOL] [EOL] name_strats = ( st . sampled_from ( sorted ( dep_names ) + sorted ( dep_schemas ) + sorted ( properties ) ) [EOL] if ( dep_names or dep_schemas or properties ) [EOL] else st . nothing ( ) , from_schema ( names , custom_formats = custom_formats ) [EOL] if additional_allowed [EOL] else st . nothing ( ) , st . one_of ( [ st . from_regex ( p ) for p in sorted ( patterns ) ] ) , ) [EOL] all_names_strategy = st . one_of ( [ s for s in name_strats if not s . is_empty ] ) . filter ( make_validator ( names ) . is_valid ) [EOL] [EOL] @ st . composite def from_object_schema ( draw ) : [EOL] [docstring] [EOL] [comment] [EOL] elements = cu . many ( draw ( st . data ( ) ) . conjecture_data , min_size = min_size , max_size = max_size , average_size = min ( min_size + [number] , ( min_size + max_size ) / [number] ) , ) [EOL] out = { } [EOL] while elements . more ( ) : [EOL] for key in required : [EOL] if key not in out : [EOL] break [EOL] else : [EOL] for k in set ( dep_names ) . intersection ( out ) : [comment] [EOL] [comment] [EOL] [comment] [EOL] key = next ( ( n for n in dep_names [ k ] if n not in out ) , None ) [EOL] if key is not None : [EOL] break [EOL] else : [EOL] key = draw ( all_names_strategy . filter ( lambda s : s not in out ) ) [EOL] [EOL] pattern_schemas = [ patterns [ rgx ] for rgx in sorted ( patterns ) if re . search ( rgx , string = key ) is not None ] [EOL] if key in properties : [EOL] pattern_schemas . insert ( [number] , properties [ key ] ) [EOL] [EOL] if pattern_schemas : [EOL] out [ key ] = draw ( merged_as_strategies ( pattern_schemas , custom_formats ) ) [EOL] else : [EOL] out [ key ] = draw ( from_schema ( additional , custom_formats = custom_formats ) ) [EOL] [EOL] for k , v in dep_schemas . items ( ) : [EOL] if k in out and not make_validator ( v ) . is_valid ( out ) : [EOL] out . pop ( key ) [EOL] elements . reject ( ) [EOL] [EOL] for k in set ( dep_names ) . intersection ( out ) : [EOL] assume ( set ( out ) . issuperset ( dep_names [ k ] ) ) [EOL] return out [EOL] [EOL] return from_object_schema ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hypothesis.strategies.SearchStrategy[typing.Dict[builtins.str,_encode.JSONType]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Callable , Type , List , Union , Tuple [EOL] import typing [EOL] import builtins [EOL] import functools [EOL] [docstring] [EOL] import functools [EOL] import json [EOL] import math [EOL] from json . encoder import _make_iterencode , encode_basestring_ascii [comment] [EOL] from typing import Any , Callable , Dict , Tuple , Type , Union [EOL] [EOL] [comment] [EOL] [comment] [EOL] JSONType = Union [ None , bool , float , str , list , Dict [ str , Any ] ] [EOL] [EOL] [EOL] class CanonicalisingJsonEncoder ( json . JSONEncoder ) : [EOL] def iterencode ( self , o , _one_shot = False ) : [EOL] [docstring] [EOL] [EOL] def floatstr ( o ) : [EOL] [comment] [EOL] [comment] [EOL] assert math . isfinite ( o ) [EOL] if o == int ( o ) : [EOL] return repr ( int ( o ) ) [EOL] return repr ( o ) [EOL] [EOL] return _make_iterencode ( { } , self . default , encode_basestring_ascii , self . indent , floatstr , self . key_separator , self . item_separator , self . sort_keys , self . skipkeys , _one_shot , ) ( o , [number] ) [EOL] [EOL] [EOL] def _make_cache_key ( value , ) : [EOL] [docstring] [EOL] if isinstance ( value , dict ) : [EOL] return ( dict , frozenset ( ( k , _make_cache_key ( v ) ) for k , v in value . items ( ) ) ) [EOL] if isinstance ( value , list ) : [EOL] return ( list , tuple ( map ( _make_cache_key , value ) ) ) [EOL] [comment] [EOL] [comment] [EOL] return ( type ( value ) , value ) [EOL] [EOL] [EOL] class HashedJSON : [EOL] [docstring] [EOL] [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , value ) : [EOL] self . value = value [EOL] [comment] [EOL] self . hashedvalue = hash ( _make_cache_key ( value ) ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . hashedvalue [EOL] [EOL] def __eq__ ( self , other ) : [comment] [EOL] [comment] [EOL] [comment] [EOL] return self . hashedvalue == other . hashedvalue [EOL] [EOL] [EOL] def cached_json ( func ) : [EOL] [docstring] [EOL] cached_func = functools . lru_cache ( maxsize = [number] ) ( func ) [EOL] [EOL] @ functools . wraps ( cached_func ) def wrapped ( value ) : [EOL] return cached_func ( HashedJSON ( value ) ) [EOL] [EOL] return wrapped [EOL] [EOL] [EOL] @ cached_json def encode_canonical_json ( value ) : [EOL] [docstring] [EOL] return json . dumps ( value . value , sort_keys = True , cls = CanonicalisingJsonEncoder ) [EOL] [EOL] [EOL] def sort_key ( value ) : [EOL] [docstring] [EOL] if value is None : [EOL] return ( [number] , [number] , [number] ) [EOL] if isinstance ( value , bool ) : [EOL] return ( [number] , int ( value ) , [number] ) [EOL] if isinstance ( value , ( int , float ) ) : [EOL] return ( [number] if int ( value ) == value else [number] , abs ( value ) , value >= [number] ) [EOL] type_key = { str : [number] , list : [number] , dict : [number] } [ type ( value ) ] [EOL] return ( type_key , len ( value ) , encode_canonical_json ( value ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Tuple[typing.Type,typing.Union[None,builtins.bool,builtins.float,builtins.str,builtins.tuple,builtins.frozenset]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.Dict[builtins.str,typing.Any],typing.List[typing.Any],builtins.bool,builtins.float,builtins.str]$ 0 0 0 0 0 $typing.Union[None,typing.Dict[builtins.str,typing.Any],typing.List[typing.Any],builtins.bool,builtins.float,builtins.str]$ 0 $typing.Union[None,typing.Dict[builtins.str,typing.Any],typing.List[typing.Any],builtins.bool,builtins.float,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.Dict[builtins.str,typing.Any],typing.List[typing.Any],builtins.bool,builtins.float,builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $"HashedJSON"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $"HashedJSON"$ 0 0 0 0 0 0 $typing.Callable[[JSONType],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.float,typing.Union[builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict , Any , NoReturn , Type , List , Union , Tuple , Optional [EOL] import typing [EOL] import src [EOL] import builtins [EOL] import _encode [EOL] [docstring] [EOL] import itertools [EOL] import json [EOL] import math [EOL] import re [EOL] from copy import deepcopy [EOL] from typing import Any , Dict , List , NoReturn , Optional , Tuple , Union [EOL] [EOL] import jsonschema [EOL] from hypothesis . errors import InvalidArgument [EOL] from hypothesis . internal . floats import next_down as ieee_next_down , next_up [EOL] [EOL] from . _encode import JSONType , encode_canonical_json , sort_key [EOL] [EOL] Schema = Dict [ str , JSONType ] [EOL] JSONSchemaValidator = Union [ jsonschema . validators . Draft4Validator , jsonschema . validators . Draft6Validator , jsonschema . validators . Draft7Validator , ] [EOL] [EOL] [comment] [EOL] TYPE_STRINGS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] TYPE_SPECIFIC_KEYS = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] [string] , ) , ) [EOL] [comment] [EOL] SCHEMA_KEYS = tuple ( [string] [string] . split ( ) ) [EOL] [comment] [EOL] [comment] [EOL] SCHEMA_OBJECT_KEYS = ( [string] , [string] , [string] ) [EOL] ALL_KEYWORDS = tuple ( [ * SCHEMA_KEYS , * SCHEMA_OBJECT_KEYS ] + sum ( ( s . split ( ) for _ , s in TYPE_SPECIFIC_KEYS ) , [ ] ) ) [EOL] [EOL] [EOL] def next_down ( val ) : [EOL] [docstring] [EOL] out = ieee_next_down ( val ) [EOL] if out == [number] and math . copysign ( [number] , out ) == - [number] : [EOL] out = ieee_next_down ( out ) [EOL] assert isinstance ( out , float ) [EOL] return out [EOL] [EOL] [EOL] def _get_validator_class ( schema ) : [EOL] try : [EOL] validator = jsonschema . validators . validator_for ( schema ) [EOL] validator . check_schema ( schema ) [EOL] except jsonschema . exceptions . SchemaError : [EOL] validator = jsonschema . Draft4Validator [EOL] validator . check_schema ( schema ) [EOL] return validator [EOL] [EOL] [EOL] def make_validator ( schema ) : [EOL] validator = _get_validator_class ( schema ) [EOL] return validator ( schema ) [EOL] [EOL] [EOL] class HypothesisRefResolutionError ( jsonschema . exceptions . RefResolutionError ) : [EOL] pass [EOL] [EOL] [EOL] def get_type ( schema ) : [EOL] [docstring] [EOL] type_ = schema . get ( [string] , list ( TYPE_STRINGS ) ) [EOL] [comment] [EOL] if isinstance ( type_ , str ) : [EOL] assert type_ in TYPE_STRINGS [EOL] return [ type_ ] [EOL] assert isinstance ( type_ , list ) and set ( type_ ) . issubset ( TYPE_STRINGS ) , type_ [EOL] type_ = [ t for t in TYPE_STRINGS if t in type_ ] [EOL] if [string] in type_ and [string] in type_ : [EOL] type_ . remove ( [string] ) [comment] [EOL] return type_ [EOL] [EOL] [EOL] def upper_bound_instances ( schema ) : [EOL] [docstring] [EOL] if schema == FALSEY : [EOL] return [number] [EOL] if [string] in schema : [EOL] return [number] [EOL] if [string] in schema : [EOL] assert isinstance ( schema [ [string] ] , list ) [EOL] return len ( schema [ [string] ] ) [EOL] if get_type ( schema ) == [ [string] ] : [EOL] lower , upper = get_integer_bounds ( schema ) [EOL] if lower is not None and upper is not None : [EOL] mul = schema . get ( [string] ) [EOL] if isinstance ( mul , int ) : [EOL] return [number] + ( upper - lower ) % mul [EOL] return [number] + ( upper - lower ) [comment] [EOL] if ( get_type ( schema ) == [ [string] ] [EOL] and isinstance ( schema . get ( [string] ) , dict ) [EOL] and schema . get ( [string] , math . inf ) < [number] ) : [EOL] [comment] [EOL] [comment] [EOL] items_bound = upper_bound_instances ( schema [ [string] ] ) [comment] [EOL] if items_bound < [number] : [EOL] lo , hi = schema . get ( [string] , [number] ) , schema [ [string] ] [EOL] assert isinstance ( lo , int ) and isinstance ( hi , int ) [EOL] return sum ( items_bound ** n for n in range ( lo , hi + [number] ) ) [EOL] return math . inf [EOL] [EOL] [EOL] def _get_numeric_bounds ( schema , ) : [EOL] [docstring] [EOL] lower = schema . get ( [string] ) [EOL] upper = schema . get ( [string] ) [EOL] exmin = schema . get ( [string] , False ) [EOL] exmax = schema . get ( [string] , False ) [EOL] assert lower is None or isinstance ( lower , ( int , float ) ) [EOL] assert upper is None or isinstance ( upper , ( int , float ) ) [EOL] assert isinstance ( exmin , ( bool , int , float ) ) [EOL] assert isinstance ( exmax , ( bool , int , float ) ) [EOL] [EOL] [comment] [EOL] if exmin is not True and exmin is not False : [EOL] if lower is None or exmin >= lower : [EOL] lower , exmin = exmin , True [EOL] else : [EOL] exmin = False [EOL] if exmax is not True and exmax is not False : [EOL] if upper is None or exmax <= upper : [EOL] upper , exmax = exmax , True [EOL] else : [EOL] exmax = False [EOL] assert isinstance ( exmin , bool ) [EOL] assert isinstance ( exmax , bool ) [EOL] return lower , upper , exmin , exmax [EOL] [EOL] [EOL] def get_number_bounds ( schema , ) : [EOL] [docstring] [EOL] lower , upper , exmin , exmax = _get_numeric_bounds ( schema ) [EOL] if lower is not None : [EOL] lo = float ( lower ) [EOL] if lo < lower : [EOL] lo = next_up ( lo ) [EOL] exmin = False [EOL] lower = lo [EOL] if upper is not None : [EOL] hi = float ( upper ) [EOL] if hi > upper : [EOL] hi = next_down ( hi ) [EOL] exmax = False [EOL] upper = hi [EOL] return lower , upper , exmin , exmax [EOL] [EOL] [EOL] def get_integer_bounds ( schema ) : [EOL] [docstring] [EOL] lower , upper , exmin , exmax = _get_numeric_bounds ( schema ) [EOL] [comment] [EOL] if lower is not None : [EOL] lo = math . ceil ( lower ) [EOL] if exmin and lo == lower : [EOL] lo += [number] [EOL] lower = lo [EOL] if upper is not None : [EOL] hi = math . floor ( upper ) [EOL] if exmax and hi == upper : [EOL] hi -= [number] [EOL] upper = hi [EOL] return lower , upper [EOL] [EOL] [EOL] def canonicalish ( schema ) : [EOL] [docstring] [EOL] if schema is True : [EOL] return { } [EOL] elif schema is False : [EOL] return { [string] : { } } [EOL] [EOL] [comment] [EOL] [comment] [EOL] schema = json . loads ( encode_canonical_json ( schema ) ) [EOL] [EOL] [comment] [EOL] if not isinstance ( schema , dict ) : [EOL] raise InvalidArgument ( f" [string] { schema !r} [string] { type ( schema ) . __name__ } [string] " [string] ) [EOL] [EOL] if [string] in schema : [EOL] if not make_validator ( schema ) . is_valid ( schema [ [string] ] ) : [EOL] return FALSEY [EOL] return { [string] : schema [ [string] ] } [EOL] if [string] in schema : [EOL] validator = make_validator ( schema ) [EOL] enum_ = sorted ( ( v for v in schema [ [string] ] if validator . is_valid ( v ) ) , key = sort_key ) [EOL] if not enum_ : [EOL] return FALSEY [EOL] elif len ( enum_ ) == [number] : [EOL] return { [string] : enum_ [ [number] ] } [EOL] return { [string] : enum_ } [EOL] [comment] [EOL] if_ = schema . pop ( [string] , None ) [EOL] then = schema . pop ( [string] , schema ) [EOL] else_ = schema . pop ( [string] , schema ) [EOL] if if_ is not None and ( then is not schema or else_ is not schema ) : [EOL] schema = { [string] : [ { [string] : [ if_ , then , schema ] } , { [string] : [ { [string] : if_ } , else_ , schema ] } , ] } [EOL] assert isinstance ( schema , dict ) [EOL] [comment] [EOL] for key in SCHEMA_KEYS : [EOL] if isinstance ( schema . get ( key ) , list ) : [EOL] schema [ key ] = [ canonicalish ( v ) for v in schema [ key ] ] [EOL] elif isinstance ( schema . get ( key ) , ( bool , dict ) ) : [EOL] schema [ key ] = canonicalish ( schema [ key ] ) [EOL] else : [EOL] assert key not in schema , ( key , schema [ key ] ) [EOL] for key in SCHEMA_OBJECT_KEYS : [EOL] if key in schema : [EOL] schema [ key ] = { k : v if isinstance ( v , list ) else canonicalish ( v ) for k , v in schema [ key ] . items ( ) } [EOL] [EOL] type_ = get_type ( schema ) [EOL] if [string] in type_ : [EOL] if schema . get ( [string] ) is False : [EOL] del schema [ [string] ] [EOL] if schema . get ( [string] ) is False : [EOL] del schema [ [string] ] [EOL] lo , hi , exmin , exmax = get_number_bounds ( schema ) [EOL] mul = schema . get ( [string] ) [EOL] if isinstance ( mul , int ) : [EOL] [comment] [EOL] type_ . remove ( [string] ) [EOL] type_ = [ t for t in TYPE_STRINGS if t in type_ or t == [string] ] [EOL] elif lo is not None and hi is not None : [EOL] lobound = next_up ( lo ) if exmin else lo [EOL] hibound = next_down ( hi ) if exmax else hi [EOL] if ( mul and not has_divisibles ( lo , hi , mul , exmin , exmax ) ) or lobound > hibound : [EOL] type_ . remove ( [string] ) [EOL] elif type_ == [ [string] ] and lobound == hibound : [EOL] return { [string] : lobound } [EOL] [EOL] if [string] in type_ : [EOL] lo , hi = get_integer_bounds ( schema ) [EOL] mul = schema . get ( [string] ) [EOL] if lo is not None and isinstance ( mul , int ) and mul > [number] and ( lo % mul ) : [EOL] lo += mul - ( lo % mul ) [EOL] if hi is not None and isinstance ( mul , int ) and mul > [number] and ( hi % mul ) : [EOL] hi -= hi % mul [EOL] [EOL] if lo is not None : [EOL] schema [ [string] ] = lo [EOL] schema . pop ( [string] , None ) [EOL] if hi is not None : [EOL] schema [ [string] ] = hi [EOL] schema . pop ( [string] , None ) [EOL] [EOL] if lo is not None and hi is not None and lo > hi : [EOL] type_ . remove ( [string] ) [EOL] [EOL] if [string] in type_ and [string] in schema : [EOL] if isinstance ( schema . get ( [string] ) , dict ) : [EOL] contains_items = merged ( [ schema [ [string] ] , schema [ [string] ] ] ) [EOL] if contains_items is not None : [EOL] schema [ [string] ] = contains_items [EOL] [EOL] if schema [ [string] ] == FALSEY : [EOL] type_ . remove ( [string] ) [EOL] else : [EOL] schema [ [string] ] = max ( schema . get ( [string] , [number] ) , [number] ) [EOL] if schema [ [string] ] == TRUTHY : [EOL] schema . pop ( [string] ) [EOL] schema [ [string] ] = max ( schema . get ( [string] , [number] ) , [number] ) [EOL] if ( [string] in type_ [EOL] and [string] in schema [EOL] and isinstance ( schema . get ( [string] , [ ] ) , dict ) ) : [EOL] item_count = upper_bound_instances ( schema [ [string] ] ) [EOL] if math . isfinite ( item_count ) : [EOL] schema [ [string] ] = min ( item_count , schema . get ( [string] , math . inf ) ) [EOL] if [string] in type_ and schema . get ( [string] , [number] ) > schema . get ( [string] , math . inf ) : [EOL] type_ . remove ( [string] ) [EOL] if ( [string] in type_ [EOL] and [string] in schema [EOL] and isinstance ( schema . get ( [string] , [ ] ) , dict ) ) : [EOL] count = upper_bound_instances ( schema [ [string] ] ) [EOL] if ( count == [number] and schema [ [string] ] > [number] ) or ( schema . get ( [string] , False ) and count < schema [ [string] ] ) : [EOL] type_ . remove ( [string] ) [EOL] if [string] in type_ and isinstance ( schema . get ( [string] ) , list ) : [EOL] schema [ [string] ] = schema [ [string] ] [ : schema . get ( [string] ) ] [EOL] for idx , s in enumerate ( schema [ [string] ] ) : [EOL] if s == FALSEY : [EOL] schema [ [string] ] = schema [ [string] ] [ : idx ] [EOL] schema [ [string] ] = idx [EOL] schema . pop ( [string] , None ) [EOL] break [EOL] if schema . get ( [string] , [number] ) > min ( len ( schema [ [string] ] ) + upper_bound_instances ( schema . get ( [string] , TRUTHY ) ) , schema . get ( [string] , math . inf ) , ) : [EOL] type_ . remove ( [string] ) [EOL] if ( [string] in type_ [EOL] and isinstance ( schema . get ( [string] ) , list ) [EOL] and schema . get ( [string] ) == FALSEY ) : [EOL] schema . pop ( [string] , None ) [EOL] if [string] in type_ and ( schema . get ( [string] ) == FALSEY or schema . get ( [string] , [number] ) == [number] ) : [EOL] schema [ [string] ] = [number] [EOL] schema . pop ( [string] , None ) [EOL] schema . pop ( [string] , None ) [EOL] schema . pop ( [string] , None ) [EOL] if [string] in type_ and schema . get ( [string] , TRUTHY ) == TRUTHY : [EOL] schema . pop ( [string] , None ) [EOL] if ( [string] in schema [EOL] and not schema . get ( [string] ) [EOL] and schema . get ( [string] ) == FALSEY ) : [EOL] max_props = schema . get ( [string] , math . inf ) [EOL] assert isinstance ( max_props , ( int , float ) ) [EOL] schema [ [string] ] = min ( max_props , len ( schema [ [string] ] ) ) [EOL] if [string] in type_ and schema . get ( [string] , [number] ) > schema . get ( [string] , math . inf ) : [EOL] type_ . remove ( [string] ) [EOL] [comment] [EOL] for k , v in schema . get ( [string] , { } ) . copy ( ) . items ( ) : [EOL] if v == [ ] or v == TRUTHY : [EOL] schema [ [string] ] . pop ( k ) [EOL] [comment] [EOL] for kw , identity in { [string] : [number] , [string] : { } , [string] : { } , [string] : { } , [string] : [number] , [string] : { } , [string] : { } , [string] : { } , [string] : { } , [string] : [ ] , } . items ( ) : [EOL] if kw in schema and schema [ kw ] == identity : [EOL] schema . pop ( kw ) [EOL] [comment] [EOL] if [string] in type_ and [string] in schema : [EOL] assert isinstance ( schema [ [string] ] , list ) [EOL] reqs = set ( schema [ [string] ] ) [EOL] if schema . get ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] dep_names = { k : sorted ( set ( v ) ) for k , v in schema [ [string] ] . items ( ) if isinstance ( v , list ) } [EOL] schema [ [string] ] . update ( dep_names ) [EOL] while reqs . intersection ( dep_names ) : [EOL] for r in reqs . intersection ( dep_names ) : [EOL] reqs . update ( dep_names . pop ( r ) ) [EOL] schema [ [string] ] . pop ( r ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not schema [ [string] ] : [EOL] schema . pop ( [string] ) [EOL] schema [ [string] ] = sorted ( reqs ) [EOL] max_ = schema . get ( [string] , float ( [string] ) ) [EOL] assert isinstance ( max_ , ( int , float ) ) [EOL] properties = schema . get ( [string] , { } ) [EOL] if len ( schema [ [string] ] ) > max_ : [EOL] type_ . remove ( [string] ) [EOL] elif any ( properties . get ( name , { } ) == FALSEY for name in schema [ [string] ] ) : [EOL] type_ . remove ( [string] ) [EOL] else : [EOL] propnames = schema . get ( [string] , { } ) [EOL] validator = make_validator ( propnames ) [EOL] if not all ( validator . is_valid ( name ) for name in schema [ [string] ] ) : [EOL] type_ . remove ( [string] ) [EOL] [EOL] for t , kw in TYPE_SPECIFIC_KEYS : [EOL] numeric = { [string] , [string] } [EOL] if t in type_ or ( t in numeric and numeric . intersection ( type_ ) ) : [EOL] continue [EOL] for k in kw . split ( ) : [EOL] schema . pop ( k , None ) [EOL] [EOL] [comment] [EOL] if [string] in schema : [EOL] not_ = schema . pop ( [string] ) [EOL] [EOL] negated = [ ] [EOL] to_negate = not_ [ [string] ] if set ( not_ ) == { [string] } else [ not_ ] [EOL] for not_ in to_negate : [EOL] type_keys = { k : set ( v . split ( ) ) for k , v in TYPE_SPECIFIC_KEYS } [EOL] type_constraints = { [string] } [EOL] for v in type_keys . values ( ) : [EOL] type_constraints |= v [EOL] if set ( not_ ) . issubset ( type_constraints ) : [EOL] not_ [ [string] ] = get_type ( not_ ) [EOL] for t in set ( type_ ) . intersection ( not_ [ [string] ] ) : [EOL] if not type_keys . get ( t , set ( ) ) . intersection ( not_ ) : [EOL] type_ . remove ( t ) [EOL] if t not in ( [string] , [string] ) : [EOL] not_ [ [string] ] . remove ( t ) [EOL] not_ = canonicalish ( not_ ) [EOL] [EOL] m = merged ( [ not_ , { ** schema , [string] : type_ } ] ) [EOL] if m is not None : [EOL] not_ = m [EOL] if not_ != FALSEY : [EOL] negated . append ( not_ ) [EOL] if len ( negated ) > [number] : [EOL] schema [ [string] ] = { [string] : negated } [EOL] elif negated : [EOL] schema [ [string] ] = negated [ [number] ] [EOL] [EOL] assert isinstance ( type_ , list ) , type_ [EOL] if not type_ : [EOL] assert type_ == [ ] [EOL] return FALSEY [EOL] if type_ == [ [string] ] : [EOL] return { [string] : None } [EOL] if type_ == [ [string] ] : [EOL] return { [string] : [ False , True ] } [EOL] if type_ == [ [string] , [string] ] : [EOL] return { [string] : [ None , False , True ] } [EOL] if len ( type_ ) == [number] : [EOL] schema [ [string] ] = type_ [ [number] ] [EOL] elif type_ == get_type ( { } ) : [EOL] schema . pop ( [string] , None ) [EOL] else : [EOL] schema [ [string] ] = type_ [EOL] [comment] [EOL] [comment] [EOL] if TRUTHY in schema . get ( [string] , ( ) ) : [EOL] schema . pop ( [string] , None ) [EOL] if [string] in schema : [EOL] i = [number] [EOL] while i < len ( schema [ [string] ] ) : [EOL] s = schema [ [string] ] [ i ] [EOL] if set ( s ) == { [string] } : [EOL] schema [ [string] ] [ i : i + [number] ] = s [ [string] ] [EOL] continue [EOL] i += [number] [EOL] schema [ [string] ] = [ json . loads ( s ) for s in sorted ( { encode_canonical_json ( a ) for a in schema [ [string] ] if a != FALSEY } ) ] [EOL] if not schema [ [string] ] : [EOL] return FALSEY [EOL] if len ( schema ) == len ( schema [ [string] ] ) == [number] : [EOL] return schema [ [string] ] [ [number] ] [comment] [EOL] if [string] in schema : [EOL] schema [ [string] ] = [ json . loads ( enc ) for enc in sorted ( set ( map ( encode_canonical_json , schema [ [string] ] ) ) ) ] [EOL] if any ( s == FALSEY for s in schema [ [string] ] ) : [EOL] return FALSEY [EOL] if all ( s == TRUTHY for s in schema [ [string] ] ) : [EOL] schema . pop ( [string] ) [EOL] elif len ( schema ) == len ( schema [ [string] ] ) == [number] : [EOL] return schema [ [string] ] [ [number] ] [comment] [EOL] else : [EOL] tmp = schema . copy ( ) [EOL] ao = tmp . pop ( [string] ) [EOL] out = merged ( [ tmp ] + ao ) [EOL] if isinstance ( out , dict ) : [comment] [EOL] schema = out [EOL] [comment] [EOL] [comment] [EOL] assert isinstance ( schema , dict ) [EOL] if [string] in schema : [EOL] one_of = schema . pop ( [string] ) [EOL] assert isinstance ( one_of , list ) [EOL] one_of = sorted ( one_of , key = encode_canonical_json ) [EOL] one_of = [ s for s in one_of if s != FALSEY ] [EOL] if len ( one_of ) == [number] : [EOL] m = merged ( [ schema , one_of [ [number] ] ] ) [EOL] if m is not None : [comment] [EOL] return m [EOL] if ( not one_of ) or one_of . count ( TRUTHY ) > [number] : [EOL] return FALSEY [EOL] schema [ [string] ] = one_of [EOL] if schema . get ( [string] ) is False : [EOL] del schema [ [string] ] [EOL] return schema [EOL] [EOL] [EOL] TRUTHY = canonicalish ( True ) [EOL] FALSEY = canonicalish ( False ) [EOL] [EOL] [EOL] class LocalResolver ( jsonschema . RefResolver ) : [EOL] def resolve_remote ( self , uri ) : [EOL] raise HypothesisRefResolutionError ( f" [string] { uri !r} [string] " ) [EOL] [EOL] [EOL] def resolve_all_refs ( schema , * , resolver = None ) : [EOL] [docstring] [EOL] if isinstance ( schema , bool ) : [EOL] return canonicalish ( schema ) [EOL] assert isinstance ( schema , dict ) , schema [EOL] if resolver is None : [EOL] resolver = LocalResolver . from_schema ( deepcopy ( schema ) ) [EOL] if not isinstance ( resolver , jsonschema . RefResolver ) : [EOL] raise InvalidArgument ( f" [string] { resolver } [string] { type ( resolver ) . __name__ } [string] " ) [EOL] [EOL] if [string] in schema : [EOL] s = dict ( schema ) [EOL] ref = s . pop ( [string] ) [EOL] with resolver . resolving ( ref ) as got : [EOL] if s == { } : [EOL] return resolve_all_refs ( got , resolver = resolver ) [EOL] m = merged ( [ s , got ] ) [EOL] if m is None : [comment] [EOL] msg = f" [string] { ref !r} [string] { s !r}" [EOL] raise HypothesisRefResolutionError ( msg ) [EOL] return resolve_all_refs ( m , resolver = resolver ) [EOL] assert [string] not in schema [EOL] [EOL] for key in SCHEMA_KEYS : [EOL] val = schema . get ( key , False ) [EOL] if isinstance ( val , list ) : [EOL] schema [ key ] = [ resolve_all_refs ( v , resolver = resolver ) if isinstance ( v , dict ) else v for v in val ] [EOL] elif isinstance ( val , dict ) : [EOL] schema [ key ] = resolve_all_refs ( val , resolver = resolver ) [EOL] else : [EOL] assert isinstance ( val , bool ) [EOL] for key in SCHEMA_OBJECT_KEYS : [comment] [EOL] if key in schema : [EOL] subschema = schema [ key ] [EOL] assert isinstance ( subschema , dict ) [EOL] schema [ key ] = { k : resolve_all_refs ( v , resolver = resolver ) if isinstance ( v , dict ) else v for k , v in subschema . items ( ) } [EOL] assert isinstance ( schema , dict ) [EOL] return schema [EOL] [EOL] [EOL] def merged ( schemas ) : [EOL] [docstring] [EOL] assert schemas , [string] [EOL] schemas = sorted ( ( canonicalish ( s ) for s in schemas ) , key = upper_bound_instances ) [EOL] if any ( s == FALSEY for s in schemas ) : [EOL] return FALSEY [EOL] out = schemas [ [number] ] [EOL] for s in schemas [ [number] : ] : [EOL] if s == TRUTHY : [EOL] continue [EOL] [comment] [EOL] if [string] in out : [EOL] if make_validator ( s ) . is_valid ( out [ [string] ] ) : [EOL] continue [EOL] return FALSEY [EOL] if [string] in out : [EOL] validator = make_validator ( s ) [EOL] enum_ = [ v for v in out [ [string] ] if validator . is_valid ( v ) ] [EOL] if not enum_ : [EOL] return FALSEY [EOL] elif len ( enum_ ) == [number] : [EOL] out = { [string] : enum_ [ [number] ] } [EOL] else : [EOL] out = { [string] : enum_ } [EOL] continue [EOL] [EOL] if [string] in out and [string] in s : [EOL] tt = s . pop ( [string] ) [EOL] ot = get_type ( out ) [EOL] if [string] in ot : [EOL] ot . append ( [string] ) [EOL] out [ [string] ] = [ t for t in ot if t in tt or t == [string] and [string] in tt ] [EOL] out_type = get_type ( out ) [EOL] if not out_type : [EOL] return FALSEY [EOL] for t , kw in TYPE_SPECIFIC_KEYS : [EOL] numeric = [ [string] , [string] ] [EOL] if t in out_type or t in numeric and t in out_type + numeric : [EOL] continue [EOL] for k in kw . split ( ) : [EOL] s . pop ( k , None ) [EOL] out . pop ( k , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] out_add = out . get ( [string] , { } ) [EOL] s_add = s . pop ( [string] , { } ) [EOL] out_pat = out . get ( [string] , { } ) [EOL] s_pat = s . pop ( [string] , { } ) [EOL] if [string] in out or [string] in s : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] out_props = out . setdefault ( [string] , { } ) [EOL] s_props = s . pop ( [string] , { } ) [EOL] for prop_name in set ( out_props ) | set ( s_props ) : [EOL] if prop_name in out_props : [EOL] out_combined = out_props [ prop_name ] [EOL] else : [EOL] out_combined = merged ( [ s for p , s in out_pat . items ( ) if re . search ( p , prop_name ) ] or [ out_add ] ) [EOL] if prop_name in s_props : [EOL] s_combined = s_props [ prop_name ] [EOL] else : [EOL] s_combined = merged ( [ s for p , s in s_pat . items ( ) if re . search ( p , prop_name ) ] or [ s_add ] ) [EOL] if out_combined is None or s_combined is None : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] m = merged ( [ out_combined , s_combined ] ) [EOL] if m is None : [EOL] return None [EOL] out_props [ prop_name ] = m [EOL] [comment] [EOL] [comment] [EOL] if out_pat or s_pat : [EOL] for pattern in set ( out_pat ) | set ( s_pat ) : [EOL] m = merged ( [ out_pat . get ( pattern , out_add ) , s_pat . get ( pattern , s_add ) ] ) [EOL] if m is None : [comment] [EOL] return None [EOL] out_pat [ pattern ] = m [EOL] out [ [string] ] = out_pat [EOL] [comment] [EOL] if out_add or s_add : [EOL] m = merged ( [ out_add , s_add ] ) [EOL] if m is None : [comment] [EOL] return None [EOL] out [ [string] ] = m [EOL] [EOL] if [string] in out and [string] in s : [EOL] [comment] [EOL] out [ [string] ] += s . pop ( [string] ) [EOL] if [string] in out and [string] in s : [EOL] out [ [string] ] = sorted ( set ( out [ [string] ] + s . pop ( [string] ) ) ) [EOL] for key in ( { [string] , [string] , [string] , [string] , [string] } & set ( s ) & set ( out ) ) : [EOL] out [ key ] = min ( [ out [ key ] , s . pop ( key ) ] ) [EOL] for key in ( { [string] , [string] , [string] , [string] , [string] } & set ( s ) & set ( out ) ) : [EOL] out [ key ] = max ( [ out [ key ] , s . pop ( key ) ] ) [EOL] if [string] in out and [string] in s : [EOL] x , y = s . pop ( [string] ) , out [ [string] ] [EOL] if isinstance ( x , int ) and isinstance ( y , int ) : [EOL] out [ [string] ] = x * y // math . gcd ( x , y ) [EOL] elif x != y : [EOL] ratio = max ( x , y ) / min ( x , y ) [EOL] if ratio == int ( ratio ) : [comment] [EOL] out [ [string] ] = max ( x , y ) [EOL] else : [EOL] return None [EOL] if [string] in out and [string] in s and out [ [string] ] != s [ [string] ] : [EOL] [comment] [EOL] m = merged ( [ out [ [string] ] , s [ [string] ] ] ) [EOL] if m == out [ [string] ] or m == s [ [string] ] : [EOL] out [ [string] ] = m [EOL] s . pop ( [string] ) [EOL] if [string] in out and [string] in s and out [ [string] ] != s [ [string] ] : [EOL] out [ [string] ] = { [string] : [ out [ [string] ] , s . pop ( [string] ) ] } [EOL] if ( [string] in out [EOL] and [string] in s [EOL] and out [ [string] ] != s [ [string] ] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] odeps = out [ [string] ] [EOL] for k , v in odeps . copy ( ) . items ( ) : [EOL] if k in s [ [string] ] : [EOL] sval = s [ [string] ] . pop ( k ) [EOL] if isinstance ( v , list ) and isinstance ( sval , list ) : [EOL] odeps [ k ] = v + sval [EOL] continue [EOL] if isinstance ( v , list ) : [EOL] v = { [string] : v } [EOL] elif isinstance ( sval , list ) : [EOL] sval = { [string] : sval } [EOL] m = merged ( [ v , sval ] ) [EOL] if m is None : [EOL] return None [EOL] odeps [ k ] = m [EOL] odeps . update ( s . pop ( [string] ) ) [EOL] if [string] in out or [string] in s : [EOL] oitems = out . pop ( [string] , TRUTHY ) [EOL] sitems = s . pop ( [string] , TRUTHY ) [EOL] if isinstance ( oitems , list ) and isinstance ( sitems , list ) : [EOL] out [ [string] ] = [ ] [EOL] out [ [string] ] = merged ( [ out . get ( [string] , TRUTHY ) , s . get ( [string] , TRUTHY ) , ] ) [EOL] for a , b in itertools . zip_longest ( oitems , sitems ) : [EOL] if a is None : [EOL] a = out . get ( [string] , TRUTHY ) [EOL] elif b is None : [EOL] b = s . get ( [string] , TRUTHY ) [EOL] out [ [string] ] . append ( merged ( [ a , b ] ) ) [EOL] elif isinstance ( oitems , list ) : [EOL] out [ [string] ] = [ merged ( [ x , sitems ] ) for x in oitems ] [EOL] out [ [string] ] = merged ( [ out . get ( [string] , TRUTHY ) , sitems ] ) [EOL] elif isinstance ( sitems , list ) : [EOL] out [ [string] ] = [ merged ( [ x , oitems ] ) for x in sitems ] [EOL] out [ [string] ] = merged ( [ s . get ( [string] , TRUTHY ) , oitems ] ) [EOL] else : [EOL] out [ [string] ] = merged ( [ oitems , sitems ] ) [EOL] if out [ [string] ] is None : [EOL] return None [EOL] if isinstance ( out [ [string] ] , list ) and None in out [ [string] ] : [EOL] return None [EOL] if out . get ( [string] , TRUTHY ) is None : [EOL] return None [EOL] s . pop ( [string] , None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for k , v in s . items ( ) : [EOL] if k not in out : [EOL] out [ k ] = v [EOL] elif out [ k ] != v and k in ALL_KEYWORDS : [EOL] [comment] [EOL] [comment] [EOL] return None [EOL] out = canonicalish ( out ) [EOL] if out == FALSEY : [EOL] return FALSEY [EOL] assert isinstance ( out , dict ) [EOL] _get_validator_class ( out ) [EOL] return out [EOL] [EOL] [EOL] def has_divisibles ( start , end , divisor , exmin , exmax ) : [EOL] [docstring] [EOL] divisible_num = end // divisor - start // divisor [EOL] if not exmin and not start % divisor : [EOL] divisible_num += [number] [EOL] if exmax and not end % divisor : [EOL] divisible_num -= [number] [EOL] return divisible_num >= [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.float],typing.Optional[builtins.float],builtins.bool,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.int],typing.Optional[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.NoReturn$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Schema]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pathlib [EOL] [docstring] [EOL] [EOL] import json [EOL] import pathlib [EOL] [EOL] p = pathlib . Path ( __file__ ) . parent / [string] [EOL] p . write_text ( json . dumps ( json . loads ( p . read_text ( ) ) , indent = [number] , sort_keys = True ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] from datetime import date [EOL] from functools import lru_cache [EOL] from pathlib import Path [EOL] from typing import NamedTuple [EOL] [EOL] import hypothesis_jsonschema [EOL] [EOL] [EOL] class Version ( NamedTuple ) : [EOL] major = ... [EOL] minor = ... [EOL] patch = ... [EOL] [EOL] @ classmethod def from_string ( cls , string ) : [EOL] return cls ( * map ( int , string . split ( [string] ) ) ) [EOL] [EOL] [EOL] @ lru_cache ( ) def get_releases ( ) : [EOL] pattern = re . compile ( [string] ) [EOL] with open ( Path ( __file__ ) . parent . parent / [string] ) as f : [EOL] return tuple ( ( Version . from_string ( match . group ( [number] ) ) , match . group ( [number] ) ) for match in map ( pattern . match , f ) if match is not None ) [EOL] [EOL] [EOL] def test_last_release_against_changelog ( ) : [EOL] last_version , last_date = get_releases ( ) [ [number] ] [EOL] assert last_version == Version . from_string ( hypothesis_jsonschema . __version__ ) [EOL] assert last_date <= date . today ( ) . isoformat ( ) [EOL] [EOL] [EOL] def test_changelog_is_ordered ( ) : [EOL] versions , dates = zip ( * get_releases ( ) ) [EOL] assert versions == tuple ( sorted ( versions , reverse = True ) ) [EOL] assert dates == tuple ( sorted ( dates , reverse = True ) ) [EOL] [EOL] [EOL] def test_version_increments_are_correct ( ) : [EOL] [comment] [EOL] [comment] [EOL] versions , _ = zip ( * get_releases ( ) ) [EOL] for prev , current in zip ( versions [ [number] : ] , versions ) : [EOL] assert prev < current [comment] [EOL] assert current in ( prev . _replace ( patch = prev . patch + [number] ) , prev . _replace ( minor = prev . minor + [number] , patch = [number] ) , prev . _replace ( major = prev . major + [number] , minor = [number] , patch = [number] ) , ) , f"{ current } [string] { prev }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] [EOL] from hypothesis import given [EOL] [EOL] from hypothesis_jsonschema . _encode import encode_canonical_json [EOL] from hypothesis_jsonschema . _from_schema import JSON_STRATEGY [EOL] [EOL] [EOL] @ given ( JSON_STRATEGY ) def test_canonical_json_encoding ( v ) : [EOL] [docstring] [EOL] encoded = encode_canonical_json ( v ) [EOL] v2 = json . loads ( encoded ) [EOL] assert v == v2 [EOL] assert encode_canonical_json ( v2 ) == encoded [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List , Any [EOL] import typing [EOL] import builtins [EOL] import hypothesis_jsonschema [EOL] import hypothesis [EOL] [docstring] [EOL] [EOL] import re [EOL] from typing import Any , Dict , List , Union [EOL] [EOL] import jsonschema [EOL] import pytest [EOL] from hypothesis import assume , strategies as st [EOL] [EOL] from hypothesis_jsonschema . _canonicalise import JSONType , Schema , encode_canonical_json [EOL] from hypothesis_jsonschema . _from_schema import ( JSON_STRATEGY , REGEX_PATTERNS , STRING_FORMATS , from_schema , ) [EOL] [EOL] [EOL] def json_schemata ( ) : [EOL] [docstring] [EOL] return _json_schemata ( ) [EOL] [EOL] [EOL] @ st . composite def _json_schemata ( draw , recur = True ) : [EOL] [comment] [EOL] [comment] [EOL] options = [ st . builds ( dict ) , st . just ( { [string] : [string] } ) , st . just ( { [string] : [string] } ) , gen_number ( [string] ) , gen_number ( [string] ) , gen_string ( ) , st . builds ( dict , const = JSON_STRATEGY ) , gen_enum ( ) , st . booleans ( ) , ] [EOL] if recur : [EOL] options += [ gen_array ( ) , gen_object ( ) , gen_if_then_else ( ) , json_schemata ( ) . map ( lambda v : assume ( v and v is not True ) and { [string] : v } ) , st . builds ( dict , anyOf = st . lists ( json_schemata ( ) , min_size = [number] ) ) , st . builds ( dict , oneOf = st . lists ( json_schemata ( ) , min_size = [number] , max_size = [number] ) ) , st . builds ( dict , allOf = st . lists ( json_schemata ( ) , min_size = [number] , max_size = [number] ) ) , ] [EOL] [EOL] return draw ( st . one_of ( options ) ) [EOL] [EOL] [EOL] def gen_enum ( ) : [EOL] [docstring] [EOL] return st . fixed_dictionaries ( { [string] : st . lists ( JSON_STRATEGY , min_size = [number] , max_size = [number] , unique_by = encode_canonical_json ) } ) [EOL] [EOL] [EOL] @ st . composite def gen_if_then_else ( draw ) : [EOL] [docstring] [EOL] [comment] [EOL] if_schema = draw ( json_schemata ( ) . filter ( lambda v : bool ( v and v is not True ) ) ) [EOL] return { [string] : if_schema , [string] : if_schema , [string] : { } } [EOL] [EOL] [EOL] @ st . composite def gen_number ( draw , kind ) : [EOL] [docstring] [EOL] max_int_float = [number] ** [number] [EOL] lower = draw ( st . none ( ) | st . integers ( - max_int_float , max_int_float ) ) [EOL] upper = draw ( st . none ( ) | st . integers ( - max_int_float , max_int_float ) ) [EOL] if lower is not None and upper is not None and lower > upper : [EOL] lower , upper = upper , lower [EOL] multiple_of = draw ( st . none ( ) | st . integers ( [number] , [number] ) | st . floats ( [number] / [number] , [number] , exclude_min = True ) ) [EOL] assume ( None in ( multiple_of , lower , upper ) or multiple_of <= ( upper - lower ) ) [EOL] assert kind in ( [string] , [string] ) [EOL] out = { [string] : kind } [EOL] [comment] [EOL] assert hasattr ( jsonschema , [string] ) [EOL] if lower is not None : [EOL] if draw ( st . booleans ( ) , label = [string] ) : [EOL] out [ [string] ] = lower - [number] [EOL] else : [EOL] out [ [string] ] = lower [EOL] if upper is not None : [EOL] if draw ( st . booleans ( ) , label = [string] ) : [EOL] out [ [string] ] = upper + [number] [EOL] else : [EOL] out [ [string] ] = upper [EOL] if multiple_of is not None : [EOL] out [ [string] ] = multiple_of [EOL] return out [EOL] [EOL] [EOL] @ st . composite def gen_string ( draw ) : [EOL] [docstring] [EOL] min_size = draw ( st . none ( ) | st . integers ( [number] , [number] ) ) [EOL] max_size = draw ( st . none ( ) | st . integers ( [number] , [number] ) ) [EOL] if min_size is not None and max_size is not None and min_size > max_size : [EOL] min_size , max_size = max_size , min_size [EOL] pattern = draw ( st . none ( ) | REGEX_PATTERNS ) [EOL] format_ = draw ( st . none ( ) | st . sampled_from ( sorted ( STRING_FORMATS ) ) ) [EOL] out = { [string] : [string] } [EOL] if pattern is not None : [EOL] out [ [string] ] = pattern [EOL] elif format_ is not None : [EOL] out [ [string] ] = format_ [EOL] if min_size is not None : [EOL] out [ [string] ] = min_size [EOL] if max_size is not None : [EOL] out [ [string] ] = max_size [EOL] return out [EOL] [EOL] [EOL] @ st . composite def gen_array ( draw ) : [EOL] [docstring] [EOL] min_size = draw ( st . none ( ) | st . integers ( [number] , [number] ) ) [EOL] max_size = draw ( st . none ( ) | st . integers ( [number] , [number] ) ) [EOL] if min_size is not None and max_size is not None and min_size > max_size : [EOL] min_size , max_size = max_size , min_size [EOL] items = draw ( st . builds ( dict ) | _json_schemata ( recur = False ) | st . lists ( _json_schemata ( recur = False ) , min_size = [number] , max_size = [number] ) ) [EOL] out = { [string] : [string] , [string] : items } [EOL] if isinstance ( items , list ) : [EOL] increment = len ( items ) [EOL] additional = draw ( st . none ( ) | _json_schemata ( recur = False ) ) [EOL] if additional is not None : [EOL] out [ [string] ] = additional [EOL] elif draw ( st . booleans ( ) ) : [EOL] out [ [string] ] = draw ( _json_schemata ( recur = False ) . filter ( bool ) ) [EOL] increment += [number] [EOL] if min_size is not None : [EOL] min_size += increment [EOL] if max_size is not None : [EOL] max_size += increment [EOL] else : [EOL] if draw ( st . booleans ( ) ) : [EOL] out [ [string] ] = True [EOL] if items == { } : [EOL] out [ [string] ] = draw ( _json_schemata ( recur = False ) ) [EOL] if min_size is not None : [EOL] out [ [string] ] = min_size [EOL] if max_size is not None : [EOL] out [ [string] ] = max_size [EOL] return out [EOL] [EOL] [EOL] @ st . composite def gen_object ( draw ) : [EOL] [docstring] [EOL] out = { [string] : [string] } [EOL] names = draw ( st . sampled_from ( [ None , None , None , draw ( gen_string ( ) ) ] ) ) [EOL] name_strat = st . text ( ) if names is None else from_schema ( names ) [EOL] required = draw ( st . just ( False ) | st . lists ( name_strat , min_size = [number] , max_size = [number] , unique = True ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] properties = draw ( st . dictionaries ( name_strat , _json_schemata ( recur = False ) ) ) [EOL] disjoint = REGEX_PATTERNS . filter ( lambda r : all ( re . search ( r , string = name ) is None for name in properties ) ) [EOL] patterns = draw ( st . dictionaries ( disjoint , _json_schemata ( recur = False ) , max_size = [number] ) ) [EOL] additional = draw ( st . none ( ) | _json_schemata ( recur = False ) ) [EOL] [EOL] min_size = draw ( st . none ( ) | st . integers ( [number] , [number] ) ) [EOL] max_size = draw ( st . none ( ) | st . integers ( [number] , [number] ) ) [EOL] if min_size is not None and max_size is not None and min_size > max_size : [EOL] min_size , max_size = max_size , min_size [EOL] [EOL] if names is not None : [EOL] out [ [string] ] = names [EOL] if required : [EOL] out [ [string] ] = required [EOL] if min_size is not None : [EOL] min_size += len ( required ) [EOL] if max_size is not None : [EOL] max_size += len ( required ) [EOL] if min_size is not None : [EOL] out [ [string] ] = min_size [EOL] if max_size is not None : [EOL] out [ [string] ] = max_size [EOL] if properties : [EOL] out [ [string] ] = properties [EOL] [EOL] props = st . sampled_from ( sorted ( properties ) ) [EOL] if draw ( st . integers ( [number] , [number] ) ) == [number] : [EOL] out [ [string] ] = draw ( st . dictionaries ( props , st . lists ( props , unique = True ) ) ) [EOL] elif draw ( st . integers ( [number] , [number] ) ) == [number] : [EOL] out [ [string] ] = draw ( st . dictionaries ( props , json_schemata ( ) ) ) [EOL] if patterns : [EOL] out [ [string] ] = patterns [EOL] if additional is not None : [EOL] out [ [string] ] = additional [EOL] [EOL] return out [EOL] [EOL] [EOL] schema_strategy_params = pytest . mark . parametrize ( [string] , [ pytest . param ( gen_number ( [string] ) , id = [string] ) , pytest . param ( gen_number ( [string] ) , id = [string] ) , pytest . param ( gen_string ( ) , id = [string] ) , pytest . param ( gen_enum ( ) , id = [string] ) , pytest . param ( gen_array ( ) , id = [string] ) , pytest . param ( gen_object ( ) , id = [string] ) , pytest . param ( json_schemata ( ) , id = [string] ) , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hypothesis.strategies.SearchStrategy[typing.Dict[builtins.str,typing.List[hypothesis_jsonschema._canonicalise.JSONType]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hypothesis_jsonschema._canonicalise.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hypothesis_jsonschema._canonicalise.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $hypothesis_jsonschema._canonicalise.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict , Any , List , Union [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] import re [EOL] from pathlib import Path [EOL] [EOL] import jsonschema [EOL] import pytest [EOL] import strict_rfc3339 [EOL] from gen_schemas import schema_strategy_params [EOL] from hypothesis import ( HealthCheck , assume , given , note , reject , settings , strategies as st , ) [EOL] from hypothesis . errors import FailedHealthCheck , InvalidArgument [EOL] from hypothesis . internal . reflection import proxies [EOL] [EOL] from hypothesis_jsonschema . _canonicalise import ( HypothesisRefResolutionError , canonicalish , resolve_all_refs , ) [EOL] from hypothesis_jsonschema . _from_schema import from_schema , rfc3339 [EOL] [EOL] [EOL] @ settings ( suppress_health_check = [ HealthCheck . too_slow , HealthCheck . filter_too_much ] , deadline = None , ) @ given ( data = st . data ( ) ) @ schema_strategy_params def test_generated_data_matches_schema ( schema_strategy , data ) : [EOL] [docstring] [EOL] schema = data . draw ( schema_strategy ) [EOL] note ( schema ) [EOL] try : [EOL] value = data . draw ( from_schema ( schema ) , [string] ) [EOL] except InvalidArgument : [EOL] reject ( ) [EOL] try : [EOL] jsonschema . validate ( value , schema ) [EOL] [comment] [EOL] jsonschema . validate ( value , canonicalish ( schema ) ) [EOL] except jsonschema . ValidationError as err : [EOL] if [string] in str ( err ) : [EOL] pytest . xfail ( [string] ) [EOL] raise [EOL] [EOL] [EOL] @ given ( from_schema ( True ) ) def test_boolean_true_is_valid_schema_and_resolvable ( _ ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ None , False , { [string] : [string] } , { [string] : [ { [string] : [string] } , { [string] : None } ] } , { [string] : [ { [string] : [string] } , { [string] : [ None ] } ] } , ] , ) def test_invalid_schemas_raise ( schema ) : [EOL] [docstring] [EOL] with pytest . raises ( Exception ) : [EOL] from_schema ( schema ) . example ( ) [EOL] [EOL] [EOL] INVALID_SCHEMAS = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] NON_EXISTENT_REF_SCHEMAS = { [string] , [string] , [string] , } [EOL] UNSUPPORTED_SCHEMAS = { [string] , [string] , } [EOL] FLAKY_SCHEMAS = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] SLOW_SCHEMAS = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] with open ( Path ( __file__ ) . parent / [string] ) as f : [EOL] catalog = json . load ( f ) [EOL] with open ( Path ( __file__ ) . parent / [string] ) as f : [EOL] suite , invalid_suite = json . load ( f ) [EOL] with open ( Path ( __file__ ) . parent / [string] ) as f : [EOL] reported = json . load ( f ) [EOL] assert set ( reported ) . isdisjoint ( suite ) [EOL] suite . update ( reported ) [EOL] [EOL] [EOL] def to_name_params ( corpus ) : [EOL] for n in sorted ( corpus ) : [EOL] if n in INVALID_SCHEMAS | NON_EXISTENT_REF_SCHEMAS : [EOL] continue [EOL] if n in UNSUPPORTED_SCHEMAS : [EOL] continue [EOL] elif n in SLOW_SCHEMAS : [EOL] yield pytest . param ( n , marks = pytest . mark . skip ) [EOL] elif n in FLAKY_SCHEMAS : [EOL] yield pytest . param ( n , marks = pytest . mark . skip ( strict = False ) ) [EOL] else : [EOL] if isinstance ( corpus [ n ] , dict ) and [string] in corpus [ n ] : [EOL] jsonschema . validators . validator_for ( corpus [ n ] ) . check_schema ( corpus [ n ] ) [EOL] yield n [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , sorted ( INVALID_SCHEMAS ) ) def test_invalid_schemas_are_invalid ( name ) : [EOL] with pytest . raises ( Exception ) : [EOL] jsonschema . validators . validator_for ( catalog [ name ] ) . check_schema ( catalog [ name ] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , sorted ( NON_EXISTENT_REF_SCHEMAS ) ) def test_invalid_ref_schemas_are_invalid ( name ) : [EOL] with pytest . raises ( Exception ) : [EOL] resolve_all_refs ( catalog [ name ] ) [EOL] [EOL] [EOL] RECURSIVE_REFS = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] [EOL] def xfail_on_reference_resolve_error ( f ) : [EOL] @ proxies ( f ) def inner ( * args , ** kwargs ) : [EOL] _ , name = args [EOL] assert isinstance ( name , str ) [EOL] try : [EOL] f ( * args , ** kwargs ) [EOL] assert name not in RECURSIVE_REFS [EOL] except jsonschema . exceptions . RefResolutionError as err : [EOL] if ( isinstance ( err , HypothesisRefResolutionError ) or isinstance ( err . _cause , HypothesisRefResolutionError ) ) and ( [string] in str ( err ) or name in RECURSIVE_REFS [EOL] and [string] in str ( err ) ) : [EOL] pytest . xfail ( ) [EOL] raise [EOL] [EOL] return inner [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , to_name_params ( catalog ) ) @ settings ( deadline = None , max_examples = [number] , suppress_health_check = HealthCheck . all ( ) ) @ given ( data = st . data ( ) ) @ xfail_on_reference_resolve_error def test_can_generate_for_real_large_schema ( data , name ) : [EOL] note ( name ) [EOL] value = data . draw ( from_schema ( catalog [ name ] ) ) [EOL] jsonschema . validate ( value , catalog [ name ] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , to_name_params ( suite ) ) @ settings ( suppress_health_check = [ HealthCheck . too_slow , HealthCheck . data_too_large ] , deadline = None , max_examples = [number] , ) @ given ( data = st . data ( ) ) @ xfail_on_reference_resolve_error def test_can_generate_for_test_suite_schema ( data , name ) : [EOL] note ( suite [ name ] ) [EOL] value = data . draw ( from_schema ( suite [ name ] ) ) [EOL] try : [EOL] jsonschema . validate ( value , suite [ name ] ) [EOL] except jsonschema . exceptions . SchemaError : [EOL] jsonschema . Draft4Validator ( suite [ name ] ) . validate ( value ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , to_name_params ( invalid_suite ) ) def test_cannot_generate_for_empty_test_suite_schema ( name ) : [EOL] strat = from_schema ( invalid_suite [ name ] ) [EOL] with pytest . raises ( Exception ) : [EOL] strat . example ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] OVERLAPPING_PATTERNS_SCHEMA = { [string] : [string] , [string] : { [string] : { } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : False , [string] : [number] , } [EOL] [EOL] [EOL] @ given ( from_schema ( OVERLAPPING_PATTERNS_SCHEMA ) ) def test_handles_overlapping_patternproperties ( value ) : [EOL] jsonschema . validate ( value , OVERLAPPING_PATTERNS_SCHEMA ) [EOL] assert [string] not in value [EOL] [EOL] [EOL] [comment] [EOL] SCHEMA = { [string] : [string] , [string] : { [string] : { [string] : [string] } } , [string] : False , } [EOL] [EOL] [EOL] @ given ( from_schema ( SCHEMA ) ) def test_single_property_can_generate_nonempty ( query ) : [EOL] [comment] [EOL] assume ( query ) [EOL] [EOL] [EOL] @ given ( rfc3339 ( [string] ) ) def test_generated_rfc3339_datetime_strings_are_valid ( datetime_string ) : [EOL] assert strict_rfc3339 . validate_rfc3339 ( datetime_string ) [EOL] [EOL] [EOL] UNIQUE_NUMERIC_ARRAY_SCHEMA = { [string] : [string] , [string] : True , [string] : { [string] : [ [number] , [number] ] } , [string] : [number] , } [EOL] [EOL] [EOL] @ given ( from_schema ( UNIQUE_NUMERIC_ARRAY_SCHEMA ) ) def test_numeric_uniqueness ( value ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] jsonschema . validate ( value , UNIQUE_NUMERIC_ARRAY_SCHEMA ) [EOL] [EOL] [EOL] def test_draft03_not_supported ( ) : [EOL] [comment] [EOL] @ given ( from_schema ( { [string] : [string] } ) ) def f ( _ ) : [EOL] raise AssertionError [EOL] [EOL] with pytest . raises ( InvalidArgument ) : [EOL] f ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_impossible_multiplier ( type_ ) : [EOL] [comment] [EOL] [comment] [EOL] schema = { [string] : - [number] , [string] : - [number] , [string] : [number] } [EOL] schema [ [string] ] = type_ [EOL] strategy = from_schema ( schema ) [EOL] strategy . validate ( ) [EOL] assert strategy . is_empty [EOL] [EOL] [EOL] ALLOF_CONTAINS = { [string] : [string] , [string] : { [string] : [string] } , [string] : [ { [string] : { [string] : [string] } } , { [string] : { [string] : [string] } } ] , } [EOL] [EOL] [EOL] @ pytest . mark . xfail ( raises = FailedHealthCheck ) @ given ( from_schema ( ALLOF_CONTAINS ) ) def test_multiple_contains_behind_allof ( value ) : [EOL] [comment] [EOL] [comment] [EOL] jsonschema . validate ( value , ALLOF_CONTAINS ) [EOL] [EOL] [EOL] @ jsonschema . FormatChecker . cls_checks ( [string] ) def validate_card_format ( string ) : [EOL] [comment] [EOL] return bool ( re . match ( [string] , string ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ { [string] : [string] } , { [number] : st . just ( [string] ) } , { [string] : st . just ( [string] ) } , { [string] : st . just ( [string] ) } , ] , ) @ given ( data = st . data ( ) ) def test_custom_formats_validation ( data , kw ) : [EOL] s = from_schema ( { [string] : [string] , [string] : [string] } , custom_formats = kw ) [EOL] with pytest . raises ( InvalidArgument ) : [EOL] data . draw ( s ) [EOL] [EOL] [EOL] @ given ( num = from_schema ( { [string] : [string] , [string] : [string] } , custom_formats = { [string] : st . just ( [string] ) } , ) ) def test_allowed_custom_format ( num ) : [EOL] assert num == [string] [EOL] [EOL] [EOL] @ given ( string = from_schema ( { [string] : [string] , [string] : [string] } , custom_formats = { [string] : st . just ( [string] ) } , ) ) def test_allowed_unknown_custom_format ( string ) : [EOL] assert string == [string] [EOL] assert [string] not in jsonschema . FormatChecker ( ) . checkers [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str]]],builtins.bool,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str]]],builtins.bool,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str]]],builtins.bool,builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.float]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.float]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.float]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import jsonschema [EOL] import pytest [EOL] from gen_schemas import gen_number , json_schemata , schema_strategy_params [EOL] from hypothesis import HealthCheck , assume , given , note , settings , strategies as st [EOL] from hypothesis . errors import InvalidArgument [EOL] [EOL] from hypothesis_jsonschema import from_schema [EOL] from hypothesis_jsonschema . _canonicalise import ( FALSEY , canonicalish , get_type , make_validator , merged , next_up , resolve_all_refs , ) [EOL] from hypothesis_jsonschema . _from_schema import JSON_STRATEGY [EOL] [EOL] [EOL] def is_valid ( instance , schema ) : [EOL] return make_validator ( schema ) . is_valid ( instance ) [EOL] [EOL] [EOL] @ settings ( suppress_health_check = [ HealthCheck . too_slow ] , deadline = None ) @ given ( data = st . data ( ) ) @ schema_strategy_params def test_canonicalises_to_equivalent_fixpoint ( schema_strategy , data ) : [EOL] [docstring] [EOL] schema = data . draw ( schema_strategy , label = [string] ) [EOL] cc = canonicalish ( schema ) [EOL] assert cc == canonicalish ( cc ) [EOL] try : [EOL] strat = from_schema ( cc ) [EOL] except InvalidArgument : [EOL] [comment] [EOL] assume ( False ) [EOL] instance = data . draw ( JSON_STRATEGY | strat , label = [string] ) [EOL] assert is_valid ( instance , schema ) == is_valid ( instance , cc ) [EOL] jsonschema . validators . validator_for ( schema ) . check_schema ( schema ) [EOL] [EOL] [EOL] def test_dependencies_canonicalises_to_fixpoint ( ) : [EOL] [docstring] [EOL] cc = canonicalish ( { [string] : [ [string] ] , [string] : { [string] : { } } , [string] : { [string] : [ [string] ] } } ) [EOL] assert cc == canonicalish ( cc ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ { [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] } , { [string] : [string] , [string] : [ [string] ] , [string] : { [string] : [number] } } , { [string] : [string] , [string] : False } , { [string] : [string] , [string] : [ False , True ] } , { [string] : [string] , [string] : None } , { [string] : [string] , [string] : False , [string] : [number] } , { [string] : [string] , [string] : { [string] : [string] } , [string] : True , [string] : [number] , } , { [string] : [string] , [string] : { [string] : [string] } , [string] : True , [string] : [number] , } , { [string] : [string] , [string] : { [string] : [ [string] , [string] ] } , [string] : True , [string] : [number] , } , { [string] : [string] , [string] : [ True , False ] , [string] : [number] } , { [string] : [string] , [string] : [ True ] , [string] : [number] , [string] : False } , { [string] : [string] , [string] : [ True , False , True ] , [string] : [number] , [string] : { [string] : [string] } , } , { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : - [number] , [string] : - [number] } , { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : - [number] , [string] : - [number] } , { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , } , { [string] : { [string] : [ [string] , [string] ] } , [string] : [string] } , { [string] : { [string] : [ { [string] : [string] } , { [string] : [string] } ] } , [string] : [string] } , { [string] : { [string] : [ [number] , [number] , [number] ] } , [string] : [number] } , { [string] : [ ] } , { [string] : [ { } , { } ] } , { [string] : [ True , False , { } ] } , { [string] : [ False , { [string] : { } } ] } , { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [ [string] , [string] ] , [string] : { [string] : [number] } , } , { [string] : [string] , [string] : { [string] : [string] , [string] : [number] , [string] : [number] } , [string] : True , [string] : [number] , } , { [string] : [string] , [string] : { [string] : [string] } , [string] : { [string] : [string] } } , { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [ [number] , [number] ] } , [string] : [number] } , [string] : [number] , [string] : True , } , ] , ) def test_canonicalises_to_empty ( schema ) : [EOL] assert canonicalish ( schema ) == { [string] : { } } , ( schema , canonicalish ( schema ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( { [string] : get_type ( { } ) } , { } ) , ( { [string] : [ ] } , { } ) , ( { [string] : [string] , [string] : { [string] : [string] } } , { [string] : [string] } ) , ( { [string] : [string] , [string] : [ True , False , True ] } , { [string] : [string] , [string] : [ { } ] , [string] : [number] } , ) , ( { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] } , ) , ( { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] } , ) , ( { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] } , ) , ( { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] } , ) , ( { [string] : [ [string] ] , [string] : { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] } } , { [string] : [ [string] , [string] , [string] ] , [string] : { [string] : [ [string] ] } } , ) , ( { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] } , { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] } , ) , ( { [string] : [string] , [string] : [number] , [string] : next_up ( [number] ) } , { [string] : [number] } , ) , ( { [string] : [string] , [string] : [number] , [string] : next_up ( [number] ) } , { [string] : next_up ( [number] ) } , ) , ( { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , } , { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , } , ) , ( { [string] : [ [string] , [number] , [string] , None , [number] ] } , { [string] : [ None , [number] , [number] , [string] , [string] ] } ) , ( { [string] : { } , [string] : { } , [string] : [string] } , { [string] : [number] , [string] : [string] } , ) , ( { [string] : [ { } , { [string] : [string] } ] } , { } ) , ( { [string] : [ { [string] : [ { [string] : [ { [string] : [string] } ] } ] } ] } , { [string] : None } ) , ( { [string] : [ { [string] : [string] } , { [string] : [ { [string] : [string] } , { [string] : [string] } ] } , ] } , { [string] : [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] } , ) , ( { [string] : False } , { } ) , ( { [string] : [string] , [string] : [ True , True ] , [string] : [number] , [string] : { [string] : [string] } , } , { [string] : [string] , [string] : [ { } , { } ] , [string] : [number] , [string] : { [string] : None } , } , ) , ( { [string] : [string] , [string] : { [string] : [string] , [string] : [number] } , [string] : { [string] : [string] , [string] : [number] } , } , { [string] : [string] , [string] : [number] , [string] : { [string] : [string] , [string] : [number] } , [string] : { [string] : [string] , [string] : [number] } , } , ) , ( { [string] : [string] , [string] : { [string] : [number] } , [string] : True } , { [string] : [string] , [string] : { [string] : [number] } , [string] : True , [string] : [number] , } , ) , ] , ) def test_canonicalises_to_expected ( schema , expected ) : [EOL] assert canonicalish ( schema ) == expected , ( schema , canonicalish ( schema ) , expected ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ { [string] : [ ] } , { } ] , { [string] : { } } ) , ( [ { [string] : [string] } , { [string] : [number] } ] , { [string] : { } } ) , ( [ { [string] : [string] } , { [string] : [ [number] ] } ] , { [string] : { } } ) , ( [ { [string] : [string] } , { [string] : [string] } ] , { [string] : { } } ) , ( [ { [string] : [string] } , { [string] : [string] } ] , { [string] : { } } ) , ( [ { [string] : [string] } , { [string] : [ None , True ] } ] , { [string] : None } ) , ( [ { [string] : [string] } , { [string] : [ [string] , True ] } ] , { [string] : [string] } ) , ( [ { [string] : [string] } , { [string] : [ [string] , [string] ] } ] , { [string] : None } ) , ( [ { [string] : [string] } , { [string] : [number] } ] , { [string] : [string] , [string] : [number] } ) , ( [ { [string] : [string] } , { [string] : [string] } ] , { [string] : [string] } ) , ( [ { [string] : [number] } , { [string] : [number] } ] , { [string] : [number] } ) , ( [ { [string] : [number] } , { [string] : [number] } ] , { [string] : [number] } ) , ( [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } , ] , None , ) , ( [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , ] , { [string] : [string] , [string] : [number] } , ) , ( [ { [string] : { [string] : { [string] : [number] } } } , { [string] : { [string] : { [string] : [number] } } } , ] , { [string] : { [string] : { [string] : [number] , [string] : [number] } } } , ) , ( [ { [string] : { } , [string] : { } , [string] : [string] } , { [string] : False , [string] : [string] } , ] , { [string] : { } } , ) , ( [ { [string] : [ { [string] : [number] } , { [string] : [number] } ] } , { [string] : [ { [string] : [number] } , { [string] : [number] } ] } , ] , { [string] : [ { [string] : [number] } , { [string] : [number] } , { [string] : [number] } , ] } , ) , ( [ { [string] : { [string] : [string] } } , { [string] : { [string] : [string] } } , ] , { [string] : { [string] : { } } } , ) , ( [ { [string] : { [string] : [string] } , [string] : { [string] : { } } } , { [string] : { [string] : [string] } } , ] , { [string] : { [string] : { [string] : [ False , True ] } } , [string] : { [string] : { } } , [string] : [number] , } , ) , ( [ { [string] : { [string] : { [string] : [string] } } , [string] : [ [string] ] , [string] : [string] , } , { [string] : { [string] : [string] } , [string] : [string] } , ] , { [string] : { } } , ) , ( [ { [string] : { [string] : { [string] : { } } } } , { [string] : { [string] : { [string] : { } } } } , ] , { [string] : { [string] : { [string] : { } , [string] : { } } } } , ) , ( [ { [string] : { [string] : { [string] : [ None , True ] } } } , { [string] : { [string] : { [string] : [string] } } } , ] , { [string] : { [string] : { [string] : [ None , True ] } } , [string] : { [string] : { [string] : True } } , } , ) , ( [ { [string] : [string] , [string] : { [string] : [string] } } , { [string] : [string] , [string] : { [string] : [string] } } , ] , { [string] : [string] , [string] : { [string] : [string] } , [string] : [number] } , ) , ( [ { [string] : { [string] : [ [number] , [number] , [number] ] } } , { [string] : { [string] : [ [string] , [string] , [string] ] } } ] , { [string] : { [string] : [ { [string] : [ [string] , [string] , [string] ] } , { [string] : [ [number] , [number] , [number] ] } ] } } , ) , ( [ { [string] : { [string] : [ [string] ] } } , { [string] : { [string] : [ [string] ] } } ] , { [string] : { [string] : [ [string] , [string] ] } } , ) , ( [ { [string] : { [string] : [ [string] ] } } , { [string] : { [string] : [ [string] ] } } ] , { [string] : { [string] : [ [string] ] , [string] : [ [string] ] } } , ) , ( [ { [string] : { [string] : [ [string] ] } } , { [string] : { [string] : { [string] : { [string] : { [string] : [string] } } } } } , ] , { [string] : { [string] : { [string] : [ [string] ] , [string] : { [string] : { [string] : [string] } } } } , } , ) , ( [ { [string] : { [string] : { [string] : { [string] : { [string] : [string] } } } } } , { [string] : { [string] : [ [string] ] } } , ] , { [string] : { [string] : { [string] : [ [string] ] , [string] : { [string] : { [string] : [string] } } } } , } , ) , ( [ { [string] : { [string] : { [string] : [string] } } } , { [string] : { [string] : { [string] : [string] } } } , ] , None , ) , ( [ { [string] : { [string] : [string] } } , { [string] : { [string] : [string] } } ] , None ) , ( [ { [string] : [ { [string] : [string] } ] } , { [string] : [ { [string] : [string] } ] } ] , None , ) , ( [ { [string] : [ { } ] , [string] : { [string] : [string] } } , { [string] : [ { } ] , [string] : { [string] : [string] } } , ] , None , ) , ( [ { [string] : [ { } , { [string] : [string] } ] , [string] : False } , { [string] : [ { [string] : [string] } ] } , ] , { [string] : [ { [string] : [string] } , { [string] : [string] } ] , [string] : FALSEY , } , ) , ] + [ ( [ { lo : [number] , hi : [number] } , { lo : [number] , hi : [number] } ] , { lo : [number] , hi : [number] } ) for lo , hi in [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ] , ) def test_merged ( group , result ) : [EOL] assert merged ( group ) == result [EOL] [EOL] [EOL] @ settings ( suppress_health_check = [ HealthCheck . too_slow ] , deadline = None ) @ given ( json_schemata ( ) ) def test_self_merge_eq_canonicalish ( schema ) : [EOL] m = merged ( [ schema , schema ] ) [EOL] assert m == canonicalish ( schema ) [EOL] [EOL] [EOL] def _merge_semantics_helper ( data , s1 , s2 , combined ) : [EOL] note ( f" [string] { combined !r}" ) [EOL] ic = data . draw ( from_schema ( combined ) , label = [string] ) [EOL] i1 = data . draw ( from_schema ( s1 ) , label = [string] ) [EOL] i2 = data . draw ( from_schema ( s2 ) , label = [string] ) [EOL] assert is_valid ( ic , s1 ) [EOL] assert is_valid ( ic , s2 ) [EOL] assert is_valid ( i1 , s2 ) == is_valid ( i1 , combined ) [EOL] assert is_valid ( i2 , s1 ) == is_valid ( i2 , combined ) [EOL] [EOL] [EOL] @ settings ( suppress_health_check = HealthCheck . all ( ) , deadline = None ) @ given ( st . data ( ) , json_schemata ( ) , json_schemata ( ) ) def test_merge_semantics ( data , s1 , s2 ) : [EOL] assume ( canonicalish ( s1 ) != FALSEY and canonicalish ( s2 ) != FALSEY ) [EOL] combined = merged ( [ s1 , s2 ] ) [EOL] assume ( combined is not None ) [EOL] assert combined == merged ( [ s2 , s1 ] ) [comment] [EOL] assume ( combined != FALSEY ) [EOL] _merge_semantics_helper ( data , s1 , s2 , combined ) [EOL] [EOL] [EOL] @ settings ( suppress_health_check = HealthCheck . all ( ) , deadline = None ) @ given ( st . data ( ) , gen_number ( kind = [string] ) | gen_number ( kind = [string] ) , gen_number ( kind = [string] ) | gen_number ( kind = [string] ) , ) def test_can_almost_always_merge_numeric_schemas ( data , s1 , s2 ) : [EOL] assume ( canonicalish ( s1 ) != FALSEY and canonicalish ( s2 ) != FALSEY ) [EOL] combined = merged ( [ s1 , s2 ] ) [EOL] if combined is None : [EOL] [comment] [EOL] [comment] [EOL] mul1 , mul2 = s1 [ [string] ] , s2 [ [string] ] [EOL] assert isinstance ( mul1 , float ) or isinstance ( mul2 , float ) [EOL] assert mul1 != mul2 [EOL] ratio = max ( mul1 , mul2 ) / min ( mul1 , mul2 ) [EOL] assert ratio != int ( ratio ) [comment] [EOL] elif combined != FALSEY : [EOL] _merge_semantics_helper ( data , s1 , s2 , combined ) [EOL] [EOL] [EOL] def test_resolution_checks_resolver_is_valid ( ) : [EOL] with pytest . raises ( InvalidArgument ) : [EOL] resolve_all_refs ( { } , resolver = [string] ) [EOL] [EOL] [EOL] @ settings ( suppress_health_check = [ HealthCheck . too_slow ] , deadline = None ) @ given ( data = st . data ( ) ) def _canonicalises_to_equivalent_fixpoint ( data ) : [EOL] [comment] [EOL] [comment] [EOL] schema = data . draw ( json_schemata ( ) , label = [string] ) [EOL] cc = canonicalish ( schema ) [EOL] assert cc == canonicalish ( cc ) [EOL] try : [EOL] strat = from_schema ( cc ) [EOL] except InvalidArgument : [EOL] [comment] [EOL] assume ( False ) [EOL] instance = data . draw ( JSON_STRATEGY | strat , label = [string] ) [EOL] assert is_valid ( instance , schema ) == is_valid ( instance , cc ) [EOL] jsonschema . validators . validator_for ( schema ) . check_schema ( schema ) [EOL] [EOL] [EOL] def test_canonicalise_is_only_valid_for_schemas ( ) : [EOL] with pytest . raises ( InvalidArgument ) : [EOL] canonicalish ( [string] ) [EOL] [EOL] [EOL] def test_validators_use_proper_draft ( ) : [EOL] [comment] [EOL] schema = { [string] : [string] , [string] : { [string] : [ { [string] : True , [string] : [number] } , { [string] : True , [string] : [number] } , ] } , } [EOL] cc = canonicalish ( schema ) [EOL] jsonschema . validators . validator_for ( cc ) . check_schema ( cc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , List , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import concurrent . futures [EOL] import io [EOL] import json [EOL] import urllib . request [EOL] import zipfile [EOL] from typing import Any [EOL] [EOL] [EOL] def get_json ( url ) : [EOL] [docstring] [EOL] assert url . startswith ( [string] ) or url . startswith ( [string] ) [EOL] with urllib . request . urlopen ( url ) as handle : [EOL] return json . load ( handle ) [EOL] [EOL] [EOL] [comment] [EOL] try : [EOL] with open ( [string] ) as f : [EOL] schemata = json . load ( f ) [EOL] except FileNotFoundError : [EOL] schemata = { } [EOL] [EOL] [comment] [EOL] with concurrent . futures . ThreadPoolExecutor ( ) as ex : [EOL] futures = [ ] [EOL] [EOL] def add_future ( name , url ) : [EOL] futures . append ( ex . submit ( lambda n , u : ( n , get_json ( u ) ) , name , url ) ) [EOL] [EOL] for s in get_json ( [string] ) [ [string] ] : [EOL] if [string] in s : [EOL] for version , link in s [ [string] ] . items ( ) : [EOL] add_future ( f"{ s [ [string] ] } [string] { version }" , link ) [EOL] else : [EOL] add_future ( s [ [string] ] , s [ [string] ] ) [EOL] for future in concurrent . futures . as_completed ( futures , timeout = [number] ) : [EOL] name = [string] [EOL] try : [EOL] name , schema = future . result ( ) [EOL] except Exception as e : [EOL] print ( f" [string] { name !r} [string] { e } [string] " ) [comment] [EOL] else : [EOL] schemata [ name ] = schema [EOL] [EOL] [EOL] [comment] [EOL] with open ( [string] , mode = [string] ) as f : [EOL] json . dump ( schemata , f , indent = [number] , sort_keys = True ) [EOL] [EOL] [EOL] [comment] [EOL] suite = { } [EOL] invalid_suite = { } [EOL] [EOL] with urllib . request . urlopen ( [string] ) as handle : [EOL] start = [string] [EOL] with zipfile . ZipFile ( io . BytesIO ( handle . read ( ) ) ) as zf : [EOL] seen = set ( ) [EOL] for path in zf . namelist ( ) : [EOL] if path . startswith ( start + [string] ) and path . endswith ( [string] ) : [EOL] for v in json . load ( zf . open ( path ) ) : [EOL] if any ( t [ [string] ] for t in v [ [string] ] ) : [EOL] suite [ [string] + v [ [string] ] ] = v [ [string] ] [EOL] seen . add ( json . dumps ( v [ [string] ] , sort_keys = True ) ) [EOL] elif [string] not in path : [EOL] invalid_suite [ [string] + v [ [string] ] ] = v [ [string] ] [EOL] seen . add ( json . dumps ( v [ [string] ] , sort_keys = True ) ) [EOL] for path in zf . namelist ( ) : [EOL] if path . startswith ( start + [string] ) and path . endswith ( [string] ) : [EOL] for v in json . load ( zf . open ( path ) ) : [EOL] if json . dumps ( v [ [string] ] , sort_keys = True ) in seen : [EOL] [comment] [EOL] continue [EOL] elif any ( t [ [string] ] for t in v [ [string] ] ) : [EOL] suite [ [string] + v [ [string] ] ] = v [ [string] ] [EOL] elif [string] not in path : [EOL] invalid_suite [ [string] + v [ [string] ] ] = v [ [string] ] [EOL] [EOL] with open ( [string] , mode = [string] ) as f : [EOL] json . dump ( [ suite , invalid_suite ] , f , indent = [number] , sort_keys = True ) [EOL] [EOL] [EOL] [comment] [EOL] with open ( [string] ) as f : [EOL] schemata = json . load ( f ) [EOL] with open ( [string] , mode = [string] ) as f : [EOL] json . dump ( schemata , f , indent = [number] , sort_keys = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0