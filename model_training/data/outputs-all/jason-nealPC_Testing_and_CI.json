[comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import numpy as np [EOL] import pytest [EOL] import examples [EOL] from examples import inc , wav_selector , telluric_mask , division [EOL] [EOL] [EOL] def test_pass_inc ( ) : [EOL] assert inc ( [number] ) == [number] [EOL] [EOL] @ pytest . mark . xfail ( ) def test_inc ( ) : [EOL] [comment] [EOL] assert inc ( [number] ) == [number] [EOL] [EOL] def test_raising_error ( ) : [EOL] [comment] [EOL] with pytest . raises ( ZeroDivisionError ) : [EOL] division ( [number] , [number] ) [EOL] [EOL] @ pytest . mark . xfail ( ) def test_not_raising_error ( ) : [EOL] [comment] [EOL] with pytest . raises ( ZeroDivisionError ) : [EOL] division ( [number] , [number] ) [EOL] [EOL] [EOL] [comment] [EOL] from hypothesis import given , example , assume [EOL] import hypothesis . strategies as st [EOL] from math import isnan [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] @ given ( st . integers ( ) , st . integers ( ) ) def test_ints_are_commutative ( x , y ) : [EOL] assert x + y == y + x [EOL] [EOL] @ given ( x = st . integers ( ) , y = st . integers ( ) ) def test_ints_cancel ( x , y ) : [EOL] assert ( x + y ) - y == x [EOL] [EOL] @ given ( st . lists ( st . integers ( ) ) ) def test_reversing_twice_gives_same_list ( xs ) : [EOL] [comment] [EOL] [comment] [EOL] ys = list ( xs ) [EOL] ys . reverse ( ) [EOL] ys . reverse ( ) [EOL] assert xs == ys [EOL] [EOL] @ given ( st . tuples ( st . booleans ( ) , st . text ( ) ) ) def test_look_tuples_work_too ( t ) : [EOL] [comment] [EOL] [comment] [EOL] assert len ( t ) == [number] [EOL] assert isinstance ( t [ [number] ] , bool ) [EOL] assert isinstance ( t [ [number] ] , str ) [EOL] [EOL] [EOL] [comment] [EOL] @ given ( st . lists ( st . floats ( allow_infinity = False ) , min_size = [number] ) , st . floats ( ) , st . floats ( ) ) [comment] [EOL] @ example ( [ [number] , [number] , [number] , [number] ] , [number] , [number] ) def test_wav_selector ( wav , xmin , xmax ) : [EOL] assume ( not isnan ( xmin ) ) [comment] [EOL] assume ( not isnan ( xmax ) ) [EOL] wav = np . asarray ( wav ) [EOL] flux = wav + [number] [comment] [EOL] [EOL] new_wav , new_flux = wav_selector ( wav , flux , xmin , xmax ) [EOL] [EOL] assert np . all ( new_wav > xmin ) [comment] [EOL] assert np . all ( new_wav < xmax ) [comment] [EOL] assert len ( new_wav ) == len ( new_flux ) [EOL] [EOL] [EOL] @ given ( st . lists ( st . floats ( min_value = [number] , max_value = [number] , allow_infinity = False ) , min_size = [number] , max_size = [number] ) , st . sampled_from ( [ [number] , [number] ] ) ) def test_telluric_mask_properties ( flux , limit ) : [EOL] flux = np . asarray ( flux ) [EOL] mask = telluric_mask ( flux , limit ) [EOL] assert np . all ( flux [ mask ] > limit ) [comment] [EOL] assert np . all ( flux [ ~ mask ] <= limit ) [comment] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] , [number] ] ) def test_telluric_mask_with_parameters ( limit ) : [EOL] flux = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [comment] [EOL] [EOL] mask = telluric_mask ( flux , limit ) [EOL] assert np . all ( flux [ mask ] > limit ) [EOL] assert np . all ( flux [ ~ mask ] <= limit ) [EOL] assert len ( flux [ mask ] ) < len ( flux ) [EOL] [EOL] [EOL] from examples import type_hint_test [EOL] [EOL] def test_type_hint_test ( ) : [EOL] [comment] [EOL] [comment] [EOL] assert type_hint_test ( [number] , [number] ) == [number] [EOL] assert isinstance ( type_hint_test ( [number] , [number] ) , float ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Dict , Any , Union [EOL] import typing [EOL] try : [EOL] from setuptools import setup [EOL] except ImportError : [EOL] from distutils . core import setup [EOL] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : [ [string] ] , [string] : { [string] : [ [string] ] , [string] : [ [string] ] , } , [string] : [ ] , [string] : [ [string] ] , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , ] , [string] : [ ] , } [EOL] [EOL] setup ( ** config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.List[typing.Any],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.List[typing.Any],typing.List[builtins.str],builtins.str]]$ 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import numpy as np [EOL] [EOL] [comment] [EOL] def inc ( x ) : [EOL] [docstring] [EOL] return x + [number] [EOL] [EOL] def division ( a , b ) : [EOL] if b == [number] : [EOL] raise ZeroDivisionError ( [string] ) [EOL] else : [EOL] return a / b [EOL] [EOL] [EOL] [comment] [EOL] def wav_selector ( wav , flux , wav_min , wav_max ) : [EOL] [docstring] [EOL] wav = np . asarray ( wav ) [EOL] flux = np . asarray ( flux ) [EOL] [EOL] mask = ( wav > wav_min ) & ( wav < wav_max ) [EOL] wav_sel = wav [ mask ] [EOL] flux_sel = flux [ mask ] [EOL] return [ wav_sel , flux_sel ] [EOL] [EOL] [EOL] [comment] [EOL] def telluric_mask ( flux , limit = [number] ) : [EOL] [docstring] [EOL] [EOL] mask = flux > limit [EOL] [EOL] return mask [EOL] [EOL] [EOL] [comment] [EOL] def type_hint_test ( x , y ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return x + y [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0