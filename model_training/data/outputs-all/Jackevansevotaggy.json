[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from itertools import chain [EOL] from setuptools import setup , find_packages [EOL] from taggy import __version__ [EOL] [EOL] dev_requirements = [ [string] , [string] , [string] , ] [EOL] [EOL] test_requirements = [ [string] , [string] , ] [EOL] [EOL] [EOL] setup ( name = [string] , version = __version__ , description = [string] , url = [string] , author = [string] , author_email = [string] , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , packages = [ [string] ] , setup_requires = [ [string] ] , tests_require = test_requirements , install_requires = [ [string] ] , python_requires = [string] , entry_points = { [string] : [ [string] ] } , extras_require = { [string] : list ( chain ( dev_requirements , test_requirements ) ) , [string] : test_requirements , } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Pattern , Tuple , Any [EOL] import typing [EOL] import re [EOL] from itertools import chain , islice , repeat [EOL] [EOL] PRERELEASE_REGEX = re . compile ( [string] ) [EOL] [EOL] SEMVER_NUMS = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] def pad ( iterable , size , padding = None ) : [EOL] return islice ( chain ( iterable , repeat ( padding ) ) , size ) [EOL] [EOL] [EOL] class InvalidSemanticVersion ( Exception ) : [EOL] [EOL] def __init__ ( self , version ) : [EOL] self . version = version [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . version ) [EOL] [EOL] [EOL] class Semver : [EOL] [EOL] def __init__ ( self , version ) : [EOL] [EOL] [comment] [EOL] init , self . build = pad ( version . rsplit ( [string] ) , [number] ) [EOL] [EOL] head , self . prerelease = pad ( init . split ( [string] , [number] ) , [number] ) [EOL] [EOL] version_nums = pad ( map ( int , head . split ( [string] ) ) , [number] ) [EOL] [EOL] self . major , self . minor , self . patch = version_nums [EOL] [EOL] if self . prerelease is not None : [EOL] if not PRERELEASE_REGEX . match ( self . prerelease ) : [EOL] raise InvalidSemanticVersion ( version ) [EOL] [EOL] if any ( part is None for part in ( self . major , self . minor , self . patch ) ) : [EOL] raise InvalidSemanticVersion ( version ) [EOL] [EOL] @ property def components ( self ) : [EOL] return dict ( zip ( SEMVER_NUMS , ( self . major , self . minor , self . patch ) ) ) [EOL] [EOL] @ property def valstrings ( self ) : [EOL] return map ( str , ( self . major , self . minor , self . patch ) ) [EOL] [EOL] def bump ( self , part ) : [EOL] part = part . lower ( ) [EOL] for key , value in self . components . items ( ) : [EOL] if key == part : [EOL] setattr ( self , key , value + [number] ) [EOL] elif SEMVER_NUMS . index ( key ) > SEMVER_NUMS . index ( part ) : [EOL] setattr ( self , key , [number] ) [EOL] return self [EOL] [EOL] def __repr__ ( self ) : [EOL] repr_string = [string] [EOL] return repr_string . format ( self . major , self . minor , self . patch ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . join ( self . valstrings ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Literal , Optional , Tuple , List , Any [EOL] import typing [EOL] import argparse [EOL] import taggy [EOL] import subprocess [EOL] import typing_extensions [EOL] import builtins [EOL] import os [EOL] import string [EOL] import sys [EOL] from argparse import ArgumentParser , FileType , Namespace [EOL] from difflib import ndiff , unified_diff [EOL] from os import fdopen , remove [EOL] from shutil import copy , which [EOL] from subprocess import DEVNULL , PIPE , CalledProcessError , run [EOL] from tempfile import mkstemp [EOL] from typing import Optional , Tuple [EOL] [EOL] import crayons [comment] [EOL] from taggy import __version__ [EOL] from taggy . prompts import choice , confirm [EOL] from taggy . semver import Semver [EOL] [EOL] DESC = [string] [EOL] [EOL] [comment] [EOL] SEMVER_NUMS = ( [string] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] PREFIX = slice ( [number] , [number] ) [EOL] REST = slice ( [number] , None ) [EOL] [EOL] [EOL] def parse_args ( args ) : [EOL] parser = ArgumentParser ( description = DESC , ) [EOL] parser . add_argument ( [string] , type = str . lower , nargs = [string] , choices = SEMVER_NUMS ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , metavar = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = FileType ( [string] ) , nargs = [string] , help = [string] ) [EOL] args = parser . parse_args ( args ) [EOL] if args . no_tag and args . files is None : [EOL] parser . error ( [string] ) [EOL] [EOL] [comment] [EOL] if args . no_color : [EOL] crayons . disable ( ) [EOL] [EOL] [comment] [EOL] if args . version : [EOL] print ( [string] , __version__ ) [EOL] sys . exit ( [number] ) [EOL] [EOL] return args [EOL] [EOL] [EOL] def is_git_repo ( path ) : [EOL] [docstring] [EOL] cmd = [ [string] , [string] ] [EOL] out = run ( cmd , cwd = path , stdout = DEVNULL , stderr = DEVNULL ) [EOL] return out . returncode == [number] [EOL] [EOL] [EOL] def sanitize ( s ) : [EOL] [docstring] [EOL] return s . decode ( [string] ) . strip ( ) [EOL] [EOL] [EOL] def color_diff ( diff ) : [EOL] [docstring] [EOL] for line in diff : [EOL] if line . startswith ( [string] ) or line . startswith ( [string] ) : [EOL] yield str ( crayons . black ( line , bold = True ) ) [EOL] elif line . startswith ( [string] ) : [EOL] yield str ( crayons . green ( line ) ) [EOL] elif line . startswith ( [string] ) : [EOL] yield str ( crayons . red ( line ) ) [EOL] elif line . startswith ( [string] ) : [EOL] yield str ( crayons . cyan ( line ) ) [EOL] else : [EOL] yield line [EOL] [EOL] [EOL] def get_tag ( path , default = None ) : [EOL] [docstring] [EOL] [comment] [EOL] cmd = [ [string] , [string] , [string] , [string] ] [EOL] try : [EOL] [comment] [EOL] result = run ( cmd , stdout = PIPE , stderr = DEVNULL , cwd = path , check = True ) [EOL] except CalledProcessError : [EOL] [comment] [EOL] return default [EOL] else : [EOL] return sanitize ( result . stdout ) [EOL] [EOL] [EOL] def create_tag ( path , tag , message ) : [EOL] [docstring] [EOL] cmd = [ [string] , [string] , [string] , tag , [string] , message . format ( tag ) ] [EOL] result = run ( cmd , cwd = path ) [EOL] return result [EOL] [EOL] [EOL] def find_and_replace ( target , old , new , preview = False ) : [EOL] [docstring] [EOL] [comment] [EOL] fh , abs_path = mkstemp ( ) [EOL] with fdopen ( fh , [string] ) as new_file : [EOL] old_lines = target . readlines ( ) [EOL] for line in old_lines : [EOL] new_file . write ( line . replace ( old , new ) ) [EOL] if preview : [EOL] new_file . seek ( [number] ) [EOL] diff = [string] . join ( unified_diff ( old_lines , new_file . readlines ( ) , fromfile = os . path . join ( [string] , target . name ) , tofile = os . path . join ( [string] , target . name ) ) ) [EOL] if not preview : [EOL] [comment] [EOL] copy ( abs_path , target . name ) [EOL] else : [EOL] [comment] [EOL] remove ( abs_path ) [EOL] return diff [EOL] [EOL] [EOL] def strip_prefix ( tag ) : [EOL] if tag . startswith ( tuple ( string . ascii_letters ) ) : [EOL] return ( tag [ PREFIX ] , tag [ REST ] ) [EOL] return ( None , tag ) [EOL] [EOL] [EOL] def runchecks ( cwd ) : [EOL] [comment] [EOL] if not which ( [string] ) : [EOL] sys . exit ( [string] ) [EOL] [EOL] [comment] [EOL] if not is_git_repo ( cwd ) : [EOL] print ( [string] . format ( cwd ) , file = sys . stderr ) [EOL] if confirm ( [string] ) : [EOL] run ( [ [string] , [string] ] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] [comment] [EOL] args = parse_args ( sys . argv [ [number] : ] ) [EOL] [EOL] [comment] [EOL] cwd = os . getcwd ( ) [EOL] [EOL] [comment] [EOL] runchecks ( cwd ) [EOL] [EOL] [comment] [EOL] tag = get_tag ( cwd ) [EOL] [EOL] if tag is None : [EOL] if confirm ( [string] ) : [EOL] create_tag ( cwd , [string] , args . message ) [EOL] sys . exit ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] prefix , tag = strip_prefix ( tag ) [EOL] [EOL] if args . bump is None : [EOL] question = [string] [EOL] choices = ( [string] , [string] , [string] ) [EOL] args . bump = choice ( question , choices , allow_prefix = True ) [EOL] [EOL] current_tag = Semver ( tag ) [EOL] next_tag = str ( current_tag . bump ( args . bump ) ) [EOL] [EOL] [comment] [EOL] if args . preview : [EOL] old , new = ( [string] . format ( prefix or [string] , v ) for v in ( tag , next_tag ) ) [EOL] diff = [string] . join ( color_diff ( ndiff ( [ old ] , [ new ] ) ) ) [EOL] print ( crayons . magenta ( [string] ) , diff , sep = [string] ) [EOL] [EOL] [comment] [EOL] if prefix is not None : [EOL] next_tag = prefix + next_tag [EOL] [EOL] if args . files : [EOL] [comment] [EOL] _ , new_tag = strip_prefix ( next_tag ) [EOL] [comment] [EOL] diffs = [ find_and_replace ( f , tag , new_tag , args . preview ) for f in args . files ] [EOL] [comment] [EOL] file_names = [ f . name for f in args . files ] [EOL] [comment] [EOL] if any ( diffs ) : [EOL] for fname , diff in zip ( file_names , diffs ) : [EOL] print ( [string] . join ( color_diff ( diff . split ( [string] ) ) ) ) [EOL] [EOL] [comment] [EOL] if not args . preview : [EOL] fnames = [string] . join ( file_names ) [EOL] print ( crayons . red ( [string] ) . format ( fnames ) ) [EOL] if confirm ( [string] ) : [EOL] run ( [ [string] , [string] ] + file_names ) [EOL] run ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] if args . no_tag or args . preview : [EOL] sys . exit ( ) [EOL] [EOL] [comment] [EOL] result = create_tag ( cwd , next_tag , args . message ) [EOL] if result . returncode == [number] : [EOL] success_msg = [string] . format ( next_tag ) [EOL] print ( crayons . green ( success_msg ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.slice$ 0 0 0 0 0 0 0 0 $builtins.slice$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.slice$ 0 0 0 0 $builtins.slice$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import ChainMap , Dict , Any [EOL] import collections [EOL] import typing [EOL] import taggy [EOL] from collections import ChainMap [EOL] import sys [EOL] [EOL] PREFIX = slice ( [number] , [number] ) [EOL] [EOL] [EOL] class WriteOnceDict ( dict ) : [EOL] def __setitem__ ( self , key , value ) : [EOL] if key in self : [EOL] raise KeyError ( [string] . format ( key ) ) [EOL] super ( WriteOnceDict , self ) . __setitem__ ( key , value ) [EOL] [EOL] [EOL] def build_choices ( choices , allow_prefix = False ) : [EOL] options = WriteOnceDict ( ) [EOL] for choice in choices : [EOL] if allow_prefix : [EOL] options [ choice [ [number] ] ] = choice [EOL] options [ choice ] = choice [EOL] return options [EOL] [EOL] [EOL] def _prompt_choice ( question , options , lower ) : [EOL] selected = prompt ( question ) [EOL] if selected in options : [EOL] return options [ selected ] [EOL] elif lower and selected . lower ( ) in options : [EOL] return options [ selected . lower ( ) ] [EOL] else : [EOL] return _prompt_choice ( question , options , lower ) [EOL] [EOL] [EOL] def choice ( question , choices , allow_prefix = False , lower = True ) : [EOL] options = build_choices ( choices , allow_prefix ) [EOL] if lower : [EOL] lowered_options = { k . lower ( ) : v for k , v in options . items ( ) } [EOL] options = ChainMap ( options , lowered_options ) [EOL] return _prompt_choice ( question , options , lower ) [EOL] [EOL] [EOL] def prompt ( question , lower = False ) : [EOL] try : [EOL] answer = input ( question ) [EOL] except ( KeyboardInterrupt , EOFError ) as error : [EOL] sys . exit ( [string] ) [EOL] else : [EOL] return answer . lower ( ) if lower else answer [EOL] [EOL] [EOL] def confirm ( question ) : [EOL] text = [string] . join ( [ question , [string] ] ) [EOL] return choice ( text , [ [string] , [string] ] , allow_prefix = True ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.slice$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import taggy [EOL] from taggy . semver import Semver , InvalidSemanticVersion [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ] ) def test_semver ( data , part , expected ) : [EOL] version = Semver ( data ) [EOL] assert str ( version . bump ( part ) ) == expected [EOL] [EOL] [EOL] def test_repr ( ) : [EOL] version = Semver ( [string] ) [EOL] assert repr ( version ) == [string] [EOL] [EOL] [EOL] def test_should_parse_zero_prerelease ( ) : [EOL] result = Semver ( [string] ) [EOL] [EOL] assert vars ( result ) == { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , } [EOL] [EOL] result = Semver ( [string] ) [EOL] [EOL] assert vars ( result ) == { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def test_should_parse_version ( ) : [EOL] result = Semver ( [string] ) [EOL] assert vars ( result ) == { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , } [EOL] [EOL] result = Semver ( [string] ) [EOL] assert vars ( result ) == { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def check_validity ( tag ) : [EOL] with pytest . raises ( InvalidSemanticVersion ) as error : [EOL] Semver ( tag ) [EOL] assert str ( error . value ) == [string] . format ( tag ) [EOL] [EOL] [EOL] def test_raises_exception_on_invalid_prerelease ( ) : [EOL] check_validity ( [string] ) [EOL] [EOL] [EOL] def test_raises_exception_on_missing_part ( ) : [EOL] check_validity ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] from taggy . prompts import build_choices , choice , confirm , prompt [EOL] [EOL] CHOICES = ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ patch ( [string] , lambda _ : [string] ) def test_prompt_lowers_input ( ) : [EOL] assert prompt ( [string] , lower = True ) == [string] [EOL] [EOL] [EOL] @ patch ( [string] ) def test_prompt_quits_on_interrupt ( mock_input ) : [EOL] mock_input . side_effect = KeyboardInterrupt [EOL] with pytest . raises ( SystemExit ) as error : [EOL] prompt ( [string] ) [EOL] error . match ( [string] ) [EOL] [EOL] [EOL] @ patch ( [string] , lambda _ : [string] ) def test_confirm ( ) : [EOL] assert confirm ( [string] ) [EOL] [EOL] [EOL] @ patch ( [string] , lambda _ : [string] ) def test_choice_accepts_prefix ( ) : [EOL] answer = choice ( [string] , choices = CHOICES , allow_prefix = True ) [EOL] assert answer == [string] [EOL] [EOL] [EOL] @ patch ( [string] , lambda _ : [string] ) def test_choice_lowers_case ( ) : [EOL] answer = choice ( [string] , choices = CHOICES ) [EOL] assert answer == [string] [EOL] [EOL] [EOL] @ patch ( [string] , side_effect = [ [string] , [string] ] ) def test_choice_case_insensitive_by_default ( mock_input ) : [EOL] answer = choice ( [string] , choices = CHOICES ) [EOL] assert answer == [string] [EOL] answer = choice ( [string] , choices = CHOICES ) [EOL] assert answer == [string] [EOL] [EOL] [EOL] @ patch ( [string] , side_effect = [ [string] , [string] ] ) def test_choice_with_lower_disabled ( mock_input ) : [EOL] [docstring] [EOL] answer = choice ( [string] , choices = CHOICES , lower = False ) [EOL] assert answer == [string] [EOL] [EOL] [EOL] @ patch ( [string] , side_effect = [ [string] , [string] ] ) def test_choice_retries_on_failure ( mock_input ) : [EOL] [docstring] [EOL] answer = choice ( [string] , choices = CHOICES ) [EOL] assert answer == [string] [EOL] [EOL] [EOL] def test_build_choices_with_prefix ( ) : [EOL] assert build_choices ( [ [string] , [string] , [string] ] , allow_prefix = True ) == { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def test_build_choices_with_duplicate_keys ( ) : [EOL] with pytest . raises ( KeyError ) as error : [EOL] build_choices ( [ [string] , [string] , [string] ] , allow_prefix = True ) [EOL] error . match ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0