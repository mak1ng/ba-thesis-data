[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from setuptools import find_packages , setup [EOL] [EOL] install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] setup ( name = [string] , version = [string] , packages = find_packages ( exclude = [ [string] ] ) , install_requires = install_requires , dependency_links = [ ] , entry_points = { [string] : [ [string] , ] , } , extras_require = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [ [string] , [string] , ] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import uuid [EOL] import circle_core [EOL] import asyncio [EOL] import logging [EOL] import asyncio [EOL] import logging [EOL] import sys [EOL] import uuid [EOL] [EOL] import tornado . ioloop [EOL] [EOL] from circle_core . database import Database [EOL] from circle_core . logger import logger [EOL] from circle_core . message import ModuleMessage [EOL] from circle_core . models import MessageBox , MetaDataSession , Module , Schema [EOL] from circle_core . testing import setup_db [EOL] from circle_core . writer import JournalDBWriter , QueuedDBWriter , QueuedDBWriterDelegate [EOL] [EOL] [EOL] def _init_logging ( debug = False ) : [EOL] [comment] [EOL] fh = logging . StreamHandler ( sys . stderr ) [EOL] try : [EOL] from circle_core . logger import NiceColoredFormatter [EOL] [comment] [EOL] fh . setFormatter ( NiceColoredFormatter ( [string] , ) ) [EOL] except ImportError : [EOL] fh . setFormatter ( logging . Formatter ( [string] , ) ) [EOL] [EOL] root_logger = logging . getLogger ( ) [EOL] root_logger . addHandler ( fh ) [EOL] root_logger . setLevel ( logging . DEBUG if debug else logging . INFO ) [EOL] [EOL] [EOL] done = False [EOL] [EOL] [EOL] async def countup ( ) : [EOL] import time [EOL] [EOL] while not done : [EOL] print ( time . time ( ) ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] [EOL] async def test ( ) : [EOL] counterloop = asyncio . ensure_future ( countup ( ) ) [EOL] [EOL] setup_db ( ) [EOL] [EOL] mbox_id = uuid . UUID ( [string] ) [EOL] with MetaDataSession . begin ( ) : [EOL] schema = Schema . create ( display_name = [string] , properties = [string] ) [EOL] module = Module . create ( display_name = [string] ) [EOL] mbox = MessageBox ( uuid = mbox_id , schema_uuid = schema . uuid , module_uuid = module . uuid ) [EOL] MetaDataSession . merge ( schema ) [EOL] MetaDataSession . merge ( module ) [EOL] MetaDataSession . merge ( mbox ) [EOL] [EOL] database = Database ( [string] , [string] , [string] , connect_args = dict ( write_timeout = [number] , read_timeout = [number] ) ) [EOL] database . drop_message_box ( mbox ) [EOL] [EOL] queued_writer = QueuedDBWriter ( database , [string] ) [EOL] [EOL] class Delegate ( QueuedDBWriterDelegate ) : [EOL] [EOL] async def on_reconnect ( self ) : [EOL] print ( [string] ) [EOL] writer . touch ( ) [EOL] [EOL] queued_writer = QueuedDBWriter ( database , [string] , delegate = Delegate ( ) ) [EOL] writer = JournalDBWriter ( queued_writer , [string] ) [EOL] [EOL] print ( [string] ) [EOL] [comment] [EOL] database . connect ( ) [EOL] [EOL] print ( [string] ) [EOL] [comment] [EOL] message = ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [number] , [string] : [number] } ) [EOL] assert ( await writer . store ( mbox , message ) ) is True [EOL] [EOL] print ( [string] ) [EOL] await async_input ( [string] ) [EOL] [EOL] message = ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [number] , [string] : [number] } ) [EOL] assert ( await writer . store ( mbox , message ) ) is True [EOL] [EOL] assert ( await writer . store ( mbox , ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [number] , [string] : [number] } ) ) ) is True [EOL] assert ( await writer . store ( mbox , ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [number] , [string] : [number] } ) ) ) is True [EOL] assert ( await writer . store ( mbox , ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [number] , [string] : [number] } ) ) ) is True [EOL] assert ( await writer . store ( mbox , ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [number] , [string] : [number] } ) ) ) is True [EOL] [EOL] print ( [string] ) [EOL] await async_input ( [string] ) [EOL] [EOL] logger . info ( [string] ) [EOL] global done [EOL] done = True [EOL] await counterloop [EOL] [EOL] [EOL] def async_input ( * args ) : [EOL] return tornado . ioloop . IOLoop . current ( ) . run_in_executor ( None , input , * args ) [EOL] [EOL] [EOL] _init_logging ( True ) [EOL] loop = tornado . ioloop . IOLoop . current ( ) [EOL] loop . run_sync ( test ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import datetime [EOL] import logging [EOL] import json [EOL] import random [EOL] import time [EOL] import uuid [EOL] [EOL] import click [EOL] import nnpy [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , type = click . STRING , default = [string] ) @ click . option ( [string] , [string] , type = uuid . UUID , required = True ) def rand_bot ( send_to , box_id ) : [EOL] [docstring] [EOL] socket = nnpy . Socket ( nnpy . AF_SP , nnpy . REQ ) [EOL] socket . connect ( send_to ) [EOL] box_id = str ( box_id ) [EOL] i = [number] [EOL] while True : [EOL] i += [number] [EOL] req = { [string] : [string] , [string] : box_id , [string] : { [string] : datetime . datetime . utcnow ( ) . isoformat ( [string] ) , [string] : random . randint ( - [number] , [number] ) , } } [EOL] raw = json . dumps ( req ) . encode ( [string] ) [EOL] click . echo ( [string] . format ( raw ) ) [EOL] socket . send ( raw ) [EOL] [EOL] resp = socket . recv ( ) [EOL] click . echo ( [string] . format ( resp ) ) [EOL] [EOL] time . sleep ( random . randint ( [number] , [number] ) / [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] rand_bot ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import base64 [EOL] from datetime import date , datetime [EOL] import json [EOL] from time import sleep , time [EOL] import random [EOL] from uuid import UUID [EOL] [EOL] [comment] [EOL] import click [EOL] import nnpy [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , type = click . STRING , default = [string] ) @ click . option ( [string] , [string] , type = UUID , required = True ) @ click . option ( [string] , [string] , is_flag = True , default = False ) def many_types_bot ( send_to , box_id , send_null_value ) : [EOL] [docstring] [EOL] [EOL] def null_or_value ( value ) : [EOL] if send_null_value : [EOL] return random . choice ( [ value , None ] ) [EOL] return value [EOL] [EOL] socket = nnpy . Socket ( nnpy . AF_SP , nnpy . REQ ) [EOL] socket . connect ( send_to ) [EOL] [EOL] i = [number] [EOL] while True : [EOL] i += [number] [EOL] [EOL] data = { [string] : [string] , [string] : str ( box_id ) , [string] : { [string] : null_or_value ( i ) , [string] : null_or_value ( float ( i ) ) , [string] : null_or_value ( bool ( i ) ) , [string] : null_or_value ( [string] . format ( i ) ) , [string] : null_or_value ( base64 . b64encode ( [string] . format ( i ) . encode ( [string] ) ) . decode ( [string] ) ) , [string] : null_or_value ( str ( date . today ( ) ) ) , [string] : null_or_value ( str ( datetime . now ( ) ) ) , [string] : null_or_value ( str ( datetime . time ( datetime . now ( ) ) ) ) , [string] : null_or_value ( str ( datetime . fromtimestamp ( time ( ) ) ) ) , } } [EOL] msg = json . dumps ( data , indent = [number] , ensure_ascii = False ) [EOL] socket . send ( msg ) [EOL] [EOL] click . echo ( msg ) [EOL] sleep ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] many_types_bot ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import json [EOL] import uuid [EOL] [EOL] import click [EOL] import nnpy [EOL] import websocket [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , type = click . STRING , default = [string] ) @ click . option ( [string] , [string] , type = click . STRING , default = [string] ) @ click . option ( [string] , [string] , type = uuid . UUID , required = True ) def echo_bot ( receive_from , send_to , box_id ) : [EOL] socket = nnpy . Socket ( nnpy . AF_SP , nnpy . REQ ) [EOL] socket . connect ( send_to ) [EOL] [EOL] websocket . enableTrace ( True ) [EOL] receiver = websocket . create_connection ( receive_from ) [EOL] [EOL] while True : [EOL] receiver = websocket . create_connection ( receive_from , timeout = [number] ) [EOL] [EOL] i = [number] [EOL] while True : [EOL] i += [number] [EOL] try : [EOL] msg = receiver . recv ( ) [EOL] except websocket . WebSocketTimeoutException : [EOL] logger . error ( [string] ) [EOL] break [EOL] [EOL] for j , dic in enumerate ( json . loads ( msg ) ) : [EOL] req = { [string] : [string] , [string] : str ( box_id ) , [string] : dic , } [EOL] raw = json . dumps ( req ) . encode ( [string] ) [EOL] print ( [string] . format ( raw ) ) [EOL] socket . send ( raw ) [EOL] [EOL] resp = socket . recv ( ) [EOL] print ( [string] . format ( resp ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] echo_bot ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] from time import sleep [EOL] from uuid import UUID [EOL] [EOL] import click [EOL] import nnpy [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , type = click . STRING , default = [string] ) @ click . option ( [string] , [string] , type = UUID , required = True ) @ click . option ( [string] , [string] , type = float , default = [number] ) @ click . option ( [string] , [string] , is_flag = True ) def counter_bot ( send_to , box_id , interval = [number] , silent = False ) : [EOL] [docstring] [EOL] socket = nnpy . Socket ( nnpy . AF_SP , nnpy . REQ ) [EOL] socket . connect ( send_to ) [EOL] [EOL] i = [number] [EOL] while True : [EOL] i += [number] [EOL] [EOL] msg = json . dumps ( { [string] : [string] , [string] : str ( box_id ) , [string] : { [string] : i , [string] : [string] , } } , indent = [number] , ensure_ascii = False ) [EOL] socket . send ( msg ) [EOL] [EOL] if not silent : [EOL] click . echo ( [string] . format ( i ) ) [EOL] sleep ( interval ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] counter_bot ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import json [EOL] import uuid [EOL] [EOL] import click [EOL] import nnpy [EOL] import websocket [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , type = click . STRING , default = [string] ) @ click . option ( [string] , [string] , type = uuid . UUID , required = True ) def bitcoin_bot ( send_to , box_id ) : [EOL] [docstring] [EOL] socket = nnpy . Socket ( nnpy . AF_SP , nnpy . REQ ) [EOL] socket . connect ( send_to ) [EOL] [EOL] websocket . enableTrace ( True ) [EOL] receiver = websocket . create_connection ( [string] ) [EOL] receiver . send ( [string] ) [EOL] box_id = str ( box_id ) [EOL] while True : [EOL] res = json . loads ( receiver . recv ( ) ) [EOL] for transaction in res [ [string] ] [ [string] ] : [EOL] req = { [string] : [string] , [string] : str ( box_id ) , [string] : { [string] : transaction [ [string] ] , [string] : transaction [ [string] ] / [number] ** [number] , } , } [EOL] raw = json . dumps ( req ) . encode ( [string] ) [EOL] print ( [string] . format ( raw ) ) [EOL] socket . send ( raw ) [EOL] [EOL] resp = socket . recv ( ) [EOL] print ( [string] . format ( resp ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] bitcoin_bot ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import urllib [EOL] [docstring] [EOL] [EOL] import urllib . request [EOL] from uuid import UUID [EOL] [EOL] import click [EOL] [EOL] [EOL] def setup_basic_auth ( uri , user , password ) : [EOL] password_mgr = urllib . request . HTTPPasswordMgrWithDefaultRealm ( ) [EOL] password_mgr . add_password ( None , uri , user , password ) [EOL] auth_handler = urllib . request . HTTPBasicAuthHandler ( password_mgr ) [EOL] opener = urllib . request . build_opener ( auth_handler ) [EOL] urllib . request . install_opener ( opener ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , type = click . STRING , required = True , default = [string] , help = [string] ) @ click . option ( [string] , type = click . STRING , required = True , help = [string] ) @ click . option ( [string] , type = click . STRING , required = True , help = [string] ) @ click . option ( [string] , [string] , type = UUID , required = True , help = [string] ) @ click . option ( [string] , [string] , type = UUID , required = True , help = [string] ) @ click . option ( [string] , type = click . STRING , help = [string] ) @ click . option ( [string] , type = click . STRING , help = [string] ) @ click . option ( [string] , [string] , [string] , type = click . STRING , help = [string] ) def download ( base_uri , user , password , module_id , box_id , start , end , filename ) : [EOL] setup_basic_auth ( base_uri , user , password ) [EOL] [EOL] url = [string] . format ( uri = base_uri , module_id = module_id , box_id = box_id , ) [EOL] query = [ ] [EOL] if start : [EOL] query . append ( [string] + start ) [EOL] if end : [EOL] query . append ( [string] + end ) [EOL] if len ( query ) : [EOL] url += [string] + [string] . join ( query ) [EOL] [EOL] if filename : [EOL] urllib . request . urlretrieve ( url , filename ) [EOL] else : [EOL] response = urllib . request . urlopen ( url ) . read ( ) [EOL] click . echo ( response ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] download ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import click [EOL] import nnpy [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , [string] , type = click . STRING , default = [string] , help = [string] ) @ click . option ( [string] , type = click . STRING , help = [string] ) @ click . option ( [string] , type = click . INT , help = [string] ) def subscribe ( receive_from , topic , timeout ) : [EOL] socket = nnpy . Socket ( nnpy . AF_SP , nnpy . SUB ) [EOL] socket . connect ( receive_from ) [EOL] [EOL] socket . setsockopt ( nnpy . SUB , nnpy . SUB_SUBSCRIBE , topic or [string] ) [EOL] if timeout : [EOL] socket . setsockopt ( nnpy . SOL_SOCKET , nnpy . RCVTIMEO , timeout * [number] ) [EOL] [EOL] while True : [EOL] try : [EOL] raw = socket . recv ( ) [EOL] message = raw . decode ( [string] ) [EOL] click . echo ( message ) [EOL] except nnpy . NNError as e : [EOL] click . echo ( e ) [EOL] break [EOL] socket . close ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] subscribe ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Optional , Dict , Type , Any [EOL] import typing [EOL] import decimal [EOL] import uuid [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] import decimal [EOL] import logging [EOL] import time [EOL] import uuid [EOL] from typing import NamedTuple , TYPE_CHECKING , Union [EOL] [EOL] from . utils import prepare_uuid [EOL] [EOL] if TYPE_CHECKING : [EOL] from typing import Optional [EOL] [EOL] from . types import Payload [EOL] [EOL] message_timestamp_context = decimal . Context ( [number] , decimal . ROUND_DOWN ) [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] Timestamp = decimal . Decimal [EOL] TimestampLike = Union [ float , str , Timestamp ] [EOL] [EOL] [EOL] class ModuleMessagePrimaryKey ( NamedTuple ) : [EOL] timestamp = ... [EOL] counter = ... [EOL] [EOL] def to_json ( self ) : [EOL] assert isinstance ( self . timestamp , decimal . Decimal ) [EOL] [EOL] return [ str ( self . timestamp ) , self . counter ] [EOL] [EOL] @ classmethod def from_json ( cls , jsonobj ) : [EOL] if jsonobj is None : [EOL] return None [EOL] [EOL] assert isinstance ( jsonobj , list ) [EOL] [EOL] return cls ( ModuleMessage . make_timestamp ( jsonobj [ [number] ] ) , jsonobj [ [number] ] ) [EOL] [EOL] @ classmethod def origin ( cls ) : [EOL] return cls ( ModuleMessage . make_timestamp ( [string] ) , [number] ) [EOL] [EOL] [EOL] class ModuleMessage ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , box_id , timestamp , counter , payload ) : [EOL] [docstring] [EOL] assert isinstance ( box_id , uuid . UUID ) [EOL] [EOL] self . box_id = box_id [EOL] self . timestamp = self . make_timestamp ( timestamp ) [EOL] self . counter = counter [EOL] self . payload = payload [EOL] [EOL] @ classmethod def from_json ( cls , data ) : [EOL] return cls ( prepare_uuid ( data [ [string] ] ) , data [ [string] ] , data [ [string] ] , data [ [string] ] ) [EOL] [EOL] @ classmethod def make_timestamp ( cls , timestamp = None ) : [EOL] if not timestamp : [EOL] timestamp = time . time ( ) [EOL] assert isinstance ( timestamp , ( float , str , decimal . Decimal ) ) [EOL] [EOL] if isinstance ( timestamp , float ) : [EOL] return message_timestamp_context . create_decimal_from_float ( timestamp ) [EOL] else : [EOL] return message_timestamp_context . create_decimal ( timestamp ) [EOL] [EOL] @ classmethod def is_equal_timestamp ( cls , x , y ) : [EOL] return message_timestamp_context . compare ( cls . make_timestamp ( x ) , cls . make_timestamp ( y ) ) . is_zero ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( str ( self . box_id ) , str ( self . timestamp ) , self . counter , ) [EOL] [EOL] @ property def primary_key ( self ) : [EOL] return ModuleMessagePrimaryKey ( self . timestamp , self . counter ) [EOL] [EOL] def to_json ( self , * , with_boxid = True ) : [EOL] [docstring] [EOL] d = { [string] : str ( self . timestamp ) , [string] : self . counter , [string] : self . payload , } [EOL] if with_boxid : [EOL] d [ [string] ] = self . box_id . hex [EOL] return d [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Timestamp$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 $builtins.int$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 $typing.Union[None,decimal.Decimal,builtins.float,builtins.str]$ 0 0 0 0 0 0 0 $typing.Union[None,decimal.Decimal,builtins.float,builtins.str]$ 0 0 $typing.Union[None,decimal.Decimal,builtins.float,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,decimal.Decimal,builtins.float,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,decimal.Decimal,builtins.float,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,decimal.Decimal,builtins.float,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,decimal.Decimal,builtins.float,builtins.str]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $TimestampLike$ 0 $TimestampLike$ 0 0 0 0 0 0 0 0 0 0 0 0 $TimestampLike$ 0 0 0 0 0 0 $TimestampLike$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ModuleMessagePrimaryKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0
[comment] [EOL] [EOL] [comment] [EOL] from typing import Any , Optional , List [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] import uuid [EOL] import datetime [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] import uuid [EOL] from typing import Optional [EOL] [EOL] [comment] [EOL] import dateutil . parser [EOL] import dateutil . tz [EOL] [EOL] [EOL] def prepare_uuid ( v ) : [EOL] if not v : [EOL] return None [EOL] if not isinstance ( v , uuid . UUID ) : [EOL] v = uuid . UUID ( v ) [EOL] return v [EOL] [EOL] [EOL] def prepare_date ( v ) : [EOL] if not v : [EOL] return v [EOL] if isinstance ( v , str ) : [EOL] v = dateutil . parser . parse ( v ) [EOL] if not v : [EOL] raise ValueError ( [string] . format ( v ) ) [EOL] if not v . tzinfo : [EOL] [comment] [EOL] v = v . replace ( tzinfo = dateutil . tz . tzlocal ( ) ) [EOL] [comment] [EOL] v = v . astimezone ( dateutil . tz . tzutc ( ) ) [EOL] return v [EOL] [EOL] [EOL] def format_date ( v ) : [EOL] assert v is None or isinstance ( v , datetime . datetime ) [EOL] [EOL] if not v : [EOL] return None [EOL] return v . isoformat ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] def portable_popen ( cmd , * args , ** kwargs ) : [EOL] [docstring] [EOL] if cmd [ [number] ] is None : [EOL] raise RuntimeError ( [string] ) [EOL] exe = locate_executable ( cmd [ [number] ] , kwargs . get ( [string] ) ) [EOL] if exe is None : [EOL] raise RuntimeError ( [string] % cmd [ [number] ] ) [EOL] [EOL] if isinstance ( exe , str ) : [EOL] exe = exe . encode ( sys . getfilesystemencoding ( ) ) [EOL] cmd [ [number] ] = exe [EOL] [EOL] return subprocess . Popen ( cmd , * args , ** kwargs ) [EOL] [EOL] [EOL] def locate_executable ( exe_file , cwd = None ) : [EOL] [docstring] [EOL] choices = [ exe_file ] [EOL] resolve = True [EOL] [EOL] [comment] [EOL] if os . path . sep in exe_file or ( os . path . altsep and os . path . altsep in exe_file ) : [EOL] resolve = False [EOL] [EOL] extensions = os . environ . get ( [string] , [string] ) . split ( [string] ) [EOL] _ , ext = os . path . splitext ( exe_file ) [EOL] if os . name != [string] and [string] not in extensions or any ( ext . lower ( ) == extension . lower ( ) for extension in extensions ) : [EOL] extensions . insert ( [number] , [string] ) [EOL] [EOL] if resolve : [EOL] paths = os . environ . get ( [string] , [string] ) . split ( os . pathsep ) [EOL] choices = [ os . path . join ( path , exe_file ) for path in paths ] [EOL] [EOL] if os . name == [string] : [EOL] choices . append ( os . path . join ( ( cwd or os . getcwd ( ) ) , exe_file ) ) [EOL] [EOL] try : [EOL] for path in choices : [EOL] for ext in extensions : [EOL] if os . access ( path + ext , os . X_OK ) : [EOL] return path + ext [EOL] except OSError : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Dict , Type [EOL] import typing [EOL] import circle_core [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import logging [EOL] [EOL] try : [EOL] import colorama [EOL] [EOL] class NiceColoredFormatter ( logging . Formatter ) : [EOL] [docstring] [EOL] [EOL] short_levelname_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] level_color_map = { [string] : colorama . Style . DIM + colorama . Fore . WHITE , [string] : colorama . Fore . WHITE , [string] : colorama . Fore . YELLOW , [string] : colorama . Fore . RED , [string] : colorama . Style . BRIGHT + colorama . Fore . RED + colorama . Back . WHITE , } [EOL] name_color = colorama . Fore . MAGENTA [EOL] asctime_color = colorama . Style . DIM + colorama . Fore . WHITE [EOL] [EOL] def _colored ( self , color , text ) : [EOL] return [string] . format ( color , text , colorama . Style . RESET_ALL ) [EOL] [EOL] def formatMessage ( self , record ) : [comment] [EOL] if isinstance ( record , logging . LogRecord ) : [EOL] record . nice_levelname = self . _colored ( self . level_color_map [ record . levelname ] , [string] . format ( self . short_levelname_map [ record . levelname ] ) ) [EOL] [EOL] record . nice_name = self . _colored ( self . name_color , record . name ) [EOL] if hasattr ( record , [string] ) : [EOL] record . asctime = self . _colored ( self . asctime_color , record . asctime ) [EOL] [EOL] return self . _style . format ( record ) + colorama . Style . RESET_ALL [EOL] except ImportError : [EOL] pass [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[circle_core.logger.NiceColoredFormatter]$ 0 0 0 0 0 0 0 $typing.Type[circle_core.logger.NiceColoredFormatter]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from six import PY2 [EOL] [EOL] if PY2 : [EOL] [EOL] class abstractclassmethod ( classmethod ) : [EOL] [EOL] __isabstractmethod__ = True [EOL] [EOL] def __init__ ( self , callable ) : [EOL] callable . __isabstractmethod__ = True [EOL] super ( abstractclassmethod , self ) . __init__ ( callable ) [EOL] else : [EOL] from abc import abstractclassmethod [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from __future__ import absolute_import [EOL] [EOL] [EOL] class CircleCoreException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ConfigError ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class InconsitencyError ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class DatabaseMismatchError ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class MigrationError ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ModuleNotFoundError ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class MessageBoxNotFoundError ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class SchemaNotFoundError ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class SchemaNotMatchError ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class AuthorizationError ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class ReplicationError ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class JournalCorrupted ( CircleCoreException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class DatabaseWriteFailed ( CircleCoreException ) : [EOL] pass [EOL] [EOL] [EOL] class DatabaseConnectionLost ( DatabaseWriteFailed ) : [EOL] pass [EOL] [EOL] [EOL] class BadMessage ( CircleCoreException ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Type , Tuple [EOL] import typing [EOL] import builtins [EOL] import decimal [EOL] import uuid [EOL] import decimal [EOL] import os [EOL] import uuid [EOL] from typing import Any , Dict , NewType , Union [EOL] [EOL] UUIDLike = Union [ str , uuid . UUID ] [EOL] Path = Union [ str , os . PathLike ] [EOL] JSON = Dict [ str , Any ] [EOL] Payload = Dict [ str , Any ] [EOL] Timestamp = decimal . Decimal [EOL] Topic = NewType ( [string] , str ) [EOL] [EOL] [EOL] class BlobMetadata : [EOL] [comment] [EOL] source = ... [EOL] [comment] [EOL] content_type = ... [EOL] [comment] [EOL] datahash = ... [EOL] [EOL] def __init__ ( self , source , content_type , datahash ) : [EOL] self . source = source [EOL] self . content_type = content_type [EOL] self . datahash = datahash [EOL] [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Type[decimal.Decimal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $uuid.UUID$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $uuid.UUID$ 0 $uuid.UUID$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import json [EOL] from typing import Any , TYPE_CHECKING [EOL] [EOL] if TYPE_CHECKING : [EOL] from . message import ModuleMessage [EOL] from . types import BlobMetadata [EOL] [EOL] [EOL] def serialize ( obj ) : [EOL] return json . dumps ( obj , cls = CircleCoreEncoder , sort_keys = True ) [EOL] [EOL] [EOL] [comment] [EOL] class CircleCoreEncoder ( json . JSONEncoder ) : [EOL] [comment] [EOL] def default ( self , o ) : [EOL] from . message import ModuleMessage [EOL] from . types import BlobMetadata [EOL] [EOL] if isinstance ( o , ModuleMessage ) : [EOL] return self . serialize_modulemessage ( o ) [EOL] elif isinstance ( o , BlobMetadata ) : [EOL] return self . seriaze_blobmetadata ( o ) [EOL] [EOL] return super ( ) . default ( o ) [EOL] [EOL] def serialize_modulemessage ( self , o ) : [EOL] return { [string] : str ( o . timestamp ) , [string] : o . counter , [string] : o . payload , [string] : o . box_id . hex } [EOL] [EOL] def seriaze_blobmetadata ( self , o ) : [EOL] return { [string] : o . content_type , [string] : o . datahash , [string] : str ( o . source ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $'ModuleMessage'$ 0 0 0 0 0 0 0 0 0 $'ModuleMessage'$ 0 0 0 0 0 0 $'ModuleMessage'$ 0 0 0 0 0 $'ModuleMessage'$ 0 0 0 0 0 $'ModuleMessage'$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $'BlobMetadata'$ 0 0 0 0 0 0 0 $'BlobMetadata'$ 0 0 0 0 0 $'BlobMetadata'$ 0 0 0 0 0 0 0 $'BlobMetadata'$ 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , List , ItemsView , Any , DefaultDict [EOL] import typing [EOL] import threading [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] import threading [EOL] from collections import defaultdict [EOL] from typing import Dict [EOL] [EOL] import whisper [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] WHISPER_ARCHIVES_STRING = [string] . split ( [string] ) [EOL] WHISPER_ARCHIVES = [ whisper . parseRetentionDef ( d ) for d in WHISPER_ARCHIVES_STRING ] [EOL] [EOL] WHISPER_GLOBAL_LOCK = threading . Lock ( ) [EOL] WHISPER_GLOBAL_LOCKS = { } [EOL] [EOL] [EOL] def get_lock ( filepath ) : [EOL] with WHISPER_GLOBAL_LOCK : [EOL] if filepath not in WHISPER_GLOBAL_LOCKS : [EOL] WHISPER_GLOBAL_LOCKS [ filepath ] = threading . Lock ( ) [EOL] return WHISPER_GLOBAL_LOCKS [ filepath ] [EOL] [EOL] [EOL] class TimedDBBundle ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , dir_prefix ) : [EOL] self . dir_prefix = dir_prefix [EOL] [EOL] def update ( self , updates ) : [EOL] [docstring] [EOL] [comment] [EOL] sorted_updates = defaultdict ( lambda : defaultdict ( int ) ) [EOL] [EOL] [comment] [EOL] for box_id , timestamp in updates : [EOL] sorted_updates [ box_id ] [ int ( timestamp ) ] += [number] [EOL] [EOL] for box_id , timestamps in sorted_updates . items ( ) : [EOL] [comment] [EOL] [comment] [EOL] timestamps = timestamps . items ( ) [EOL] [EOL] db_path = os . path . join ( self . dir_prefix , TimedDB . make_db_name ( box_id ) ) [EOL] [EOL] if not os . path . exists ( db_path ) : [EOL] logger . info ( [string] , box_id , db_path ) [EOL] whisper . create ( db_path , WHISPER_ARCHIVES , xFilesFactor = [number] , aggregationMethod = [string] , sparse = False , useFallocate = True ) [EOL] [EOL] with get_lock ( db_path ) : [EOL] whisper . update_many ( db_path , timestamps ) [EOL] [EOL] def find_db ( self , box_id ) : [EOL] return TimedDB ( os . path . join ( self . dir_prefix , TimedDB . make_db_name ( box_id ) ) ) [EOL] [EOL] [EOL] class TimedDB ( object ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def make_db_name ( cls , box_id ) : [EOL] return [string] . format ( box_id ) [EOL] [EOL] def __init__ ( self , filepath ) : [EOL] self . filepath = filepath [EOL] [EOL] def fetch ( self , start_time , end_time ) : [EOL] try : [EOL] with get_lock ( self . filepath ) : [EOL] data = whisper . fetch ( self . filepath , start_time , end_time ) [EOL] except FileNotFoundError : [EOL] return None [EOL] [EOL] if not data : [EOL] return None [EOL] [EOL] ( start , end , step ) , values = data [EOL] [EOL] return start , end , step , values [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.DefaultDict[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.DefaultDict[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ItemsView[typing.Any,builtins.int]$ 0 $typing.DefaultDict[typing.Any,typing.DefaultDict[typing.Any,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.ItemsView[typing.Any,builtins.int]$ 0 $typing.ItemsView[typing.Any,builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.ItemsView[typing.Any,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional , List [EOL] import typing [EOL] import builtins [EOL] import uuid [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import uuid [EOL] from typing import Optional [EOL] [EOL] [comment] [EOL] from base58 import b58encode [EOL] [EOL] TOPIC_LENGTH = [number] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def make_topic ( topic ) : [EOL] [docstring] [EOL] assert isinstance ( topic , str ) [EOL] assert len ( topic ) < TOPIC_LENGTH [EOL] return topic . ljust ( TOPIC_LENGTH ) [EOL] [EOL] [EOL] def make_message_topic ( module_id = None , box_id = None ) : [EOL] [docstring] [EOL] assert module_id is None or isinstance ( module_id , uuid . UUID ) [EOL] assert box_id is None or isinstance ( box_id , uuid . UUID ) [EOL] [EOL] t = [ [string] ] [EOL] if module_id : [EOL] t . append ( b58encode ( module_id . bytes ) . decode ( [string] ) ) [EOL] if box_id : [EOL] t . append ( b58encode ( box_id . bytes ) . decode ( [string] ) ) [EOL] return make_topic ( [string] . join ( t ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple [EOL] import typing [EOL] [docstring] [EOL] [EOL] from . nanomsg import Receiver , Replier , Sender [EOL] from . topics import make_message_topic [EOL] [EOL] __all__ = ( [string] , [string] , [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Awaitable , Callable , TypeVar , Type , Any [EOL] import builtins [EOL] import typing [EOL] import circle_core [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import asyncio [EOL] import json [EOL] import logging [EOL] import typing [EOL] from typing import Awaitable , Callable , cast [EOL] [EOL] [comment] [EOL] import nnpy [EOL] [EOL] from tornado . ioloop import IOLoop [EOL] [EOL] [comment] [EOL] from . topics import TOPIC_LENGTH [EOL] [EOL] [comment] [EOL] if typing . TYPE_CHECKING : [EOL] pass [EOL] [EOL] __all__ = ( [string] , [string] , [string] , ) [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] RawMessage = typing . TypeVar ( [string] ) [EOL] ReplierCallback = Callable [ [ RawMessage , Exception ] , Awaitable [ None ] ] [EOL] [EOL] [EOL] class Receiver ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , socket_url , topic = None ) : [EOL] [docstring] [EOL] self . _socket = nnpy . Socket ( nnpy . AF_SP , nnpy . SUB ) [EOL] self . _socket . connect ( socket_url ) [EOL] if topic : [EOL] self . _socket . setsockopt ( nnpy . SUB , nnpy . SUB_SUBSCRIBE , topic . rstrip ( ) ) [EOL] self . topic = topic [EOL] [EOL] def __del__ ( self ) : [EOL] [docstring] [EOL] self . _socket . close ( ) [EOL] [EOL] def fileno ( self ) : [EOL] [docstring] [EOL] hoge = self . _socket . getsockopt ( nnpy . SOL_SOCKET , nnpy . RCVFD ) [EOL] return hoge [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] logger . debug ( [string] ) [EOL] self . _socket . close ( ) [EOL] [EOL] def set_timeout ( self , timeout ) : [EOL] [docstring] [EOL] self . _socket . setsockopt ( nnpy . SOL_SOCKET , nnpy . RCVTIMEO , timeout ) [EOL] [EOL] def register_ioloop ( self , callback ) : [EOL] [docstring] [EOL] [EOL] def call_callback_receiver ( * args ) : [EOL] [comment] [EOL] try : [EOL] raw = self . _socket . recv ( ) [EOL] plain_msg = raw . decode ( [string] ) [EOL] topic , message = plain_msg [ : TOPIC_LENGTH ] , plain_msg [ TOPIC_LENGTH : ] [EOL] message = json . loads ( message ) [EOL] rv = callback ( topic , message ) [EOL] [EOL] if asyncio . iscoroutine ( rv ) : [EOL] [comment] [EOL] asyncio . ensure_future ( rv ) [EOL] [EOL] except Exception : [EOL] import traceback [EOL] traceback . print_exc ( ) [EOL] [EOL] IOLoop . current ( ) . add_handler ( self , call_callback_receiver , IOLoop . READ ) [EOL] [EOL] [EOL] class Sender ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , socket_url ) : [EOL] [docstring] [EOL] self . _socket = nnpy . Socket ( nnpy . AF_SP , nnpy . PUB ) [EOL] self . _socket . bind ( socket_url ) [EOL] [comment] [EOL] [EOL] def __del__ ( self ) : [EOL] [docstring] [EOL] self . _socket . close ( ) [EOL] [EOL] def send ( self , payload ) : [EOL] [docstring] [EOL] self . _socket . send ( payload ) [EOL] [EOL] [EOL] class Replier ( object ) : [EOL] [EOL] def __init__ ( self , socket_url ) : [EOL] [docstring] [EOL] self . _socket = nnpy . Socket ( nnpy . AF_SP , nnpy . REP ) [EOL] self . _socket . bind ( socket_url ) [EOL] [comment] [EOL] [EOL] def __del__ ( self ) : [EOL] [docstring] [EOL] self . _socket . close ( ) [EOL] [EOL] def recv ( self ) : [EOL] [docstring] [EOL] raw = self . _socket . recv ( ) [EOL] return cast ( RawMessage , json . loads ( raw . decode ( [string] ) ) ) [EOL] [EOL] def send ( self , payload ) : [EOL] [docstring] [EOL] data = json . dumps ( payload ) [EOL] return self . _socket . send ( data . encode ( [string] ) ) [EOL] [EOL] def fileno ( self ) : [EOL] [docstring] [EOL] return self . _socket . getsockopt ( nnpy . SOL_SOCKET , nnpy . RCVFD ) [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] self . _socket . close ( ) [EOL] [EOL] def register_ioloop ( self , callback ) : [EOL] [docstring] [EOL] [EOL] def call_callback_replier ( * args ) : [EOL] try : [EOL] msg = self . recv ( ) [EOL] except Exception as exc : [EOL] [comment] [EOL] rv = callback ( None , exc ) [EOL] else : [EOL] [comment] [EOL] rv = callback ( msg , None ) [EOL] [EOL] if asyncio . iscoroutine ( rv ) : [EOL] [comment] [EOL] asyncio . ensure_future ( rv ) [EOL] [EOL] IOLoop . current ( ) . add_handler ( self , call_callback_replier , IOLoop . READ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RawMessage$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RawMessage$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $RawMessage$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ReplierCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[None]$ 0 0 0 0 0 0 0 0 0 $typing.Awaitable[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from alembic import op [EOL] [EOL] [comment] [EOL] revision = [string] [EOL] down_revision = [string] [EOL] branch_labels = None [EOL] depends_on = None [EOL] [EOL] [EOL] def upgrade ( ) : [EOL] [comment] [EOL] with op . batch_alter_table ( [string] , schema = None ) as batch_op : [EOL] batch_op . alter_column ( [string] , new_column_name = [string] ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def downgrade ( ) : [EOL] [comment] [EOL] with op . batch_alter_table ( [string] , schema = None ) as batch_op : [EOL] batch_op . alter_column ( [string] , new_column_name = [string] ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] from typing import List [EOL] import unittest [EOL] import typing [EOL] import circle_core [EOL] import uuid [EOL] import asyncio [EOL] import decimal [EOL] import json [EOL] import os [EOL] import uuid [EOL] from unittest . mock import MagicMock [EOL] [EOL] import pytest [EOL] [EOL] from circle_core . message import ModuleMessage [EOL] from circle_core . models import MessageBox , MetaDataSession , Module , Schema [EOL] from circle_core . testing import mock_circlecore_context [EOL] from circle_core . writer . journal_writer import JournalDBWriter , JournalReader [EOL] [EOL] [EOL] @ pytest . fixture ( ) def dummy_mbox ( ) : [EOL] print ( [string] ) [EOL] [EOL] with mock_circlecore_context ( ) : [EOL] [EOL] mbox_id = uuid . uuid4 ( ) [EOL] with MetaDataSession . begin ( ) : [EOL] schema = Schema . create ( display_name = [string] , properties = [string] ) [EOL] module = Module . create ( display_name = [string] ) [EOL] mbox = MessageBox ( uuid = mbox_id , schema_uuid = schema . uuid , module_uuid = module . uuid ) [EOL] MetaDataSession . add ( schema ) [EOL] MetaDataSession . add ( module ) [EOL] MetaDataSession . add ( mbox ) [EOL] [EOL] yield ( schema , module , mbox ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_journal_db_writer ( tmpdir , dummy_mbox , caplog ) : [EOL] schema , module , mbox = dummy_mbox [EOL] [EOL] import logging [EOL] caplog . set_level ( logging . DEBUG ) [EOL] [comment] [EOL] assert not os . listdir ( tmpdir ) [EOL] [EOL] [comment] [EOL] child_writer_mock = MagicMock ( ) [EOL] writer = JournalDBWriter ( child_writer_mock , tmpdir ) [EOL] [EOL] files = os . listdir ( tmpdir ) [EOL] assert [string] in files [EOL] assert open ( os . path . join ( tmpdir , [string] ) , [string] ) . read ( ) == [string] [EOL] [EOL] [comment] [EOL] message = ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [number] , [string] : [number] } ) [EOL] child_writer_mock . store . side_effect = asyncio . coroutine ( lambda * args , ** kwargs : True ) [EOL] await writer . store ( mbox , message ) [EOL] await asyncio . sleep ( [number] ) [EOL] await writer . close ( ) [EOL] del writer [EOL] [EOL] files = os . listdir ( tmpdir ) [EOL] assert [string] in files [EOL] assert [string] in files [EOL] [EOL] ln = open ( os . path . join ( tmpdir , [string] ) ) . read ( ) [EOL] assert ln . endswith ( [string] ) [EOL] assert ln and json . loads ( ln ) == { [string] : mbox . uuid . hex , [string] : [string] , [string] : [number] , [string] : { [string] : [number] , [string] : [number] } } [EOL] child_writer_mock . store . assert_called_once ( ) [EOL] checkpoint = [string] . format ( len ( ln ) ) [EOL] assert open ( os . path . join ( tmpdir , [string] ) ) . read ( ) == checkpoint [EOL] [EOL] [comment] [EOL] child_writer_mock . store . side_effect = asyncio . coroutine ( lambda * args , ** kwargs : False ) [EOL] [EOL] writer = JournalDBWriter ( child_writer_mock , tmpdir ) [EOL] [EOL] message = ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [number] , [string] : [number] } ) [EOL] await writer . store ( mbox , message ) [EOL] await asyncio . sleep ( [number] ) [EOL] await writer . close ( ) [EOL] del writer [EOL] [EOL] with open ( os . path . join ( tmpdir , [string] ) ) as fp : [EOL] ln = fp . readline ( ) [EOL] assert ln and json . loads ( ln ) == { [string] : mbox . uuid . hex , [string] : [string] , [string] : [number] , [string] : { [string] : [number] , [string] : [number] } } [EOL] [EOL] ln = fp . readline ( ) [EOL] assert ln and json . loads ( ln ) == { [string] : mbox . uuid . hex , [string] : [string] , [string] : [number] , [string] : { [string] : [number] , [string] : [number] } } [EOL] [EOL] print ( child_writer_mock . store . call_args ) [EOL] print ( child_writer_mock . store . call_args [ [number] ] ) [EOL] assert child_writer_mock . store . call_count == [number] [EOL] assert child_writer_mock . store . call_args [ [number] ] [ [number] ] . timestamp == decimal . Decimal ( [string] ) [EOL] assert open ( os . path . join ( tmpdir , [string] ) ) . read ( ) == checkpoint [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_journal_reader ( tmpdir ) : [EOL] pos_file_path = os . path . join ( tmpdir , [string] ) [EOL] [EOL] [comment] [EOL] with open ( os . path . join ( tmpdir , [string] ) , [string] ) as fp : [EOL] for x in range ( [number] ) : [EOL] fp . write ( [string] . format ( x ) ) [EOL] [EOL] with open ( os . path . join ( tmpdir , [string] ) , [string] ) as fp : [EOL] for x in range ( [number] , [number] ) : [EOL] fp . write ( [string] . format ( x ) ) [EOL] [EOL] assert not os . path . exists ( pos_file_path ) [EOL] reader = JournalReader ( os . path . join ( tmpdir , [string] ) ) [EOL] [EOL] [comment] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] assert os . path . exists ( pos_file_path ) [EOL] assert open ( pos_file_path ) . read ( ) == [string] [EOL] [EOL] [comment] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] assert open ( pos_file_path ) . read ( ) == [string] [EOL] assert open ( pos_file_path ) . read ( ) == [string] [EOL] [EOL] [comment] [EOL] try : [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] raise Exception [EOL] except Exception : [EOL] pass [EOL] assert open ( pos_file_path ) . read ( ) == [string] [EOL] [EOL] [comment] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] assert open ( pos_file_path ) . read ( ) == [string] [EOL] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] assert open ( pos_file_path ) . read ( ) == [string] [EOL] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] assert open ( pos_file_path ) . read ( ) == [string] [EOL] [EOL] [comment] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] assert open ( pos_file_path ) . read ( ) == [string] [EOL] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] async with reader . read ( ) as data : [EOL] assert data == [string] [EOL] async with reader . read ( ) as data : [EOL] assert data is None [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_rotate_journal ( tmpdir , dummy_mbox , caplog ) : [EOL] schema , module , mbox = dummy_mbox [EOL] [EOL] import logging [EOL] caplog . set_level ( logging . DEBUG ) [EOL] [EOL] [comment] [EOL] pos_file_path = os . path . join ( tmpdir , [string] ) [EOL] [EOL] for log_index in range ( [number] ) : [EOL] log_file_path = os . path . join ( tmpdir , [string] . format ( log_index ) ) [EOL] with open ( log_file_path , [string] ) as fp : [EOL] for x in range ( [number] ) : [EOL] fp . write ( [string] . format ( x ) ) [EOL] [EOL] with open ( pos_file_path , [string] ) as fp : [EOL] log_file_path = os . path . join ( tmpdir , [string] . format ( log_index ) ) [EOL] fp . write ( [string] . format ( log_index , os . stat ( log_file_path ) . st_size ) ) [EOL] [EOL] before_files = os . listdir ( tmpdir ) [EOL] assert len ( before_files ) == [number] [EOL] [EOL] [comment] [EOL] child_writer_mock = MagicMock ( ) [EOL] child_writer_mock . store . side_effect = asyncio . coroutine ( lambda * args , ** kwargs : True ) [EOL] writer = JournalDBWriter ( child_writer_mock , tmpdir , max_log_file_size = [number] ) [EOL] [EOL] message = ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [number] , [string] : [number] } ) [EOL] await writer . store ( mbox , message ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] after_files = os . listdir ( tmpdir ) [EOL] [EOL] print ( before_files ) [EOL] print ( after_files ) [EOL] [EOL] after_files . sort ( ) [EOL] assert after_files == [ [string] , [string] ] [EOL] [EOL] await writer . close ( ) [EOL] del writer [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import asyncio [EOL] import typing [EOL] import circle_core [EOL] import uuid [EOL] import asyncio [EOL] import uuid [EOL] [EOL] import pytest [EOL] [EOL] from sqlalchemy . sql . expression import select [EOL] [EOL] from circle_core . database import Database [EOL] from circle_core . message import ModuleMessage [EOL] from circle_core . models import MessageBox , MetaDataSession , Module , Schema [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_post_date ( mysql , mock_circlecore ) : [EOL] mbox_id = uuid . uuid4 ( ) [EOL] with MetaDataSession . begin ( ) : [EOL] schema = Schema . create ( display_name = [string] , properties = [string] ) [EOL] module = Module . create ( display_name = [string] ) [EOL] mbox = MessageBox ( uuid = mbox_id , schema_uuid = schema . uuid , module_uuid = module . uuid ) [EOL] MetaDataSession . add ( schema ) [EOL] MetaDataSession . add ( module ) [EOL] MetaDataSession . add ( mbox ) [EOL] [EOL] envdir = mock_circlecore [ [number] ] [EOL] database = Database ( mysql . url , time_db_dir = envdir , log_dir = envdir ) [EOL] journal_writer = database . make_writer ( ) [EOL] queued_writer = journal_writer . child_writer [EOL] run_loop = asyncio . ensure_future ( journal_writer . run ( ) ) [EOL] [EOL] [comment] [EOL] message = ModuleMessage ( mbox . uuid , [number] , [number] , { [string] : [string] , [string] : [number] } ) [EOL] await queued_writer . store ( mbox , message ) [EOL] await queued_writer . flush ( ) [EOL] [EOL] [comment] [EOL] await journal_writer . close ( ) [EOL] await run_loop [EOL] [EOL] with database . _engine . begin ( ) as connection : [EOL] table = database . find_table_for_message_box ( mbox ) [EOL] rows = connection . execute ( select ( [ table ] ) ) . fetchall ( ) [EOL] assert len ( rows ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Any , Generator [EOL] import email [EOL] import typing [EOL] import unittest [EOL] import circle_core [EOL] import base64 [EOL] import json [EOL] import mimetypes [EOL] import os [EOL] from email . message import EmailMessage [EOL] from unittest . mock import MagicMock [EOL] [EOL] from tornado import httpclient [EOL] from tornado . gen import sleep [EOL] from tornado . testing import AsyncHTTPTestCase , gen_test [EOL] from tornado . web import Application [EOL] from tornado . websocket import websocket_connect [EOL] [EOL] from circle_core . models import MessageBox , MetaDataSession , Module , Schema , User [EOL] from circle_core . testing import mock_circlecore_context [EOL] from circle_core . workers . http import ModuleEventHandler [EOL] [EOL] [EOL] async def _receive_new_message_side_effect ( * args , ** kwargs ) : [EOL] return True [EOL] [EOL] [EOL] class TestModuleEventHandlerBase ( AsyncHTTPTestCase ) : [EOL] [EOL] def get_app ( self ) : [EOL] return Application ( [ ( [string] , ModuleEventHandler ) ] , _core = self . app_mock ) [EOL] [EOL] def setUp ( self ) : [EOL] self . app_mock = MagicMock ( ) [EOL] self . datareceiver = MagicMock ( ) [EOL] self . datareceiver . receive_new_message . return_value = True [EOL] self . datareceiver . receive_new_message . side_effect = _receive_new_message_side_effect [EOL] self . app_mock . get_datareceiver . return_value = self . datareceiver [EOL] [EOL] super ( ) . setUp ( ) [EOL] [EOL] self . ctxt = mock_circlecore_context ( ) [EOL] self . ctxt . __enter__ ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . ctxt . __exit__ ( None , None , None ) [EOL] [EOL] super ( ) . tearDown ( ) [EOL] [EOL] def reset_mock ( self ) : [EOL] self . datareceiver . reset_mock ( ) [EOL] self . datareceiver . receive_new_message . side_effect = _receive_new_message_side_effect [EOL] [EOL] [EOL] class TestModuleEventHandlerViaREST ( TestModuleEventHandlerBase ) : [EOL] [EOL] def test_rest_not_found ( self ) : [EOL] [docstring] [EOL] with MetaDataSession . begin ( ) : [EOL] user = User . create ( account = [string] , password = [string] ) [EOL] user . renew_token ( ) [EOL] [EOL] MetaDataSession . add ( user ) [EOL] [EOL] response = self . fetch ( self . get_url ( [string] ) , method = [string] , body = json . dumps ( { [string] : [number] , [string] : [number] } ) , headers = { [string] : [string] , [string] : [string] . format ( token = user . encoded_token ) , } ) [EOL] self . assertEqual ( response . code , [number] ) [EOL] [EOL] def test_rest ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] with MetaDataSession . begin ( ) : [EOL] user = User . create ( account = [string] , password = [string] ) [EOL] user . renew_token ( ) [EOL] schema = Schema . create ( display_name = [string] , properties = [string] ) [EOL] module = Module . create ( display_name = [string] ) [EOL] mbox = MessageBox ( uuid = [string] , schema_uuid = schema . uuid , module_uuid = module . uuid ) [EOL] MetaDataSession . add ( user ) [EOL] MetaDataSession . add ( schema ) [EOL] MetaDataSession . add ( module ) [EOL] MetaDataSession . add ( mbox ) [EOL] [EOL] response = self . fetch ( self . get_url ( [string] . format ( module . uuid , mbox . uuid ) ) , method = [string] , body = json . dumps ( { [string] : [number] , [string] : [number] } ) , headers = { [string] : [string] , [string] : [string] . format ( token = user . encoded_token ) , } ) [EOL] self . assertEqual ( response . code , [number] ) [EOL] self . datareceiver . receive_new_message . assert_called_once_with ( str ( mbox . uuid ) , { [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_rest_with_data ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] with MetaDataSession . begin ( ) : [EOL] user = User . create ( account = [string] , password = [string] ) [EOL] user . renew_token ( ) [EOL] schema = Schema . create ( display_name = [string] , properties = [string] ) [EOL] module = Module . create ( display_name = [string] ) [EOL] mbox = MessageBox ( uuid = [string] , schema_uuid = schema . uuid , module_uuid = module . uuid ) [EOL] MetaDataSession . add ( user ) [EOL] MetaDataSession . add ( schema ) [EOL] MetaDataSession . add ( module ) [EOL] MetaDataSession . add ( mbox ) [EOL] [EOL] async def _async_side_effect ( ) : [EOL] print ( [string] ) [EOL] return True [EOL] [EOL] [comment] [EOL] response = self . fetch ( self . get_url ( [string] . format ( module . uuid , mbox . uuid ) ) , method = [string] , body = json . dumps ( { [string] : [number] , [string] : [number] , [string] : encode_to_data ( * load_file ( [string] ) ) } ) , headers = { [string] : [string] , [string] : [string] . format ( token = user . encoded_token ) , } ) [EOL] self . assertEqual ( response . code , [number] ) [EOL] self . datareceiver . receive_new_message . assert_called_once ( ) [EOL] args , kwargs = self . datareceiver . receive_new_message . call_args [EOL] assert args [ [number] ] == str ( mbox . uuid ) [EOL] assert args [ [number] ] [ [string] ] == [number] [EOL] assert args [ [number] ] [ [string] ] == [number] [EOL] assert args [ [number] ] [ [string] ] . startswith ( [string] ) [EOL] [EOL] self . reset_mock ( ) [EOL] [EOL] [comment] [EOL] response = self . fetch ( self . get_url ( [string] . format ( module . uuid , mbox . uuid ) ) , method = [string] , body = json . dumps ( { [string] : [number] , [string] : [number] , [string] : [string] } ) , headers = { [string] : [string] , [string] : [string] . format ( token = user . encoded_token ) , } ) [EOL] self . assertEqual ( response . code , [number] ) [EOL] self . datareceiver . receive_new_message . assert_not_called ( ) [EOL] [EOL] self . reset_mock ( ) [EOL] [EOL] [comment] [EOL] body , headers = make_multipart_request ( [string] , json . dumps ( { [string] : [number] , [string] : [number] , [string] : [string] } ) , [string] ) [EOL] headers [ [string] ] = [string] . format ( token = user . encoded_token ) [EOL] response = self . fetch ( self . get_url ( [string] . format ( module . uuid , mbox . uuid ) ) , method = [string] , headers = headers , body = body , ) [EOL] self . assertEqual ( response . code , [number] ) [EOL] args , kwargs = self . datareceiver . receive_new_message . call_args [EOL] assert args [ [number] ] == str ( mbox . uuid ) [EOL] assert args [ [number] ] [ [string] ] == [number] [EOL] assert args [ [number] ] [ [string] ] == [number] [EOL] assert [string] in args [ [number] ] [EOL] [EOL] [EOL] def load_file ( filename ) : [EOL] path = os . path . join ( os . path . split ( __file__ ) [ [number] ] , filename ) [EOL] [EOL] type , encoding = mimetypes . guess_type ( path ) [EOL] [EOL] with open ( path , [string] ) as fp : [EOL] data = fp . read ( ) [EOL] [EOL] return type , encoding , data [EOL] [EOL] [EOL] def encode_to_data ( content_type , encoding , data ) : [EOL] return [string] . format ( content_type = content_type , charset = [string] . format ( encoding ) if encoding else [string] , encoded = base64 . b64encode ( data ) . decode ( [string] ) ) [EOL] [EOL] [EOL] def make_multipart_request ( content_type , mainbody , append_filename ) : [EOL] message = EmailMessage ( ) [EOL] [EOL] maintype , subtype = content_type . split ( [string] ) [EOL] message . set_content ( mainbody . encode ( [string] ) , maintype = maintype , subtype = subtype ) [EOL] [EOL] ct , enc , data = load_file ( append_filename ) [EOL] maintype , subtype = ct . split ( [string] ) [EOL] message . add_attachment ( data , maintype = maintype , subtype = subtype , filename = append_filename ) [EOL] [EOL] headerlines , body = message . as_string ( ) . split ( [string] , [number] ) [EOL] headers = { } [EOL] for ln in headerlines . split ( [string] ) : [EOL] k , v = ln . split ( [string] , [number] ) [EOL] headers [ k ] = v . lstrip ( ) [EOL] [EOL] return body , headers [EOL] [EOL] [EOL] class TestModuleEventHandlerViaWebsocket ( TestModuleEventHandlerBase ) : [EOL] [EOL] def get_protocol ( self ) : [EOL] return [string] [EOL] [EOL] @ gen_test ( timeout = [number] ) def test_websocket_auth_failed ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] with MetaDataSession . begin ( ) : [EOL] schema = Schema . create ( display_name = [string] , properties = [string] ) [EOL] module = Module . create ( display_name = [string] ) [EOL] mbox = MessageBox ( uuid = [string] , schema_uuid = schema . uuid , module_uuid = module . uuid ) [EOL] [EOL] MetaDataSession . add ( schema ) [EOL] MetaDataSession . add ( module ) [EOL] MetaDataSession . add ( mbox ) [EOL] [EOL] with self . assertRaises ( httpclient . HTTPClientError ) : [EOL] dummy_module = yield websocket_connect ( self . get_url ( [string] . format ( module . uuid , mbox . uuid ) ) ) [EOL] dummy_module . write_message ( json . dumps ( { [string] : [number] , [string] : [number] } ) ) [EOL] yield sleep ( [number] ) [EOL] self . datareceiver . receive_new_message . assert_not_called ( ) [EOL] [EOL] @ gen_test ( timeout = [number] ) def test_websocket_not_found ( self ) : [EOL] [docstring] [EOL] with MetaDataSession . begin ( ) : [EOL] user = User . create ( account = [string] , password = [string] ) [EOL] user . renew_token ( ) [EOL] [EOL] unknown_box = yield websocket_connect ( httpclient . HTTPRequest ( self . get_url ( [string] ) , headers = { [string] : [string] . format ( token = user . encoded_token ) , } ) ) [EOL] res = yield unknown_box . read_message ( ) [EOL] assert res is None [EOL] [EOL] @ gen_test ( timeout = [number] ) def test_websocket_pass_to_nanomsg ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] with MetaDataSession . begin ( ) : [EOL] user = User . create ( account = [string] , password = [string] ) [EOL] user . renew_token ( ) [EOL] schema = Schema . create ( display_name = [string] , properties = [string] ) [EOL] module = Module . create ( display_name = [string] ) [EOL] mbox = MessageBox ( uuid = [string] , schema_uuid = schema . uuid , module_uuid = module . uuid ) [EOL] [EOL] MetaDataSession . add ( user ) [EOL] MetaDataSession . add ( schema ) [EOL] MetaDataSession . add ( module ) [EOL] MetaDataSession . add ( mbox ) [EOL] [EOL] dummy_module = yield websocket_connect ( httpclient . HTTPRequest ( self . get_url ( [string] . format ( module . uuid , mbox . uuid ) ) , headers = { [string] : [string] . format ( token = user . encoded_token ) , } ) ) [EOL] dummy_module . write_message ( json . dumps ( { [string] : [number] , [string] : [number] } ) ) [EOL] [EOL] [comment] [EOL] yield sleep ( [number] ) [EOL] self . datareceiver . receive_new_message . assert_called_once_with ( [string] , { [string] : [number] , [string] : [number] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] import circle_core [EOL] from unittest . mock import DEFAULT , MagicMock , Mock [EOL] [EOL] import pytest [EOL] [EOL] from circle_core . database import Database [EOL] from circle_core . models import MessageBox , MetaDataSession , Module , Schema , generate_uuid [EOL] from circle_core . workers . blobstore import StoredBlob [EOL] from circle_core . workers . datareceiver import DataReceiverWorker [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . usefixtures ( [string] ) @ pytest . mark . usefixtures ( [string] ) async def test_datareceiver_store_blob ( mock_circlecore , mysql , monkeypatch ) : [EOL] metadata_db_engine , tmp_dir = mock_circlecore [EOL] [EOL] writer_mock = MagicMock ( ) [EOL] make_writer_mock = Mock ( name = [string] , return_value = writer_mock ) [EOL] [EOL] async def dummy_store ( * args , ** kwargs ) : [EOL] return DEFAULT [EOL] [EOL] writer_mock . store . side_effect = dummy_store [EOL] [EOL] monkeypatch . setattr ( Database , [string] , make_writer_mock ) [EOL] [EOL] [comment] [EOL] with MetaDataSession . begin ( ) : [EOL] schema = Schema . create ( display_name = [string] , properties = [string] ) [EOL] module = Module . create ( display_name = [string] ) [EOL] mbox = MessageBox ( uuid = generate_uuid ( model = MessageBox ) , schema_uuid = schema . uuid , module_uuid = module . uuid ) [EOL] [EOL] MetaDataSession . add ( schema ) [EOL] MetaDataSession . add ( module ) [EOL] MetaDataSession . add ( mbox ) [EOL] [EOL] core_mock = MagicMock ( ) [EOL] worker = DataReceiverWorker ( core_mock , [string] , db_url = mysql . url , time_db_dir = tmp_dir , log_dir = tmp_dir , cycle_time = [number] , cycle_count = [number] , ) [EOL] [EOL] datahash = ( [string] [string] ) [EOL] blobobj = StoredBlob ( None , [string] , datahash ) [EOL] await worker . receive_new_message ( mbox . uuid , { [string] : [number] , [string] : [number] , [string] : blobobj } ) [EOL] [EOL] publish_mock = core_mock . hub . publish [EOL] publish_mock . assert_called_once ( ) [EOL] message = publish_mock . call_args [ [number] ] [ [number] ] [EOL] assert message . payload [ [string] ] . content_type == [string] [EOL] assert message . payload [ [string] ] . datahash == datahash [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import typing [EOL] import subprocess [EOL] import os [EOL] import re [EOL] import subprocess [EOL] import sys [EOL] from time import sleep [EOL] from uuid import UUID [EOL] [EOL] from base58 import b58encode [EOL] [EOL] import pytest [EOL] [EOL] from sqlalchemy import create_engine [EOL] [EOL] import circle_core [EOL] [EOL] [EOL] def setup_module ( module ) : [EOL] terminate_crcr ( ) [EOL] [EOL] [EOL] def teardown_module ( module ) : [EOL] terminate_crcr ( ) [EOL] [EOL] [EOL] def terminate_crcr ( ) : [EOL] subprocess . run ( [string] , shell = True , check = True ) [EOL] [EOL] [EOL] @ pytest . yield_fixture def save_cwd ( ) : [EOL] saved = os . getcwd ( ) [EOL] try : [EOL] yield [EOL] finally : [EOL] os . chdir ( saved ) [EOL] [EOL] [EOL] def test_reproduce_missing_message ( tmpdir_factory , save_cwd , caplog ) : [EOL] master_dir = str ( tmpdir_factory . mktemp ( [string] ) ) [EOL] slave_dir = str ( tmpdir_factory . mktemp ( [string] ) ) [EOL] ipc_prefix = [string] [EOL] [EOL] [comment] [EOL] engine = create_engine ( [string] ) [EOL] engine . execute ( [string] ) [EOL] engine . execute ( [string] ) [EOL] engine . execute ( [string] ) [EOL] engine . execute ( [string] ) [EOL] [EOL] [comment] [EOL] master_db_url = [string] [EOL] slave_db_url = [string] [EOL] [EOL] counter_py = os . path . abspath ( os . path . join ( circle_core . __package__ , os . pardir , [string] , [string] ) ) [EOL] assert os . path . exists ( counter_py ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] os . chdir ( master_dir ) [EOL] with open ( [string] , [string] ) as config : [EOL] config . write ( [string] . format ( db_url = master_db_url , master_dir = master_dir , ipc_prefix = ipc_prefix ) ) [EOL] [EOL] result = subprocess . run ( [ [string] , [string] , [string] , [string] , [string] ] , check = True , stdout = subprocess . PIPE ) [EOL] module_uuid = re . search ( [string] , result . stdout . decode ( ) , re . MULTILINE ) . group ( [number] ) [EOL] [EOL] result = subprocess . run ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , check = True , stdout = subprocess . PIPE ) [EOL] schema_uuid = re . search ( [string] , result . stdout . decode ( ) , re . MULTILINE ) . group ( [number] ) [EOL] [EOL] [comment] [EOL] result = subprocess . run ( [ [string] , [string] , [string] , [string] , [string] , [string] , schema_uuid , [string] , module_uuid ] , check = True , stdout = subprocess . PIPE ) [EOL] box_uuid = re . search ( [string] , result . stdout . decode ( ) , re . MULTILINE ) . group ( [number] ) [EOL] table_name = [string] . format ( b58encode ( UUID ( box_uuid ) . bytes ) . decode ( [string] ) ) [EOL] [EOL] result = subprocess . run ( [ [string] , [string] , [string] , [string] , [string] , [string] ] , check = True , stdout = subprocess . PIPE ) [EOL] link_uuid = re . search ( [string] , result . stdout . decode ( ) , re . MULTILINE ) . group ( [number] ) [EOL] [EOL] [comment] [EOL] running_master = subprocess . Popen ( [ [string] , [string] , [string] ] ) [EOL] sleep ( [number] ) [EOL] [EOL] bot = subprocess . Popen ( [ sys . executable , counter_py , [string] , box_uuid , [string] , [string] . format ( ipc_prefix = ipc_prefix ) , [string] , [string] , [string] , ] , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] bot . wait ( timeout = [number] ) [EOL] except subprocess . TimeoutExpired : [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert ( create_engine ( master_db_url ) . connect ( ) . execute ( [string] . format ( table_name ) ) . fetchall ( ) ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] os . chdir ( slave_dir ) [EOL] [EOL] with open ( [string] , [string] ) as config : [EOL] config . write ( [string] . format ( db_url = slave_db_url , slave_dir = slave_dir , ipc_prefix = ipc_prefix ) ) [EOL] [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] , [string] . format ( link_uuid ) ] , check = True ) [EOL] [EOL] running_slave = subprocess . Popen ( [ [string] , [string] , [string] ] ) [EOL] [EOL] try : [EOL] bot . wait ( timeout = [number] ) [EOL] except subprocess . TimeoutExpired : [EOL] pass [EOL] else : [EOL] assert [number] , [string] [EOL] assert bot . returncode is None [EOL] [EOL] bot . terminate ( ) [EOL] sleep ( [number] ) [comment] [EOL] running_master . terminate ( ) [EOL] running_slave . terminate ( ) [EOL] [EOL] master_messages = frozenset ( tuple ( t ) for t in create_engine ( master_db_url ) . connect ( ) . execute ( [string] . format ( table_name ) ) . fetchall ( ) ) [EOL] slave_messages = frozenset ( tuple ( t ) for t in create_engine ( slave_db_url ) . connect ( ) . execute ( [string] . format ( table_name ) ) . fetchall ( ) ) [EOL] [EOL] assert master_messages == slave_messages , [string] . format ( sorted ( master_messages - slave_messages ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import unittest [EOL] import typing [EOL] import circle_core [EOL] from unittest . mock import DEFAULT , MagicMock , Mock [EOL] [EOL] import pytest [EOL] [EOL] from sqlalchemy . sql . expression import select [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from circle_core . constants import MasterCommand , ReplicationState [EOL] from circle_core . database import Database [EOL] from circle_core . models import CcInfo , MessageBox , MetaDataSession , Module , ReplicationMaster , Schema , generate_uuid [EOL] from circle_core . workers . slave_driver import SlaveDriverWorker [EOL] from circle_core . writer import QueuedDBWriter [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) @ pytest . mark . usefixtures ( [string] ) @ pytest . mark . asyncio async def test_replicate_blob ( mysql , mock_circlecore ) : [EOL] [docstring] [EOL] mock_cc = MagicMock ( ) [EOL] envdir = mock_circlecore [ [number] ] [EOL] [EOL] database = Database ( mysql . url , time_db_dir = envdir , log_dir = envdir ) [EOL] [EOL] with MetaDataSession . begin ( ) : [EOL] master_uuid = generate_uuid ( model = CcInfo ) [EOL] [EOL] [comment] [EOL] master_cc_info = CcInfo ( uuid = master_uuid , display_name = [string] , myself = False , work = [string] ) [EOL] replication_master = ReplicationMaster ( endpoint_url = [string] , info = master_cc_info ) [EOL] module = Module ( uuid = generate_uuid ( model = Module ) , cc_info = master_cc_info ) [EOL] schema = Schema . create ( cc_uuid = master_cc_info . uuid , display_name = [string] , properties = [string] ) [EOL] box = MessageBox ( uuid = generate_uuid ( model = MessageBox ) , schema = schema , module = module , display_name = [string] ) [EOL] [EOL] MetaDataSession . add ( master_cc_info ) [EOL] MetaDataSession . add ( replication_master ) [EOL] MetaDataSession . add ( module ) [EOL] MetaDataSession . add ( schema ) [EOL] MetaDataSession . add ( box ) [EOL] [EOL] async def dummy_store ( * args ) : [EOL] return DEFAULT [EOL] [EOL] slave_dirver = SlaveDriverWorker ( mock_cc , [string] , False ) [EOL] slave_dirver . initialize ( ) [EOL] assert len ( slave_dirver . replicators ) == [number] [EOL] assert replication_master . id in slave_dirver . replicators [EOL] [EOL] replicator = slave_dirver . replicators [ replication_master . id ] [EOL] replicator . state = ReplicationState . SYNCING [EOL] replicator . target_boxes = { box . uuid : box } [EOL] replicator . ws = MagicMock ( ) [EOL] [EOL] writer = QueuedDBWriter ( database , envdir ) [EOL] replicator . writer = writer [EOL] [EOL] datahash = ( [string] [string] ) [EOL] replicator . ws . read_message = Mock ( side_effect = make_dummy_read_message ( [string] . format ( box_id = str ( box . uuid ) , datahash = datahash , source = master_cc_info . uuid ) ) ) [EOL] await replicator . wait_command ( ( MasterCommand . NEW_MESSAGE , ) ) [EOL] [EOL] replicator . ws . read_message . assert_called_once ( ) [EOL] [EOL] with database . _engine . begin ( ) as connection : [EOL] table = database . find_table_for_message_box ( box ) [EOL] rows = connection . execute ( select ( [ table . c . data ] ) ) . fetchall ( ) [EOL] [EOL] assert len ( rows ) == [number] [EOL] expected = [string] . format ( datahash = datahash , source = str ( master_cc_info . uuid ) ) [EOL] assert rows [ [number] ] [ [number] ] == expected [EOL] [EOL] [EOL] def make_dummy_read_message ( message ) : [EOL] [EOL] async def dummy ( ) : [EOL] return message [EOL] [EOL] return dummy [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] import circle_core [EOL] from unittest . mock import MagicMock [EOL] [EOL] from tornado . testing import AsyncHTTPTestCase [EOL] from tornado . web import Application , FallbackHandler [EOL] from tornado . wsgi import WSGIContainer [EOL] [EOL] from circle_core . models import MessageBox , MetaDataSession , Module , Schema , User [EOL] from circle_core . testing import mock_circlecore_context [EOL] from circle_core . web import create_app [EOL] [EOL] [EOL] class AdminWebBase ( AsyncHTTPTestCase ) : [EOL] [EOL] def get_app ( self ) : [EOL] self . flask_app = create_app ( self . app_mock , self . get_url ( [string] ) ) [EOL] return Application ( [ ( [string] , FallbackHandler , { [string] : WSGIContainer ( self . flask_app ) } ) ] , _core = self . app_mock ) [EOL] [EOL] def setUp ( self ) : [EOL] self . app_mock = MagicMock ( ) [EOL] [EOL] self . ctxt = mock_circlecore_context ( ) [EOL] self . ctxt . __enter__ ( ) [EOL] [EOL] super ( ) . setUp ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . ctxt . __exit__ ( None , None , None ) [EOL] [EOL] super ( ) . tearDown ( ) [EOL] [EOL] [EOL] class NiceTestSuite ( AdminWebBase ) : [EOL] [EOL] def test_moge ( self ) : [EOL] [docstring] [EOL] with MetaDataSession . begin ( ) : [EOL] user = User . create ( account = [string] , password = [string] ) [EOL] user . renew_token ( ) [EOL] schema = Schema . create ( display_name = [string] , properties = [string] ) [EOL] module = Module . create ( display_name = [string] ) [EOL] mbox = MessageBox ( uuid = [string] , schema_uuid = schema . uuid , module_uuid = module . uuid ) [EOL] MetaDataSession . add ( user ) [EOL] MetaDataSession . add ( schema ) [EOL] MetaDataSession . add ( module ) [EOL] MetaDataSession . add ( mbox ) [EOL] [EOL] data_api_endpoint = self . get_url ( [string] . format ( module . uuid , mbox . uuid ) ) [EOL] [EOL] [comment] [EOL] response = self . fetch ( data_api_endpoint ) [EOL] assert response . code == [number] [EOL] [EOL] [comment] [EOL] response = self . fetch ( data_api_endpoint , headers = { [string] : [string] . format ( user . encoded_token ) } ) [EOL] assert response . code == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $circle_core.models.schema.Schema$ 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $circle_core.models.module.Module$ 0 0 0 $circle_core.models.message_box.MessageBox$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import click [EOL] import typing [EOL] from click . testing import CliRunner [EOL] [EOL] import pytest [EOL] [EOL] from circle_core . cli import cli_entry [EOL] from circle_core . testing import uuid_rex [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) class TestCliUser ( object ) : [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_user ( self ) : [EOL] runner = CliRunner ( ) [EOL] [EOL] def _call ( * args ) : [EOL] from circle_core . models import MetaDataSession [EOL] MetaDataSession . remove ( ) [EOL] return runner . invoke ( cli_entry , [ [string] , [string] ] + list ( args ) ) [EOL] [EOL] [comment] [EOL] result = _call ( [string] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] assert result . exit_code == [number] [EOL] mo = uuid_rex . search ( result . output ) [EOL] assert mo is None , result . output [EOL] [EOL] [comment] [EOL] result = _call ( [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] assert result . exit_code == [number] [EOL] mo = uuid_rex . search ( result . output ) [EOL] assert mo is not None , result . output [EOL] user_uuid = mo . group ( [number] ) [EOL] [EOL] [comment] [EOL] result = _call ( [string] , [string] ) [EOL] assert result . exit_code == [number] [EOL] assert user_uuid in result . output [EOL] [EOL] [comment] [EOL] result = _call ( [string] , [string] , user_uuid ) [EOL] assert result . exit_code == [number] [EOL] assert user_uuid in result . output [EOL] assert [string] in result . output [EOL] [EOL] [comment] [EOL] result = _call ( [string] , [string] , [string] ) [EOL] assert result . exit_code != [number] [EOL] [EOL] [comment] [EOL] result = _call ( [string] , [string] , user_uuid ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [comment] [EOL] result = _call ( [string] , [string] ) [EOL] assert result . exit_code == [number] [EOL] mo = uuid_rex . search ( result . output ) [EOL] assert mo is None , result . output [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.testing.CliRunner$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] from typing import Union , Dict , List , Any , DefaultDict [EOL] import click [EOL] import typing [EOL] import os [EOL] from collections import defaultdict [EOL] [EOL] [comment] [EOL] from click . testing import CliRunner [EOL] [EOL] import pytest [EOL] [EOL] [comment] [EOL] from circle_core . cli import cli_entry [EOL] from circle_core . testing import crcr_uuid [EOL] [EOL] [EOL] @ pytest . mark . skip class TestCliMain ( object ) : [EOL] [EOL] [comment] [EOL] @ pytest . mark . usefixtures ( [string] ) @ pytest . mark . parametrize ( ( [string] , [string] ) , [ ( [ ] , { [string] : - [number] , [string] : [ [string] , [string] , [string] ] } , ) , ( [ [string] , [string] ] , { [string] : - [number] , [string] : [ [string] [string] ] } , ) , ] ) [comment] [EOL] def test_main_env_failure ( self , main_params , expected ) : [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli_entry , main_params + [ [string] ] ) [EOL] assert result . exit_code == expected [ [string] ] [EOL] assert result . output == [string] . join ( expected [ [string] ] ) + [string] [EOL] [EOL] @ pytest . mark . parametrize ( ( [string] , [string] ) , [ ( [ [string] , [string] ] , { [string] : crcr_uuid , [string] : [string] } ) , ] ) def test_main_env_success ( self , main_param_uuid , expected ) : [EOL] [comment] [EOL] [EOL] metadata = os . environ [ [string] ] [EOL] main_params = [ [string] , metadata ] + main_param_uuid [EOL] runner = CliRunner ( ) [EOL] result = runner . invoke ( cli_entry , main_params + [ [string] ] ) [EOL] assert result . exit_code == [number] [EOL] assert result . output == [string] . join ( [ metadata , expected [ [string] ] , expected [ [string] ] ] ) + [string] [EOL] [EOL] def test_main_migrate_failure ( self , monkeypatch ) : [EOL] [docstring] [EOL] default_args = [ [string] , [string] . format ( os . getcwd ( ) ) , [string] ] [EOL] result = CliRunner ( ) . invoke ( cli_entry , default_args ) [EOL] assert result . exit_code != [number] [EOL] [EOL] @ pytest . mark . skip def test_main_migrate ( self , monkeypatch ) : [EOL] test_db_url = [string] [EOL] [comment] [EOL] call_result = { [string] : [ ] , [string] : defaultdict ( list ) , } [EOL] [EOL] class MockDatabase ( object ) : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] call_result [ [string] ] . append ( ( args , kwargs ) ) [EOL] [EOL] def __getattr__ ( self , key ) : [EOL] [EOL] def _f ( * args , ** kwargs ) : [EOL] call_result [ [string] ] [ key ] . append ( ( args , kwargs ) ) [EOL] [EOL] return _f [EOL] [EOL] import circle_core . cli . cli_main [EOL] monkeypatch . setattr ( circle_core . cli . cli_main , [string] , MockDatabase ) [EOL] [EOL] [comment] [EOL] default_args = [ [string] , [string] . format ( os . getcwd ( ) ) , [string] , [string] . format ( test_db_url ) ] [EOL] result = CliRunner ( ) . invoke ( cli_entry , default_args ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [comment] [EOL] assert call_result [ [string] ] [ [number] ] == ( ( test_db_url , ) , { } ) [EOL] [comment] [EOL] assert len ( call_result [ [string] ] [ [string] ] ) == [number] [EOL] [EOL] [comment] [EOL] call_result = { [string] : [ ] , [string] : defaultdict ( list ) , } [EOL] result = CliRunner ( ) . invoke ( cli_entry , default_args + [ [string] ] ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [comment] [EOL] assert call_result [ [string] ] [ [number] ] == ( ( test_db_url , ) , { } ) [EOL] [comment] [EOL] assert [string] in call_result [ [string] ] [EOL] assert [string] not in call_result [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.testing.CliRunner$ 0 0 0 0 0 $click.testing.Result$ 0 $click.testing.CliRunner$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $click.testing.CliRunner$ 0 0 0 0 0 $click.testing.Result$ 0 $click.testing.CliRunner$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.DefaultDict[typing.Any,typing.List[typing.Any]],typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.DefaultDict[typing.Any,typing.List[typing.Any]],typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.DefaultDict[typing.Any,typing.List[typing.Any]],typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.DefaultDict[typing.Any,typing.List[typing.Any]],typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $click.testing.Result$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.DefaultDict[typing.Any,typing.List[typing.Any]],typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.DefaultDict[typing.Any,typing.List[typing.Any]],typing.List[typing.Any]]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.DefaultDict[typing.Any,typing.List[typing.Any]],typing.List[typing.Any]]]$ 0 0 0 0