[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict , List [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] from unittest . mock import ANY , patch [EOL] [EOL] from homeassistant . setup import setup_component [EOL] import homeassistant . components . mqtt_eventstream as eventstream [EOL] from homeassistant . const import EVENT_STATE_CHANGED [EOL] from homeassistant . core import State , callback [EOL] from homeassistant . helpers . json import JSONEncoder [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] from tests . common import ( get_test_home_assistant , mock_mqtt_component , fire_mqtt_message , mock_state_change_event , fire_time_changed ) [EOL] [EOL] [EOL] class TestMqttEventStream : [EOL] [docstring] [EOL] [EOL] def setup_method ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . mock_mqtt = mock_mqtt_component ( self . hass ) [EOL] [EOL] def teardown_method ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def add_eventstream ( self , sub_topic = None , pub_topic = None , ignore_event = None ) : [EOL] [docstring] [EOL] config = { } [EOL] if sub_topic : [EOL] config [ [string] ] = sub_topic [EOL] if pub_topic : [EOL] config [ [string] ] = pub_topic [EOL] if ignore_event : [EOL] config [ [string] ] = ignore_event [EOL] return setup_component ( self . hass , eventstream . DOMAIN , { eventstream . DOMAIN : config } ) [EOL] [EOL] def test_setup_succeeds ( self ) : [EOL] [docstring] [EOL] assert self . add_eventstream ( ) [EOL] [EOL] def test_setup_with_pub ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] assert self . hass . bus . listeners . get ( [string] ) is None [EOL] [EOL] assert self . add_eventstream ( pub_topic = [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . bus . listeners . get ( [string] ) == [number] [EOL] [EOL] @ patch ( [string] ) def test_subscribe ( self , mock_sub ) : [EOL] [docstring] [EOL] sub_topic = [string] [EOL] assert self . add_eventstream ( sub_topic = sub_topic ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] mock_sub . assert_called_with ( self . hass , sub_topic , ANY ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_state_changed_event_sends_message ( self , mock_utcnow , mock_pub ) : [EOL] [docstring] [EOL] now = dt_util . as_utc ( dt_util . now ( ) ) [EOL] e_id = [string] [EOL] pub_topic = [string] [EOL] mock_utcnow . return_value = now [EOL] [EOL] [comment] [EOL] assert self . add_eventstream ( pub_topic = pub_topic ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . reset_mock ( ) [EOL] [EOL] [comment] [EOL] mock_state_change_event ( self . hass , State ( e_id , [string] ) ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . assert_called_with ( self . hass , pub_topic , ANY ) [EOL] assert mock_pub . called [EOL] [EOL] [comment] [EOL] [comment] [EOL] msg = mock_pub . call_args [ [number] ] [ [number] ] [EOL] event = { } [EOL] event [ [string] ] = EVENT_STATE_CHANGED [EOL] new_state = { [string] : now . isoformat ( ) , [string] : [string] , [string] : e_id , [string] : { } , [string] : now . isoformat ( ) , } [EOL] event [ [string] ] = { [string] : new_state , [string] : e_id } [EOL] [EOL] [comment] [EOL] result = json . loads ( msg ) [EOL] result [ [string] ] [ [string] ] . pop ( [string] ) [EOL] assert result == event [EOL] [EOL] @ patch ( [string] ) def test_time_event_does_not_send_message ( self , mock_pub ) : [EOL] [docstring] [EOL] assert self . add_eventstream ( pub_topic = [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . reset_mock ( ) [EOL] [EOL] fire_time_changed ( self . hass , dt_util . utcnow ( ) ) [EOL] assert not mock_pub . called [EOL] [EOL] def test_receiving_remote_event_fires_hass_event ( self ) : [EOL] [docstring] [EOL] sub_topic = [string] [EOL] assert self . add_eventstream ( sub_topic = sub_topic ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] calls = [ ] [EOL] [EOL] @ callback def listener ( _ ) : [EOL] calls . append ( [number] ) [EOL] [EOL] self . hass . bus . listen_once ( [string] , listener ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] payload = json . dumps ( { [string] : [string] , [string] : { } } , cls = JSONEncoder ) [EOL] fire_mqtt_message ( self . hass , sub_topic , payload ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert [number] == len ( calls ) [EOL] [EOL] @ patch ( [string] ) def test_ignored_event_doesnt_send_over_stream ( self , mock_pub ) : [EOL] [docstring] [EOL] assert self . add_eventstream ( pub_topic = [string] , ignore_event = [ [string] ] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] e_id = [string] [EOL] event = { } [EOL] event [ [string] ] = EVENT_STATE_CHANGED [EOL] new_state = { [string] : [string] , [string] : e_id , [string] : { } , } [EOL] event [ [string] ] = { [string] : new_state , [string] : e_id } [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . reset_mock ( ) [EOL] [EOL] [comment] [EOL] mock_state_change_event ( self . hass , State ( e_id , [string] ) ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert not mock_pub . called [EOL] [EOL] @ patch ( [string] ) def test_wrong_ignored_event_sends_over_stream ( self , mock_pub ) : [EOL] [docstring] [EOL] assert self . add_eventstream ( pub_topic = [string] , ignore_event = [ [string] ] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] e_id = [string] [EOL] event = { } [EOL] event [ [string] ] = EVENT_STATE_CHANGED [EOL] new_state = { [string] : [string] , [string] : e_id , [string] : { } , } [EOL] event [ [string] ] = { [string] : new_state , [string] : e_id } [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . reset_mock ( ) [EOL] [EOL] [comment] [EOL] mock_state_change_event ( self . hass , State ( e_id , [string] ) ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert mock_pub . called [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from unittest . mock import patch [EOL] from tests . common import get_test_home_assistant , MockDependency [EOL] [EOL] from homeassistant . components import nuheat [EOL] [EOL] VALID_CONFIG = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } } [EOL] [EOL] [EOL] class TestNuHeat ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . config = VALID_CONFIG [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] ) def test_setup ( self , mocked_nuheat , mocked_load ) : [EOL] [docstring] [EOL] nuheat . setup ( self . hass , self . config ) [EOL] [EOL] mocked_nuheat . NuHeat . assert_called_with ( [string] , [string] ) [EOL] self . assertIn ( nuheat . DOMAIN , self . hass . data ) [EOL] self . assertEqual ( [number] , len ( self . hass . data [ nuheat . DOMAIN ] ) ) [EOL] self . assertIsInstance ( self . hass . data [ nuheat . DOMAIN ] [ [number] ] , type ( mocked_nuheat . NuHeat ( ) ) ) [EOL] self . assertEqual ( self . hass . data [ nuheat . DOMAIN ] [ [number] ] , [string] ) [EOL] [EOL] mocked_load . assert_called_with ( self . hass , [string] , nuheat . DOMAIN , { } , self . config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Union , List , Type , Tuple , Literal , Any , Dict [EOL] import typing [EOL] import unittest [EOL] import typing_extensions [EOL] import tests [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import MagicMock [EOL] [EOL] from homeassistant . components . remote import kira as kira [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] SERVICE_SEND_COMMAND = [string] [EOL] [EOL] TEST_CONFIG = { kira . DOMAIN : { [string] : [ { [string] : [string] , [string] : [number] } ] } } [EOL] [EOL] DISCOVERY_INFO = { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] class TestKiraSensor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] DEVICES = [ ] [EOL] [EOL] def add_entities ( self , devices ) : [EOL] [docstring] [EOL] for device in devices : [EOL] self . DEVICES . append ( device ) [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . mock_kira = MagicMock ( ) [EOL] self . hass . data [ kira . DOMAIN ] = { kira . CONF_REMOTE : { } } [EOL] self . hass . data [ kira . DOMAIN ] [ kira . CONF_REMOTE ] [ [string] ] = self . mock_kira [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_service_call ( self ) : [EOL] [docstring] [EOL] kira . setup_platform ( self . hass , TEST_CONFIG , self . add_entities , DISCOVERY_INFO ) [EOL] assert len ( self . DEVICES ) == [number] [EOL] remote = self . DEVICES [ [number] ] [EOL] [EOL] assert remote . name == [string] [EOL] [EOL] command = [ [string] ] [EOL] device = [string] [EOL] commandTuple = ( command [ [number] ] , device ) [EOL] remote . send_command ( device = device , command = command ) [EOL] [EOL] self . mock_kira . sendCode . assert_called_with ( commandTuple ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.str,typing_extensions.Literal]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing_extensions.Literal]$ 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Type [EOL] import typing [EOL] import tests [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] from collections import namedtuple [EOL] [EOL] from homeassistant . components import weather [EOL] from homeassistant . components . weather import ( ATTR_WEATHER_HUMIDITY , ATTR_WEATHER_PRESSURE , ATTR_WEATHER_TEMPERATURE , ATTR_WEATHER_WIND_BEARING , ATTR_WEATHER_WIND_SPEED ) [EOL] from homeassistant . util . unit_system import METRIC_SYSTEM [EOL] from homeassistant . setup import setup_component [EOL] [EOL] from tests . common import get_test_home_assistant , MockDependency [EOL] [EOL] [EOL] class MockStation ( ) : [EOL] [docstring] [EOL] [EOL] @ classmethod async def get ( cls , websession , lat , lon ) : [EOL] [docstring] [EOL] return MockStation ( ) [EOL] [EOL] async def observation ( self ) : [EOL] [docstring] [EOL] Observation = namedtuple ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] return Observation ( [number] , [number] , [number] , [string] , [number] , [number] , [string] ) [EOL] [EOL] async def forecast ( self ) : [EOL] [docstring] [EOL] Forecast = namedtuple ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] return [ Forecast ( [number] , [number] , [number] , [string] , [number] , [number] , - [number] , [string] , [number] , [number] , [string] ) ] [EOL] [EOL] @ property def local ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class TestIPMA ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . hass . config . units = METRIC_SYSTEM [EOL] self . lat = self . hass . config . latitude = [number] [EOL] self . lon = self . hass . config . longitude = - [number] [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = MockStation ) def test_setup ( self , mock_pyipma ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , weather . DOMAIN , { [string] : { [string] : [string] , [string] : [string] , } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( state . state , [string] ) [EOL] [EOL] data = state . attributes [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_TEMPERATURE ) , [number] ) [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_HUMIDITY ) , [number] ) [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_PRESSURE ) , [number] ) [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_WIND_SPEED ) , [number] ) [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_WIND_BEARING ) , [string] ) [EOL] self . assertEqual ( state . attributes . get ( [string] ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.components.weather.test_ipma.MockStation.observation.Observation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.components.weather.test_ipma.MockStation.observation.Observation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.components.weather.test_ipma.MockStation.forecast.Forecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.components.weather.test_ipma.MockStation.forecast.Forecast]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from homeassistant . components import vacuum [EOL] from homeassistant . components . vacuum import ( ATTR_BATTERY_LEVEL , ATTR_COMMAND , ATTR_ENTITY_ID , ATTR_FAN_SPEED , ATTR_FAN_SPEED_LIST , ATTR_PARAMS , ATTR_STATUS , DOMAIN , ENTITY_ID_ALL_VACUUMS , SERVICE_SEND_COMMAND , SERVICE_SET_FAN_SPEED , STATE_DOCKED , STATE_CLEANING , STATE_PAUSED , STATE_IDLE , STATE_RETURNING ) [EOL] from homeassistant . components . vacuum . demo import ( DEMO_VACUUM_BASIC , DEMO_VACUUM_COMPLETE , DEMO_VACUUM_MINIMAL , DEMO_VACUUM_MOST , DEMO_VACUUM_NONE , DEMO_VACUUM_STATE , FAN_SPEEDS ) [EOL] from homeassistant . const import ( ATTR_SUPPORTED_FEATURES , CONF_PLATFORM , STATE_OFF , STATE_ON ) [EOL] from homeassistant . setup import setup_component [EOL] from tests . common import get_test_home_assistant , mock_service [EOL] [EOL] [EOL] ENTITY_VACUUM_BASIC = [string] . format ( DOMAIN , DEMO_VACUUM_BASIC ) . lower ( ) [EOL] ENTITY_VACUUM_COMPLETE = [string] . format ( DOMAIN , DEMO_VACUUM_COMPLETE ) . lower ( ) [EOL] ENTITY_VACUUM_MINIMAL = [string] . format ( DOMAIN , DEMO_VACUUM_MINIMAL ) . lower ( ) [EOL] ENTITY_VACUUM_MOST = [string] . format ( DOMAIN , DEMO_VACUUM_MOST ) . lower ( ) [EOL] ENTITY_VACUUM_NONE = [string] . format ( DOMAIN , DEMO_VACUUM_NONE ) . lower ( ) [EOL] ENTITY_VACUUM_STATE = [string] . format ( DOMAIN , DEMO_VACUUM_STATE ) . lower ( ) [EOL] [EOL] [EOL] class TestVacuumDemo ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . assertTrue ( setup_component ( self . hass , DOMAIN , { DOMAIN : { CONF_PLATFORM : [string] } } ) ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_supported_features ( self ) : [EOL] [docstring] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertListEqual ( FAN_SPEEDS , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_MOST ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_MINIMAL ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_NONE ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertEqual ( None , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_SUPPORTED_FEATURES ) ) [EOL] self . assertEqual ( STATE_DOCKED , state . state ) [EOL] self . assertEqual ( [number] , state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] self . assertEqual ( [string] , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] self . assertListEqual ( FAN_SPEEDS , state . attributes . get ( ATTR_FAN_SPEED_LIST ) ) [EOL] [EOL] def test_methods ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( ENTITY_VACUUM_BASIC , STATE_ON ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_BASIC ) ) [EOL] [EOL] self . hass . states . set ( ENTITY_VACUUM_BASIC , STATE_OFF ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_BASIC ) ) [EOL] [EOL] self . hass . states . set ( ENTITY_ID_ALL_VACUUMS , STATE_ON ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass ) ) [EOL] [EOL] self . hass . states . set ( ENTITY_ID_ALL_VACUUMS , STATE_OFF ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass ) ) [EOL] [EOL] vacuum . turn_on ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . turn_off ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . toggle ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . start_pause ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . start_pause ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . stop ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertLess ( state . attributes . get ( ATTR_BATTERY_LEVEL ) , [number] ) [EOL] self . assertNotEqual ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . locate ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertIn ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . return_to_base ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertIn ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . set_fan_speed ( self . hass , FAN_SPEEDS [ - [number] ] , entity_id = ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertEqual ( FAN_SPEEDS [ - [number] ] , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] [EOL] vacuum . clean_spot ( self . hass , entity_id = ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] self . assertIn ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( STATE_ON , state . state ) [EOL] [EOL] vacuum . start ( self . hass , ENTITY_VACUUM_STATE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertEqual ( STATE_CLEANING , state . state ) [EOL] [EOL] vacuum . pause ( self . hass , ENTITY_VACUUM_STATE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertEqual ( STATE_PAUSED , state . state ) [EOL] [EOL] vacuum . stop ( self . hass , ENTITY_VACUUM_STATE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertEqual ( STATE_IDLE , state . state ) [EOL] [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertLess ( state . attributes . get ( ATTR_BATTERY_LEVEL ) , [number] ) [EOL] self . assertNotEqual ( STATE_DOCKED , state . state ) [EOL] [EOL] vacuum . return_to_base ( self . hass , ENTITY_VACUUM_STATE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertEqual ( STATE_RETURNING , state . state ) [EOL] [EOL] vacuum . set_fan_speed ( self . hass , FAN_SPEEDS [ - [number] ] , entity_id = ENTITY_VACUUM_STATE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertEqual ( FAN_SPEEDS [ - [number] ] , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] [EOL] vacuum . clean_spot ( self . hass , entity_id = ENTITY_VACUUM_STATE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertEqual ( STATE_CLEANING , state . state ) [EOL] [EOL] def test_unsupported_methods ( self ) : [EOL] [docstring] [EOL] self . hass . states . set ( ENTITY_VACUUM_NONE , STATE_ON ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . turn_off ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . stop ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] self . hass . states . set ( ENTITY_VACUUM_NONE , STATE_OFF ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . turn_on ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . toggle ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] [comment] [EOL] vacuum . start_pause ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_NONE ) ) [EOL] [EOL] vacuum . locate ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_NONE ) [EOL] self . assertIsNone ( state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . return_to_base ( self . hass , ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_NONE ) [EOL] self . assertIsNone ( state . attributes . get ( ATTR_STATUS ) ) [EOL] [EOL] vacuum . set_fan_speed ( self . hass , FAN_SPEEDS [ - [number] ] , entity_id = ENTITY_VACUUM_NONE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_NONE ) [EOL] self . assertNotEqual ( FAN_SPEEDS [ - [number] ] , state . attributes . get ( ATTR_FAN_SPEED ) ) [EOL] [EOL] vacuum . clean_spot ( self . hass , entity_id = ENTITY_VACUUM_BASIC ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] self . assertNotIn ( [string] , state . attributes . get ( ATTR_STATUS ) ) [EOL] self . assertEqual ( STATE_OFF , state . state ) [EOL] [EOL] [comment] [EOL] self . hass . states . set ( ENTITY_VACUUM_COMPLETE , STATE_ON ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . pause ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertTrue ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] self . hass . states . set ( ENTITY_VACUUM_COMPLETE , STATE_OFF ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] vacuum . start ( self . hass , ENTITY_VACUUM_COMPLETE ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertFalse ( vacuum . is_on ( self . hass , ENTITY_VACUUM_COMPLETE ) ) [EOL] [EOL] [comment] [EOL] vacuum . turn_on ( self . hass , entity_id = ENTITY_VACUUM_STATE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertNotEqual ( STATE_CLEANING , state . state ) [EOL] [EOL] vacuum . turn_off ( self . hass , entity_id = ENTITY_VACUUM_STATE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertNotEqual ( STATE_RETURNING , state . state ) [EOL] [EOL] vacuum . toggle ( self . hass , entity_id = ENTITY_VACUUM_STATE ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] self . assertNotEqual ( STATE_CLEANING , state . state ) [EOL] [EOL] def test_services ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] send_command_calls = mock_service ( self . hass , DOMAIN , SERVICE_SEND_COMMAND ) [EOL] [EOL] params = { [string] : [number] , [string] : [number] } [EOL] vacuum . send_command ( self . hass , [string] , entity_id = ENTITY_VACUUM_BASIC , params = params ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( send_command_calls ) ) [EOL] call = send_command_calls [ - [number] ] [EOL] [EOL] self . assertEqual ( DOMAIN , call . domain ) [EOL] self . assertEqual ( SERVICE_SEND_COMMAND , call . service ) [EOL] self . assertEqual ( ENTITY_VACUUM_BASIC , call . data [ ATTR_ENTITY_ID ] ) [EOL] self . assertEqual ( [string] , call . data [ ATTR_COMMAND ] ) [EOL] self . assertEqual ( params , call . data [ ATTR_PARAMS ] ) [EOL] [EOL] [comment] [EOL] set_fan_speed_calls = mock_service ( self . hass , DOMAIN , SERVICE_SET_FAN_SPEED ) [EOL] [EOL] vacuum . set_fan_speed ( self . hass , FAN_SPEEDS [ [number] ] , entity_id = ENTITY_VACUUM_COMPLETE ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( set_fan_speed_calls ) ) [EOL] call = set_fan_speed_calls [ - [number] ] [EOL] [EOL] self . assertEqual ( DOMAIN , call . domain ) [EOL] self . assertEqual ( SERVICE_SET_FAN_SPEED , call . service ) [EOL] self . assertEqual ( ENTITY_VACUUM_COMPLETE , call . data [ ATTR_ENTITY_ID ] ) [EOL] self . assertEqual ( FAN_SPEEDS [ [number] ] , call . data [ ATTR_FAN_SPEED ] ) [EOL] [EOL] def test_set_fan_speed ( self ) : [EOL] [docstring] [EOL] group_vacuums = [string] . join ( [ ENTITY_VACUUM_BASIC , ENTITY_VACUUM_COMPLETE , ENTITY_VACUUM_STATE ] ) [EOL] old_state_basic = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] old_state_complete = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] old_state_state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] [EOL] vacuum . set_fan_speed ( self . hass , FAN_SPEEDS [ [number] ] , entity_id = group_vacuums ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] new_state_basic = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] new_state_complete = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] new_state_state = self . hass . states . get ( ENTITY_VACUUM_STATE ) [EOL] [EOL] self . assertEqual ( old_state_basic , new_state_basic ) [EOL] self . assertNotIn ( ATTR_FAN_SPEED , new_state_basic . attributes ) [EOL] [EOL] self . assertNotEqual ( old_state_complete , new_state_complete ) [EOL] self . assertEqual ( FAN_SPEEDS [ [number] ] , old_state_complete . attributes [ ATTR_FAN_SPEED ] ) [EOL] self . assertEqual ( FAN_SPEEDS [ [number] ] , new_state_complete . attributes [ ATTR_FAN_SPEED ] ) [EOL] [EOL] self . assertNotEqual ( old_state_state , new_state_state ) [EOL] self . assertEqual ( FAN_SPEEDS [ [number] ] , old_state_state . attributes [ ATTR_FAN_SPEED ] ) [EOL] self . assertEqual ( FAN_SPEEDS [ [number] ] , new_state_state . attributes [ ATTR_FAN_SPEED ] ) [EOL] [EOL] def test_send_command ( self ) : [EOL] [docstring] [EOL] group_vacuums = [string] . join ( [ ENTITY_VACUUM_BASIC , ENTITY_VACUUM_COMPLETE ] ) [EOL] old_state_basic = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] old_state_complete = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] [EOL] vacuum . send_command ( self . hass , [string] , params = { [string] : [number] } , entity_id = group_vacuums ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] new_state_basic = self . hass . states . get ( ENTITY_VACUUM_BASIC ) [EOL] new_state_complete = self . hass . states . get ( ENTITY_VACUUM_COMPLETE ) [EOL] [EOL] self . assertEqual ( old_state_basic , new_state_basic ) [EOL] self . assertNotEqual ( old_state_complete , new_state_complete ) [EOL] self . assertEqual ( STATE_ON , new_state_complete . state ) [EOL] self . assertEqual ( [string] , new_state_complete . attributes [ ATTR_STATUS ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] from libpurecoollink . dyson_360_eye import Dyson360Eye [EOL] from libpurecoollink . const import Dyson360EyeMode , PowerMode [EOL] [EOL] from homeassistant . components . vacuum import dyson [EOL] from homeassistant . components . vacuum . dyson import Dyson360EyeDevice [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] def _get_non_vacuum_device ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( ) [EOL] device . name = [string] [EOL] device . state = None [EOL] return device [EOL] [EOL] [EOL] def _get_vacuum_device_cleaning ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( spec = Dyson360Eye ) [EOL] device . name = [string] [EOL] device . state = mock . MagicMock ( ) [EOL] device . state . state = Dyson360EyeMode . FULL_CLEAN_RUNNING [EOL] device . state . battery_level = [number] [EOL] device . state . power_mode = PowerMode . QUIET [EOL] device . state . position = ( [number] , [number] ) [EOL] return device [EOL] [EOL] [EOL] def _get_vacuum_device_charging ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( spec = Dyson360Eye ) [EOL] device . name = [string] [EOL] device . state = mock . MagicMock ( ) [EOL] device . state . state = Dyson360EyeMode . INACTIVE_CHARGING [EOL] device . state . battery_level = [number] [EOL] device . state . power_mode = PowerMode . QUIET [EOL] device . state . position = ( [number] , [number] ) [EOL] return device [EOL] [EOL] [EOL] def _get_vacuum_device_pause ( ) : [EOL] [docstring] [EOL] device = mock . MagicMock ( spec = Dyson360Eye ) [EOL] device . name = [string] [EOL] device . state = mock . MagicMock ( ) [EOL] device . state . state = Dyson360EyeMode . FULL_CLEAN_PAUSED [EOL] device . state . battery_level = [number] [EOL] device . state . power_mode = PowerMode . QUIET [EOL] device . state . position = ( [number] , [number] ) [EOL] return device [EOL] [EOL] [EOL] def _get_vacuum_device_unknown_state ( ) : [EOL] [docstring] [EOL] device = mock . Mock ( spec = Dyson360Eye ) [EOL] device . name = [string] [EOL] device . state = mock . MagicMock ( ) [EOL] device . state . state = [string] [EOL] return device [EOL] [EOL] [EOL] class DysonTest ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_component_with_no_devices ( self ) : [EOL] [docstring] [EOL] self . hass . data [ dyson . DYSON_DEVICES ] = [ ] [EOL] add_entities = mock . MagicMock ( ) [EOL] dyson . setup_platform ( self . hass , { } , add_entities ) [EOL] add_entities . assert_called_with ( [ ] ) [EOL] [EOL] def test_setup_component ( self ) : [EOL] [docstring] [EOL] def _add_device ( devices ) : [EOL] assert len ( devices ) == [number] [EOL] assert devices [ [number] ] . name == [string] [EOL] [EOL] device_vacuum = _get_vacuum_device_cleaning ( ) [EOL] device_non_vacuum = _get_non_vacuum_device ( ) [EOL] self . hass . data [ dyson . DYSON_DEVICES ] = [ device_vacuum , device_non_vacuum ] [EOL] dyson . setup_platform ( self . hass , { } , _add_device ) [EOL] [EOL] def test_on_message ( self ) : [EOL] [docstring] [EOL] device = _get_vacuum_device_cleaning ( ) [EOL] component = Dyson360EyeDevice ( device ) [EOL] component . entity_id = [string] [EOL] component . schedule_update_ha_state = mock . Mock ( ) [EOL] component . on_message ( mock . Mock ( ) ) [EOL] self . assertTrue ( component . schedule_update_ha_state . called ) [EOL] [EOL] def test_should_poll ( self ) : [EOL] [docstring] [EOL] device = _get_vacuum_device_cleaning ( ) [EOL] component = Dyson360EyeDevice ( device ) [EOL] self . assertFalse ( component . should_poll ) [EOL] [EOL] def test_properties ( self ) : [EOL] [docstring] [EOL] device1 = _get_vacuum_device_cleaning ( ) [EOL] device2 = _get_vacuum_device_unknown_state ( ) [EOL] device3 = _get_vacuum_device_charging ( ) [EOL] component = Dyson360EyeDevice ( device1 ) [EOL] component2 = Dyson360EyeDevice ( device2 ) [EOL] component3 = Dyson360EyeDevice ( device3 ) [EOL] self . assertEqual ( component . name , [string] ) [EOL] self . assertTrue ( component . is_on ) [EOL] self . assertEqual ( component . status , [string] ) [EOL] self . assertEqual ( component2 . status , [string] ) [EOL] self . assertEqual ( component . battery_level , [number] ) [EOL] self . assertEqual ( component . fan_speed , [string] ) [EOL] self . assertEqual ( component . fan_speed_list , [ [string] , [string] ] ) [EOL] self . assertEqual ( component . device_state_attributes [ [string] ] , [string] ) [EOL] self . assertTrue ( component . available ) [EOL] self . assertEqual ( component . supported_features , [number] ) [EOL] self . assertEqual ( component . battery_icon , [string] ) [EOL] self . assertEqual ( component3 . battery_icon , [string] ) [EOL] [EOL] def test_turn_on ( self ) : [EOL] [docstring] [EOL] device1 = _get_vacuum_device_charging ( ) [EOL] component1 = Dyson360EyeDevice ( device1 ) [EOL] component1 . turn_on ( ) [EOL] self . assertTrue ( device1 . start . called ) [EOL] [EOL] device2 = _get_vacuum_device_pause ( ) [EOL] component2 = Dyson360EyeDevice ( device2 ) [EOL] component2 . turn_on ( ) [EOL] self . assertTrue ( device2 . resume . called ) [EOL] [EOL] def test_turn_off ( self ) : [EOL] [docstring] [EOL] device1 = _get_vacuum_device_cleaning ( ) [EOL] component1 = Dyson360EyeDevice ( device1 ) [EOL] component1 . turn_off ( ) [EOL] self . assertTrue ( device1 . pause . called ) [EOL] [EOL] def test_stop ( self ) : [EOL] [docstring] [EOL] device1 = _get_vacuum_device_cleaning ( ) [EOL] component1 = Dyson360EyeDevice ( device1 ) [EOL] component1 . stop ( ) [EOL] self . assertTrue ( device1 . pause . called ) [EOL] [EOL] def test_set_fan_speed ( self ) : [EOL] [docstring] [EOL] device1 = _get_vacuum_device_cleaning ( ) [EOL] component1 = Dyson360EyeDevice ( device1 ) [EOL] component1 . set_fan_speed ( [string] ) [EOL] device1 . set_power_mode . assert_called_with ( PowerMode . MAX ) [EOL] [EOL] def test_start_pause ( self ) : [EOL] [docstring] [EOL] device1 = _get_vacuum_device_charging ( ) [EOL] component1 = Dyson360EyeDevice ( device1 ) [EOL] component1 . start_pause ( ) [EOL] self . assertTrue ( device1 . start . called ) [EOL] [EOL] device2 = _get_vacuum_device_pause ( ) [EOL] component2 = Dyson360EyeDevice ( device2 ) [EOL] component2 . start_pause ( ) [EOL] self . assertTrue ( device2 . resume . called ) [EOL] [EOL] device3 = _get_vacuum_device_cleaning ( ) [EOL] component3 = Dyson360EyeDevice ( device3 ) [EOL] component3 . start_pause ( ) [EOL] self . assertTrue ( device3 . pause . called ) [EOL] [EOL] def test_return_to_base ( self ) : [EOL] [docstring] [EOL] device = _get_vacuum_device_pause ( ) [EOL] component = Dyson360EyeDevice ( device ) [EOL] component . return_to_base ( ) [EOL] self . assertTrue ( device . abort . called ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import json [EOL] from unittest . mock import patch , MagicMock , mock_open [EOL] from aiohttp . hdrs import AUTHORIZATION [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] from homeassistant . components . notify import html5 [EOL] [EOL] CONFIG_FILE = [string] [EOL] [EOL] SUBSCRIPTION_1 = { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } } , } [EOL] SUBSCRIPTION_2 = { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , } , } [EOL] SUBSCRIPTION_3 = { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , } , } [EOL] SUBSCRIPTION_4 = { [string] : [string] , [string] : { [string] : [string] , [string] : None , [string] : { [string] : [string] , [string] : [string] } } , } [EOL] [EOL] REGISTER_URL = [string] [EOL] PUBLISH_URL = [string] [EOL] [EOL] [EOL] async def mock_client ( hass , aiohttp_client , registrations = None ) : [EOL] [docstring] [EOL] if registrations is None : [EOL] registrations = { } [EOL] [EOL] with patch ( [string] , return_value = registrations ) : [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] } } ) [EOL] [EOL] return await aiohttp_client ( hass . http . app ) [EOL] [EOL] [EOL] class TestHtml5Notify : [EOL] [docstring] [EOL] [EOL] def test_get_service_with_no_json ( self ) : [EOL] [docstring] [EOL] hass = MagicMock ( ) [EOL] [EOL] m = mock_open ( ) [EOL] with patch ( [string] , m , create = True ) : [EOL] service = html5 . get_service ( hass , { } ) [EOL] [EOL] assert service is not None [EOL] [EOL] @ patch ( [string] ) def test_sending_message ( self , mock_wp ) : [EOL] [docstring] [EOL] hass = MagicMock ( ) [EOL] [EOL] data = { [string] : SUBSCRIPTION_1 } [EOL] [EOL] m = mock_open ( read_data = json . dumps ( data ) ) [EOL] with patch ( [string] , m , create = True ) : [EOL] service = html5 . get_service ( hass , { [string] : [string] } ) [EOL] [EOL] assert service is not None [EOL] [EOL] service . send_message ( [string] , target = [ [string] , [string] ] , data = { [string] : [string] } ) [EOL] [EOL] assert len ( mock_wp . mock_calls ) == [number] [EOL] [EOL] [comment] [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] [ [number] ] == SUBSCRIPTION_1 [ [string] ] [EOL] [comment] [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] == [string] [EOL] [EOL] [comment] [EOL] payload = json . loads ( mock_wp . mock_calls [ [number] ] [ [number] ] [ [number] ] ) [EOL] [EOL] assert payload [ [string] ] == [string] [EOL] assert payload [ [string] ] == [string] [EOL] [EOL] @ patch ( [string] ) def test_gcm_key_include ( self , mock_wp ) : [EOL] [docstring] [EOL] hass = MagicMock ( ) [EOL] [EOL] data = { [string] : SUBSCRIPTION_1 , [string] : SUBSCRIPTION_2 } [EOL] [EOL] m = mock_open ( read_data = json . dumps ( data ) ) [EOL] with patch ( [string] , m , create = True ) : [EOL] service = html5 . get_service ( hass , { [string] : [string] , [string] : [string] } ) [EOL] [EOL] assert service is not None [EOL] [EOL] service . send_message ( [string] , target = [ [string] , [string] ] ) [EOL] [EOL] assert len ( mock_wp . mock_calls ) == [number] [EOL] [EOL] [comment] [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] [ [number] ] == SUBSCRIPTION_1 [ [string] ] [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] [ [number] ] == SUBSCRIPTION_2 [ [string] ] [EOL] [EOL] [comment] [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] == [string] [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] == [string] [EOL] [EOL] [comment] [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] [ [string] ] is not None [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] [ [string] ] is None [EOL] [EOL] [EOL] async def test_registering_new_device_view ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] client = await mock_client ( hass , aiohttp_client ) [EOL] [EOL] with patch ( [string] ) as mock_save : [EOL] resp = await client . post ( REGISTER_URL , data = json . dumps ( SUBSCRIPTION_1 ) ) [EOL] [EOL] assert resp . status == [number] [EOL] assert len ( mock_save . mock_calls ) == [number] [EOL] assert mock_save . mock_calls [ [number] ] [ [number] ] [ [number] ] == { [string] : SUBSCRIPTION_1 , } [EOL] [EOL] [EOL] async def test_registering_new_device_expiration_view ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] client = await mock_client ( hass , aiohttp_client ) [EOL] [EOL] with patch ( [string] ) as mock_save : [EOL] resp = await client . post ( REGISTER_URL , data = json . dumps ( SUBSCRIPTION_4 ) ) [EOL] [EOL] assert resp . status == [number] [EOL] assert mock_save . mock_calls [ [number] ] [ [number] ] [ [number] ] == { [string] : SUBSCRIPTION_4 , } [EOL] [EOL] [EOL] async def test_registering_new_device_fails_view ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] registrations = { } [EOL] client = await mock_client ( hass , aiohttp_client , registrations ) [EOL] [EOL] with patch ( [string] , side_effect = HomeAssistantError ( ) ) : [EOL] resp = await client . post ( REGISTER_URL , data = json . dumps ( SUBSCRIPTION_4 ) ) [EOL] [EOL] assert resp . status == [number] [EOL] assert registrations == { } [EOL] [EOL] [EOL] async def test_registering_existing_device_view ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] registrations = { } [EOL] client = await mock_client ( hass , aiohttp_client , registrations ) [EOL] [EOL] with patch ( [string] ) as mock_save : [EOL] await client . post ( REGISTER_URL , data = json . dumps ( SUBSCRIPTION_1 ) ) [EOL] resp = await client . post ( REGISTER_URL , data = json . dumps ( SUBSCRIPTION_4 ) ) [EOL] [EOL] assert resp . status == [number] [EOL] assert mock_save . mock_calls [ [number] ] [ [number] ] [ [number] ] == { [string] : SUBSCRIPTION_4 , } [EOL] assert registrations == { [string] : SUBSCRIPTION_4 , } [EOL] [EOL] [EOL] async def test_registering_existing_device_fails_view ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] registrations = { } [EOL] client = await mock_client ( hass , aiohttp_client , registrations ) [EOL] [EOL] with patch ( [string] ) as mock_save : [EOL] await client . post ( REGISTER_URL , data = json . dumps ( SUBSCRIPTION_1 ) ) [EOL] mock_save . side_effect = HomeAssistantError [EOL] resp = await client . post ( REGISTER_URL , data = json . dumps ( SUBSCRIPTION_4 ) ) [EOL] [EOL] assert resp . status == [number] [EOL] assert registrations == { [string] : SUBSCRIPTION_1 , } [EOL] [EOL] [EOL] async def test_registering_new_device_validation ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] client = await mock_client ( hass , aiohttp_client ) [EOL] [EOL] resp = await client . post ( REGISTER_URL , data = json . dumps ( { [string] : [string] , [string] : [string] , } ) ) [EOL] assert resp . status == [number] [EOL] [EOL] resp = await client . post ( REGISTER_URL , data = json . dumps ( { [string] : [string] , } ) ) [EOL] assert resp . status == [number] [EOL] [EOL] with patch ( [string] , return_value = False ) : [EOL] resp = await client . post ( REGISTER_URL , data = json . dumps ( { [string] : [string] , [string] : [string] , } ) ) [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] async def test_unregistering_device_view ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] registrations = { [string] : SUBSCRIPTION_1 , [string] : SUBSCRIPTION_2 , } [EOL] client = await mock_client ( hass , aiohttp_client , registrations ) [EOL] [EOL] with patch ( [string] ) as mock_save : [EOL] resp = await client . delete ( REGISTER_URL , data = json . dumps ( { [string] : SUBSCRIPTION_1 [ [string] ] , } ) ) [EOL] [EOL] assert resp . status == [number] [EOL] assert len ( mock_save . mock_calls ) == [number] [EOL] assert registrations == { [string] : SUBSCRIPTION_2 } [EOL] [EOL] [EOL] async def test_unregister_device_view_handle_unknown_subscription ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] registrations = { } [EOL] client = await mock_client ( hass , aiohttp_client , registrations ) [EOL] [EOL] with patch ( [string] ) as mock_save : [EOL] resp = await client . delete ( REGISTER_URL , data = json . dumps ( { [string] : SUBSCRIPTION_3 [ [string] ] } ) ) [EOL] [EOL] assert resp . status == [number] , resp . response [EOL] assert registrations == { } [EOL] assert len ( mock_save . mock_calls ) == [number] [EOL] [EOL] [EOL] async def test_unregistering_device_view_handles_save_error ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] registrations = { [string] : SUBSCRIPTION_1 , [string] : SUBSCRIPTION_2 , } [EOL] client = await mock_client ( hass , aiohttp_client , registrations ) [EOL] [EOL] with patch ( [string] , side_effect = HomeAssistantError ( ) ) : [EOL] resp = await client . delete ( REGISTER_URL , data = json . dumps ( { [string] : SUBSCRIPTION_1 [ [string] ] , } ) ) [EOL] [EOL] assert resp . status == [number] , resp . response [EOL] assert registrations == { [string] : SUBSCRIPTION_1 , [string] : SUBSCRIPTION_2 , } [EOL] [EOL] [EOL] async def test_callback_view_no_jwt ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] client = await mock_client ( hass , aiohttp_client ) [EOL] resp = await client . post ( PUBLISH_URL , data = json . dumps ( { [string] : [string] , [string] : [string] } ) ) [EOL] [EOL] assert resp . status == [number] , resp . response [EOL] [EOL] [EOL] async def test_callback_view_with_jwt ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] registrations = { [string] : SUBSCRIPTION_1 } [EOL] client = await mock_client ( hass , aiohttp_client , registrations ) [EOL] [EOL] with patch ( [string] ) as mock_wp : [EOL] await hass . services . async_call ( [string] , [string] , { [string] : [string] , [string] : [ [string] ] , [string] : { [string] : [string] } } , blocking = True ) [EOL] [EOL] assert len ( mock_wp . mock_calls ) == [number] [EOL] [EOL] [comment] [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] [ [number] ] == SUBSCRIPTION_1 [ [string] ] [EOL] [comment] [EOL] assert mock_wp . mock_calls [ [number] ] [ [number] ] == [string] [EOL] [EOL] [comment] [EOL] push_payload = json . loads ( mock_wp . mock_calls [ [number] ] [ [number] ] [ [number] ] ) [EOL] [EOL] assert push_payload [ [string] ] == [string] [EOL] assert push_payload [ [string] ] == [string] [EOL] [EOL] bearer_token = [string] . format ( push_payload [ [string] ] [ [string] ] ) [EOL] [EOL] resp = await client . post ( PUBLISH_URL , json = { [string] : [string] , } , headers = { AUTHORIZATION : bearer_token } ) [EOL] [EOL] assert resp . status == [number] [EOL] body = await resp . json ( ) [EOL] assert body == { [string] : [string] , [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from homeassistant . components . climate import zwave , STATE_COOL , STATE_HEAT [EOL] from homeassistant . const import ( STATE_OFF , TEMP_CELSIUS , TEMP_FAHRENHEIT , ATTR_TEMPERATURE ) [EOL] [EOL] from tests . mock . zwave import ( MockNode , MockValue , MockEntityValues , value_changed ) [EOL] [EOL] [EOL] @ pytest . fixture def device ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] values = MockEntityValues ( primary = MockValue ( data = [number] , node = node ) , temperature = MockValue ( data = [number] , node = node , units = None ) , mode = MockValue ( data = [string] , data_items = [ [number] , [number] , [number] ] , node = node ) , fan_mode = MockValue ( data = [string] , data_items = [ [number] , [number] , [number] ] , node = node ) , operating_state = MockValue ( data = [number] , node = node ) , fan_state = MockValue ( data = [number] , node = node ) , ) [EOL] device = zwave . get_device ( hass , node = node , values = values , node_config = { } ) [EOL] [EOL] yield device [EOL] [EOL] [EOL] @ pytest . fixture def device_zxt_120 ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( manufacturer_id = [string] , product_id = [string] ) [EOL] [EOL] values = MockEntityValues ( primary = MockValue ( data = [number] , node = node ) , temperature = MockValue ( data = [number] , node = node , units = None ) , mode = MockValue ( data = [string] , data_items = [ [number] , [number] , [number] ] , node = node ) , fan_mode = MockValue ( data = [string] , data_items = [ [number] , [number] , [number] ] , node = node ) , operating_state = MockValue ( data = [number] , node = node ) , fan_state = MockValue ( data = [number] , node = node ) , zxt_120_swing_mode = MockValue ( data = [string] , data_items = [ [number] , [number] , [number] ] , node = node ) , ) [EOL] device = zwave . get_device ( hass , node = node , values = values , node_config = { } ) [EOL] [EOL] yield device [EOL] [EOL] [EOL] @ pytest . fixture def device_mapping ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] values = MockEntityValues ( primary = MockValue ( data = [number] , node = node ) , temperature = MockValue ( data = [number] , node = node , units = None ) , mode = MockValue ( data = [string] , data_items = [ [string] , [string] , [string] ] , node = node ) , fan_mode = MockValue ( data = [string] , data_items = [ [number] , [number] , [number] ] , node = node ) , operating_state = MockValue ( data = [number] , node = node ) , fan_state = MockValue ( data = [number] , node = node ) , ) [EOL] device = zwave . get_device ( hass , node = node , values = values , node_config = { } ) [EOL] [EOL] yield device [EOL] [EOL] [EOL] def test_zxt_120_swing_mode ( device_zxt_120 ) : [EOL] [docstring] [EOL] device = device_zxt_120 [EOL] [EOL] assert device . swing_list == [ [number] , [number] , [number] ] [EOL] assert device . _zxt_120 == [number] [EOL] [EOL] [comment] [EOL] assert device . values . zxt_120_swing_mode . data == [string] [EOL] device . set_swing_mode ( [string] ) [EOL] assert device . values . zxt_120_swing_mode . data == [string] [EOL] [EOL] [comment] [EOL] value_changed ( device . values . zxt_120_swing_mode ) [EOL] assert device . current_swing_mode == [string] [EOL] device . values . zxt_120_swing_mode . data = [string] [EOL] value_changed ( device . values . zxt_120_swing_mode ) [EOL] assert device . current_swing_mode == [string] [EOL] [EOL] [EOL] def test_temperature_unit ( device ) : [EOL] [docstring] [EOL] assert device . temperature_unit == TEMP_CELSIUS [EOL] device . values . temperature . units = [string] [EOL] value_changed ( device . values . temperature ) [EOL] assert device . temperature_unit == TEMP_FAHRENHEIT [EOL] device . values . temperature . units = [string] [EOL] value_changed ( device . values . temperature ) [EOL] assert device . temperature_unit == TEMP_CELSIUS [EOL] [EOL] [EOL] def test_default_target_temperature ( device ) : [EOL] [docstring] [EOL] assert device . target_temperature == [number] [EOL] device . values . primary . data = [number] [EOL] value_changed ( device . values . primary ) [EOL] assert device . target_temperature == [number] [comment] [EOL] [EOL] [EOL] def test_data_lists ( device ) : [EOL] [docstring] [EOL] assert device . fan_list == [ [number] , [number] , [number] ] [EOL] assert device . operation_list == [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_target_value_set ( device ) : [EOL] [docstring] [EOL] assert device . values . primary . data == [number] [EOL] device . set_temperature ( ) [EOL] assert device . values . primary . data == [number] [EOL] device . set_temperature ( ** { ATTR_TEMPERATURE : [number] } ) [EOL] assert device . values . primary . data == [number] [EOL] [EOL] [EOL] def test_operation_value_set ( device ) : [EOL] [docstring] [EOL] assert device . values . mode . data == [string] [EOL] device . set_operation_mode ( [string] ) [EOL] assert device . values . mode . data == [string] [EOL] [EOL] [EOL] def test_operation_value_set_mapping ( device_mapping ) : [EOL] [docstring] [EOL] device = device_mapping [EOL] assert device . values . mode . data == [string] [EOL] device . set_operation_mode ( STATE_HEAT ) [EOL] assert device . values . mode . data == [string] [EOL] device . set_operation_mode ( STATE_COOL ) [EOL] assert device . values . mode . data == [string] [EOL] device . set_operation_mode ( STATE_OFF ) [EOL] assert device . values . mode . data == [string] [EOL] [EOL] [EOL] def test_fan_mode_value_set ( device ) : [EOL] [docstring] [EOL] assert device . values . fan_mode . data == [string] [EOL] device . set_fan_mode ( [string] ) [EOL] assert device . values . fan_mode . data == [string] [EOL] [EOL] [EOL] def test_target_value_changed ( device ) : [EOL] [docstring] [EOL] assert device . target_temperature == [number] [EOL] device . values . primary . data = [number] [EOL] value_changed ( device . values . primary ) [EOL] assert device . target_temperature == [number] [EOL] [EOL] [EOL] def test_temperature_value_changed ( device ) : [EOL] [docstring] [EOL] assert device . current_temperature == [number] [EOL] device . values . temperature . data = [number] [EOL] value_changed ( device . values . temperature ) [EOL] assert device . current_temperature == [number] [EOL] [EOL] [EOL] def test_operation_value_changed ( device ) : [EOL] [docstring] [EOL] assert device . current_operation == [string] [EOL] device . values . mode . data = [string] [EOL] value_changed ( device . values . mode ) [EOL] assert device . current_operation == [string] [EOL] [EOL] [EOL] def test_operation_value_changed_mapping ( device_mapping ) : [EOL] [docstring] [EOL] device = device_mapping [EOL] assert device . current_operation == [string] [EOL] device . values . mode . data = [string] [EOL] value_changed ( device . values . mode ) [EOL] assert device . current_operation == STATE_HEAT [EOL] device . values . mode . data = [string] [EOL] value_changed ( device . values . mode ) [EOL] assert device . current_operation == STATE_COOL [EOL] device . values . mode . data = [string] [EOL] value_changed ( device . values . mode ) [EOL] assert device . current_operation == STATE_OFF [EOL] [EOL] [EOL] def test_fan_mode_value_changed ( device ) : [EOL] [docstring] [EOL] assert device . current_fan_mode == [string] [EOL] device . values . fan_mode . data = [string] [EOL] value_changed ( device . values . fan_mode ) [EOL] assert device . current_fan_mode == [string] [EOL] [EOL] [EOL] def test_operating_state_value_changed ( device ) : [EOL] [docstring] [EOL] assert device . device_state_attributes [ zwave . ATTR_OPERATING_STATE ] == [number] [EOL] device . values . operating_state . data = [number] [EOL] value_changed ( device . values . operating_state ) [EOL] assert device . device_state_attributes [ zwave . ATTR_OPERATING_STATE ] == [number] [EOL] [EOL] [EOL] def test_fan_state_value_changed ( device ) : [EOL] [docstring] [EOL] assert device . device_state_attributes [ zwave . ATTR_FAN_STATE ] == [number] [EOL] device . values . fan_state . data = [number] [EOL] value_changed ( device . values . fan_state ) [EOL] assert device . device_state_attributes [ zwave . ATTR_FAN_STATE ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from datetime import timedelta , datetime [EOL] from unittest . mock import patch [EOL] [EOL] import homeassistant . core as ha [EOL] from homeassistant . setup import setup_component , async_setup_component [EOL] import homeassistant . components . sensor as sensor [EOL] from homeassistant . const import EVENT_STATE_CHANGED , STATE_UNAVAILABLE [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] from tests . common import mock_mqtt_component , fire_mqtt_message , assert_setup_component , async_fire_mqtt_message , async_mock_mqtt_component [EOL] from tests . common import get_test_home_assistant , mock_component [EOL] [EOL] [EOL] class TestSensorMQTT ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] mock_mqtt_component ( self . hass ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setting_sensor_value_via_mqtt_message ( self ) : [EOL] [docstring] [EOL] mock_component ( self . hass , [string] ) [EOL] assert setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( [string] , state . state ) [EOL] self . assertEqual ( [string] , state . attributes . get ( [string] ) ) [EOL] [EOL] @ patch ( [string] ) def test_setting_sensor_value_expires ( self , mock_utcnow ) : [EOL] [docstring] [EOL] mock_component ( self . hass , [string] ) [EOL] assert setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True } } ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [string] , state . state ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] mock_utcnow . return_value = now [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [string] , state . state ) [EOL] [EOL] [comment] [EOL] now = now + timedelta ( seconds = [number] ) [EOL] self . _send_time_changed ( now ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [string] , state . state ) [EOL] [EOL] [comment] [EOL] mock_utcnow . return_value = now [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [string] , state . state ) [EOL] [EOL] [comment] [EOL] now = now + timedelta ( seconds = [number] ) [EOL] self . _send_time_changed ( now ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [string] , state . state ) [EOL] [EOL] [comment] [EOL] now = now + timedelta ( seconds = [number] ) [EOL] self . _send_time_changed ( now ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( [string] , state . state ) [EOL] [EOL] def test_setting_sensor_value_via_mqtt_json_message ( self ) : [EOL] [docstring] [EOL] mock_component ( self . hass , [string] ) [EOL] assert setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( [string] , state . state ) [EOL] [EOL] def test_force_update_disabled ( self ) : [EOL] [docstring] [EOL] mock_component ( self . hass , [string] ) [EOL] assert setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] events = [ ] [EOL] [EOL] @ ha . callback def callback ( event ) : [EOL] events . append ( event ) [EOL] [EOL] self . hass . bus . listen ( EVENT_STATE_CHANGED , callback ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( events ) ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( events ) ) [EOL] [EOL] def test_force_update_enabled ( self ) : [EOL] [docstring] [EOL] mock_component ( self . hass , [string] ) [EOL] assert setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True } } ) [EOL] [EOL] events = [ ] [EOL] [EOL] @ ha . callback def callback ( event ) : [EOL] events . append ( event ) [EOL] [EOL] self . hass . bus . listen ( EVENT_STATE_CHANGED , callback ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( events ) ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( events ) ) [EOL] [EOL] def test_default_availability_payload ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] def test_custom_availability_payload ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertNotEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( STATE_UNAVAILABLE , state . state ) [EOL] [EOL] def _send_time_changed ( self , now ) : [EOL] [docstring] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : now } ) [EOL] [EOL] def test_setting_sensor_attribute_via_mqtt_json_message ( self ) : [EOL] [docstring] [EOL] mock_component ( self . hass , [string] ) [EOL] assert setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( [string] , state . attributes . get ( [string] ) ) [EOL] [EOL] @ patch ( [string] ) def test_update_with_json_attrs_not_dict ( self , mock_logger ) : [EOL] [docstring] [EOL] mock_component ( self . hass , [string] ) [EOL] assert setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( None , state . attributes . get ( [string] ) ) [EOL] self . assertTrue ( mock_logger . warning . called ) [EOL] [EOL] @ patch ( [string] ) def test_update_with_json_attrs_bad_JSON ( self , mock_logger ) : [EOL] [docstring] [EOL] mock_component ( self . hass , [string] ) [EOL] assert setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( None , state . attributes . get ( [string] ) ) [EOL] self . assertTrue ( mock_logger . warning . called ) [EOL] self . assertTrue ( mock_logger . debug . called ) [EOL] [EOL] def test_update_with_json_attrs_and_template ( self ) : [EOL] [docstring] [EOL] mock_component ( self . hass , [string] ) [EOL] assert setup_component ( self . hass , sensor . DOMAIN , { sensor . DOMAIN : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] fire_mqtt_message ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertEqual ( [string] , state . attributes . get ( [string] ) ) [EOL] self . assertEqual ( [string] , state . state ) [EOL] [EOL] def test_invalid_device_class ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] def test_valid_device_class ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , [string] , { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , } ] } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [string] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert [string] not in state . attributes [EOL] [EOL] [EOL] async def test_unique_id ( hass ) : [EOL] [docstring] [EOL] await async_mock_mqtt_component ( hass ) [EOL] assert await async_setup_component ( hass , sensor . DOMAIN , { sensor . DOMAIN : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } ) [EOL] [EOL] async_fire_mqtt_message ( hass , [string] , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( hass . states . async_all ( ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Union , List , Type , Tuple , Literal , Any , Dict [EOL] import typing [EOL] import unittest [EOL] import tests [EOL] import typing_extensions [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import MagicMock [EOL] [EOL] from homeassistant . components . sensor import kira as kira [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] TEST_CONFIG = { kira . DOMAIN : { [string] : [ { [string] : [string] , [string] : [number] } ] } } [EOL] [EOL] DISCOVERY_INFO = { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] class TestKiraSensor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] DEVICES = [ ] [EOL] [EOL] def add_entities ( self , devices ) : [EOL] [docstring] [EOL] for device in devices : [EOL] self . DEVICES . append ( device ) [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] mock_kira = MagicMock ( ) [EOL] self . hass . data [ kira . DOMAIN ] = { kira . CONF_SENSOR : { } } [EOL] self . hass . data [ kira . DOMAIN ] [ kira . CONF_SENSOR ] [ [string] ] = mock_kira [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] [comment] [EOL] def test_kira_sensor_callback ( self ) : [EOL] [docstring] [EOL] kira . setup_platform ( self . hass , TEST_CONFIG , self . add_entities , DISCOVERY_INFO ) [EOL] assert len ( self . DEVICES ) == [number] [EOL] sensor = self . DEVICES [ [number] ] [EOL] [EOL] assert sensor . name == [string] [EOL] [EOL] sensor . hass = self . hass [EOL] [EOL] codeName = [string] [EOL] deviceName = [string] [EOL] codeTuple = ( codeName , deviceName ) [EOL] sensor . _update_callback ( codeTuple ) [EOL] [EOL] assert sensor . state == codeName [EOL] assert sensor . device_state_attributes == { kira . CONF_DEVICE : deviceName } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any , Dict [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] import json [EOL] from unittest . mock import Mock [EOL] [EOL] from homeassistant . components . melissa import DATA_MELISSA [EOL] from homeassistant . components . sensor import melissa [EOL] from homeassistant . components . sensor . melissa import MelissaTemperatureSensor , MelissaHumiditySensor [EOL] from homeassistant . const import TEMP_CELSIUS [EOL] from tests . common import get_test_home_assistant , load_fixture [EOL] [EOL] [EOL] class TestMelissa ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . _serial = [string] [EOL] [EOL] self . api = Mock ( ) [EOL] self . api . fetch_devices . return_value = json . loads ( load_fixture ( [string] ) ) [EOL] self . api . status . return_value = json . loads ( load_fixture ( [string] ) ) [EOL] [EOL] self . api . TEMP = [string] [EOL] self . api . HUMIDITY = [string] [EOL] device = self . api . fetch_devices ( ) [ self . _serial ] [EOL] self . temp = MelissaTemperatureSensor ( device , self . api ) [EOL] self . hum = MelissaHumiditySensor ( device , self . api ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_platform ( self ) : [EOL] [docstring] [EOL] self . hass . data [ DATA_MELISSA ] = self . api [EOL] [EOL] config = { } [EOL] add_entities = Mock ( ) [EOL] discovery_info = { } [EOL] [EOL] melissa . setup_platform ( self . hass , config , add_entities , discovery_info ) [EOL] [EOL] def test_name ( self ) : [EOL] [docstring] [EOL] device = self . api . fetch_devices ( ) [ self . _serial ] [EOL] self . assertEqual ( self . temp . name , [string] . format ( device [ [string] ] , self . temp . _type ) ) [EOL] self . assertEqual ( self . hum . name , [string] . format ( device [ [string] ] , self . hum . _type ) ) [EOL] [EOL] def test_state ( self ) : [EOL] [docstring] [EOL] device = self . api . status ( ) [ self . _serial ] [EOL] self . temp . update ( ) [EOL] self . assertEqual ( self . temp . state , device [ self . api . TEMP ] ) [EOL] self . hum . update ( ) [EOL] self . assertEqual ( self . hum . state , device [ self . api . HUMIDITY ] ) [EOL] [EOL] def test_unit_of_measurement ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . temp . unit_of_measurement , TEMP_CELSIUS ) [EOL] self . assertEqual ( self . hum . unit_of_measurement , [string] ) [EOL] [EOL] def test_update ( self ) : [EOL] [docstring] [EOL] self . temp . update ( ) [EOL] self . assertEqual ( self . temp . state , [number] ) [EOL] self . hum . update ( ) [EOL] self . assertEqual ( self . hum . state , [number] ) [EOL] [EOL] def test_update_keyerror ( self ) : [EOL] [docstring] [EOL] self . temp . _api . status . return_value = { } [EOL] self . temp . update ( ) [EOL] self . assertEqual ( None , self . temp . state ) [EOL] self . hum . _api . status . return_value = { } [EOL] self . hum . update ( ) [EOL] self . assertEqual ( None , self . hum . state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $unittest.mock.Mock$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , Tuple , Any , Dict [EOL] import typing [EOL] import homeassistant [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_API_KEY , CONF_BINARY_SENSORS , CONF_ELEVATION , CONF_LATITUDE , CONF_LONGITUDE , CONF_MONITORED_CONDITIONS , CONF_SCAN_INTERVAL , CONF_SENSORS ) [EOL] from homeassistant . helpers import ( aiohttp_client , config_validation as cv , discovery ) [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_send [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import async_track_time_interval [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] DATA_PROTECTION_WINDOW = [string] [EOL] DATA_UV = [string] [EOL] [EOL] DEFAULT_ATTRIBUTION = [string] [EOL] DEFAULT_SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] TOPIC_UPDATE = [string] . format ( DOMAIN ) [EOL] [EOL] TYPE_CURRENT_OZONE_LEVEL = [string] [EOL] TYPE_CURRENT_UV_INDEX = [string] [EOL] TYPE_CURRENT_UV_LEVEL = [string] [EOL] TYPE_MAX_UV_INDEX = [string] [EOL] TYPE_PROTECTION_WINDOW = [string] [EOL] TYPE_SAFE_EXPOSURE_TIME_1 = [string] [EOL] TYPE_SAFE_EXPOSURE_TIME_2 = [string] [EOL] TYPE_SAFE_EXPOSURE_TIME_3 = [string] [EOL] TYPE_SAFE_EXPOSURE_TIME_4 = [string] [EOL] TYPE_SAFE_EXPOSURE_TIME_5 = [string] [EOL] TYPE_SAFE_EXPOSURE_TIME_6 = [string] [EOL] [EOL] BINARY_SENSORS = { TYPE_PROTECTION_WINDOW : ( [string] , [string] ) } [EOL] [EOL] BINARY_SENSOR_SCHEMA = vol . Schema ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( BINARY_SENSORS ) ) : vol . All ( cv . ensure_list , [ vol . In ( BINARY_SENSORS ) ] ) } ) [EOL] [EOL] SENSORS = { TYPE_CURRENT_OZONE_LEVEL : ( [string] , [string] , [string] ) , TYPE_CURRENT_UV_INDEX : ( [string] , [string] , [string] ) , TYPE_CURRENT_UV_LEVEL : ( [string] , [string] , None ) , TYPE_MAX_UV_INDEX : ( [string] , [string] , [string] ) , TYPE_SAFE_EXPOSURE_TIME_1 : ( [string] , [string] , [string] ) , TYPE_SAFE_EXPOSURE_TIME_2 : ( [string] , [string] , [string] ) , TYPE_SAFE_EXPOSURE_TIME_3 : ( [string] , [string] , [string] ) , TYPE_SAFE_EXPOSURE_TIME_4 : ( [string] , [string] , [string] ) , TYPE_SAFE_EXPOSURE_TIME_5 : ( [string] , [string] , [string] ) , TYPE_SAFE_EXPOSURE_TIME_6 : ( [string] , [string] , [string] ) , } [EOL] [EOL] SENSOR_SCHEMA = vol . Schema ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSORS ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSORS ) ] ) } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Optional ( CONF_ELEVATION ) : float , vol . Optional ( CONF_LATITUDE ) : cv . latitude , vol . Optional ( CONF_LONGITUDE ) : cv . longitude , vol . Optional ( CONF_BINARY_SENSORS , default = { } ) : BINARY_SENSOR_SCHEMA , vol . Optional ( CONF_SENSORS , default = { } ) : SENSOR_SCHEMA , vol . Optional ( CONF_SCAN_INTERVAL , default = DEFAULT_SCAN_INTERVAL ) : cv . time_period , } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] from pyopenuv import Client [EOL] from pyopenuv . errors import OpenUvError [EOL] [EOL] conf = config [ DOMAIN ] [EOL] api_key = conf [ CONF_API_KEY ] [EOL] elevation = conf . get ( CONF_ELEVATION , hass . config . elevation ) [EOL] latitude = conf . get ( CONF_LATITUDE , hass . config . latitude ) [EOL] longitude = conf . get ( CONF_LONGITUDE , hass . config . longitude ) [EOL] [EOL] try : [EOL] websession = aiohttp_client . async_get_clientsession ( hass ) [EOL] openuv = OpenUV ( Client ( api_key , latitude , longitude , websession , altitude = elevation ) , conf [ CONF_BINARY_SENSORS ] [ CONF_MONITORED_CONDITIONS ] + conf [ CONF_SENSORS ] [ CONF_MONITORED_CONDITIONS ] ) [EOL] await openuv . async_update ( ) [EOL] hass . data [ DOMAIN ] = openuv [EOL] except OpenUvError as err : [EOL] _LOGGER . error ( [string] , str ( err ) ) [EOL] hass . components . persistent_notification . create ( [string] [string] [string] . format ( err ) , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] return False [EOL] [EOL] for component , schema in [ ( [string] , conf [ CONF_BINARY_SENSORS ] ) , ( [string] , conf [ CONF_SENSORS ] ) , ] : [EOL] hass . async_create_task ( discovery . async_load_platform ( hass , component , DOMAIN , schema , config ) ) [EOL] [EOL] async def refresh_sensors ( event_time ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] await openuv . async_update ( ) [EOL] async_dispatcher_send ( hass , TOPIC_UPDATE ) [EOL] [EOL] async_track_time_interval ( hass , refresh_sensors , conf [ CONF_SCAN_INTERVAL ] ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class OpenUV : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , monitored_conditions ) : [EOL] [docstring] [EOL] self . _monitored_conditions = monitored_conditions [EOL] self . client = client [EOL] self . data = { } [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] if TYPE_PROTECTION_WINDOW in self . _monitored_conditions : [EOL] data = await self . client . uv_protection_window ( ) [EOL] self . data [ DATA_PROTECTION_WINDOW ] = data [EOL] [EOL] if any ( c in self . _monitored_conditions for c in SENSORS ) : [EOL] data = await self . client . uv_index ( ) [EOL] self . data [ DATA_UV ] = data [EOL] [EOL] [EOL] class OpenUvEntity ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , openuv ) : [EOL] [docstring] [EOL] self . _attrs = { ATTR_ATTRIBUTION : DEFAULT_ATTRIBUTION } [EOL] self . _name = None [EOL] self . openuv = openuv [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attrs [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,typing.Optional[builtins.str]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import EVENT_HOMEASSISTANT_STOP , CONF_PORT [EOL] from homeassistant . helpers . discovery import load_platform [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] VELBUS_MESSAGE = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_PORT ) : cv . string , } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] import velbus [EOL] port = config [ DOMAIN ] . get ( CONF_PORT ) [EOL] controller = velbus . Controller ( port ) [EOL] [EOL] hass . data [ DOMAIN ] = controller [EOL] [EOL] def stop_velbus ( event ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] controller . stop ( ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , stop_velbus ) [EOL] [EOL] def callback ( ) : [EOL] modules = controller . get_modules ( ) [EOL] discovery_info = { [string] : [ ] , [string] : [ ] } [EOL] for module in modules : [EOL] for channel in range ( [number] , module . number_of_channels ( ) + [number] ) : [EOL] for category in discovery_info : [EOL] if category in module . get_categories ( channel ) : [EOL] discovery_info [ category ] . append ( ( module . get_module_address ( ) , channel ) ) [EOL] load_platform ( hass , [string] , DOMAIN , discovery_info [ [string] ] , config ) [EOL] load_platform ( hass , [string] , DOMAIN , discovery_info [ [string] ] , config ) [EOL] [EOL] controller . scan ( callback ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class VelbusEntity ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , module , channel ) : [EOL] [docstring] [EOL] self . _module = module [EOL] self . _channel = channel [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] serial = [number] [EOL] if self . _module . serial == [number] : [EOL] serial = self . _module . get_module_address ( ) [EOL] else : [EOL] serial = self . _module . serial [EOL] return [string] . format ( serial , self . _channel ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _module . get_name ( self . _channel ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _module . on_status_update ( self . _channel , self . _on_update ) [EOL] [EOL] def _on_update ( self , state ) : [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict , Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] import json [EOL] import logging [EOL] import os [EOL] import time [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . http import HomeAssistantView [EOL] from homeassistant . const import ( ATTR_BATTERY_LEVEL , ATTR_ENTITY_ID , ATTR_NAME , CONF_EMAIL , CONF_PASSWORD , EVENT_HOMEASSISTANT_START , EVENT_HOMEASSISTANT_STOP , STATE_OFF , STATE_ON , __version__ ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers import discovery [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . event import track_time_interval [EOL] from homeassistant . util . json import load_json , save_json [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] SUBSCRIPTION_HANDLER = None [EOL] [EOL] CONF_CLIENT_ID = [string] [EOL] CONF_CLIENT_SECRET = [string] [EOL] CONF_USER_AGENT = [string] [EOL] CONF_OAUTH = [string] [EOL] CONF_LOCAL_CONTROL = [string] [EOL] CONF_MISSING_OAUTH_MSG = [string] [EOL] [EOL] ATTR_ACCESS_TOKEN = [string] [EOL] ATTR_REFRESH_TOKEN = [string] [EOL] ATTR_CLIENT_ID = [string] [EOL] ATTR_CLIENT_SECRET = [string] [EOL] ATTR_PAIRING_MODE = [string] [EOL] ATTR_KIDDE_RADIO_CODE = [string] [EOL] ATTR_HUB_NAME = [string] [EOL] [EOL] WINK_AUTH_CALLBACK_PATH = [string] [EOL] WINK_AUTH_START = [string] [EOL] WINK_CONFIG_FILE = [string] [EOL] USER_AGENT = [string] . format ( __version__ ) [EOL] [EOL] DEFAULT_CONFIG = { [string] : [string] , [string] : [string] } [EOL] [EOL] SERVICE_ADD_NEW_DEVICES = [string] [EOL] SERVICE_REFRESH_STATES = [string] [EOL] SERVICE_RENAME_DEVICE = [string] [EOL] SERVICE_DELETE_DEVICE = [string] [EOL] SERVICE_SET_PAIRING_MODE = [string] [EOL] SERVICE_SET_CHIME_VOLUME = [string] [EOL] SERVICE_SET_SIREN_VOLUME = [string] [EOL] SERVICE_ENABLE_CHIME = [string] [EOL] SERVICE_SET_SIREN_TONE = [string] [EOL] SERVICE_SET_AUTO_SHUTOFF = [string] [EOL] SERVICE_SIREN_STROBE_ENABLED = [string] [EOL] SERVICE_CHIME_STROBE_ENABLED = [string] [EOL] SERVICE_ENABLE_SIREN = [string] [EOL] [EOL] ATTR_VOLUME = [string] [EOL] ATTR_TONE = [string] [EOL] ATTR_ENABLED = [string] [EOL] ATTR_AUTO_SHUTOFF = [string] [EOL] [EOL] VOLUMES = [ [string] , [string] , [string] ] [EOL] TONES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] CHIME_TONES = TONES + [ [string] ] [EOL] AUTO_SHUTOFF_TIMES = [ None , - [number] , [number] , [number] , [number] ] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Inclusive ( CONF_EMAIL , CONF_OAUTH , msg = CONF_MISSING_OAUTH_MSG ) : cv . string , vol . Inclusive ( CONF_PASSWORD , CONF_OAUTH , msg = CONF_MISSING_OAUTH_MSG ) : cv . string , vol . Inclusive ( CONF_CLIENT_ID , CONF_OAUTH , msg = CONF_MISSING_OAUTH_MSG ) : cv . string , vol . Inclusive ( CONF_CLIENT_SECRET , CONF_OAUTH , msg = CONF_MISSING_OAUTH_MSG ) : cv . string , vol . Optional ( CONF_LOCAL_CONTROL , default = False ) : cv . boolean } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] RENAME_DEVICE_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_NAME ) : cv . string } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] DELETE_DEVICE_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . entity_ids } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] SET_PAIRING_MODE_SCHEMA = vol . Schema ( { vol . Required ( ATTR_HUB_NAME ) : cv . string , vol . Required ( ATTR_PAIRING_MODE ) : cv . string , vol . Optional ( ATTR_KIDDE_RADIO_CODE ) : cv . string } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] SET_VOLUME_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_VOLUME ) : vol . In ( VOLUMES ) } ) [EOL] [EOL] SET_SIREN_TONE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_TONE ) : vol . In ( TONES ) } ) [EOL] [EOL] SET_CHIME_MODE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_TONE ) : vol . In ( CHIME_TONES ) } ) [EOL] [EOL] SET_AUTO_SHUTOFF_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_AUTO_SHUTOFF ) : vol . In ( AUTO_SHUTOFF_TIMES ) } ) [EOL] [EOL] SET_STROBE_ENABLED_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_ENABLED ) : cv . boolean } ) [EOL] [EOL] ENABLED_SIREN_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_ENABLED ) : cv . boolean } ) [EOL] [EOL] WINK_COMPONENTS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] WINK_HUBS = [ ] [EOL] [EOL] [EOL] def _request_app_setup ( hass , config ) : [EOL] [docstring] [EOL] hass . data [ DOMAIN ] [ [string] ] = True [EOL] configurator = hass . components . configurator [EOL] [EOL] def wink_configuration_callback ( callback_data ) : [EOL] [docstring] [EOL] _config_path = hass . config . path ( WINK_CONFIG_FILE ) [EOL] if not os . path . isfile ( _config_path ) : [EOL] setup ( hass , config ) [EOL] return [EOL] [EOL] client_id = callback_data . get ( [string] ) . strip ( ) [EOL] client_secret = callback_data . get ( [string] ) . strip ( ) [EOL] if None not in ( client_id , client_secret ) : [EOL] save_json ( _config_path , { ATTR_CLIENT_ID : client_id , ATTR_CLIENT_SECRET : client_secret } ) [EOL] setup ( hass , config ) [EOL] return [EOL] error_msg = [string] [EOL] _configurator = hass . data [ DOMAIN ] [ [string] ] [ DOMAIN ] [EOL] configurator . notify_errors ( _configurator , error_msg ) [EOL] [EOL] start_url = [string] . format ( hass . config . api . base_url , WINK_AUTH_CALLBACK_PATH ) [EOL] [EOL] description = [string] . format ( start_url ) [EOL] [EOL] hass . data [ DOMAIN ] [ [string] ] [ DOMAIN ] = configurator . request_config ( DOMAIN , wink_configuration_callback , description = description , submit_caption = [string] , description_image = [string] , fields = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } ] ) [EOL] [EOL] [EOL] def _request_oauth_completion ( hass , config ) : [EOL] [docstring] [EOL] hass . data [ DOMAIN ] [ [string] ] = True [EOL] configurator = hass . components . configurator [EOL] if DOMAIN in hass . data [ DOMAIN ] [ [string] ] : [EOL] configurator . notify_errors ( hass . data [ DOMAIN ] [ [string] ] [ DOMAIN ] , [string] ) [EOL] return [EOL] [EOL] def wink_configuration_callback ( callback_data ) : [EOL] [docstring] [EOL] setup ( hass , config ) [EOL] [EOL] start_url = [string] . format ( hass . config . api . base_url , WINK_AUTH_START ) [EOL] [EOL] description = [string] . format ( start_url ) [EOL] [EOL] hass . data [ DOMAIN ] [ [string] ] [ DOMAIN ] = configurator . request_config ( DOMAIN , wink_configuration_callback , description = description ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] import pywink [EOL] from pubnubsubhandler import PubNubSubscriptionHandler [EOL] [EOL] if hass . data . get ( DOMAIN ) is None : [EOL] hass . data [ DOMAIN ] = { [string] : [ ] , [string] : { } , [string] : { } , [string] : { } , [string] : None , [string] : False } [EOL] [EOL] if config . get ( DOMAIN ) is not None : [EOL] client_id = config [ DOMAIN ] . get ( ATTR_CLIENT_ID ) [EOL] client_secret = config [ DOMAIN ] . get ( ATTR_CLIENT_SECRET ) [EOL] email = config [ DOMAIN ] . get ( CONF_EMAIL ) [EOL] password = config [ DOMAIN ] . get ( CONF_PASSWORD ) [EOL] local_control = config [ DOMAIN ] . get ( CONF_LOCAL_CONTROL ) [EOL] else : [EOL] client_id = None [EOL] client_secret = None [EOL] email = None [EOL] password = None [EOL] local_control = None [EOL] hass . data [ DOMAIN ] [ [string] ] = True [EOL] if None not in [ client_id , client_secret ] : [EOL] _LOGGER . info ( [string] ) [EOL] if not local_control : [EOL] pywink . disable_local_control ( ) [EOL] hass . data [ DOMAIN ] [ [string] ] [ [string] ] = client_id [EOL] hass . data [ DOMAIN ] [ [string] ] [ [string] ] = client_secret [EOL] hass . data [ DOMAIN ] [ [string] ] [ [string] ] = email [EOL] hass . data [ DOMAIN ] [ [string] ] [ [string] ] = password [EOL] pywink . legacy_set_wink_credentials ( email , password , client_id , client_secret ) [EOL] else : [EOL] _LOGGER . info ( [string] ) [EOL] if not local_control : [EOL] pywink . disable_local_control ( ) [EOL] config_path = hass . config . path ( WINK_CONFIG_FILE ) [EOL] if os . path . isfile ( config_path ) : [EOL] config_file = load_json ( config_path ) [EOL] if config_file == DEFAULT_CONFIG : [EOL] _request_app_setup ( hass , config ) [EOL] return True [EOL] [comment] [EOL] else : [EOL] save_json ( config_path , DEFAULT_CONFIG ) [EOL] _request_app_setup ( hass , config ) [EOL] return True [EOL] [EOL] if DOMAIN in hass . data [ DOMAIN ] [ [string] ] : [EOL] _configurator = hass . data [ DOMAIN ] [ [string] ] [EOL] hass . components . configurator . request_done ( _configurator . pop ( DOMAIN ) ) [EOL] [EOL] [comment] [EOL] access_token = config_file . get ( ATTR_ACCESS_TOKEN ) [EOL] refresh_token = config_file . get ( ATTR_REFRESH_TOKEN ) [EOL] [EOL] [comment] [EOL] if None not in ( access_token , refresh_token ) : [EOL] pywink . set_wink_credentials ( config_file . get ( ATTR_CLIENT_ID ) , config_file . get ( ATTR_CLIENT_SECRET ) , access_token = access_token , refresh_token = refresh_token ) [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] [EOL] redirect_uri = [string] . format ( hass . config . api . base_url , WINK_AUTH_CALLBACK_PATH ) [EOL] [EOL] wink_auth_start_url = pywink . get_authorization_url ( config_file . get ( ATTR_CLIENT_ID ) , redirect_uri ) [EOL] hass . http . register_redirect ( WINK_AUTH_START , wink_auth_start_url ) [EOL] hass . http . register_view ( WinkAuthCallbackView ( config , config_file , pywink . request_token ) ) [EOL] _request_oauth_completion ( hass , config ) [EOL] return True [EOL] [EOL] pywink . set_user_agent ( USER_AGENT ) [EOL] hass . data [ DOMAIN ] [ [string] ] = PubNubSubscriptionHandler ( pywink . get_subscription_key ( ) ) [EOL] [EOL] def _subscribe ( ) : [EOL] hass . data [ DOMAIN ] [ [string] ] . subscribe ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if hass . data [ DOMAIN ] [ [string] ] : [EOL] _subscribe ( ) [EOL] [EOL] def keep_alive_call ( event_time ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] pywink . set_user_agent ( str ( int ( time . time ( ) ) ) ) [EOL] _temp_response = pywink . get_user ( ) [EOL] _LOGGER . debug ( str ( json . dumps ( _temp_response ) ) ) [EOL] time . sleep ( [number] ) [EOL] pywink . set_user_agent ( USER_AGENT ) [EOL] _temp_response = pywink . wink_api_fetch ( ) [EOL] _LOGGER . debug ( str ( json . dumps ( _temp_response ) ) ) [EOL] [EOL] [comment] [EOL] track_time_interval ( hass , keep_alive_call , timedelta ( minutes = [number] ) ) [EOL] [EOL] def start_subscription ( event ) : [EOL] [docstring] [EOL] _subscribe ( ) [EOL] [EOL] hass . bus . listen ( EVENT_HOMEASSISTANT_START , start_subscription ) [EOL] [EOL] def stop_subscription ( event ) : [EOL] [docstring] [EOL] hass . data [ DOMAIN ] [ [string] ] . unsubscribe ( ) [EOL] hass . data [ DOMAIN ] [ [string] ] = None [EOL] [EOL] hass . bus . listen ( EVENT_HOMEASSISTANT_STOP , stop_subscription ) [EOL] [EOL] def save_credentials ( event ) : [EOL] [docstring] [EOL] if hass . data [ DOMAIN ] [ [string] ] . get ( [string] ) is None : [EOL] config_path = hass . config . path ( WINK_CONFIG_FILE ) [EOL] _config = pywink . get_current_oauth_credentials ( ) [EOL] save_json ( config_path , _config ) [EOL] [EOL] hass . bus . listen ( EVENT_HOMEASSISTANT_STOP , save_credentials ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] track_time_interval ( hass , save_credentials , timedelta ( minutes = [number] ) ) [EOL] [EOL] def force_update ( call ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] for entity_list in hass . data [ DOMAIN ] [ [string] ] . values ( ) : [EOL] [comment] [EOL] for entity in entity_list : [EOL] time . sleep ( [number] ) [EOL] entity . schedule_update_ha_state ( True ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_REFRESH_STATES , force_update ) [EOL] [EOL] def pull_new_devices ( call ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] for _component in WINK_COMPONENTS : [EOL] discovery . load_platform ( hass , _component , DOMAIN , { } , config ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_ADD_NEW_DEVICES , pull_new_devices ) [EOL] [EOL] def set_pairing_mode ( call ) : [EOL] [docstring] [EOL] hub_name = call . data . get ( [string] ) [EOL] pairing_mode = call . data . get ( [string] ) [EOL] kidde_code = call . data . get ( [string] ) [EOL] for hub in WINK_HUBS : [EOL] if hub . name ( ) == hub_name : [EOL] hub . pair_new_device ( pairing_mode , kidde_radio_code = kidde_code ) [EOL] [EOL] def rename_device ( call ) : [EOL] [docstring] [EOL] [comment] [EOL] found_device = None [EOL] entity_id = call . data . get ( [string] ) [ [number] ] [EOL] all_devices = [ ] [EOL] for list_of_devices in hass . data [ DOMAIN ] [ [string] ] . values ( ) : [EOL] all_devices += list_of_devices [EOL] for device in all_devices : [EOL] if device . entity_id == entity_id : [EOL] found_device = device [EOL] if found_device is not None : [EOL] name = call . data . get ( [string] ) [EOL] found_device . wink . set_name ( name ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_RENAME_DEVICE , rename_device , schema = RENAME_DEVICE_SCHEMA ) [EOL] [EOL] def delete_device ( call ) : [EOL] [docstring] [EOL] [comment] [EOL] found_device = None [EOL] entity_id = call . data . get ( [string] ) [ [number] ] [EOL] all_devices = [ ] [EOL] for list_of_devices in hass . data [ DOMAIN ] [ [string] ] . values ( ) : [EOL] all_devices += list_of_devices [EOL] for device in all_devices : [EOL] if device . entity_id == entity_id : [EOL] found_device = device [EOL] if found_device is not None : [EOL] found_device . wink . remove_device ( ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_DELETE_DEVICE , delete_device , schema = DELETE_DEVICE_SCHEMA ) [EOL] [EOL] hubs = pywink . get_hubs ( ) [EOL] for hub in hubs : [EOL] if hub . device_manufacturer ( ) == [string] : [EOL] WINK_HUBS . append ( hub ) [EOL] [EOL] if WINK_HUBS : [EOL] hass . services . register ( DOMAIN , SERVICE_SET_PAIRING_MODE , set_pairing_mode , schema = SET_PAIRING_MODE_SCHEMA ) [EOL] [EOL] def service_handle ( service ) : [EOL] [docstring] [EOL] entity_ids = service . data . get ( [string] ) [EOL] all_sirens = [ ] [EOL] for switch in hass . data [ DOMAIN ] [ [string] ] [ [string] ] : [EOL] if isinstance ( switch , WinkSirenDevice ) : [EOL] all_sirens . append ( switch ) [EOL] sirens_to_set = [ ] [EOL] if entity_ids is None : [EOL] sirens_to_set = all_sirens [EOL] else : [EOL] for siren in all_sirens : [EOL] if siren . entity_id in entity_ids : [EOL] sirens_to_set . append ( siren ) [EOL] [EOL] for siren in sirens_to_set : [EOL] _man = siren . wink . device_manufacturer ( ) [EOL] if ( service . service != SERVICE_SET_AUTO_SHUTOFF and service . service != SERVICE_ENABLE_SIREN and _man not in ( [string] , [string] ) ) : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] if service . service == SERVICE_ENABLE_SIREN : [EOL] siren . wink . set_state ( service . data . get ( ATTR_ENABLED ) ) [EOL] elif service . service == SERVICE_SET_AUTO_SHUTOFF : [EOL] siren . wink . set_auto_shutoff ( service . data . get ( ATTR_AUTO_SHUTOFF ) ) [EOL] elif service . service == SERVICE_SET_CHIME_VOLUME : [EOL] siren . wink . set_chime_volume ( service . data . get ( ATTR_VOLUME ) ) [EOL] elif service . service == SERVICE_SET_SIREN_VOLUME : [EOL] siren . wink . set_siren_volume ( service . data . get ( ATTR_VOLUME ) ) [EOL] elif service . service == SERVICE_SET_SIREN_TONE : [EOL] siren . wink . set_siren_sound ( service . data . get ( ATTR_TONE ) ) [EOL] elif service . service == SERVICE_ENABLE_CHIME : [EOL] siren . wink . set_chime ( service . data . get ( ATTR_TONE ) ) [EOL] elif service . service == SERVICE_SIREN_STROBE_ENABLED : [EOL] siren . wink . set_siren_strobe_enabled ( service . data . get ( ATTR_ENABLED ) ) [EOL] elif service . service == SERVICE_CHIME_STROBE_ENABLED : [EOL] siren . wink . set_chime_strobe_enabled ( service . data . get ( ATTR_ENABLED ) ) [EOL] [EOL] [comment] [EOL] for wink_component in WINK_COMPONENTS : [EOL] hass . data [ DOMAIN ] [ [string] ] [ wink_component ] = [ ] [EOL] discovery . load_platform ( hass , wink_component , DOMAIN , { } , config ) [EOL] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass ) [EOL] [EOL] sirens = [ ] [EOL] has_dome_or_wink_siren = False [EOL] for siren in pywink . get_sirens ( ) : [EOL] _man = siren . device_manufacturer ( ) [EOL] if _man in ( [string] , [string] ) : [EOL] has_dome_or_wink_siren = True [EOL] _id = siren . object_id ( ) + siren . name ( ) [EOL] if _id not in hass . data [ DOMAIN ] [ [string] ] : [EOL] sirens . append ( WinkSirenDevice ( siren , hass ) ) [EOL] [EOL] if sirens : [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_SET_AUTO_SHUTOFF , service_handle , schema = SET_AUTO_SHUTOFF_SCHEMA ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_ENABLE_SIREN , service_handle , schema = ENABLED_SIREN_SCHEMA ) [EOL] [EOL] if has_dome_or_wink_siren : [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_SET_SIREN_TONE , service_handle , schema = SET_SIREN_TONE_SCHEMA ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_ENABLE_CHIME , service_handle , schema = SET_CHIME_MODE_SCHEMA ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_SET_SIREN_VOLUME , service_handle , schema = SET_VOLUME_SCHEMA ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_SET_CHIME_VOLUME , service_handle , schema = SET_VOLUME_SCHEMA ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_SIREN_STROBE_ENABLED , service_handle , schema = SET_STROBE_ENABLED_SCHEMA ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_CHIME_STROBE_ENABLED , service_handle , schema = SET_STROBE_ENABLED_SCHEMA ) [EOL] [EOL] component . add_entities ( sirens ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class WinkAuthCallbackView ( HomeAssistantView ) : [EOL] [docstring] [EOL] [EOL] url = [string] [EOL] name = [string] [EOL] requires_auth = False [EOL] [EOL] def __init__ ( self , config , config_file , request_token ) : [EOL] [docstring] [EOL] self . config = config [EOL] self . config_file = config_file [EOL] self . request_token = request_token [EOL] [EOL] @ callback def get ( self , request ) : [EOL] [docstring] [EOL] from aiohttp import web [EOL] [EOL] hass = request . app [ [string] ] [EOL] data = request . query [EOL] [EOL] response_message = [string] [EOL] html_response = [string] [EOL] [EOL] if data . get ( [string] ) is not None : [EOL] response = self . request_token ( data . get ( [string] ) , self . config_file [ [string] ] ) [EOL] [EOL] config_contents = { ATTR_ACCESS_TOKEN : response [ [string] ] , ATTR_REFRESH_TOKEN : response [ [string] ] , ATTR_CLIENT_ID : self . config_file [ [string] ] , ATTR_CLIENT_SECRET : self . config_file [ [string] ] } [EOL] save_json ( hass . config . path ( WINK_CONFIG_FILE ) , config_contents ) [EOL] [EOL] hass . async_add_job ( setup , hass , self . config ) [EOL] [EOL] return web . Response ( text = html_response . format ( response_message ) , content_type = [string] ) [EOL] [EOL] error_msg = [string] [EOL] _LOGGER . error ( error_msg ) [EOL] return web . Response ( text = html_response . format ( error_msg ) , content_type = [string] ) [EOL] [EOL] [EOL] class WinkDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , wink , hass ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . wink = wink [EOL] hass . data [ DOMAIN ] [ [string] ] . add_subscription ( self . wink . pubnub_channel , self . _pubnub_update ) [EOL] hass . data [ DOMAIN ] [ [string] ] . append ( self . wink . object_id ( ) + self . wink . name ( ) ) [EOL] [EOL] def _pubnub_update ( self , message ) : [EOL] try : [EOL] if message is None : [EOL] _LOGGER . error ( [string] [string] , self . name ) [EOL] self . schedule_update_ha_state ( True ) [EOL] else : [EOL] self . wink . pubnub_update ( message ) [EOL] self . schedule_update_ha_state ( ) [EOL] except ( ValueError , KeyError , AttributeError ) : [EOL] _LOGGER . error ( [string] [string] , self . name ) [EOL] self . schedule_update_ha_state ( True ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . wink . name ( ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . wink . available ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . wink . update_state ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return self . wink . pubnub_channel is None [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = { } [EOL] battery = self . _battery_level [EOL] if battery : [EOL] attributes [ ATTR_BATTERY_LEVEL ] = battery [EOL] man_dev_model = self . _manufacturer_device_model [EOL] if man_dev_model : [EOL] attributes [ [string] ] = man_dev_model [EOL] man_dev_id = self . _manufacturer_device_id [EOL] if man_dev_id : [EOL] attributes [ [string] ] = man_dev_id [EOL] dev_man = self . _device_manufacturer [EOL] if dev_man : [EOL] attributes [ [string] ] = dev_man [EOL] model_name = self . _model_name [EOL] if model_name : [EOL] attributes [ [string] ] = model_name [EOL] tamper = self . _tamper [EOL] if tamper is not None : [EOL] attributes [ [string] ] = tamper [EOL] return attributes [EOL] [EOL] @ property def _battery_level ( self ) : [EOL] [docstring] [EOL] if self . wink . battery_level ( ) is not None : [EOL] return self . wink . battery_level ( ) * [number] [EOL] [EOL] @ property def _manufacturer_device_model ( self ) : [EOL] [docstring] [EOL] return self . wink . manufacturer_device_model ( ) [EOL] [EOL] @ property def _manufacturer_device_id ( self ) : [EOL] [docstring] [EOL] return self . wink . manufacturer_device_id ( ) [EOL] [EOL] @ property def _device_manufacturer ( self ) : [EOL] [docstring] [EOL] return self . wink . device_manufacturer ( ) [EOL] [EOL] @ property def _model_name ( self ) : [EOL] [docstring] [EOL] return self . wink . model_name ( ) [EOL] [EOL] @ property def _tamper ( self ) : [EOL] [docstring] [EOL] if hasattr ( self . wink , [string] ) : [EOL] return self . wink . tamper_detected ( ) [EOL] return None [EOL] [EOL] [EOL] class WinkSirenDevice ( WinkDevice ) : [EOL] [docstring] [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . data [ DOMAIN ] [ [string] ] [ [string] ] . append ( self ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . wink . state ( ) : [EOL] return STATE_ON [EOL] return STATE_OFF [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = super ( WinkSirenDevice , self ) . device_state_attributes [EOL] [EOL] auto_shutoff = self . wink . auto_shutoff ( ) [EOL] if auto_shutoff is not None : [EOL] attributes [ [string] ] = auto_shutoff [EOL] [EOL] siren_volume = self . wink . siren_volume ( ) [EOL] if siren_volume is not None : [EOL] attributes [ [string] ] = siren_volume [EOL] [EOL] chime_volume = self . wink . chime_volume ( ) [EOL] if chime_volume is not None : [EOL] attributes [ [string] ] = chime_volume [EOL] [EOL] strobe_enabled = self . wink . strobe_enabled ( ) [EOL] if strobe_enabled is not None : [EOL] attributes [ [string] ] = strobe_enabled [EOL] [EOL] chime_strobe_enabled = self . wink . chime_strobe_enabled ( ) [EOL] if chime_strobe_enabled is not None : [EOL] attributes [ [string] ] = chime_strobe_enabled [EOL] [EOL] siren_sound = self . wink . siren_sound ( ) [EOL] if siren_sound is not None : [EOL] attributes [ [string] ] = siren_sound [EOL] [EOL] chime_mode = self . wink . chime_mode ( ) [EOL] if chime_mode is not None : [EOL] attributes [ [string] ] = chime_mode [EOL] [EOL] return attributes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Optional[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.int]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] ATTR_NODE_ID = [string] [EOL] ATTR_TARGET_NODE_ID = [string] [EOL] ATTR_ASSOCIATION = [string] [EOL] ATTR_INSTANCE = [string] [EOL] ATTR_GROUP = [string] [EOL] ATTR_VALUE_ID = [string] [EOL] ATTR_MESSAGES = [string] [EOL] ATTR_NAME = [string] [EOL] ATTR_RETURN_ROUTES = [string] [EOL] ATTR_SCENE_ID = [string] [EOL] ATTR_SCENE_DATA = [string] [EOL] ATTR_BASIC_LEVEL = [string] [EOL] ATTR_CONFIG_PARAMETER = [string] [EOL] ATTR_CONFIG_SIZE = [string] [EOL] ATTR_CONFIG_VALUE = [string] [EOL] ATTR_POLL_INTENSITY = [string] [EOL] ATTR_VALUE_INDEX = [string] [EOL] ATTR_VALUE_INSTANCE = [string] [EOL] NETWORK_READY_WAIT_SECS = [number] [EOL] NODE_READY_WAIT_SECS = [number] [EOL] [EOL] DISCOVERY_DEVICE = [string] [EOL] [EOL] DATA_DEVICES = [string] [EOL] DATA_NETWORK = [string] [EOL] DATA_ENTITY_VALUES = [string] [EOL] [EOL] SERVICE_CHANGE_ASSOCIATION = [string] [EOL] SERVICE_ADD_NODE = [string] [EOL] SERVICE_ADD_NODE_SECURE = [string] [EOL] SERVICE_REMOVE_NODE = [string] [EOL] SERVICE_CANCEL_COMMAND = [string] [EOL] SERVICE_HEAL_NETWORK = [string] [EOL] SERVICE_HEAL_NODE = [string] [EOL] SERVICE_SOFT_RESET = [string] [EOL] SERVICE_TEST_NODE = [string] [EOL] SERVICE_TEST_NETWORK = [string] [EOL] SERVICE_SET_CONFIG_PARAMETER = [string] [EOL] SERVICE_PRINT_CONFIG_PARAMETER = [string] [EOL] SERVICE_PRINT_NODE = [string] [EOL] SERVICE_REMOVE_FAILED_NODE = [string] [EOL] SERVICE_REPLACE_FAILED_NODE = [string] [EOL] SERVICE_SET_POLL_INTENSITY = [string] [EOL] SERVICE_SET_WAKEUP = [string] [EOL] SERVICE_STOP_NETWORK = [string] [EOL] SERVICE_START_NETWORK = [string] [EOL] SERVICE_RENAME_NODE = [string] [EOL] SERVICE_RENAME_VALUE = [string] [EOL] SERVICE_REFRESH_ENTITY = [string] [EOL] SERVICE_REFRESH_NODE = [string] [EOL] SERVICE_RESET_NODE_METERS = [string] [EOL] SERVICE_UPDATE_CONFIG = [string] [EOL] [EOL] EVENT_SCENE_ACTIVATED = [string] [EOL] EVENT_NODE_EVENT = [string] [EOL] EVENT_NETWORK_READY = [string] [EOL] EVENT_NETWORK_COMPLETE = [string] [EOL] EVENT_NETWORK_START = [string] [EOL] EVENT_NETWORK_STOP = [string] [EOL] [EOL] COMMAND_CLASS_ALARM = [number] [EOL] COMMAND_CLASS_ANTITHEFT = [number] [EOL] COMMAND_CLASS_APPLICATION_CAPABILITY = [number] [EOL] COMMAND_CLASS_APPLICATION_STATUS = [number] [EOL] COMMAND_CLASS_ASSOCIATION = [number] [EOL] COMMAND_CLASS_ASSOCIATION_COMMAND_CONFIGURATION = [number] [EOL] COMMAND_CLASS_ASSOCIATION_GRP_INFO = [number] [EOL] COMMAND_CLASS_BARRIER_OPERATOR = [number] [EOL] COMMAND_CLASS_BASIC = [number] [EOL] COMMAND_CLASS_BASIC_TARIFF_INFO = [number] [EOL] COMMAND_CLASS_BASIC_WINDOW_COVERING = [number] [EOL] COMMAND_CLASS_BATTERY = [number] [EOL] COMMAND_CLASS_CENTRAL_SCENE = [number] [EOL] COMMAND_CLASS_CLIMATE_CONTROL_SCHEDULE = [number] [EOL] COMMAND_CLASS_CLOCK = [number] [EOL] COMMAND_CLASS_CONFIGURATION = [number] [EOL] COMMAND_CLASS_CONTROLLER_REPLICATION = [number] [EOL] COMMAND_CLASS_CRC_16_ENCAP = [number] [EOL] COMMAND_CLASS_DCP_CONFIG = [number] [EOL] COMMAND_CLASS_DCP_MONITOR = [number] [EOL] COMMAND_CLASS_DEVICE_RESET_LOCALLY = [number] [EOL] COMMAND_CLASS_DOOR_LOCK = [number] [EOL] COMMAND_CLASS_DOOR_LOCK_LOGGING = [number] [EOL] COMMAND_CLASS_ENERGY_PRODUCTION = [number] [EOL] COMMAND_CLASS_ENTRY_CONTROL = [number] [EOL] COMMAND_CLASS_FIRMWARE_UPDATE_MD = [number] [EOL] COMMAND_CLASS_GEOGRAPHIC_LOCATION = [number] [EOL] COMMAND_CLASS_GROUPING_NAME = [number] [EOL] COMMAND_CLASS_HAIL = [number] [EOL] COMMAND_CLASS_HRV_CONTROL = [number] [EOL] COMMAND_CLASS_HRV_STATUS = [number] [EOL] COMMAND_CLASS_HUMIDITY_CONTROL_MODE = [number] [EOL] COMMAND_CLASS_HUMIDITY_CONTROL_OPERATING_STATE = [number] [EOL] COMMAND_CLASS_HUMIDITY_CONTROL_SETPOINT = [number] [EOL] COMMAND_CLASS_INDICATOR = [number] [EOL] COMMAND_CLASS_IP_ASSOCIATION = [number] [EOL] COMMAND_CLASS_IP_CONFIGURATION = [number] [EOL] COMMAND_CLASS_IRRIGATION = [number] [EOL] COMMAND_CLASS_LANGUAGE = [number] [EOL] COMMAND_CLASS_LOCK = [number] [EOL] COMMAND_CLASS_MAILBOX = [number] [EOL] COMMAND_CLASS_MANUFACTURER_PROPRIETARY = [number] [EOL] COMMAND_CLASS_MANUFACTURER_SPECIFIC = [number] [EOL] COMMAND_CLASS_MARK = [number] [EOL] COMMAND_CLASS_METER = [number] [EOL] COMMAND_CLASS_METER_PULSE = [number] [EOL] COMMAND_CLASS_METER_TBL_CONFIG = [number] [EOL] COMMAND_CLASS_METER_TBL_MONITOR = [number] [EOL] COMMAND_CLASS_METER_TBL_PUSH = [number] [EOL] COMMAND_CLASS_MTP_WINDOW_COVERING = [number] [EOL] COMMAND_CLASS_MULTI_CHANNEL = [number] [EOL] COMMAND_CLASS_MULTI_CHANNEL_ASSOCIATION = [number] [EOL] COMMAND_CLASS_MULTI_COMMAND = [number] [EOL] COMMAND_CLASS_NETWORK_MANAGEMENT_BASIC = [number] [EOL] COMMAND_CLASS_NETWORK_MANAGEMENT_INCLUSION = [number] [EOL] COMMAND_CLASS_NETWORK_MANAGEMENT_PRIMARY = [number] [EOL] COMMAND_CLASS_NETWORK_MANAGEMENT_PROXY = [number] [EOL] COMMAND_CLASS_NO_OPERATION = [number] [EOL] COMMAND_CLASS_NODE_NAMING = [number] [EOL] COMMAND_CLASS_NON_INTEROPERABLE = [number] [EOL] COMMAND_CLASS_NOTIFICATION = [number] [EOL] COMMAND_CLASS_POWERLEVEL = [number] [EOL] COMMAND_CLASS_PREPAYMENT = [number] [EOL] COMMAND_CLASS_PREPAYMENT_ENCAPSULATION = [number] [EOL] COMMAND_CLASS_PROPRIETARY = [number] [EOL] COMMAND_CLASS_PROTECTION = [number] [EOL] COMMAND_CLASS_RATE_TBL_CONFIG = [number] [EOL] COMMAND_CLASS_RATE_TBL_MONITOR = [number] [EOL] COMMAND_CLASS_REMOTE_ASSOCIATION_ACTIVATE = [number] [EOL] COMMAND_CLASS_REMOTE_ASSOCIATION = [number] [EOL] COMMAND_CLASS_SCENE_ACTIVATION = [number] [EOL] COMMAND_CLASS_SCENE_ACTUATOR_CONF = [number] [EOL] COMMAND_CLASS_SCENE_CONTROLLER_CONF = [number] [EOL] COMMAND_CLASS_SCHEDULE = [number] [EOL] COMMAND_CLASS_SCHEDULE_ENTRY_LOCK = [number] [EOL] COMMAND_CLASS_SCREEN_ATTRIBUTES = [number] [EOL] COMMAND_CLASS_SCREEN_MD = [number] [EOL] COMMAND_CLASS_SECURITY = [number] [EOL] COMMAND_CLASS_SECURITY_SCHEME0_MARK = [number] [EOL] COMMAND_CLASS_SENSOR_ALARM = [number] [EOL] COMMAND_CLASS_SENSOR_BINARY = [number] [EOL] COMMAND_CLASS_SENSOR_CONFIGURATION = [number] [EOL] COMMAND_CLASS_SENSOR_MULTILEVEL = [number] [EOL] COMMAND_CLASS_SILENCE_ALARM = [number] [EOL] COMMAND_CLASS_SIMPLE_AV_CONTROL = [number] [EOL] COMMAND_CLASS_SUPERVISION = [number] [EOL] COMMAND_CLASS_SWITCH_ALL = [number] [EOL] COMMAND_CLASS_SWITCH_BINARY = [number] [EOL] COMMAND_CLASS_SWITCH_COLOR = [number] [EOL] COMMAND_CLASS_SWITCH_MULTILEVEL = [number] [EOL] COMMAND_CLASS_SWITCH_TOGGLE_BINARY = [number] [EOL] COMMAND_CLASS_SWITCH_TOGGLE_MULTILEVEL = [number] [EOL] COMMAND_CLASS_TARIFF_TBL_CONFIG = [number] [EOL] COMMAND_CLASS_TARIFF_TBL_MONITOR = [number] [EOL] COMMAND_CLASS_THERMOSTAT_FAN_MODE = [number] [EOL] COMMAND_CLASS_THERMOSTAT_FAN_STATE = [number] [EOL] COMMAND_CLASS_THERMOSTAT_MODE = [number] [EOL] COMMAND_CLASS_THERMOSTAT_OPERATING_STATE = [number] [EOL] COMMAND_CLASS_THERMOSTAT_SETBACK = [number] [EOL] COMMAND_CLASS_THERMOSTAT_SETPOINT = [number] [EOL] COMMAND_CLASS_TIME = [number] [EOL] COMMAND_CLASS_TIME_PARAMETERS = [number] [EOL] COMMAND_CLASS_TRANSPORT_SERVICE = [number] [EOL] COMMAND_CLASS_USER_CODE = [number] [EOL] COMMAND_CLASS_VERSION = [number] [EOL] COMMAND_CLASS_WAKE_UP = [number] [EOL] COMMAND_CLASS_ZIP = [number] [EOL] COMMAND_CLASS_ZIP_NAMING = [number] [EOL] COMMAND_CLASS_ZIP_ND = [number] [EOL] COMMAND_CLASS_ZIP_6LOWPAN = [number] [EOL] COMMAND_CLASS_ZIP_GATEWAY = [number] [EOL] COMMAND_CLASS_ZIP_PORTAL = [number] [EOL] COMMAND_CLASS_ZWAVEPLUS_INFO = [number] [EOL] COMMAND_CLASS_WHATEVER = None [comment] [EOL] COMMAND_CLASS_WINDOW_COVERING = [number] [EOL] [EOL] GENERIC_TYPE_WHATEVER = None [comment] [EOL] SPECIFIC_TYPE_WHATEVER = None [comment] [EOL] SPECIFIC_TYPE_NOT_USED = [number] [comment] [EOL] [EOL] GENERIC_TYPE_AV_CONTROL_POINT = [number] [EOL] SPECIFIC_TYPE_DOORBELL = [number] [EOL] SPECIFIC_TYPE_SATELLITE_RECEIVER = [number] [EOL] SPECIFIC_TYPE_SATELLITE_RECEIVER_V2 = [number] [EOL] [EOL] GENERIC_TYPE_DISPLAY = [number] [EOL] SPECIFIC_TYPE_SIMPLE_DISPLAY = [number] [EOL] [EOL] GENERIC_TYPE_ENTRY_CONTROL = [number] [EOL] SPECIFIC_TYPE_DOOR_LOCK = [number] [EOL] SPECIFIC_TYPE_ADVANCED_DOOR_LOCK = [number] [EOL] SPECIFIC_TYPE_SECURE_KEYPAD_DOOR_LOCK = [number] [EOL] SPECIFIC_TYPE_SECURE_KEYPAD_DOOR_LOCK_DEADBOLT = [number] [EOL] SPECIFIC_TYPE_SECURE_DOOR = [number] [EOL] SPECIFIC_TYPE_SECURE_GATE = [number] [EOL] SPECIFIC_TYPE_SECURE_BARRIER_ADDON = [number] [EOL] SPECIFIC_TYPE_SECURE_BARRIER_OPEN_ONLY = [number] [EOL] SPECIFIC_TYPE_SECURE_BARRIER_CLOSE_ONLY = [number] [EOL] SPECIFIC_TYPE_SECURE_LOCKBOX = [number] [EOL] SPECIFIC_TYPE_SECURE_KEYPAD = [number] [EOL] [EOL] GENERIC_TYPE_GENERIC_CONTROLLER = [number] [EOL] SPECIFIC_TYPE_PORTABLE_CONTROLLER = [number] [EOL] SPECIFIC_TYPE_PORTABLE_SCENE_CONTROLLER = [number] [EOL] SPECIFIC_TYPE_PORTABLE_INSTALLER_TOOL = [number] [EOL] SPECIFIC_TYPE_REMOTE_CONTROL_AV = [number] [EOL] SPECIFIC_TYPE_REMOTE_CONTROL_SIMPLE = [number] [EOL] [EOL] GENERIC_TYPE_METER = [number] [EOL] SPECIFIC_TYPE_SIMPLE_METER = [number] [EOL] SPECIFIC_TYPE_ADV_ENERGY_CONTROL = [number] [EOL] SPECIFIC_TYPE_WHOLE_HOME_METER_SIMPLE = [number] [EOL] [EOL] GENERIC_TYPE_METER_PULSE = [number] [EOL] [EOL] GENERIC_TYPE_NON_INTEROPERABLE = [number] [EOL] [EOL] GENERIC_TYPE_REPEATER_SLAVE = [number] [EOL] SPECIFIC_TYPE_REPEATER_SLAVE = [number] [EOL] SPECIFIC_TYPE_VIRTUAL_NODE = [number] [EOL] [EOL] GENERIC_TYPE_SECURITY_PANEL = [number] [EOL] SPECIFIC_TYPE_ZONED_SECURITY_PANEL = [number] [EOL] [EOL] GENERIC_TYPE_SEMI_INTEROPERABLE = [number] [EOL] SPECIFIC_TYPE_ENERGY_PRODUCTION = [number] [EOL] [EOL] GENERIC_TYPE_SENSOR_ALARM = [number] [EOL] SPECIFIC_TYPE_ADV_ZENSOR_NET_ALARM_SENSOR = [number] [EOL] SPECIFIC_TYPE_ADV_ZENSOR_NET_SMOKE_SENSOR = [number] [EOL] SPECIFIC_TYPE_BASIC_ROUTING_ALARM_SENSOR = [number] [EOL] SPECIFIC_TYPE_BASIC_ROUTING_SMOKE_SENSOR = [number] [EOL] SPECIFIC_TYPE_BASIC_ZENSOR_NET_ALARM_SENSOR = [number] [EOL] SPECIFIC_TYPE_BASIC_ZENSOR_NET_SMOKE_SENSOR = [number] [EOL] SPECIFIC_TYPE_ROUTING_ALARM_SENSOR = [number] [EOL] SPECIFIC_TYPE_ROUTING_SMOKE_SENSOR = [number] [EOL] SPECIFIC_TYPE_ZENSOR_NET_ALARM_SENSOR = [number] [EOL] SPECIFIC_TYPE_ZENSOR_NET_SMOKE_SENSOR = [number] [EOL] SPECIFIC_TYPE_ALARM_SENSOR = [number] [EOL] [EOL] GENERIC_TYPE_SENSOR_BINARY = [number] [EOL] SPECIFIC_TYPE_ROUTING_SENSOR_BINARY = [number] [EOL] [EOL] GENERIC_TYPE_SENSOR_MULTILEVEL = [number] [EOL] SPECIFIC_TYPE_ROUTING_SENSOR_MULTILEVEL = [number] [EOL] SPECIFIC_TYPE_CHIMNEY_FAN = [number] [EOL] [EOL] GENERIC_TYPE_STATIC_CONTROLLER = [number] [EOL] SPECIFIC_TYPE_PC_CONTROLLER = [number] [EOL] SPECIFIC_TYPE_SCENE_CONTROLLER = [number] [EOL] SPECIFIC_TYPE_STATIC_INSTALLER_TOOL = [number] [EOL] SPECIFIC_TYPE_SET_TOP_BOX = [number] [EOL] SPECIFIC_TYPE_SUB_SYSTEM_CONTROLLER = [number] [EOL] SPECIFIC_TYPE_TV = [number] [EOL] SPECIFIC_TYPE_GATEWAY = [number] [EOL] [EOL] GENERIC_TYPE_SWITCH_BINARY = [number] [EOL] SPECIFIC_TYPE_POWER_SWITCH_BINARY = [number] [EOL] SPECIFIC_TYPE_SCENE_SWITCH_BINARY = [number] [EOL] SPECIFIC_TYPE_POWER_STRIP = [number] [EOL] SPECIFIC_TYPE_SIREN = [number] [EOL] SPECIFIC_TYPE_VALVE_OPEN_CLOSE = [number] [EOL] SPECIFIC_TYPE_COLOR_TUNABLE_BINARY = [number] [EOL] SPECIFIC_TYPE_IRRIGATION_CONTROLLER = [number] [EOL] [EOL] GENERIC_TYPE_SWITCH_MULTILEVEL = [number] [EOL] SPECIFIC_TYPE_CLASS_A_MOTOR_CONTROL = [number] [EOL] SPECIFIC_TYPE_CLASS_B_MOTOR_CONTROL = [number] [EOL] SPECIFIC_TYPE_CLASS_C_MOTOR_CONTROL = [number] [EOL] SPECIFIC_TYPE_MOTOR_MULTIPOSITION = [number] [EOL] SPECIFIC_TYPE_POWER_SWITCH_MULTILEVEL = [number] [EOL] SPECIFIC_TYPE_SCENE_SWITCH_MULTILEVEL = [number] [EOL] SPECIFIC_TYPE_FAN_SWITCH = [number] [EOL] SPECIFIC_TYPE_COLOR_TUNABLE_MULTILEVEL = [number] [EOL] [EOL] GENERIC_TYPE_SWITCH_REMOTE = [number] [EOL] SPECIFIC_TYPE_REMOTE_BINARY = [number] [EOL] SPECIFIC_TYPE_REMOTE_MULTILEVEL = [number] [EOL] SPECIFIC_TYPE_REMOTE_TOGGLE_BINARY = [number] [EOL] SPECIFIC_TYPE_REMOTE_TOGGLE_MULTILEVEL = [number] [EOL] [EOL] GENERIC_TYPE_SWITCH_TOGGLE = [number] [EOL] SPECIFIC_TYPE_SWITCH_TOGGLE_BINARY = [number] [EOL] SPECIFIC_TYPE_SWITCH_TOGGLE_MULTILEVEL = [number] [EOL] [EOL] GENERIC_TYPE_THERMOSTAT = [number] [EOL] SPECIFIC_TYPE_SETBACK_SCHEDULE_THERMOSTAT = [number] [EOL] SPECIFIC_TYPE_SETBACK_THERMOSTAT = [number] [EOL] SPECIFIC_TYPE_SETPOINT_THERMOSTAT = [number] [EOL] SPECIFIC_TYPE_THERMOSTAT_GENERAL = [number] [EOL] SPECIFIC_TYPE_THERMOSTAT_GENERAL_V2 = [number] [EOL] SPECIFIC_TYPE_THERMOSTAT_HEATING = [number] [EOL] [EOL] GENERIC_TYPE_VENTILATION = [number] [EOL] SPECIFIC_TYPE_RESIDENTIAL_HRV = [number] [EOL] [EOL] GENERIC_TYPE_WINDOWS_COVERING = [number] [EOL] SPECIFIC_TYPE_SIMPLE_WINDOW_COVERING = [number] [EOL] [EOL] GENERIC_TYPE_ZIP_NODE = [number] [EOL] SPECIFIC_TYPE_ZIP_ADV_NODE = [number] [EOL] SPECIFIC_TYPE_ZIP_TUN_NODE = [number] [EOL] [EOL] GENERIC_TYPE_WALL_CONTROLLER = [number] [EOL] SPECIFIC_TYPE_BASIC_WALL_CONTROLLER = [number] [EOL] [EOL] GENERIC_TYPE_NETWORK_EXTENDER = [number] [EOL] SPECIFIC_TYPE_SECURE_EXTENDER = [number] [EOL] [EOL] GENERIC_TYPE_APPLIANCE = [number] [EOL] SPECIFIC_TYPE_GENERAL_APPLIANCE = [number] [EOL] SPECIFIC_TYPE_KITCHEN_APPLIANCE = [number] [EOL] SPECIFIC_TYPE_LAUNDRY_APPLIANCE = [number] [EOL] [EOL] GENERIC_TYPE_SENSOR_NOTIFICATION = [number] [EOL] SPECIFIC_TYPE_NOTIFICATION_SENSOR = [number] [EOL] [EOL] GENRE_WHATEVER = None [EOL] GENRE_USER = [string] [EOL] GENRE_SYSTEM = [string] [EOL] [EOL] TYPE_WHATEVER = None [EOL] TYPE_BYTE = [string] [EOL] TYPE_BOOL = [string] [EOL] TYPE_DECIMAL = [string] [EOL] TYPE_INT = [string] [EOL] TYPE_LIST = [string] [EOL] TYPE_STRING = [string] [EOL] TYPE_BUTTON = [string] [EOL] [EOL] DISC_COMMAND_CLASS = [string] [EOL] DISC_COMPONENT = [string] [EOL] DISC_GENERIC_DEVICE_CLASS = [string] [EOL] DISC_GENRE = [string] [EOL] DISC_INDEX = [string] [EOL] DISC_INSTANCE = [string] [EOL] DISC_NODE_ID = [string] [EOL] DISC_OPTIONAL = [string] [EOL] DISC_PRIMARY = [string] [EOL] DISC_SCHEMAS = [string] [EOL] DISC_SPECIFIC_DEVICE_CLASS = [string] [EOL] DISC_TYPE = [string] [EOL] DISC_VALUES = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] INDEX_ALARM_TYPE = [number] [EOL] INDEX_ALARM_LEVEL = [number] [EOL] INDEX_ALARM_ACCESS_CONTROL = [number] [EOL] [EOL] [comment] [EOL] INDEX_BARRIER_OPERATOR_LABEL = [number] [EOL] [EOL] [comment] [EOL] INDEX_DOOR_LOCK_LOCK = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] INDEX_METER_POWER = [number] [EOL] INDEX_METER_RESET = [number] [EOL] [EOL] [comment] [EOL] INDEX_SENSOR_MULTILEVEL_TEMPERATURE = [number] [EOL] INDEX_SENSOR_MULTILEVEL_POWER = [number] [EOL] [EOL] [comment] [EOL] INDEX_SWITCH_COLOR_COLOR = [number] [EOL] INDEX_SWITCH_COLOR_CHANNELS = [number] [EOL] [EOL] [comment] [EOL] INDEX_SWITCH_MULTILEVEL_LEVEL = [number] [EOL] INDEX_SWITCH_MULTILEVEL_BRIGHT = [number] [EOL] INDEX_SWITCH_MULTILEVEL_DIM = [number] [EOL] INDEX_SWITCH_MULTILEVEL_DURATION = [number] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
from typing import Any , List , Tuple [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import struct [EOL] import binascii [EOL] from homeassistant . components . xiaomi_aqara import ( PY_XIAOMI_GATEWAY , XiaomiDevice ) [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_HS_COLOR , SUPPORT_BRIGHTNESS , SUPPORT_COLOR , Light ) [EOL] import homeassistant . util . color as color_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for ( _ , gateway ) in hass . data [ PY_XIAOMI_GATEWAY ] . gateways . items ( ) : [EOL] for device in gateway . devices [ [string] ] : [EOL] model = device [ [string] ] [EOL] if model in [ [string] , [string] ] : [EOL] devices . append ( XiaomiGatewayLight ( device , [string] , gateway ) ) [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class XiaomiGatewayLight ( XiaomiDevice , Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , name , xiaomi_hub ) : [EOL] [docstring] [EOL] self . _data_key = [string] [EOL] self . _hs = ( [number] , [number] ) [EOL] self . _brightness = [number] [EOL] [EOL] XiaomiDevice . __init__ ( self , device , name , xiaomi_hub ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def parse_data ( self , data , raw_data ) : [EOL] [docstring] [EOL] value = data . get ( self . _data_key ) [EOL] if value is None : [EOL] return False [EOL] [EOL] if value == [number] : [EOL] if self . _state : [EOL] self . _state = False [EOL] return True [EOL] [EOL] rgbhexstr = [string] % value [EOL] if len ( rgbhexstr ) > [number] : [EOL] _LOGGER . error ( [string] [string] , rgbhexstr ) [EOL] return False [EOL] [EOL] rgbhexstr = rgbhexstr . zfill ( [number] ) [EOL] rgbhex = bytes . fromhex ( rgbhexstr ) [EOL] rgba = struct . unpack ( [string] , rgbhex ) [EOL] brightness = rgba [ [number] ] [EOL] rgb = rgba [ [number] : ] [EOL] [EOL] self . _brightness = brightness [EOL] self . _hs = color_util . color_RGB_to_hs ( * rgb ) [EOL] self . _state = True [EOL] return True [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return int ( [number] * self . _brightness / [number] ) [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return self . _hs [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_BRIGHTNESS | SUPPORT_COLOR [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_HS_COLOR in kwargs : [EOL] self . _hs = kwargs [ ATTR_HS_COLOR ] [EOL] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = int ( [number] * kwargs [ ATTR_BRIGHTNESS ] / [number] ) [EOL] [EOL] rgb = color_util . color_hs_to_RGB ( * self . _hs ) [EOL] rgba = ( self . _brightness , ) + rgb [EOL] rgbhex = binascii . hexlify ( struct . pack ( [string] , * rgba ) ) . decode ( [string] ) [EOL] rgbhex = int ( rgbhex , [number] ) [EOL] [EOL] if self . _write_to_hub ( self . _sid , ** { self . _data_key : rgbhex } ) : [EOL] self . _state = True [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _write_to_hub ( self . _sid , ** { self . _data_key : [number] } ) : [EOL] self . _state = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $builtins.int$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,...]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import homeassistant [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_NAME , CONF_TYPE [EOL] from homeassistant . components . light import ( Light , ATTR_BRIGHTNESS , ATTR_HS_COLOR , ATTR_TRANSITION , SUPPORT_BRIGHTNESS , SUPPORT_COLOR , SUPPORT_TRANSITION , PLATFORM_SCHEMA ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . color as color_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_LEDS = [string] [EOL] CONF_DRIVER = [string] [EOL] CONF_PINS = [string] [EOL] CONF_FREQUENCY = [string] [EOL] CONF_ADDRESS = [string] [EOL] [EOL] CONF_DRIVER_GPIO = [string] [EOL] CONF_DRIVER_PCA9685 = [string] [EOL] CONF_DRIVER_TYPES = [ CONF_DRIVER_GPIO , CONF_DRIVER_PCA9685 ] [EOL] [EOL] CONF_LED_TYPE_SIMPLE = [string] [EOL] CONF_LED_TYPE_RGB = [string] [EOL] CONF_LED_TYPE_RGBW = [string] [EOL] CONF_LED_TYPES = [ CONF_LED_TYPE_SIMPLE , CONF_LED_TYPE_RGB , CONF_LED_TYPE_RGBW ] [EOL] [EOL] DEFAULT_COLOR = [ [number] , [number] ] [EOL] [EOL] SUPPORT_SIMPLE_LED = ( SUPPORT_BRIGHTNESS | SUPPORT_TRANSITION ) [EOL] SUPPORT_RGB_LED = ( SUPPORT_BRIGHTNESS | SUPPORT_COLOR | SUPPORT_TRANSITION ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_LEDS ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_DRIVER ) : vol . In ( CONF_DRIVER_TYPES ) , vol . Required ( CONF_PINS ) : vol . All ( cv . ensure_list , [ cv . positive_int ] ) , vol . Required ( CONF_TYPE ) : vol . In ( CONF_LED_TYPES ) , vol . Optional ( CONF_FREQUENCY ) : cv . positive_int , vol . Optional ( CONF_ADDRESS ) : cv . byte } ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pwmled . led import SimpleLed [EOL] from pwmled . led . rgb import RgbLed [EOL] from pwmled . led . rgbw import RgbwLed [EOL] from pwmled . driver . gpio import GpioDriver [EOL] from pwmled . driver . pca9685 import Pca9685Driver [EOL] [EOL] leds = [ ] [EOL] for led_conf in config [ CONF_LEDS ] : [EOL] driver_type = led_conf [ CONF_DRIVER ] [EOL] pins = led_conf [ CONF_PINS ] [EOL] opt_args = { } [EOL] if CONF_FREQUENCY in led_conf : [EOL] opt_args [ [string] ] = led_conf [ CONF_FREQUENCY ] [EOL] if driver_type == CONF_DRIVER_GPIO : [EOL] driver = GpioDriver ( pins , ** opt_args ) [EOL] elif driver_type == CONF_DRIVER_PCA9685 : [EOL] if CONF_ADDRESS in led_conf : [EOL] opt_args [ [string] ] = led_conf [ CONF_ADDRESS ] [EOL] driver = Pca9685Driver ( pins , ** opt_args ) [EOL] else : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] name = led_conf [ CONF_NAME ] [EOL] led_type = led_conf [ CONF_TYPE ] [EOL] if led_type == CONF_LED_TYPE_SIMPLE : [EOL] led = PwmSimpleLed ( SimpleLed ( driver ) , name ) [EOL] elif led_type == CONF_LED_TYPE_RGB : [EOL] led = PwmRgbLed ( RgbLed ( driver ) , name ) [EOL] elif led_type == CONF_LED_TYPE_RGBW : [EOL] led = PwmRgbLed ( RgbwLed ( driver ) , name ) [EOL] else : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] leds . append ( led ) [EOL] [EOL] add_entities ( leds ) [EOL] [EOL] [EOL] class PwmSimpleLed ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , led , name ) : [EOL] [docstring] [EOL] self . _led = led [EOL] self . _name = name [EOL] self . _is_on = False [EOL] self . _brightness = [number] [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _is_on [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_SIMPLE_LED [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition_time = kwargs [ ATTR_TRANSITION ] [EOL] self . _led . transition ( transition_time , is_on = True , brightness = _from_hass_brightness ( self . _brightness ) ) [EOL] else : [EOL] self . _led . set ( is_on = True , brightness = _from_hass_brightness ( self . _brightness ) ) [EOL] [EOL] self . _is_on = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . is_on : [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition_time = kwargs [ ATTR_TRANSITION ] [EOL] self . _led . transition ( transition_time , is_on = False ) [EOL] else : [EOL] self . _led . off ( ) [EOL] [EOL] self . _is_on = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] [EOL] class PwmRgbLed ( PwmSimpleLed ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , led , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( led , name ) [EOL] self . _color = DEFAULT_COLOR [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return self . _color [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_RGB_LED [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_HS_COLOR in kwargs : [EOL] self . _color = kwargs [ ATTR_HS_COLOR ] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition_time = kwargs [ ATTR_TRANSITION ] [EOL] self . _led . transition ( transition_time , is_on = True , brightness = _from_hass_brightness ( self . _brightness ) , color = _from_hass_color ( self . _color ) ) [EOL] else : [EOL] self . _led . set ( is_on = True , brightness = _from_hass_brightness ( self . _brightness ) , color = _from_hass_color ( self . _color ) ) [EOL] [EOL] self . _is_on = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] [EOL] def _from_hass_brightness ( brightness ) : [EOL] [docstring] [EOL] return brightness / [number] [EOL] [EOL] [EOL] def _from_hass_color ( color ) : [EOL] [docstring] [EOL] from pwmled import Color [EOL] rgb = color_util . color_hs_to_RGB ( * color ) [EOL] return Color ( * tuple ( rgb ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Dict , Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_HOST , CONF_PORT , CONF_TYPE , STATE_ON ) [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_EFFECT , ATTR_FLASH , ATTR_HS_COLOR , ATTR_TRANSITION , EFFECT_COLORLOOP , EFFECT_WHITE , FLASH_LONG , SUPPORT_BRIGHTNESS , SUPPORT_COLOR_TEMP , SUPPORT_EFFECT , SUPPORT_FLASH , SUPPORT_COLOR , SUPPORT_TRANSITION , Light , PLATFORM_SCHEMA ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util . color import ( color_temperature_mired_to_kelvin , color_hs_to_RGB ) [EOL] from homeassistant . helpers . restore_state import async_get_last_state [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_BRIDGES = [string] [EOL] CONF_GROUPS = [string] [EOL] CONF_NUMBER = [string] [EOL] CONF_VERSION = [string] [EOL] CONF_FADE = [string] [EOL] [EOL] DEFAULT_LED_TYPE = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_TRANSITION = [number] [EOL] DEFAULT_VERSION = [number] [EOL] DEFAULT_FADE = False [EOL] [EOL] LED_TYPE = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] EFFECT_NIGHT = [string] [EOL] [EOL] MIN_SATURATION = [number] [EOL] [EOL] WHITE = [ [number] , [number] ] [EOL] [EOL] SUPPORT_LIMITLESSLED_WHITE = ( SUPPORT_BRIGHTNESS | SUPPORT_COLOR_TEMP | SUPPORT_EFFECT | SUPPORT_TRANSITION ) [EOL] SUPPORT_LIMITLESSLED_DIMMER = ( SUPPORT_BRIGHTNESS | SUPPORT_TRANSITION ) [EOL] SUPPORT_LIMITLESSLED_RGB = ( SUPPORT_BRIGHTNESS | SUPPORT_EFFECT | SUPPORT_FLASH | SUPPORT_COLOR | SUPPORT_TRANSITION ) [EOL] SUPPORT_LIMITLESSLED_RGBWW = ( SUPPORT_BRIGHTNESS | SUPPORT_COLOR_TEMP | SUPPORT_EFFECT | SUPPORT_FLASH | SUPPORT_COLOR | SUPPORT_TRANSITION ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_BRIDGES ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_VERSION , default = DEFAULT_VERSION ) : cv . positive_int , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Required ( CONF_GROUPS ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_TYPE , default = DEFAULT_LED_TYPE ) : vol . In ( LED_TYPE ) , vol . Required ( CONF_NUMBER ) : cv . positive_int , vol . Optional ( CONF_FADE , default = DEFAULT_FADE ) : cv . boolean , } ] ) , } , ] ) , } ) [EOL] [EOL] [EOL] def rewrite_legacy ( config ) : [EOL] [docstring] [EOL] bridges = config . get ( CONF_BRIDGES , [ config ] ) [EOL] new_bridges = [ ] [EOL] for bridge_conf in bridges : [EOL] groups = [ ] [EOL] if [string] in bridge_conf : [EOL] groups = bridge_conf [ [string] ] [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] for i in range ( [number] , [number] ) : [EOL] name_key = [string] % i [EOL] if name_key in bridge_conf : [EOL] groups . append ( { [string] : i , [string] : bridge_conf . get ( [string] % i , DEFAULT_LED_TYPE ) , [string] : bridge_conf . get ( name_key ) } ) [EOL] new_bridges . append ( { [string] : bridge_conf . get ( CONF_HOST ) , [string] : bridge_conf . get ( CONF_VERSION ) , [string] : bridge_conf . get ( CONF_PORT ) , [string] : groups } ) [EOL] return { [string] : new_bridges } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from limitlessled . bridge import Bridge [EOL] [EOL] [comment] [EOL] [comment] [EOL] config = rewrite_legacy ( config ) [EOL] [EOL] [comment] [EOL] lights = [ ] [EOL] for bridge_conf in config . get ( CONF_BRIDGES ) : [EOL] bridge = Bridge ( bridge_conf . get ( CONF_HOST ) , port = bridge_conf . get ( CONF_PORT , DEFAULT_PORT ) , version = bridge_conf . get ( CONF_VERSION , DEFAULT_VERSION ) ) [EOL] for group_conf in bridge_conf . get ( CONF_GROUPS ) : [EOL] group = bridge . add_group ( group_conf . get ( CONF_NUMBER ) , group_conf . get ( CONF_NAME ) , group_conf . get ( CONF_TYPE , DEFAULT_LED_TYPE ) ) [EOL] lights . append ( LimitlessLEDGroup ( group , { [string] : group_conf [ CONF_FADE ] } ) ) [EOL] add_entities ( lights ) [EOL] [EOL] [EOL] def state ( new_state ) : [EOL] [docstring] [EOL] def decorator ( function ) : [EOL] [docstring] [EOL] [comment] [EOL] def wrapper ( self , ** kwargs ) : [EOL] [docstring] [EOL] from limitlessled . pipeline import Pipeline [EOL] pipeline = Pipeline ( ) [EOL] transition_time = DEFAULT_TRANSITION [EOL] if self . _effect == EFFECT_COLORLOOP : [EOL] self . group . stop ( ) [EOL] self . _effect = None [EOL] [comment] [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition_time = int ( kwargs [ ATTR_TRANSITION ] ) [EOL] [comment] [EOL] function ( self , transition_time , pipeline , ** kwargs ) [EOL] [comment] [EOL] self . _is_on = new_state [EOL] self . group . enqueue ( pipeline ) [EOL] self . schedule_update_ha_state ( ) [EOL] return wrapper [EOL] return decorator [EOL] [EOL] [EOL] class LimitlessLEDGroup ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , group , config ) : [EOL] [docstring] [EOL] from limitlessled . group . rgbw import RgbwGroup [EOL] from limitlessled . group . white import WhiteGroup [EOL] from limitlessled . group . dimmer import DimmerGroup [EOL] from limitlessled . group . rgbww import RgbwwGroup [EOL] if isinstance ( group , WhiteGroup ) : [EOL] self . _supported = SUPPORT_LIMITLESSLED_WHITE [EOL] self . _effect_list = [ EFFECT_NIGHT ] [EOL] elif isinstance ( group , DimmerGroup ) : [EOL] self . _supported = SUPPORT_LIMITLESSLED_DIMMER [EOL] self . _effect_list = [ ] [EOL] elif isinstance ( group , RgbwGroup ) : [EOL] self . _supported = SUPPORT_LIMITLESSLED_RGB [EOL] self . _effect_list = [ EFFECT_COLORLOOP , EFFECT_NIGHT , EFFECT_WHITE ] [EOL] elif isinstance ( group , RgbwwGroup ) : [EOL] self . _supported = SUPPORT_LIMITLESSLED_RGBWW [EOL] self . _effect_list = [ EFFECT_COLORLOOP , EFFECT_NIGHT , EFFECT_WHITE ] [EOL] [EOL] self . group = group [EOL] self . config = config [EOL] self . _is_on = False [EOL] self . _brightness = None [EOL] self . _temperature = None [EOL] self . _color = None [EOL] self . _effect = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] last_state = yield from async_get_last_state ( self . hass , self . entity_id ) [EOL] if last_state : [EOL] self . _is_on = ( last_state . state == STATE_ON ) [EOL] self . _brightness = last_state . attributes . get ( [string] ) [EOL] self . _temperature = last_state . attributes . get ( [string] ) [EOL] self . _color = last_state . attributes . get ( [string] ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . group . name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _is_on [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] if self . _effect == EFFECT_NIGHT : [EOL] return [number] [EOL] [EOL] return self . _brightness [EOL] [EOL] @ property def min_mireds ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] @ property def max_mireds ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] if self . hs_color is not None : [EOL] return None [EOL] return self . _temperature [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] if self . _effect == EFFECT_NIGHT : [EOL] return None [EOL] [EOL] if self . _color is None or self . _color [ [number] ] == [number] : [EOL] return None [EOL] [EOL] return self . _color [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported [EOL] [EOL] @ property def effect ( self ) : [EOL] [docstring] [EOL] return self . _effect [EOL] [EOL] @ property def effect_list ( self ) : [EOL] [docstring] [EOL] return self . _effect_list [EOL] [EOL] [comment] [EOL] @ state ( False ) def turn_off ( self , transition_time , pipeline , ** kwargs ) : [EOL] [docstring] [EOL] if self . config [ CONF_FADE ] : [EOL] pipeline . transition ( transition_time , brightness = [number] ) [EOL] pipeline . off ( ) [EOL] [EOL] [comment] [EOL] @ state ( True ) def turn_on ( self , transition_time , pipeline , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] if kwargs . get ( ATTR_EFFECT ) == EFFECT_NIGHT : [EOL] if EFFECT_NIGHT in self . _effect_list : [EOL] pipeline . night_light ( ) [EOL] self . _effect = EFFECT_NIGHT [EOL] return [EOL] [EOL] pipeline . on ( ) [EOL] [EOL] [comment] [EOL] args = { } [EOL] if self . config [ CONF_FADE ] and not self . is_on and self . _brightness : [EOL] args [ [string] ] = self . limitlessled_brightness ( ) [EOL] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] args [ [string] ] = self . limitlessled_brightness ( ) [EOL] [EOL] if ATTR_HS_COLOR in kwargs and self . _supported & SUPPORT_COLOR : [EOL] self . _color = kwargs [ ATTR_HS_COLOR ] [EOL] [comment] [EOL] if self . _color [ [number] ] < MIN_SATURATION : [EOL] pipeline . white ( ) [EOL] self . _color = WHITE [EOL] else : [EOL] args [ [string] ] = self . limitlessled_color ( ) [EOL] [EOL] if ATTR_COLOR_TEMP in kwargs : [EOL] if self . _supported & SUPPORT_COLOR : [EOL] pipeline . white ( ) [EOL] self . _color = WHITE [EOL] if self . _supported & SUPPORT_COLOR_TEMP : [EOL] self . _temperature = kwargs [ ATTR_COLOR_TEMP ] [EOL] args [ [string] ] = self . limitlessled_temperature ( ) [EOL] [EOL] if args : [EOL] pipeline . transition ( transition_time , ** args ) [EOL] [EOL] [comment] [EOL] if ATTR_FLASH in kwargs and self . _supported & SUPPORT_FLASH : [EOL] duration = [number] [EOL] if kwargs [ ATTR_FLASH ] == FLASH_LONG : [EOL] duration = [number] [EOL] pipeline . flash ( duration = duration ) [EOL] [EOL] [comment] [EOL] if ATTR_EFFECT in kwargs and self . _effect_list : [EOL] if kwargs [ ATTR_EFFECT ] == EFFECT_COLORLOOP : [EOL] from limitlessled . presets import COLORLOOP [EOL] self . _effect = EFFECT_COLORLOOP [EOL] pipeline . append ( COLORLOOP ) [EOL] if kwargs [ ATTR_EFFECT ] == EFFECT_WHITE : [EOL] pipeline . white ( ) [EOL] self . _color = WHITE [EOL] [EOL] def limitlessled_temperature ( self ) : [EOL] [docstring] [EOL] max_kelvin = color_temperature_mired_to_kelvin ( self . min_mireds ) [EOL] min_kelvin = color_temperature_mired_to_kelvin ( self . max_mireds ) [EOL] width = max_kelvin - min_kelvin [EOL] kelvin = color_temperature_mired_to_kelvin ( self . _temperature ) [EOL] temperature = ( kelvin - min_kelvin ) / width [EOL] return max ( [number] , min ( [number] , temperature ) ) [EOL] [EOL] def limitlessled_brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness / [number] [EOL] [EOL] def limitlessled_color ( self ) : [EOL] [docstring] [EOL] from limitlessled import Color [EOL] return Color ( * color_hs_to_RGB ( * tuple ( self . _color ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 $builtins.bool$ 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from datetime import timedelta [EOL] import requests [EOL] [EOL] from homeassistant import util [EOL] from homeassistant . components . light import ( Light , ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_HS_COLOR , ATTR_TRANSITION , SUPPORT_BRIGHTNESS , SUPPORT_COLOR_TEMP , SUPPORT_COLOR , SUPPORT_TRANSITION ) [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] import homeassistant . util . color as color_util [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( milliseconds = [number] ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_WEMO = ( SUPPORT_BRIGHTNESS | SUPPORT_COLOR_TEMP | SUPPORT_COLOR | SUPPORT_TRANSITION ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pywemo import discovery [EOL] [EOL] if discovery_info is not None : [EOL] location = discovery_info [ [string] ] [EOL] mac = discovery_info [ [string] ] [EOL] [EOL] try : [EOL] device = discovery . device_from_description ( location , mac ) [EOL] except ( requests . exceptions . ConnectionError , requests . exceptions . Timeout ) as err : [EOL] _LOGGER . error ( [string] , location , err ) [EOL] raise PlatformNotReady [EOL] [EOL] if device . model_name == [string] : [EOL] add_entities ( [ WemoDimmer ( device ) ] ) [EOL] else : [EOL] setup_bridge ( device , add_entities ) [EOL] [EOL] [EOL] def setup_bridge ( bridge , add_entities ) : [EOL] [docstring] [EOL] lights = { } [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update_lights ( ) : [EOL] [docstring] [EOL] bridge . bridge_update ( ) [EOL] [EOL] new_lights = [ ] [EOL] [EOL] for light_id , device in bridge . Lights . items ( ) : [EOL] if light_id not in lights : [EOL] lights [ light_id ] = WemoLight ( device , update_lights ) [EOL] new_lights . append ( lights [ light_id ] ) [EOL] [EOL] if new_lights : [EOL] add_entities ( new_lights ) [EOL] [EOL] update_lights ( ) [EOL] [EOL] [EOL] class WemoLight ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , update_lights ) : [EOL] [docstring] [EOL] self . light_id = device . name [EOL] self . wemo = device [EOL] self . update_lights = update_lights [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . wemo . uniqueID [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . wemo . name [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . wemo . state . get ( [string] , [number] ) [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] xy_color = self . wemo . state . get ( [string] ) [EOL] return color_util . color_xy_to_hs ( * xy_color ) if xy_color else None [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] return self . wemo . state . get ( [string] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . wemo . state [ [string] ] != [number] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_WEMO [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . wemo . state [ [string] ] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] transitiontime = int ( kwargs . get ( ATTR_TRANSITION , [number] ) ) [EOL] [EOL] hs_color = kwargs . get ( ATTR_HS_COLOR ) [EOL] [EOL] if hs_color is not None : [EOL] xy_color = color_util . color_hs_to_xy ( * hs_color ) [EOL] self . wemo . set_color ( xy_color , transition = transitiontime ) [EOL] [EOL] if ATTR_COLOR_TEMP in kwargs : [EOL] colortemp = kwargs [ ATTR_COLOR_TEMP ] [EOL] self . wemo . set_temperature ( mireds = colortemp , transition = transitiontime ) [EOL] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] brightness = kwargs . get ( ATTR_BRIGHTNESS , self . brightness or [number] ) [EOL] self . wemo . turn_on ( level = brightness , transition = transitiontime ) [EOL] else : [EOL] self . wemo . turn_on ( transition = transitiontime ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] transitiontime = int ( kwargs . get ( ATTR_TRANSITION , [number] ) ) [EOL] self . wemo . turn_off ( transition = transitiontime ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . update_lights ( no_throttle = True ) [EOL] [EOL] [EOL] class WemoDimmer ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] self . wemo = device [EOL] self . _brightness = None [EOL] self . _state = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] wemo = self . hass . components . wemo [EOL] [comment] [EOL] [comment] [EOL] yield from self . hass . async_add_job ( wemo . SUBSCRIPTION_REGISTRY . register , self . wemo ) [EOL] [comment] [EOL] wemo . SUBSCRIPTION_REGISTRY . on ( self . wemo , None , self . _update_callback ) [EOL] [EOL] def _update_callback ( self , _device , _type , _params ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , _device ) [EOL] updated = self . wemo . subscription_update ( _type , _params ) [EOL] self . _update ( force_update = ( not updated ) ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . wemo . serialnumber [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . wemo . name [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def _update ( self , force_update = True ) : [EOL] [docstring] [EOL] try : [EOL] self . _state = self . wemo . get_state ( force_update ) [EOL] wemobrightness = int ( self . wemo . get_brightness ( force_update ) ) [EOL] self . _brightness = int ( ( wemobrightness * [number] ) / [number] ) [EOL] except AttributeError as err : [EOL] _LOGGER . warning ( [string] , self . name , err ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . wemo . on ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] brightness = int ( ( brightness / [number] ) * [number] ) [EOL] else : [EOL] brightness = [number] [EOL] self . wemo . set_brightness ( brightness ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . wemo . off ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import homeassistant [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import datetime [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . const import ( CONF_API_KEY , CONF_NAME , EVENT_HOMEASSISTANT_START , ATTR_LATITUDE , ATTR_LONGITUDE , CONF_MODE ) [EOL] from homeassistant . util import Throttle [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers import location [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DESTINATION = [string] [EOL] CONF_OPTIONS = [string] [EOL] CONF_ORIGIN = [string] [EOL] CONF_TRAVEL_MODE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] ALL_LANGUAGES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] AVOID = [ [string] , [string] , [string] , [string] ] [EOL] TRANSIT_PREFS = [ [string] , [string] ] [EOL] TRANSPORT_TYPE = [ [string] , [string] , [string] , [string] , [string] ] [EOL] TRAVEL_MODE = [ [string] , [string] , [string] , [string] ] [EOL] TRAVEL_MODEL = [ [string] , [string] , [string] ] [EOL] UNITS = [ [string] , [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_DESTINATION ) : cv . string , vol . Required ( CONF_ORIGIN ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_TRAVEL_MODE ) : vol . In ( TRAVEL_MODE ) , vol . Optional ( CONF_OPTIONS , default = { CONF_MODE : [string] } ) : vol . All ( dict , vol . Schema ( { vol . Optional ( CONF_MODE , default = [string] ) : vol . In ( TRAVEL_MODE ) , vol . Optional ( [string] ) : vol . In ( ALL_LANGUAGES ) , vol . Optional ( [string] ) : vol . In ( AVOID ) , vol . Optional ( [string] ) : vol . In ( UNITS ) , vol . Exclusive ( [string] , [string] ) : cv . string , vol . Exclusive ( [string] , [string] ) : cv . string , vol . Optional ( [string] ) : vol . In ( TRAVEL_MODEL ) , vol . Optional ( [string] ) : vol . In ( TRANSPORT_TYPE ) , vol . Optional ( [string] ) : vol . In ( TRANSIT_PREFS ) } ) ) } ) [EOL] [EOL] TRACKABLE_DOMAINS = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def convert_time_to_utc ( timestr ) : [EOL] [docstring] [EOL] combined = datetime . combine ( dt_util . start_of_local_day ( ) , dt_util . parse_time ( timestr ) ) [EOL] if combined < datetime . now ( ) : [EOL] combined = combined + timedelta ( days = [number] ) [EOL] return dt_util . as_timestamp ( combined ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities_callback , discovery_info = None ) : [EOL] [docstring] [EOL] def run_setup ( event ) : [EOL] [docstring] [EOL] options = config . get ( CONF_OPTIONS ) [EOL] [EOL] if options . get ( [string] ) is None : [EOL] options [ [string] ] = hass . config . units . name [EOL] [EOL] travel_mode = config . get ( CONF_TRAVEL_MODE ) [EOL] mode = options . get ( CONF_MODE ) [EOL] [EOL] if travel_mode is not None : [EOL] wstr = ( [string] [string] ) [EOL] _LOGGER . warning ( wstr ) [EOL] if mode is None : [EOL] options [ CONF_MODE ] = travel_mode [EOL] [EOL] titled_mode = options . get ( CONF_MODE ) . title ( ) [EOL] formatted_name = [string] . format ( DEFAULT_NAME , titled_mode ) [EOL] name = config . get ( CONF_NAME , formatted_name ) [EOL] api_key = config . get ( CONF_API_KEY ) [EOL] origin = config . get ( CONF_ORIGIN ) [EOL] destination = config . get ( CONF_DESTINATION ) [EOL] [EOL] sensor = GoogleTravelTimeSensor ( hass , name , api_key , origin , destination , options ) [EOL] [EOL] if sensor . valid_api_connection : [EOL] add_entities_callback ( [ sensor ] ) [EOL] [EOL] [comment] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , run_setup ) [EOL] [EOL] [EOL] class GoogleTravelTimeSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , api_key , origin , destination , options ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _name = name [EOL] self . _options = options [EOL] self . _unit_of_measurement = [string] [EOL] self . _matrix = None [EOL] self . valid_api_connection = True [EOL] [EOL] [comment] [EOL] if origin . split ( [string] , [number] ) [ [number] ] in TRACKABLE_DOMAINS : [EOL] self . _origin_entity_id = origin [EOL] else : [EOL] self . _origin = origin [EOL] [EOL] if destination . split ( [string] , [number] ) [ [number] ] in TRACKABLE_DOMAINS : [EOL] self . _destination_entity_id = destination [EOL] else : [EOL] self . _destination = destination [EOL] [EOL] import googlemaps [EOL] self . _client = googlemaps . Client ( api_key , timeout = [number] ) [EOL] try : [EOL] self . update ( ) [EOL] except googlemaps . exceptions . ApiError as exp : [EOL] _LOGGER . error ( exp ) [EOL] self . valid_api_connection = False [EOL] return [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _matrix is None : [EOL] return None [EOL] [EOL] _data = self . _matrix [ [string] ] [ [number] ] [ [string] ] [ [number] ] [EOL] if [string] in _data : [EOL] return round ( _data [ [string] ] [ [string] ] / [number] ) [EOL] if [string] in _data : [EOL] return round ( _data [ [string] ] [ [string] ] / [number] ) [EOL] return None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _matrix is None : [EOL] return None [EOL] [EOL] res = self . _matrix . copy ( ) [EOL] res . update ( self . _options ) [EOL] del res [ [string] ] [EOL] _data = self . _matrix [ [string] ] [ [number] ] [ [string] ] [ [number] ] [EOL] if [string] in _data : [EOL] res [ [string] ] = _data [ [string] ] [ [string] ] [EOL] if [string] in _data : [EOL] res [ [string] ] = _data [ [string] ] [ [string] ] [EOL] if [string] in _data : [EOL] res [ [string] ] = _data [ [string] ] [ [string] ] [EOL] return res [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] options_copy = self . _options . copy ( ) [EOL] dtime = options_copy . get ( [string] ) [EOL] atime = options_copy . get ( [string] ) [EOL] if dtime is not None and [string] in dtime : [EOL] options_copy [ [string] ] = convert_time_to_utc ( dtime ) [EOL] elif dtime is not None : [EOL] options_copy [ [string] ] = dtime [EOL] elif atime is None : [EOL] options_copy [ [string] ] = [string] [EOL] [EOL] if atime is not None and [string] in atime : [EOL] options_copy [ [string] ] = convert_time_to_utc ( atime ) [EOL] elif atime is not None : [EOL] options_copy [ [string] ] = atime [EOL] [EOL] [comment] [EOL] if hasattr ( self , [string] ) : [EOL] self . _origin = self . _get_location_from_entity ( self . _origin_entity_id ) [EOL] [EOL] if hasattr ( self , [string] ) : [EOL] self . _destination = self . _get_location_from_entity ( self . _destination_entity_id ) [EOL] [EOL] self . _destination = self . _resolve_zone ( self . _destination ) [EOL] self . _origin = self . _resolve_zone ( self . _origin ) [EOL] [EOL] if self . _destination is not None and self . _origin is not None : [EOL] self . _matrix = self . _client . distance_matrix ( self . _origin , self . _destination , ** options_copy ) [EOL] [EOL] def _get_location_from_entity ( self , entity_id ) : [EOL] [docstring] [EOL] entity = self . _hass . states . get ( entity_id ) [EOL] [EOL] if entity is None : [EOL] _LOGGER . error ( [string] , entity_id ) [EOL] self . valid_api_connection = False [EOL] return None [EOL] [EOL] [comment] [EOL] if location . has_location ( entity ) : [EOL] return self . _get_location_from_attributes ( entity ) [EOL] [EOL] [comment] [EOL] zone_entity = self . _hass . states . get ( [string] % entity . state ) [EOL] if location . has_location ( zone_entity ) : [EOL] _LOGGER . debug ( [string] , entity_id , zone_entity . entity_id ) [EOL] return self . _get_location_from_attributes ( zone_entity ) [EOL] [EOL] [comment] [EOL] if entity_id . startswith ( [string] ) : [EOL] return entity . state [EOL] [EOL] [comment] [EOL] return None [EOL] [EOL] @ staticmethod def _get_location_from_attributes ( entity ) : [EOL] [docstring] [EOL] attr = entity . attributes [EOL] return [string] % ( attr . get ( ATTR_LATITUDE ) , attr . get ( ATTR_LONGITUDE ) ) [EOL] [EOL] def _resolve_zone ( self , friendly_name ) : [EOL] entities = self . _hass . states . all ( ) [EOL] for entity in entities : [EOL] if entity . domain == [string] and entity . name == friendly_name : [EOL] return self . _get_location_from_attributes ( entity ) [EOL] [EOL] return friendly_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import requests [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_API_KEY , CONF_NAME , ATTR_ATTRIBUTION ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] _RESOURCE = [string] [EOL] [EOL] CONF_ZPID = [string] [EOL] CONF_ATTRIBUTION = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] NAME = [string] [EOL] ZESTIMATE = [string] . format ( DEFAULT_NAME , NAME ) [EOL] [EOL] ICON = [string] [EOL] [EOL] ATTR_AMOUNT = [string] [EOL] ATTR_CHANGE = [string] [EOL] ATTR_CURRENCY = [string] [EOL] ATTR_LAST_UPDATED = [string] [EOL] ATTR_VAL_HI = [string] [EOL] ATTR_VAL_LOW = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_ZPID ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] [comment] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] properties = config [ CONF_ZPID ] [EOL] params = { [string] : config [ CONF_API_KEY ] } [EOL] [EOL] sensors = [ ] [EOL] for zpid in properties : [EOL] params [ [string] ] = zpid [EOL] sensors . append ( ZestimateDataSensor ( name , params ) ) [EOL] add_entities ( sensors , True ) [EOL] [EOL] [EOL] class ZestimateDataSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , params ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . params = params [EOL] self . data = None [EOL] self . address = None [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] try : [EOL] return round ( float ( self . _state ) , [number] ) [EOL] except ValueError : [EOL] return None [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = { } [EOL] if self . data is not None : [EOL] attributes = self . data [EOL] attributes [ [string] ] = self . address [EOL] attributes [ ATTR_ATTRIBUTION ] = CONF_ATTRIBUTION [EOL] return attributes [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] import xmltodict [EOL] try : [EOL] response = requests . get ( _RESOURCE , params = self . params , timeout = [number] ) [EOL] data = response . content . decode ( [string] ) [EOL] data_dict = xmltodict . parse ( data ) . get ( ZESTIMATE ) [EOL] error_code = int ( data_dict [ [string] ] [ [string] ] ) [EOL] if error_code != [number] : [EOL] _LOGGER . error ( [string] , data_dict [ [string] ] [ [string] ] ) [EOL] return [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] , _RESOURCE ) [EOL] return [EOL] data = data_dict [ [string] ] [ NAME ] [EOL] details = { } [EOL] details [ ATTR_AMOUNT ] = data [ [string] ] [ [string] ] [EOL] details [ ATTR_CURRENCY ] = data [ [string] ] [ [string] ] [EOL] details [ ATTR_LAST_UPDATED ] = data [ [string] ] [EOL] details [ ATTR_CHANGE ] = int ( data [ [string] ] [ [string] ] ) [EOL] details [ ATTR_VAL_HI ] = int ( data [ [string] ] [ [string] ] [ [string] ] ) [EOL] details [ ATTR_VAL_LOW ] = int ( data [ [string] ] [ [string] ] [ [string] ] ) [EOL] self . address = data_dict [ [string] ] [ [string] ] [ [string] ] [EOL] self . data = details [EOL] if self . data is not None : [EOL] self . _state = self . data [ ATTR_AMOUNT ] [EOL] else : [EOL] self . _state = None [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Optional , Union , List , Any , Dict [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_API_KEY , CONF_MONITORED_CONDITIONS , CONF_NAME , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_FORECAST = [string] [EOL] CONF_LANGUAGE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_FORECAST , default = False ) : cv . boolean , vol . Optional ( CONF_LANGUAGE ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pyowm import OWM [EOL] [EOL] if None in ( hass . config . latitude , hass . config . longitude ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] SENSOR_TYPES [ [string] ] [ [number] ] = hass . config . units . temperature_unit [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] forecast = config . get ( CONF_FORECAST ) [EOL] language = config . get ( CONF_LANGUAGE ) [EOL] if isinstance ( language , str ) : [EOL] language = language . lower ( ) [ : [number] ] [EOL] [EOL] owm = OWM ( API_key = config . get ( CONF_API_KEY ) , language = language ) [EOL] [EOL] if not owm : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] data = WeatherData ( owm , forecast , hass . config . latitude , hass . config . longitude ) [EOL] dev = [ ] [EOL] for variable in config [ CONF_MONITORED_CONDITIONS ] : [EOL] dev . append ( OpenWeatherMapSensor ( name , data , variable , SENSOR_TYPES [ variable ] [ [number] ] ) ) [EOL] [EOL] if forecast : [EOL] SENSOR_TYPES [ [string] ] = [ [string] , None ] [EOL] dev . append ( OpenWeatherMapSensor ( name , data , [string] , SENSOR_TYPES [ [string] ] [ [number] ] ) ) [EOL] [EOL] add_entities ( dev , True ) [EOL] [EOL] [EOL] class OpenWeatherMapSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , weather_data , sensor_type , temp_unit ) : [EOL] [docstring] [EOL] self . client_name = name [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . owa_client = weather_data [EOL] self . temp_unit = temp_unit [EOL] self . type = sensor_type [EOL] self . _state = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from pyowm . exceptions . api_call_error import APICallError [EOL] [EOL] try : [EOL] self . owa_client . update ( ) [EOL] except APICallError : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] data = self . owa_client . data [EOL] fc_data = self . owa_client . fc_data [EOL] [EOL] if data is None : [EOL] return [EOL] [EOL] if self . type == [string] : [EOL] self . _state = data . get_detailed_status ( ) [EOL] elif self . type == [string] : [EOL] if self . temp_unit == TEMP_CELSIUS : [EOL] self . _state = round ( data . get_temperature ( [string] ) [ [string] ] , [number] ) [EOL] elif self . temp_unit == TEMP_FAHRENHEIT : [EOL] self . _state = round ( data . get_temperature ( [string] ) [ [string] ] , [number] ) [EOL] else : [EOL] self . _state = round ( data . get_temperature ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_wind ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_wind ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_humidity ( ) , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_pressure ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = data . get_clouds ( ) [EOL] elif self . type == [string] : [EOL] if data . get_rain ( ) : [EOL] self . _state = round ( data . get_rain ( ) [ [string] ] , [number] ) [EOL] self . _unit_of_measurement = [string] [EOL] else : [EOL] self . _state = [string] [EOL] self . _unit_of_measurement = [string] [EOL] elif self . type == [string] : [EOL] if data . get_snow ( ) : [EOL] self . _state = round ( data . get_snow ( ) , [number] ) [EOL] self . _unit_of_measurement = [string] [EOL] else : [EOL] self . _state = [string] [EOL] self . _unit_of_measurement = [string] [EOL] elif self . type == [string] : [EOL] if fc_data is None : [EOL] return [EOL] self . _state = fc_data . get_weathers ( ) [ [number] ] . get_detailed_status ( ) [EOL] [EOL] [EOL] class WeatherData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , owm , forecast , latitude , longitude ) : [EOL] [docstring] [EOL] self . owm = owm [EOL] self . forecast = forecast [EOL] self . latitude = latitude [EOL] self . longitude = longitude [EOL] self . data = None [EOL] self . fc_data = None [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] from pyowm . exceptions . api_call_error import APICallError [EOL] [EOL] try : [EOL] obs = self . owm . weather_at_coords ( self . latitude , self . longitude ) [EOL] except ( APICallError , TypeError ) : [EOL] _LOGGER . error ( [string] [string] ) [EOL] obs = None [EOL] [EOL] if obs is None : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] [EOL] self . data = obs . get_weather ( ) [EOL] [EOL] if self . forecast == [number] : [EOL] try : [EOL] obs = self . owm . three_hours_forecast_at_coords ( self . latitude , self . longitude ) [EOL] self . fc_data = obs . get_forecast ( ) [EOL] except ( ConnectionResetError , TypeError ) : [EOL] _LOGGER . warning ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . blink import DOMAIN [EOL] from homeassistant . const import TEMP_FAHRENHEIT [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , TEMP_FAHRENHEIT ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] data = hass . data [ DOMAIN ] . blink [EOL] devs = list ( ) [EOL] index = [number] [EOL] for name in data . cameras : [EOL] devs . append ( BlinkSensor ( name , [string] , index , data ) ) [EOL] devs . append ( BlinkSensor ( name , [string] , index , data ) ) [EOL] devs . append ( BlinkSensor ( name , [string] , index , data ) ) [EOL] index += [number] [EOL] [EOL] add_entities ( devs , True ) [EOL] [EOL] [EOL] class BlinkSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , sensor_type , index , data ) : [EOL] [docstring] [EOL] self . _name = [string] + name + [string] + SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _camera_name = name [EOL] self . _type = sensor_type [EOL] self . data = data [EOL] self . index = index [EOL] self . _state = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] camera = self . data . cameras [ self . _camera_name ] [EOL] if self . _type == [string] : [EOL] self . _state = camera . temperature [EOL] elif self . _type == [string] : [EOL] self . _state = camera . battery_string [EOL] elif self . _type == [string] : [EOL] self . _state = camera . notifications [EOL] else : [EOL] self . _state = None [EOL] _LOGGER . warning ( [string] , self . name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components import sleepiq [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] ICON = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] data = sleepiq . DATA [EOL] data . update ( ) [EOL] [EOL] dev = list ( ) [EOL] for bed_id , _ in data . beds . items ( ) : [EOL] for side in sleepiq . SIDES : [EOL] dev . append ( SleepNumberSensor ( data , bed_id , side ) ) [EOL] add_entities ( dev ) [EOL] [EOL] [EOL] class SleepNumberSensor ( sleepiq . SleepIQSensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sleepiq_data , bed_id , side ) : [EOL] [docstring] [EOL] sleepiq . SleepIQSensor . __init__ ( self , sleepiq_data , bed_id , side ) [EOL] [EOL] self . _state = None [EOL] self . type = sleepiq . SLEEP_NUMBER [EOL] self . _name = sleepiq . SENSOR_TYPES [ self . type ] [EOL] [EOL] self . update ( ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] sleepiq . SleepIQSensor . update ( self ) [EOL] self . _state = self . side . sleep_number [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_API_KEY , CONF_SCAN_INTERVAL , CONF_MONITORED_CONDITIONS , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_BRANCH = [string] [EOL] CONF_REPOSITORY = [string] [EOL] [EOL] DEFAULT_BRANCH_NAME = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] [comment] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , } [EOL] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Required ( CONF_BRANCH , default = DEFAULT_BRANCH_NAME ) : cv . string , vol . Optional ( CONF_REPOSITORY , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_SCAN_INTERVAL , default = SCAN_INTERVAL ) : cv . time_period , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from travispy import TravisPy [EOL] from travispy . errors import TravisError [EOL] [EOL] token = config . get ( CONF_API_KEY ) [EOL] repositories = config . get ( CONF_REPOSITORY ) [EOL] branch = config . get ( CONF_BRANCH ) [EOL] [EOL] try : [EOL] travis = TravisPy . github_auth ( token ) [EOL] user = travis . user ( ) [EOL] [EOL] except TravisError as ex : [EOL] _LOGGER . error ( [string] , str ( ex ) ) [EOL] hass . components . persistent_notification . create ( [string] [string] [string] . format ( ex ) , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] return False [EOL] [EOL] sensors = [ ] [EOL] [EOL] [comment] [EOL] if not repositories : [EOL] all_repos = travis . repos ( member = user . login ) [EOL] repositories = [ repo . slug for repo in all_repos ] [EOL] [EOL] for repo in repositories : [EOL] if [string] not in repo : [EOL] repo = [string] . format ( user . login , repo ) [EOL] [EOL] for sensor_type in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] sensors . append ( TravisCISensor ( travis , repo , user , branch , sensor_type ) ) [EOL] [EOL] add_entities ( sensors , True ) [EOL] return True [EOL] [EOL] [EOL] class TravisCISensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , repo_name , user , branch , sensor_type ) : [EOL] [docstring] [EOL] self . _build = None [EOL] self . _sensor_type = sensor_type [EOL] self . _data = data [EOL] self . _repo_name = repo_name [EOL] self . _user = user [EOL] self . _branch = branch [EOL] self . _state = STATE_UNKNOWN [EOL] self . _name = [string] . format ( self . _repo_name , SENSOR_TYPES [ self . _sensor_type ] [ [number] ] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES [ self . _sensor_type ] [ [number] ] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { } [EOL] attrs [ ATTR_ATTRIBUTION ] = CONF_ATTRIBUTION [EOL] [EOL] if self . _build and self . _state is not STATE_UNKNOWN : [EOL] if self . _user and self . _sensor_type == [string] : [EOL] attrs [ [string] ] = self . _user . name [EOL] attrs [ [string] ] = self . _user . email [EOL] else : [EOL] attrs [ [string] ] = self . _build . commit . committer_name [EOL] attrs [ [string] ] = self . _build . commit . committer_email [EOL] attrs [ [string] ] = self . _build . commit . branch [EOL] attrs [ [string] ] = self . _build . commit . committed_at [EOL] attrs [ [string] ] = self . _build . commit . sha [EOL] [EOL] return attrs [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES [ self . _sensor_type ] [ [number] ] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] [EOL] repo = self . _data . repo ( self . _repo_name ) [EOL] self . _build = self . _data . build ( repo . last_build_id ) [EOL] [EOL] if self . _build : [EOL] if self . _sensor_type == [string] : [EOL] branch_stats = self . _data . branch ( self . _branch , self . _repo_name ) [EOL] self . _state = branch_stats . state [EOL] [EOL] else : [EOL] param = self . _sensor_type . replace ( [string] , [string] ) [EOL] self . _state = getattr ( self . _build , param ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Optional , Union , List , Any , Dict [EOL] import logging [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_DISPLAY_OPTIONS , ATTR_ATTRIBUTION , CONF_CURRENCY ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] [EOL] DEFAULT_CURRENCY = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] OPTION_TYPES = { [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DISPLAY_OPTIONS , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . In ( OPTION_TYPES ) ] ) , vol . Optional ( CONF_CURRENCY , default = DEFAULT_CURRENCY ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from blockchain import exchangerates [EOL] [EOL] currency = config . get ( CONF_CURRENCY ) [EOL] [EOL] if currency not in exchangerates . get_ticker ( ) : [EOL] _LOGGER . warning ( [string] , currency ) [EOL] currency = DEFAULT_CURRENCY [EOL] [EOL] data = BitcoinData ( ) [EOL] dev = [ ] [EOL] for variable in config [ CONF_DISPLAY_OPTIONS ] : [EOL] dev . append ( BitcoinSensor ( data , variable , currency ) ) [EOL] [EOL] add_entities ( dev , True ) [EOL] [EOL] [EOL] class BitcoinSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , option_type , currency ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _name = OPTION_TYPES [ option_type ] [ [number] ] [EOL] self . _unit_of_measurement = OPTION_TYPES [ option_type ] [ [number] ] [EOL] self . _currency = currency [EOL] self . type = option_type [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] stats = self . data . stats [EOL] ticker = self . data . ticker [EOL] [EOL] if self . type == [string] : [EOL] self . _state = ticker [ self . _currency ] . p15min [EOL] self . _unit_of_measurement = self . _currency [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . trade_volume_btc ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . miners_revenue_usd ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . btc_mined * [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . trade_volume_usd ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . difficulty ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . minutes_between_blocks ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . number_of_transactions ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . hash_rate * [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = stats . timestamp [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . mined_blocks ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . blocks_size ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . total_fees_btc * [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . total_btc_sent * [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . estimated_btc_sent * [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . total_btc * [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . total_blocks ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . next_retarget ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . estimated_transaction_volume_usd ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . miners_revenue_btc * [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( stats . market_price_usd ) [EOL] [EOL] [EOL] class BitcoinData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . stats = None [EOL] self . ticker = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from blockchain import statistics , exchangerates [EOL] [EOL] self . stats = statistics . get ( ) [EOL] self . ticker = exchangerates . get_ticker ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import homeassistant [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import asyncio [EOL] import logging [EOL] [EOL] from datetime import timedelta [EOL] [EOL] import re [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_SCAN_INTERVAL , CONF_FILE_PATH ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_JAILS = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_LOG = [string] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] STATE_CURRENT_BANS = [string] [EOL] STATE_ALL_BANS = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_JAILS ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) ) , vol . Optional ( CONF_FILE_PATH ) : cv . isfile , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] jails = config . get ( CONF_JAILS ) [EOL] scan_interval = config . get ( CONF_SCAN_INTERVAL ) [EOL] log_file = config . get ( CONF_FILE_PATH , DEFAULT_LOG ) [EOL] [EOL] device_list = [ ] [EOL] log_parser = BanLogParser ( scan_interval , log_file ) [EOL] for jail in jails : [EOL] device_list . append ( BanSensor ( name , jail , log_parser ) ) [EOL] [EOL] async_add_entities ( device_list , True ) [EOL] [EOL] [EOL] class BanSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , jail , log_parser ) : [EOL] [docstring] [EOL] self . _name = [string] . format ( name , jail ) [EOL] self . jail = jail [EOL] self . ban_dict = { STATE_CURRENT_BANS : [ ] , STATE_ALL_BANS : [ ] } [EOL] self . last_ban = None [EOL] self . log_parser = log_parser [EOL] self . log_parser . ip_regex [ self . jail ] = re . compile ( [string] . format ( re . escape ( self . jail ) ) ) [EOL] _LOGGER . debug ( [string] , self . jail ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] return self . ban_dict [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . last_ban [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . log_parser . timer ( ) : [EOL] self . log_parser . read_log ( self . jail ) [EOL] [EOL] if self . log_parser . data : [EOL] for entry in self . log_parser . data : [EOL] _LOGGER . debug ( entry ) [EOL] current_ip = entry [ [number] ] [EOL] if entry [ [number] ] == [string] : [EOL] if current_ip not in self . ban_dict [ STATE_CURRENT_BANS ] : [EOL] self . ban_dict [ STATE_CURRENT_BANS ] . append ( current_ip ) [EOL] if current_ip not in self . ban_dict [ STATE_ALL_BANS ] : [EOL] self . ban_dict [ STATE_ALL_BANS ] . append ( current_ip ) [EOL] if len ( self . ban_dict [ STATE_ALL_BANS ] ) > [number] : [EOL] self . ban_dict [ STATE_ALL_BANS ] . pop ( [number] ) [EOL] [EOL] elif entry [ [number] ] == [string] : [EOL] if current_ip in self . ban_dict [ STATE_CURRENT_BANS ] : [EOL] self . ban_dict [ STATE_CURRENT_BANS ] . remove ( current_ip ) [EOL] [EOL] if self . ban_dict [ STATE_CURRENT_BANS ] : [EOL] self . last_ban = self . ban_dict [ STATE_CURRENT_BANS ] [ - [number] ] [EOL] else : [EOL] self . last_ban = [string] [EOL] [EOL] [EOL] class BanLogParser : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , interval , log_file ) : [EOL] [docstring] [EOL] self . interval = interval [EOL] self . log_file = log_file [EOL] self . data = list ( ) [EOL] self . last_update = dt_util . now ( ) [EOL] self . ip_regex = dict ( ) [EOL] [EOL] def timer ( self ) : [EOL] [docstring] [EOL] boundary = dt_util . now ( ) - self . interval [EOL] if boundary > self . last_update : [EOL] self . last_update = dt_util . now ( ) [EOL] return True [EOL] return False [EOL] [EOL] def read_log ( self , jail ) : [EOL] [docstring] [EOL] self . data = list ( ) [EOL] try : [EOL] with open ( self . log_file , [string] , encoding = [string] ) as file_data : [EOL] self . data = self . ip_regex [ jail ] . findall ( file_data . read ( ) ) [EOL] [EOL] except ( IndexError , FileNotFoundError , IsADirectoryError , UnboundLocalError ) : [EOL] _LOGGER . warning ( [string] , os . path . basename ( self . log_file ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from homeassistant import config_entries [EOL] from homeassistant . helpers import config_entry_flow [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config . get ( DOMAIN ) [EOL] [EOL] hass . data [ DOMAIN ] = conf or { } [EOL] [EOL] if conf is not None : [EOL] hass . async_create_task ( hass . config_entries . flow . async_init ( DOMAIN , context = { [string] : config_entries . SOURCE_IMPORT } ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry ) : [EOL] [docstring] [EOL] hass . async_create_task ( hass . config_entries . async_forward_entry_setup ( entry , [string] ) ) [EOL] return True [EOL] [EOL] [EOL] async def _async_has_devices ( hass ) : [EOL] [docstring] [EOL] from pychromecast . discovery import discover_chromecasts [EOL] [EOL] return await hass . async_add_executor_job ( discover_chromecasts ) [EOL] [EOL] [EOL] config_entry_flow . register_discovery_flow ( DOMAIN , [string] , _async_has_devices ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import typing [EOL] import subprocess [EOL] import logging [EOL] import io [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import io [EOL] import os [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . core import split_entity_id [EOL] from homeassistant . components . image_processing import ( PLATFORM_SCHEMA , ImageProcessingEntity , CONF_SOURCE , CONF_ENTITY_ID , CONF_NAME ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DIGITS = [string] [EOL] CONF_EXTRA_ARGUMENTS = [string] [EOL] CONF_HEIGHT = [string] [EOL] CONF_ROTATE = [string] [EOL] CONF_SSOCR_BIN = [string] [EOL] CONF_THRESHOLD = [string] [EOL] CONF_WIDTH = [string] [EOL] CONF_X_POS = [string] [EOL] CONF_Y_POS = [string] [EOL] [EOL] DEFAULT_BINARY = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_EXTRA_ARGUMENTS , default = [string] ) : cv . string , vol . Optional ( CONF_DIGITS ) : cv . positive_int , vol . Optional ( CONF_HEIGHT , default = [number] ) : cv . positive_int , vol . Optional ( CONF_SSOCR_BIN , default = DEFAULT_BINARY ) : cv . string , vol . Optional ( CONF_THRESHOLD , default = [number] ) : cv . positive_int , vol . Optional ( CONF_ROTATE , default = [number] ) : cv . positive_int , vol . Optional ( CONF_WIDTH , default = [number] ) : cv . positive_int , vol . Optional ( CONF_X_POS , default = [number] ) : cv . string , vol . Optional ( CONF_Y_POS , default = [number] ) : cv . positive_int , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] entities = [ ] [EOL] for camera in config [ CONF_SOURCE ] : [EOL] entities . append ( ImageProcessingSsocr ( hass , camera [ CONF_ENTITY_ID ] , config , camera . get ( CONF_NAME ) ) ) [EOL] [EOL] async_add_entities ( entities ) [EOL] [EOL] [EOL] class ImageProcessingSsocr ( ImageProcessingEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , camera_entity , config , name ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _camera_entity = camera_entity [EOL] if name : [EOL] self . _name = name [EOL] else : [EOL] self . _name = [string] . format ( split_entity_id ( camera_entity ) [ [number] ] ) [EOL] self . _state = None [EOL] [EOL] self . filepath = os . path . join ( self . hass . config . config_dir , [string] ) [EOL] crop = [ [string] , str ( config [ CONF_X_POS ] ) , str ( config [ CONF_Y_POS ] ) , str ( config [ CONF_WIDTH ] ) , str ( config [ CONF_HEIGHT ] ) ] [EOL] digits = [ [string] , str ( config . get ( CONF_DIGITS , - [number] ) ) ] [EOL] rotate = [ [string] , str ( config [ CONF_ROTATE ] ) ] [EOL] threshold = [ [string] , str ( config [ CONF_THRESHOLD ] ) ] [EOL] extra_arguments = config [ CONF_EXTRA_ARGUMENTS ] . split ( [string] ) [EOL] [EOL] self . _command = [ config [ CONF_SSOCR_BIN ] ] + crop + digits + threshold + rotate + extra_arguments [EOL] self . _command . append ( self . filepath ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def camera_entity ( self ) : [EOL] [docstring] [EOL] return self . _camera_entity [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def process_image ( self , image ) : [EOL] [docstring] [EOL] from PIL import Image [EOL] import subprocess [EOL] [EOL] stream = io . BytesIO ( image ) [EOL] img = Image . open ( stream ) [EOL] img . save ( self . filepath , [string] ) [EOL] [EOL] ocr = subprocess . Popen ( self . _command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] out = ocr . communicate ( ) [EOL] if out [ [number] ] != [string] : [EOL] self . _state = out [ [number] ] . strip ( ) . decode ( [string] ) [EOL] else : [EOL] self . _state = None [EOL] _LOGGER . warning ( [string] , out [ [number] ] . strip ( ) . decode ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.BytesIO$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor . metoffice import ( CONDITION_CLASSES , CONF_ATTRIBUTION , MetOfficeCurrentData ) [EOL] from homeassistant . components . weather import PLATFORM_SCHEMA , WeatherEntity [EOL] from homeassistant . const import ( CONF_API_KEY , CONF_LATITUDE , CONF_LONGITUDE , CONF_NAME , TEMP_CELSIUS ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Inclusive ( CONF_LATITUDE , [string] , [string] ) : cv . latitude , vol . Inclusive ( CONF_LONGITUDE , [string] , [string] ) : cv . longitude , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import datapoint as dp [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] datapoint = dp . connection ( api_key = config . get ( CONF_API_KEY ) ) [EOL] [EOL] latitude = config . get ( CONF_LATITUDE , hass . config . latitude ) [EOL] longitude = config . get ( CONF_LONGITUDE , hass . config . longitude ) [EOL] [EOL] if None in ( latitude , longitude ) : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] try : [EOL] site = datapoint . get_nearest_site ( latitude = latitude , longitude = longitude ) [EOL] except dp . exceptions . APIException as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] return [EOL] [EOL] if not site : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] data = MetOfficeCurrentData ( hass , datapoint , site ) [EOL] try : [EOL] data . update ( ) [EOL] except ( ValueError , dp . exceptions . APIException ) as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] return [EOL] [EOL] add_entities ( [ MetOfficeWeather ( site , data , name ) ] , True ) [EOL] [EOL] [EOL] class MetOfficeWeather ( WeatherEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , site , data , name ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . data = data [EOL] self . site = site [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name , self . site . name ) [EOL] [EOL] @ property def condition ( self ) : [EOL] [docstring] [EOL] return [ k for k , v in CONDITION_CLASSES . items ( ) if self . data . data . weather . value in v ] [ [number] ] [EOL] [EOL] @ property def temperature ( self ) : [EOL] [docstring] [EOL] return self . data . data . temperature . value [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def pressure ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ property def humidity ( self ) : [EOL] [docstring] [EOL] return self . data . data . humidity . value [EOL] [EOL] @ property def wind_speed ( self ) : [EOL] [docstring] [EOL] return self . data . data . wind_speed . value [EOL] [EOL] @ property def wind_bearing ( self ) : [EOL] [docstring] [EOL] return self . data . data . wind_direction . value [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] return CONF_ATTRIBUTION [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PREVIOUS_TRACK , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_SELECT_SOURCE , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_STEP , SUPPORT_PLAY , SUPPORT_VOLUME_SET , MediaPlayerDevice , PLATFORM_SCHEMA ) [EOL] [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , STATE_OFF , STATE_ON , STATE_UNKNOWN , CONF_PORT , CONF_USERNAME , CONF_PASSWORD , CONF_TIMEOUT ) [EOL] [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_USERNAME = [string] [EOL] DEFAULT_PASSWORD = [string] [EOL] DEFAULT_TIMEOUT = [number] [EOL] DEFAULT_RETRIES = [number] [EOL] [EOL] SUPPORT_SHARPTV = SUPPORT_TURN_OFF | SUPPORT_NEXT_TRACK | SUPPORT_PAUSE | SUPPORT_PREVIOUS_TRACK | SUPPORT_SELECT_SOURCE | SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_STEP | SUPPORT_VOLUME_SET | SUPPORT_PLAY [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_USERNAME , default = DEFAULT_USERNAME ) : cv . string , vol . Optional ( CONF_PASSWORD , default = DEFAULT_PASSWORD ) : cv . string , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . string , vol . Optional ( [string] , default = DEFAULT_RETRIES ) : cv . string , vol . Optional ( [string] , default = False ) : cv . boolean , } ) [EOL] [EOL] SOURCES = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import sharp_aquos_rc [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] port = config . get ( CONF_PORT ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] power_on_enabled = config . get ( [string] ) [EOL] [EOL] if discovery_info : [EOL] _LOGGER . debug ( [string] , discovery_info ) [EOL] vals = discovery_info . split ( [string] ) [EOL] if len ( vals ) > [number] : [EOL] port = vals [ [number] ] [EOL] [EOL] host = vals [ [number] ] [EOL] remote = sharp_aquos_rc . TV ( host , port , username , password , timeout = [number] ) [EOL] add_entities ( [ SharpAquosTVDevice ( name , remote , power_on_enabled ) ] ) [EOL] return True [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] remote = sharp_aquos_rc . TV ( host , port , username , password , [number] , [number] ) [EOL] [EOL] add_entities ( [ SharpAquosTVDevice ( name , remote , power_on_enabled ) ] ) [EOL] return True [EOL] [EOL] [EOL] def _retry ( func ) : [EOL] [docstring] [EOL] def wrapper ( obj , * args , ** kwargs ) : [EOL] [docstring] [EOL] update_retries = [number] [EOL] while update_retries > [number] : [EOL] try : [EOL] func ( obj , * args , ** kwargs ) [EOL] break [EOL] except ( OSError , TypeError , ValueError ) : [EOL] update_retries -= [number] [EOL] if update_retries == [number] : [EOL] obj . set_state ( STATE_OFF ) [EOL] return wrapper [EOL] [EOL] [EOL] class SharpAquosTVDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , remote , power_on_enabled = False ) : [EOL] [docstring] [EOL] global SUPPORT_SHARPTV [EOL] self . _power_on_enabled = power_on_enabled [EOL] if self . _power_on_enabled : [EOL] SUPPORT_SHARPTV = SUPPORT_SHARPTV | SUPPORT_TURN_ON [EOL] [comment] [EOL] self . _name = name [EOL] [comment] [EOL] self . _muted = False [EOL] self . _state = STATE_UNKNOWN [EOL] self . _remote = remote [EOL] self . _volume = [number] [EOL] self . _source = None [EOL] self . _source_list = list ( SOURCES . values ( ) ) [EOL] [EOL] def set_state ( self , state ) : [EOL] [docstring] [EOL] self . _state = state [EOL] [EOL] @ _retry def update ( self ) : [EOL] [docstring] [EOL] if self . _remote . power ( ) == [number] : [EOL] self . _state = STATE_ON [EOL] else : [EOL] self . _state = STATE_OFF [EOL] [comment] [EOL] if self . _power_on_enabled : [EOL] self . _remote . power_on_command_settings ( [number] ) [EOL] else : [EOL] self . _remote . power_on_command_settings ( [number] ) [EOL] [comment] [EOL] if self . _remote . mute ( ) == [number] : [EOL] self . _muted = False [EOL] else : [EOL] self . _muted = True [EOL] [comment] [EOL] self . _source = SOURCES . get ( self . _remote . input ( ) ) [EOL] [comment] [EOL] self . _volume = self . _remote . volume ( ) / [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _source [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _source_list [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _muted [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_SHARPTV [EOL] [EOL] @ _retry def turn_off ( self ) : [EOL] [docstring] [EOL] self . _remote . power ( [number] ) [EOL] [EOL] @ _retry def volume_up ( self ) : [EOL] [docstring] [EOL] self . _remote . volume ( int ( self . _volume * [number] ) + [number] ) [EOL] [EOL] @ _retry def volume_down ( self ) : [EOL] [docstring] [EOL] self . _remote . volume ( int ( self . _volume * [number] ) - [number] ) [EOL] [EOL] @ _retry def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . _remote . volume ( int ( volume * [number] ) ) [EOL] [EOL] @ _retry def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . _remote . mute ( [number] ) [EOL] [EOL] @ _retry def turn_on ( self ) : [EOL] [docstring] [EOL] self . _remote . power ( [number] ) [EOL] [EOL] @ _retry def media_play_pause ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] @ _retry def media_play ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] @ _retry def media_pause ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] @ _retry def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] @ _retry def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] for key , value in SOURCES . items ( ) : [EOL] if source == value : [EOL] self . _remote . input ( key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( MediaPlayerDevice , PLATFORM_SCHEMA , MEDIA_TYPE_CHANNEL , SUPPORT_NEXT_TRACK , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_PAUSE , SUPPORT_PLAY , SUPPORT_PLAY_MEDIA , SUPPORT_PREVIOUS_TRACK ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , STATE_OFF , STATE_PAUSED , STATE_PLAYING ) [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant import util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] SUPPORT_HORIZON = SUPPORT_NEXT_TRACK | SUPPORT_PAUSE | SUPPORT_PLAY | SUPPORT_PLAY_MEDIA | SUPPORT_PREVIOUS_TRACK | SUPPORT_TURN_ON | SUPPORT_TURN_OFF [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from einder import Client , keys [EOL] from einder . exceptions import AuthenticationError [EOL] [EOL] host = config [ CONF_HOST ] [EOL] name = config [ CONF_NAME ] [EOL] port = config [ CONF_PORT ] [EOL] [EOL] try : [EOL] client = Client ( host , port = port ) [EOL] except AuthenticationError as msg : [EOL] _LOGGER . error ( [string] , name , host , msg ) [EOL] return [EOL] except OSError as msg : [EOL] [comment] [EOL] _LOGGER . error ( [string] , name , host , msg ) [EOL] raise PlatformNotReady [EOL] [EOL] _LOGGER . info ( [string] , name , host ) [EOL] [EOL] add_entities ( [ HorizonDevice ( client , name , keys ) ] , True ) [EOL] [EOL] [EOL] class HorizonDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , name , keys ) : [EOL] [docstring] [EOL] self . _client = client [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _keys = keys [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_HORIZON [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update ( self ) : [EOL] [docstring] [EOL] if self . _client . is_powered_on ( ) : [EOL] self . _state = STATE_PLAYING [EOL] else : [EOL] self . _state = STATE_OFF [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] if self . _state is STATE_OFF : [EOL] self . _send_key ( self . _keys . POWER ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] if self . _state is not STATE_OFF : [EOL] self . _send_key ( self . _keys . POWER ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . CHAN_DOWN ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . CHAN_UP ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . PAUSE ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . PAUSE ) [EOL] self . _state = STATE_PAUSED [EOL] [EOL] def media_play_pause ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . PAUSE ) [EOL] if self . _state == STATE_PAUSED : [EOL] self . _state = STATE_PLAYING [EOL] else : [EOL] self . _state = STATE_PAUSED [EOL] [EOL] def play_media ( self , media_type , media_id , ** kwargs ) : [EOL] [docstring] [EOL] if MEDIA_TYPE_CHANNEL == media_type : [EOL] try : [EOL] self . _select_channel ( int ( media_id ) ) [EOL] self . _state = STATE_PLAYING [EOL] except ValueError : [EOL] _LOGGER . error ( [string] , media_id ) [EOL] else : [EOL] _LOGGER . error ( [string] , media_type , MEDIA_TYPE_CHANNEL ) [EOL] [EOL] def _select_channel ( self , channel ) : [EOL] [docstring] [EOL] self . _send ( channel = channel ) [EOL] [EOL] def _send_key ( self , key ) : [EOL] [docstring] [EOL] self . _send ( key = key ) [EOL] [EOL] def _send ( self , key = None , channel = None ) : [EOL] [docstring] [EOL] from einder . exceptions import AuthenticationError [EOL] [EOL] try : [EOL] if key : [EOL] self . _client . send_key ( key ) [EOL] elif channel : [EOL] self . _client . select_channel ( channel ) [EOL] except OSError as msg : [EOL] _LOGGER . error ( [string] , self . _name , msg ) [EOL] [EOL] [comment] [EOL] self . _client . disconnect ( ) [EOL] [EOL] try : [EOL] self . _client . connect ( ) [EOL] self . _client . authorize ( ) [EOL] except AuthenticationError as msg : [EOL] _LOGGER . error ( [string] , self . _name , msg ) [EOL] return [EOL] except OSError as msg : [EOL] [comment] [EOL] _LOGGER . error ( [string] , self . _name , msg ) [EOL] return [EOL] [EOL] self . _send ( key = key , channel = channel ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import socket [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( PLATFORM_SCHEMA , MediaPlayerDevice , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_NEXT_TRACK , SUPPORT_PREVIOUS_TRACK , SUPPORT_SELECT_SOURCE , SUPPORT_PLAY , SUPPORT_PAUSE ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , STATE_OFF , STATE_ON , STATE_PAUSED , STATE_PLAYING ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DATA_KNOWN_DEVICES = [string] [EOL] [EOL] SUPPORT_ZIGGO = SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_NEXT_TRACK | SUPPORT_PAUSE | SUPPORT_PREVIOUS_TRACK | SUPPORT_SELECT_SOURCE | SUPPORT_PLAY [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from ziggo_mediabox_xl import ZiggoMediaboxXL [EOL] [EOL] hass . data [ DATA_KNOWN_DEVICES ] = known_devices = set ( ) [EOL] [EOL] [comment] [EOL] if config . get ( CONF_HOST ) is not None : [EOL] host = config . get ( CONF_HOST ) [EOL] name = config . get ( CONF_NAME ) [EOL] elif discovery_info is not None : [EOL] host = discovery_info . get ( [string] ) [EOL] name = discovery_info . get ( [string] ) [EOL] else : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] hosts = [ ] [EOL] ip_addr = socket . gethostbyname ( host ) [EOL] if ip_addr not in known_devices : [EOL] try : [EOL] mediabox = ZiggoMediaboxXL ( ip_addr ) [EOL] if mediabox . test_connection ( ) : [EOL] hosts . append ( ZiggoMediaboxXLDevice ( mediabox , host , name ) ) [EOL] known_devices . add ( ip_addr ) [EOL] else : [EOL] _LOGGER . error ( [string] , host ) [EOL] except socket . error as error : [EOL] _LOGGER . error ( [string] , host , error ) [EOL] else : [EOL] _LOGGER . info ( [string] , host ) [EOL] add_entities ( hosts , True ) [EOL] [EOL] [EOL] class ZiggoMediaboxXLDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mediabox , host , name ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _mediabox = mediabox [EOL] self . _host = host [EOL] self . _name = name [EOL] self . _state = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] if self . _mediabox . turned_on ( ) : [EOL] if self . _state != STATE_PAUSED : [EOL] self . _state = STATE_PLAYING [EOL] else : [EOL] self . _state = STATE_OFF [EOL] except socket . error : [EOL] _LOGGER . error ( [string] , self . _host ) [EOL] [EOL] def send_keys ( self , keys ) : [EOL] [docstring] [EOL] try : [EOL] self . _mediabox . send_keys ( keys ) [EOL] except socket . error : [EOL] _LOGGER . error ( [string] , self . _host ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return [ self . _mediabox . channels ( ) [ c ] for c in sorted ( self . _mediabox . channels ( ) . keys ( ) ) ] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_ZIGGO [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . send_keys ( [ [string] ] ) [EOL] self . _state = STATE_ON [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . send_keys ( [ [string] ] ) [EOL] self . _state = STATE_OFF [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . send_keys ( [ [string] ] ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . send_keys ( [ [string] ] ) [EOL] self . _state = STATE_PAUSED [EOL] [EOL] def media_play_pause ( self ) : [EOL] [docstring] [EOL] self . send_keys ( [ [string] ] ) [EOL] if self . _state == STATE_PAUSED : [EOL] self . _state = STATE_PLAYING [EOL] else : [EOL] self . _state = STATE_PAUSED [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . send_keys ( [ [string] ] ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . send_keys ( [ [string] ] ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] if str ( source ) . isdigit ( ) : [EOL] digits = str ( source ) [EOL] else : [EOL] digits = next ( ( key for key , value in self . _mediabox . channels ( ) . items ( ) if value == source ) , None ) [EOL] if digits is None : [EOL] return [EOL] [EOL] self . send_keys ( [ [string] . format ( digit ) for digit in str ( digits ) ] ) [EOL] self . _state = STATE_PLAYING [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , List [EOL] import typing [EOL] import logging [EOL] import subprocess [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import socket [EOL] from datetime import timedelta [EOL] [EOL] import sys [EOL] [EOL] import subprocess [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PREVIOUS_TRACK , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_PLAY , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_STEP , SUPPORT_PLAY_MEDIA , MediaPlayerDevice , PLATFORM_SCHEMA , MEDIA_TYPE_CHANNEL ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , STATE_OFF , STATE_ON , STATE_UNKNOWN , CONF_PORT , CONF_MAC ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_TIMEOUT = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_TIMEOUT = [number] [EOL] KEY_PRESS_TIMEOUT = [number] [EOL] [EOL] KNOWN_DEVICES_KEY = [string] [EOL] [EOL] SUPPORT_SAMSUNGTV = SUPPORT_PAUSE | SUPPORT_VOLUME_STEP | SUPPORT_VOLUME_MUTE | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_TURN_OFF | SUPPORT_PLAY | SUPPORT_PLAY_MEDIA [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] known_devices = hass . data . get ( KNOWN_DEVICES_KEY ) [EOL] if known_devices is None : [EOL] known_devices = set ( ) [EOL] hass . data [ KNOWN_DEVICES_KEY ] = known_devices [EOL] [EOL] [comment] [EOL] if config . get ( CONF_HOST ) is not None : [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] name = config . get ( CONF_NAME ) [EOL] mac = config . get ( CONF_MAC ) [EOL] timeout = config . get ( CONF_TIMEOUT ) [EOL] elif discovery_info is not None : [EOL] tv_name = discovery_info . get ( [string] ) [EOL] model = discovery_info . get ( [string] ) [EOL] host = discovery_info . get ( [string] ) [EOL] name = [string] . format ( tv_name , model ) [EOL] port = DEFAULT_PORT [EOL] timeout = DEFAULT_TIMEOUT [EOL] mac = None [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] ip_addr = socket . gethostbyname ( host ) [EOL] if ip_addr not in known_devices : [EOL] known_devices . add ( ip_addr ) [EOL] add_entities ( [ SamsungTVDevice ( host , port , name , timeout , mac ) ] ) [EOL] _LOGGER . info ( [string] , host , port , name ) [EOL] else : [EOL] _LOGGER . info ( [string] , host , port ) [EOL] [EOL] [EOL] class SamsungTVDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , name , timeout , mac ) : [EOL] [docstring] [EOL] from samsungctl import exceptions [EOL] from samsungctl import Remote [EOL] import wakeonlan [EOL] [comment] [EOL] self . _exceptions_class = exceptions [EOL] self . _remote_class = Remote [EOL] self . _name = name [EOL] self . _mac = mac [EOL] self . _wol = wakeonlan [EOL] [comment] [EOL] self . _muted = False [EOL] [comment] [EOL] self . _playing = True [EOL] self . _state = STATE_UNKNOWN [EOL] self . _remote = None [EOL] [comment] [EOL] [comment] [EOL] self . _end_of_power_off = None [EOL] [comment] [EOL] self . _config = { [string] : [string] , [string] : name , [string] : [string] , [string] : port , [string] : host , [string] : timeout , } [EOL] [EOL] if self . _config [ [string] ] == [number] : [EOL] self . _config [ [string] ] = [string] [EOL] else : [EOL] self . _config [ [string] ] = [string] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if sys . platform == [string] : [EOL] _ping_cmd = [ [string] , [string] , [string] , [string] , self . _config [ [string] ] ] [EOL] else : [EOL] _ping_cmd = [ [string] , [string] , [string] , [string] , [string] , self . _config [ [string] ] ] [EOL] [EOL] ping = subprocess . Popen ( _ping_cmd , stdout = subprocess . PIPE , stderr = subprocess . DEVNULL ) [EOL] try : [EOL] ping . communicate ( ) [EOL] self . _state = STATE_ON if ping . returncode == [number] else STATE_OFF [EOL] except subprocess . CalledProcessError : [EOL] self . _state = STATE_OFF [EOL] [EOL] def get_remote ( self ) : [EOL] [docstring] [EOL] if self . _remote is None : [EOL] [comment] [EOL] self . _remote = self . _remote_class ( self . _config ) [EOL] [EOL] return self . _remote [EOL] [EOL] def send_key ( self , key ) : [EOL] [docstring] [EOL] if self . _power_off_in_progress ( ) \ [EOL] and key not in ( [string] , [string] ) : [EOL] _LOGGER . info ( [string] , key ) [EOL] return [EOL] try : [EOL] [comment] [EOL] retry_count = [number] [EOL] for _ in range ( retry_count + [number] ) : [EOL] try : [EOL] self . get_remote ( ) . control ( key ) [EOL] break [EOL] except ( self . _exceptions_class . ConnectionClosed , BrokenPipeError ) : [EOL] [comment] [EOL] self . _remote = None [EOL] self . _state = STATE_ON [EOL] except ( self . _exceptions_class . UnhandledResponse , self . _exceptions_class . AccessDenied ) : [EOL] [comment] [EOL] self . _state = STATE_ON [EOL] self . _remote = None [EOL] _LOGGER . debug ( [string] , key , exc_info = True ) [EOL] return [EOL] except OSError : [EOL] self . _state = STATE_OFF [EOL] self . _remote = None [EOL] if self . _power_off_in_progress ( ) : [EOL] self . _state = STATE_OFF [EOL] [EOL] def _power_off_in_progress ( self ) : [EOL] return self . _end_of_power_off is not None and self . _end_of_power_off > dt_util . utcnow ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _muted [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . _mac : [EOL] return SUPPORT_SAMSUNGTV | SUPPORT_TURN_ON [EOL] return SUPPORT_SAMSUNGTV [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . _end_of_power_off = dt_util . utcnow ( ) + timedelta ( seconds = [number] ) [EOL] [EOL] if self . _config [ [string] ] == [string] : [EOL] self . send_key ( [string] ) [EOL] else : [EOL] self . send_key ( [string] ) [EOL] [comment] [EOL] try : [EOL] self . get_remote ( ) . close ( ) [EOL] self . _remote = None [EOL] except OSError : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] self . send_key ( [string] ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] self . send_key ( [string] ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . send_key ( [string] ) [EOL] [EOL] def media_play_pause ( self ) : [EOL] [docstring] [EOL] if self . _playing : [EOL] self . media_pause ( ) [EOL] else : [EOL] self . media_play ( ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _playing = True [EOL] self . send_key ( [string] ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _playing = False [EOL] self . send_key ( [string] ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . send_key ( [string] ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . send_key ( [string] ) [EOL] [EOL] async def async_play_media ( self , media_type , media_id , ** kwargs ) : [EOL] [docstring] [EOL] if media_type != MEDIA_TYPE_CHANNEL : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] try : [EOL] cv . positive_int ( media_id ) [EOL] except vol . Invalid : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] for digit in media_id : [EOL] await self . hass . async_add_job ( self . send_key , [string] + digit ) [EOL] await asyncio . sleep ( KEY_PRESS_TIMEOUT , self . hass . loop ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] if self . _mac : [EOL] self . _wol . send_magic_packet ( self . _mac ) [EOL] else : [EOL] self . send_key ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import requests [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import datetime , timezone [EOL] import requests [EOL] [EOL] from homeassistant . components import ios [EOL] [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] from homeassistant . components . notify import ( ATTR_TARGET , ATTR_TITLE , ATTR_TITLE_DEFAULT , ATTR_MESSAGE , ATTR_DATA , BaseNotificationService ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PUSH_URL = [string] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] def log_rate_limits ( target , resp , level = [number] ) : [EOL] [docstring] [EOL] rate_limits = resp [ [string] ] [EOL] resetsAt = dt_util . parse_datetime ( rate_limits [ [string] ] ) [EOL] resetsAtTime = resetsAt - datetime . now ( timezone . utc ) [EOL] rate_limit_msg = ( [string] [string] [string] ) [EOL] _LOGGER . log ( level , rate_limit_msg , ios . device_name_for_push_id ( target ) , rate_limits [ [string] ] , rate_limits [ [string] ] , rate_limits [ [string] ] , str ( resetsAtTime ) . split ( [string] ) [ [number] ] ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] if [string] not in hass . config . components : [EOL] [comment] [EOL] hass . config . components . add ( [string] ) [EOL] [EOL] if not ios . devices_with_push ( ) : [EOL] _LOGGER . error ( [string] [string] [string] [string] ) [EOL] return None [EOL] [EOL] return iOSNotificationService ( ) [EOL] [EOL] [EOL] class iOSNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] @ property def targets ( self ) : [EOL] [docstring] [EOL] return ios . devices_with_push ( ) [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_MESSAGE : message } [EOL] [EOL] if kwargs . get ( ATTR_TITLE ) is not None : [EOL] [comment] [EOL] if kwargs . get ( ATTR_TITLE ) != ATTR_TITLE_DEFAULT : [EOL] data [ ATTR_TITLE ] = kwargs . get ( ATTR_TITLE ) [EOL] [EOL] targets = kwargs . get ( ATTR_TARGET ) [EOL] [EOL] if not targets : [EOL] targets = ios . enabled_push_ids ( ) [EOL] [EOL] if kwargs . get ( ATTR_DATA ) is not None : [EOL] data [ ATTR_DATA ] = kwargs . get ( ATTR_DATA ) [EOL] [EOL] for target in targets : [EOL] if target not in ios . enabled_push_ids ( ) : [EOL] _LOGGER . error ( [string] , targets ) [EOL] return [EOL] [EOL] data [ ATTR_TARGET ] = target [EOL] [EOL] req = requests . post ( PUSH_URL , json = data , timeout = [number] ) [EOL] [EOL] if req . status_code != [number] : [EOL] fallback_error = req . json ( ) . get ( [string] , [string] ) [EOL] fallback_message = ( [string] [string] [string] ) . format ( fallback_error ) [EOL] message = req . json ( ) . get ( [string] , fallback_message ) [EOL] if req . status_code == [number] : [EOL] _LOGGER . warning ( message ) [EOL] log_rate_limits ( target , req . json ( ) , [number] ) [EOL] else : [EOL] _LOGGER . error ( message ) [EOL] else : [EOL] log_rate_limits ( target , req . json ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components import mochad [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . const import ( CONF_NAME , CONF_DEVICES , CONF_PLATFORM , CONF_ADDRESS ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] PLATFORM_SCHEMA = vol . Schema ( { vol . Required ( CONF_PLATFORM ) : mochad . DOMAIN , CONF_DEVICES : [ { vol . Optional ( CONF_NAME ) : cv . string , vol . Required ( CONF_ADDRESS ) : cv . x10_address , vol . Optional ( mochad . CONF_COMM_TYPE ) : cv . string , } ] } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devs = config . get ( CONF_DEVICES ) [EOL] add_entities ( [ MochadSwitch ( hass , mochad . CONTROLLER . ctrl , dev ) for dev in devs ] ) [EOL] return True [EOL] [EOL] [EOL] class MochadSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , ctrl , dev ) : [EOL] [docstring] [EOL] from pymochad import device [EOL] [EOL] self . _controller = ctrl [EOL] self . _address = dev [ CONF_ADDRESS ] [EOL] self . _name = dev . get ( CONF_NAME , [string] % self . _address ) [EOL] self . _comm_type = dev . get ( mochad . CONF_COMM_TYPE , [string] ) [EOL] self . switch = device . Device ( ctrl , self . _address , comm_type = self . _comm_type ) [EOL] [comment] [EOL] [comment] [EOL] if self . _comm_type == [string] : [EOL] self . _state = self . _get_device_status ( ) [EOL] else : [EOL] self . _state = False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] from pymochad . exceptions import MochadException [EOL] _LOGGER . debug ( [string] , self . _controller . server , self . _controller . port ) [EOL] with mochad . REQ_LOCK : [EOL] try : [EOL] [comment] [EOL] self . _controller . reconnect ( ) [EOL] self . switch . send_cmd ( [string] ) [EOL] [comment] [EOL] if self . _comm_type == [string] : [EOL] self . _controller . read_data ( ) [EOL] self . _state = True [EOL] except ( MochadException , OSError ) as exc : [EOL] _LOGGER . error ( [string] , exc ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] from pymochad . exceptions import MochadException [EOL] _LOGGER . debug ( [string] , self . _controller . server , self . _controller . port ) [EOL] with mochad . REQ_LOCK : [EOL] try : [EOL] [comment] [EOL] self . _controller . reconnect ( ) [EOL] self . switch . send_cmd ( [string] ) [EOL] [comment] [EOL] if self . _comm_type == [string] : [EOL] self . _controller . read_data ( ) [EOL] self . _state = False [EOL] except ( MochadException , OSError ) as exc : [EOL] _LOGGER . error ( [string] , exc ) [EOL] [EOL] def _get_device_status ( self ) : [EOL] [docstring] [EOL] with mochad . REQ_LOCK : [EOL] status = self . switch . get_status ( ) . rstrip ( ) [EOL] return status == [string] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import homeassistant [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . rflink import ( CONF_ALIASES , CONF_ALIASSES , CONF_DEVICE_DEFAULTS , CONF_DEVICES , CONF_FIRE_EVENT , CONF_GROUP , CONF_GROUP_ALIASES , CONF_GROUP_ALIASSES , CONF_NOGROUP_ALIASES , CONF_NOGROUP_ALIASSES , CONF_SIGNAL_REPETITIONS , DATA_ENTITY_GROUP_LOOKUP , DATA_ENTITY_LOOKUP , DEVICE_DEFAULTS_SCHEMA , DOMAIN , EVENT_KEY_COMMAND , SwitchableRflinkDevice , cv , remove_deprecated , vol ) [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . const import CONF_NAME , CONF_PLATFORM [EOL] from homeassistant . helpers . deprecation import get_deprecated [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = vol . Schema ( { vol . Required ( CONF_PLATFORM ) : DOMAIN , vol . Optional ( CONF_DEVICE_DEFAULTS , default = DEVICE_DEFAULTS_SCHEMA ( { } ) ) : DEVICE_DEFAULTS_SCHEMA , vol . Optional ( CONF_DEVICES , default = { } ) : vol . Schema ( { cv . string : { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_ALIASES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_GROUP_ALIASES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_NOGROUP_ALIASES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_FIRE_EVENT ) : cv . boolean , vol . Optional ( CONF_SIGNAL_REPETITIONS ) : vol . Coerce ( int ) , vol . Optional ( CONF_GROUP , default = True ) : cv . boolean , vol . Optional ( CONF_ALIASSES ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_GROUP_ALIASSES ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_NOGROUP_ALIASSES ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } , } ) , } ) [EOL] [EOL] [EOL] def devices_from_config ( domain_config , hass = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for device_id , config in domain_config [ CONF_DEVICES ] . items ( ) : [EOL] device_config = dict ( domain_config [ CONF_DEVICE_DEFAULTS ] , ** config ) [EOL] remove_deprecated ( device_config ) [EOL] device = RflinkSwitch ( device_id , hass , ** device_config ) [EOL] devices . append ( device ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] hass . data [ DATA_ENTITY_LOOKUP ] [ EVENT_KEY_COMMAND ] [ device_id ] . append ( device ) [EOL] if config [ CONF_GROUP ] : [EOL] hass . data [ DATA_ENTITY_GROUP_LOOKUP ] [ EVENT_KEY_COMMAND ] [ device_id ] . append ( device ) [EOL] for _id in get_deprecated ( config , CONF_ALIASES , CONF_ALIASSES ) : [EOL] hass . data [ DATA_ENTITY_LOOKUP ] [ EVENT_KEY_COMMAND ] [ _id ] . append ( device ) [EOL] hass . data [ DATA_ENTITY_GROUP_LOOKUP ] [ EVENT_KEY_COMMAND ] [ _id ] . append ( device ) [EOL] [comment] [EOL] for _id in get_deprecated ( config , CONF_GROUP_ALIASES , CONF_GROUP_ALIASSES ) : [EOL] hass . data [ DATA_ENTITY_GROUP_LOOKUP ] [ EVENT_KEY_COMMAND ] [ _id ] . append ( device ) [EOL] [comment] [EOL] for _id in get_deprecated ( config , CONF_NOGROUP_ALIASES , CONF_NOGROUP_ALIASSES ) : [EOL] hass . data [ DATA_ENTITY_LOOKUP ] [ EVENT_KEY_COMMAND ] [ _id ] . append ( device ) [EOL] [EOL] return devices [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] async_add_entities ( devices_from_config ( config , hass ) ) [EOL] [EOL] [EOL] class RflinkSwitch ( SwitchableRflinkDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any , List [EOL] import typing [EOL] import homeassistant [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_HEADERS , CONF_NAME , CONF_RESOURCE , CONF_TIMEOUT , CONF_METHOD , CONF_USERNAME , CONF_PASSWORD ) [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_BODY_OFF = [string] [EOL] CONF_BODY_ON = [string] [EOL] CONF_IS_ON_TEMPLATE = [string] [EOL] [EOL] DEFAULT_METHOD = [string] [EOL] DEFAULT_BODY_OFF = [string] [EOL] DEFAULT_BODY_ON = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_TIMEOUT = [number] [EOL] [EOL] SUPPORT_REST_METHODS = [ [string] , [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_RESOURCE ) : cv . url , vol . Optional ( CONF_HEADERS ) : { cv . string : cv . string } , vol . Optional ( CONF_BODY_OFF , default = DEFAULT_BODY_OFF ) : cv . template , vol . Optional ( CONF_BODY_ON , default = DEFAULT_BODY_ON ) : cv . template , vol . Optional ( CONF_IS_ON_TEMPLATE ) : cv . template , vol . Optional ( CONF_METHOD , default = DEFAULT_METHOD ) : vol . All ( vol . Lower , vol . In ( SUPPORT_REST_METHODS ) ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int , vol . Inclusive ( CONF_USERNAME , [string] ) : cv . string , vol . Inclusive ( CONF_PASSWORD , [string] ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] body_off = config . get ( CONF_BODY_OFF ) [EOL] body_on = config . get ( CONF_BODY_ON ) [EOL] is_on_template = config . get ( CONF_IS_ON_TEMPLATE ) [EOL] method = config . get ( CONF_METHOD ) [EOL] headers = config . get ( CONF_HEADERS ) [EOL] name = config . get ( CONF_NAME ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] resource = config . get ( CONF_RESOURCE ) [EOL] [EOL] auth = None [EOL] if username : [EOL] auth = aiohttp . BasicAuth ( username , password = password ) [EOL] [EOL] if is_on_template is not None : [EOL] is_on_template . hass = hass [EOL] if body_on is not None : [EOL] body_on . hass = hass [EOL] if body_off is not None : [EOL] body_off . hass = hass [EOL] timeout = config . get ( CONF_TIMEOUT ) [EOL] [EOL] try : [EOL] switch = RestSwitch ( name , resource , method , headers , auth , body_on , body_off , is_on_template , timeout ) [EOL] [EOL] req = yield from switch . get_device_state ( hass ) [EOL] if req . status >= [number] : [EOL] _LOGGER . error ( [string] , req . status ) [EOL] else : [EOL] async_add_entities ( [ switch ] ) [EOL] except ( TypeError , ValueError ) : [EOL] _LOGGER . error ( [string] [string] ) [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . error ( [string] , resource ) [EOL] [EOL] [EOL] class RestSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , resource , method , headers , auth , body_on , body_off , is_on_template , timeout ) : [EOL] [docstring] [EOL] self . _state = None [EOL] self . _name = name [EOL] self . _resource = resource [EOL] self . _method = method [EOL] self . _headers = headers [EOL] self . _auth = auth [EOL] self . _body_on = body_on [EOL] self . _body_off = body_off [EOL] self . _is_on_template = is_on_template [EOL] self . _timeout = timeout [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] body_on_t = self . _body_on . async_render ( ) [EOL] [EOL] try : [EOL] req = yield from self . set_device_state ( body_on_t ) [EOL] [EOL] if req . status == [number] : [EOL] self . _state = True [EOL] else : [EOL] _LOGGER . error ( [string] , self . _resource ) [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . error ( [string] , self . _resource ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] body_off_t = self . _body_off . async_render ( ) [EOL] [EOL] try : [EOL] req = yield from self . set_device_state ( body_off_t ) [EOL] if req . status == [number] : [EOL] self . _state = False [EOL] else : [EOL] _LOGGER . error ( [string] , self . _resource ) [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . error ( [string] , self . _resource ) [EOL] [EOL] @ asyncio . coroutine def set_device_state ( self , body ) : [EOL] [docstring] [EOL] websession = async_get_clientsession ( self . hass ) [EOL] [EOL] with async_timeout . timeout ( self . _timeout , loop = self . hass . loop ) : [EOL] req = yield from getattr ( websession , self . _method ) ( self . _resource , auth = self . _auth , data = bytes ( body , [string] ) , headers = self . _headers ) [EOL] return req [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] try : [EOL] yield from self . get_device_state ( self . hass ) [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . exception ( [string] ) [EOL] [EOL] @ asyncio . coroutine def get_device_state ( self , hass ) : [EOL] [docstring] [EOL] websession = async_get_clientsession ( hass ) [EOL] [EOL] with async_timeout . timeout ( self . _timeout , loop = hass . loop ) : [EOL] req = yield from websession . get ( self . _resource , auth = self . _auth ) [EOL] text = yield from req . text ( ) [EOL] [EOL] if self . _is_on_template is not None : [EOL] text = self . _is_on_template . async_render_with_possible_json_value ( text , [string] ) [EOL] text = text . lower ( ) [EOL] if text == [string] : [EOL] self . _state = True [EOL] elif text == [string] : [EOL] self . _state = False [EOL] else : [EOL] self . _state = None [EOL] else : [EOL] if text == self . _body_on . template : [EOL] self . _state = True [EOL] elif text == self . _body_off . template : [EOL] self . _state = False [EOL] else : [EOL] self . _state = None [EOL] [EOL] return req [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import homeassistant [EOL] import logging [EOL] import io [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . camera import PLATFORM_SCHEMA , Camera [EOL] from homeassistant . const import CONF_ENTITY_ID , CONF_NAME , HTTP_HEADER_HA_AUTH [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . aiohttp_client import ( async_aiohttp_proxy_web , async_get_clientsession ) [EOL] from homeassistant . util . async_ import run_coroutine_threadsafe [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_CACHE_IMAGES = [string] [EOL] CONF_FORCE_RESIZE = [string] [EOL] CONF_IMAGE_QUALITY = [string] [EOL] CONF_IMAGE_REFRESH_RATE = [string] [EOL] CONF_MAX_IMAGE_WIDTH = [string] [EOL] CONF_MAX_STREAM_WIDTH = [string] [EOL] CONF_STREAM_QUALITY = [string] [EOL] [EOL] DEFAULT_BASENAME = [string] [EOL] DEFAULT_QUALITY = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ENTITY_ID ) : cv . entity_id , vol . Optional ( CONF_CACHE_IMAGES , False ) : cv . boolean , vol . Optional ( CONF_FORCE_RESIZE , False ) : cv . boolean , vol . Optional ( CONF_IMAGE_QUALITY ) : int , vol . Optional ( CONF_IMAGE_REFRESH_RATE ) : float , vol . Optional ( CONF_MAX_IMAGE_WIDTH ) : int , vol . Optional ( CONF_MAX_STREAM_WIDTH ) : int , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_STREAM_QUALITY ) : int , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] async_add_entities ( [ ProxyCamera ( hass , config ) ] ) [EOL] [EOL] [EOL] def _resize_image ( image , opts ) : [EOL] [docstring] [EOL] from PIL import Image [EOL] import io [EOL] [EOL] if not opts : [EOL] return image [EOL] [EOL] quality = opts . quality or DEFAULT_QUALITY [EOL] new_width = opts . max_width [EOL] [EOL] try : [EOL] img = Image . open ( io . BytesIO ( image ) ) [EOL] except IOError : [EOL] return image [EOL] imgfmt = str ( img . format ) [EOL] if imgfmt not in ( [string] , [string] ) : [EOL] _LOGGER . debug ( [string] , imgfmt ) [EOL] return image [EOL] [EOL] ( old_width , old_height ) = img . size [EOL] old_size = len ( image ) [EOL] if old_width <= new_width : [EOL] if opts . quality is None : [EOL] _LOGGER . debug ( [string] ) [EOL] return image [EOL] new_width = old_width [EOL] [EOL] scale = new_width / float ( old_width ) [EOL] new_height = int ( ( float ( old_height ) * float ( scale ) ) ) [EOL] [EOL] img = img . resize ( ( new_width , new_height ) , Image . ANTIALIAS ) [EOL] imgbuf = io . BytesIO ( ) [EOL] img . save ( imgbuf , [string] , optimize = True , quality = quality ) [EOL] newimage = imgbuf . getvalue ( ) [EOL] if not opts . force_resize and len ( newimage ) >= old_size : [EOL] _LOGGER . debug ( [string] [string] , old_size , len ( newimage ) ) [EOL] return image [EOL] [EOL] _LOGGER . debug ( [string] , old_width , old_height , old_size , new_width , new_height , len ( newimage ) ) [EOL] return newimage [EOL] [EOL] [EOL] class ImageOpts ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , max_width , quality , force_resize ) : [EOL] [docstring] [EOL] self . max_width = max_width [EOL] self . quality = quality [EOL] self . force_resize = force_resize [EOL] [EOL] def __bool__ ( self ) : [EOL] [docstring] [EOL] return bool ( self . max_width or self . quality ) [EOL] [EOL] [EOL] class ProxyCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . hass = hass [EOL] self . _proxied_camera = config . get ( CONF_ENTITY_ID ) [EOL] self . _name = ( config . get ( CONF_NAME ) or [string] . format ( DEFAULT_BASENAME , self . _proxied_camera ) ) [EOL] self . _image_opts = ImageOpts ( config . get ( CONF_MAX_IMAGE_WIDTH ) , config . get ( CONF_IMAGE_QUALITY ) , config . get ( CONF_FORCE_RESIZE ) ) [EOL] [EOL] self . _stream_opts = ImageOpts ( config . get ( CONF_MAX_STREAM_WIDTH ) , config . get ( CONF_STREAM_QUALITY ) , True ) [EOL] [EOL] self . _image_refresh_rate = config . get ( CONF_IMAGE_REFRESH_RATE ) [EOL] self . _cache_images = bool ( config . get ( CONF_IMAGE_REFRESH_RATE ) or config . get ( CONF_CACHE_IMAGES ) ) [EOL] self . _last_image_time = [number] [EOL] self . _last_image = None [EOL] self . _headers = ( { HTTP_HEADER_HA_AUTH : self . hass . config . api . api_password } [EOL] if self . hass . config . api . api_password is not None else None ) [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] return run_coroutine_threadsafe ( self . async_camera_image ( ) , self . hass . loop ) . result ( ) [EOL] [EOL] async def async_camera_image ( self ) : [EOL] [docstring] [EOL] now = dt_util . utcnow ( ) [EOL] [EOL] if ( self . _image_refresh_rate and now < self . _last_image_time + self . _image_refresh_rate ) : [EOL] return self . _last_image [EOL] [EOL] self . _last_image_time = now [EOL] url = [string] . format ( self . hass . config . api . base_url , self . _proxied_camera ) [EOL] try : [EOL] websession = async_get_clientsession ( self . hass ) [EOL] with async_timeout . timeout ( [number] , loop = self . hass . loop ) : [EOL] response = await websession . get ( url , headers = self . _headers ) [EOL] image = await response . read ( ) [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . error ( [string] ) [EOL] return self . _last_image [EOL] except aiohttp . ClientError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] return self . _last_image [EOL] [EOL] image = await self . hass . async_add_job ( _resize_image , image , self . _image_opts ) [EOL] [EOL] if self . _cache_images : [EOL] self . _last_image = image [EOL] return image [EOL] [EOL] async def handle_async_mjpeg_stream ( self , request ) : [EOL] [docstring] [EOL] websession = async_get_clientsession ( self . hass ) [EOL] url = [string] . format ( self . hass . config . api . base_url , self . _proxied_camera ) [EOL] stream_coro = websession . get ( url , headers = self . _headers ) [EOL] [EOL] if not self . _stream_opts : [EOL] return await async_aiohttp_proxy_web ( self . hass , request , stream_coro ) [EOL] [EOL] response = aiohttp . web . StreamResponse ( ) [EOL] response . content_type = ( [string] ) [EOL] await response . prepare ( request ) [EOL] [EOL] async def write ( img_bytes ) : [EOL] [docstring] [EOL] await response . write ( bytes ( [string] [string] [string] . format ( self . content_type , len ( img_bytes ) ) , [string] ) + img_bytes + [string] ) [EOL] [EOL] with async_timeout . timeout ( [number] , loop = self . hass . loop ) : [EOL] req = await stream_coro [EOL] [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] data = [string] [EOL] stream = req . content [EOL] while True : [EOL] chunk = await stream . read ( [number] ) [EOL] if not chunk : [EOL] break [EOL] data += chunk [EOL] jpg_start = data . find ( [string] ) [EOL] jpg_end = data . find ( [string] ) [EOL] if jpg_start != - [number] and jpg_end != - [number] : [EOL] image = data [ jpg_start : jpg_end + [number] ] [EOL] image = await self . hass . async_add_job ( _resize_image , image , self . _stream_opts ) [EOL] await write ( image ) [EOL] data = data [ jpg_end + [number] : ] [EOL] finally : [EOL] req . close ( ) [EOL] [EOL] return response [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $homeassistant.components.camera.proxy.ImageOpts$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $homeassistant.components.camera.proxy.ImageOpts$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bytes$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $builtins.bytes$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from homeassistant . const import ATTR_HIDDEN , ATTR_LATITUDE , ATTR_LONGITUDE [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . loader import bind_hass [EOL] from homeassistant . util . async_ import run_callback_threadsafe [EOL] from homeassistant . util . location import distance [EOL] [EOL] from . const import DOMAIN [EOL] [EOL] ATTR_PASSIVE = [string] [EOL] ATTR_RADIUS = [string] [EOL] [EOL] STATE = [string] [EOL] [EOL] [EOL] @ bind_hass def active_zone ( hass , latitude , longitude , radius = [number] ) : [EOL] [docstring] [EOL] return run_callback_threadsafe ( hass . loop , async_active_zone , hass , latitude , longitude , radius ) . result ( ) [EOL] [EOL] [EOL] @ bind_hass def async_active_zone ( hass , latitude , longitude , radius = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] zones = ( hass . states . get ( entity_id ) for entity_id in sorted ( hass . states . async_entity_ids ( DOMAIN ) ) ) [EOL] [EOL] min_dist = None [EOL] closest = None [EOL] [EOL] for zone in zones : [EOL] if zone . attributes . get ( ATTR_PASSIVE ) : [EOL] continue [EOL] [EOL] zone_dist = distance ( latitude , longitude , zone . attributes [ ATTR_LATITUDE ] , zone . attributes [ ATTR_LONGITUDE ] ) [EOL] [EOL] within_zone = zone_dist - radius < zone . attributes [ ATTR_RADIUS ] [EOL] closer_zone = closest is None or zone_dist < min_dist [EOL] smaller_zone = ( zone_dist == min_dist and zone . attributes [ ATTR_RADIUS ] < closest . attributes [ ATTR_RADIUS ] ) [EOL] [EOL] if within_zone and ( closer_zone or smaller_zone ) : [EOL] min_dist = zone_dist [EOL] closest = zone [EOL] [EOL] return closest [EOL] [EOL] [EOL] def in_zone ( zone , latitude , longitude , radius = [number] ) : [EOL] [docstring] [EOL] zone_dist = distance ( latitude , longitude , zone . attributes [ ATTR_LATITUDE ] , zone . attributes [ ATTR_LONGITUDE ] ) [EOL] [EOL] return zone_dist - radius < zone . attributes [ ATTR_RADIUS ] [EOL] [EOL] [EOL] class Zone ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , latitude , longitude , radius , icon , passive ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _name = name [EOL] self . _latitude = latitude [EOL] self . _longitude = longitude [EOL] self . _radius = radius [EOL] self . _icon = icon [EOL] self . _passive = passive [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return STATE [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] data = { ATTR_HIDDEN : True , ATTR_LATITUDE : self . _latitude , ATTR_LONGITUDE : self . _longitude , ATTR_RADIUS : self . _radius , } [EOL] if self . _passive : [EOL] data [ ATTR_PASSIVE ] = self . _passive [EOL] return data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.dict$ 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . device_tracker import ( DOMAIN , PLATFORM_SCHEMA , DeviceScanner ) [EOL] from homeassistant . const import CONF_HOST [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DEFAULT_IP = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST , default = CONF_DEFAULT_IP ) : cv . string , } ) [EOL] [EOL] [EOL] def get_scanner ( hass , config ) : [EOL] [docstring] [EOL] scanner = BTHomeHub5DeviceScanner ( config [ DOMAIN ] ) [EOL] [EOL] return scanner if scanner . success_init else None [EOL] [EOL] [EOL] class BTHomeHub5DeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] import bthomehub5_devicelist [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] self . host = config [ CONF_HOST ] [EOL] self . last_results = { } [EOL] [EOL] [comment] [EOL] data = bthomehub5_devicelist . get_devicelist ( self . host ) [EOL] self . success_init = data is not None [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . update_info ( ) [EOL] [EOL] return ( device for device in self . last_results ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] [comment] [EOL] if device not in self . last_results : [EOL] self . update_info ( ) [EOL] [EOL] if not self . last_results : [EOL] return None [EOL] [EOL] return self . last_results . get ( device ) [EOL] [EOL] def update_info ( self ) : [EOL] [docstring] [EOL] import bthomehub5_devicelist [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] data = bthomehub5_devicelist . get_devicelist ( self . host ) [EOL] [EOL] if not data : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] [EOL] self . last_results = data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Optional , Union , List , Any , Dict , Match [EOL] import requests [EOL] import typing [EOL] import homeassistant [EOL] import logging [EOL] [docstring] [EOL] import base64 [EOL] from datetime import datetime [EOL] import hashlib [EOL] import logging [EOL] import re [EOL] [EOL] from aiohttp . hdrs import ( ACCEPT , COOKIE , PRAGMA , REFERER , CONNECTION , KEEP_ALIVE , USER_AGENT , CONTENT_TYPE , CACHE_CONTROL , ACCEPT_ENCODING , ACCEPT_LANGUAGE ) [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . device_tracker import ( DOMAIN , PLATFORM_SCHEMA , DeviceScanner ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_USERNAME , HTTP_HEADER_X_REQUESTED_WITH ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] HTTP_HEADER_NO_CACHE = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string } ) [EOL] [EOL] [EOL] def get_scanner ( hass , config ) : [EOL] [docstring] [EOL] for cls in [ TplinkDeviceScanner , Tplink5DeviceScanner , Tplink4DeviceScanner , Tplink3DeviceScanner , Tplink2DeviceScanner , Tplink1DeviceScanner ] : [EOL] scanner = cls ( config [ DOMAIN ] ) [EOL] if scanner . success_init : [EOL] return scanner [EOL] [EOL] return None [EOL] [EOL] [EOL] class TplinkDeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] from tplink . tplink import TpLinkClient [EOL] host = config [ CONF_HOST ] [EOL] password = config [ CONF_PASSWORD ] [EOL] username = config [ CONF_USERNAME ] [EOL] [EOL] self . success_init = False [EOL] try : [EOL] self . tplink_client = TpLinkClient ( password , host = host , username = username ) [EOL] [EOL] self . last_results = { } [EOL] [EOL] self . success_init = self . _update_info ( ) [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results . keys ( ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return self . last_results . get ( device ) [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] result = self . tplink_client . get_connected_devices ( ) [EOL] [EOL] if result : [EOL] self . last_results = result [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] class Tplink1DeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] host = config [ CONF_HOST ] [EOL] username , password = config [ CONF_USERNAME ] , config [ CONF_PASSWORD ] [EOL] [EOL] self . parse_macs = re . compile ( [string] + [string] ) [EOL] [EOL] self . host = host [EOL] self . username = username [EOL] self . password = password [EOL] [EOL] self . last_results = { } [EOL] self . success_init = False [EOL] try : [EOL] self . success_init = self . _update_info ( ) [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = [string] . format ( self . host ) [EOL] referer = [string] . format ( self . host ) [EOL] page = requests . get ( url , auth = ( self . username , self . password ) , headers = { REFERER : referer } , timeout = [number] ) [EOL] [EOL] result = self . parse_macs . findall ( page . text ) [EOL] [EOL] if result : [EOL] self . last_results = [ mac . replace ( [string] , [string] ) for mac in result ] [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] class Tplink2DeviceScanner ( Tplink1DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results . keys ( ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return self . last_results . get ( device ) [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = [string] . format ( self . host ) [EOL] referer = [string] . format ( self . host ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] username_password = [string] . format ( self . username , self . password ) [EOL] b64_encoded_username_password = base64 . b64encode ( username_password . encode ( [string] ) ) . decode ( [string] ) [EOL] cookie = [string] . format ( b64_encoded_username_password ) [EOL] [EOL] response = requests . post ( url , headers = { REFERER : referer , COOKIE : cookie } , timeout = [number] ) [EOL] [EOL] try : [EOL] result = response . json ( ) . get ( [string] ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] [EOL] if result : [EOL] self . last_results = { device [ [string] ] . replace ( [string] , [string] ) : device [ [string] ] for device in result } [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] class Tplink3DeviceScanner ( Tplink1DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . stok = [string] [EOL] self . sysauth = [string] [EOL] super ( Tplink3DeviceScanner , self ) . __init__ ( config ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] self . _log_out ( ) [EOL] return self . last_results . keys ( ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return self . last_results . get ( device ) [EOL] [EOL] def _get_auth_tokens ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = [string] . format ( self . host ) [EOL] referer = [string] . format ( self . host ) [EOL] [EOL] [comment] [EOL] response = requests . post ( url , params = { [string] : [string] , [string] : self . username , [string] : self . password } , headers = { REFERER : referer } , timeout = [number] ) [EOL] [EOL] try : [EOL] self . stok = response . json ( ) . get ( [string] ) . get ( [string] ) [EOL] _LOGGER . info ( self . stok ) [EOL] regex_result = re . search ( [string] , response . headers [ [string] ] ) [EOL] self . sysauth = regex_result . group ( [number] ) [EOL] _LOGGER . info ( self . sysauth ) [EOL] return True [EOL] except ( ValueError , KeyError ) as _ : [EOL] _LOGGER . error ( [string] , response . text ) [EOL] return False [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] if ( self . stok == [string] ) or ( self . sysauth == [string] ) : [EOL] self . _get_auth_tokens ( ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = ( [string] [string] ) . format ( self . host , self . stok ) [EOL] referer = [string] . format ( self . host ) [EOL] [EOL] response = requests . post ( url , params = { [string] : [string] } , headers = { REFERER : referer } , cookies = { [string] : self . sysauth } , timeout = [number] ) [EOL] [EOL] try : [EOL] json_response = response . json ( ) [EOL] [EOL] if json_response . get ( [string] ) : [EOL] result = response . json ( ) . get ( [string] ) [EOL] else : [EOL] if json_response . get ( [string] ) == [string] : [EOL] _LOGGER . info ( [string] ) [EOL] self . stok = [string] [EOL] self . sysauth = [string] [EOL] return False [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] except ValueError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] [EOL] if result : [EOL] self . last_results = { device [ [string] ] . replace ( [string] , [string] ) : device [ [string] ] for device in result } [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def _log_out ( self ) : [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = ( [string] [string] ) . format ( self . host , self . stok ) [EOL] referer = [string] . format ( self . host ) [EOL] [EOL] requests . post ( url , params = { [string] : [string] } , headers = { REFERER : referer } , cookies = { [string] : self . sysauth } ) [EOL] self . stok = [string] [EOL] self . sysauth = [string] [EOL] [EOL] [EOL] class Tplink4DeviceScanner ( Tplink1DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . credentials = [string] [EOL] self . token = [string] [EOL] super ( Tplink4DeviceScanner , self ) . __init__ ( config ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def _get_auth_tokens ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] url = [string] . format ( self . host ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] password = hashlib . md5 ( self . password . encode ( [string] ) [ : [number] ] ) . hexdigest ( ) [EOL] credentials = [string] . format ( self . username , password ) . encode ( [string] ) [EOL] [EOL] [comment] [EOL] self . credentials = base64 . b64encode ( credentials ) . decode ( [string] ) [EOL] [EOL] [comment] [EOL] cookie = [string] . format ( self . credentials ) [EOL] [EOL] response = requests . get ( url , headers = { COOKIE : cookie } ) [EOL] [EOL] try : [EOL] result = re . search ( [string] [string] , response . text ) [EOL] if not result : [EOL] return False [EOL] self . token = result . group ( [number] ) [EOL] return True [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] if ( self . credentials == [string] ) or ( self . token == [string] ) : [EOL] self . _get_auth_tokens ( ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] mac_results = [ ] [EOL] [EOL] [comment] [EOL] for clients_url in ( [string] , [string] ) : [EOL] url = [string] . format ( self . host , self . token , clients_url ) [EOL] referer = [string] . format ( self . host ) [EOL] cookie = [string] . format ( self . credentials ) [EOL] [EOL] page = requests . get ( url , headers = { COOKIE : cookie , REFERER : referer , } ) [EOL] mac_results . extend ( self . parse_macs . findall ( page . text ) ) [EOL] [EOL] if not mac_results : [EOL] return False [EOL] [EOL] self . last_results = [ mac . replace ( [string] , [string] ) for mac in mac_results ] [EOL] return True [EOL] [EOL] [EOL] class Tplink5DeviceScanner ( Tplink1DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results . keys ( ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] base_url = [string] . format ( self . host ) [EOL] [EOL] header = { USER_AGENT : [string] [string] , ACCEPT : [string] , ACCEPT_LANGUAGE : [string] , ACCEPT_ENCODING : [string] , CONTENT_TYPE : [string] , HTTP_HEADER_X_REQUESTED_WITH : [string] , REFERER : [string] . format ( self . host ) , CONNECTION : KEEP_ALIVE , PRAGMA : HTTP_HEADER_NO_CACHE , CACHE_CONTROL : HTTP_HEADER_NO_CACHE , } [EOL] [EOL] password_md5 = hashlib . md5 ( self . password . encode ( [string] ) ) . hexdigest ( ) . upper ( ) [EOL] [EOL] [comment] [EOL] session = requests . session ( ) [EOL] session . get ( base_url , headers = header ) [EOL] [EOL] login_data = { [string] : self . username , [string] : password_md5 } [EOL] session . post ( base_url , login_data , headers = header ) [EOL] [EOL] [comment] [EOL] timestamp = int ( datetime . now ( ) . timestamp ( ) * [number] ) [EOL] [EOL] client_list_url = [string] . format ( base_url ) [EOL] [EOL] get_params = { [string] : [string] , [string] : timestamp , } [EOL] [EOL] response = session . get ( client_list_url , headers = header , params = get_params ) [EOL] session . close ( ) [EOL] try : [EOL] list_of_devices = response . json ( ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] [EOL] if list_of_devices : [EOL] self . last_results = { device [ [string] ] . replace ( [string] , [string] ) : device [ [string] ] for device in list_of_devices [ [string] ] } [EOL] return True [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.sessions.Session$ 0 0 0 $requests.sessions.Session$ 0 0 0 $requests.sessions.Session$ 0 0 0 $builtins.str$ 0 0 0 $typing.dict$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $requests.sessions.Session$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $typing.dict$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $requests.models.Response$ 0 $requests.sessions.Session$ 0 0 0 $builtins.str$ 0 0 0 $typing.dict$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 $requests.sessions.Session$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Literal , Tuple , Any [EOL] import logging [EOL] import homeassistant [EOL] import requests [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] import json [EOL] import logging [EOL] import re [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] from homeassistant . components . device_tracker import ( DOMAIN , PLATFORM_SCHEMA , DeviceScanner ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_USERNAME , CONF_PASSWORD , CONF_SSL ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_SSL = False [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_SSL , default = DEFAULT_SSL ) : cv . boolean } ) [EOL] [EOL] [EOL] class InvalidLuciTokenError ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] def get_scanner ( hass , config ) : [EOL] [docstring] [EOL] scanner = LuciDeviceScanner ( config [ DOMAIN ] ) [EOL] [EOL] return scanner if scanner . success_init else None [EOL] [EOL] [EOL] class LuciDeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] host = config [ CONF_HOST ] [EOL] protocol = [string] if not config [ CONF_SSL ] else [string] [EOL] self . origin = [string] . format ( protocol , host ) [EOL] self . username = config [ CONF_USERNAME ] [EOL] self . password = config [ CONF_PASSWORD ] [EOL] [EOL] self . parse_api_pattern = re . compile ( [string] ) [EOL] [EOL] self . last_results = { } [EOL] self . refresh_token ( ) [EOL] self . mac2name = None [EOL] self . success_init = self . token is not None [EOL] [EOL] def refresh_token ( self ) : [EOL] [docstring] [EOL] self . token = _get_token ( self . origin , self . username , self . password ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return self . last_results [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] if self . mac2name is None : [EOL] url = [string] . format ( self . origin ) [EOL] result = _req_json_rpc ( url , [string] , [string] , params = { [string] : self . token } ) [EOL] if result : [EOL] hosts = [ x for x in result . values ( ) if x [ [string] ] == [string] and [string] in x and [string] in x ] [EOL] mac2name_list = [ ( x [ [string] ] . upper ( ) , x [ [string] ] ) for x in hosts ] [EOL] self . mac2name = dict ( mac2name_list ) [EOL] else : [EOL] [comment] [EOL] return [EOL] return self . mac2name . get ( device . upper ( ) , None ) [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] if not self . success_init : [EOL] return False [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] url = [string] . format ( self . origin ) [EOL] [EOL] try : [EOL] result = _req_json_rpc ( url , [string] , params = { [string] : self . token } ) [EOL] except InvalidLuciTokenError : [EOL] _LOGGER . info ( [string] ) [EOL] self . refresh_token ( ) [EOL] return False [EOL] [EOL] if result : [EOL] self . last_results = [ ] [EOL] for device_entry in result : [EOL] [comment] [EOL] [comment] [EOL] if int ( device_entry [ [string] ] , [number] ) & [number] : [EOL] self . last_results . append ( device_entry [ [string] ] ) [EOL] [EOL] return True [EOL] [EOL] return False [EOL] [EOL] [EOL] def _req_json_rpc ( url , method , * args , ** kwargs ) : [EOL] [docstring] [EOL] data = json . dumps ( { [string] : method , [string] : args } ) [EOL] [EOL] try : [EOL] res = requests . post ( url , data = data , timeout = [number] , ** kwargs ) [EOL] except requests . exceptions . Timeout : [EOL] _LOGGER . exception ( [string] ) [EOL] return [EOL] if res . status_code == [number] : [EOL] try : [EOL] result = res . json ( ) [EOL] except ValueError : [EOL] [comment] [EOL] _LOGGER . exception ( [string] ) [EOL] return [EOL] try : [EOL] return result [ [string] ] [EOL] except KeyError : [EOL] _LOGGER . exception ( [string] ) [EOL] return [EOL] elif res . status_code == [number] : [EOL] [comment] [EOL] _LOGGER . exception ( [string] ) [EOL] return [EOL] elif res . status_code == [number] : [EOL] _LOGGER . error ( [string] ) [EOL] raise InvalidLuciTokenError [EOL] [EOL] else : [EOL] _LOGGER . error ( [string] , res ) [EOL] [EOL] [EOL] def _get_token ( origin , username , password ) : [EOL] [docstring] [EOL] url = [string] . format ( origin ) [EOL] return _req_json_rpc ( url , [string] , username , password ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Pattern , List [EOL] import typing [EOL] import homeassistant [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . device_tracker import ( DOMAIN , PLATFORM_SCHEMA , DeviceScanner ) [EOL] from homeassistant . const import CONF_HOST , CONF_PASSWORD , CONF_USERNAME [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _DEVICES_REGEX = re . compile ( [string] + [string] + [string] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string } ) [EOL] [EOL] [EOL] def get_scanner ( hass , config ) : [EOL] [docstring] [EOL] scanner = ArubaDeviceScanner ( config [ DOMAIN ] ) [EOL] [EOL] return scanner if scanner . success_init else None [EOL] [EOL] [EOL] class ArubaDeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . host = config [ CONF_HOST ] [EOL] self . username = config [ CONF_USERNAME ] [EOL] self . password = config [ CONF_PASSWORD ] [EOL] [EOL] self . last_results = { } [EOL] [EOL] [comment] [EOL] data = self . get_aruba_data ( ) [EOL] self . success_init = data is not None [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return [ client [ [string] ] for client in self . last_results ] [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] if not self . last_results : [EOL] return None [EOL] for client in self . last_results : [EOL] if client [ [string] ] == device : [EOL] return client [ [string] ] [EOL] return None [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] if not self . success_init : [EOL] return False [EOL] [EOL] data = self . get_aruba_data ( ) [EOL] if not data : [EOL] return False [EOL] [EOL] self . last_results = data . values ( ) [EOL] return True [EOL] [EOL] def get_aruba_data ( self ) : [EOL] [docstring] [EOL] import pexpect [EOL] connect = [string] [EOL] ssh = pexpect . spawn ( connect . format ( self . username , self . host ) ) [EOL] query = ssh . expect ( [ [string] , pexpect . TIMEOUT , pexpect . EOF , [string] , [string] , [string] , [string] ] , timeout = [number] ) [EOL] if query == [number] : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] if query == [number] : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] if query == [number] : [EOL] ssh . sendline ( [string] ) [EOL] ssh . expect ( [string] ) [EOL] elif query == [number] : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] elif query == [number] : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] elif query == [number] : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] ssh . sendline ( self . password ) [EOL] ssh . expect ( [string] ) [EOL] ssh . sendline ( [string] ) [EOL] ssh . expect ( [string] ) [EOL] devices_result = ssh . before . split ( [string] ) [EOL] ssh . sendline ( [string] ) [EOL] [EOL] devices = { } [EOL] for device in devices_result : [EOL] match = _DEVICES_REGEX . search ( device . decode ( [string] ) ) [EOL] if match : [EOL] devices [ match . group ( [string] ) ] = { [string] : match . group ( [string] ) , [string] : match . group ( [string] ) . upper ( ) , [string] : match . group ( [string] ) } [EOL] return devices [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . mqtt import ( valid_publish_topic , valid_subscribe_topic ) [EOL] from homeassistant . const import CONF_OPTIMISTIC [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] from . const import ( ATTR_DEVICES , CONF_BAUD_RATE , CONF_DEVICE , CONF_GATEWAYS , CONF_NODES , CONF_PERSISTENCE , CONF_PERSISTENCE_FILE , CONF_RETAIN , CONF_TCP_PORT , CONF_TOPIC_IN_PREFIX , CONF_TOPIC_OUT_PREFIX , CONF_VERSION , DOMAIN , MYSENSORS_GATEWAYS ) [EOL] from . device import get_mysensors_devices [EOL] from . gateway import get_mysensors_gateway , setup_gateways , finish_setup [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DEBUG = [string] [EOL] CONF_NODE_NAME = [string] [EOL] [EOL] DEFAULT_BAUD_RATE = [number] [EOL] DEFAULT_TCP_PORT = [number] [EOL] DEFAULT_VERSION = [string] [EOL] [EOL] [EOL] def has_all_unique_files ( value ) : [EOL] [docstring] [EOL] persistence_files = [ gateway . get ( CONF_PERSISTENCE_FILE ) for gateway in value ] [EOL] if None in persistence_files and any ( name is not None for name in persistence_files ) : [EOL] raise vol . Invalid ( [string] ) [EOL] if not all ( name is None for name in persistence_files ) : [EOL] schema = vol . Schema ( vol . Unique ( ) ) [EOL] schema ( persistence_files ) [EOL] return value [EOL] [EOL] [EOL] def is_persistence_file ( value ) : [EOL] [docstring] [EOL] if value . endswith ( ( [string] , [string] ) ) : [EOL] return value [EOL] raise vol . Invalid ( [string] . format ( value ) ) [EOL] [EOL] [EOL] def deprecated ( key ) : [EOL] [docstring] [EOL] def validator ( config ) : [EOL] [docstring] [EOL] if key not in config : [EOL] return config [EOL] _LOGGER . warning ( [string] [string] , key , DOMAIN , key ) [EOL] config . pop ( key ) [EOL] return config [EOL] return validator [EOL] [EOL] [EOL] NODE_SCHEMA = vol . Schema ( { cv . positive_int : { vol . Required ( CONF_NODE_NAME ) : cv . string } } ) [EOL] [EOL] GATEWAY_SCHEMA = { vol . Required ( CONF_DEVICE ) : cv . string , vol . Optional ( CONF_PERSISTENCE_FILE ) : vol . All ( cv . string , is_persistence_file ) , vol . Optional ( CONF_BAUD_RATE , default = DEFAULT_BAUD_RATE ) : cv . positive_int , vol . Optional ( CONF_TCP_PORT , default = DEFAULT_TCP_PORT ) : cv . port , vol . Optional ( CONF_TOPIC_IN_PREFIX ) : valid_subscribe_topic , vol . Optional ( CONF_TOPIC_OUT_PREFIX ) : valid_publish_topic , vol . Optional ( CONF_NODES , default = { } ) : NODE_SCHEMA , } [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( vol . All ( deprecated ( CONF_DEBUG ) , { vol . Required ( CONF_GATEWAYS ) : vol . All ( cv . ensure_list , has_all_unique_files , [ GATEWAY_SCHEMA ] ) , vol . Optional ( CONF_OPTIMISTIC , default = False ) : cv . boolean , vol . Optional ( CONF_PERSISTENCE , default = True ) : cv . boolean , vol . Optional ( CONF_RETAIN , default = True ) : cv . boolean , vol . Optional ( CONF_VERSION , default = DEFAULT_VERSION ) : cv . string , } ) ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] gateways = await setup_gateways ( hass , config ) [EOL] [EOL] if not gateways : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] hass . data [ MYSENSORS_GATEWAYS ] = gateways [EOL] [EOL] hass . async_add_job ( finish_setup ( hass , gateways ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def _get_mysensors_name ( gateway , node_id , child_id ) : [EOL] [docstring] [EOL] node_name = [string] . format ( gateway . sensors [ node_id ] . sketch_name , node_id ) [EOL] node_name = next ( ( node [ CONF_NODE_NAME ] for conf_id , node in gateway . nodes_config . items ( ) if node . get ( CONF_NODE_NAME ) is not None and conf_id == node_id ) , node_name ) [EOL] return [string] . format ( node_name , child_id ) [EOL] [EOL] [EOL] @ callback def setup_mysensors_platform ( hass , domain , discovery_info , device_class , device_args = None , async_add_entities = None ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] if not discovery_info : [EOL] return [EOL] if device_args is None : [EOL] device_args = ( ) [EOL] new_devices = [ ] [EOL] new_dev_ids = discovery_info [ ATTR_DEVICES ] [EOL] for dev_id in new_dev_ids : [EOL] devices = get_mysensors_devices ( hass , domain ) [EOL] if dev_id in devices : [EOL] continue [EOL] gateway_id , node_id , child_id , value_type = dev_id [EOL] gateway = get_mysensors_gateway ( hass , gateway_id ) [EOL] if not gateway : [EOL] continue [EOL] device_class_copy = device_class [EOL] if isinstance ( device_class , dict ) : [EOL] child = gateway . sensors [ node_id ] . children [ child_id ] [EOL] s_type = gateway . const . Presentation ( child . type ) . name [EOL] device_class_copy = device_class [ s_type ] [EOL] name = _get_mysensors_name ( gateway , node_id , child_id ) [EOL] [EOL] args_copy = ( * device_args , gateway , node_id , child_id , name , value_type ) [EOL] devices [ dev_id ] = device_class_copy ( * args_copy ) [EOL] new_devices . append ( devices [ dev_id ] ) [EOL] if new_devices : [EOL] _LOGGER . info ( [string] , new_devices ) [EOL] if async_add_entities is not None : [EOL] async_add_entities ( new_devices , True ) [EOL] return new_devices [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , DefaultDict , List , Any , Dict [EOL] import asyncio [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] from collections import defaultdict [EOL] import logging [EOL] import socket [EOL] import sys [EOL] from timeit import default_timer as timer [EOL] [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_OPTIMISTIC , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers import discovery [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_send [EOL] from homeassistant . setup import async_setup_component [EOL] [EOL] from . const import ( ATTR_DEVICES , CONF_BAUD_RATE , CONF_DEVICE , CONF_GATEWAYS , CONF_NODES , CONF_PERSISTENCE , CONF_PERSISTENCE_FILE , CONF_RETAIN , CONF_TCP_PORT , CONF_TOPIC_IN_PREFIX , CONF_TOPIC_OUT_PREFIX , CONF_VERSION , DOMAIN , MYSENSORS_CONST_SCHEMA , MYSENSORS_GATEWAYS , PLATFORM , SCHEMA , SIGNAL_CALLBACK , TYPE ) [EOL] from . device import get_mysensors_devices [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] GATEWAY_READY_TIMEOUT = [number] [EOL] MQTT_COMPONENT = [string] [EOL] MYSENSORS_GATEWAY_READY = [string] [EOL] [EOL] [EOL] def is_serial_port ( value ) : [EOL] [docstring] [EOL] if sys . platform . startswith ( [string] ) : [EOL] ports = ( [string] . format ( idx + [number] ) for idx in range ( [number] ) ) [EOL] if value in ports : [EOL] return value [EOL] raise vol . Invalid ( [string] . format ( value ) ) [EOL] return cv . isdevice ( value ) [EOL] [EOL] [EOL] def is_socket_address ( value ) : [EOL] [docstring] [EOL] try : [EOL] socket . getaddrinfo ( value , None ) [EOL] return value [EOL] except OSError : [EOL] raise vol . Invalid ( [string] ) [EOL] [EOL] [EOL] def get_mysensors_gateway ( hass , gateway_id ) : [EOL] [docstring] [EOL] if MYSENSORS_GATEWAYS not in hass . data : [EOL] hass . data [ MYSENSORS_GATEWAYS ] = { } [EOL] gateways = hass . data . get ( MYSENSORS_GATEWAYS ) [EOL] return gateways . get ( gateway_id ) [EOL] [EOL] [EOL] async def setup_gateways ( hass , config ) : [EOL] [docstring] [EOL] conf = config [ DOMAIN ] [EOL] gateways = { } [EOL] [EOL] for index , gateway_conf in enumerate ( conf [ CONF_GATEWAYS ] ) : [EOL] persistence_file = gateway_conf . get ( CONF_PERSISTENCE_FILE , hass . config . path ( [string] . format ( index + [number] ) ) ) [EOL] ready_gateway = await _get_gateway ( hass , config , gateway_conf , persistence_file ) [EOL] if ready_gateway is not None : [EOL] gateways [ id ( ready_gateway ) ] = ready_gateway [EOL] [EOL] return gateways [EOL] [EOL] [EOL] async def _get_gateway ( hass , config , gateway_conf , persistence_file ) : [EOL] [docstring] [EOL] from mysensors import mysensors [EOL] [EOL] conf = config [ DOMAIN ] [EOL] persistence = conf [ CONF_PERSISTENCE ] [EOL] version = conf [ CONF_VERSION ] [EOL] device = gateway_conf [ CONF_DEVICE ] [EOL] baud_rate = gateway_conf [ CONF_BAUD_RATE ] [EOL] tcp_port = gateway_conf [ CONF_TCP_PORT ] [EOL] in_prefix = gateway_conf . get ( CONF_TOPIC_IN_PREFIX , [string] ) [EOL] out_prefix = gateway_conf . get ( CONF_TOPIC_OUT_PREFIX , [string] ) [EOL] [EOL] if device == MQTT_COMPONENT : [EOL] if not await async_setup_component ( hass , MQTT_COMPONENT , config ) : [EOL] return None [EOL] mqtt = hass . components . mqtt [EOL] retain = conf [ CONF_RETAIN ] [EOL] [EOL] def pub_callback ( topic , payload , qos , retain ) : [EOL] [docstring] [EOL] mqtt . async_publish ( topic , payload , qos , retain ) [EOL] [EOL] def sub_callback ( topic , sub_cb , qos ) : [EOL] [docstring] [EOL] @ callback def internal_callback ( * args ) : [EOL] [docstring] [EOL] sub_cb ( * args ) [EOL] [EOL] hass . async_add_job ( mqtt . async_subscribe ( topic , internal_callback , qos ) ) [EOL] [EOL] gateway = mysensors . AsyncMQTTGateway ( pub_callback , sub_callback , in_prefix = in_prefix , out_prefix = out_prefix , retain = retain , loop = hass . loop , event_callback = None , persistence = persistence , persistence_file = persistence_file , protocol_version = version ) [EOL] else : [EOL] try : [EOL] await hass . async_add_job ( is_serial_port , device ) [EOL] gateway = mysensors . AsyncSerialGateway ( device , baud = baud_rate , loop = hass . loop , event_callback = None , persistence = persistence , persistence_file = persistence_file , protocol_version = version ) [EOL] except vol . Invalid : [EOL] try : [EOL] await hass . async_add_job ( is_socket_address , device ) [EOL] [comment] [EOL] gateway = mysensors . AsyncTCPGateway ( device , port = tcp_port , loop = hass . loop , event_callback = None , persistence = persistence , persistence_file = persistence_file , protocol_version = version ) [EOL] except vol . Invalid : [EOL] [comment] [EOL] return None [EOL] gateway . metric = hass . config . units . is_metric [EOL] gateway . optimistic = conf [ CONF_OPTIMISTIC ] [EOL] gateway . device = device [EOL] gateway . event_callback = _gw_callback_factory ( hass ) [EOL] gateway . nodes_config = gateway_conf [ CONF_NODES ] [EOL] if persistence : [EOL] await gateway . start_persistence ( ) [EOL] [EOL] return gateway [EOL] [EOL] [EOL] async def finish_setup ( hass , gateways ) : [EOL] [docstring] [EOL] discover_tasks = [ ] [EOL] start_tasks = [ ] [EOL] for gateway in gateways . values ( ) : [EOL] discover_tasks . append ( _discover_persistent_devices ( hass , gateway ) ) [EOL] start_tasks . append ( _gw_start ( hass , gateway ) ) [EOL] if discover_tasks : [EOL] [comment] [EOL] await asyncio . wait ( discover_tasks , loop = hass . loop ) [EOL] if start_tasks : [EOL] await asyncio . wait ( start_tasks , loop = hass . loop ) [EOL] [EOL] [EOL] async def _discover_persistent_devices ( hass , gateway ) : [EOL] [docstring] [EOL] tasks = [ ] [EOL] new_devices = defaultdict ( list ) [EOL] for node_id in gateway . sensors : [EOL] node = gateway . sensors [ node_id ] [EOL] for child in node . children . values ( ) : [EOL] validated = _validate_child ( gateway , node_id , child ) [EOL] for platform , dev_ids in validated . items ( ) : [EOL] new_devices [ platform ] . extend ( dev_ids ) [EOL] for platform , dev_ids in new_devices . items ( ) : [EOL] tasks . append ( _discover_mysensors_platform ( hass , platform , dev_ids ) ) [EOL] if tasks : [EOL] await asyncio . wait ( tasks , loop = hass . loop ) [EOL] [EOL] [EOL] @ callback def _discover_mysensors_platform ( hass , platform , new_devices ) : [EOL] [docstring] [EOL] task = hass . async_create_task ( discovery . async_load_platform ( hass , platform , DOMAIN , { ATTR_DEVICES : new_devices , CONF_NAME : DOMAIN } ) ) [EOL] return task [EOL] [EOL] [EOL] async def _gw_start ( hass , gateway ) : [EOL] [docstring] [EOL] [comment] [EOL] connect_task = hass . loop . create_task ( gateway . start ( ) ) [EOL] [EOL] @ callback def gw_stop ( event ) : [EOL] [docstring] [EOL] hass . async_add_job ( gateway . stop ( ) ) [EOL] if not connect_task . done ( ) : [EOL] connect_task . cancel ( ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , gw_stop ) [EOL] if gateway . device == [string] : [EOL] [comment] [EOL] return [EOL] gateway_ready = asyncio . Future ( ) [EOL] gateway_ready_key = MYSENSORS_GATEWAY_READY . format ( id ( gateway ) ) [EOL] hass . data [ gateway_ready_key ] = gateway_ready [EOL] [EOL] try : [EOL] with async_timeout . timeout ( GATEWAY_READY_TIMEOUT , loop = hass . loop ) : [EOL] await gateway_ready [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . warning ( [string] , gateway . device , GATEWAY_READY_TIMEOUT ) [EOL] finally : [EOL] hass . data . pop ( gateway_ready_key , None ) [EOL] [EOL] [EOL] def _gw_callback_factory ( hass ) : [EOL] [docstring] [EOL] @ callback def mysensors_callback ( msg ) : [EOL] [docstring] [EOL] start = timer ( ) [EOL] _LOGGER . debug ( [string] , msg . node_id , msg . child_id ) [EOL] [EOL] _set_gateway_ready ( hass , msg ) [EOL] [EOL] try : [EOL] child = msg . gateway . sensors [ msg . node_id ] . children [ msg . child_id ] [EOL] except KeyError : [EOL] _LOGGER . debug ( [string] , msg . node_id ) [EOL] return [EOL] [EOL] signals = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] validated = _validate_child ( msg . gateway , msg . node_id , child ) [EOL] for platform , dev_ids in validated . items ( ) : [EOL] devices = get_mysensors_devices ( hass , platform ) [EOL] new_dev_ids = [ ] [EOL] for dev_id in dev_ids : [EOL] if dev_id in devices : [EOL] signals . append ( SIGNAL_CALLBACK . format ( * dev_id ) ) [EOL] else : [EOL] new_dev_ids . append ( dev_id ) [EOL] if new_dev_ids : [EOL] _discover_mysensors_platform ( hass , platform , new_dev_ids ) [EOL] for signal in set ( signals ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] async_dispatcher_send ( hass , signal ) [EOL] end = timer ( ) [EOL] if end - start > [number] : [EOL] _LOGGER . debug ( [string] , msg . node_id , msg . child_id , end - start ) [EOL] return mysensors_callback [EOL] [EOL] [EOL] @ callback def _set_gateway_ready ( hass , msg ) : [EOL] [docstring] [EOL] if ( msg . type != msg . gateway . const . MessageType . internal or msg . sub_type != msg . gateway . const . Internal . I_GATEWAY_READY ) : [EOL] return [EOL] gateway_ready = hass . data . get ( MYSENSORS_GATEWAY_READY . format ( id ( msg . gateway ) ) ) [EOL] if gateway_ready is None or gateway_ready . cancelled ( ) : [EOL] return [EOL] gateway_ready . set_result ( True ) [EOL] [EOL] [EOL] def _validate_child ( gateway , node_id , child ) : [EOL] [docstring] [EOL] validated = defaultdict ( list ) [EOL] [EOL] if not child . values : [EOL] _LOGGER . debug ( [string] , node_id , child . id ) [EOL] return validated [EOL] if gateway . sensors [ node_id ] . sketch_name is None : [EOL] _LOGGER . debug ( [string] , node_id ) [EOL] return validated [EOL] pres = gateway . const . Presentation [EOL] set_req = gateway . const . SetReq [EOL] s_name = next ( ( member . name for member in pres if member . value == child . type ) , None ) [EOL] if s_name not in MYSENSORS_CONST_SCHEMA : [EOL] _LOGGER . warning ( [string] , s_name ) [EOL] return validated [EOL] child_schemas = MYSENSORS_CONST_SCHEMA [ s_name ] [EOL] [EOL] def msg ( name ) : [EOL] [docstring] [EOL] return [string] . format ( pres ( child . type ) . name , set_req [ name ] . name ) [EOL] [EOL] for schema in child_schemas : [EOL] platform = schema [ PLATFORM ] [EOL] v_name = schema [ TYPE ] [EOL] value_type = next ( ( member . value for member in set_req if member . name == v_name ) , None ) [EOL] if value_type is None : [EOL] continue [EOL] _child_schema = child . get_schema ( gateway . protocol_version ) [EOL] vol_schema = _child_schema . extend ( { vol . Required ( set_req [ key ] . value , msg = msg ( key ) ) : _child_schema . schema . get ( set_req [ key ] . value , val ) for key , val in schema . get ( SCHEMA , { v_name : cv . string } ) . items ( ) } , extra = vol . ALLOW_EXTRA ) [EOL] try : [EOL] vol_schema ( child . values ) [EOL] except vol . Invalid as exc : [EOL] level = ( logging . WARNING if value_type in child . values [EOL] else logging . DEBUG ) [EOL] _LOGGER . log ( level , [string] , child . values , platform , node_id , child . id , exc ) [EOL] continue [EOL] dev_id = id ( gateway ) , node_id , child . id , value_type [EOL] validated [ platform ] . append ( dev_id ) [EOL] return validated [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import time [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . cover import ( CoverDevice , PLATFORM_SCHEMA , SUPPORT_OPEN , SUPPORT_CLOSE , SUPPORT_STOP ) [EOL] from homeassistant . components . velbus import DOMAIN [EOL] from homeassistant . const import ( CONF_COVERS , CONF_NAME ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] COVER_SCHEMA = vol . Schema ( { vol . Required ( [string] ) : cv . positive_int , vol . Required ( [string] ) : cv . positive_int , vol . Required ( [string] ) : cv . positive_int , vol . Required ( CONF_NAME ) : cv . string } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_COVERS ) : vol . Schema ( { cv . slug : COVER_SCHEMA } ) , } ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devices = config . get ( CONF_COVERS , { } ) [EOL] covers = [ ] [EOL] [EOL] velbus = hass . data [ DOMAIN ] [EOL] for device_name , device_config in devices . items ( ) : [EOL] covers . append ( VelbusCover ( velbus , device_config . get ( CONF_NAME , device_name ) , device_config . get ( [string] ) , device_config . get ( [string] ) , device_config . get ( [string] ) ) ) [EOL] [EOL] if not covers : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] add_entities ( covers ) [EOL] [EOL] [EOL] class VelbusCover ( CoverDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , velbus , name , module , open_channel , close_channel ) : [EOL] [docstring] [EOL] self . _velbus = velbus [EOL] self . _name = name [EOL] self . _close_channel_state = None [EOL] self . _open_channel_state = None [EOL] self . _module = module [EOL] self . _open_channel = open_channel [EOL] self . _close_channel = close_channel [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] def _init_velbus ( ) : [EOL] [docstring] [EOL] self . _velbus . subscribe ( self . _on_message ) [EOL] self . get_status ( ) [EOL] [EOL] await self . hass . async_add_job ( _init_velbus ) [EOL] [EOL] def _on_message ( self , message ) : [EOL] import velbus [EOL] if isinstance ( message , velbus . RelayStatusMessage ) : [EOL] if message . address == self . _module : [EOL] if message . channel == self . _close_channel : [EOL] self . _close_channel_state = message . is_on ( ) [EOL] self . schedule_update_ha_state ( ) [EOL] if message . channel == self . _open_channel : [EOL] self . _open_channel_state = message . is_on ( ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_OPEN | SUPPORT_CLOSE | SUPPORT_STOP [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] return self . _close_channel_state [EOL] [EOL] @ property def current_cover_position ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def _relay_off ( self , channel ) : [EOL] import velbus [EOL] message = velbus . SwitchRelayOffMessage ( ) [EOL] message . set_defaults ( self . _module ) [EOL] message . relay_channels = [ channel ] [EOL] self . _velbus . send ( message ) [EOL] [EOL] def _relay_on ( self , channel ) : [EOL] import velbus [EOL] message = velbus . SwitchRelayOnMessage ( ) [EOL] message . set_defaults ( self . _module ) [EOL] message . relay_channels = [ channel ] [EOL] self . _velbus . send ( message ) [EOL] [EOL] def open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _relay_off ( self . _close_channel ) [EOL] time . sleep ( [number] ) [EOL] self . _relay_on ( self . _open_channel ) [EOL] [EOL] def close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _relay_off ( self . _open_channel ) [EOL] time . sleep ( [number] ) [EOL] self . _relay_on ( self . _close_channel ) [EOL] [EOL] def stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _relay_off ( self . _open_channel ) [EOL] time . sleep ( [number] ) [EOL] self . _relay_off ( self . _close_channel ) [EOL] [EOL] def get_status ( self ) : [EOL] [docstring] [EOL] import velbus [EOL] message = velbus . ModuleStatusRequestMessage ( ) [EOL] message . set_defaults ( self . _module ) [EOL] message . channels = [ self . _open_channel , self . _close_channel ] [EOL] self . _velbus . send ( message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . cover import ( DOMAIN , PLATFORM_SCHEMA , CoverDevice , ATTR_POSITION , ATTR_CURRENT_POSITION , ATTR_TILT_POSITION , ATTR_CURRENT_TILT_POSITION , SUPPORT_OPEN , SUPPORT_CLOSE , SUPPORT_STOP , SUPPORT_SET_POSITION , SUPPORT_OPEN_TILT , SUPPORT_CLOSE_TILT , SUPPORT_STOP_TILT , SUPPORT_SET_TILT_POSITION , SERVICE_OPEN_COVER , SERVICE_CLOSE_COVER , SERVICE_SET_COVER_POSITION , SERVICE_STOP_COVER , SERVICE_OPEN_COVER_TILT , SERVICE_CLOSE_COVER_TILT , SERVICE_STOP_COVER_TILT , SERVICE_SET_COVER_TILT_POSITION ) [EOL] from homeassistant . const import ( ATTR_ASSUMED_STATE , ATTR_ENTITY_ID , ATTR_SUPPORTED_FEATURES , CONF_ENTITIES , CONF_NAME , STATE_CLOSED ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] KEY_OPEN_CLOSE = [string] [EOL] KEY_STOP = [string] [EOL] KEY_POSITION = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Required ( CONF_ENTITIES ) : cv . entities_domain ( DOMAIN ) , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] async_add_entities ( [ CoverGroup ( config [ CONF_NAME ] , config [ CONF_ENTITIES ] ) ] ) [EOL] [EOL] [EOL] class CoverGroup ( CoverDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , entities ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _is_closed = False [EOL] self . _cover_position = [number] [EOL] self . _tilt_position = None [EOL] self . _supported_features = [number] [EOL] self . _assumed_state = True [EOL] [EOL] self . _entities = entities [EOL] self . _covers = { KEY_OPEN_CLOSE : set ( ) , KEY_STOP : set ( ) , KEY_POSITION : set ( ) } [EOL] self . _tilts = { KEY_OPEN_CLOSE : set ( ) , KEY_STOP : set ( ) , KEY_POSITION : set ( ) } [EOL] [EOL] @ callback def update_supported_features ( self , entity_id , old_state , new_state , update_state = True ) : [EOL] [docstring] [EOL] if not new_state : [EOL] for values in self . _covers . values ( ) : [EOL] values . discard ( entity_id ) [EOL] for values in self . _tilts . values ( ) : [EOL] values . discard ( entity_id ) [EOL] if update_state : [EOL] self . async_schedule_update_ha_state ( True ) [EOL] return [EOL] [EOL] features = new_state . attributes . get ( ATTR_SUPPORTED_FEATURES , [number] ) [EOL] [EOL] if features & ( SUPPORT_OPEN | SUPPORT_CLOSE ) : [EOL] self . _covers [ KEY_OPEN_CLOSE ] . add ( entity_id ) [EOL] else : [EOL] self . _covers [ KEY_OPEN_CLOSE ] . discard ( entity_id ) [EOL] if features & (SUPPORT_STOP) : [EOL] self . _covers [ KEY_STOP ] . add ( entity_id ) [EOL] else : [EOL] self . _covers [ KEY_STOP ] . discard ( entity_id ) [EOL] if features & (SUPPORT_SET_POSITION) : [EOL] self . _covers [ KEY_POSITION ] . add ( entity_id ) [EOL] else : [EOL] self . _covers [ KEY_POSITION ] . discard ( entity_id ) [EOL] [EOL] if features & ( SUPPORT_OPEN_TILT | SUPPORT_CLOSE_TILT ) : [EOL] self . _tilts [ KEY_OPEN_CLOSE ] . add ( entity_id ) [EOL] else : [EOL] self . _tilts [ KEY_OPEN_CLOSE ] . discard ( entity_id ) [EOL] if features & (SUPPORT_STOP_TILT) : [EOL] self . _tilts [ KEY_STOP ] . add ( entity_id ) [EOL] else : [EOL] self . _tilts [ KEY_STOP ] . discard ( entity_id ) [EOL] if features & (SUPPORT_SET_TILT_POSITION) : [EOL] self . _tilts [ KEY_POSITION ] . add ( entity_id ) [EOL] else : [EOL] self . _tilts [ KEY_POSITION ] . discard ( entity_id ) [EOL] [EOL] if update_state : [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] for entity_id in self . _entities : [EOL] new_state = self . hass . states . get ( entity_id ) [EOL] self . update_supported_features ( entity_id , None , new_state , update_state = False ) [EOL] async_track_state_change ( self . hass , self . _entities , self . update_supported_features ) [EOL] await self . async_update ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return self . _assumed_state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported_features [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] return self . _is_closed [EOL] [EOL] @ property def current_cover_position ( self ) : [EOL] [docstring] [EOL] return self . _cover_position [EOL] [EOL] @ property def current_cover_tilt_position ( self ) : [EOL] [docstring] [EOL] return self . _tilt_position [EOL] [EOL] async def async_open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : self . _covers [ KEY_OPEN_CLOSE ] } [EOL] await self . hass . services . async_call ( DOMAIN , SERVICE_OPEN_COVER , data , blocking = True ) [EOL] [EOL] async def async_close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : self . _covers [ KEY_OPEN_CLOSE ] } [EOL] await self . hass . services . async_call ( DOMAIN , SERVICE_CLOSE_COVER , data , blocking = True ) [EOL] [EOL] async def async_stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : self . _covers [ KEY_STOP ] } [EOL] await self . hass . services . async_call ( DOMAIN , SERVICE_STOP_COVER , data , blocking = True ) [EOL] [EOL] async def async_set_cover_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : self . _covers [ KEY_POSITION ] , ATTR_POSITION : kwargs [ ATTR_POSITION ] } [EOL] await self . hass . services . async_call ( DOMAIN , SERVICE_SET_COVER_POSITION , data , blocking = True ) [EOL] [EOL] async def async_open_cover_tilt ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : self . _tilts [ KEY_OPEN_CLOSE ] } [EOL] await self . hass . services . async_call ( DOMAIN , SERVICE_OPEN_COVER_TILT , data , blocking = True ) [EOL] [EOL] async def async_close_cover_tilt ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : self . _tilts [ KEY_OPEN_CLOSE ] } [EOL] await self . hass . services . async_call ( DOMAIN , SERVICE_CLOSE_COVER_TILT , data , blocking = True ) [EOL] [EOL] async def async_stop_cover_tilt ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : self . _tilts [ KEY_STOP ] } [EOL] await self . hass . services . async_call ( DOMAIN , SERVICE_STOP_COVER_TILT , data , blocking = True ) [EOL] [EOL] async def async_set_cover_tilt_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : self . _tilts [ KEY_POSITION ] , ATTR_TILT_POSITION : kwargs [ ATTR_TILT_POSITION ] } [EOL] await self . hass . services . async_call ( DOMAIN , SERVICE_SET_COVER_TILT_POSITION , data , blocking = True ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] self . _assumed_state = False [EOL] [EOL] self . _is_closed = True [EOL] for entity_id in self . _entities : [EOL] state = self . hass . states . get ( entity_id ) [EOL] if not state : [EOL] continue [EOL] if state . state != STATE_CLOSED : [EOL] self . _is_closed = False [EOL] break [EOL] [EOL] self . _cover_position = None [EOL] if self . _covers [ KEY_POSITION ] : [EOL] position = - [number] [EOL] self . _cover_position = [number] if self . is_closed else [number] [EOL] for entity_id in self . _covers [ KEY_POSITION ] : [EOL] state = self . hass . states . get ( entity_id ) [EOL] pos = state . attributes . get ( ATTR_CURRENT_POSITION ) [EOL] if position == - [number] : [EOL] position = pos [EOL] elif position != pos : [EOL] self . _assumed_state = True [EOL] break [EOL] else : [EOL] if position != - [number] : [EOL] self . _cover_position = position [EOL] [EOL] self . _tilt_position = None [EOL] if self . _tilts [ KEY_POSITION ] : [EOL] position = - [number] [EOL] self . _tilt_position = [number] [EOL] for entity_id in self . _tilts [ KEY_POSITION ] : [EOL] state = self . hass . states . get ( entity_id ) [EOL] pos = state . attributes . get ( ATTR_CURRENT_TILT_POSITION ) [EOL] if position == - [number] : [EOL] position = pos [EOL] elif position != pos : [EOL] self . _assumed_state = True [EOL] break [EOL] else : [EOL] if position != - [number] : [EOL] self . _tilt_position = position [EOL] [EOL] supported_features = [number] [EOL] supported_features |= SUPPORT_OPEN | SUPPORT_CLOSE \ [EOL] if self . _covers [ KEY_OPEN_CLOSE ] else [number] [EOL] supported_features |= SUPPORT_STOP \ [EOL] if self . _covers [ KEY_STOP ] else [number] [EOL] supported_features |= SUPPORT_SET_POSITION \ [EOL] if self . _covers [ KEY_POSITION ] else [number] [EOL] supported_features |= SUPPORT_OPEN_TILT | SUPPORT_CLOSE_TILT \ [EOL] if self . _tilts [ KEY_OPEN_CLOSE ] else [number] [EOL] supported_features |= SUPPORT_STOP_TILT \ [EOL] if self . _tilts [ KEY_STOP ] else [number] [EOL] supported_features |= SUPPORT_SET_TILT_POSITION \ [EOL] if self . _tilts [ KEY_POSITION ] else [number] [EOL] self . _supported_features = supported_features [EOL] [EOL] if not self . _assumed_state : [EOL] for entity_id in self . _entities : [EOL] state = self . hass . states . get ( entity_id ) [EOL] if state and state . attributes . get ( ATTR_ASSUMED_STATE ) : [EOL] self . _assumed_state = True [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] import copy [EOL] import datetime [EOL] import logging [EOL] import re [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] from homeassistant . const import ( CONF_CODE , CONF_DELAY_TIME , CONF_DISARM_AFTER_TRIGGER , CONF_NAME , CONF_PENDING_TIME , CONF_PLATFORM , CONF_TRIGGER_TIME , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_CUSTOM_BYPASS , STATE_ALARM_ARMED_HOME , STATE_ALARM_ARMED_NIGHT , STATE_ALARM_DISARMED , STATE_ALARM_PENDING , STATE_ALARM_TRIGGERED ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . event import track_point_in_time [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_CODE_TEMPLATE = [string] [EOL] [EOL] DEFAULT_ALARM_NAME = [string] [EOL] DEFAULT_DELAY_TIME = datetime . timedelta ( seconds = [number] ) [EOL] DEFAULT_PENDING_TIME = datetime . timedelta ( seconds = [number] ) [EOL] DEFAULT_TRIGGER_TIME = datetime . timedelta ( seconds = [number] ) [EOL] DEFAULT_DISARM_AFTER_TRIGGER = False [EOL] [EOL] SUPPORTED_STATES = [ STATE_ALARM_DISARMED , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_ARMED_NIGHT , STATE_ALARM_ARMED_CUSTOM_BYPASS , STATE_ALARM_TRIGGERED ] [EOL] [EOL] SUPPORTED_PRETRIGGER_STATES = [ state for state in SUPPORTED_STATES if state != STATE_ALARM_TRIGGERED ] [EOL] [EOL] SUPPORTED_PENDING_STATES = [ state for state in SUPPORTED_STATES if state != STATE_ALARM_DISARMED ] [EOL] [EOL] ATTR_PRE_PENDING_STATE = [string] [EOL] ATTR_POST_PENDING_STATE = [string] [EOL] [EOL] [EOL] def _state_validator ( config ) : [EOL] [docstring] [EOL] config = copy . deepcopy ( config ) [EOL] for state in SUPPORTED_PRETRIGGER_STATES : [EOL] if CONF_DELAY_TIME not in config [ state ] : [EOL] config [ state ] [ CONF_DELAY_TIME ] = config [ CONF_DELAY_TIME ] [EOL] if CONF_TRIGGER_TIME not in config [ state ] : [EOL] config [ state ] [ CONF_TRIGGER_TIME ] = config [ CONF_TRIGGER_TIME ] [EOL] for state in SUPPORTED_PENDING_STATES : [EOL] if CONF_PENDING_TIME not in config [ state ] : [EOL] config [ state ] [ CONF_PENDING_TIME ] = config [ CONF_PENDING_TIME ] [EOL] [EOL] return config [EOL] [EOL] [EOL] def _state_schema ( state ) : [EOL] [docstring] [EOL] schema = { } [EOL] if state in SUPPORTED_PRETRIGGER_STATES : [EOL] schema [ vol . Optional ( CONF_DELAY_TIME ) ] = vol . All ( cv . time_period , cv . positive_timedelta ) [EOL] schema [ vol . Optional ( CONF_TRIGGER_TIME ) ] = vol . All ( cv . time_period , cv . positive_timedelta ) [EOL] if state in SUPPORTED_PENDING_STATES : [EOL] schema [ vol . Optional ( CONF_PENDING_TIME ) ] = vol . All ( cv . time_period , cv . positive_timedelta ) [EOL] return vol . Schema ( schema ) [EOL] [EOL] [EOL] PLATFORM_SCHEMA = vol . Schema ( vol . All ( { vol . Required ( CONF_PLATFORM ) : [string] , vol . Optional ( CONF_NAME , default = DEFAULT_ALARM_NAME ) : cv . string , vol . Exclusive ( CONF_CODE , [string] ) : cv . string , vol . Exclusive ( CONF_CODE_TEMPLATE , [string] ) : cv . template , vol . Optional ( CONF_DELAY_TIME , default = DEFAULT_DELAY_TIME ) : vol . All ( cv . time_period , cv . positive_timedelta ) , vol . Optional ( CONF_PENDING_TIME , default = DEFAULT_PENDING_TIME ) : vol . All ( cv . time_period , cv . positive_timedelta ) , vol . Optional ( CONF_TRIGGER_TIME , default = DEFAULT_TRIGGER_TIME ) : vol . All ( cv . time_period , cv . positive_timedelta ) , vol . Optional ( CONF_DISARM_AFTER_TRIGGER , default = DEFAULT_DISARM_AFTER_TRIGGER ) : cv . boolean , vol . Optional ( STATE_ALARM_ARMED_AWAY , default = { } ) : _state_schema ( STATE_ALARM_ARMED_AWAY ) , vol . Optional ( STATE_ALARM_ARMED_HOME , default = { } ) : _state_schema ( STATE_ALARM_ARMED_HOME ) , vol . Optional ( STATE_ALARM_ARMED_NIGHT , default = { } ) : _state_schema ( STATE_ALARM_ARMED_NIGHT ) , vol . Optional ( STATE_ALARM_ARMED_CUSTOM_BYPASS , default = { } ) : _state_schema ( STATE_ALARM_ARMED_CUSTOM_BYPASS ) , vol . Optional ( STATE_ALARM_DISARMED , default = { } ) : _state_schema ( STATE_ALARM_DISARMED ) , vol . Optional ( STATE_ALARM_TRIGGERED , default = { } ) : _state_schema ( STATE_ALARM_TRIGGERED ) , } , _state_validator ) ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] add_entities ( [ ManualAlarm ( hass , config [ CONF_NAME ] , config . get ( CONF_CODE ) , config . get ( CONF_CODE_TEMPLATE ) , config . get ( CONF_DISARM_AFTER_TRIGGER , DEFAULT_DISARM_AFTER_TRIGGER ) , config ) ] ) [EOL] [EOL] [EOL] class ManualAlarm ( alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , code , code_template , disarm_after_trigger , config ) : [EOL] [docstring] [EOL] self . _state = STATE_ALARM_DISARMED [EOL] self . _hass = hass [EOL] self . _name = name [EOL] if code_template : [EOL] self . _code = code_template [EOL] self . _code . hass = hass [EOL] else : [EOL] self . _code = code or None [EOL] self . _disarm_after_trigger = disarm_after_trigger [EOL] self . _previous_state = self . _state [EOL] self . _state_ts = None [EOL] [EOL] self . _delay_time_by_state = { state : config [ state ] [ CONF_DELAY_TIME ] for state in SUPPORTED_PRETRIGGER_STATES } [EOL] self . _trigger_time_by_state = { state : config [ state ] [ CONF_TRIGGER_TIME ] for state in SUPPORTED_PRETRIGGER_STATES } [EOL] self . _pending_time_by_state = { state : config [ state ] [ CONF_PENDING_TIME ] for state in SUPPORTED_PENDING_STATES } [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _state == STATE_ALARM_TRIGGERED : [EOL] if self . _within_pending_time ( self . _state ) : [EOL] return STATE_ALARM_PENDING [EOL] trigger_time = self . _trigger_time_by_state [ self . _previous_state ] [EOL] if ( self . _state_ts + self . _pending_time ( self . _state ) + trigger_time ) < dt_util . utcnow ( ) : [EOL] if self . _disarm_after_trigger : [EOL] return STATE_ALARM_DISARMED [EOL] self . _state = self . _previous_state [EOL] return self . _state [EOL] [EOL] if self . _state in SUPPORTED_PENDING_STATES and self . _within_pending_time ( self . _state ) : [EOL] return STATE_ALARM_PENDING [EOL] [EOL] return self . _state [EOL] [EOL] @ property def _active_state ( self ) : [EOL] [docstring] [EOL] if self . state == STATE_ALARM_PENDING : [EOL] return self . _previous_state [EOL] return self . _state [EOL] [EOL] def _pending_time ( self , state ) : [EOL] [docstring] [EOL] pending_time = self . _pending_time_by_state [ state ] [EOL] if state == STATE_ALARM_TRIGGERED : [EOL] pending_time += self . _delay_time_by_state [ self . _previous_state ] [EOL] return pending_time [EOL] [EOL] def _within_pending_time ( self , state ) : [EOL] [docstring] [EOL] return self . _state_ts + self . _pending_time ( state ) > dt_util . utcnow ( ) [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] if self . _code is None : [EOL] return None [EOL] if isinstance ( self . _code , str ) and re . search ( [string] , self . _code ) : [EOL] return [string] [EOL] return [string] [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , STATE_ALARM_DISARMED ) : [EOL] return [EOL] [EOL] self . _state = STATE_ALARM_DISARMED [EOL] self . _state_ts = dt_util . utcnow ( ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , STATE_ALARM_ARMED_HOME ) : [EOL] return [EOL] [EOL] self . _update_state ( STATE_ALARM_ARMED_HOME ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , STATE_ALARM_ARMED_AWAY ) : [EOL] return [EOL] [EOL] self . _update_state ( STATE_ALARM_ARMED_AWAY ) [EOL] [EOL] def alarm_arm_night ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , STATE_ALARM_ARMED_NIGHT ) : [EOL] return [EOL] [EOL] self . _update_state ( STATE_ALARM_ARMED_NIGHT ) [EOL] [EOL] def alarm_arm_custom_bypass ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , STATE_ALARM_ARMED_CUSTOM_BYPASS ) : [EOL] return [EOL] [EOL] self . _update_state ( STATE_ALARM_ARMED_CUSTOM_BYPASS ) [EOL] [EOL] def alarm_trigger ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _trigger_time_by_state [ self . _active_state ] : [EOL] return [EOL] self . _update_state ( STATE_ALARM_TRIGGERED ) [EOL] [EOL] def _update_state ( self , state ) : [EOL] [docstring] [EOL] if self . _state == state : [EOL] return [EOL] [EOL] self . _previous_state = self . _state [EOL] self . _state = state [EOL] self . _state_ts = dt_util . utcnow ( ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] pending_time = self . _pending_time ( state ) [EOL] if state == STATE_ALARM_TRIGGERED : [EOL] track_point_in_time ( self . _hass , self . async_update_ha_state , self . _state_ts + pending_time ) [EOL] [EOL] trigger_time = self . _trigger_time_by_state [ self . _previous_state ] [EOL] track_point_in_time ( self . _hass , self . async_update_ha_state , self . _state_ts + pending_time + trigger_time ) [EOL] elif state in SUPPORTED_PENDING_STATES and pending_time : [EOL] track_point_in_time ( self . _hass , self . async_update_ha_state , self . _state_ts + pending_time ) [EOL] [EOL] def _validate_code ( self , code , state ) : [EOL] [docstring] [EOL] if self . _code is None : [EOL] return True [EOL] if isinstance ( self . _code , str ) : [EOL] alarm_code = self . _code [EOL] else : [EOL] alarm_code = self . _code . render ( from_state = self . _state , to_state = state ) [EOL] check = not alarm_code or code == alarm_code [EOL] if not check : [EOL] _LOGGER . warning ( [string] , state ) [EOL] return check [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] state_attr = { } [EOL] [EOL] if self . state == STATE_ALARM_PENDING : [EOL] state_attr [ ATTR_PRE_PENDING_STATE ] = self . _previous_state [EOL] state_attr [ ATTR_POST_PENDING_STATE ] = self . _state [EOL] [EOL] return state_attr [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . alarm_control_panel import ( PLATFORM_SCHEMA , AlarmControlPanel ) [EOL] from homeassistant . const import ( CONF_CODE , CONF_NAME , CONF_PASSWORD , CONF_USERNAME , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_UNKNOWN ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] ATTR_ALARM_ACTIVE = [string] [EOL] ATTR_TEMPERATURE = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_CODE ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from simplipy . api import SimpliSafeApiInterface , SimpliSafeAPIException [EOL] name = config . get ( CONF_NAME ) [EOL] code = config . get ( CONF_CODE ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] try : [EOL] simplisafe = SimpliSafeApiInterface ( username , password ) [EOL] except SimpliSafeAPIException : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] systems = [ ] [EOL] [EOL] for system in simplisafe . get_systems ( ) : [EOL] systems . append ( SimpliSafeAlarm ( system , name , code ) ) [EOL] [EOL] add_entities ( systems ) [EOL] [EOL] [EOL] class SimpliSafeAlarm ( AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , simplisafe , name , code ) : [EOL] [docstring] [EOL] self . simplisafe = simplisafe [EOL] self . _name = name [EOL] self . _code = str ( code ) if code else None [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . simplisafe . location_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] if self . _name is not None : [EOL] return self . _name [EOL] return [string] . format ( self . simplisafe . location_id ) [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] if self . _code is None : [EOL] return None [EOL] if isinstance ( self . _code , str ) and re . search ( [string] , self . _code ) : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] status = self . simplisafe . state [EOL] if status . lower ( ) == [string] : [EOL] state = STATE_ALARM_DISARMED [EOL] elif status . lower ( ) == [string] or status . lower ( ) == [string] : [EOL] state = STATE_ALARM_ARMED_HOME [EOL] elif ( status . lower ( ) == [string] or status . lower ( ) == [string] or status . lower ( ) == [string] ) : [EOL] state = STATE_ALARM_ARMED_AWAY [EOL] else : [EOL] state = STATE_UNKNOWN [EOL] return state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = { } [EOL] [EOL] attributes [ ATTR_ALARM_ACTIVE ] = self . simplisafe . alarm_active [EOL] if self . simplisafe . temperature is not None : [EOL] attributes [ ATTR_TEMPERATURE ] = self . simplisafe . temperature [EOL] [EOL] return attributes [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . simplisafe . update ( ) [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , [string] ) : [EOL] return [EOL] self . simplisafe . set_state ( [string] ) [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , [string] ) : [EOL] return [EOL] self . simplisafe . set_state ( [string] ) [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] if not self . _validate_code ( code , [string] ) : [EOL] return [EOL] self . simplisafe . set_state ( [string] ) [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] def _validate_code ( self , code , state ) : [EOL] [docstring] [EOL] check = self . _code is None or code == self . _code [EOL] if not check : [EOL] _LOGGER . warning ( [string] , state ) [EOL] return check [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . hydrawise import ( BINARY_SENSORS , DATA_HYDRAWISE , HydrawiseEntity , DEVICE_MAP , DEVICE_MAP_INDEX ) [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import CONF_MONITORED_CONDITIONS [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = BINARY_SENSORS ) : vol . All ( cv . ensure_list , [ vol . In ( BINARY_SENSORS ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] hydrawise = hass . data [ DATA_HYDRAWISE ] . data [EOL] [EOL] sensors = [ ] [EOL] for sensor_type in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] if sensor_type in [ [string] , [string] ] : [EOL] sensors . append ( HydrawiseBinarySensor ( hydrawise . controller_status , sensor_type ) ) [EOL] [EOL] else : [EOL] [comment] [EOL] for zone in hydrawise . relays : [EOL] zone_data = zone [EOL] zone_data [ [string] ] = hydrawise . controller_status . get ( [string] , False ) [EOL] sensors . append ( HydrawiseBinarySensor ( zone_data , sensor_type ) ) [EOL] [EOL] add_entities ( sensors , True ) [EOL] [EOL] [EOL] class HydrawiseBinarySensor ( HydrawiseEntity , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] mydata = self . hass . data [ DATA_HYDRAWISE ] . data [EOL] if self . _sensor_type == [string] : [EOL] self . _state = mydata . status == [string] [EOL] elif self . _sensor_type == [string] : [EOL] for sensor in mydata . sensors : [EOL] if sensor [ [string] ] == [string] : [EOL] self . _state = sensor [ [string] ] == [number] [EOL] elif self . _sensor_type == [string] : [EOL] if not mydata . running : [EOL] self . _state = False [EOL] elif int ( mydata . running [ [number] ] [ [string] ] ) == self . data [ [string] ] : [EOL] self . _state = True [EOL] else : [EOL] self . _state = False [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_MAP [ self . _sensor_type ] [ DEVICE_MAP_INDEX . index ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Optional , Union , List , Literal , Any [EOL] import typing [EOL] import logging [EOL] import typing_extensions [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import DOMAIN , BinarySensorDevice [EOL] from homeassistant . components . http import HomeAssistantView [EOL] from homeassistant . const import HTTP_UNPROCESSABLE_ENTITY [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] hass . http . register_view ( MyStromView ( async_add_entities ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class MyStromView ( HomeAssistantView ) : [EOL] [docstring] [EOL] [EOL] url = [string] [EOL] name = [string] [EOL] supported_actions = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , add_entities ) : [EOL] [docstring] [EOL] self . buttons = { } [EOL] self . add_entities = add_entities [EOL] [EOL] @ asyncio . coroutine def get ( self , request ) : [EOL] [docstring] [EOL] res = yield from self . _handle ( request . app [ [string] ] , request . query ) [EOL] return res [EOL] [EOL] @ asyncio . coroutine def _handle ( self , hass , data ) : [EOL] [docstring] [EOL] button_action = next ( ( parameter for parameter in data if parameter in self . supported_actions ) , None ) [EOL] [EOL] if button_action is None : [EOL] _LOGGER . error ( [string] , data ) [EOL] return ( [string] . format ( data ) , HTTP_UNPROCESSABLE_ENTITY ) [EOL] [EOL] button_id = data [ button_action ] [EOL] entity_id = [string] . format ( DOMAIN , button_id , button_action ) [EOL] if entity_id not in self . buttons : [EOL] _LOGGER . info ( [string] , button_id , button_action ) [EOL] self . buttons [ entity_id ] = MyStromBinarySensor ( [string] . format ( button_id , button_action ) ) [EOL] self . add_entities ( [ self . buttons [ entity_id ] ] ) [EOL] else : [EOL] new_state = True if self . buttons [ entity_id ] . state == [string] \ [EOL] else False [EOL] self . buttons [ entity_id ] . async_on_update ( new_state ) [EOL] [EOL] [EOL] class MyStromBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , button_id ) : [EOL] [docstring] [EOL] self . _button_id = button_id [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _button_id [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def async_on_update ( self , value ) : [EOL] [docstring] [EOL] self . _state = value [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Union[typing_extensions.Literal[False],typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components import modbus [EOL] from homeassistant . const import CONF_NAME , CONF_SLAVE [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_COIL = [string] [EOL] CONF_COILS = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_COILS ) : [ { vol . Required ( CONF_COIL ) : cv . positive_int , vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_SLAVE ) : cv . positive_int } ] } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] sensors = [ ] [EOL] for coil in config . get ( CONF_COILS ) : [EOL] sensors . append ( ModbusCoilSensor ( coil . get ( CONF_NAME ) , coil . get ( CONF_SLAVE ) , coil . get ( CONF_COIL ) ) ) [EOL] add_entities ( sensors ) [EOL] [EOL] [EOL] class ModbusCoilSensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , slave , coil ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _slave = int ( slave ) if slave else None [EOL] self . _coil = int ( coil ) [EOL] self . _value = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _value [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] result = modbus . HUB . read_coils ( self . _slave , self . _coil , [number] ) [EOL] try : [EOL] self . _value = result . bits [ [number] ] [EOL] except AttributeError : [EOL] _LOGGER . error ( [string] , self . _slave , self . _coil ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import DefaultDict , List , Tuple , Any , Dict , Coroutine [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import json [EOL] import logging [EOL] from collections import defaultdict [EOL] [EOL] from homeassistant . loader import bind_hass [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . components . media_player import ( ATTR_MEDIA_CONTENT_ID , ATTR_MEDIA_CONTENT_TYPE , ATTR_MEDIA_SEEK_POSITION , ATTR_MEDIA_VOLUME_LEVEL , ATTR_MEDIA_VOLUME_MUTED , SERVICE_PLAY_MEDIA , SERVICE_SELECT_SOURCE , ATTR_INPUT_SOURCE ) [EOL] from homeassistant . components . notify import ( ATTR_MESSAGE , SERVICE_NOTIFY ) [EOL] from homeassistant . components . sun import ( STATE_ABOVE_HORIZON , STATE_BELOW_HORIZON ) [EOL] from homeassistant . components . switch . mysensors import ( ATTR_IR_CODE , SERVICE_SEND_IR_CODE ) [EOL] from homeassistant . components . climate import ( ATTR_AUX_HEAT , ATTR_AWAY_MODE , ATTR_FAN_MODE , ATTR_HOLD_MODE , ATTR_HUMIDITY , ATTR_OPERATION_MODE , ATTR_SWING_MODE , SERVICE_SET_AUX_HEAT , SERVICE_SET_AWAY_MODE , SERVICE_SET_HOLD_MODE , SERVICE_SET_FAN_MODE , SERVICE_SET_HUMIDITY , SERVICE_SET_OPERATION_MODE , SERVICE_SET_SWING_MODE , SERVICE_SET_TEMPERATURE , STATE_HEAT , STATE_COOL , STATE_IDLE ) [EOL] from homeassistant . components . climate . ecobee import ( ATTR_FAN_MIN_ON_TIME , SERVICE_SET_FAN_MIN_ON_TIME , ATTR_RESUME_ALL , SERVICE_RESUME_PROGRAM ) [EOL] from homeassistant . components . cover import ( ATTR_POSITION , ATTR_TILT_POSITION ) [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_OPTION , ATTR_TEMPERATURE , SERVICE_ALARM_ARM_AWAY , SERVICE_ALARM_ARM_HOME , SERVICE_ALARM_DISARM , SERVICE_ALARM_TRIGGER , SERVICE_LOCK , SERVICE_MEDIA_PAUSE , SERVICE_MEDIA_PLAY , SERVICE_MEDIA_STOP , SERVICE_MEDIA_SEEK , SERVICE_TURN_OFF , SERVICE_TURN_ON , SERVICE_UNLOCK , SERVICE_VOLUME_MUTE , SERVICE_VOLUME_SET , SERVICE_OPEN_COVER , SERVICE_CLOSE_COVER , SERVICE_SET_COVER_POSITION , SERVICE_SET_COVER_TILT_POSITION , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_ALARM_TRIGGERED , STATE_CLOSED , STATE_HOME , STATE_LOCKED , STATE_NOT_HOME , STATE_OFF , STATE_ON , STATE_OPEN , STATE_PAUSED , STATE_PLAYING , STATE_UNKNOWN , STATE_UNLOCKED , SERVICE_SELECT_OPTION ) [EOL] from homeassistant . core import State [EOL] from homeassistant . util . async_ import run_coroutine_threadsafe [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] GROUP_DOMAIN = [string] [EOL] HASS_DOMAIN = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] SERVICE_ATTRIBUTES = { SERVICE_PLAY_MEDIA : [ ATTR_MEDIA_CONTENT_TYPE , ATTR_MEDIA_CONTENT_ID ] , SERVICE_MEDIA_SEEK : [ ATTR_MEDIA_SEEK_POSITION ] , SERVICE_VOLUME_MUTE : [ ATTR_MEDIA_VOLUME_MUTED ] , SERVICE_VOLUME_SET : [ ATTR_MEDIA_VOLUME_LEVEL ] , SERVICE_NOTIFY : [ ATTR_MESSAGE ] , SERVICE_SET_AWAY_MODE : [ ATTR_AWAY_MODE ] , SERVICE_SET_FAN_MODE : [ ATTR_FAN_MODE ] , SERVICE_SET_FAN_MIN_ON_TIME : [ ATTR_FAN_MIN_ON_TIME ] , SERVICE_RESUME_PROGRAM : [ ATTR_RESUME_ALL ] , SERVICE_SET_TEMPERATURE : [ ATTR_TEMPERATURE ] , SERVICE_SET_HUMIDITY : [ ATTR_HUMIDITY ] , SERVICE_SET_SWING_MODE : [ ATTR_SWING_MODE ] , SERVICE_SET_HOLD_MODE : [ ATTR_HOLD_MODE ] , SERVICE_SET_OPERATION_MODE : [ ATTR_OPERATION_MODE ] , SERVICE_SET_AUX_HEAT : [ ATTR_AUX_HEAT ] , SERVICE_SELECT_SOURCE : [ ATTR_INPUT_SOURCE ] , SERVICE_SEND_IR_CODE : [ ATTR_IR_CODE ] , SERVICE_SELECT_OPTION : [ ATTR_OPTION ] , SERVICE_SET_COVER_POSITION : [ ATTR_POSITION ] , SERVICE_SET_COVER_TILT_POSITION : [ ATTR_TILT_POSITION ] } [EOL] [EOL] [comment] [EOL] [comment] [EOL] SERVICE_TO_STATE = { SERVICE_TURN_ON : STATE_ON , SERVICE_TURN_OFF : STATE_OFF , SERVICE_MEDIA_PLAY : STATE_PLAYING , SERVICE_MEDIA_PAUSE : STATE_PAUSED , SERVICE_MEDIA_STOP : STATE_IDLE , SERVICE_ALARM_ARM_AWAY : STATE_ALARM_ARMED_AWAY , SERVICE_ALARM_ARM_HOME : STATE_ALARM_ARMED_HOME , SERVICE_ALARM_DISARM : STATE_ALARM_DISARMED , SERVICE_ALARM_TRIGGER : STATE_ALARM_TRIGGERED , SERVICE_LOCK : STATE_LOCKED , SERVICE_UNLOCK : STATE_UNLOCKED , SERVICE_OPEN_COVER : STATE_OPEN , SERVICE_CLOSE_COVER : STATE_CLOSED } [EOL] [EOL] [EOL] class AsyncTrackStates : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . states = [ ] [EOL] [EOL] [comment] [EOL] def __enter__ ( self ) : [EOL] [docstring] [EOL] self . now = dt_util . utcnow ( ) [EOL] return self . states [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback ) : [EOL] [docstring] [EOL] self . states . extend ( get_changed_since ( self . hass . states . async_all ( ) , self . now ) ) [EOL] [EOL] [EOL] def get_changed_since ( states , utc_point_in_time ) : [EOL] [docstring] [EOL] return [ state for state in states if state . last_updated >= utc_point_in_time ] [EOL] [EOL] [EOL] @ bind_hass def reproduce_state ( hass , states , blocking = False ) : [EOL] [docstring] [EOL] return run_coroutine_threadsafe ( async_reproduce_state ( hass , states , blocking ) , hass . loop ) . result ( ) [EOL] [EOL] [EOL] @ bind_hass async def async_reproduce_state ( hass , states , blocking = False ) : [EOL] [docstring] [EOL] if isinstance ( states , State ) : [EOL] states = [ states ] [EOL] [EOL] to_call = defaultdict ( list ) [EOL] [EOL] for state in states : [EOL] [EOL] if hass . states . get ( state . entity_id ) is None : [EOL] _LOGGER . warning ( [string] , state . entity_id ) [EOL] continue [EOL] [EOL] if state . domain == GROUP_DOMAIN : [EOL] service_domain = HASS_DOMAIN [EOL] else : [EOL] service_domain = state . domain [EOL] [EOL] domain_services = hass . services . async_services ( ) . get ( service_domain ) [EOL] [EOL] if not domain_services : [EOL] _LOGGER . warning ( [string] , state ) [EOL] continue [EOL] [EOL] service = None [EOL] for _service in domain_services . keys ( ) : [EOL] if ( _service in SERVICE_ATTRIBUTES and all ( attr in state . attributes for attr in SERVICE_ATTRIBUTES [ _service ] ) or _service in SERVICE_TO_STATE and SERVICE_TO_STATE [ _service ] == state . state ) : [EOL] service = _service [EOL] if ( _service in SERVICE_TO_STATE and SERVICE_TO_STATE [ _service ] == state . state ) : [EOL] break [EOL] [EOL] if not service : [EOL] _LOGGER . warning ( [string] , state ) [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] key = ( service_domain , service , json . dumps ( dict ( state . attributes ) , sort_keys = True ) ) [EOL] to_call [ key ] . append ( state . entity_id ) [EOL] [EOL] domain_tasks = { } [EOL] for ( service_domain , service , service_data ) , entity_ids in to_call . items ( ) : [EOL] data = json . loads ( service_data ) [EOL] data [ ATTR_ENTITY_ID ] = entity_ids [EOL] [EOL] if service_domain not in domain_tasks : [EOL] domain_tasks [ service_domain ] = [ ] [EOL] [EOL] domain_tasks [ service_domain ] . append ( hass . services . async_call ( service_domain , service , data , blocking ) ) [EOL] [EOL] async def async_handle_service_calls ( coro_list ) : [EOL] [docstring] [EOL] for coro in coro_list : [EOL] await coro [EOL] [EOL] execute_tasks = [ async_handle_service_calls ( coro_list ) for coro_list in domain_tasks . values ( ) ] [EOL] if execute_tasks : [EOL] await asyncio . wait ( execute_tasks , loop = hass . loop ) [EOL] [EOL] [EOL] def state_as_number ( state ) : [EOL] [docstring] [EOL] if state . state in ( STATE_ON , STATE_LOCKED , STATE_ABOVE_HORIZON , STATE_OPEN , STATE_HOME , STATE_HEAT , STATE_COOL ) : [EOL] return [number] [EOL] if state . state in ( STATE_OFF , STATE_UNLOCKED , STATE_UNKNOWN , STATE_BELOW_HORIZON , STATE_CLOSED , STATE_NOT_HOME , STATE_IDLE ) : [EOL] return [number] [EOL] [EOL] return float ( state . state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0