from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] from setuptools import setup , find_packages [EOL] from codecs import open [EOL] import ruamel . yaml as yaml [EOL] [EOL] [EOL] def load_yaml ( file , keep_order = False ) : [EOL] with open ( file , [string] ) as stream : [EOL] if keep_order : [EOL] return yaml . load ( stream . read ( ) , Loader = yaml . RoundTripLoader ) [EOL] else : [EOL] return yaml . safe_load ( stream . read ( ) ) [EOL] [EOL] [EOL] with open ( [string] ) as f : [EOL] long_description = f . read ( ) [EOL] [EOL] print ( long_description ) [EOL] [EOL] config = load_yaml ( [string] ) [EOL] [EOL] setup ( name = config [ [string] ] , version = config [ [string] ] , author = config [ [string] ] , author_email = config [ [string] ] , maintainer = config [ [string] ] , maintainer_email = config [ [string] ] , url = config [ [string] ] , description = config [ [string] ] , long_description = long_description , long_description_content_type = [string] , download_url = config [ [string] ] + [string] + config [ [string] ] , license = config [ [string] ] , keywords = config [ [string] ] , include_package_data = True , platforms = [ ] , classifiers = [ ] , install_requires = [ ] , packages = find_packages ( where = [string] , exclude = ( [string] , [string] ) ) , package_dir = { [string] : [string] } , package_data = { } , data_files = [ ] , entry_points = { [string] : [ ] , [string] : [ ] } , tests_require = [ ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Optional , Union , Awaitable , Iterator , Any [EOL] import typing [EOL] import asyncio [EOL] import builtins [EOL] [docstring] [EOL] from functools import partial [EOL] from concurrent . futures import ProcessPoolExecutor , ThreadPoolExecutor [EOL] from typing import Optional , List , Callable , Awaitable , Iterable , Any , Union , Iterator [EOL] from types import GeneratorType [EOL] import asyncio [EOL] [EOL] [EOL] class Call : [EOL] [EOL] def __init__ ( self , fn , * args , ** kwargs ) : [EOL] self . fn = fn [EOL] self . args = args [EOL] self . kwargs = kwargs [EOL] [EOL] [EOL] def _call_async ( fn , args , kwargs ) : [EOL] new_loop = asyncio . new_event_loop ( ) [EOL] try : [EOL] coro = fn ( * args , ** kwargs ) [EOL] asyncio . set_event_loop ( new_loop ) [EOL] return new_loop . run_until_complete ( coro ) [EOL] finally : [EOL] new_loop . close ( ) [EOL] [EOL] [EOL] def _call ( fn , args , kwargs , loop , pool ) : [EOL] if asyncio . iscoroutinefunction ( fn ) : [EOL] return loop . run_in_executor ( pool , partial ( _call_async , fn , args , kwargs ) ) [EOL] else : [EOL] return loop . run_in_executor ( pool , partial ( fn , * args , ** kwargs ) ) [EOL] [EOL] [EOL] def _batch_get_calls ( raw_calls ) : [EOL] [EOL] for call in raw_calls : [EOL] [EOL] if isinstance ( call , Call ) : [EOL] yield call [EOL] [EOL] elif isinstance ( call , ( GeneratorType , list ) ) : [EOL] for c in call : [EOL] yield c [EOL] [EOL] [EOL] class ConcurrentBase : [EOL] [EOL] def __init__ ( self , Executor = None , n = None , loop = None , ) : [EOL] self . Executor = Executor [EOL] self . n = n [EOL] self . loop = loop [EOL] self . pool = None [EOL] [EOL] def __enter__ ( self ) : [EOL] self . pool = self . Executor ( ) [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] self . pool . shutdown ( wait = True ) [EOL] return False [EOL] [EOL] def call ( self , fn , * args , ** kwargs ) : [EOL] [EOL] if not self . loop : [EOL] self . loop = asyncio . get_event_loop ( ) [EOL] [EOL] if not self . pool : [EOL] with self . Executor ( self . n ) as pool : [EOL] return _call ( fn , args , kwargs , self . loop , pool ) [EOL] else : [EOL] return _call ( fn , args , kwargs , self . loop , self . pool ) [EOL] [EOL] def batch ( self , * calls , ) : [EOL] [EOL] if not self . loop : [EOL] self . loop = asyncio . get_event_loop ( ) [EOL] [EOL] if not self . pool : [EOL] [EOL] with self . Executor ( self . n ) as pool : [EOL] for c in _batch_get_calls ( calls ) : [EOL] yield _call ( c . fn , c . args , c . kwargs , self . loop , pool ) [EOL] [EOL] else : [EOL] for c in _batch_get_calls ( calls ) : [EOL] yield _call ( c . fn , c . args , c . kwargs , self . loop , self . pool ) [EOL] [EOL] [EOL] class Threads ( ConcurrentBase ) : [EOL] [EOL] def __init__ ( self , n = None , loop = None , ) : [EOL] ConcurrentBase . __init__ ( self , ThreadPoolExecutor , n , loop ) [EOL] [EOL] [EOL] class Procs ( ConcurrentBase ) : [EOL] [EOL] def __init__ ( self , n = None , loop = None , ) : [EOL] ConcurrentBase . __init__ ( self , ProcessPoolExecutor , n , loop ) [EOL] [EOL] [EOL] class Coros ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[typing.Any]$ 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Awaitable[typing.Any]]$ 0 0 0 0 $typing.Union[Call,typing.Iterator[Call]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[Call,typing.Iterator[Call]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[Call,typing.Iterator[Call]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[asyncio.AbstractEventLoop]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[asyncio.AbstractEventLoop]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[asyncio.AbstractEventLoop]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[asyncio.AbstractEventLoop]$ 0 0 0 0 0 0 0 0 0 0 0 0
import aioexec [EOL]	0 0 0