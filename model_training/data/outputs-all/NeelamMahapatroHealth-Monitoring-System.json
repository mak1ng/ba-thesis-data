[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import os [EOL] import time [EOL] [EOL] print ( [string] ) [EOL] time . sleep ( [number] ) [EOL] os . system ( [string] ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Dict [EOL] import typing [EOL] import io [EOL] import typing_extensions [EOL] import logging [EOL] import tornado . web [EOL] import tornado . websocket [EOL] import tornado . ioloop [EOL] import tornado . options [EOL] import time [EOL] [EOL] from tornado . options import define , options [EOL] from tornado . ioloop import IOLoop , PeriodicCallback [EOL] from tornado import gen [EOL] from tornado . websocket import websocket_connect [EOL] [EOL] class data : [EOL] def __init__ ( self , incoming ) : [EOL] self . incoming = incoming [EOL] [EOL] obj = data ( [string] ) [EOL] define ( [string] , default = [number] , help = [string] , type = int ) [EOL] class Client ( object ) : [EOL] def __init__ ( self , url , timeout ) : [EOL] self . url = url [EOL] self . timeout = timeout [EOL] self . ioloop = IOLoop . instance ( ) [EOL] self . ws = None [EOL] self . connect ( ) [EOL] [comment] [EOL] self . ioloop . start ( ) [EOL] [EOL] @ gen . coroutine def connect ( self ) : [EOL] print ( [string] ) [EOL] try : [EOL] self . ws = yield websocket_connect ( self . url ) [EOL] except Exception : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] self . run ( ) [EOL] [EOL] @ gen . coroutine def run ( self ) : [EOL] while True : [EOL] if self . ws is None : [EOL] self . connect ( ) [EOL] else : [EOL] print ( [string] ) [EOL] self . ws . write_message ( obj . incoming ) [EOL] time . sleep ( [number] ) [EOL] self . ws = None [EOL] break [EOL] [EOL] [EOL] class Application ( tornado . web . Application ) : [EOL] def __init__ ( self ) : [EOL] handlers = [ ( [string] , MainHandler ) ] [EOL] settings = dict ( debug = True ) [EOL] tornado . web . Application . __init__ ( self , handlers , ** settings ) [EOL] [EOL] [EOL] class MainHandler ( tornado . websocket . WebSocketHandler ) : [EOL] def check_origin ( self , origin ) : [EOL] return True [EOL] [EOL] def open ( self ) : [EOL] print ( [string] ) [EOL] [comment] [EOL] [EOL] def on_close ( self ) : [EOL] print ( [string] ) [EOL] [comment] [EOL] [EOL] def on_message ( self , message ) : [EOL] obj . incoming = message [EOL] print ( [string] + message ) [EOL] try : [EOL] client = Client ( [string] , [number] ) [EOL] [comment] [EOL] [comment] [EOL] except : [EOL] file = open ( [string] , [string] ) [EOL] file . write ( message + [string] ) [EOL] file . close ( ) [EOL] [comment] [EOL] [EOL] def main ( ) : [EOL] tornado . options . parse_command_line ( ) [EOL] app = Application ( ) [EOL] app . listen ( [number] ) [comment] [EOL] tornado . ioloop . IOLoop . instance ( ) . start ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import sys [EOL] from lib2to3 . main import main [EOL] [EOL] sys . exit ( main ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from tornado import gen [EOL] from tornado . web import RequestHandler [EOL] [EOL] [EOL] class MyHandler ( RequestHandler ) : [EOL] def get ( self ) : [EOL] self . write ( [string] ) [EOL] [EOL] async def post ( self ) : [EOL] await gen . sleep ( [number] ) [EOL] self . write ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from tornado . web import RequestHandler [EOL] [EOL] [EOL] class MyHandler ( RequestHandler ) : [EOL] def get ( self ) : [comment] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from tornado import gen [EOL] [EOL] [EOL] @ gen . coroutine def hello ( ) : [EOL] yield gen . sleep ( [number] ) [EOL] raise gen . Return ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] try : [EOL] import Cython . Build [EOL] except : [EOL] Cython = None [EOL] [EOL] if Cython is None : [EOL] ext_modules = None [EOL] else : [EOL] ext_modules = Cython . Build . cythonize ( [string] ) [EOL] [EOL] setup ( name = [string] , py_modules = [ [string] , [string] ] , ext_modules = ext_modules , setup_requires = [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Literal , Generator , Tuple , Dict [EOL] import typing [EOL] import typing_extensions [EOL] import tornado [EOL] from tornado . testing import AsyncTestCase , gen_test [EOL] from tornado . util import ArgReplacer [EOL] import unittest [EOL] [EOL] import cythonapp [EOL] [EOL] [EOL] class CythonCoroutineTest ( AsyncTestCase ) : [EOL] @ gen_test def test_native_coroutine ( self ) : [EOL] x = yield cythonapp . native_coroutine ( ) [EOL] self . assertEqual ( x , [string] ) [EOL] [EOL] @ gen_test def test_decorated_coroutine ( self ) : [EOL] x = yield cythonapp . decorated_coroutine ( ) [EOL] self . assertEqual ( x , [string] ) [EOL] [EOL] [EOL] class CythonArgReplacerTest ( unittest . TestCase ) : [EOL] def test_arg_replacer_function ( self ) : [EOL] replacer = ArgReplacer ( cythonapp . function_with_args , [string] ) [EOL] args = ( [number] , [string] , [number] ) [EOL] kwargs = { } [EOL] self . assertEqual ( replacer . get_old_value ( args , kwargs ) , [string] ) [EOL] self . assertEqual ( replacer . replace ( [string] , args , kwargs ) , ( [string] , [ [number] , [string] , [number] ] , { } ) ) [EOL] [EOL] def test_arg_replacer_method ( self ) : [EOL] replacer = ArgReplacer ( cythonapp . AClass ( ) . method_with_args , [string] ) [EOL] args = ( [number] , [string] , [number] ) [EOL] kwargs = { } [EOL] self . assertEqual ( replacer . get_old_value ( args , kwargs ) , [string] ) [EOL] self . assertEqual ( replacer . replace ( [string] , args , kwargs ) , ( [string] , [ [number] , [string] , [number] ] , { } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.util.ArgReplacer$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $tornado.util.ArgReplacer$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $tornado.util.ArgReplacer$ 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.util.ArgReplacer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $tornado.util.ArgReplacer$ 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $tornado.util.ArgReplacer$ 0 0 0 0 0 $typing.Tuple[typing_extensions.Literal,typing_extensions.Literal,typing_extensions.Literal]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List , Generator , Set [EOL] import typing [EOL] import tornado [EOL] [docstring] [EOL] [EOL] import gc [EOL] import traceback [EOL] import types [EOL] from tornado import web , ioloop , gen , httpclient [EOL] [EOL] [EOL] def find_circular_references ( garbage = None ) : [EOL] def inner ( level ) : [EOL] for item in level : [EOL] item_id = id ( item ) [EOL] if item_id not in garbage_ids : [EOL] continue [EOL] if item_id in visited_ids : [EOL] continue [EOL] if item_id in stack_ids : [EOL] candidate = stack [ stack . index ( item ) : ] [EOL] candidate . append ( item ) [EOL] found . append ( candidate ) [EOL] continue [EOL] [EOL] stack . append ( item ) [EOL] stack_ids . add ( item_id ) [EOL] inner ( gc . get_referents ( item ) ) [EOL] stack . pop ( ) [EOL] stack_ids . remove ( item_id ) [EOL] visited_ids . add ( item_id ) [EOL] [EOL] garbage = garbage or gc . garbage [EOL] found = [ ] [EOL] stack = [ ] [EOL] stack_ids = set ( ) [EOL] garbage_ids = set ( map ( id , garbage ) ) [EOL] visited_ids = set ( ) [EOL] [EOL] inner ( garbage ) [EOL] inner = None [EOL] return found [EOL] [EOL] [EOL] class CollectHandler ( web . RequestHandler ) : [EOL] @ gen . coroutine def get ( self ) : [EOL] self . write ( [string] . format ( gc . collect ( ) ) ) [EOL] self . write ( [string] . format ( len ( gc . garbage ) ) ) [EOL] for circular in find_circular_references ( ) : [EOL] print ( [string] ) [EOL] for item in circular : [EOL] print ( [string] , repr ( item ) ) [EOL] for item in circular : [EOL] if isinstance ( item , types . FrameType ) : [EOL] print ( [string] , item . f_locals ) [EOL] print ( [string] , repr ( item ) ) [EOL] traceback . print_stack ( item ) [EOL] [EOL] [EOL] class DummyHandler ( web . RequestHandler ) : [EOL] @ gen . coroutine def get ( self ) : [EOL] self . write ( [string] ) [EOL] [EOL] [EOL] class DummyAsyncHandler ( web . RequestHandler ) : [EOL] @ gen . coroutine def get ( self ) : [EOL] raise web . Finish ( [string] ) [EOL] [EOL] [EOL] application = web . Application ( [ ( [string] , DummyHandler ) , ( [string] , DummyAsyncHandler ) , ( [string] , CollectHandler ) , ] , debug = True ) [EOL] [EOL] [EOL] @ gen . coroutine def main ( ) : [EOL] gc . disable ( ) [EOL] gc . collect ( ) [EOL] gc . set_debug ( gc . DEBUG_STATS | gc . DEBUG_SAVEALL ) [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] application . listen ( [number] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] client = httpclient . AsyncHTTPClient ( ) [EOL] yield client . fetch ( [string] ) [EOL] yield client . fetch ( [string] , raise_error = False ) [EOL] [EOL] [comment] [EOL] resp = yield client . fetch ( [string] ) [EOL] print ( resp . body ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] ioloop . IOLoop . current ( ) . run_sync ( main ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = [string] [EOL] version_info = ( [number] , [number] , [number] , - [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] if os . name == [string] : [EOL] from tornado . platform . windows import set_close_exec [EOL] else : [EOL] from tornado . platform . posix import set_close_exec [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def set_close_exec ( fd ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterable , Callable [EOL] import typing [EOL] [docstring] [EOL] from tornado . test . runtests import all , main [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] all = all [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import logging [EOL] import typing [EOL] import logging [EOL] from tornado . ioloop import IOLoop [EOL] from tornado import gen [EOL] from tornado . iostream import StreamClosedError [EOL] from tornado . tcpserver import TCPServer [EOL] from tornado . options import options , define [EOL] [EOL] define ( [string] , default = [number] , help = [string] ) [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class EchoServer ( TCPServer ) : [EOL] @ gen . coroutine def handle_stream ( self , stream , address ) : [EOL] while True : [EOL] try : [EOL] data = yield stream . read_until ( [string] ) [EOL] logger . info ( [string] , data ) [EOL] if not data . endswith ( [string] ) : [EOL] data = data + [string] [EOL] yield stream . write ( data ) [EOL] except StreamClosedError : [EOL] logger . warning ( [string] , address [ [number] ] ) [EOL] break [EOL] except Exception as e : [EOL] print ( e ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] options . parse_command_line ( ) [EOL] server = EchoServer ( ) [EOL] server . listen ( options . port ) [EOL] logger . info ( [string] , options . port ) [EOL] IOLoop . current ( ) . start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Generator [EOL] import typing [EOL] import tornado [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] from tornado . auth import TwitterMixin [EOL] from tornado . escape import json_decode , json_encode [EOL] from tornado . ioloop import IOLoop [EOL] from tornado import gen [EOL] from tornado . options import define , options , parse_command_line , parse_config_file [EOL] from tornado . web import Application , RequestHandler , authenticated [EOL] [EOL] define ( [string] , default = [number] , help = [string] ) [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] [EOL] define ( [string] , default = False , group = [string] , help = [string] , ) [EOL] [comment] [EOL] define ( [string] , type = str , group = [string] ) [EOL] define ( [string] , type = str , group = [string] ) [EOL] define ( [string] , type = str , group = [string] , default = [string] , help = [string] , ) [EOL] [EOL] [EOL] class BaseHandler ( RequestHandler ) : [EOL] COOKIE_NAME = [string] [EOL] [EOL] def get_current_user ( self ) : [EOL] user_json = self . get_secure_cookie ( self . COOKIE_NAME ) [EOL] if not user_json : [EOL] return None [EOL] return json_decode ( user_json ) [EOL] [EOL] [EOL] class MainHandler ( BaseHandler , TwitterMixin ) : [EOL] @ authenticated @ gen . coroutine def get ( self ) : [EOL] timeline = yield self . twitter_request ( [string] , access_token = self . current_user [ [string] ] ) [EOL] self . render ( [string] , timeline = timeline ) [EOL] [EOL] [EOL] class LoginHandler ( BaseHandler , TwitterMixin ) : [EOL] @ gen . coroutine def get ( self ) : [EOL] if self . get_argument ( [string] , None ) : [EOL] user = yield self . get_authenticated_user ( ) [EOL] del user [ [string] ] [EOL] self . set_secure_cookie ( self . COOKIE_NAME , json_encode ( user ) ) [EOL] self . redirect ( self . get_argument ( [string] , [string] ) ) [EOL] else : [EOL] yield self . authorize_redirect ( callback_uri = self . request . full_url ( ) ) [EOL] [EOL] [EOL] class LogoutHandler ( BaseHandler ) : [EOL] def get ( self ) : [EOL] self . clear_cookie ( self . COOKIE_NAME ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parse_command_line ( final = False ) [EOL] parse_config_file ( options . config_file ) [EOL] [EOL] app = Application ( [ ( [string] , MainHandler ) , ( [string] , LoginHandler ) , ( [string] , LogoutHandler ) ] , login_url = [string] , ** options . group_dict ( [string] ) ) [EOL] app . listen ( options . port ) [EOL] [EOL] logging . info ( [string] % options . port ) [EOL] IOLoop . current ( ) . start ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Any , List , Set [EOL] import typing [EOL] import sys [EOL] from setuptools import setup , find_packages [EOL] [EOL] sys . path . insert ( [number] , [string] ) [EOL] from paho . mqtt import __version__ [EOL] [EOL] with open ( [string] , [string] ) as readme_file : [EOL] readme = readme_file . read ( ) . decode ( [string] ) [EOL] [EOL] requirements = [ ] [EOL] test_requirements = [ [string] , [string] ] [EOL] needs_pytest = { [string] , [string] , [string] } . intersection ( sys . argv ) [EOL] setup_requirements = [ [string] ] if needs_pytest else [ ] [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] test_requirements += [ [string] ] [EOL] [EOL] setup ( name = [string] , version = __version__ , description = [string] , long_description = readme , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( [string] ) , package_dir = { [string] : [string] } , include_package_data = True , install_requires = requirements , license = [string] , zip_safe = False , keywords = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , test_suite = [string] , tests_require = test_requirements , setup_requires = setup_requirements ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[builtins.str]]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[builtins.str]]$ 0 0
	0
__version__ = [string] [EOL] [EOL] [EOL] class MQTTException ( Exception ) : [EOL] pass [EOL]	$builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import context [comment] [EOL] import paho . mqtt . subscribe as subscribe [EOL] [EOL] def print_msg ( client , userdata , message ) : [EOL] print ( [string] % ( message . topic , message . payload ) ) [EOL] [EOL] subscribe . callback ( print_msg , [string] , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import socket [EOL] import uuid [EOL] import paho . mqtt . client as mqtt [EOL] import asyncio [EOL] [EOL] client_id = [string] + str ( uuid . uuid4 ( ) ) [EOL] topic = client_id [EOL] print ( [string] + client_id ) [EOL] [EOL] [EOL] class AsyncioHelper : [EOL] def __init__ ( self , loop , client ) : [EOL] self . loop = loop [EOL] self . client = client [EOL] self . client . on_socket_open = self . on_socket_open [EOL] self . client . on_socket_close = self . on_socket_close [EOL] self . client . on_socket_register_write = self . on_socket_register_write [EOL] self . client . on_socket_unregister_write = self . on_socket_unregister_write [EOL] [EOL] def on_socket_open ( self , client , userdata , sock ) : [EOL] print ( [string] ) [EOL] [EOL] def cb ( ) : [EOL] print ( [string] ) [EOL] client . loop_read ( ) [EOL] [EOL] self . loop . add_reader ( sock , cb ) [EOL] self . misc = self . loop . create_task ( self . misc_loop ( ) ) [EOL] [EOL] def on_socket_close ( self , client , userdata , sock ) : [EOL] print ( [string] ) [EOL] self . loop . remove_reader ( sock ) [EOL] self . misc . cancel ( ) [EOL] [EOL] def on_socket_register_write ( self , client , userdata , sock ) : [EOL] print ( [string] ) [EOL] [EOL] def cb ( ) : [EOL] print ( [string] ) [EOL] client . loop_write ( ) [EOL] [EOL] self . loop . add_writer ( sock , cb ) [EOL] [EOL] def on_socket_unregister_write ( self , client , userdata , sock ) : [EOL] print ( [string] ) [EOL] self . loop . remove_writer ( sock ) [EOL] [EOL] async def misc_loop ( self ) : [EOL] print ( [string] ) [EOL] while self . client . loop_misc ( ) == mqtt . MQTT_ERR_SUCCESS : [EOL] try : [EOL] await asyncio . sleep ( [number] ) [EOL] except asyncio . CancelledError : [EOL] break [EOL] print ( [string] ) [EOL] [EOL] [EOL] class AsyncMqttExample : [EOL] def __init__ ( self , loop ) : [EOL] self . loop = loop [EOL] [EOL] def on_connect ( self , client , userdata , flags , rc ) : [EOL] print ( [string] ) [EOL] client . subscribe ( topic ) [EOL] [EOL] def on_message ( self , client , userdata , msg ) : [EOL] if not self . got_message : [EOL] print ( [string] . format ( msg . decode ( ) ) ) [EOL] else : [EOL] self . got_message . set_result ( msg . payload ) [EOL] [EOL] def on_disconnect ( self , client , userdata , rc ) : [EOL] self . disconnected . set_result ( rc ) [EOL] [EOL] async def main ( self ) : [EOL] self . disconnected = self . loop . create_future ( ) [EOL] self . got_message = None [EOL] [EOL] self . client = mqtt . Client ( client_id = client_id ) [EOL] self . client . on_connect = self . on_connect [EOL] self . client . on_message = self . on_message [EOL] self . client . on_disconnect = self . on_disconnect [EOL] [EOL] aioh = AsyncioHelper ( self . loop , self . client ) [EOL] [EOL] self . client . connect ( [string] , [number] , [number] ) [EOL] self . client . socket ( ) . setsockopt ( socket . SOL_SOCKET , socket . SO_SNDBUF , [number] ) [EOL] [EOL] for c in range ( [number] ) : [EOL] await asyncio . sleep ( [number] ) [EOL] print ( [string] ) [EOL] self . got_message = self . loop . create_future ( ) [EOL] self . client . publish ( topic , [string] * [number] , qos = [number] ) [EOL] msg = await self . got_message [EOL] print ( [string] . format ( len ( msg ) ) ) [EOL] self . got_message = None [EOL] [EOL] self . client . disconnect ( ) [EOL] print ( [string] . format ( await self . disconnected ) ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] loop . run_until_complete ( AsyncMqttExample ( loop ) . main ( ) ) [EOL] loop . close ( ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [comment] [EOL] import paho . mqtt . client as mqtt [EOL] [EOL] def on_connect ( mqttc , obj , flags , rc ) : [EOL] print ( [string] % ( mqttc . _host , mqttc . _port ) ) [EOL] [EOL] def on_message ( mqttc , obj , msg ) : [EOL] print ( msg . topic + [string] + str ( msg . qos ) + [string] + str ( msg . payload ) ) [EOL] [EOL] def on_publish ( mqttc , obj , mid ) : [EOL] print ( [string] + str ( mid ) ) [EOL] [EOL] def on_subscribe ( mqttc , obj , mid , granted_qos ) : [EOL] print ( [string] + str ( mid ) + [string] + str ( granted_qos ) ) [EOL] [EOL] def on_log ( mqttc , obj , level , string ) : [EOL] print ( string ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mqttc = mqtt . Client ( ) [EOL] mqttc . on_message = on_message [EOL] mqttc . on_connect = on_connect [EOL] mqttc . on_publish = on_publish [EOL] mqttc . on_subscribe = on_subscribe [EOL] [comment] [EOL] [comment] [EOL] mqttc . connect_srv ( [string] , [number] ) [EOL] mqttc . subscribe ( [string] , [number] ) [EOL] [EOL] [EOL] rc = [number] [EOL] while rc == [number] : [EOL] rc = mqttc . loop ( ) [EOL] [EOL] print ( [string] + str ( rc ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Union , List , Dict [EOL] import typing [EOL] import context [comment] [EOL] import paho . mqtt . publish as publish [EOL] [EOL] msgs = [ { [string] : [string] , [string] : [string] } , ( [string] , [string] , [number] , False ) ] [EOL] publish . multiple ( msgs , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.bool]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.bool]]]$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import sys [EOL] import getopt [EOL] [EOL] import context [comment] [EOL] import paho . mqtt . client as mqtt [EOL] [EOL] final_mid = [number] [EOL] [EOL] [EOL] def on_connect ( mqttc , userdata , flags , rc ) : [EOL] if userdata == True : [EOL] print ( [string] + str ( rc ) ) [EOL] [EOL] [EOL] def on_message ( mqttc , userdata , msg ) : [EOL] global final_mid [EOL] if msg . retain == [number] : [EOL] pass [EOL] [comment] [EOL] else : [EOL] if userdata == True : [EOL] print ( [string] + msg . topic ) [EOL] ( rc , final_mid ) = mqttc . publish ( msg . topic , None , [number] , True ) [EOL] [EOL] [EOL] def on_publish ( mqttc , userdata , mid ) : [EOL] global final_mid [EOL] if mid == final_mid : [EOL] sys . exit ( ) [EOL] [EOL] [EOL] def on_log ( mqttc , userdata , level , string ) : [EOL] print ( string ) [EOL] [EOL] [EOL] def print_usage ( ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def main ( argv ) : [EOL] debug = False [EOL] host = [string] [EOL] client_id = None [EOL] keepalive = [number] [EOL] port = [number] [EOL] password = None [EOL] topic = None [EOL] username = None [EOL] verbose = False [EOL] [EOL] try : [EOL] opts , args = getopt . getopt ( argv , [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] except getopt . GetoptError as s : [EOL] print_usage ( ) [EOL] sys . exit ( [number] ) [EOL] for opt , arg in opts : [EOL] if opt in ( [string] , [string] ) : [EOL] debug = True [EOL] elif opt in ( [string] , [string] ) : [EOL] host = arg [EOL] elif opt in ( [string] , [string] ) : [EOL] client_id = arg [EOL] elif opt in ( [string] , [string] ) : [EOL] keepalive = int ( arg ) [EOL] elif opt in ( [string] , [string] ) : [EOL] port = int ( arg ) [EOL] elif opt in ( [string] , [string] ) : [EOL] password = arg [EOL] elif opt in ( [string] , [string] ) : [EOL] topic = arg [EOL] print ( topic ) [EOL] elif opt in ( [string] , [string] ) : [EOL] username = arg [EOL] elif opt in ( [string] , [string] ) : [EOL] verbose = True [EOL] [EOL] if topic == None : [EOL] print ( [string] ) [EOL] print_usage ( ) [EOL] sys . exit ( [number] ) [EOL] [EOL] mqttc = mqtt . Client ( client_id ) [EOL] mqttc . _userdata = verbose [EOL] mqttc . on_message = on_message [EOL] mqttc . on_publish = on_publish [EOL] mqttc . on_connect = on_connect [EOL] if debug : [EOL] mqttc . on_log = on_log [EOL] [EOL] if username : [EOL] mqttc . username_pw_set ( username , password ) [EOL] mqttc . connect ( host , port , keepalive ) [EOL] mqttc . subscribe ( topic ) [EOL] mqttc . loop_forever ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( sys . argv [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import context [comment] [EOL] import paho . mqtt . publish as publish [EOL] [EOL] publish . single ( [string] , [string] , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import context [comment] [EOL] import paho . mqtt . publish as publish [EOL] [EOL] topic = [string] [EOL] payload = [string] [EOL] publish . single ( topic , payload , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [EOL] [EOL] context . check_ssl ( ) [EOL] [EOL] rc = [number] [EOL] [EOL] client = context . start_client ( ) [EOL] [EOL] client . wait ( ) [EOL] [EOL] rc = client . returncode [EOL] [EOL] exit ( rc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [EOL] import paho_test [EOL] [EOL] rc = [number] [EOL] keepalive = [number] [EOL] connect_packet = paho_test . gen_connect ( [string] , keepalive = keepalive , ) [EOL] connack_packet = paho_test . gen_connack ( rc = [number] ) [EOL] [EOL] publish_packet = paho_test . gen_publish ( [string] , qos = [number] , payload = [string] . encode ( [string] ) , ) [EOL] [EOL] disconnect_packet = paho_test . gen_disconnect ( ) [EOL] [EOL] sock = paho_test . create_server_socket ( ) [EOL] [EOL] client = context . start_client ( ) [EOL] [EOL] try : [EOL] ( conn , address ) = sock . accept ( ) [EOL] conn . settimeout ( [number] ) [EOL] [EOL] if paho_test . expect_packet ( conn , [string] , connect_packet ) : [EOL] conn . send ( connack_packet ) [EOL] [EOL] if paho_test . expect_packet ( conn , [string] , publish_packet ) : [EOL] if paho_test . expect_packet ( conn , [string] , disconnect_packet ) : [EOL] rc = [number] [EOL] [EOL] conn . close ( ) [EOL] finally : [EOL] client . terminate ( ) [EOL] client . wait ( ) [EOL] sock . close ( ) [EOL] [EOL] exit ( rc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from typing import Any , Generator [EOL] import typing [EOL] import random [EOL] import string [EOL] from tornado . ioloop import IOLoop , PeriodicCallback [EOL] from tornado import gen [EOL] from tornado . websocket import websocket_connect [EOL] [EOL] def random_string ( length ) : [EOL] return [string] . join ( random . choice ( string . ascii_letters ) for m in range ( length ) ) [EOL] [EOL] class Client ( object ) : [EOL] def __init__ ( self , url , timeout ) : [EOL] self . url = url [EOL] self . timeout = timeout [EOL] self . ioloop = IOLoop . instance ( ) [EOL] self . ws = None [EOL] self . connect ( ) [EOL] [comment] [EOL] self . ioloop . start ( ) [EOL] [EOL] @ gen . coroutine def connect ( self ) : [EOL] print ( [string] ) [EOL] try : [EOL] self . ws = yield websocket_connect ( self . url ) [EOL] except Exception : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] self . run ( ) [EOL] [EOL] @ gen . coroutine def run ( self ) : [EOL] while True : [EOL] msg = yield self . ws . read_message ( ) [EOL] print ( msg ) [EOL] [EOL] def keep_alive ( self ) : [EOL] if self . ws is None : [EOL] self . connect ( ) [EOL] else : [EOL] print ( [string] ) [EOL] [comment] [EOL] self . ws . write_message ( random_string ( [number] ) ) [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] client = Client ( [string] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Dict [EOL] import typing [EOL] import typing_extensions [EOL] import logging [EOL] import tornado . web [EOL] import tornado . websocket [EOL] import tornado . ioloop [EOL] import tornado . options [EOL] [EOL] from tornado . options import define , options [EOL] [EOL] define ( [string] , default = [number] , help = [string] , type = int ) [EOL] class Application ( tornado . web . Application ) : [EOL] def __init__ ( self ) : [EOL] handlers = [ ( [string] , MainHandler ) ] [EOL] settings = dict ( debug = True ) [EOL] tornado . web . Application . __init__ ( self , handlers , ** settings ) [EOL] [EOL] [EOL] class MainHandler ( tornado . websocket . WebSocketHandler ) : [EOL] def check_origin ( self , origin ) : [EOL] return True [EOL] [EOL] def open ( self ) : [EOL] logging . info ( [string] ) [EOL] [EOL] def on_close ( self ) : [EOL] logging . info ( [string] ) [EOL] [EOL] def on_message ( self , message ) : [EOL] logging . info ( [string] . format ( message ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] tornado . options . parse_command_line ( ) [EOL] app = Application ( ) [EOL] app . listen ( [number] ) [EOL] tornado . ioloop . IOLoop . instance ( ) . start ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from tornado import gen [EOL] [EOL] [EOL] @ gen . coroutine def hello ( ) : [EOL] yield gen . sleep ( [number] ) [EOL] raise gen . Return ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from tornado . web import RequestHandler [EOL] [EOL] [EOL] class MyHandler ( RequestHandler ) : [EOL] def get ( self ) : [comment] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from tornado import gen [EOL] from tornado . web import RequestHandler [EOL] [EOL] [EOL] class MyHandler ( RequestHandler ) : [EOL] def get ( self ) : [EOL] self . write ( [string] ) [EOL] [EOL] async def post ( self ) : [EOL] await gen . sleep ( [number] ) [EOL] self . write ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import sys [EOL] from lib2to3 . main import main [EOL] [EOL] sys . exit ( main ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Any , List , Dict [EOL] import typing [EOL] import timeit [EOL] import sys [EOL] from timeit import Timer [EOL] [EOL] from tornado . options import options , define , parse_command_line [EOL] from tornado . template import Template [EOL] [EOL] define ( [string] , default = [number] , help = [string] ) [EOL] define ( [string] , default = False , help = [string] ) [EOL] [EOL] context = { [string] : [string] , [string] : [ dict ( a = [number] , b = [number] , c = [number] , d = [number] , e = [number] , f = [number] , g = [number] , h = [number] , i = [number] , j = [number] ) for x in range ( [number] ) ] } [EOL] [EOL] tmpl = Template ( [string] ) [EOL] [EOL] [EOL] def render ( ) : [EOL] tmpl . generate ( ** context ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parse_command_line ( ) [EOL] if options . dump : [EOL] print ( tmpl . code ) [EOL] sys . exit ( [number] ) [EOL] t = Timer ( render ) [EOL] results = t . timeit ( options . num ) / options . num [EOL] print ( [string] % ( results * [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.int]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Union , Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] import tornado . escape [EOL] import tornado . ioloop [EOL] import tornado . options [EOL] import tornado . web [EOL] import tornado . websocket [EOL] import os . path [EOL] import uuid [EOL] [EOL] from tornado . options import define , options [EOL] [EOL] define ( [string] , default = [number] , help = [string] , type = int ) [EOL] [EOL] [EOL] class Application ( tornado . web . Application ) : [EOL] def __init__ ( self ) : [EOL] handlers = [ ( [string] , MainHandler ) , ( [string] , ChatSocketHandler ) ] [EOL] settings = dict ( cookie_secret = [string] , template_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) , static_path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) , xsrf_cookies = True , ) [EOL] super ( Application , self ) . __init__ ( handlers , ** settings ) [EOL] [EOL] [EOL] class MainHandler ( tornado . web . RequestHandler ) : [EOL] def get ( self ) : [EOL] self . render ( [string] , messages = ChatSocketHandler . cache ) [EOL] [EOL] [EOL] class ChatSocketHandler ( tornado . websocket . WebSocketHandler ) : [EOL] waiters = set ( ) [EOL] cache = [ ] [EOL] cache_size = [number] [EOL] [EOL] def get_compression_options ( self ) : [EOL] [comment] [EOL] return { } [EOL] [EOL] def open ( self ) : [EOL] ChatSocketHandler . waiters . add ( self ) [EOL] [EOL] def on_close ( self ) : [EOL] ChatSocketHandler . waiters . remove ( self ) [EOL] [EOL] @ classmethod def update_cache ( cls , chat ) : [EOL] cls . cache . append ( chat ) [EOL] if len ( cls . cache ) > cls . cache_size : [EOL] cls . cache = cls . cache [ - cls . cache_size : ] [EOL] [EOL] @ classmethod def send_updates ( cls , chat ) : [EOL] logging . info ( [string] , len ( cls . waiters ) ) [EOL] for waiter in cls . waiters : [EOL] try : [EOL] waiter . write_message ( chat ) [EOL] except : [EOL] logging . error ( [string] , exc_info = True ) [EOL] [EOL] def on_message ( self , message ) : [EOL] logging . info ( [string] , message ) [EOL] parsed = tornado . escape . json_decode ( message ) [EOL] chat = { [string] : str ( uuid . uuid4 ( ) ) , [string] : parsed [ [string] ] } [EOL] chat [ [string] ] = tornado . escape . to_basestring ( self . render_string ( [string] , message = chat ) ) [EOL] [EOL] ChatSocketHandler . update_cache ( chat ) [EOL] ChatSocketHandler . send_updates ( chat ) [EOL] [EOL] [EOL] def main ( ) : [EOL] tornado . options . parse_command_line ( ) [EOL] app = Application ( ) [EOL] app . listen ( options . port ) [EOL] tornado . ioloop . IOLoop . current ( ) . start ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = [string] [EOL] version_info = ( [number] , [number] , [number] , - [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def set_close_exec ( fd ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] if os . name == [string] : [EOL] from tornado . platform . windows import set_close_exec [EOL] else : [EOL] from tornado . platform . posix import set_close_exec [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
	0
	0
from typing import Iterable , Callable [EOL] import typing [EOL] [docstring] [EOL] from tornado . test . runtests import all , main [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] all = all [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import paho . mqtt . publish as publish [EOL] import paho . mqtt . client as paho [EOL] import random , string , time [EOL] import serial [EOL] [EOL] broker = [string] [EOL] port = [number] [EOL] [EOL] def on_publish ( client , userdata , result ) : [comment] [EOL] print ( [string] ) [EOL] [EOL] client1 = paho . Client ( ) [EOL] client1 . on_publish = on_publish [EOL] [EOL] client1 . connect ( broker , port ) [EOL] ser = serial . Serial ( [string] , [number] , [number] , [string] , [number] , timeout = [number] ) [EOL] [EOL] while True : [EOL] data = ser . readline ( ) [EOL] client1 . publish ( [string] , data ) [EOL] print ( data + [string] ) [EOL] time . sleep ( [number] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Tuple , Any [EOL] import typing [EOL] import ssl [EOL] import socket [EOL] import binascii [EOL] import struct [EOL] import socket [EOL] import sys [EOL] [EOL] try : [EOL] import ssl [EOL] except ImportError : [EOL] ssl = None [EOL] [EOL] [EOL] if sys . version_info [ [number] ] >= [number] : [EOL] [comment] [EOL] unicode = str [EOL] [EOL] [EOL] def create_server_socket ( ) : [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] sock . settimeout ( [number] ) [EOL] sock . bind ( ( [string] , [number] ) ) [EOL] sock . listen ( [number] ) [EOL] return sock [EOL] [EOL] [EOL] def create_server_socket_ssl ( * args , ** kwargs ) : [EOL] if ssl is None : [EOL] raise RuntimeError [EOL] [EOL] ssl_version = ssl . PROTOCOL_TLSv1 [EOL] if hasattr ( ssl , [string] ) : [EOL] ssl_version = ssl . PROTOCOL_TLS [EOL] [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] ssock = ssl . wrap_socket ( sock , ca_certs = [string] , keyfile = [string] , certfile = [string] , server_side = True , ssl_version = ssl_version , ** kwargs ) [EOL] ssock . settimeout ( [number] ) [EOL] ssock . bind ( ( [string] , [number] ) ) [EOL] ssock . listen ( [number] ) [EOL] return ssock [EOL] [EOL] [EOL] def expect_packet ( sock , name , expected ) : [EOL] if len ( expected ) > [number] : [EOL] rlen = len ( expected ) [EOL] else : [EOL] rlen = [number] [EOL] [EOL] packet_recvd = sock . recv ( rlen ) [EOL] return packet_matches ( name , packet_recvd , expected ) [EOL] [EOL] [EOL] def packet_matches ( name , recvd , expected ) : [EOL] if recvd != expected : [EOL] print ( [string] + name + [string] ) [EOL] try : [EOL] print ( [string] + to_string ( recvd ) ) [EOL] except struct . error : [EOL] print ( [string] + binascii . b2a_hex ( recvd ) . decode ( [string] ) ) [EOL] try : [EOL] print ( [string] + to_string ( expected ) ) [EOL] except struct . error : [EOL] print ( [string] + binascii . b2a_hex ( expected ) . decode ( [string] ) ) [EOL] [EOL] return [number] [EOL] else : [EOL] return [number] [EOL] [EOL] [EOL] def remaining_length ( packet ) : [EOL] l = min ( [number] , len ( packet ) ) [EOL] all_bytes = struct . unpack ( [string] + [string] * l , packet [ : l ] ) [EOL] mult = [number] [EOL] rl = [number] [EOL] for i in range ( [number] , l - [number] ) : [EOL] byte = all_bytes [ i ] [EOL] [EOL] rl += ( byte & [number] ) * mult [EOL] mult *= [number] [EOL] if byte & [number] == [number] : [EOL] packet = packet [ i + [number] : ] [EOL] break [EOL] [EOL] return ( packet , rl ) [EOL] [EOL] [EOL] def to_string ( packet ) : [EOL] if len ( packet ) == [number] : [EOL] return [string] [EOL] [EOL] packet0 = struct . unpack ( [string] , packet [ [number] : [number] ] ) [EOL] packet0 = packet0 [ [number] ] [EOL] cmd = packet0 & [number] [EOL] if cmd == [number] : [EOL] [comment] [EOL] return [string] [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( packet , rl ) = remaining_length ( packet ) [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( slen , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + str ( slen ) + [string] + str ( len ( packet ) - slen - [number] ) + [string] [EOL] ( protocol , proto_ver , flags , keepalive , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = [string] + protocol + str ( proto_ver ) + [string] + str ( keepalive ) [EOL] if flags & [number] : [EOL] s = s + [string] [EOL] else : [EOL] s = s + [string] [EOL] [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( slen , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + str ( slen ) + [string] + str ( len ( packet ) - slen ) + [string] [EOL] ( client_id , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = s + [string] + client_id [EOL] [EOL] if flags & [number] : [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( slen , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + str ( slen ) + [string] + str ( len ( packet ) - slen ) + [string] [EOL] ( will_topic , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = s + [string] + will_topic [EOL] [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( slen , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + str ( slen ) + [string] + str ( len ( packet ) - slen ) + [string] [EOL] ( will_message , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = s + [string] + will_message [EOL] [EOL] s = s + [string] + str ( ( flags & [number] ) >> [number] ) [EOL] s = s + [string] + str ( ( flags & [number] ) >> [number] ) [EOL] [EOL] if flags & [number] : [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( slen , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + str ( slen ) + [string] + str ( len ( packet ) - slen ) + [string] [EOL] ( username , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = s + [string] + username [EOL] [EOL] if flags & [number] : [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( slen , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + str ( slen ) + [string] + str ( len ( packet ) - slen ) + [string] [EOL] ( password , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = s + [string] + password [EOL] [EOL] return s [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( cmd , rl , resv , rc ) = struct . unpack ( [string] , packet ) [EOL] return [string] + str ( rl ) + [string] + str ( resv ) + [string] + str ( rc ) [EOL] elif cmd == [number] : [EOL] [comment] [EOL] dup = ( packet0 & [number] ) >> [number] [EOL] qos = ( packet0 & [number] ) >> [number] [EOL] retain = ( packet0 & [number] ) [EOL] ( packet , rl ) = remaining_length ( packet ) [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( tlen , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + str ( tlen ) + [string] + str ( len ( packet ) - tlen ) + [string] [EOL] ( topic , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = [string] + str ( rl ) + [string] + topic + [string] + str ( qos ) + [string] + str ( retain ) + [string] + str ( dup ) [EOL] if qos > [number] : [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( mid , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = s + [string] + str ( mid ) [EOL] [EOL] s = s + [string] + packet [EOL] return s [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( cmd , rl , mid ) = struct . unpack ( [string] , packet ) [EOL] return [string] + str ( rl ) + [string] + str ( mid ) [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( cmd , rl , mid ) = struct . unpack ( [string] , packet ) [EOL] return [string] + str ( rl ) + [string] + str ( mid ) [EOL] elif cmd == [number] : [EOL] [comment] [EOL] dup = ( packet0 & [number] ) >> [number] [EOL] ( cmd , rl , mid ) = struct . unpack ( [string] , packet ) [EOL] return [string] + str ( rl ) + [string] + str ( mid ) + [string] + str ( dup ) [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( cmd , rl , mid ) = struct . unpack ( [string] , packet ) [EOL] return [string] + str ( rl ) + [string] + str ( mid ) [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( packet , rl ) = remaining_length ( packet ) [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( mid , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = [string] + str ( rl ) + [string] + str ( mid ) [EOL] topic_index = [number] [EOL] while len ( packet ) > [number] : [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( tlen , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + str ( tlen ) + [string] + str ( len ( packet ) - tlen - [number] ) + [string] [EOL] ( topic , qos , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = s + [string] + str ( topic_index ) + [string] + topic + [string] + str ( qos ) [EOL] return s [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( packet , rl ) = remaining_length ( packet ) [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( mid , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + [string] * len ( packet ) [EOL] granted_qos = struct . unpack ( pack_format , packet ) [EOL] [EOL] s = [string] + str ( rl ) + [string] + str ( mid ) + [string] + str ( granted_qos [ [number] ] ) [EOL] for i in range ( [number] , len ( granted_qos ) - [number] ) : [EOL] s = s + [string] + str ( granted_qos [ i ] ) [EOL] return s [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( packet , rl ) = remaining_length ( packet ) [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( mid , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = [string] + str ( rl ) + [string] + str ( mid ) [EOL] topic_index = [number] [EOL] while len ( packet ) > [number] : [EOL] pack_format = [string] + str ( len ( packet ) - [number] ) + [string] [EOL] ( tlen , packet ) = struct . unpack ( pack_format , packet ) [EOL] pack_format = [string] + str ( tlen ) + [string] + str ( len ( packet ) - tlen ) + [string] [EOL] ( topic , packet ) = struct . unpack ( pack_format , packet ) [EOL] s = s + [string] + str ( topic_index ) + [string] + topic [EOL] return s [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( cmd , rl , mid ) = struct . unpack ( [string] , packet ) [EOL] return [string] + str ( rl ) + [string] + str ( mid ) [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( cmd , rl ) = struct . unpack ( [string] , packet ) [EOL] return [string] + str ( rl ) [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( cmd , rl ) = struct . unpack ( [string] , packet ) [EOL] return [string] + str ( rl ) [EOL] elif cmd == [number] : [EOL] [comment] [EOL] ( cmd , rl ) = struct . unpack ( [string] , packet ) [EOL] return [string] + str ( rl ) [EOL] elif cmd == [number] : [EOL] [comment] [EOL] return [string] [EOL] [EOL] [EOL] def gen_connect ( client_id , clean_session = True , keepalive = [number] , username = None , password = None , will_topic = None , will_qos = [number] , will_retain = False , will_payload = [string] , proto_name = None , proto_ver = [number] ) : [EOL] proto_name = [string] if proto_ver >= [number] else [string] [EOL] [EOL] if client_id is None : [EOL] remaining_length = [number] [EOL] else : [EOL] client_id = client_id . encode ( [string] ) [EOL] remaining_length = [number] + len ( proto_name ) + [number] + [number] + [number] + [number] + len ( client_id ) [EOL] connect_flags = [number] [EOL] if clean_session : [EOL] connect_flags = connect_flags | [number] [EOL] [EOL] if will_topic is not None : [EOL] will_topic = will_topic . encode ( [string] ) [EOL] remaining_length = remaining_length + [number] + len ( will_topic ) + [number] + len ( will_payload ) [EOL] connect_flags = connect_flags | [number] | ( ( will_qos & [number] ) << [number] ) [EOL] if will_retain : [EOL] connect_flags = connect_flags | [number] [EOL] [EOL] if username is not None : [EOL] username = username . encode ( [string] ) [EOL] remaining_length = remaining_length + [number] + len ( username ) [EOL] connect_flags = connect_flags | [number] [EOL] if password is not None : [EOL] password = password . encode ( [string] ) [EOL] connect_flags = connect_flags | [number] [EOL] remaining_length = remaining_length + [number] + len ( password ) [EOL] [EOL] rl = pack_remaining_length ( remaining_length ) [EOL] packet = struct . pack ( [string] + str ( len ( rl ) ) + [string] , [number] , rl ) [EOL] packet = packet + struct . pack ( [string] + str ( len ( proto_name ) ) + [string] , len ( proto_name ) , proto_name , proto_ver , connect_flags , keepalive ) [EOL] if client_id is not None : [EOL] packet = packet + struct . pack ( [string] + str ( len ( client_id ) ) + [string] , len ( client_id ) , client_id ) [EOL] [EOL] if will_topic is not None : [EOL] packet = packet + struct . pack ( [string] + str ( len ( will_topic ) ) + [string] , len ( will_topic ) , will_topic ) [EOL] if len ( will_payload ) > [number] : [EOL] packet = packet + struct . pack ( [string] + str ( len ( will_payload ) ) + [string] , len ( will_payload ) , will_payload ) [EOL] else : [EOL] packet = packet + struct . pack ( [string] , [number] ) [EOL] [EOL] if username is not None : [EOL] packet = packet + struct . pack ( [string] + str ( len ( username ) ) + [string] , len ( username ) , username ) [EOL] if password is not None : [EOL] packet = packet + struct . pack ( [string] + str ( len ( password ) ) + [string] , len ( password ) , password ) [EOL] return packet [EOL] [EOL] [EOL] def gen_connack ( resv = [number] , rc = [number] ) : [EOL] return struct . pack ( [string] , [number] , [number] , resv , rc ) [EOL] [EOL] [EOL] def gen_publish ( topic , qos , payload = None , retain = False , dup = False , mid = [number] ) : [EOL] if isinstance ( topic , unicode ) : [EOL] topic = topic . encode ( [string] ) [EOL] rl = [number] + len ( topic ) [EOL] pack_format = [string] + str ( len ( topic ) ) + [string] [EOL] if qos > [number] : [EOL] rl = rl + [number] [EOL] pack_format = pack_format + [string] [EOL] if payload is not None : [EOL] rl = rl + len ( payload ) [EOL] pack_format = pack_format + str ( len ( payload ) ) + [string] [EOL] else : [EOL] payload = [string] [EOL] pack_format = pack_format + [string] [EOL] [EOL] cmd = [number] | ( qos << [number] ) [EOL] if retain : [EOL] cmd = cmd + [number] [EOL] if dup : [EOL] cmd = cmd + [number] [EOL] [EOL] if qos > [number] : [EOL] return struct . pack ( pack_format , cmd , rl , len ( topic ) , topic , mid , payload ) [EOL] else : [EOL] return struct . pack ( pack_format , cmd , rl , len ( topic ) , topic , payload ) [EOL] [EOL] [EOL] def gen_puback ( mid ) : [EOL] return struct . pack ( [string] , [number] , [number] , mid ) [EOL] [EOL] [EOL] def gen_pubrec ( mid ) : [EOL] return struct . pack ( [string] , [number] , [number] , mid ) [EOL] [EOL] [EOL] def gen_pubrel ( mid ) : [EOL] cmd = [number] + [number] [EOL] return struct . pack ( [string] , cmd , [number] , mid ) [EOL] [EOL] [EOL] def gen_pubcomp ( mid ) : [EOL] return struct . pack ( [string] , [number] , [number] , mid ) [EOL] [EOL] [EOL] def gen_subscribe ( mid , topic , qos ) : [EOL] topic = topic . encode ( [string] ) [EOL] pack_format = [string] + str ( len ( topic ) ) + [string] [EOL] return struct . pack ( pack_format , [number] , [number] + [number] + len ( topic ) + [number] , mid , len ( topic ) , topic , qos ) [EOL] [EOL] [EOL] def gen_suback ( mid , qos ) : [EOL] return struct . pack ( [string] , [number] , [number] + [number] , mid , qos ) [EOL] [EOL] [EOL] def gen_unsubscribe ( mid , topic ) : [EOL] topic = topic . encode ( [string] ) [EOL] pack_format = [string] + str ( len ( topic ) ) + [string] [EOL] return struct . pack ( pack_format , [number] , [number] + [number] + len ( topic ) , mid , len ( topic ) , topic ) [EOL] [EOL] [EOL] def gen_unsuback ( mid ) : [EOL] return struct . pack ( [string] , [number] , [number] , mid ) [EOL] [EOL] [EOL] def gen_pingreq ( ) : [EOL] return struct . pack ( [string] , [number] , [number] ) [EOL] [EOL] [EOL] def gen_pingresp ( ) : [EOL] return struct . pack ( [string] , [number] , [number] ) [EOL] [EOL] [EOL] def gen_disconnect ( ) : [EOL] return struct . pack ( [string] , [number] , [number] ) [EOL] [EOL] [EOL] def pack_remaining_length ( remaining_length ) : [EOL] s = [string] [EOL] while True : [EOL] byte = remaining_length % [number] [EOL] remaining_length = remaining_length // [number] [EOL] [comment] [EOL] if remaining_length > [number] : [EOL] byte = byte | [number] [EOL] [EOL] s = s + struct . pack ( [string] , byte ) [EOL] if remaining_length == [number] : [EOL] return s [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [EOL] import paho_test [EOL] [EOL] rc = [number] [EOL] keepalive = [number] [EOL] username = [string] [EOL] password = [string] [EOL] connect_packet = paho_test . gen_connect ( [string] , keepalive = keepalive , username = username , password = [string] ) [EOL] [EOL] sock = paho_test . create_server_socket ( ) [EOL] [EOL] client = context . start_client ( ) [EOL] [EOL] try : [EOL] ( conn , address ) = sock . accept ( ) [EOL] conn . settimeout ( [number] ) [EOL] [EOL] if paho_test . expect_packet ( conn , [string] , connect_packet ) : [EOL] rc = [number] [EOL] [EOL] conn . close ( ) [EOL] finally : [EOL] client . terminate ( ) [EOL] client . wait ( ) [EOL] sock . close ( ) [EOL] [EOL] exit ( rc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import time [EOL] [EOL] import context [EOL] import paho_test [EOL] from paho_test import ssl [EOL] [EOL] context . check_ssl ( ) [EOL] [EOL] ssock = paho_test . create_server_socket_ssl ( cert_reqs = ssl . CERT_REQUIRED ) [EOL] [EOL] client = context . start_client ( ) [EOL] [EOL] try : [EOL] ( conn , address ) = ssock . accept ( ) [EOL] [EOL] conn . close ( ) [EOL] except ssl . SSLError : [EOL] [comment] [EOL] pass [EOL] finally : [EOL] time . sleep ( [number] ) [EOL] client . terminate ( ) [EOL] client . wait ( ) [EOL] ssock . close ( ) [EOL] [EOL] if client . returncode == [number] : [EOL] exit ( [number] ) [EOL] else : [EOL] exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [EOL] [EOL] context . check_ssl ( ) [EOL] [EOL] rc = [number] [EOL] [EOL] client = context . start_client ( ) [EOL] [EOL] client . wait ( ) [EOL] [EOL] rc = client . returncode [EOL] [EOL] exit ( rc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import OrderedDict , Any [EOL] import typing [EOL] import collections [EOL] import base64 [EOL] import re [EOL] import hashlib [EOL] from collections import OrderedDict [EOL] [EOL] from six . moves import socketserver [EOL] import pytest [EOL] import paho . mqtt . client as client [EOL] [EOL] from paho . mqtt . client import WebsocketConnectionError [EOL] from testsupport . broker import fake_websocket_broker [EOL] [EOL] [EOL] @ pytest . fixture def init_response_headers ( ) : [EOL] [comment] [EOL] response_headers = OrderedDict ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) [EOL] [EOL] return response_headers [EOL] [EOL] [EOL] def get_websocket_response ( response_headers ) : [EOL] [docstring] [EOL] response = [string] . join ( [ [string] , [string] . join ( [string] . format ( i , j ) for i , j in response_headers . items ( ) ) , [string] , ] ) . encode ( [string] ) [EOL] [EOL] return response [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( client . MQTTv31 , [string] ) , ( client . MQTTv311 , [string] ) , ] ) class TestInvalidWebsocketResponse ( object ) : [EOL] def test_unexpected_response ( self , proto_ver , proto_name , fake_websocket_broker ) : [EOL] [docstring] [EOL] [EOL] mqttc = client . Client ( [string] , protocol = proto_ver , transport = [string] ) [EOL] [EOL] class WebsocketHandler ( socketserver . BaseRequestHandler ) : [EOL] def handle ( _self ) : [EOL] [comment] [EOL] _self . request . sendall ( [string] . encode ( [string] ) ) [EOL] [EOL] with fake_websocket_broker . serve ( WebsocketHandler ) : [EOL] with pytest . raises ( WebsocketConnectionError ) as exc : [EOL] mqttc . connect ( [string] , [number] , keepalive = [number] ) [EOL] [EOL] assert str ( exc . value ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( client . MQTTv31 , [string] ) , ( client . MQTTv311 , [string] ) , ] ) class TestBadWebsocketHeaders ( object ) : [EOL] [docstring] [EOL] [EOL] def _get_basic_handler ( self , response_headers ) : [EOL] [docstring] [EOL] [EOL] response = get_websocket_response ( response_headers ) [EOL] [EOL] class WebsocketHandler ( socketserver . BaseRequestHandler ) : [EOL] def handle ( _self ) : [EOL] self . data = _self . request . recv ( [number] ) . strip ( ) [EOL] print ( [string] . format ( self . data . decode ( [string] ) ) ) [EOL] [comment] [EOL] _self . request . sendall ( response ) [EOL] [EOL] return WebsocketHandler [EOL] [EOL] def test_no_upgrade ( self , proto_ver , proto_name , fake_websocket_broker , init_response_headers ) : [EOL] [docstring] [EOL] [EOL] mqttc = client . Client ( [string] , protocol = proto_ver , transport = [string] ) [EOL] [EOL] init_response_headers [ [string] ] = [string] [EOL] response = self . _get_basic_handler ( init_response_headers ) [EOL] [EOL] with fake_websocket_broker . serve ( response ) : [EOL] with pytest . raises ( WebsocketConnectionError ) as exc : [EOL] mqttc . connect ( [string] , [number] , keepalive = [number] ) [EOL] [EOL] assert str ( exc . value ) == [string] [EOL] [EOL] def test_bad_secret_key ( self , proto_ver , proto_name , fake_websocket_broker , init_response_headers ) : [EOL] [docstring] [EOL] [EOL] mqttc = client . Client ( [string] , protocol = proto_ver , transport = [string] ) [EOL] [EOL] response = self . _get_basic_handler ( init_response_headers ) [EOL] [EOL] with fake_websocket_broker . serve ( response ) : [EOL] with pytest . raises ( WebsocketConnectionError ) as exc : [EOL] mqttc . connect ( [string] , [number] , keepalive = [number] ) [EOL] [EOL] assert str ( exc . value ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( client . MQTTv31 , [string] ) , ( client . MQTTv311 , [string] ) , ] ) class TestValidHeaders ( object ) : [EOL] [docstring] [EOL] [EOL] def _get_callback_handler ( self , response_headers , check_request = None ) : [EOL] [docstring] [EOL] [EOL] class WebsocketHandler ( socketserver . BaseRequestHandler ) : [EOL] def handle ( _self ) : [EOL] self . data = _self . request . recv ( [number] ) . strip ( ) [EOL] print ( [string] . format ( self . data . decode ( [string] ) ) ) [EOL] [EOL] decoded = self . data . decode ( [string] ) [EOL] [EOL] if check_request is not None : [EOL] check_request ( decoded ) [EOL] [EOL] [comment] [EOL] GUID = [string] [EOL] key = re . search ( [string] , decoded , re . IGNORECASE ) . group ( [number] ) [EOL] [EOL] to_hash = [string] . format ( key , GUID ) [EOL] hashed = hashlib . sha1 ( to_hash . encode ( [string] ) ) [EOL] encoded = base64 . b64encode ( hashed . digest ( ) ) . decode ( [string] ) [EOL] [EOL] response_headers [ [string] ] = encoded [EOL] [EOL] [comment] [EOL] response = get_websocket_response ( response_headers ) [EOL] [EOL] _self . request . sendall ( response ) [EOL] [EOL] return WebsocketHandler [EOL] [EOL] def test_successful_connection ( self , proto_ver , proto_name , fake_websocket_broker , init_response_headers ) : [EOL] [docstring] [EOL] [EOL] mqttc = client . Client ( [string] , protocol = proto_ver , transport = [string] ) [EOL] [EOL] response = self . _get_callback_handler ( init_response_headers ) [EOL] [EOL] with fake_websocket_broker . serve ( response ) : [EOL] mqttc . connect ( [string] , [number] , keepalive = [number] ) [EOL] [EOL] mqttc . disconnect ( ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] [string] , None , ] ) def test_correct_path ( self , proto_ver , proto_name , fake_websocket_broker , mqtt_path , init_response_headers ) : [EOL] [docstring] [EOL] [EOL] mqttc = client . Client ( [string] , protocol = proto_ver , transport = [string] ) [EOL] [EOL] mqttc . ws_set_options ( path = mqtt_path , ) [EOL] [EOL] def check_path_correct ( decoded ) : [EOL] [comment] [EOL] if mqtt_path : [EOL] assert re . search ( [string] . format ( mqtt_path ) , decoded , re . IGNORECASE ) is not None [EOL] [EOL] response = self . _get_callback_handler ( init_response_headers , check_request = check_path_correct , ) [EOL] [EOL] with fake_websocket_broker . serve ( response ) : [EOL] mqttc . connect ( [string] , [number] , keepalive = [number] ) [EOL] [EOL] mqttc . disconnect ( ) [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ { [string] : [string] } , { [string] : [string] , [string] : [string] } , None , ] ) def test_correct_auth ( self , proto_ver , proto_name , fake_websocket_broker , auth_headers , init_response_headers ) : [EOL] [docstring] [EOL] [EOL] mqttc = client . Client ( [string] , protocol = proto_ver , transport = [string] ) [EOL] [EOL] mqttc . ws_set_options ( headers = auth_headers , ) [EOL] [EOL] def check_headers_used ( decoded ) : [EOL] [comment] [EOL] if auth_headers : [EOL] for h in auth_headers : [EOL] assert re . search ( [string] . format ( h , auth_headers [ h ] ) , decoded , re . IGNORECASE ) is not None [EOL] [EOL] response = self . _get_callback_handler ( init_response_headers , check_request = check_headers_used , ) [EOL] [EOL] with fake_websocket_broker . serve ( response ) : [EOL] mqttc . connect ( [string] , [number] , keepalive = [number] ) [EOL] [EOL] mqttc . disconnect ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import socket [EOL] from six . moves import socketserver [EOL] import threading [EOL] import contextlib [EOL] [EOL] import pytest [EOL] [EOL] [EOL] class FakeBroker : [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] sock . settimeout ( [number] ) [EOL] sock . bind ( ( [string] , [number] ) ) [EOL] sock . listen ( [number] ) [EOL] [EOL] self . _sock = sock [EOL] self . _conn = None [EOL] [EOL] def start ( self ) : [EOL] if self . _sock is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] ( conn , address ) = self . _sock . accept ( ) [EOL] conn . settimeout ( [number] ) [EOL] self . _conn = conn [EOL] [EOL] def finish ( self ) : [EOL] if self . _conn is not None : [EOL] self . _conn . close ( ) [EOL] self . _conn = None [EOL] [EOL] if self . _sock is not None : [EOL] self . _sock . close ( ) [EOL] self . _sock = None [EOL] [EOL] def receive_packet ( self , num_bytes ) : [EOL] if self . _conn is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] packet_in = self . _conn . recv ( num_bytes ) [EOL] return packet_in [EOL] [EOL] def send_packet ( self , packet_out ) : [EOL] if self . _conn is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] count = self . _conn . send ( packet_out ) [EOL] return count [EOL] [EOL] [EOL] @ pytest . fixture def fake_broker ( ) : [EOL] [comment] [EOL] broker = FakeBroker ( ) [EOL] [EOL] yield broker [EOL] [EOL] [comment] [EOL] broker . finish ( ) [EOL] [EOL] [EOL] class ThreadedTCPServer ( socketserver . ThreadingMixIn , socketserver . TCPServer ) : [EOL] pass [EOL] [EOL] [EOL] class FakeWebsocketBroker ( threading . Thread ) : [EOL] def __init__ ( self ) : [EOL] super ( FakeWebsocketBroker , self ) . __init__ ( ) [EOL] [EOL] self . host = [string] [EOL] self . port = [number] [EOL] [EOL] self . _server = None [EOL] self . _running = True [EOL] self . handler_cls = False [EOL] [EOL] @ contextlib . contextmanager def serve ( self , tcphandler ) : [EOL] self . _server = ThreadedTCPServer ( ( self . host , self . port ) , tcphandler ) [EOL] [EOL] try : [EOL] self . start ( ) [EOL] [EOL] if not self . _running : [EOL] raise RuntimeError ( [string] ) [EOL] yield [EOL] finally : [EOL] if self . _server : [EOL] self . _server . shutdown ( ) [EOL] self . _server . server_close ( ) [EOL] [EOL] def run ( self ) : [EOL] self . _running = True [EOL] self . _server . serve_forever ( ) [EOL] [EOL] [EOL] @ pytest . fixture def fake_websocket_broker ( ) : [EOL] socketserver . TCPServer . allow_reuse_address = True [EOL] [EOL] broker = FakeWebsocketBroker ( ) [EOL] [EOL] yield broker [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Union , List , Dict [EOL] import typing [EOL] import context [comment] [EOL] import paho . mqtt . publish as publish [EOL] [EOL] msgs = [ { [string] : [string] , [string] : [string] } , ( [string] , [string] , [number] , False ) ] [EOL] publish . multiple ( msgs , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.bool]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.bool]]]$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import context [comment] [EOL] import paho . mqtt . publish as publish [EOL] [EOL] topic = [string] [EOL] payload = [string] [EOL] publish . single ( topic , payload , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import context [comment] [EOL] import paho . mqtt . subscribe as subscribe [EOL] [EOL] topics = [ [string] ] [EOL] [EOL] m = subscribe . simple ( topics , hostname = [string] , retained = False , msg_count = [number] ) [EOL] for a in m : [EOL] print ( a . topic ) [EOL] print ( a . payload ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import socket [EOL] import uuid [EOL] import paho . mqtt . client as mqtt [EOL] from select import select [EOL] from time import time [EOL] [EOL] client_id = [string] + str ( uuid . uuid4 ( ) ) [EOL] topic = client_id [EOL] print ( [string] + client_id ) [EOL] [EOL] [EOL] class SelectMqttExample : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def on_connect ( self , client , userdata , flags , rc ) : [EOL] print ( [string] ) [EOL] client . subscribe ( topic ) [EOL] [EOL] def on_message ( self , client , userdata , msg ) : [EOL] if self . state not in { [number] , [number] , [number] } : [EOL] print ( [string] . format ( msg . decode ( ) ) ) [EOL] return [EOL] [EOL] print ( [string] . format ( len ( msg . payload ) ) ) [EOL] self . state += [number] [EOL] self . t = time ( ) [EOL] [EOL] def on_disconnect ( self , client , userdata , rc ) : [EOL] self . disconnected = True , rc [EOL] [EOL] def do_select ( self ) : [EOL] sock = self . client . socket ( ) [EOL] if not sock : [EOL] raise Exception ( [string] ) [EOL] [EOL] print ( [string] + ( [string] if self . client . want_write ( ) else [string] ) ) [EOL] r , w , e = select ( [ sock ] , [ sock ] if self . client . want_write ( ) else [ ] , [ ] , [number] ) [EOL] [EOL] if sock in r : [EOL] print ( [string] ) [EOL] self . client . loop_read ( ) [EOL] [EOL] if sock in w : [EOL] print ( [string] ) [EOL] self . client . loop_write ( ) [EOL] [EOL] self . client . loop_misc ( ) [EOL] [EOL] def main ( self ) : [EOL] self . disconnected = ( False , None ) [EOL] self . t = time ( ) [EOL] self . state = [number] [EOL] [EOL] self . client = mqtt . Client ( client_id = client_id ) [EOL] self . client . on_connect = self . on_connect [EOL] self . client . on_message = self . on_message [EOL] self . client . on_disconnect = self . on_disconnect [EOL] [EOL] self . client . connect ( [string] , [number] , [number] ) [EOL] print ( [string] ) [EOL] self . client . socket ( ) . setsockopt ( socket . SOL_SOCKET , socket . SO_SNDBUF , [number] ) [EOL] [EOL] while not self . disconnected [ [number] ] : [EOL] self . do_select ( ) [EOL] [EOL] if self . state in { [number] , [number] , [number] } : [EOL] if time ( ) - self . t >= [number] : [EOL] print ( [string] ) [EOL] self . client . publish ( topic , [string] * [number] ) [EOL] self . state += [number] [EOL] [EOL] if self . state == [number] : [EOL] self . state += [number] [EOL] self . client . disconnect ( ) [EOL] [EOL] print ( [string] . format ( self . disconnected [ [number] ] ) ) [EOL] [EOL] [EOL] print ( [string] ) [EOL] SelectMqttExample ( ) . main ( ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import context [comment] [EOL] import paho . mqtt . publish as publish [EOL] [EOL] publish . single ( [string] , [string] , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [comment] [EOL] import paho . mqtt . client as mqtt [EOL] [EOL] class MyMQTTClass ( mqtt . Client ) : [EOL] [EOL] def on_connect ( self , mqttc , obj , flags , rc ) : [EOL] print ( [string] + str ( rc ) ) [EOL] [EOL] def on_message ( self , mqttc , obj , msg ) : [EOL] print ( msg . topic + [string] + str ( msg . qos ) + [string] + str ( msg . payload ) ) [EOL] [EOL] def on_publish ( self , mqttc , obj , mid ) : [EOL] print ( [string] + str ( mid ) ) [EOL] [EOL] def on_subscribe ( self , mqttc , obj , mid , granted_qos ) : [EOL] print ( [string] + str ( mid ) + [string] + str ( granted_qos ) ) [EOL] [EOL] def on_log ( self , mqttc , obj , level , string ) : [EOL] print ( string ) [EOL] [EOL] def run ( self ) : [EOL] self . connect ( [string] , [number] , [number] ) [EOL] self . subscribe ( [string] , [number] ) [EOL] [EOL] rc = [number] [EOL] while rc == [number] : [EOL] rc = self . loop ( ) [EOL] return rc [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mqttc = MyMQTTClass ( ) [EOL] rc = mqttc . run ( ) [EOL] [EOL] print ( [string] + str ( rc ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
	0
__version__ = [string] [EOL] [EOL] [EOL] class MQTTException ( Exception ) : [EOL] pass [EOL]	$builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Callable [EOL] import typing [EOL] import io [EOL] import paho . mqtt . publish as publish [EOL] import paho . mqtt . client as paho [EOL] import random , string , time [EOL] import serial [EOL] [EOL] broker = [string] [EOL] port = [number] [EOL] [EOL] def on_publish ( client , userdata , result ) : [comment] [EOL] print ( [string] ) [EOL] [EOL] client1 = paho . Client ( ) [EOL] client1 . on_publish = on_publish [EOL] [EOL] client1 . connect ( broker , port ) [EOL] ser = serial . Serial ( [string] , [number] , [number] , [string] , [number] , timeout = [number] ) [EOL] [EOL] while True : [EOL] data = ser . readline ( ) [EOL] client1 . publish ( [string] , data ) [EOL] sensor = data . decode ( [string] ) . split ( [string] ) [EOL] para = ( sensor [ [number] ] ) [EOL] if ( para == [string] ) : [EOL] file = open ( [string] , [string] ) [EOL] hash = file . readline ( ) [EOL] msg = [string] + hash [EOL] client1 . publish ( [string] , msg ) [EOL] print ( msg ) [EOL] print ( data ) [EOL] print ( [string] ) [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import tkinter [EOL] import tkinter as tk [EOL] import os [EOL] import sys [EOL] from PIL import Image , ImageTk [EOL] import random , string , time [EOL] import serial [EOL] [EOL] [EOL] def on_click_pbm ( ) : [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] time . sleep ( [number] ) [EOL] print ( [string] ) [EOL] root . destroy ( ) [EOL] os . system ( [string] ) [EOL] [EOL] def on_click_spo2 ( ) : [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] time . sleep ( [number] ) [EOL] print ( [string] ) [EOL] root . destroy ( ) [EOL] os . system ( [string] ) [EOL] [EOL] def on_click_temp ( ) : [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] time . sleep ( [number] ) [EOL] print ( [string] ) [EOL] root . destroy ( ) [EOL] os . system ( [string] ) [EOL] [EOL] def on_click_airflow ( ) : [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] time . sleep ( [number] ) [EOL] print ( [string] ) [EOL] root . destroy ( ) [EOL] os . system ( [string] ) [EOL] [EOL] def on_click ( event = None ) : [EOL] print ( [string] ) [EOL] [EOL] def on_click_ecg ( ) : [EOL] button = [string] [EOL] print ( [string] ) [EOL] [EOL] def function ( ) : [EOL] root . destroy ( ) [EOL] os . system ( [string] ) [EOL] [comment] [EOL] os . system ( [string] ) [EOL] [EOL] root = tk . Tk ( ) [EOL] root . title ( [string] ) [EOL] root . geometry ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] image = Image . open ( [string] ) [EOL] photo = ImageTk . PhotoImage ( image ) [EOL] l = tk . Label ( root ) [EOL] l . grid ( ) [EOL] [EOL] image1 = Image . open ( [string] ) [EOL] photo1 = ImageTk . PhotoImage ( image1 ) [EOL] l1 = tk . Label ( root ) [EOL] l1 . grid ( ) [EOL] [EOL] image2 = Image . open ( [string] ) [EOL] photo2 = ImageTk . PhotoImage ( image2 ) [EOL] l2 = tk . Label ( root ) [EOL] l2 . grid ( ) [EOL] [EOL] image3 = Image . open ( [string] ) [EOL] photo3 = ImageTk . PhotoImage ( image3 ) [EOL] l3 = tk . Label ( root ) [EOL] l3 . grid ( ) [EOL] [EOL] image4 = Image . open ( [string] ) [EOL] photo4 = ImageTk . PhotoImage ( image4 ) [EOL] l4 = tk . Label ( root ) [EOL] l4 . grid ( ) [EOL] [EOL] b = tk . Button ( root , image = photo , command = on_click_pbm , height = [number] , width = [number] ) [EOL] b . grid ( row = [number] , column = [number] ) [EOL] [EOL] b1 = tk . Button ( root , image = photo1 , command = on_click_spo2 , height = [number] , width = [number] ) [EOL] b1 . grid ( row = [number] , column = [number] ) [EOL] [EOL] b2 = tk . Button ( root , image = photo2 , command = on_click_temp , height = [number] , width = [number] ) [EOL] b2 . grid ( row = [number] , column = [number] ) [EOL] [EOL] b3 = tk . Button ( root , image = photo3 , command = on_click_airflow , height = [number] , width = [number] ) [EOL] b3 . grid ( row = [number] , column = [number] ) [EOL] [EOL] b4 = tk . Button ( root , image = photo4 , command = on_click_ecg , height = [number] , width = [number] ) [EOL] b4 . grid ( row = [number] , column = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] close = tk . Button ( root , text = [string] , command = function , font = ( [string] , [number] ) ) [EOL] close . grid ( row = [number] , column = [number] ) [EOL] [EOL] root . mainloop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $tkinter.Label$ 0 0 0 0 0 $tkinter.Tk$ 0 0 $tkinter.Label$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $tkinter.Label$ 0 0 0 0 0 $tkinter.Tk$ 0 0 $tkinter.Label$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $tkinter.Label$ 0 0 0 0 0 $tkinter.Tk$ 0 0 $tkinter.Label$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $tkinter.Label$ 0 0 0 0 0 $tkinter.Tk$ 0 0 $tkinter.Label$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $tkinter.Label$ 0 0 0 0 0 $tkinter.Tk$ 0 0 $tkinter.Label$ 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 $tkinter.Tk$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 $tkinter.Tk$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 $tkinter.Tk$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 $tkinter.Tk$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 $tkinter.Tk$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import io [EOL] import tkinter [EOL] import paho . mqtt . publish as publish [EOL] import paho . mqtt . client as paho [EOL] import time [EOL] [EOL] import os [EOL] import matplotlib as mpl [EOL] if os . environ . get ( [string] , [string] ) == [string] : [EOL] print ( [string] ) [EOL] mpl . use ( [string] ) [EOL] import serial [EOL] import time [EOL] import string [EOL] import tkinter as Tk [EOL] from matplotlib import pyplot as plt [EOL] import matplotlib . animation as animation [EOL] from matplotlib . backends . backend_tkagg import FigureCanvasTkAgg [EOL] [EOL] broker = [string] [EOL] port = [number] [EOL] [EOL] def on_publish ( client , userdata , result ) : [comment] [EOL] print ( [string] ) [EOL] client1 = paho . Client ( ) [EOL] client1 . on_publish = on_publish [EOL] client1 . connect ( broker , port ) [EOL] [EOL] [EOL] ser = serial . Serial ( [string] , [number] , [number] , [string] , [number] , timeout = [number] ) [EOL] [EOL] def backtoicon ( ) : [EOL] root . destroy ( ) [EOL] os . system ( [string] ) [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] class Window : [EOL] [EOL] def __init__ ( self , master ) : [EOL] [EOL] frame = Tk . Frame ( master ) [EOL] self . fig = plt . figure ( figsize = ( [number] , [number] ) , dpi = [number] ) [EOL] self . b1 = Tk . Button ( frame , text = [string] , command = backtoicon , foreground = [string] ) [EOL] self . b1 . pack ( side = Tk . LEFT ) [EOL] self . ax = self . fig . add_subplot ( [number] , [number] , [number] ) [EOL] self . ax . grid ( ) [EOL] self . ax . set_ylim ( [ [number] , [number] ] ) [EOL] print ( [string] ) [EOL] print ( xar , yar ) [EOL] print ( [string] ) [EOL] self . rect = self . ax . bar ( xar , yar , width = [number] ) [EOL] [EOL] self . canvas = FigureCanvasTkAgg ( self . fig , master = master ) [EOL] self . canvas . show ( ) [EOL] self . canvas . get_tk_widget ( ) . pack ( side = [string] , fill = [string] , expand = [number] ) [EOL] frame . pack ( ) [EOL] [EOL] def animate ( self , i ) : [EOL] xar = [number] [EOL] yar = [number] [EOL] data = ser . readline ( ) . strip ( ) [EOL] print ( data ) [EOL] client1 . publish ( [string] , data ) [EOL] if ( data != [string] ) : [EOL] sensor = data . decode ( [string] ) . split ( [string] ) [EOL] para = ( sensor [ [number] ] ) [EOL] val = ( sensor [ - [number] ] ) [EOL] [EOL] if ( para == [string] ) : [EOL] [EOL] yar = float ( val ) [EOL] xar = i [EOL] print ( [string] ) [EOL] print ( yar ) [EOL] self . rect = self . ax . bar ( xar , yar , width = [number] ) [EOL] self . ax . set_xlim ( [ i - [number] , i + [number] ] ) [EOL] [EOL] if ( para == [string] ) : [EOL] file = open ( [string] , [string] ) [EOL] hashk = file . readline ( ) [EOL] msg = [string] + hashk [EOL] client1 . publish ( [string] , msg ) [EOL] print ( msg ) [EOL] file . close ( ) [EOL] [EOL] xar = [number] [EOL] yar = [number] [EOL] [EOL] root = Tk . Tk ( ) [EOL] root . title ( [string] ) [EOL] app = Window ( root ) [EOL] ani = animation . FuncAnimation ( app . fig , app . animate , interval = [number] , blit = False ) [EOL] root . mainloop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 $tkinter.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $io.TextIOWrapper$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $io.TextIOWrapper$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0
import os [EOL] import sys [EOL] [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] import sys [EOL] [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import io [EOL] import time [EOL] import paho . mqtt . client as mqtt [EOL] import string [EOL] import os [EOL] import sys [EOL] [EOL] def on_connect ( client , userdata , flags , rc ) : [EOL] print ( [string] + str ( rc ) ) [EOL] client . subscribe ( [string] ) [EOL] client . subscribe ( [string] ) [EOL] client . subscribe ( [string] ) [comment] [EOL] print ( [string] ) [EOL] [EOL] def on_message ( client , userdata , msg ) : [EOL] print ( msg . topic + [string] + str ( msg . payload ) ) [EOL] [comment] [EOL] [comment] [EOL] print ( [string] ) [EOL] if ( msg . topic == [string] ) : [EOL] if ( str ( msg . payload ) == [string] ) : [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] if ( msg . topic == [string] ) : [EOL] print ( str ( msg . payload ) ) [EOL] file = open ( [string] , [string] ) [EOL] s = str ( msg . payload ) [EOL] s = s [ [number] : ] [EOL] hashkey = s [ : len ( s ) - [number] ] [EOL] file . write ( hashkey ) [EOL] file . close ( ) [EOL] if ( msg . topic == [string] ) : [EOL] if ( str ( msg . payload ) == [string] ) : [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] elif ( str ( msg . payload ) == [string] ) : [EOL] print ( [string] ) [EOL] os . system ( [string] ) [EOL] [EOL] [EOL] [EOL] client = mqtt . Client ( ) [EOL] client . on_connect = on_connect [EOL] client . on_message = on_message [EOL] [EOL] client . connect ( [string] , [number] , [number] ) [EOL] client . loop_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import io [EOL] import hashlib [EOL] import tkinter [EOL] from tkinter import * [EOL] from tkinter import ttk [EOL] import sys [EOL] import os [EOL] import tkinter [EOL] import paho . mqtt . publish as publish [EOL] import paho . mqtt . client as paho [EOL] import random , string , time [EOL] import json [EOL] import serial [EOL] import time [EOL] import hashlib [EOL] import string [EOL] from tkinter import messagebox [EOL] global temp2 [EOL] [EOL] def validate_up ( P ) : [EOL] signupbutn . config ( state = ( NORMAL if P else DISABLED ) ) [EOL] return True [EOL] [EOL] def validate_in ( P ) : [EOL] loginbutton . config ( state = ( NORMAL if P else DISABLED ) ) [EOL] return True [EOL] [EOL] ser = serial . Serial ( [string] , [number] , [number] , [string] , [number] , timeout = [number] ) [EOL] [EOL] broker = [string] [EOL] port = [number] [EOL] [EOL] def on_publish ( client , userdata , result ) : [EOL] print ( [string] ) [EOL] [EOL] client1 = paho . Client ( ) [comment] [EOL] client1 . on_publish = on_publish [EOL] [EOL] [comment] [EOL] creds = [string] [EOL] [EOL] root = Tk ( ) [EOL] root . title ( [string] ) [EOL] root . geometry ( [string] ) [EOL] root . configure ( background = [string] ) [EOL] nb = ttk . Notebook ( root ) [EOL] ttk . Style ( ) . configure ( [string] ) [EOL] tab2 = ttk . Frame ( nb ) [EOL] tab1 = ttk . Frame ( nb ) [EOL] [EOL] nb . add ( tab2 , text = [string] ) [EOL] nb . add ( tab1 , text = [string] ) [EOL] [EOL] def fpsignin ( ) : [EOL] p = str ( [number] ) [EOL] p = [string] + p + [string] [EOL] ser . write ( p . encode ( ) , ) [EOL] msg = ser . readline ( ) [EOL] temp1 = msg . decode ( [string] ) [EOL] if ( temp1 . startswith ( [string] ) ) : [EOL] temp2 = temp1 . strip ( ) [EOL] print ( temp2 ) [EOL] file = open ( [string] , [string] ) [EOL] print ( [string] ) [EOL] while True : [EOL] data = file . readline ( ) [EOL] if ( data == [string] ) : [EOL] break [EOL] id , key = data . split ( [string] ) [EOL] if ( id == temp2 ) : [EOL] print ( [string] + key ) [EOL] file1 = open ( [string] , [string] ) [EOL] file1 . write ( key ) [EOL] file1 . close ( ) [EOL] print ( [string] ) [EOL] root . destroy ( ) [EOL] os . system ( [string] ) [EOL] break [EOL] file . close ( ) [EOL] top = Toplevel ( ) [EOL] top . title ( [string] ) [EOL] Message ( top , text = msg , padx = [number] , pady = [number] ) . pack ( ) [EOL] top . after ( [number] , top . destroy ) [EOL] print ( msg ) [EOL] [EOL] [EOL] [EOL] label_9 = Label ( tab2 , text = [string] , foreground = [string] ) [EOL] label_9 . grid ( row = [number] , column = [number] , sticky = W ) [EOL] labelfont = [number] [EOL] label_10 = Label ( tab2 , text = [string] , foreground = [string] ) [EOL] label_10 . grid ( row = [number] , column = [number] , sticky = W ) [EOL] labelfont = [number] [EOL] label_13 = Label ( tab2 , text = [string] , foreground = [string] ) [EOL] label_13 . grid ( row = [number] , column = [number] , sticky = W ) [EOL] labelfont = [number] [EOL] label_14 = Label ( tab2 , text = [string] , foreground = [string] ) [EOL] label_14 . grid ( row = [number] , column = [number] , sticky = W ) [EOL] labelfont = [number] [EOL] label_or = Label ( tab2 , text = [string] , foreground = [string] ) [EOL] label_or . grid ( row = [number] , column = [number] ) [EOL] [EOL] vcmd1 = tab2 . register ( validate_in ) [EOL] entry_9 = Entry ( tab2 ) [EOL] entry_9 . grid ( row = [number] , column = [number] , columnspan = [number] , sticky = E ) [EOL] entry_9 . focus_set ( ) [EOL] entry_10 = Entry ( tab2 , show = [string] , validate = [string] , validatecommand = ( vcmd1 , [string] ) ) [EOL] entry_10 . grid ( row = [number] , column = [number] , columnspan = [number] , sticky = E ) [EOL] entry_10 . focus_set ( ) [EOL] fpbutton = Button ( tab2 , text = [string] , width = [number] , command = fpsignin , foreground = [string] ) [EOL] fpbutton . grid ( row = [number] , column = [number] , sticky = E ) [EOL] variable2 = StringVar ( tab2 ) [EOL] variable2 . set ( [string] ) [EOL] q = OptionMenu ( tab2 , variable2 , [string] , [string] ) [EOL] q . grid ( row = [number] , column = [number] , columnspan = [number] , sticky = E ) [EOL] q . config ( foreground = [string] ) [EOL] q [ [string] ] . config ( ) [EOL] [EOL] [EOL] def savesignin ( ) : [EOL] e8 = variable2 . get ( ) [EOL] e9 = entry_9 . get ( ) [EOL] e10 = entry_10 . get ( ) [EOL] point_data = { [string] : e8 , [string] : e9 , [string] : e10 } [EOL] data = ( json . dumps ( point_data ) ) [EOL] print ( data ) [EOL] try : [EOL] client1 . connect ( broker , port ) [EOL] client1 . publish ( [string] , data ) [EOL] root . destroy ( ) [EOL] [comment] [EOL] except : [EOL] client1 . publish ( [string] , data ) [EOL] root . destroy ( ) [EOL] [comment] [EOL] [EOL] [EOL] loginbutton = Button ( tab2 , text = [string] , width = [number] , state = DISABLED , command = savesignin , foreground = [string] ) [EOL] loginbutton . grid ( row = [number] , column = [number] , rowspan = [number] ) [EOL] loginbutton . place ( relx = [number] , rely = [number] ) [EOL] [EOL] def fpsignup ( ) : [EOL] p = str ( [number] ) [EOL] p = [string] + p + [string] [EOL] ser . write ( p . encode ( ) , ) [EOL] msg2 = ser . readline ( ) [EOL] temp1 = msg2 . decode ( [string] ) [EOL] if ( temp1 . startswith ( [string] ) ) : [EOL] e1 = entry_1 . get ( ) [EOL] e3 = entry_2 . get ( ) [EOL] e5 = entry_5 . get ( ) [EOL] x = hashlib . sha1 ( str . encode ( e1 + e3 + e5 ) ) [EOL] hashkey = x . hexdigest ( ) [EOL] file = open ( [string] , [string] ) [EOL] temp = temp1 . strip ( ) + [string] + hashkey + [string] [EOL] file . write ( temp ) [EOL] top = Toplevel ( ) [EOL] top . title ( [string] ) [EOL] Message ( top , text = msg2 , padx = [number] , pady = [number] ) . pack ( ) [EOL] top . after ( [number] , top . destroy ) [EOL] print ( msg2 ) [EOL] [EOL] [EOL] variable = StringVar ( tab1 ) [EOL] variable . set ( [string] ) [comment] [EOL] [EOL] w = OptionMenu ( tab1 , variable , [string] , [string] ) [EOL] w . grid ( row = [number] , column = [number] , columnspan = [number] , sticky = E ) [EOL] w . config ( foreground = [string] ) [EOL] w [ [string] ] . config ( ) [EOL] [EOL] [EOL] label_0 = Label ( tab1 , text = [string] , foreground = [string] ) [EOL] label_0 . grid ( row = [number] , column = [number] , sticky = W ) [EOL] labelfont = [number] [EOL] [EOL] label_1 = Label ( tab1 , text = [string] , foreground = [string] ) [EOL] label_1 . grid ( row = [number] , column = [number] , sticky = W ) [EOL] labelfont = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] label_3 = Label ( tab1 , text = [string] , foreground = [string] ) [EOL] label_3 . grid ( row = [number] , column = [number] , sticky = W ) [EOL] labelfont = [number] [EOL] [EOL] label_4 = Label ( tab1 , text = [string] , foreground = [string] ) [EOL] label_4 . grid ( row = [number] , column = [number] , sticky = W ) [EOL] labelfont = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] label_7 = Label ( tab1 , text = [string] , foreground = [string] ) [EOL] label_7 . grid ( row = [number] , column = [number] , sticky = W ) [EOL] labelfont = [number] [EOL] [EOL] vcmd = tab1 . register ( validate_up ) [EOL] entry_1 = Entry ( tab1 ) [EOL] entry_1 . grid ( row = [number] , column = [number] , columnspan = [number] , sticky = E ) [EOL] entry_1 . focus_set ( ) [EOL] fpbutton1 = Button ( tab1 , text = [string] , height = [number] , width = [number] , command = fpsignup , foreground = [string] ) [EOL] fpbutton1 . place ( relx = [number] , rely = [number] ) [EOL] [EOL] entry_2 = Entry ( tab1 ) [EOL] entry_2 . grid ( row = [number] , column = [number] , columnspan = [number] , sticky = E ) [EOL] entry_2 . focus_set ( ) [EOL] entry_3 = Entry ( tab1 , show = [string] ) [EOL] entry_3 . grid ( row = [number] , column = [number] , columnspan = [number] , sticky = E ) [EOL] entry_3 . focus_set ( ) [EOL] [comment] [EOL] [comment] [EOL] entry_5 = Entry ( tab1 , validate = [string] , validatecommand = ( vcmd , [string] ) ) [EOL] entry_5 . grid ( row = [number] , column = [number] , columnspan = [number] , sticky = E ) [EOL] entry_5 . focus_set ( ) [EOL] [EOL] def savesignup ( ) : [EOL] e0 = variable . get ( ) [EOL] e1 = entry_1 . get ( ) [EOL] e2 = [string] [EOL] e3 = entry_2 . get ( ) [EOL] e4 = entry_3 . get ( ) [EOL] e5 = entry_5 . get ( ) [EOL] [comment] [EOL] point_data = { [string] : e0 , [string] : e1 , [string] : e2 , [string] : e3 , [string] : e4 , [string] : e5 } [EOL] print ( point_data ) [EOL] data = ( json . dumps ( point_data ) ) [EOL] try : [EOL] client1 . connect ( broker , port ) [EOL] client1 . publish ( [string] , data ) [EOL] except : [EOL] client1 . publish ( [string] , data ) [EOL] [EOL] signupbutn = Button ( tab1 , text = [string] , state = DISABLED , command = savesignup , width = [number] , foreground = [string] ) [EOL] signupbutn . grid ( row = [number] , rowspan = [number] ) [EOL] signupbutn . place ( relx = [number] , rely = [number] ) [EOL] [EOL] [EOL] nb . pack ( expand = [number] , fill = [string] ) [EOL] [EOL] root . mainloop ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 $tkinter.ttk.Frame$ 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 $tkinter.Entry$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 $tkinter.Button$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.StringVar$ 0 0 0 $tkinter.ttk.Frame$ 0 0 $tkinter.StringVar$ 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 $tkinter.ttk.Frame$ 0 $tkinter.StringVar$ 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.StringVar$ 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.StringVar$ 0 0 0 $tkinter.ttk.Frame$ 0 0 $tkinter.StringVar$ 0 0 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 $tkinter.ttk.Frame$ 0 $tkinter.StringVar$ 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 0 0 0 0 0 $tkinter.OptionMenu$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 $tkinter.Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 $tkinter.ttk.Frame$ 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 $tkinter.Button$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 $tkinter.ttk.Frame$ 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 $tkinter.Entry$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.StringVar$ 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 $tkinter.Entry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 $tkinter.ttk.Frame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Button$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.ttk.Notebook$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tkinter.Tk$ 0 0 0 0 0 0
from typing import Literal , Tuple , Any [EOL] import typing [EOL] import typing_extensions [EOL] import mysql . connector [EOL] [EOL] mydb = mysql . connector . connect ( host = [string] , user = [string] , passwd = [string] , database = [string] ) [EOL] mycursor = mydb . cursor ( ) [EOL] [EOL] email = [string] [EOL] password = [string] [EOL] sql = [string] [EOL] adr = ( email , password , ) [EOL] [EOL] mycursor . execute ( sql , adr ) [EOL] myresult = mycursor . fetchall ( ) [EOL] [EOL] [EOL] for x in myresult : [EOL] print ( x ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[EOL] from typing import Tuple , Any [EOL] import typing [EOL] import paho . mqtt . client as mqtt [EOL] import time [EOL] import datetime [EOL] import string [EOL] import mysql . connector [EOL] from mysql . connector import Error [EOL] from mysql . connector import errorcode [EOL] [EOL] class sen : [EOL] def __init__ ( self , pbm , spo2 , temp , airflow , body_pos , skin_cond , skin_resist , skin_volt , hkey ) : [EOL] self . pbm = pbm [EOL] self . spo2 = spo2 [EOL] self . temp = temp [EOL] self . airflow = airflow [EOL] self . body_pos = body_pos [EOL] self . skin_cond = skin_cond [EOL] self . skin_resist = skin_resist [EOL] self . skin_volt = skin_volt [EOL] self . hkey = hkey [EOL] [EOL] s1 = sen ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] def on_call ( sensor , data ) : [EOL] if ( sensor == [string] ) : [EOL] s1 . pbm = data [EOL] [EOL] elif ( sensor == [string] ) : [EOL] s1 . spo2 = data [EOL] [EOL] elif ( sensor == [string] ) : [EOL] s1 . temp = data [EOL] [EOL] elif ( sensor == [string] ) : [EOL] s1 . airflow = data [EOL] [EOL] elif ( sensor == [string] ) : [EOL] hkey = data [EOL] try : [EOL] connection = mysql . connector . connect ( host = [string] , database = [string] , user = [string] , password = [string] ) [EOL] print ( type ( hkey ) ) [EOL] print ( [string] ) [EOL] sql = [string] [EOL] val = ( s1 . pbm , s1 . spo2 , s1 . temp , s1 . airflow , hkey ) [EOL] print ( [string] ) [EOL] cursor = connection . cursor ( ) [EOL] result = cursor . execute ( sql , val ) [EOL] connection . commit ( ) [EOL] print ( [string] ) [EOL] except mysql . connector . Error as error : [EOL] connection . rollback ( ) [EOL] print ( [string] . format ( error ) ) [EOL] finally : [EOL] if ( connection . is_connected ( ) ) : [EOL] cursor . close ( ) [EOL] connection . close ( ) [EOL] print ( [string] ) [EOL] [EOL] def on_connect ( client , userdata , flags , rc ) : [EOL] print ( [string] + str ( rc ) ) [EOL] client . subscribe ( [string] ) [EOL] client . subscribe ( [string] ) [comment] [EOL] print ( [string] ) [EOL] [EOL] def on_message ( client , userdata , msg ) : [EOL] [comment] [EOL] incoming = str ( msg . payload ) [EOL] print ( incoming ) [EOL] if ( incoming != [string] and incoming != [string] ) : [EOL] [comment] [EOL] sensor , data = incoming . split ( [string] ) [EOL] on_call ( sensor , data ) [EOL] [EOL] [EOL] [EOL] client = mqtt . Client ( ) [EOL] client . on_connect = on_connect [EOL] client . on_message = on_message [EOL] [EOL] client . connect ( [string] , [number] , [number] ) [EOL] [EOL] client . loop_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import mysql . connector [EOL] from mysql . connector import Error [EOL] from mysql . connector import errorcode [EOL] import datetime [EOL] import time [EOL] [EOL] ts = time . time ( ) [EOL] timestamp = datetime . datetime . fromtimestamp ( ts ) . strftime ( [string] ) [EOL] x , data = timestamp . split ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] try : [EOL] connection = mysql . connector . connect ( host = [string] , database = [string] , user = [string] , password = [string] ) [EOL] x = [string] [EOL] ts = time . time ( ) [EOL] timestamp = datetime . datetime . fromtimestamp ( ts ) . strftime ( [string] ) [EOL] x , y = timestamp . split ( [string] ) [EOL] sql_insert_query = ( [string] . format ( x , x , x , x , x , x , x , x , y ) ) [EOL] cursor = connection . cursor ( ) [EOL] result = cursor . execute ( sql_insert_query ) [EOL] connection . commit ( ) [EOL] print ( [string] ) [EOL] except mysql . connector . Error as error : [EOL] connection . rollback ( ) [comment] [EOL] print ( [string] . format ( error ) ) [EOL] finally : [EOL] if ( connection . is_connected ( ) ) : [EOL] cursor . close ( ) [EOL] connection . close ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Tuple , Any [EOL] import typing [EOL] import typing_extensions [EOL] import hashlib [EOL] import time [EOL] import datetime [EOL] import string [EOL] import mysql . connector [EOL] from mysql . connector import Error [EOL] from mysql . connector import errorcode [EOL] import json [EOL] import hashlib [EOL] import paho . mqtt [EOL] import paho . mqtt . publish as publish [EOL] import paho . mqtt . client as paho [EOL] [EOL] broker = [string] [EOL] port = [number] [EOL] [EOL] def on_publish_signin ( client , userdata , result ) : [comment] [EOL] print ( [string] ) [EOL] [EOL] client1 = paho . Client ( ) [EOL] client1 . on_publish = on_publish_signin [EOL] [EOL] client1 . connect ( broker , port ) [EOL] [EOL] def signup ( data ) : [EOL] try : [EOL] ts = time . time ( ) [EOL] timestamp = datetime . datetime . fromtimestamp ( ts ) . strftime ( [string] ) [EOL] date , time_ = timestamp . split ( [string] ) [EOL] date = str ( date ) [EOL] time_ = str ( time_ ) [EOL] print ( type ( date ) ) [EOL] print ( type ( time_ ) ) [EOL] connection = mysql . connector . connect ( host = [string] , database = [string] , user = [string] , password = [string] ) [EOL] print ( [string] ) [EOL] name = str ( data [ [string] ] ) [EOL] email = str ( data [ [string] ] ) [EOL] password = str ( data [ [string] ] ) [EOL] contact = str ( data [ [string] ] ) [EOL] x = hashlib . sha1 ( str . encode ( name + email + contact ) ) [EOL] hashkey = x . hexdigest ( ) [EOL] print ( hashkey ) [EOL] if ( data [ [string] ] == [string] ) : [EOL] print ( [string] ) [EOL] [comment] [EOL] sql = [string] [EOL] val = ( [string] , name , [string] , email , password , contact , [string] ) [EOL] else : [EOL] sql = [string] [EOL] val = ( [string] , [string] , [string] , name , [string] , [string] , email , password , [string] , [string] , [string] , date , time_ , contact , hashkey , [string] ) [EOL] print ( [string] ) [EOL] cursor = connection . cursor ( ) [EOL] result = cursor . execute ( sql , val ) [EOL] connection . commit ( ) [EOL] print ( [string] ) [EOL] client1 . publish ( [string] , [string] ) [EOL] client1 . publish ( [string] , key ) [EOL] except mysql . connector . Error as error : [EOL] client1 . publish ( [string] , [string] ) [EOL] connection . rollback ( ) [EOL] print ( [string] . format ( error ) ) [EOL] finally : [EOL] if ( connection . is_connected ( ) ) : [EOL] cursor . close ( ) [EOL] connection . close ( ) [EOL] print ( [string] ) [EOL] [EOL] def signin ( data ) : [EOL] try : [EOL] connection = mysql . connector . connect ( host = [string] , database = [string] , user = [string] , password = [string] ) [EOL] mycursor = connection . cursor ( ) [EOL] print ( [string] ) [EOL] email_ = str ( data [ [string] ] ) [EOL] password = str ( data [ [string] ] ) [EOL] print ( [string] + email_ + [string] + password ) [EOL] print ( data [ [string] ] ) [EOL] usertype = data [ [string] ] [EOL] print ( [string] ) [EOL] if ( usertype == [string] ) : [EOL] sql = [string] [EOL] adr = ( email_ , password , ) [EOL] elif ( usertype == [string] ) : [EOL] sql = [string] [EOL] adr = ( email_ , password , ) [EOL] print ( [string] ) [EOL] mycursor . execute ( sql , adr ) [EOL] records = mycursor . fetchall ( ) [EOL] print ( [string] , mycursor . rowcount ) [EOL] print ( [string] ) [EOL] key = [string] [EOL] for row in records : [EOL] print ( [string] , row [ [number] ] ) [EOL] print ( [string] , row [ [number] ] ) [EOL] key = row [ [number] ] [EOL] connection . commit ( ) [EOL] print ( [string] ) [EOL] [comment] [EOL] client1 . publish ( [string] , [string] ) [EOL] client1 . publish ( [string] , key ) [EOL] except mysql . connector . Error as error : [EOL] connection . rollback ( ) [EOL] print ( [string] . format ( error ) ) [EOL] client1 . publish ( [string] , [string] ) [EOL] finally : [EOL] if ( connection . is_connected ( ) ) : [EOL] mycursor . close ( ) [EOL] connection . close ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def on_connect ( client , userdata , flags , rc ) : [EOL] print ( [string] + str ( rc ) ) [EOL] client . subscribe ( [string] ) [comment] [EOL] client . subscribe ( [string] ) [EOL] print ( [string] ) [EOL] [EOL] def on_message ( client , userdata , msg ) : [EOL] [comment] [EOL] incoming = str ( msg . payload ) [EOL] print ( str ( msg . payload ) ) [EOL] data = json . loads ( incoming ) [EOL] print ( data [ [string] ] ) [EOL] if ( msg . topic == [string] ) : [EOL] signup ( data ) [EOL] if ( msg . topic == [string] ) : [EOL] signin ( data ) [EOL] [EOL] client = paho . Client ( ) [EOL] client . on_connect = on_connect [EOL] client . on_message = on_message [EOL] [EOL] client . connect ( [string] , [number] , [number] ) [EOL] [EOL] client . loop_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Union , Any , List , Dict [EOL] import typing [EOL] import unittest [EOL] import socket [EOL] import sys [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] from mock import Mock [EOL] else : [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] from paho . mqtt . client import WebsocketWrapper , WebsocketConnectionError [EOL] [EOL] [EOL] class TestHeaders ( object ) : [EOL] [docstring] [EOL] [EOL] def test_normal_headers ( self ) : [EOL] [docstring] [EOL] [EOL] response = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] def iter_response ( ) : [EOL] for i in [string] . join ( response ) . encode ( [string] ) : [EOL] yield i [EOL] [EOL] for i in [string] . encode ( [string] ) : [EOL] yield i [EOL] [EOL] it = iter_response ( ) [EOL] [EOL] def fakerecv ( * args ) : [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] return next ( it ) [EOL] else : [EOL] return bytes ( [ next ( it ) ] ) [EOL] [EOL] mocksock = Mock ( spec_set = socket . socket , recv = fakerecv , send = Mock ( ) , ) [EOL] [EOL] wargs = { [string] : [string] , [string] : [number] , [string] : [string] , [string] : None , [string] : True , [string] : mocksock , } [EOL] [EOL] with pytest . raises ( WebsocketConnectionError ) as exc : [EOL] WebsocketWrapper ( ** wargs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert str ( exc . value ) == [string] [EOL] [EOL] expected_sent = [ i . format ( ** wargs ) for i in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ] [EOL] [EOL] [comment] [EOL] assert mocksock . send . call_count == [number] [EOL] [EOL] for i in expected_sent : [EOL] assert i in mocksock . send . call_args [ [number] ] [ [number] ] . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str,unittest.mock.Mock]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str,unittest.mock.Mock]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[None,builtins.int,builtins.str,unittest.mock.Mock]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] import paho . mqtt . client as client [EOL] [EOL] [EOL] class Test_client_function ( object ) : [EOL] [docstring] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) def test_matching ( self , sub , topic ) : [EOL] assert client . topic_matches_sub ( sub , topic ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) def test_not_matching ( self , sub , topic ) : [EOL] assert not client . topic_matches_sub ( sub , topic ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [EOL] import paho_test [EOL] [EOL] context . check_ssl ( ) [EOL] [EOL] rc = [number] [EOL] keepalive = [number] [EOL] connect_packet = paho_test . gen_connect ( [string] , keepalive = keepalive ) [EOL] connack_packet = paho_test . gen_connack ( rc = [number] ) [EOL] disconnect_packet = paho_test . gen_disconnect ( ) [EOL] [EOL] ssock = paho_test . create_server_socket_ssl ( ) [EOL] [EOL] client = context . start_client ( ) [EOL] [EOL] try : [EOL] ( conn , address ) = ssock . accept ( ) [EOL] conn . settimeout ( [number] ) [EOL] [EOL] if paho_test . expect_packet ( conn , [string] , connect_packet ) : [EOL] conn . send ( connack_packet ) [EOL] [EOL] if paho_test . expect_packet ( conn , [string] , disconnect_packet ) : [EOL] rc = [number] [EOL] [EOL] conn . close ( ) [EOL] finally : [EOL] client . terminate ( ) [EOL] client . wait ( ) [EOL] ssock . close ( ) [EOL] [EOL] exit ( rc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [EOL] [EOL] context . check_ssl ( ) [EOL] [EOL] rc = [number] [EOL] [EOL] client = context . start_client ( ) [EOL] [EOL] client . wait ( ) [EOL] [EOL] rc = client . returncode [EOL] [EOL] exit ( rc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [EOL] import paho_test [EOL] [EOL] rc = [number] [EOL] keepalive = [number] [EOL] connect_packet = paho_test . gen_connect ( [string] , keepalive = keepalive ) [EOL] connack_packet = paho_test . gen_connack ( rc = [number] ) [EOL] [EOL] disconnect_packet = paho_test . gen_disconnect ( ) [EOL] [EOL] mid = [number] [EOL] unsubscribe_packet = paho_test . gen_unsubscribe ( mid , [string] ) [EOL] unsuback_packet = paho_test . gen_unsuback ( mid ) [EOL] [EOL] sock = paho_test . create_server_socket ( ) [EOL] [EOL] client = context . start_client ( ) [EOL] [EOL] try : [EOL] ( conn , address ) = sock . accept ( ) [EOL] conn . settimeout ( [number] ) [EOL] [EOL] if paho_test . expect_packet ( conn , [string] , connect_packet ) : [EOL] conn . send ( connack_packet ) [EOL] [EOL] if paho_test . expect_packet ( conn , [string] , unsubscribe_packet ) : [EOL] conn . send ( unsuback_packet ) [EOL] [EOL] if paho_test . expect_packet ( conn , [string] , disconnect_packet ) : [EOL] rc = [number] [EOL] [EOL] conn . close ( ) [EOL] finally : [EOL] client . terminate ( ) [EOL] client . wait ( ) [EOL] sock . close ( ) [EOL] [EOL] exit ( rc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
	0
from typing import Tuple , Any , List [EOL] import typing [EOL] class MQTTMatcher ( object ) : [EOL] [docstring] [EOL] [EOL] class Node ( object ) : [EOL] __slots__ = [string] , [string] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _children = { } [EOL] self . _content = None [EOL] [EOL] def __init__ ( self ) : [EOL] self . _root = self . Node ( ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] [docstring] [EOL] node = self . _root [EOL] for sym in key . split ( [string] ) : [EOL] node = node . _children . setdefault ( sym , self . Node ( ) ) [EOL] node . _content = value [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] [docstring] [EOL] try : [EOL] node = self . _root [EOL] for sym in key . split ( [string] ) : [EOL] node = node . _children [ sym ] [EOL] if node . _content is None : [EOL] raise KeyError ( key ) [EOL] return node . _content [EOL] except KeyError : [EOL] raise KeyError ( key ) [EOL] [EOL] def __delitem__ ( self , key ) : [EOL] [docstring] [EOL] lst = [ ] [EOL] try : [EOL] parent , node = None , self . _root [EOL] for k in key . split ( [string] ) : [EOL] parent , node = node , node . _children [ k ] [EOL] lst . append ( ( parent , k , node ) ) [EOL] [comment] [EOL] node . _content = None [EOL] except KeyError : [EOL] raise KeyError ( key ) [EOL] else : [comment] [EOL] for parent , k , node in reversed ( lst ) : [EOL] if node . _children or node . _content is not None : [EOL] break [EOL] del parent . _children [ k ] [EOL] [EOL] def iter_match ( self , topic ) : [EOL] [docstring] [EOL] lst = topic . split ( [string] ) [EOL] normal = not topic . startswith ( [string] ) [EOL] def rec ( node , i = [number] ) : [EOL] if i == len ( lst ) : [EOL] if node . _content is not None : [EOL] yield node . _content [EOL] else : [EOL] part = lst [ i ] [EOL] if part in node . _children : [EOL] for content in rec ( node . _children [ part ] , i + [number] ) : [EOL] yield content [EOL] if [string] in node . _children and ( normal or i > [number] ) : [EOL] for content in rec ( node . _children [ [string] ] , i + [number] ) : [EOL] yield content [EOL] if [string] in node . _children and ( normal or i > [number] ) : [EOL] content = node . _children [ [string] ] . _content [EOL] if content is not None : [EOL] yield content [EOL] return rec ( self . _root ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL] [EOL] [EOL] class MQTTException ( Exception ) : [EOL] pass [EOL]	$builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Union , List , Dict [EOL] import typing [EOL] import context [comment] [EOL] import paho . mqtt . publish as publish [EOL] [EOL] msgs = [ { [string] : [string] , [string] : [string] } , ( [string] , [string] , [number] , False ) ] [EOL] publish . multiple ( msgs , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.bool]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,builtins.str],typing.Tuple[builtins.str,builtins.str,builtins.int,builtins.bool]]]$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import context [comment] [EOL] import paho . mqtt . publish as publish [EOL] [EOL] publish . single ( [string] , [string] , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [comment] [EOL] import paho . mqtt . client as mqtt [EOL] [EOL] [EOL] def on_connect ( mqttc , obj , flags , rc ) : [EOL] if obj == [number] : [EOL] print ( [string] ) [EOL] elif obj == [number] : [EOL] print ( [string] ) [EOL] elif obj == [number] : [EOL] print ( [string] ) [EOL] print ( [string] + str ( flags [ [string] ] ) ) [EOL] print ( [string] + str ( rc ) ) [EOL] mqttc . disconnect ( ) [EOL] [EOL] [EOL] def on_disconnect ( mqttc , obj , rc ) : [EOL] mqttc . user_data_set ( obj + [number] ) [EOL] if obj == [number] : [EOL] mqttc . reconnect ( ) [EOL] [EOL] [EOL] def on_log ( mqttc , obj , level , string ) : [EOL] print ( string ) [EOL] [EOL] [EOL] mqttc = mqtt . Client ( client_id = [string] , clean_session = False ) [EOL] mqttc . on_connect = on_connect [EOL] mqttc . on_disconnect = on_disconnect [EOL] [comment] [EOL] [comment] [EOL] mqttc . user_data_set ( [number] ) [EOL] mqttc . connect ( [string] , [number] , [number] ) [EOL] [EOL] mqttc . loop_forever ( ) [EOL] [EOL] [comment] [EOL] mqttc = mqtt . Client ( client_id = [string] , clean_session = True ) [EOL] mqttc . on_connect = on_connect [EOL] mqttc . user_data_set ( [number] ) [EOL] mqttc . connect ( [string] , [number] , [number] ) [EOL] mqttc . loop_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import logging [EOL] import typing [EOL] import context [comment] [EOL] import paho . mqtt . client as mqtt [EOL] [EOL] import logging [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mqttc = mqtt . Client ( ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] mqttc . enable_logger ( logger ) [EOL] [EOL] mqttc . connect ( [string] , [number] , [number] ) [EOL] mqttc . subscribe ( [string] , [number] ) [EOL] [EOL] mqttc . loop_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import context [comment] [EOL] import paho . mqtt . publish as publish [EOL] [EOL] topic = [string] [EOL] payload = [string] [EOL] publish . single ( topic , payload , hostname = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import context [comment] [EOL] import paho . mqtt . client as mqtt [EOL] [EOL] [EOL] def on_message_msgs ( mosq , obj , msg ) : [EOL] [comment] [EOL] [comment] [EOL] print ( [string] + msg . topic + [string] + str ( msg . qos ) + [string] + str ( msg . payload ) ) [EOL] [EOL] [EOL] def on_message_bytes ( mosq , obj , msg ) : [EOL] [comment] [EOL] [comment] [EOL] print ( [string] + msg . topic + [string] + str ( msg . qos ) + [string] + str ( msg . payload ) ) [EOL] [EOL] [EOL] def on_message ( mosq , obj , msg ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] print ( msg . topic + [string] + str ( msg . qos ) + [string] + str ( msg . payload ) ) [EOL] [EOL] [EOL] mqttc = mqtt . Client ( ) [EOL] [EOL] [comment] [EOL] mqttc . message_callback_add ( [string] , on_message_msgs ) [EOL] mqttc . message_callback_add ( [string] , on_message_bytes ) [EOL] mqttc . on_message = on_message [EOL] mqttc . connect ( [string] , [number] , [number] ) [EOL] mqttc . subscribe ( [string] , [number] ) [EOL] [EOL] mqttc . loop_forever ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Union , Any , List , Dict [EOL] import typing [EOL] import functools [EOL] import datetime [EOL] import hmac [EOL] import hashlib [EOL] import datetime [EOL] import base64 [EOL] import uuid [EOL] import functools [EOL] [EOL] from paho . mqtt . client import Client [EOL] [EOL] [EOL] def get_amazon_auth_headers ( access_key , secret_key , region , host , port , headers = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def sign ( key , msg ) : [EOL] return hmac . new ( key , msg . encode ( [string] ) , hashlib . sha256 ) . digest ( ) [EOL] [EOL] def getSignatureKey ( key , dateStamp , regionName , serviceName ) : [EOL] kDate = sign ( ( [string] + key ) . encode ( [string] ) , dateStamp ) [EOL] kRegion = sign ( kDate , regionName ) [EOL] kService = sign ( kRegion , serviceName ) [EOL] kSigning = sign ( kService , [string] ) [EOL] return kSigning [EOL] [EOL] service = [string] [EOL] algorithm = [string] [EOL] [EOL] t = datetime . datetime . utcnow ( ) [EOL] amzdate = t . strftime ( [string] ) [EOL] datestamp = t . strftime ( [string] ) [comment] [EOL] [EOL] if headers is None : [EOL] headers = { [string] : [string] . format ( host ) , [string] : [string] , [string] : [string] , [string] : [string] . format ( host ) , [string] : base64 . b64encode ( uuid . uuid4 ( ) . bytes ) , [string] : [string] , [string] : [string] , } [EOL] [EOL] headers . update ( { [string] : amzdate , } ) [EOL] [EOL] [comment] [EOL] canonical_headers = [string] . join ( sorted ( [string] . format ( i . lower ( ) , j ) . strip ( ) for i , j in headers . items ( ) ) ) [EOL] [comment] [EOL] signed_headers = [string] . join ( sorted ( i . lower ( ) . strip ( ) for i in headers . keys ( ) ) ) [EOL] [EOL] [comment] [EOL] payload_hash = hashlib . sha256 ( [string] ) . hexdigest ( ) . lower ( ) [EOL] [EOL] request_parts = [ [string] , [string] , [string] , canonical_headers + [string] , signed_headers , payload_hash , ] [EOL] [EOL] canonical_request = [string] . join ( request_parts ) [EOL] [EOL] [comment] [EOL] hashed_request = hashlib . sha256 ( canonical_request ) . hexdigest ( ) [EOL] [EOL] credential_scope = [string] . format ( ** locals ( ) ) [EOL] string_to_sign = [string] . format ( ** locals ( ) ) [EOL] [EOL] signing_key = getSignatureKey ( secret_key , datestamp , region , service ) [EOL] signature = hmac . new ( signing_key , (string_to_sign) . encode ( [string] ) , hashlib . sha256 ) . hexdigest ( ) [EOL] [EOL] [comment] [EOL] authorization_header = [string] . format ( ** locals ( ) ) [EOL] [EOL] [comment] [EOL] headers [ [string] ] = authorization_header [EOL] [EOL] return headers [EOL] [EOL] [EOL] def example_use ( ) : [EOL] access_key = os . environ [ [string] ] [EOL] secret_key = os . environ [ [string] ] [EOL] port = [number] [EOL] [EOL] region = [string] [EOL] [EOL] [comment] [EOL] host = [string] . format ( region ) [EOL] [EOL] extra_headers = functools . partial ( get_amazon_auth_headers , access_key , secret_key , region , host , port , ) [EOL] [EOL] client = Client ( transport = [string] ) [EOL] [EOL] client . ws_set_options ( headers = extra_headers ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Dict [EOL] import typing [EOL] import typing_extensions [EOL] import logging [EOL] import tornado . web [EOL] import tornado . websocket [EOL] import tornado . ioloop [EOL] import tornado . options [EOL] [EOL] from tornado . options import define , options [EOL] [EOL] define ( [string] , default = [number] , help = [string] , type = int ) [EOL] class Application ( tornado . web . Application ) : [EOL] def __init__ ( self ) : [EOL] handlers = [ ( [string] , MainHandler ) ] [EOL] settings = dict ( debug = True ) [EOL] tornado . web . Application . __init__ ( self , handlers , ** settings ) [EOL] [EOL] class MainHandler ( tornado . websocket . WebSocketHandler ) : [EOL] def check_origin ( self , origin ) : [EOL] return True [EOL] [EOL] def open ( self ) : [EOL] print ( [string] ) [EOL] [comment] [EOL] def on_close ( self ) : [EOL] print ( [string] ) [EOL] [comment] [EOL] [EOL] def on_message ( self , message ) : [EOL] print ( [string] + message ) [EOL] [comment] [EOL] [EOL] def main ( ) : [EOL] tornado . options . parse_command_line ( ) [EOL] app = Application ( ) [EOL] app . listen ( [number] ) [EOL] tornado . ioloop . IOLoop . instance ( ) . start ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Any , Dict [EOL] import typing [EOL] import typing_extensions [EOL] import logging [EOL] import tornado . web [EOL] import tornado . websocket [EOL] import tornado . ioloop [EOL] import tornado . options [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class sen : [EOL] def __init__ ( self , pbm , spo2 , temp , airflow , body_pos , skin_cond , skin_resist , skin_volt ) : [EOL] self . pbm = pbm [EOL] self . spo2 = spo2 [EOL] self . temp = temp [EOL] self . airflow = airflow [EOL] self . body_pos = body_pos [EOL] self . skin_cond = skin_cond [EOL] self . skin_resist = skin_resist [EOL] self . skin_volt = skin_volt [EOL] [EOL] sensor = sen ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] [EOL] [EOL] class WebSocketHandler ( tornado . websocket . WebSocketHandler ) : [EOL] def check_orgin ( self , origin ) : [EOL] return True [EOL] [EOL] def open ( self ) : [EOL] print ( [string] ) [EOL] ioloop . IOLoop . instance ( ) . add_timeout ( datetime . timedelta ( seconds = [number] ) , self . send_data ) [EOL] [EOL] [EOL] def on_close ( self ) : [EOL] print ( [string] ) [EOL] [EOL] def send_data ( self ) : [EOL] try : [EOL] print ( [string] ) [EOL] point_data = { [string] : sensor . pbm , [string] : sensor . spo2 , [string] : sensor . temp , [string] : sensor . airflow } [EOL] self . write_message ( json . dumps ( point_data ) ) [EOL] ioloop . IOLoop . instance ( ) . add_timeout ( datetime . timedelta ( seconds = [number] ) , self . send_data ) [EOL] except : [EOL] pass [EOL] [EOL] [EOL] class Application ( tornado . web . Application ) : [EOL] def __init__ ( self ) : [EOL] handlers = [ ( [string] , MainHandler ) ] [EOL] settings = dict ( debug = True ) [EOL] tornado . web . Application . __init__ ( self , handlers , ** settings ) [EOL] [EOL] class MainHandler ( tornado . websocket . WebSocketHandler ) : [EOL] def check_origin ( self , origin ) : [EOL] return True [EOL] [EOL] def open ( self ) : [EOL] print ( [string] ) [EOL] [comment] [EOL] def on_close ( self ) : [EOL] print ( [string] ) [EOL] [comment] [EOL] [EOL] def on_message ( self , message ) : [EOL] print ( [string] + message ) [EOL] [comment] [EOL] if ( message . find ( [string] ) != - [number] ) : [EOL] param , value = message . split ( [string] ) [EOL] if ( param == [string] ) : [EOL] sensor . pbm = value [EOL] elif ( param == [string] ) : [EOL] sensor . spo2 = value [EOL] elif ( param == [string] ) : [EOL] sensor . temp = value [EOL] elif ( param == [string] ) : [EOL] sensor . airflow = value [EOL] try : [EOL] application = web . Application ( [ ( [string] , web . StaticFileHandler , { [string] : os . path . dirname ( __file__ ) } ) , ( [string] , WebSocketHandler ) ] ) [EOL] application . listen ( [number] )[comment] [EOL] except : [EOL] print ( [string] ) [EOL] elif ( param == [string] ) : [EOL] sensor . body_pos = value [EOL] elif ( param == [string] ) : [EOL] sensor . skin_cond = value [EOL] elif ( param == [string] ) : [EOL] sensor . skin_resist = value [EOL] elif ( param == [string] ) : [EOL] sensor . skin_volt = value [EOL] [EOL] [EOL] [EOL] def main ( ) : [EOL] tornado . options . parse_command_line ( ) [EOL] app = Application ( ) [EOL] app . listen ( [number] ) [EOL] tornado . ioloop . IOLoop . instance ( ) . start ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing_extensions.Literal[True]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tornado [EOL] from tornado . ioloop import IOLoop [EOL] from tornado . options import define , options , parse_command_line [EOL] from tornado . websocket import WebSocketHandler [EOL] from tornado . web import Application [EOL] [EOL] define ( [string] , default = [number] ) [EOL] [EOL] [EOL] class EchoHandler ( WebSocketHandler ) : [EOL] def on_message ( self , message ) : [EOL] self . write_message ( message , binary = isinstance ( message , bytes ) ) [EOL] [EOL] def get_compression_options ( self ) : [EOL] return { } [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parse_command_line ( ) [EOL] app = Application ( [ ( [string] , EchoHandler ) , ] ) [EOL] app . listen ( options . port , address = [string] ) [EOL] IOLoop . instance ( ) . start ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.web.Application$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from tornado import gen [EOL] [EOL] [EOL] @ gen . coroutine def hello ( ) : [EOL] yield gen . sleep ( [number] ) [EOL] raise gen . Return ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from tornado . web import RequestHandler [EOL] [EOL] [EOL] class MyHandler ( RequestHandler ) : [EOL] def get ( self ) : [comment] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from tornado import gen [EOL] from tornado . web import RequestHandler [EOL] [EOL] [EOL] class MyHandler ( RequestHandler ) : [EOL] def get ( self ) : [EOL] self . write ( [string] ) [EOL] [EOL] async def post ( self ) : [EOL] await gen . sleep ( [number] ) [EOL] self . write ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import sys [EOL] from lib2to3 . main import main [EOL] [EOL] sys . exit ( main ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List , Generator [EOL] import typing [EOL] import socket [EOL] import tornado [EOL] import pprint [EOL] import socket [EOL] [EOL] from tornado import gen [EOL] from tornado . ioloop import IOLoop [EOL] from tornado . netutil import Resolver , ThreadedResolver [EOL] from tornado . options import parse_command_line , define , options [EOL] [EOL] try : [EOL] import twisted [EOL] except ImportError : [EOL] twisted = None [EOL] [EOL] try : [EOL] import pycares [EOL] except ImportError : [EOL] pycares = None [EOL] [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] [EOL] [EOL] @ gen . coroutine def main ( ) : [EOL] args = parse_command_line ( ) [EOL] [EOL] if not args : [EOL] args = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] resolvers = [ Resolver ( ) , ThreadedResolver ( ) ] [EOL] [EOL] if twisted is not None : [EOL] from tornado . platform . twisted import TwistedResolver [EOL] resolvers . append ( TwistedResolver ( ) ) [EOL] [EOL] if pycares is not None : [EOL] from tornado . platform . caresresolver import CaresResolver [EOL] resolvers . append ( CaresResolver ( ) ) [EOL] [EOL] family = { [string] : socket . AF_UNSPEC , [string] : socket . AF_INET , [string] : socket . AF_INET6 , } [ options . family ] [EOL] [EOL] for host in args : [EOL] print ( [string] % host ) [EOL] for resolver in resolvers : [EOL] addrinfo = yield resolver . resolve ( host , [number] , family ) [EOL] print ( [string] % ( resolver . __class__ . __name__ , pprint . pformat ( addrinfo ) ) ) [EOL] print ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] IOLoop . instance ( ) . run_sync ( main ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Type , List [EOL] import typing [EOL] import tornado [EOL] from tornado . ioloop import IOLoop [EOL] from tornado . options import define , options , parse_command_line [EOL] from tornado . web import RequestHandler , Application [EOL] [EOL] import random [EOL] import signal [EOL] import subprocess [EOL] [EOL] try : [EOL] xrange [EOL] except NameError : [EOL] xrange = range [EOL] [EOL] [comment] [EOL] [comment] [EOL] define ( [string] , type = int , default = [number] ) [EOL] define ( [string] , type = int , default = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] define ( [string] , type = int , default = [number] ) [EOL] define ( [string] , type = int , default = [number] ) [EOL] define ( [string] , type = bool , default = False ) [EOL] define ( [string] , type = bool , default = False ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] define ( [string] , type = int , default = [number] ) [EOL] [EOL] define ( [string] , type = str , default = None ) [EOL] [EOL] [EOL] class RootHandler ( RequestHandler ) : [EOL] def get ( self ) : [EOL] self . write ( [string] ) [EOL] [EOL] def _log ( self ) : [EOL] pass [EOL] [EOL] [EOL] def handle_sigchld ( sig , frame ) : [EOL] IOLoop . current ( ) . add_callback_from_signal ( IOLoop . current ( ) . stop ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parse_command_line ( ) [EOL] if options . ioloop : [EOL] IOLoop . configure ( options . ioloop ) [EOL] for i in xrange ( options . num_runs ) : [EOL] run ( ) [EOL] [EOL] [EOL] def run ( ) : [EOL] io_loop = IOLoop ( make_current = True ) [EOL] app = Application ( [ ( [string] , RootHandler ) ] ) [EOL] port = random . randrange ( options . min_port , options . max_port ) [EOL] app . listen ( port , address = [string] ) [EOL] signal . signal ( signal . SIGCHLD , handle_sigchld ) [EOL] args = [ [string] ] [EOL] args . extend ( [ [string] , str ( options . n ) ] ) [EOL] args . extend ( [ [string] , str ( options . c ) ] ) [EOL] if options . keepalive : [EOL] args . append ( [string] ) [EOL] if options . quiet : [EOL] [comment] [EOL] args . append ( [string] ) [EOL] args . append ( [string] % port ) [EOL] subprocess . Popen ( args ) [EOL] io_loop . start ( ) [EOL] io_loop . close ( ) [EOL] io_loop . clear_current ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import typing [EOL] import tornado [EOL] import logging [EOL] from tornado . curl_httpclient import CurlAsyncHTTPClient [EOL] from tornado . simple_httpclient import SimpleAsyncHTTPClient [EOL] from tornado . ioloop import IOLoop [EOL] from tornado . options import define , options , parse_command_line [EOL] from tornado . web import RequestHandler , Application [EOL] [EOL] try : [EOL] xrange [EOL] except NameError : [EOL] xrange = range [EOL] [EOL] define ( [string] , default = [number] ) [EOL] define ( [string] , default = [number] ) [EOL] define ( [string] , default = [number] ) [EOL] [EOL] [EOL] class ChunkHandler ( RequestHandler ) : [EOL] def get ( self ) : [EOL] for i in xrange ( options . num_chunks ) : [EOL] self . write ( [string] * options . chunk_size ) [EOL] self . flush ( ) [EOL] self . finish ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] parse_command_line ( ) [EOL] app = Application ( [ ( [string] , ChunkHandler ) ] ) [EOL] app . listen ( options . port , address = [string] ) [EOL] [EOL] def callback ( response ) : [EOL] response . rethrow ( ) [EOL] assert len ( response . body ) == ( options . num_chunks * options . chunk_size ) [EOL] logging . warning ( [string] , response . request_time ) [EOL] IOLoop . current ( ) . stop ( ) [EOL] [EOL] logging . warning ( [string] ) [EOL] curl_client = CurlAsyncHTTPClient ( ) [EOL] curl_client . fetch ( [string] % options . port , callback = callback ) [EOL] IOLoop . current ( ) . start ( ) [EOL] [EOL] logging . warning ( [string] ) [EOL] simple_client = SimpleAsyncHTTPClient ( ) [EOL] simple_client . fetch ( [string] % options . port , callback = callback ) [EOL] IOLoop . current ( ) . start ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Tuple , Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] import urllib [EOL] [EOL] TMPDIR = [string] [EOL] [EOL] PYTHON_VERSIONS = [ ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] SCRIPTS_DIR = [string] [EOL] EASY_INSTALL = os . path . join ( SCRIPTS_DIR , [string] ) [EOL] [EOL] PY_PACKAGES = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def download_to_cache ( url , local_name = None ) : [EOL] if local_name is None : [EOL] local_name = url . split ( [string] ) [ - [number] ] [EOL] filename = os . path . join ( TMPDIR , local_name ) [EOL] if not os . path . exists ( filename ) : [EOL] data = urllib . urlopen ( url ) . read ( ) [EOL] with open ( filename , [string] ) as f : [EOL] f . write ( data ) [EOL] return filename [EOL] [EOL] [EOL] def main ( ) : [EOL] if not os . path . exists ( TMPDIR ) : [EOL] os . mkdir ( TMPDIR ) [EOL] os . chdir ( TMPDIR ) [EOL] for exe , url in PYTHON_VERSIONS : [EOL] if os . path . exists ( exe ) : [EOL] print ( [string] % exe ) [EOL] continue [EOL] print ( [string] % url ) [EOL] filename = download_to_cache ( url ) [EOL] [comment] [EOL] subprocess . check_call ( [ [string] , [string] , filename , [string] , [string] ] ) [EOL] [EOL] if not os . path . exists ( EASY_INSTALL ) : [EOL] filename = download_to_cache ( [string] ) [EOL] subprocess . check_call ( [ sys . executable , filename ] ) [EOL] [EOL] subprocess . check_call ( [ EASY_INSTALL ] + PY_PACKAGES ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Generator [EOL] import typing [EOL] from tornado . ioloop import IOLoop [EOL] from tornado import gen [EOL] from tornado . tcpclient import TCPClient [EOL] from tornado . options import options , define [EOL] [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] define ( [string] , default = [number] , help = [string] ) [EOL] define ( [string] , default = [string] , help = [string] ) [EOL] [EOL] [EOL] @ gen . coroutine def send_message ( ) : [EOL] stream = yield TCPClient ( ) . connect ( options . host , options . port ) [EOL] yield stream . write ( ( options . message + [string] ) . encode ( ) ) [EOL] print ( [string] , options . message ) [EOL] reply = yield stream . read_until ( [string] ) [EOL] print ( [string] , reply . decode ( ) . strip ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] options . parse_command_line ( ) [EOL] IOLoop . current ( ) . run_sync ( send_message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import tornado [EOL] import tornado . httpserver [EOL] import tornado . ioloop [EOL] import tornado . options [EOL] import tornado . web [EOL] [EOL] from tornado . options import define , options [EOL] [EOL] define ( [string] , default = [number] , help = [string] , type = int ) [EOL] [EOL] [EOL] class MainHandler ( tornado . web . RequestHandler ) : [EOL] def get ( self ) : [EOL] self . write ( [string] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] tornado . options . parse_command_line ( ) [EOL] application = tornado . web . Application ( [ ( [string] , MainHandler ) ] ) [EOL] http_server = tornado . httpserver . HTTPServer ( application ) [EOL] http_server . listen ( options . port ) [EOL] tornado . ioloop . IOLoop . current ( ) . start ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] from typing import Any , List , Callable , Tuple , Dict [EOL] import typing [EOL] import os [EOL] import sys [EOL] import time [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] import tornado [EOL] [EOL] master_doc = [string] [EOL] [EOL] project = [string] [EOL] copyright = [string] % time . strftime ( [string] ) [EOL] [EOL] version = release = tornado . version [EOL] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] primary_domain = [string] [EOL] default_role = [string] [EOL] [EOL] autodoc_member_order = [string] [EOL] autoclass_content = [string] [EOL] autodoc_inherit_docstrings = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] autodoc_docstring_signature = False [EOL] [EOL] coverage_skip_undoc_in_source = True [EOL] coverage_ignore_modules = [ [string] , [string] , [string] , ] [EOL] [comment] [EOL] coverage_ignore_classes = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] coverage_ignore_functions = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] html_favicon = [string] [EOL] [EOL] latex_documents = [ ( [string] , [string] , [string] , [string] , [string] , False ) , ] [EOL] [EOL] intersphinx_mapping = { [string] : ( [string] , None ) , } [EOL] [EOL] on_rtd = os . environ . get ( [string] , None ) == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not on_rtd : [EOL] import sphinx_rtd_theme [EOL] html_theme = [string] [EOL] html_theme_path = [ sphinx_rtd_theme . get_html_theme_path ( ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Literal , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = [string] [EOL] version_info = ( [number] , [number] , [number] , - [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def set_close_exec ( fd ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] [EOL] if os . name == [string] : [EOL] from tornado . platform . windows import set_close_exec [EOL] else : [EOL] from tornado . platform . posix import set_close_exec [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
	0
from typing import Iterable , Callable [EOL] import typing [EOL] [docstring] [EOL] from tornado . test . runtests import all , main [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] all = all [EOL] [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 $typing.Callable[[typing.Iterable],builtins.bool]$ 0 0 0 0 0 0
import tornado [EOL] from tornado . ioloop import IOLoop [EOL] from tornado . netutil import ThreadedResolver [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] resolver = ThreadedResolver ( ) [EOL] IOLoop . current ( ) . run_sync ( lambda : resolver . resolve ( [string] , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.netutil.ThreadedResolver$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tornado.netutil.ThreadedResolver$ 0 0 0 0 0 0 0 0 0
	0