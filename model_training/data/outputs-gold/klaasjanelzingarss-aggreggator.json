	0
from typing import Dict , List , Generator , Any , Optional [EOL] import flask [EOL] import core_lib [EOL] import builtins [EOL] import typing [EOL] from datetime import date , timedelta [EOL] from typing import Any , Dict , Generator [EOL] [EOL] from flask import Blueprint , jsonify , request , Response [EOL] from flask_cors import cross_origin [EOL] [EOL] from core_lib import application_data [EOL] from core_lib . application_data import ( event_repository , user_profile_repository , event_entity_transformer , ) [EOL] from core_lib . core . app_config import AppConfig [EOL] from core_lib . core . models import Event , Venue [EOL] from core_lib . core . repositories import EventEntityTransformer [EOL] from core_lib . core . token_verifier import TokenVerifier [EOL] from core_lib . core . user_profile import UserProfile [EOL] from core_lib . core . rss import RSSChannel , Transformer [EOL] [EOL] EVENT_API_ROUTES = Blueprint ( [string] , __name__ , template_folder = [string] ) [EOL] EVENT_ENTITY_TRANSFORMER = EventEntityTransformer ( venue_repository = application_data . venue_repository ) [EOL] VENUE_API_ROUTES = Blueprint ( [string] , __name__ , template_folder = [string] ) [EOL] USER_ROUTES = Blueprint ( [string] , __name__ , template_folder = [string] ) [EOL] MAINTENANCE_ROUTES = Blueprint ( [string] , __name__ , template_folder = [string] ) [EOL] RSS_ROUTES = Blueprint ( [string] , __name__ , template_folder = [string] ) [EOL] [EOL] [EOL] @ MAINTENANCE_ROUTES . route ( [string] ) def maintenance_ping ( ) : [EOL] return Response ( status = [number] ) [EOL] [EOL] [EOL] @ EVENT_API_ROUTES . route ( [string] , methods = [ [string] ] ) @ cross_origin ( ** AppConfig . cors ( ) ) def fetch_events ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] fetch_offset = request . args . get ( [string] ) [EOL] cursor = bytes ( fetch_offset , [string] ) if fetch_offset is not None else None [EOL] [EOL] query_result = event_repository . fetch_items ( cursor = cursor , limit = [number] ) [EOL] events = [ transform ( EVENT_ENTITY_TRANSFORMER . to_event ( item ) ) for item in query_result . items ] [EOL] [EOL] return jsonify ( { [string] : events , [string] : query_result . token . decode ( [string] ) } ) [EOL] [EOL] [EOL] @ EVENT_API_ROUTES . route ( [string] , methods = [ [string] ] ) @ cross_origin ( ** AppConfig . cors ( ) ) def fetch_today_events ( ) : [EOL] query_result = event_repository . fetch_items_on ( when = date . today ( ) ) [EOL] events = [ transform ( EVENT_ENTITY_TRANSFORMER . to_event ( item ) ) for item in query_result . items ] [EOL] return jsonify ( { [string] : events , [string] : query_result . token . decode ( [string] ) } ) [EOL] [EOL] [EOL] @ EVENT_API_ROUTES . route ( [string] , methods = [ [string] ] ) @ cross_origin ( ** AppConfig . cors ( ) ) def fetch_tomorrow_events ( ) : [EOL] query_result = event_repository . fetch_items_on ( when = date . today ( ) + timedelta ( days = [number] ) ) [EOL] events = [ transform ( EVENT_ENTITY_TRANSFORMER . to_event ( item ) ) for item in query_result . items ] [EOL] return jsonify ( { [string] : events , [string] : query_result . token . decode ( [string] ) } ) [EOL] [EOL] [EOL] @ EVENT_API_ROUTES . route ( [string] , methods = [ [string] ] ) @ cross_origin ( ** AppConfig . cors ( ) ) def fetch_day_after_tomorrow_events ( ) : [EOL] query_result = event_repository . fetch_items_on ( when = date . today ( ) + timedelta ( days = [number] ) ) [EOL] events = [ transform ( EVENT_ENTITY_TRANSFORMER . to_event ( item ) ) for item in query_result . items ] [EOL] return jsonify ( { [string] : events , [string] : query_result . token . decode ( [string] ) } ) [EOL] [EOL] [EOL] @ EVENT_API_ROUTES . route ( [string] , methods = [ [string] ] ) @ cross_origin ( ** AppConfig . cors ( ) ) def search_events ( ) : [EOL] term = request . args . get ( [string] ) [EOL] fetch_offset = request . args . get ( [string] ) [EOL] cursor = bytes ( fetch_offset , [string] ) if fetch_offset is not None else None [EOL] if term is None : [EOL] return fetch_events ( ) [EOL] query_result = event_repository . search ( term = term , cursor = cursor , limit = [number] ) [EOL] events = [ transform ( EVENT_ENTITY_TRANSFORMER . to_event ( item ) ) for item in query_result . items ] [EOL] [EOL] return jsonify ( { [string] : events , [string] : query_result . token . decode ( [string] ) } ) [EOL] [EOL] [EOL] def transform ( event ) : [EOL] venue = event . venue [EOL] return { [string] : event . event_id , [string] : event . url , [string] : event . title , [string] : event . description , [string] : event . image_url , [string] : event . when . isoformat ( ) , [string] : { [string] : venue . venue_id , [string] : venue . name , [string] : venue . city } , } [EOL] [EOL] [EOL] @ USER_ROUTES . route ( [string] , methods = [ [string] ] ) @ cross_origin ( ** AppConfig . cors ( ) ) def login_user ( ) : [EOL] [EOL] user_profile_token = TokenVerifier . verify_for_headers ( request . headers ) [EOL] if not user_profile_token : [EOL] return Response ( status = [number] ) [EOL] [EOL] user_profile_in_request = transform_to_user_profile ( request . json ) [EOL] user_profile = user_profile_repository . fetch_user_by_email ( user_profile_in_request . email ) [EOL] if user_profile : [EOL] return jsonify ( transform_to_json ( user_profile ) ) [EOL] [EOL] user_profile = user_profile_repository . insert ( user_profile_in_request ) [EOL] return jsonify ( transform_to_json ( user_profile ) ) , [number] [EOL] [EOL] [EOL] @ USER_ROUTES . route ( [string] , methods = [ [string] ] ) @ cross_origin ( ** AppConfig . cors ( ) ) def update_user ( ) : [EOL] user_profile_token = TokenVerifier . verify_for_headers ( request . headers ) [EOL] if not user_profile_token : [EOL] return Response ( status = [number] ) [EOL] [EOL] user_profile = user_profile_repository . insert ( transform_to_user_profile ( request . json ) ) [EOL] return jsonify ( transform_to_json ( user_profile ) ) [EOL] [EOL] [EOL] @ USER_ROUTES . route ( [string] , methods = [ [string] ] ) @ cross_origin ( ** AppConfig . cors ( ) ) def fetch_user_profile ( ) : [EOL] user_profile_token = TokenVerifier . verify_for_headers ( request . headers ) [EOL] if not user_profile_token : [EOL] return Response ( status = [number] ) [EOL] [EOL] result = user_profile_repository . fetch_user_by_email ( user_profile_token . email ) [EOL] if not result : [EOL] return Response ( status = [number] ) [EOL] return jsonify ( transform_to_json ( result ) ) [EOL] [EOL] [EOL] def transform_to_json ( user_profile ) : [EOL] return { [string] : user_profile . email , [string] : user_profile . avatar_url , [string] : user_profile . family_name , [string] : user_profile . given_name , } [EOL] [EOL] [EOL] def transform_to_user_profile ( body ) : [EOL] return UserProfile ( email = body [ [string] ] , given_name = body [ [string] ] , family_name = body [ [string] ] , avatar_url = body [ [string] ] , ) [EOL] [EOL] [EOL] @ VENUE_API_ROUTES . route ( [string] , methods = [ [string] ] ) @ cross_origin ( ** AppConfig . cors ( ) ) def fetch_venues ( ) : [EOL] venues = application_data . venue_repository . fetch_all ( ) [EOL] return jsonify ( { [string] : [ _transform ( venue ) for venue in venues ] } ) [EOL] [EOL] [EOL] def _transform ( venue ) : [EOL] return { [string] : venue . venue_id , [string] : venue . city , [string] : venue . country , [string] : venue . email , [string] : venue . name , [string] : venue . phone , [string] : venue . source_url , [string] : venue . convert_utc_to_venue_timezone ( venue . last_fetched_date ) . isoformat ( ) , [string] : venue . url , } [EOL] [EOL] [EOL] @ RSS_ROUTES . route ( [string] ) def fetch_rss ( ) : [EOL] def generate ( ) : [EOL] rss_channel = RSSChannel ( ) [EOL] pre_amble = rss_channel . generate_pre_amble ( ) [EOL] yield pre_amble . replace ( [string] , [string] ) . replace ( [string] , [string] ) . encode ( [string] ) [EOL] for event in [ event_entity_transformer . to_event ( event ) for event in event_repository . fetch_all_rss_items ( ) ] : [EOL] yield Transformer . item_to_rss ( event ) . as_node ( ) [EOL] yield rss_channel . generate_post_amble ( ) [EOL] [EOL] return Response ( generate ( ) , mimetype = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.user_profile.UserProfile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import flask [EOL] from flask import Flask [EOL] [EOL] from api . api import ( EVENT_API_ROUTES , USER_ROUTES , VENUE_API_ROUTES , MAINTENANCE_ROUTES , RSS_ROUTES , ) [EOL] from core_lib . core . app_config import AppConfig [EOL] [EOL] APP = Flask ( __name__ , static_folder = [string] , template_folder = [string] ) [EOL] [EOL] APP . register_blueprint ( EVENT_API_ROUTES ) [EOL] APP . register_blueprint ( MAINTENANCE_ROUTES ) [EOL] APP . register_blueprint ( RSS_ROUTES ) [EOL] APP . register_blueprint ( USER_ROUTES ) [EOL] APP . register_blueprint ( VENUE_API_ROUTES ) [EOL] [EOL] if __name__ == [string] : [EOL] APP . run ( host = [string] , port = AppConfig . get_port ( ) , debug = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from api . __main__ . api import __version__ [EOL] [EOL] [EOL] def test_version ( ) : [EOL] assert __version__ == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List , AsyncIterable [EOL] import core_lib [EOL] import builtins [EOL] import typing [EOL] import aiohttp [EOL] from abc import ABC , abstractmethod [EOL] from typing import AsyncIterable , List [EOL] [EOL] from aiohttp import ClientSession [EOL] [EOL] from core_lib . core . models import Event , Venue [EOL] from core_lib . core . fetcher_util import fetch [EOL] from core_lib . core . parser import Parser , ParsingContext [EOL] [EOL] [EOL] class Source ( ABC ) : [EOL] def __init__ ( self , venue , scrape_url , parser ) : [EOL] self . venue = venue [EOL] self . scrape_url = scrape_url [EOL] self . parser = parser [EOL] [EOL] async def fetch_page_in_one_call ( self , session ) : [EOL] data = await fetch ( url = self . scrape_url , session = session ) [EOL] events = self . parser . parse ( ParsingContext ( venue = self . venue , content = data ) ) [EOL] yield events [EOL] [EOL] async def fetch_page_indexed ( self , session , items_per_page ) : [EOL] page_index = [number] [EOL] done = False [EOL] while not done : [EOL] page_index += [number] [EOL] data = await fetch ( url = self . scrape_url . format ( page_index ) , session = session ) [EOL] new_events = self . parser . parse ( ParsingContext ( venue = self . venue , content = data ) ) [EOL] yield new_events [EOL] done = len ( new_events ) < items_per_page [EOL] [EOL] async def fetch_event_detail ( self , event , client_session ) : [EOL] return await fetch ( url = event . url , session = client_session ) [EOL] [EOL] @ abstractmethod async def fetch_events ( self , session ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterable[typing.List[core_lib.core.models.Event]]$ 0 0 0 $aiohttp.ClientSession$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 $aiohttp.ClientSession$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.AsyncIterable[typing.List[core_lib.core.models.Event]]$ 0 0 0 $aiohttp.ClientSession$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $aiohttp.ClientSession$ 0 $aiohttp.ClientSession$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $core_lib.core.models.Event$ 0 $aiohttp.ClientSession$ 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 $aiohttp.ClientSession$ 0 0 0 0 0 0 0 $typing.AsyncIterable[typing.List[core_lib.core.models.Event]]$ 0 0 0 $aiohttp.ClientSession$ 0 0 0 0 0
	0
from typing import Dict , Any , List , Optional [EOL] import google [EOL] import builtins [EOL] import typing [EOL] from dataclasses import dataclass [EOL] from typing import Optional , Dict [EOL] [EOL] from google . cloud import datastore [EOL] from google . cloud . client import Client [EOL] [EOL] [EOL] @ dataclass class UserProfile : [EOL] given_name = ... [EOL] family_name = ... [EOL] email = ... [EOL] avatar_url = ... [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . email }" [EOL] [EOL] [EOL] class UserProfileRepository : [EOL] def __init__ ( self , client ) : [EOL] self . client = client [EOL] [EOL] def fetch_user_by_email ( self , email ) : [EOL] query = self . client . query ( kind = [string] ) [EOL] query . add_filter ( [string] , [string] , email ) [EOL] result = list ( query . fetch ( ) ) [EOL] if not result : [EOL] return None [EOL] return UserProfileEntityTransformer . from_entity ( result [ [number] ] ) [EOL] [EOL] def insert ( self , user_profile ) : [EOL] entity = datastore . Entity ( self . client . key ( [string] , user_profile . email ) ) [EOL] entity . update ( UserProfileEntityTransformer . as_entity ( user_profile ) ) [EOL] self . client . put ( entity ) [EOL] return UserProfileEntityTransformer . from_entity ( entity ) [EOL] [EOL] [EOL] class UserProfileEntityTransformer : [EOL] @ staticmethod def as_entity ( user_profile ) : [EOL] return { [string] : user_profile . email , [string] : user_profile . given_name , [string] : user_profile . family_name , [string] : user_profile . avatar_url , } [EOL] [EOL] @ staticmethod def from_entity ( entity ) : [EOL] return UserProfile ( email = entity [ [string] ] , given_name = entity [ [string] ] , family_name = entity [ [string] ] , avatar_url = entity [ [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[UserProfile]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $UserProfile$ 0 0 0 $UserProfile$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $UserProfile$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $UserProfile$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $UserProfile$ 0 0 0 0 0 0 0 $UserProfile$ 0 0 0 0 0 $UserProfile$ 0 0 0 0 0 $UserProfile$ 0 0 0 0 0 $UserProfile$ 0 0 0 0 0 0 0 0 0 $UserProfile$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import core_lib [EOL] import asyncio [EOL] import aiohttp [EOL] import asyncio [EOL] import logging [EOL] from abc import ABC , abstractmethod [EOL] from datetime import datetime [EOL] [EOL] from aiohttp import ClientSession [EOL] [EOL] from core_lib . core . models import Venue [EOL] from core_lib . core . fetch_and_parse_details import FetchAndParseDetails [EOL] from core_lib . core . processing_chain import Chain , OnlyValidEvents , OnlyChangedEventsFilter , DatabaseSink [EOL] from core_lib . core . repositories import VenueRepository , EventRepository [EOL] from core_lib . core . source import Source [EOL] [EOL] [EOL] class VenueProcessor ( ABC ) : [EOL] def __init__ ( self , event_repository , venue_repository , venue , ) : [EOL] self . event_repository = event_repository [EOL] self . venue_repository = venue_repository [EOL] self . venue = venue [EOL] self . logger = logging . getLogger ( __name__ ) [EOL] self . venue_repository . insert ( self . venue ) [EOL] [EOL] [comment] [EOL] def create_processing_chain ( self , client_session , database_sink ) : [EOL] existing_keys = self . event_repository . fetch_all_keys_as_string_for_venue ( self . venue ) [EOL] only_changed_events_filter = OnlyChangedEventsFilter ( existing_keys ) [EOL] return Chain ( [ only_changed_events_filter , OnlyValidEvents ( ) , database_sink ] ) [EOL] [EOL] def processing_chain_with_additionals ( self , client_session , database_sink ) : [EOL] existing_keys = self . event_repository . fetch_all_keys_as_string_for_venue ( self . venue ) [EOL] only_changed_events_filter = OnlyChangedEventsFilter ( existing_keys ) [EOL] [EOL] return Chain ( [ only_changed_events_filter , OnlyValidEvents ( ) , FetchAndParseDetails ( client_session = client_session , source = self . fetch_source ( ) ) , database_sink , ] ) [EOL] [EOL] async def fetch_new_events ( self , session ) : [EOL] database_sink = DatabaseSink ( self . event_repository ) [EOL] chain = self . create_processing_chain ( session , database_sink ) [EOL] try : [EOL] fetched_events = await self . fetch_source ( ) . fetch_events ( session ) [EOL] tasks = [ asyncio . create_task ( chain . start_chain ( fetched_event ) ) async for fetched_event in fetched_events ] [EOL] await asyncio . gather ( * tasks ) [EOL] [EOL] database_sink . flush ( ) [EOL] [comment] [EOL] logging . getLogger ( __name__ ) . info ( [string] , database_sink . total_sunk , self . venue . venue_id ) [EOL] self . venue . last_fetched_date = datetime . now ( ) [EOL] self . venue_repository . upsert ( self . venue ) [EOL] [comment] [EOL] except Exception as exception : [EOL] logging . getLogger ( __name__ ) . exception ( [string] , self . venue . venue_id , exception ) [EOL] return database_sink . total_sunk [EOL] [EOL] @ abstractmethod def fetch_source ( self ) : [EOL] pass [EOL] [EOL] @ staticmethod @ abstractmethod def create_venue ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.processing_chain.Chain$ 0 0 0 $aiohttp.ClientSession$ 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 0 0 $core_lib.core.processing_chain.Chain$ 0 0 0 $aiohttp.ClientSession$ 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 $aiohttp.ClientSession$ 0 0 0 0 0 0 0 0 0 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $aiohttp.ClientSession$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 0 $typing.List[asyncio.tasks.Task[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[asyncio.tasks.Task[typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $core_lib.core.source.Source$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 0 0 0 0 0
from typing import List , Type , Optional [EOL] import builtins [EOL] import typing [EOL] import core_lib [EOL] import bs4 [EOL] import datetime [EOL] import logging [EOL] import re [EOL] from abc import ABC , abstractmethod [EOL] from dataclasses import dataclass [EOL] from datetime import datetime [EOL] from typing import List , Optional [EOL] [EOL] import dateparser [EOL] import pytz [EOL] from bs4 import Tag [EOL] from dateutil . relativedelta import relativedelta [EOL] [EOL] from core_lib . core . models import Event , Venue [EOL] [EOL] [EOL] @ dataclass class ParsingContext : [EOL] venue = ... [EOL] content = ... [EOL] [EOL] [EOL] class Parser ( ABC ) : [EOL] @ abstractmethod def parse ( self , parsing_context ) : [EOL] pass [EOL] [EOL] def update_event_with_details ( self , event , additional_details ) : [EOL] pass [EOL] [EOL] [EOL] class ParserUtil : [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] @ staticmethod def not_empty ( text ) : [EOL] return text is not None and text != [string] and text . strip ( ) != [string] [EOL] [EOL] @ staticmethod def is_empty ( text ) : [EOL] return not ParserUtil . not_empty ( text ) [EOL] [EOL] @ staticmethod def has_non_empty_text ( tag ) : [EOL] return tag is not None and ParserUtil . not_empty ( tag . text ) [EOL] [EOL] @ staticmethod def stripped_text_or_default_if_empty ( tag , default ) : [EOL] if tag is None or ParserUtil . is_empty ( tag . text ) : [EOL] return default [EOL] return tag . text . strip ( ) [EOL] [EOL] @ staticmethod def sanitize_text ( text ) : [EOL] return re . sub ( [string] , [string] , text ) . replace ( [string] , [string] ) [EOL] [EOL] @ staticmethod def remove_children_text_from ( parent_tag , text ) : [EOL] for tag in parent_tag . children : [EOL] if isinstance ( tag , Tag ) : [EOL] child_text = tag . text [EOL] text = text . replace ( child_text , [string] ) [EOL] return text [EOL] [EOL] @ staticmethod def parse_date_time_to_datetime ( date , time , tz_str ) : [EOL] when_date = dateparser . parse ( f"{ date } [string] { time }" , languages = [ [string] ] , settings = { [string] : tz_str , [string] : True } ) [EOL] if when_date is None : [EOL] now = datetime . now ( ) [EOL] year = now . year [EOL] when_date = dateparser . parse ( f"{ date } [string] { year } [string] { time }" , languages = [ [string] ] , settings = { [string] : tz_str , [string] : True } , ) [EOL] [EOL] if when_date is None : [EOL] now = datetime . now ( ) [EOL] year = now . year + [number] [EOL] when_date = dateparser . parse ( f"{ date } [string] { year } [string] { time }" , languages = [ [string] ] , settings = { [string] : tz_str , [string] : True } , ) [EOL] if when_date is None : [EOL] logging . warning ( [string] , date , time , tz_str ) [EOL] return None [EOL] [EOL] [comment] [EOL] if when_date is not None and when_date < ( datetime . now ( pytz . timezone ( tz_str ) ) - relativedelta ( days = [number] ) ) : [EOL] when_date = when_date + relativedelta ( years = [number] ) [EOL] return when_date [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Optional [EOL] import builtins [EOL] import typing [EOL] import werkzeug [EOL] import core_lib [EOL] import asyncio [EOL] import asyncio [EOL] import logging [EOL] from typing import Dict , Optional [EOL] [EOL] import aiohttp [EOL] from google . auth import jwt [EOL] from werkzeug . datastructures import EnvironHeaders [EOL] [EOL] from core_lib . core . user_profile import UserProfile [EOL] [EOL] [EOL] class TokenVerificationException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class TokenVerifier : [EOL] @ staticmethod async def _fetch_certs ( ) : [EOL] timeout = aiohttp . ClientTimeout ( total = [number] ) [EOL] async with aiohttp . ClientSession ( timeout = timeout ) as task_session : [EOL] async with task_session . get ( [string] ) as response : [EOL] return await response . json ( ) [EOL] [EOL] @ staticmethod async def _verify ( headers ) : [EOL] token_certs_task = asyncio . create_task ( TokenVerifier . _fetch_certs ( ) ) [EOL] try : [EOL] if [string] not in headers : [EOL] raise TokenVerificationException ( [string] ) [EOL] bearer_token = headers [ [string] ] [EOL] if len ( bearer_token ) < [number] : [EOL] raise TokenVerificationException ( [string] ) [EOL] if not bearer_token . startswith ( [string] ) : [EOL] raise TokenVerificationException ( [string] ) [EOL] token = bearer_token [ [number] : ] [EOL] result = jwt . decode ( token = token , certs = await token_certs_task , audience = [string] , ) [EOL] return UserProfile ( given_name = result [ [string] ] , family_name = result [ [string] ] , email = result [ [string] ] , avatar_url = result [ [string] ] , ) [EOL] except ValueError as error : [EOL] logging . info ( [string] , error . __str__ ( ) ) [EOL] except TokenVerificationException as error : [EOL] logging . info ( [string] , error . __str__ ( ) ) [EOL] finally : [EOL] if not token_certs_task . done ( ) : [EOL] token_certs_task . cancel ( ) [EOL] return None [EOL] [EOL] @ staticmethod def verify_for_headers ( headers ) : [EOL] result = asyncio . run ( TokenVerifier . _verify ( dict ( headers ) ) ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[core_lib.core.user_profile.UserProfile]$ 0 $typing.Dict$ 0 0 0 $asyncio.tasks.Task[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $asyncio.tasks.Task[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.tasks.Task[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 $asyncio.tasks.Task[typing.Dict[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[core_lib.core.user_profile.UserProfile]$ 0 $werkzeug.datastructures.EnvironHeaders$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.EnvironHeaders$ 0 0 0 0 0 $typing.Any$ 0
from typing import Any [EOL] import core_lib [EOL] import typing [EOL] import aiohttp [EOL] import asyncio [EOL] import concurrent [EOL] from json import JSONDecodeError [EOL] import logging [EOL] [EOL] from aiohttp import ClientSession [EOL] from aiohttp . client import ServerDisconnectedError [EOL] [EOL] from core_lib . core . models import Event [EOL] from core_lib . core . processing_chain import Link [EOL] from core_lib . core . source import Source [EOL] [EOL] [EOL] class FetchAndParseDetails ( Link ) : [EOL] def __init__ ( self , source , client_session ) : [EOL] super ( ) . __init__ ( ) [EOL] self . source = source [EOL] self . client_session = client_session [EOL] self . logger = logging . getLogger ( __name__ ) [EOL] [EOL] async def chain ( self , event ) : [EOL] try : [EOL] additional_data = await self . source . fetch_event_detail ( event = event , client_session = self . client_session ) [EOL] event = self . source . parser . update_event_with_details ( event = event , additional_details = additional_data ) [EOL] except JSONDecodeError : [EOL] self . logger . info ( [string] , event , event . venue ) [EOL] except ( concurrent . futures . TimeoutError , asyncio . TimeoutError ) : [EOL] self . logger . info ( [string] , event , event . venue ) [EOL] except ServerDisconnectedError : [EOL] self . logger . info ( [string] , event , event . venue ) [EOL] await self . invoke_next_link ( event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , List , Optional [EOL] import core_lib [EOL] import builtins [EOL] import typing [EOL] from abc import ABC , abstractmethod [EOL] from datetime import datetime [EOL] from typing import List , Optional [EOL] [EOL] from core_lib . core . models import Event [EOL] from core_lib . core . repositories import EventRepository [EOL] [EOL] [EOL] class Link ( ABC ) : [EOL] def __init__ ( self ) : [EOL] self . next_link = None [EOL] [EOL] @ abstractmethod async def chain ( self , event ) : [EOL] pass [EOL] [EOL] async def invoke_next_link ( self , event ) : [EOL] if self . next_link : [EOL] await self . next_link . chain ( event ) [EOL] [EOL] [EOL] class Chain : [EOL] def __init__ ( self , chain ) : [EOL] self . chain = chain [EOL] for i , link in enumerate ( self . chain [ : - [number] ] ) : [EOL] link . next_link = self . chain [ i + [number] ] [EOL] [EOL] async def start_chain ( self , events ) : [EOL] for event in events : [EOL] await self . chain [ [number] ] . chain ( event ) [EOL] [EOL] [EOL] class OnlyValidEvents ( Link ) : [EOL] async def chain ( self , event ) : [EOL] if event . is_valid ( ) : [EOL] await self . invoke_next_link ( event ) [EOL] [EOL] [EOL] class OnlyChangedEventsFilter ( Link ) : [EOL] def __init__ ( self , existing_keys ) : [EOL] super ( ) . __init__ ( ) [EOL] self . existing_keys = existing_keys [EOL] [EOL] async def chain ( self , event ) : [EOL] if event . event_id not in self . existing_keys : [EOL] await self . invoke_next_link ( event ) [EOL] [EOL] [EOL] class OnlyEventsWithWhen ( Link ) : [EOL] async def chain ( self , event ) : [EOL] if event . when is not None and event . when != datetime . min : [EOL] await self . invoke_next_link ( event ) [EOL] [EOL] [EOL] class DatabaseSink ( Link ) : [EOL] def __init__ ( self , event_repository ) : [EOL] super ( ) . __init__ ( ) [EOL] self . total_sunk = [number] [EOL] self . accumulator = [ ] [EOL] self . event_repository = event_repository [EOL] [EOL] async def chain ( self , event ) : [EOL] self . accumulator . append ( event ) [EOL] self . total_sunk += [number] [EOL] await self . invoke_next_link ( event ) [EOL] [EOL] def flush ( self ) : [EOL] sliced_events = DatabaseSink . slice_it ( [number] , self . accumulator ) [EOL] for slice_of_events in sliced_events : [EOL] self . event_repository . upsert_no_slicing ( slice_of_events ) [EOL] [EOL] @ staticmethod def slice_it ( batches , items ) : [EOL] result = [ ] [EOL] pivot = batches [EOL] index = [number] [EOL] done = False [EOL] while not done : [EOL] actual = min ( pivot + index , len ( items ) ) [EOL] first = items [ index : ( actual + index ) ] [EOL] done = actual == len ( items ) [EOL] result . append ( first ) [EOL] index += pivot [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[core_lib.core.models.Event]$ 0 0 0 0 0 0 $typing.List[core_lib.core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $None$ 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[core_lib.core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[core_lib.core.models.Event]]$ 0 $builtins.int$ 0 $typing.List[core_lib.core.models.Event]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[core_lib.core.models.Event]$ 0 0 0 $typing.Any$ 0 $typing.List[core_lib.core.models.Event]$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 $builtins.int$ 0 0 0 $typing.List[core_lib.core.models.Event]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0
from typing import Dict [EOL] import builtins [EOL] import typing [EOL] from enum import Enum [EOL] from os import getenv [EOL] from typing import Dict [EOL] [EOL] [EOL] class Environment ( Enum ) : [EOL] LOCALHOST = [string] [EOL] PRODUCTION = [string] [EOL] [EOL] [EOL] class AppConfig : [EOL] [EOL] _environment = Environment ( getenv ( [string] , [string] ) ) [EOL] [EOL] @ staticmethod def is_production ( ) : [EOL] return AppConfig . _environment == Environment . PRODUCTION [EOL] [EOL] @ staticmethod def is_localhost ( ) : [EOL] return AppConfig . _environment == Environment . LOCALHOST [EOL] [EOL] @ staticmethod def cors ( ) : [EOL] return { [string] : [string] if AppConfig . is_localhost ( ) else [string] } [EOL] [EOL] @ staticmethod def get_port ( ) : [EOL] return int ( getenv ( [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , AsyncIterable [EOL] import builtins [EOL] import typing [EOL] import core_lib [EOL] import bs4 [EOL] import aiohttp [EOL] from datetime import datetime [EOL] from typing import List , Dict , AsyncIterable [EOL] [EOL] from aiohttp import ClientSession [EOL] from bs4 import BeautifulSoup , Tag [EOL] [EOL] from core_lib . core . app_config import AppConfig [EOL] from core_lib . core . models import Event , Venue [EOL] from core_lib . core . parser import Parser , ParsingContext , ParserUtil [EOL] from core_lib . core . processing_chain import DatabaseSink , Chain , OnlyEventsWithWhen [EOL] from core_lib . core . repositories import EventRepository , VenueRepository [EOL] from core_lib . core . source import Source [EOL] from core_lib . core . venue_processor import VenueProcessor [EOL] [EOL] [EOL] class HedonParser ( Parser ) : [EOL] [docstring] [EOL] [EOL] def parse ( self , parsing_context ) : [EOL] soup = BeautifulSoup ( parsing_context . content , [string] ) [EOL] program_items = soup . find_all ( [string] ) [EOL] unique_items = { } [EOL] for program_item in program_items : [EOL] url = program_item . a . get ( [string] ) [EOL] if url not in unique_items : [EOL] unique_items [ url ] = program_item [EOL] else : [EOL] has_figure = program_item . find ( [string] ) is not None [EOL] has_time = program_item . find ( [string] ) is not None [EOL] old_has_time = unique_items [ url ] . find ( [string] ) is not None [EOL] if has_figure and has_time : [EOL] unique_items [ url ] = program_item [EOL] if has_time and not old_has_time : [EOL] unique_items [ url ] = program_item [EOL] return [ HedonParser . _transform ( parsing_context . venue , f ) for f in unique_items . values ( ) ] [EOL] [EOL] @ staticmethod def _transform ( venue , article ) : [EOL] source = venue . source_url [EOL] base_url = venue . url [EOL] url = f"{ base_url }{ article . a . get ( [string] ) }" [EOL] title = article . find ( [string] ) . text [EOL] description = title [EOL] figure = None [EOL] when = None [EOL] if article . find ( [string] ) is not None : [EOL] figure = article . find ( [string] ) . img . get ( [string] ) [EOL] figure = f" [string] { figure }" if not figure . startswith ( [string] ) else figure [EOL] if article . find ( [string] ) : [EOL] date = article . find ( [string] , { [string] : [string] } ) . text [EOL] time = article . find ( [string] , { [string] : [string] } ) . text [EOL] when = ParserUtil . parse_date_time_to_datetime ( date , time , venue . timezone ) [EOL] [EOL] return Event ( url = url , title = title , description = description , venue = venue , image_url = figure , source = source , date_published = datetime . now ( ) , when = when if when is not None else datetime . min , ) [EOL] [EOL] [EOL] class HedonProcessor ( VenueProcessor ) : [EOL] def __init__ ( self , event_repository , venue_repository ) : [EOL] self . venue = HedonProcessor . create_venue ( ) [EOL] super ( ) . __init__ ( event_repository , venue_repository , self . venue ) [EOL] [EOL] def fetch_source ( self ) : [EOL] return HedonSource ( self . venue ) [EOL] [EOL] def create_processing_chain ( self , client_session , database_sink ) : [EOL] if AppConfig . is_production ( ) : [EOL] return super ( ) . create_processing_chain ( client_session , database_sink ) [EOL] return Chain ( [ OnlyEventsWithWhen ( ) , database_sink ] ) [EOL] [EOL] @ staticmethod def create_venue ( ) : [EOL] return Venue ( venue_id = [string] , name = [string] , short_name = [string] , phone = [string] , city = [string] , country = [string] , timezone = [string] , email = [string] , url = [string] , source_url = [string] , ) [EOL] [EOL] [EOL] class HedonSource ( Source ) : [EOL] def __init__ ( self , venue , scrape_url = [string] ) : [EOL] super ( ) . __init__ ( venue , scrape_url , HedonParser ( ) ) [EOL] [EOL] async def fetch_events ( self , session ) : [EOL] return self . fetch_page_in_one_call ( session = session ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[core_lib.core.models.Event]$ 0 0 0 $core_lib.core.parser.ParsingContext$ 0 0 0 $typing.Any$ 0 0 0 $core_lib.core.parser.ParsingContext$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,bs4.Tag]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,bs4.Tag]$ 0 0 $typing.Dict[builtins.str,bs4.Tag]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Dict[builtins.str,bs4.Tag]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 $typing.Dict[builtins.str,bs4.Tag]$ 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $typing.Dict[builtins.str,bs4.Tag]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $core_lib.core.parser.ParsingContext$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,bs4.Tag]$ 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 $core_lib.core.models.Venue$ 0 $bs4.Tag$ 0 0 0 0 0 $core_lib.core.models.Venue$ 0 0 0 0 0 $core_lib.core.models.Venue$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 $core_lib.core.models.Venue$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.repositories.EventRepository$ 0 $core_lib.core.repositories.VenueRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.repositories.EventRepository$ 0 $core_lib.core.repositories.VenueRepository$ 0 0 0 0 0 0 0 0 $core_lib.core.source.Source$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.processing_chain.Chain$ 0 0 0 $aiohttp.ClientSession$ 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 0 0 0 0 0 0 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.AsyncIterable[typing.List[core_lib.core.models.Event]]$ 0 0 0 $aiohttp.ClientSession$ 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 $aiohttp.ClientSession$ 0 0
	0
from typing import Any , List , AsyncIterable , Optional [EOL] import builtins [EOL] import typing [EOL] import xml [EOL] import core_lib [EOL] import aiohttp [EOL] from datetime import datetime [EOL] from typing import List , AsyncIterable [EOL] from xml . etree import ElementTree [EOL] [EOL] from aiohttp import ClientSession [EOL] from bs4 import BeautifulSoup [EOL] [EOL] from core_lib . core . fetch_and_parse_details import FetchAndParseDetails [EOL] from core_lib . core . models import Event , Venue [EOL] from core_lib . core . parser import Parser , ParsingContext , ParserUtil [EOL] from core_lib . core . processing_chain import DatabaseSink , Chain , OnlyValidEvents [EOL] from core_lib . core . repositories import EventRepository , VenueRepository [EOL] from core_lib . core . source import Source [EOL] from core_lib . core . venue_processor import VenueProcessor [EOL] [EOL] [EOL] class NeushoornParser ( Parser ) : [EOL] def parse ( self , parsing_context ) : [EOL] root = ElementTree . fromstring ( parsing_context . content ) [EOL] events = [ ] [EOL] for item in root . iter ( [string] ) : [EOL] maybe_url = item . find ( [string] ) [EOL] maybe_description = item . find ( [string] ) [EOL] maybe_title = item . find ( [string] ) [EOL] if maybe_url is None or maybe_title is None or maybe_description is None : [EOL] break [EOL] url = maybe_url . text [EOL] description = maybe_description . text [EOL] title = maybe_title . text [EOL] events . append ( Event ( url = str ( url ) , title = str ( title ) , description = str ( description ) , venue = parsing_context . venue , source = parsing_context . venue . url , date_published = datetime . now ( ) , when = datetime . min , image_url = None , ) ) [EOL] return events [EOL] [EOL] def update_event_with_details ( self , event , additional_details ) : [EOL] soup = BeautifulSoup ( additional_details , features = [string] ) [EOL] image_url = None [EOL] when_date = None [EOL] if soup . find ( [string] , { [string] : [string] } ) is not None : [EOL] image_url = soup . find ( [string] , { [string] : [string] } ) [ [string] ] [EOL] if soup . find ( [string] , { [string] : [string] } ) : [EOL] image_url = soup . find ( [string] , { [string] : [string] } ) [ [string] ] [EOL] summary_div = soup . find ( [string] , { [string] : [string] } ) [EOL] summary_item_divs = summary_div . find_all ( [string] , { [string] : [string] } ) [EOL] if len ( summary_item_divs ) == [number] : [EOL] date = summary_item_divs [ [number] ] . text [EOL] time = summary_item_divs [ [number] ] . text [EOL] date = ParserUtil . sanitize_text ( date ) [EOL] time = ParserUtil . sanitize_text ( time ) [EOL] time = time [ time . index ( [string] ) + [number] : ] [EOL] when_date = ParserUtil . parse_date_time_to_datetime ( date , time , event . venue . timezone ) [EOL] [EOL] if when_date is not None : [EOL] event . when = when_date [EOL] event . image_url = image_url [EOL] return event [EOL] [EOL] [EOL] class NeushoornProcessor ( VenueProcessor ) : [EOL] def __init__ ( self , event_repository , venue_repository ) : [EOL] self . venue = NeushoornProcessor . create_venue ( ) [EOL] super ( ) . __init__ ( event_repository , venue_repository , self . venue ) [EOL] [EOL] def fetch_source ( self ) : [EOL] return NeushoornSource ( self . venue ) [EOL] [EOL] [comment] [EOL] def create_processing_chain ( self , client_session , database_sink ) : [EOL] return Chain ( [ FetchAndParseDetails ( client_session = client_session , source = self . fetch_source ( ) ) , OnlyValidEvents ( ) , database_sink , ] ) [EOL] [EOL] @ staticmethod def create_venue ( ) : [EOL] return Venue ( venue_id = [string] , short_name = [string] , name = [string] , phone = [string] , city = [string] , country = [string] , timezone = [string] , email = [string] , url = [string] , source_url = [string] , ) [EOL] [EOL] [EOL] class NeushoornSource ( Source ) : [EOL] def __init__ ( self , venue , scrape_url = [string] ) : [EOL] super ( ) . __init__ ( venue , scrape_url , NeushoornParser ( ) ) [EOL] [EOL] async def fetch_events ( self , session ) : [EOL] return self . fetch_page_in_one_call ( session = session ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[core_lib.core.models.Event]$ 0 0 0 $core_lib.core.parser.ParsingContext$ 0 0 0 $xml.etree.ElementTree.Element$ 0 0 0 0 0 $core_lib.core.parser.ParsingContext$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $xml.etree.ElementTree.Element$ 0 0 0 0 0 0 0 $typing.Optional[xml.etree.ElementTree.Element]$ 0 0 0 0 0 0 0 0 $typing.Optional[xml.etree.ElementTree.Element]$ 0 0 0 0 0 0 0 0 $typing.Optional[xml.etree.ElementTree.Element]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[xml.etree.ElementTree.Element]$ 0 0 0 $typing.Optional[xml.etree.ElementTree.Element]$ 0 0 0 $typing.Optional[xml.etree.ElementTree.Element]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[xml.etree.ElementTree.Element]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[xml.etree.ElementTree.Element]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[xml.etree.ElementTree.Element]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $core_lib.core.parser.ParsingContext$ 0 0 0 0 0 $core_lib.core.parser.ParsingContext$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $core_lib.core.models.Event$ 0 0 0 $core_lib.core.models.Event$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 $typing.Any$ 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.repositories.EventRepository$ 0 $core_lib.core.repositories.VenueRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.repositories.EventRepository$ 0 $core_lib.core.repositories.VenueRepository$ 0 0 0 0 0 0 0 0 $core_lib.core.source.Source$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.processing_chain.Chain$ 0 0 0 $aiohttp.ClientSession$ 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 $aiohttp.ClientSession$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.AsyncIterable[typing.List[core_lib.core.models.Event]]$ 0 0 0 $aiohttp.ClientSession$ 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 $aiohttp.ClientSession$ 0 0
from typing import Dict , List , Optional , Any , AsyncIterable [EOL] import builtins [EOL] import typing [EOL] import core_lib [EOL] import datetime [EOL] import aiohttp [EOL] import json [EOL] from datetime import datetime [EOL] from typing import List , Dict , AsyncIterable [EOL] [EOL] import dateparser [EOL] from aiohttp import ClientSession [EOL] [EOL] from core_lib . core . models import Event , Venue [EOL] from core_lib . core . parser import Parser , ParsingContext , ParserUtil [EOL] from core_lib . core . processing_chain import DatabaseSink , Chain [EOL] from core_lib . core . repositories import EventRepository , VenueRepository [EOL] from core_lib . core . source import Source [EOL] from core_lib . core . venue_processor import VenueProcessor [EOL] [EOL] [EOL] class ParadisoParser ( Parser ) : [EOL] def parse ( self , parsing_context ) : [EOL] program_items = json . loads ( parsing_context . content ) [EOL] return [ ParadisoParser . _transform ( parsing_context . venue , item ) for item in program_items ] [EOL] [EOL] @ staticmethod def _transform ( venue , data ) : [EOL] source = venue . source_url [EOL] paradiso_url = f' [string] { data [ [string] ] } [string] ' [EOL] title = data [ [string] ] [EOL] description = data [ [string] ] [EOL] description = description if ParserUtil . not_empty ( description ) else title [EOL] when_format = f'{ data [ [string] ] }' [EOL] [EOL] when = dateparser . parse ( when_format , languages = [ [string] ] , settings = { [string] : venue . timezone , [string] : True } ) [EOL] [EOL] return Event ( url = paradiso_url , title = title , description = description , date_published = datetime . now ( ) , venue = venue , source = source , when = when , ) [EOL] [EOL] def update_event_with_details ( self , event , additional_details ) : [EOL] additional_json = json . loads ( additional_details ) [EOL] if len ( additional_json ) > [number] : [EOL] if [string] in additional_json [ [number] ] : [EOL] if [string] in additional_json [ [number] ] [ [string] ] : [EOL] event . url = additional_json [ [number] ] [ [string] ] [ [string] ] [ [string] ] [EOL] if [string] in additional_json [ [number] ] [ [string] ] : [EOL] main_image = additional_json [ [number] ] [ [string] ] [ [string] ] [EOL] folder_path = main_image [ [string] ] [EOL] filename = main_image [ [string] ] [EOL] event . image_url = f" [string] { folder_path } [string] { filename }" [EOL] return event [EOL] [EOL] [EOL] class ParadisoProcessor ( VenueProcessor ) : [EOL] def __init__ ( self , event_repository , venue_repository ) : [EOL] self . venue = ParadisoProcessor . create_venue ( ) [EOL] super ( ) . __init__ ( event_repository , venue_repository , self . venue ) [EOL] [EOL] def fetch_source ( self ) : [EOL] return ParadisoSource ( self . venue ) [EOL] [EOL] def create_processing_chain ( self , client_session , database_sink ) : [EOL] return super ( ) . processing_chain_with_additionals ( client_session , database_sink ) [EOL] [EOL] @ staticmethod def create_venue ( ) : [EOL] return Venue ( venue_id = [string] , short_name = [string] , name = [string] , phone = [string] , city = [string] , country = [string] , timezone = [string] , email = [string] , url = [string] , source_url = [string] , ) [EOL] [EOL] [EOL] class ParadisoSource ( Source ) : [EOL] def __init__ ( self , venue , scrape_url = [string] [string] , ) : [EOL] super ( ) . __init__ ( venue , scrape_url , ParadisoParser ( ) ) [EOL] [EOL] async def fetch_events ( self , session ) : [EOL] return self . fetch_page_indexed ( session = session , items_per_page = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 $core_lib.core.models.Event$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.repositories.EventRepository$ 0 $core_lib.core.repositories.VenueRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.repositories.EventRepository$ 0 $core_lib.core.repositories.VenueRepository$ 0 0 0 0 0 0 0 0 $core_lib.core.source.Source$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.processing_chain.Chain$ 0 0 0 $aiohttp.ClientSession$ 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 $core_lib.core.processing_chain.DatabaseSink$ 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.AsyncIterable[typing.List[core_lib.core.models.Event]]$ 0 0 0 $aiohttp.ClientSession$ 0 0 0 0 0 0 0 0 $aiohttp.ClientSession$ 0 $aiohttp.ClientSession$ 0 0 0 0 0 0
from typing import Any [EOL] import core_lib [EOL] import typing [EOL] from unittest . mock import Mock [EOL] [EOL] import pytest [EOL] import pytz [EOL] from aiohttp import ClientSession , ClientTimeout [EOL] from faker import Faker [EOL] [EOL] from core_lib . core . models import Event , Venue [EOL] from core_lib . core . user_profile import UserProfile [EOL] from core_lib . core . repositories import VenueRepository , EventRepository [EOL] from core_lib . venues . hedon_zwolle import HedonProcessor [EOL] from core_lib . venues . melkweg_amsterdam import MelkwegProcessor [EOL] from core_lib . venues . neushoorn_leeuwarden import NeushoornProcessor [EOL] from core_lib . venues . oost_groningen import OostGroningenProcessor [EOL] from core_lib . venues . paradiso_amsterdam import ParadisoProcessor [EOL] from core_lib . venues . simplon_groningen import SimplonProcessor [EOL] from core_lib . venues . spot_groningen import SpotProcessor [EOL] from core_lib . venues . t013_tilburg import T013Processor [EOL] from core_lib . venues . tivoli_utrecht import TivoliProcessor [EOL] from core_lib . venues . vera_groningen import VeraProcessor [EOL] [EOL] FAKE = Faker ( ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_venue_repository ( ) : [EOL] return Mock ( spec = VenueRepository ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_event_repository ( ) : [EOL] return Mock ( spec = EventRepository ) [EOL] [EOL] [EOL] @ pytest . fixture def hedon_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return HedonProcessor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def melkweg_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return MelkwegProcessor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def neushoorn_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return NeushoornProcessor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def oost_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return OostGroningenProcessor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def paradiso_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return ParadisoProcessor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def simplon_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return SimplonProcessor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def spot_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return SpotProcessor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def t013_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return T013Processor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def tivoli_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return TivoliProcessor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def vera_processor ( mock_event_repository , mock_venue_repository ) : [EOL] return VeraProcessor ( event_repository = mock_event_repository , venue_repository = mock_venue_repository , ) [EOL] [EOL] [EOL] @ pytest . fixture def valid_venue ( ) : [EOL] return Venue ( venue_id = FAKE . name ( ) , name = FAKE . name ( ) , short_name = FAKE . sentence ( ) , phone = FAKE . phone_number ( ) , city = FAKE . city ( ) , country = FAKE . country_code ( ) , timezone = [string] , email = FAKE . ascii_email ( ) , source_url = FAKE . url ( ) , url = FAKE . url ( ) , ) [EOL] [EOL] [EOL] @ pytest . fixture def valid_event ( valid_venue ) : [EOL] return Event ( url = FAKE . url ( ) , description = FAKE . sentence ( ) , title = FAKE . sentence ( ) , source = valid_venue . source_url , date_published = FAKE . past_date ( start_date = [string] , tzinfo = pytz . timezone ( [string] ) ) , image_url = FAKE . uri ( ) , venue = valid_venue , when = FAKE . date_time_this_year ( before_now = False , after_now = True , tzinfo = pytz . timezone ( [string] ) ) , ) [EOL] [EOL] [EOL] @ pytest . fixture def valid_user_profile ( ) : [EOL] return UserProfile ( email = FAKE . ascii_email ( ) , given_name = FAKE . first_name ( ) , family_name = FAKE . last_name ( ) , avatar_url = FAKE . uri ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture async def client_session ( ) : [EOL] timeout = ClientTimeout ( [number] ) [EOL] a_client_session = ClientSession ( timeout = timeout ) [EOL] yield a_client_session [EOL] await a_client_session . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.repositories.VenueRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.repositories.EventRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.hedon_zwolle.HedonProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.melkweg_amsterdam.MelkwegProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.neushoorn_leeuwarden.NeushoornProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.oost_groningen.OostGroningenProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.paradiso_amsterdam.ParadisoProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.simplon_groningen.SimplonProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.spot_groningen.SpotProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.t013_tilburg.T013Processor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.tivoli_utrecht.TivoliProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.venues.vera_groningen.VeraProcessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Venue$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.user_profile.UserProfile$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] from hamcrest import matches_regexp [EOL] from hamcrest . core import assert_that [EOL] [EOL] from core_lib . core . fetcher_util import _fix [EOL] [EOL] [EOL] def test_random_future_date ( ) : [EOL] result = _fix ( [string] ) [EOL] assert_that ( result , matches_regexp ( [string] ) ) [EOL] [EOL] [EOL] def test_random_future_date_pattern ( ) : [EOL] result = _fix ( [string] ) [EOL] assert_that ( result , matches_regexp ( [string] ) ) [EOL] [EOL] [EOL] def test_random_future_time_pattern ( ) : [EOL] result = _fix ( [string] ) [EOL] assert_that ( result , matches_regexp ( [string] ) ) [EOL] [EOL] [EOL] def test_random_future_date_time_pattern ( ) : [EOL] result = _fix ( [string] ) [EOL] assert_that ( result , matches_regexp ( [string] ) ) [EOL] [EOL] [EOL] def test_simplon_pattern ( ) : [EOL] result = _fix ( [string] ) [EOL] assert_that ( result , matches_regexp ( [string] ) ) [EOL] [EOL] [EOL] def test_tivoli_pattern ( ) : [EOL] result = _fix ( [string] ) [EOL] assert_that ( result , matches_regexp ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from hamcrest import has_items [EOL] from hamcrest . core import assert_that [EOL] [EOL] from core_lib . core . models import split_term [EOL] [EOL] [EOL] def test_search_terms ( ) : [EOL] term = [string] [EOL] search_terms = split_term ( term ) [EOL] assert_that ( search_terms , has_items ( [string] , [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import core_lib [EOL] from copy import copy [EOL] from datetime import datetime , timedelta [EOL] [EOL] import pytz [EOL] from hamcrest import equal_to , is_not [EOL] from hamcrest . core import assert_that [EOL] [EOL] from core_lib . core . models import Event [EOL] [EOL] [EOL] def test_valid ( valid_event ) : [EOL] assert_that ( valid_event . is_valid ( ) , equal_to ( True ) ) [EOL] Event [EOL] [EOL] [EOL] def test_title ( valid_event ) : [EOL] event = valid_event [EOL] event . title = None [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] event . title = [string] [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] [EOL] [EOL] def test_url ( valid_event ) : [EOL] event = valid_event [EOL] event . url = None [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] event . url = [string] [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] [EOL] [EOL] def test_description ( valid_event ) : [EOL] event = valid_event [EOL] event . description = None [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] event . description = [string] [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] [EOL] [EOL] def test_when ( valid_event ) : [EOL] event = valid_event [EOL] event . when = datetime . min [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] [EOL] [EOL] def test_equality ( valid_event ) : [EOL] event = valid_event [EOL] event2 = copy ( valid_event ) [EOL] event3 = copy ( valid_event ) [EOL] event3 . url = [string] [EOL] event3 . __post_init__ ( ) [EOL] [EOL] assert_that ( event , equal_to ( event2 ) ) [EOL] assert_that ( event2 , equal_to ( event ) ) [EOL] assert_that ( event2 , is_not ( equal_to ( event3 ) ) ) [EOL] assert_that ( event , is_not ( equal_to ( event3 ) ) ) [EOL] [EOL] [EOL] def test_invalid_when_too_old ( valid_event ) : [EOL] event = valid_event [EOL] event . when = datetime . now ( pytz . timezone ( [string] ) ) - timedelta ( days = [number] ) [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] [EOL] event . when = datetime . now ( pytz . timezone ( [string] ) ) - timedelta ( minutes = [number] ) [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] [EOL] event . when = datetime . now ( pytz . timezone ( [string] ) ) + timedelta ( minutes = [number] ) [EOL] assert_that ( event . is_valid ( ) , equal_to ( True ) ) [EOL] [EOL] [EOL] def test_invalid_event_empty_title ( valid_event ) : [EOL] event = valid_event [EOL] assert_that ( event . is_valid ( ) , equal_to ( True ) ) [EOL] [EOL] event = valid_event [EOL] event . title = None [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] [EOL] [EOL] def test_invalid_event_empty_image_url ( valid_event ) : [EOL] event = valid_event [EOL] event . image_url = None [EOL] assert_that ( event . is_valid ( ) , equal_to ( True ) ) [EOL] [EOL] [EOL] def test_invalid_event_empty_description ( valid_event ) : [EOL] event = valid_event [EOL] event . description = None [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL] [EOL] [EOL] def test_invalid_event_past_date ( valid_event ) : [EOL] event = valid_event [EOL] event . when = datetime . now ( pytz . timezone ( [string] ) ) + timedelta ( minutes = - [number] ) [EOL] assert_that ( event . is_valid ( ) , equal_to ( False ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import core_lib [EOL] import typing [EOL] from datetime import datetime [EOL] [EOL] from hamcrest import equal_to , not_none [EOL] from hamcrest . core import assert_that [EOL] [EOL] from core_lib . core . models import Event , Venue [EOL] from core_lib . core . repositories import VenueRepository , EventEntityTransformer [EOL] [EOL] [EOL] def test_mapping_to_event ( mock_venue_repository , valid_venue ) : [EOL] event_entity_transformer = EventEntityTransformer ( mock_venue_repository ) [EOL] mock_venue_repository . get_venue_for . return_value = valid_venue [EOL] event = event_entity_transformer . to_event ( entity_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : datetime . now ( ) , [string] : [string] , [string] : valid_venue . venue_id , [string] : datetime . now ( ) , } ) [EOL] assert_that ( event . url , equal_to ( [string] ) ) [EOL] assert_that ( event . title , equal_to ( [string] ) ) [EOL] assert_that ( event . source , equal_to ( [string] ) ) [EOL] assert_that ( event . description , equal_to ( [string] ) ) [EOL] assert_that ( event . image_url , equal_to ( [string] ) ) [EOL] assert_that ( event . venue , equal_to ( valid_venue ) ) [EOL] assert_that ( event . when , not_none ( ) ) [EOL] mock_venue_repository . get_venue_for . assert_called_once ( ) [EOL] mock_venue_repository . get_venue_for . assert_called_with ( valid_venue . venue_id ) [EOL] [EOL] [EOL] def test_mapping_to_entity ( valid_event ) : [EOL] entity = EventEntityTransformer . to_entity ( valid_event ) [EOL] assert_that ( entity [ [string] ] , valid_event . url ) [EOL] assert_that ( entity [ [string] ] , valid_event . venue . venue_id ) [EOL] assert_that ( entity [ [string] ] , valid_event . image_url ) [EOL] assert_that ( entity [ [string] ] , valid_event . source ) [EOL] assert_that ( entity [ [string] ] , valid_event . when ) [EOL] assert_that ( entity [ [string] ] , valid_event . description ) [EOL] assert_that ( entity [ [string] ] , valid_event . title ) [EOL] assert_that ( len ( entity ) , equal_to ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import core_lib [EOL] import typing [EOL] from hamcrest . core . assert_that import assert_that [EOL] from hamcrest . core . core . isequal import equal_to [EOL] [EOL] from core_lib . core . models import Venue [EOL] from core_lib . core . repositories import VenueEntityTransformer [EOL] [EOL] [EOL] def test_to_entity ( valid_venue ) : [EOL] transformer = VenueEntityTransformer ( ) [EOL] entity = transformer . to_entity ( valid_venue ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . name ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . short_name ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . timezone ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . venue_id ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . phone ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . email ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . city ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . country ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . url ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . last_fetched_date ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_venue . search_terms ) ) [EOL] assert_that ( len ( entity ) , equal_to ( [number] ) ) [EOL] [EOL] [EOL] def test_from_entity ( valid_venue ) : [EOL] transformer = VenueEntityTransformer ( ) [EOL] entity = transformer . to_entity ( valid_venue ) [EOL] venue = transformer . to_venue ( entity ) [EOL] assert_that ( venue . name , equal_to ( valid_venue . name ) ) [EOL] assert_that ( venue . short_name , equal_to ( valid_venue . short_name ) ) [EOL] assert_that ( venue . timezone , equal_to ( valid_venue . timezone ) ) [EOL] assert_that ( venue . venue_id , equal_to ( valid_venue . venue_id ) ) [EOL] assert_that ( venue . phone , equal_to ( valid_venue . phone ) ) [EOL] assert_that ( venue . email , equal_to ( valid_venue . email ) ) [EOL] assert_that ( venue . city , equal_to ( valid_venue . city ) ) [EOL] assert_that ( venue . country , equal_to ( valid_venue . country ) ) [EOL] assert_that ( venue . url , equal_to ( valid_venue . url ) ) [EOL] assert_that ( venue . last_fetched_date , equal_to ( valid_venue . last_fetched_date ) ) [EOL] assert_that ( venue . search_terms , equal_to ( valid_venue . search_terms ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import core_lib [EOL] import typing [EOL] from datetime import datetime [EOL] [EOL] from hamcrest . core . assert_that import assert_that [EOL] from hamcrest . core . core . isequal import equal_to [EOL] import pytest [EOL] [EOL] from core_lib . core . models import Event [EOL] from core_lib . core . processing_chain import Chain , Link , OnlyValidEvents [EOL] [EOL] [EOL] class SinkMock ( Link ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . mocked = [ ] [EOL] [EOL] async def chain ( self , event ) : [EOL] print ( [string] ) [EOL] self . mocked . append ( event ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_valid_event ( valid_event ) : [EOL] sink = SinkMock ( ) [EOL] chain = Chain ( [ OnlyValidEvents ( ) , sink ] ) [EOL] await chain . start_chain ( [ valid_event ] ) [EOL] [EOL] assert_that ( len ( sink . mocked ) , equal_to ( [number] ) ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_invalid_event ( valid_event ) : [EOL] sink = SinkMock ( ) [EOL] chain = Chain ( [ OnlyValidEvents ( ) , sink ] ) [EOL] event = valid_event [EOL] event . when = datetime . min [EOL] await chain . start_chain ( [ event ] ) [EOL] assert_that ( len ( sink . mocked ) , equal_to ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core_lib.core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import core_lib [EOL] import typing [EOL] from hamcrest . core import assert_that , equal_to [EOL] [EOL] from core_lib . core . user_profile import UserProfileEntityTransformer , UserProfile [EOL] [EOL] [EOL] def test_transform_to_entity ( valid_user_profile ) : [EOL] entity = UserProfileEntityTransformer . as_entity ( valid_user_profile ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_user_profile . email ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_user_profile . given_name ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_user_profile . family_name ) ) [EOL] assert_that ( entity [ [string] ] , equal_to ( valid_user_profile . avatar_url ) ) [EOL] [EOL] [EOL] def test_entity_to ( valid_user_profile ) : [EOL] entity = UserProfileEntityTransformer . as_entity ( valid_user_profile ) [EOL] up = UserProfileEntityTransformer . from_entity ( entity ) [EOL] assert_that ( up . email , equal_to ( valid_user_profile . email ) ) [EOL] assert_that ( up . given_name , equal_to ( valid_user_profile . given_name ) ) [EOL] assert_that ( up . family_name , equal_to ( valid_user_profile . family_name ) ) [EOL] assert_that ( up . avatar_url , equal_to ( valid_user_profile . avatar_url ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import xml [EOL] import typing [EOL] from xml . etree import ElementTree [EOL] [EOL] from hamcrest import assert_that , equal_to [EOL] [EOL] from core_lib . core . rss import RSSItem [EOL] [EOL] [EOL] def test_as_xml ( ) : [EOL] rss_item = RSSItem ( title = [string] , link = [string] , description = [string] , author = [string] , guid = [string] , source = [string] , ) [EOL] root = ElementTree . fromstring ( rss_item . as_node ( ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import core_lib [EOL] import typing [EOL] from hamcrest import assert_that , equal_to , matches_regexp [EOL] [EOL] from core_lib . core . rss import Transformer [EOL] from core_lib . core . models import Event [EOL] [EOL] [EOL] def test_as_xml ( valid_event ) : [EOL] event = valid_event [EOL] rss_item = Transformer ( ) . item_to_rss ( event ) [EOL] assert_that ( rss_item . title , equal_to ( f"{ valid_event . title } [string] { valid_event . venue . short_name } [string] " ) ) [EOL] assert_that ( rss_item . author , equal_to ( valid_event . source ) ) [EOL] assert_that ( rss_item . guid , equal_to ( valid_event . url ) ) [EOL] assert_that ( rss_item . link , equal_to ( valid_event . url ) ) [EOL] description = rss_item . description [EOL] assert_that ( description , matches_regexp ( f" [string] { valid_event . description } [string] " ) ) [EOL] assert_that ( description , matches_regexp ( f' [string] { valid_event . venue . url } [string] { valid_event . venue . name } [string] { valid_event . venue . city } [string] { valid_event . venue . country } [string] ' ) , ) [EOL] assert_that ( description , matches_regexp ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import xml [EOL] import typing [EOL] from xml . etree import ElementTree [EOL] [EOL] from hamcrest import assert_that , equal_to , is_not , none [EOL] [EOL] from core_lib . core . rss import RSSChannel [EOL] [EOL] [EOL] def test_as_xml ( ) : [EOL] channel = RSSChannel ( ) [EOL] as_xml = channel . generate_pre_amble ( ) [EOL] assert_that ( as_xml , is_not ( none ( ) ) ) [EOL] root = ElementTree . fromstring ( as_xml ) [EOL] channel = root . findall ( [string] ) [EOL] assert_that ( len ( channel ) , equal_to ( [number] ) ) [EOL] assert_that ( channel [ [number] ] . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( len ( root . findall ( [string] ) ) , equal_to ( [number] ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( root . find ( [string] ) . text , is_not ( none ( ) ) ) [EOL] assert_that ( root . find ( [string] ) . text , is_not ( none ( ) ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL] assert_that ( root . find ( [string] ) . text , equal_to ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Any , List [EOL] import typing [EOL] import aiohttp [EOL] from aiohttp import ClientSession [EOL] from hamcrest import equal_to , is_not , none [EOL] from hamcrest . core import assert_that [EOL] import pytest [EOL] [EOL] from core_lib . core . fetcher_util import fetch [EOL] from core_lib . core . parser import ParsingContext [EOL] from core_lib . venues . spot_groningen import SpotParser , SpotProcessor [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_sample_file ( client_session ) : [EOL] venue = SpotProcessor . create_venue ( ) [EOL] data = await fetch ( session = client_session , url = venue . url ) [EOL] results = SpotParser ( ) . parse ( ParsingContext ( venue = venue , content = data ) ) [EOL] assert_that ( results , is_not ( none ( ) ) ) [EOL] assert_that ( len ( results ) , equal_to ( [number] ) ) [EOL] kamagurka = [ item for item in results if item . url == [string] ] [EOL] assert_that ( len ( kamagurka ) , equal_to ( [number] ) ) [EOL] assert_that ( kamagurka [ [number] ] . source , equal_to ( [string] ) ) [EOL] assert_that ( kamagurka [ [number] ] . description , equal_to ( [string] ) ) [EOL] assert_that ( kamagurka [ [number] ] . date_published , is_not ( none ( ) ) ) [EOL] assert_that ( kamagurka [ [number] ] . image_url , equal_to ( [string] [string] [string] ) , ) [EOL] assert_that ( kamagurka [ [number] ] . title , equal_to ( [string] ) ) [EOL] assert_that ( kamagurka [ [number] ] . when , is_not ( none ( ) ) ) [EOL] assert_that ( kamagurka [ [number] ] . url , equal_to ( [string] ) ) [EOL] assert_that ( kamagurka [ [number] ] . event_id , is_not ( none ( ) ) ) [EOL] assert_that ( kamagurka [ [number] ] . venue , equal_to ( venue ) ) [EOL] [EOL] for event in results : [EOL] assert_that ( event . when , is_not ( none ) ) [EOL] assert_that ( event . description , is_not ( none ) ) [EOL] assert_that ( event . title , is_not ( none ) ) [EOL] assert_that ( event . url , is_not ( none ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import core_lib [EOL] import typing [EOL] import aiohttp [EOL] from aiohttp import ClientSession [EOL] from hamcrest import equal_to [EOL] from hamcrest . core import assert_that [EOL] import pytest [EOL] [EOL] from core_lib . core . repositories import EventRepository [EOL] from core_lib . venues . spot_groningen import SpotProcessor [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_process_upserted_all_events ( client_session , spot_processor , mock_event_repository ) : [EOL] mock_event_repository . upsert_no_slicing . return_value = [ ] [EOL] mock_event_repository . fetch_all_keys_as_string_for_venue . return_value = [ ] [EOL] await spot_processor . fetch_new_events ( session = client_session ) [EOL] mock_event_repository . upsert_no_slicing . assert_called_once ( ) [EOL] args = mock_event_repository . upsert_no_slicing . call_args [ [number] ] [ [number] ] [EOL] assert_that ( len ( args ) , equal_to ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import core_lib [EOL] import typing [EOL] import aiohttp [EOL] from aiohttp import ClientSession [EOL] from hamcrest import equal_to [EOL] from hamcrest . core import assert_that [EOL] import pytest [EOL] [EOL] from core_lib . core . repositories import EventRepository [EOL] from core_lib . venues . t013_tilburg import T013Processor [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_process_upserted_all_events ( client_session , t013_processor , mock_event_repository ) : [EOL] mock_event_repository . upsert_no_slicing . return_value = [ ] [EOL] mock_event_repository . fetch_all_keys_as_string_for_venue . return_value = [ ] [EOL] await t013_processor . fetch_new_events ( session = client_session ) [EOL] mock_event_repository . upsert_no_slicing . assert_called_once ( ) [EOL] args = mock_event_repository . upsert_no_slicing . call_args [ [number] ] [ [number] ] [EOL] assert_that ( len ( args ) , equal_to ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] from aiohttp import ClientSession [EOL] from hamcrest import equal_to [EOL] from hamcrest . core import assert_that [EOL] import pytest [EOL] [EOL] from core_lib . venues . melkweg_amsterdam import MelkwegProcessor , MelkwegSource [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_sample_file ( client_session ) : [EOL] source = MelkwegSource ( MelkwegProcessor . create_venue ( ) ) [EOL] res = [number] [EOL] async for e in ( await source . fetch_events ( session = client_session ) ) : [EOL] res += len ( e ) [EOL] assert_that ( res , equal_to ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] from aiohttp import ClientSession [EOL] from hamcrest import equal_to , is_not , none [EOL] from hamcrest . core import assert_that [EOL] import pytest [EOL] [EOL] from core_lib . core . fetcher_util import fetch [EOL] from core_lib . core . parser import ParsingContext [EOL] from core_lib . venues . tivoli_utrecht import TivoliParser , TivoliProcessor [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_sample_file ( client_session ) : [EOL] venue = TivoliProcessor . create_venue ( ) [EOL] parser = TivoliParser ( ) [EOL] data = await fetch ( session = client_session , url = f"{ venue . url } [string] " ) [EOL] results = parser . parse ( ParsingContext ( venue = venue , content = data ) ) [EOL] assert_that ( len ( results ) , equal_to ( [number] ) ) [EOL] event = [ result for result in results if result . title == [string] ] [ [number] ] [EOL] [EOL] assert_that ( event . url , equal_to ( [string] ) ) [EOL] assert_that ( event . venue , equal_to ( venue ) ) [EOL] assert_that ( event . title , equal_to ( [string] ) ) [EOL] assert_that ( event . when , is_not ( none ( ) ) ) [EOL] assert_that ( event . image_url , equal_to ( [string] ) , ) [EOL] assert_that ( event . description , equal_to ( [string] ) ) [EOL] assert_that ( event . date_published , is_not ( none ( ) ) ) [EOL] assert_that ( event . source , equal_to ( [string] ) ) [EOL] [EOL] for event in results : [EOL] assert_that ( event . when , is_not ( none ) ) [EOL] assert_that ( event . description , is_not ( none ) ) [EOL] assert_that ( event . title , is_not ( none ) ) [EOL] assert_that ( event . url , is_not ( none ) ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_additional_event_data ( client_session ) : [EOL] venue = TivoliProcessor . create_venue ( ) [EOL] parser = TivoliParser ( ) [EOL] data = await fetch ( session = client_session , url = f"{ venue . url } [string] " ) [EOL] results = parser . parse ( ParsingContext ( venue = venue , content = data ) ) [EOL] assert_that ( len ( results ) , equal_to ( [number] ) ) [EOL] event = [ result for result in results if result . title == [string] ] [ [number] ] [EOL] assert_that ( event . when . hour , equal_to ( [number] ) ) [EOL] assert_that ( event . when . hour , equal_to ( [number] ) ) [EOL] event = parser . update_event_with_details ( event = event , additional_details = await fetch ( session = client_session , url = event . url ) ) [EOL] assert_that ( event . when . hour , equal_to ( [number] ) ) [EOL] assert_that ( event . when . minute , equal_to ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import base64 [EOL] [EOL] from hamcrest import equal_to [EOL] from hamcrest . core import assert_that [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_single_result ( client_session , api_url ) : [EOL] result = await client_session . get ( f"{ api_url } [string] " , params = { [string] : [string] } ) [EOL] assert_that ( result . status , equal_to ( [number] ) ) [EOL] json = await result . json ( ) [EOL] assert_that ( len ( json [ [string] ] ) , equal_to ( [number] ) ) [EOL] token = json [ [string] ] [EOL] assert_that ( base64 . decodebytes ( token . encode ( [string] ) ) . decode ( [string] ) , equal_to ( [string] ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test_none_result ( client_session , api_url ) : [EOL] result = await client_session . get ( f"{ api_url } [string] " , params = { [string] : [string] } ) [EOL] assert_that ( result . status , equal_to ( [number] ) ) [EOL] json = await result . json ( ) [EOL] assert_that ( len ( json [ [string] ] ) , equal_to ( [number] ) ) [EOL] token = json [ [string] ] [EOL] assert_that ( base64 . decodebytes ( token . encode ( [string] ) ) . decode ( [string] ) , equal_to ( [string] ) ) [EOL] [EOL] @ pytest . mark . asyncio async def test_paging_result ( client_session , api_url ) : [EOL] done = False [EOL] token = [string] [EOL] ite = [number] [EOL] tot_items = [number] [EOL] while not done : [EOL] result = await client_session . get ( f"{ api_url } [string] " , params = { [string] : [string] , [string] : token } ) [EOL] ite += [number] [EOL] assert_that ( result . status , equal_to ( [number] ) ) [EOL] json = await result . json ( ) [EOL] tot_items += len ( json [ [string] ] ) [EOL] token = json [ [string] ] [EOL] done = base64 . decodebytes ( token . encode ( [string] ) ) . decode ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import xml [EOL] import typing [EOL] from xml . etree import ElementTree [EOL] [EOL] from hamcrest import equal_to [EOL] from hamcrest . core import assert_that [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_events_xml ( client_session , api_url ) : [EOL] result = await client_session . get ( f"{ api_url } [string] " ) [EOL] assert_that ( result . status , equal_to ( [number] ) ) [EOL] root = ElementTree . fromstring ( await result . text ( ) ) [EOL] assert_that ( len ( root ) , equal_to ( [number] ) ) [EOL] assert_that ( root . tag , equal_to ( [string] ) ) [EOL] channel = root [ [number] ] [EOL] assert_that ( channel . tag , equal_to ( [string] ) ) [EOL] for child in channel : [EOL] if child . tag == [string] : [EOL] assert_that ( child . text , equal_to ( [string] ) ) [EOL] if child . tag == [string] : [EOL] assert_that ( child . text , equal_to ( [string] ) ) [EOL] if child . tag == [string] : [EOL] assert_that ( child . text , equal_to ( [string] ) ) [EOL] if child . tag == [string] : [EOL] assert_that ( child . text , equal_to ( [string] ) ) [EOL] if child . tag == [string] : [EOL] assert_that ( child . text , equal_to ( [string] ) ) [EOL] if child . tag == [string] : [EOL] assert_that ( child . text , equal_to ( [string] ) ) [EOL] if child . tag == [string] : [EOL] assert_that ( child . text , equal_to ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import base64 [EOL] [EOL] from hamcrest import equal_to , is_not [EOL] from hamcrest . core import assert_that [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_first_fetch ( client_session , api_url ) : [EOL] result = await client_session . get ( f"{ api_url } [string] " , params = { [string] : [string] } ) [EOL] assert_that ( result . status , equal_to ( [number] ) ) [EOL] json = await result . json ( ) [EOL] assert_that ( len ( json [ [string] ] ) , equal_to ( [number] ) ) [EOL] token = json [ [string] ] [EOL] assert_that ( base64 . decodebytes ( token . encode ( [string] ) ) . decode ( [string] ) , is_not ( equal_to ( [string] ) ) ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_paging ( client_session , api_url ) : [EOL] result = await client_session . get ( f"{ api_url } [string] " , params = { [string] : [string] } ) [EOL] assert_that ( result . status , equal_to ( [number] ) ) [EOL] json = await result . json ( ) [EOL] assert_that ( len ( json [ [string] ] ) , equal_to ( [number] ) ) [EOL] first_event_id = json [ [string] ] [ [number] ] [ [string] ] [EOL] token = json [ [string] ] [EOL] result = await client_session . get ( f"{ api_url } [string] " , params = { [string] : token } ) [EOL] assert_that ( result . status , equal_to ( [number] ) ) [EOL] json = await result . json ( ) [EOL] assert_that ( len ( json [ [string] ] ) , equal_to ( [number] ) ) [EOL] second_event_id = json [ [string] ] [ [number] ] [ [string] ] [EOL] assert_that ( first_event_id , is_not ( equal_to ( second_event_id ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import aiohttp [EOL] from aiohttp import ClientSession [EOL] from hamcrest import equal_to [EOL] from hamcrest . core import assert_that [EOL] import pytest [EOL] [EOL] [EOL] async def validate ( client_session , url ) : [EOL] response = await client_session . get ( url ) [EOL] assert_that ( response . status , equal_to ( [number] ) ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_events_xml ( client_session , api_url ) : [EOL] await validate ( client_session , f"{ api_url } [string] " ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_maintenance ( client_session , api_url ) : [EOL] await validate ( client_session , f"{ api_url } [string] " ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_maintenance_cron ( client_session , cron_url ) : [EOL] await validate ( client_session , f"{ cron_url } [string] " ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_api_events ( client_session , api_url ) : [EOL] await validate ( client_session , f"{ api_url } [string] " ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_api_events_today ( client_session , api_url ) : [EOL] await validate ( client_session , f"{ api_url } [string] " ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_api_events_tomorrow ( client_session , api_url ) : [EOL] await validate ( client_session , f"{ api_url } [string] " ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_api_venues ( client_session , api_url ) : [EOL] await validate ( client_session , f"{ api_url } [string] " ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_api_search ( client_session , api_url ) : [EOL] await validate ( client_session , f"{ api_url } [string] " ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_user_profile ( client_session , api_url ) : [EOL] response = await client_session . get ( f"{ api_url } [string] " ) [EOL] assert_that ( response . status , equal_to ( [number] ) ) [EOL] response = await client_session . post ( f"{ api_url } [string] " , json = { [string] : [string] , [string] : [string] , [string] : [string] } , ) [EOL] assert_that ( response . status , equal_to ( [number] ) ) [EOL] response = await client_session . post ( f"{ api_url } [string] " , json = { [string] : [string] , [string] : [string] , [string] : [string] } , ) [EOL] assert_that ( response . status , equal_to ( [number] ) ) [EOL] response = await client_session . get ( f"{ api_url } [string] " , headers = { [string] : [string] , [string] : [string] } , ) [EOL] assert_that ( response . status , equal_to ( [number] ) ) [EOL] response = await client_session . get ( f"{ api_url } [string] " , headers = { [string] : [string] , [string] : [string] } ) [EOL] assert_that ( response . status , equal_to ( [number] ) ) [EOL] response = await client_session . get ( f"{ api_url } [string] " , headers = { [string] : [string] , [string] : [string] } ) [EOL] assert_that ( response . status , equal_to ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import asyncio [EOL] import builtins [EOL] import typing [EOL] import aiohttp [EOL] import asyncio [EOL] import os [EOL] from time import sleep [EOL] [EOL] from aiohttp import ClientSession , ClientTimeout [EOL] import pytest [EOL] [EOL] API_URL = [string] [EOL] CRON_URL = [string] [EOL] [EOL] [EOL] async def with_url ( url , session ) : [EOL] number_of_tries = [number] [EOL] while number_of_tries < [number] : [EOL] try : [EOL] response = await session . get ( url ) [EOL] if response . status == [number] : [EOL] return [EOL] except Exception : [EOL] pass [EOL] sleep ( [number] ) [EOL] number_of_tries += [number] [EOL] [EOL] [EOL] async def clean_datastore ( session , cron_url ) : [EOL] url = f"{ cron_url } [string] " [EOL] response = await session . get ( url ) [EOL] if response . status > [number] : [EOL] raise Exception ( f" [string] { response }" ) [EOL] [EOL] [EOL] async def insert_default_in_datastore ( session , cron_url ) : [EOL] result = await session . get ( f"{ cron_url } [string] " ) [EOL] if result . status > [number] : [EOL] raise Exception ( f" [string] { result }" ) [EOL] [EOL] [EOL] async def init_integration_test ( session , cron_url , api_url ) : [EOL] await with_url ( f"{ cron_url } [string] " , session ) [EOL] await with_url ( f"{ api_url } [string] " , session ) [EOL] await clean_datastore ( session , cron_url ) [EOL] await insert_default_in_datastore ( session , cron_url ) [EOL] [EOL] [EOL] async def call_init ( cron_url , api_url ) : [EOL] timeout = ClientTimeout ( [number] ) [EOL] async with ClientSession ( timeout = timeout ) as session : [EOL] await asyncio . gather ( init_integration_test ( session , cron_url , api_url ) ) [EOL] [EOL] [EOL] @ pytest . fixture def event_loop ( ) : [EOL] [docstring] [EOL] loop = asyncio . new_event_loop ( ) [EOL] yield loop [EOL] loop . close ( ) [EOL] [EOL] [EOL] @ pytest . fixture def api_url ( ) : [EOL] return os . getenv ( [string] , API_URL ) [EOL] [EOL] [EOL] @ pytest . fixture def cron_url ( ) : [EOL] return os . getenv ( [string] , CRON_URL ) [EOL] [EOL] [EOL] @ pytest . fixture async def client_session ( event_loop ) : [EOL] timeout = ClientTimeout ( [number] ) [EOL] [comment] [EOL] a_client_session = ClientSession ( timeout = timeout , loop = event_loop ) [EOL] yield a_client_session [EOL] await a_client_session . close ( ) [EOL] [EOL] [EOL] def pytest_runtestloop ( session ) : [EOL] asyncio . run ( call_init ( api_url = os . getenv ( [string] , API_URL ) , cron_url = os . getenv ( [string] , CRON_URL ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
	0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any [EOL] import flask [EOL] import typing [EOL] import logging [EOL] from datetime import datetime , timedelta [EOL] from typing import Any [EOL] [EOL] from flask import Blueprint , Response [EOL] [EOL] from core_lib import application_data [EOL] from core_lib . application_data import event_repository , venue_repository [EOL] [EOL] MAINTENANCE_ROUTES = Blueprint ( [string] , __name__ , template_folder = [string] ) [EOL] CRON_ROUTES = Blueprint ( [string] , __name__ , template_folder = [string] ) [EOL] [EOL] [EOL] @ MAINTENANCE_ROUTES . route ( [string] ) def maintenance_ping ( ) : [EOL] return Response ( status = [number] ) [EOL] [EOL] [EOL] @ CRON_ROUTES . route ( [string] ) def maintenance_fetch_data ( ) : [EOL] application_data . sync_venues ( ) [EOL] return Response ( status = [number] ) [EOL] [EOL] [EOL] @ CRON_ROUTES . route ( [string] ) def maintenance_fetch_integration_test_data ( ) : [EOL] application_data . sync_integration_test_venues ( ) [EOL] return Response ( status = [number] ) [EOL] [EOL] [EOL] @ CRON_ROUTES . route ( [string] ) def maintenance_fetch_all_data ( ) : [EOL] application_data . sync_all_venues ( ) [EOL] return Response ( status = [number] ) [EOL] [EOL] [EOL] @ CRON_ROUTES . route ( [string] ) def maintenance_clean_up ( ) : [EOL] number_cleaned = event_repository . clean_items_before ( datetime . now ( ) - timedelta ( hours = [number] ) ) [EOL] logging . getLogger ( __name__ ) . info ( [string] , number_cleaned ) [EOL] return Response ( status = [number] ) [EOL] [EOL] [EOL] @ CRON_ROUTES . route ( [string] ) def maintenance_clean_up_all ( ) : [EOL] number_cleaned = event_repository . clean_items_before ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] for venue in venue_repository . fetch_all ( ) : [EOL] venue . last_fetched_date = datetime . min [EOL] venue_repository . upsert ( venue ) [EOL] logging . getLogger ( __name__ ) . info ( [string] , number_cleaned ) [EOL] return Response ( status = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import flask [EOL] from flask import Flask [EOL] [EOL] from cron . api import MAINTENANCE_ROUTES , CRON_ROUTES [EOL] from core_lib . core . app_config import AppConfig [EOL] [EOL] APP = Flask ( __name__ , static_folder = [string] , template_folder = [string] ) [EOL] [EOL] APP . register_blueprint ( CRON_ROUTES ) [EOL] APP . register_blueprint ( MAINTENANCE_ROUTES ) [EOL] [EOL] if __name__ == [string] : [EOL] APP . run ( host = [string] , port = AppConfig . get_port ( ) , debug = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from cron . __main__ . cron import __version__ [EOL] [EOL] [EOL] def test_version ( ) : [EOL] assert __version__ == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0