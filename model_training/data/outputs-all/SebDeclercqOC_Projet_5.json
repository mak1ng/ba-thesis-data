[comment] [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] import app [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import NoReturn , List , Dict , Optional , Any , Generator [EOL] import getopt [EOL] import sys [EOL] import os [EOL] from app import App , Params [EOL] [EOL] [EOL] def usage ( ) : [EOL] [docstring] [EOL] print ( [string] . join ( ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) ) ) [EOL] [EOL] [EOL] def parse_options ( ) : [EOL] [docstring] [EOL] params = { } [EOL] try : [EOL] options , args = getopt . getopt ( sys . argv [ [number] : ] , [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] except getopt . GetoptError as err : [EOL] print ( [string] % str ( err ) ) [EOL] usage ( ) [EOL] exit ( ) [EOL] modes = [ ] [EOL] for option , arg in options : [EOL] [comment] [EOL] if option == [string] : [EOL] params [ [string] ] = True [EOL] modes . append ( [string] ) [EOL] elif option == [string] : [EOL] params [ [string] ] = True [EOL] modes . append ( [string] ) [EOL] elif option in ( [string] , [string] ) : [EOL] params [ [string] ] = True [EOL] modes . append ( [string] ) [EOL] [comment] [EOL] elif option in ( [string] , [string] ) : [EOL] params [ [string] ] = arg [EOL] elif option in ( [string] , [string] ) : [EOL] params [ [string] ] = arg [EOL] elif option in ( [string] , [string] ) : [EOL] params [ [string] ] = arg [EOL] elif option == [string] : [EOL] params [ [string] ] = arg [EOL] elif option in ( [string] , [string] ) : [EOL] usage ( ) [EOL] exit ( ) [EOL] if len ( modes ) != [number] : [comment] [EOL] for mode in modes : [EOL] params [ mode ] = False [EOL] params [ [string] ] = True [comment] [EOL] return Params ( ** params ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] params = parse_options ( ) [EOL] app = App ( params ) [EOL] try : [EOL] app . run ( ) [EOL] except Exception as err : [EOL] print ( err ) [EOL] exit ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app.Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] from dataclasses import dataclass [EOL] from typing import List [EOL] [EOL] [EOL] @ dataclass class Product : [EOL] [docstring] [EOL] id = ... [EOL] name = ... [EOL] nutrition_grades = ... [EOL] url = ... [EOL] stores = ... [EOL] categories = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0
[comment] [EOL] from typing import Dict , Generator , Union , Set [EOL] import typing [EOL] import OpenFoodFacts [EOL] import requests [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Dict , Set , Union , Generator , Any , List , NoReturn [EOL] import dataclasses [EOL] import re [EOL] import requests [EOL] from OpenFoodFacts . Product import Product [EOL] [EOL] [EOL] class API : [EOL] [docstring] [EOL] BASE_URL = [string] [EOL] BASE_PARAMS = { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] USEFUL_FIELDS = { field . name for field in dataclasses . fields ( Product ) } [EOL] [EOL] def _get_products ( self , params ) : [EOL] [docstring] [EOL] r_params = self . BASE_PARAMS . copy ( ) [EOL] r_params . update ( params ) [EOL] r_result = requests . get ( self . BASE_URL , r_params ) [EOL] if r_result . status_code != requests . codes . ok : [EOL] r_result . raise_for_status ( ) [EOL] products = r_result . json ( ) [ [string] ] [EOL] for result in products : [EOL] result [ [string] ] = result . pop ( [string] ) [EOL] if self . _result_complete ( result ) : [comment] [EOL] for field in ( [string] , [string] ) : [EOL] result [ field ] = re . split ( [string] , result [ field ] . lower ( ) ) [EOL] product = Product ( ** { k : result [ k ] for k in self . USEFUL_FIELDS } ) [EOL] yield product [EOL] [EOL] def _result_complete ( self , result ) : [EOL] [docstring] [EOL] for field in self . USEFUL_FIELDS : [EOL] if field not in result or not result [ field ] : [EOL] return False [EOL] return True [EOL] [EOL] def search ( self , category , page_size = [number] ) : [EOL] [docstring] [EOL] return self . _get_products ( { [string] : category , [string] : page_size , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . API import API [EOL] from . Product import Product [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . App import App [EOL] from . Params import Params [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from dataclasses import dataclass [EOL] from typing import Optional [EOL] [EOL] [EOL] @ dataclass class Params : [EOL] [docstring] [EOL] setup_db = False [EOL] update_db = False [EOL] user = [string] [EOL] password = [string] [EOL] dbname = [string] [EOL] search = None [EOL] category = None [EOL] tag = None [EOL] categories_file = [string] [EOL] interactive = False [EOL] ui = [string] [EOL] [EOL] @ property def db_uri ( self ) : [EOL] [docstring] [EOL] if [string] in self . dbname : [EOL] return self . dbname [EOL] else : [EOL] return ( [string] % ( self . user , self . password , self . dbname ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Optional [EOL] import DB [EOL] import sqlalchemy [EOL] import typing [EOL] import db [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import NoReturn , List , Dict , Optional , Any , Generator , Union [EOL] from sqlalchemy . orm import Session , Query [EOL] from sqlalchemy . ext . declarative . api import DeclarativeMeta [EOL] from OpenFoodFacts import Product [EOL] from db . setup import ( Product as DBProduct , Store as DBStore , Category as DBCategory ) [EOL] [EOL] [EOL] class DB : [EOL] [docstring] [EOL] [EOL] base = ... [EOL] session = ... [EOL] Product = ... [EOL] Store = ... [EOL] Category = ... [EOL] [EOL] def __init__ ( self , base , session ) : [EOL] [docstring] [EOL] self . base = base [EOL] self . session = session [EOL] self . Product = DBProduct [EOL] self . Store = DBStore [EOL] self . Category = DBCategory [EOL] [EOL] def add ( self , product ) : [EOL] [docstring] [EOL] stores = self . _add_stores ( product . stores ) [EOL] categories = self . _add_categories ( product . categories ) [EOL] query = self . session . query ( self . Product ) [EOL] existing_product = query . filter ( self . Product . id == product . id ) . first ( ) [EOL] if existing_product : [comment] [EOL] new_product = self . _update_product ( existing_product , product , stores , categories ) [EOL] else : [comment] [EOL] new_product = self . _add_product ( product , stores , categories ) [EOL] try : [EOL] self . session . commit ( ) [EOL] return new_product [EOL] except Exception as err : [EOL] self . session . rollback ( ) [EOL] pass [EOL] [EOL] def _add_product ( self , product , stores , categories ) : [EOL] [docstring] [EOL] p = self . Product ( id = product . id , name = product . name , nutrition_grade = product . nutrition_grades , url = product . url , stores = stores , categories = categories ) [EOL] self . session . add ( p ) [EOL] return p [EOL] [EOL] def _add_stores ( self , store_names ) : [EOL] [docstring] [EOL] stores = [ ] [EOL] query = self . session . query ( self . Store ) [EOL] for store_name in store_names : [EOL] existing_store = query . filter ( self . Store . name == store_name ) . first ( ) [EOL] if not existing_store : [EOL] store = self . Store ( name = store_name ) [EOL] self . session . add ( store ) [EOL] stores . append ( store ) [EOL] else : [EOL] stores . append ( existing_store ) [EOL] return stores [EOL] [EOL] def _add_categories ( self , category_names ) : [EOL] [docstring] [EOL] categories = [ ] [EOL] query = self . session . query ( self . Category ) [EOL] for category_name in category_names : [EOL] existing_category = query . filter ( self . Category . name == category_name ) . first ( ) [EOL] if not existing_category : [EOL] category = self . Category ( name = category_name ) [EOL] self . session . add ( category ) [EOL] categories . append ( category ) [EOL] else : [EOL] categories . append ( existing_category ) [EOL] return categories [EOL] [EOL] def _update_product ( self , existing_product , product , stores , categories ) : [EOL] [docstring] [EOL] existing_product . id = product . id [EOL] existing_product . name = product . name [EOL] existing_product . nutrition_grade = product . nutrition_grades [EOL] existing_product . url = product . url [EOL] existing_product . stores = stores [EOL] existing_product . categories = categories [EOL] return existing_product [EOL] [EOL] def get_categories ( self ) : [EOL] [docstring] [EOL] return self . session . query ( self . Category ) [EOL] [EOL] def get_products_by_category ( self , category_id ) : [EOL] [docstring] [EOL] return self . session . query ( self . Category ) . filter ( self . Category . id == category_id ) . first ( ) . products [EOL] [EOL] def get_product_by_id ( self , product_id ) : [EOL] [docstring] [EOL] return self . session . query ( self . Product ) . filter ( self . Product . id == product_id ) . first ( ) [EOL] [EOL] def get_substitutes_for ( self , product_id ) : [EOL] [docstring] [EOL] product = self . get_product_by_id ( product_id ) [EOL] query = self . session . query ( self . Product ) . filter ( self . Product . nutrition_grade < product . nutrition_grade ) . filter ( self . Product . categories . any ( id = product . categories [ [number] ] . id ) ) . order_by ( self . Product . nutrition_grade , self . Product . name ) [EOL] return query . all ( ) [EOL] [EOL] def add_favorite ( self , substituted , substituter ) : [EOL] [docstring] [EOL] substituted . substituted_by . append ( substituter ) [EOL] substituter . substitutes . append ( substituted ) [EOL] self . session . commit ( ) [EOL] return [ substituted , substituter ] [EOL] [EOL] def get_favorite_products ( self ) : [EOL] [docstring] [EOL] return self . session . query ( self . Product ) . filter ( self . Product . substitutes . any ( self . Product . id ) ) . all ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.ext.declarative.api.DeclarativeMeta$ 0 0 0 $sqlalchemy.orm.Session$ 0 0 0 $sqlalchemy.ext.declarative.api.DeclarativeMeta$ 0 0 0 $sqlalchemy.ext.declarative.api.DeclarativeMeta$ 0 0 0 $sqlalchemy.ext.declarative.api.DeclarativeMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $db.setup.Product$ 0 0 0 $DB.Product$ 0 $typing.List[db.setup.Store]$ 0 $typing.List[db.setup.Category]$ 0 0 0 0 0 $db.setup.Product$ 0 0 0 0 0 0 0 $DB.Product$ 0 0 0 0 0 $DB.Product$ 0 0 0 0 0 $DB.Product$ 0 0 0 0 0 $DB.Product$ 0 0 0 $typing.List[db.setup.Store]$ 0 $typing.List[db.setup.Store]$ 0 $typing.List[db.setup.Category]$ 0 $typing.List[db.setup.Category]$ 0 0 0 0 0 0 0 0 $db.setup.Product$ 0 0 0 $db.setup.Product$ 0 0 0 $typing.List[db.setup.Store]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $sqlalchemy.orm.Query$ 0 0 0 0 0 $sqlalchemy.orm.Query$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Optional[db.setup.Store]$ 0 $sqlalchemy.orm.Query$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[db.setup.Store]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[db.setup.Store]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[db.setup.Category]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $sqlalchemy.orm.Query$ 0 0 0 0 0 $sqlalchemy.orm.Query$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Optional[db.setup.Category]$ 0 $sqlalchemy.orm.Query$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[db.setup.Category]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[db.setup.Category]$ 0 0 0 $typing.Any$ 0 0 0 $db.setup.Product$ 0 0 0 $db.setup.Product$ 0 $DB.Product$ 0 0 0 0 0 0 0 0 0 $db.setup.Product$ 0 0 0 $DB.Product$ 0 0 0 $db.setup.Product$ 0 0 0 $DB.Product$ 0 0 0 $db.setup.Product$ 0 0 0 $DB.Product$ 0 0 0 $db.setup.Product$ 0 0 0 $DB.Product$ 0 0 0 $db.setup.Product$ 0 0 0 0 0 $db.setup.Product$ 0 0 0 0 0 0 $db.setup.Product$ 0 0 0 $typing.List[db.setup.Category]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[db.setup.Product]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $db.setup.Product$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[db.setup.Product]$ 0 0 0 $builtins.int$ 0 0 0 0 0 $db.setup.Product$ 0 0 0 0 0 $builtins.int$ 0 0 $sqlalchemy.orm.Query$ 0 0 0 0 0 $sqlalchemy.orm.Query$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $db.setup.Product$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $db.setup.Product$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.orm.Query$ 0 0 0 0 0 0 0 $typing.List[db.setup.Product]$ 0 0 0 $db.setup.Product$ 0 $db.setup.Product$ 0 0 0 0 0 $db.setup.Product$ 0 0 0 0 0 $db.setup.Product$ 0 0 $db.setup.Product$ 0 0 0 0 0 $db.setup.Product$ 0 0 0 0 0 0 0 0 0 0 0 0 $db.setup.Product$ 0 $db.setup.Product$ 0 0 0 0 $typing.List[db.setup.Product]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . DB import DB [EOL] from db . setup import ( Product as DBProduct , Store as DBStore , Category as DBCategory ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Tuple [EOL] import typing [EOL] import sqlalchemy [EOL] import builtins [EOL] [docstring] [EOL] from sqlalchemy import ( Table , Column , Integer , BigInteger , ForeignKey , create_engine ) [EOL] from sqlalchemy . ext . declarative import declarative_base , DeclarativeMeta [EOL] from sqlalchemy . orm import sessionmaker , Session [EOL] from typing import Tuple [EOL] [EOL] [EOL] class repr_mixin : [EOL] [docstring] [EOL] def __repr__ ( self ) : [EOL] self . __dict__ . pop ( [string] ) [EOL] return str ( self . __dict__ ) [EOL] [EOL] [EOL] Base = declarative_base ( ) [comment] [EOL] [EOL] [EOL] def start_up ( _DB_URI ) : [EOL] [docstring] [EOL] engine = create_engine ( _DB_URI ) [EOL] Base . metadata . create_all ( engine ) [EOL] Session = sessionmaker ( bind = engine ) [EOL] return ( Base , Session ( ) ) [EOL] [EOL] [EOL] def remove_all ( _DB_URI ) : [EOL] [docstring] [EOL] engine = create_engine ( _DB_URI ) [EOL] Base . metadata . drop_all ( engine ) [EOL] [EOL] [EOL] [comment] [EOL] IsSoldAt = Table ( [string] , Base . metadata , Column ( [string] , BigInteger ( ) , ForeignKey ( [string] ) , nullable = False , primary_key = True ) , Column ( [string] , Integer ( ) , ForeignKey ( [string] ) , nullable = False , primary_key = True ) ) [EOL] [EOL] [comment] [EOL] HasCategory = Table ( [string] , Base . metadata , Column ( [string] , BigInteger ( ) , ForeignKey ( [string] ) , nullable = False , primary_key = True ) , Column ( [string] , Integer ( ) , ForeignKey ( [string] ) , nullable = False , primary_key = True ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] IsFavoriteSubstituteOf = Table ( [string] , Base . metadata , Column ( [string] , BigInteger ( ) , ForeignKey ( [string] ) , nullable = False , primary_key = True ) , Column ( [string] , BigInteger ( ) , ForeignKey ( [string] ) , nullable = False , primary_key = True ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from . Product import Product [EOL] from . Store import Store [EOL] from . Category import Category [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.ext.declarative.DeclarativeMeta$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[sqlalchemy.ext.declarative.DeclarativeMeta,sqlalchemy.orm.Session]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.ext.declarative.DeclarativeMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.ext.declarative.DeclarativeMeta$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.ext.declarative.DeclarativeMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.Table$ 0 0 0 0 0 $sqlalchemy.ext.declarative.DeclarativeMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.Table$ 0 0 0 0 0 $sqlalchemy.ext.declarative.DeclarativeMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlalchemy.Table$ 0 0 0 0 0 $sqlalchemy.ext.declarative.DeclarativeMeta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type [EOL] import typing [EOL] import db [EOL] [docstring] [EOL] from sqlalchemy import Column , Integer , String [EOL] from sqlalchemy . orm import relationship , backref [EOL] from db . setup import Base , HasCategory , repr_mixin [EOL] [EOL] [EOL] class Category ( Base , repr_mixin ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] [EOL] id = Column ( Integer ( ) , autoincrement = True , primary_key = True , nullable = False ) [EOL] name = Column ( String ( [number] ) , nullable = False , unique = True ) [EOL] products = relationship ( [string] , secondary = HasCategory , backref = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type [EOL] import typing [EOL] import db [EOL] [docstring] [EOL] from sqlalchemy import Column , BigInteger , String [EOL] from sqlalchemy . orm import relationship , backref [EOL] from db . setup import ( Base , IsSoldAt , HasCategory , IsFavoriteSubstituteOf , repr_mixin ) [EOL] [EOL] [EOL] class Product ( Base , repr_mixin ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] [EOL] id = Column ( BigInteger ( ) , nullable = False , primary_key = True ) [EOL] name = Column ( String ( [number] ) , nullable = False ) [EOL] nutrition_grade = Column ( String ( [number] ) , nullable = False ) [EOL] url = Column ( String ( [number] ) , nullable = False ) [EOL] stores = relationship ( [string] , secondary = IsSoldAt , backref = [string] ) [EOL] categories = relationship ( [string] , secondary = HasCategory , backref = [string] ) [EOL] substituted_by = relationship ( [string] , secondary = IsFavoriteSubstituteOf , primaryjoin = id == IsFavoriteSubstituteOf . c . substituted_product_id , secondaryjoin = id == IsFavoriteSubstituteOf . c . substitute_product_id , backref = [string] ) [EOL] substitutes = relationship ( [string] , secondary = IsFavoriteSubstituteOf , primaryjoin = id == IsFavoriteSubstituteOf . c . substitute_product_id , secondaryjoin = id == IsFavoriteSubstituteOf . c . substituted_product_id , backref = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type [EOL] import typing [EOL] import db [EOL] [docstring] [EOL] from sqlalchemy import Column , Integer , String [EOL] from sqlalchemy . orm import relationship , backref [EOL] from db . setup import Base , IsSoldAt , repr_mixin [EOL] [EOL] [EOL] class Store ( Base , repr_mixin ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] [EOL] id = Column ( Integer ( ) , autoincrement = True , primary_key = True , nullable = False ) [EOL] name = Column ( String ( [number] ) , nullable = False , unique = True ) [EOL] products = relationship ( [string] , secondary = IsSoldAt , backref = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import UI [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from . console import ConsoleUI [EOL] from . UI import UI [EOL] [EOL] [EOL] class UIFactory : [EOL] [docstring] [EOL] @ staticmethod def factory ( type ) : [EOL] [docstring] [EOL] type = type . lower ( ) [EOL] if type == [string] : [EOL] ui = ConsoleUI ( ) [EOL] else : [EOL] raise ValueError ( [string] % type ) [EOL] if not isinstance ( ui , UI ) : [EOL] raise TypeError ( [string] % type ) [EOL] else : [EOL] return ui [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import app [EOL] [docstring] [EOL] from abc import ABC , abstractmethod [EOL] from app import App [EOL] [EOL] [EOL] class UI ( ABC ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def start ( self , app ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $app.App$ 0 0 0 0 0 0 0
[comment] [EOL] from . UI import UI [EOL] from . UIFactory import UIFactory [EOL] from . console import ConsoleUI [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from . ConsoleUI import ConsoleUI [EOL]	0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Dict [EOL] import app [EOL] import Menu [EOL] import typing [EOL] import db [EOL] import builtins [EOL] [docstring] [EOL] from typing import NoReturn , List , Dict , Optional , Any , Union , Callable [EOL] import yaml [EOL] import os [EOL] import platform [EOL] from . . UI import UI [EOL] from . Menu import Menu , MenuEntry [EOL] from app import App [EOL] from db import DBCategory , DBProduct [EOL] [EOL] [EOL] class ConsoleUI ( UI ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] text_file = os . path . join ( [string] , [string] , [string] ) [EOL] with open ( text_file , encoding = [string] ) as f : [comment] [EOL] self . contents = yaml . load ( f ) [EOL] [EOL] def start ( self , app ) : [EOL] [docstring] [EOL] self . app = app [EOL] self . history = [ ] [EOL] print ( self . contents [ [string] ] ) [EOL] self . top_menu ( ) [EOL] [EOL] def quit ( self ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] exit ( ) [EOL] [EOL] def top_menu ( self ) : [EOL] [docstring] [EOL] self . history . clear ( ) [comment] [EOL] menu = Menu ( ) [EOL] menu . add ( [string] , self . category_list_menu ) [EOL] menu . add ( [string] , self . favorite_list_menu ) [EOL] self . interact ( menu ) [EOL] [EOL] def category_list_menu ( self ) : [EOL] [docstring] [EOL] print ( self . contents [ [string] ] ) [EOL] menu = Menu ( ) [EOL] for category in self . app . get_categories ( ) : [EOL] menu . add ( category . name . capitalize ( ) , self . product_list_menu , args = category . id ) [EOL] self . interact ( menu ) [EOL] [EOL] def favorite_list_menu ( self ) : [EOL] [docstring] [EOL] print ( self . contents [ [string] ] ) [EOL] menu = Menu ( ) [EOL] for favorite in self . app . get_favorite_products ( ) : [EOL] menu . add ( favorite . name . capitalize ( ) , self . favorite_page , args = favorite . id ) [EOL] self . interact ( menu ) [EOL] [EOL] def product_list_menu ( self , category_id ) : [EOL] [docstring] [EOL] print ( self . contents [ [string] ] ) [EOL] menu = Menu ( ) [EOL] for product in self . app . get_products ( category_id ) : [EOL] text_option = ( [string] % ( product . nutrition_grade . upper ( ) , product . name . capitalize ( ) ) ) [EOL] menu . add ( text_option , self . product_page , args = product . id ) [EOL] self . interact ( menu ) [EOL] [EOL] def product_page ( self , product_id ) : [EOL] [docstring] [EOL] product = self . app . get_product_details ( product_id ) [EOL] self . history . append ( product ) [comment] [EOL] print ( self . contents [ [string] ] % { [string] : product . id , [string] : product . name . capitalize ( ) , [string] : product . nutrition_grade . upper ( ) , [string] : [string] . join ( [ s . name for s in product . stores ] ) , [string] : product . url , } ) [EOL] menu = Menu ( ) [EOL] menu . add ( [string] , self . substitute_list_menu , args = product_id ) [EOL] menu . add ( [string] , self . save_to_favorite ) [EOL] self . interact ( menu ) [EOL] [EOL] def favorite_page ( self , product_id ) : [EOL] [docstring] [EOL] product = self . app . get_product_details ( product_id ) [EOL] print ( self . contents [ [string] ] % { [string] : product . id , [string] : product . name . capitalize ( ) , [string] : product . nutrition_grade . upper ( ) , [string] : [string] . join ( [ s . name for s in product . stores ] ) , [string] : product . url , [string] : [string] . join ( [ [string] + p . name + [string] + p . nutrition_grade . upper ( ) + [string] for p in product . substitutes ] ) , } ) [EOL] menu = Menu ( ) [EOL] self . interact ( menu ) [EOL] [EOL] def substitute_list_menu ( self , product_id ) : [EOL] print ( self . contents [ [string] ] ) [EOL] menu = Menu ( ) [EOL] for product in self . app . get_substitutes_for ( product_id ) : [EOL] text_option = ( [string] % ( product . nutrition_grade . upper ( ) , product . name . capitalize ( ) ) ) [EOL] menu . add ( text_option , self . product_page , args = product . id ) [EOL] if not menu . entries : [EOL] print ( [string] ) [EOL] self . interact ( menu ) [EOL] [EOL] def save_to_favorite ( self ) : [EOL] [docstring] [EOL] if not len ( self . history ) >= [number] : [EOL] print ( [string] [string] ) [EOL] previous_product_id = self . history . pop ( ) . id [EOL] self . product_page ( previous_product_id ) [EOL] favorites = self . app . add_favorite ( * self . history [ - [number] : ] ) [EOL] print ( self . contents [ [string] ] % { [string] : favorites [ [number] ] . name . capitalize ( ) , [string] : favorites [ [number] ] . name . capitalize ( ) , } ) [EOL] menu = Menu ( ) [EOL] self . interact ( menu ) [EOL] [EOL] def interact ( self , menu ) : [EOL] [docstring] [EOL] action = self . _get_next_action ( menu ) [EOL] if action . args : [EOL] action . handler ( action . args ) [EOL] else : [EOL] action . handler ( ) [EOL] [EOL] def _get_next_action ( self , menu ) : [EOL] [docstring] [EOL] menu . add ( [string] , self . top_menu , [number] ) [EOL] menu . add ( [string] , self . quit , [string] ) [EOL] while True : [EOL] for entry in menu . entries . values ( ) : [EOL] print ( entry ) [EOL] action = input ( [string] ) . lower ( ) . rstrip ( ) [EOL] if action in menu . entries : [EOL] return menu . entries [ action ] [EOL] else : [EOL] print ( f' [string] { action } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[db.DBProduct]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $db.DBProduct$ 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[db.DBProduct]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[db.DBProduct]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[db.DBProduct]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 $typing.Any$ 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 $Menu.MenuEntry$ 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 $Menu.MenuEntry$ 0 0 0 0 $Menu.MenuEntry$ 0 0 0 $Menu.MenuEntry$ 0 0 0 0 0 0 0 $Menu.MenuEntry$ 0 0 0 0 0 0 0 $Menu.MenuEntry$ 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $Menu.Menu.Menu$ 0 0 0 0 0 $Menu.Menu.Menu$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
[comment] [EOL] from typing import Callable , Any , Dict , Union , Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from __future__ import annotations [EOL] from dataclasses import dataclass , field [EOL] from typing import Optional , Dict , Callable , Union , Any [EOL] [EOL] [EOL] @ dataclass class MenuEntry : [EOL] [docstring] [EOL] id = ... [EOL] label = ... [EOL] handler = ... [EOL] args = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return f'{ self . id : [string] } [string] { self . label }' [EOL] [EOL] [EOL] @ dataclass class Menu : [EOL] [docstring] [EOL] counter = [number] [EOL] entries = field ( default_factory = dict ) [EOL] [EOL] def add ( self , label , handler , id = None , args = None ) : [EOL] [docstring] [EOL] if not id and id != [number] : [EOL] id = self . counter [EOL] self . counter += [number] [EOL] self . entries [ str ( id ) ] = MenuEntry ( str ( id ) , label , handler , args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Callable$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,MenuEntry]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Callable$ 0 $typing.Union[None,builtins.int,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.int,builtins.str]$ 0 $typing.Union[None,builtins.int,builtins.str]$ 0 0 0 0 $typing.Union[None,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 $typing.Union[None,builtins.int,builtins.str]$ 0 0 $builtins.str$ 0 $typing.Callable$ 0 $typing.Any$ 0 0