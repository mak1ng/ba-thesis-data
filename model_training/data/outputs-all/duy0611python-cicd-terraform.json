[comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import os [EOL] from setuptools import setup [EOL] [EOL] [comment] [EOL] about = { } [comment] [EOL] here = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] with open ( os . path . join ( here , [string] , [string] ) ) as f : [EOL] exec ( f . read ( ) , about ) [EOL] [EOL] [comment] [EOL] with open ( [string] , [string] ) as f : [EOL] readme = f . read ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] setup ( name = about [ [string] ] , description = about [ [string] ] , long_description = readme , long_description_content_type = [string] , version = about [ [string] ] , author = about [ [string] ] , author_email = about [ [string] ] , url = about [ [string] ] , packages = [ [string] ] , include_package_data = True , python_requires = [string] , install_requires = [ [string] , [string] ] , license = about [ [string] ] , zip_safe = False , entry_points = { [string] : [ [string] ] , } , classifiers = [ [string] , [string] , [string] , ] , keywords = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] __title__ = [string] [EOL] __description__ = [string] [EOL] __version__ = [string] [EOL] __author__ = [string] [EOL] __author_email__ = [string] [EOL] __license__ = [string] [EOL] __url__ = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Optional , Any , TypeVar , Tuple , Sequence , Dict , List [EOL] import builtins [EOL] import typing [EOL] import example [EOL] [docstring] [EOL] [EOL] import abc [EOL] from dataclasses import dataclass [EOL] from typing import Dict , Optional , Sequence , Tuple , TypeVar [EOL] [EOL] import numpy as np [comment] [EOL] [EOL] [EOL] class SupplyCurve : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data ) : [EOL] data_price_ord = sorted ( data , key = lambda e : e [ [string] ] ) [EOL] [EOL] if data_price_ord [ [number] ] [ [string] ] == [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] for n , e in enumerate ( data_price_ord [ [number] : ] ) : [EOL] current_point = e [ [string] ] [EOL] previous_point = data_price_ord [ n ] [ [string] ] [EOL] if current_point < previous_point : [EOL] raise SupplyMonotonicityError [EOL] [EOL] self . _price = np . array ( [ d [ [string] ] for d in data_price_ord ] ) [EOL] self . _quantity = np . array ( [ d [ [string] ] for d in data_price_ord ] ) [EOL] self . _min_price = self . _price . min ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if ( np . all ( self . _price == other . _price ) [EOL] and np . all ( self . _quantity == other . _quantity ) ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] def quantity ( self , price ) : [EOL] [docstring] [EOL] [EOL] if price < self . _min_price : [EOL] quantity_at_price = [number] [EOL] else : [EOL] quantity_at_price = self . _quantity [ self . _price <= price ] [ - [number] ] [EOL] return quantity_at_price [EOL] [EOL] [EOL] class DemandCurve : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data ) : [EOL] data_price_ord = sorted ( data , key = lambda e : e [ [string] ] ) [EOL] [EOL] if data_price_ord [ [number] ] [ [string] ] == [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] for n , e in enumerate ( data_price_ord [ [number] : ] ) : [EOL] current_point = e [ [string] ] [EOL] previous_point = data_price_ord [ n ] [ [string] ] [EOL] if current_point > previous_point : [EOL] raise DemandMonotonicityError [EOL] [EOL] self . _price = np . array ( [ d [ [string] ] for d in data_price_ord ] ) [EOL] self . _quantity = np . array ( [ d [ [string] ] for d in data_price_ord ] ) [EOL] self . _max_price = self . _price . max ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if ( np . all ( self . _price == other . _price ) [EOL] and np . all ( self . _quantity == other . _quantity ) ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] def quantity ( self , price ) : [EOL] [docstring] [EOL] [EOL] if price > self . _max_price : [EOL] quantity_at_price = [number] [EOL] else : [EOL] quantity_at_price = self . _quantity [ self . _price >= price ] [ [number] ] [EOL] return quantity_at_price [EOL] [EOL] [EOL] class SupplyMonotonicityError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] message = [string] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] class DemandMonotonicityError ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] message = [string] [EOL] super ( ) . __init__ ( message ) [EOL] [EOL] [EOL] def equil_price ( s , d ) : [EOL] [docstring] [EOL] [EOL] price_domain = np . unique ( np . hstack ( [ np . zeros ( [number] ) , s . _price , d . _price ] ) ) [EOL] demand_gte_supply = [ d . quantity ( p ) >= s . quantity ( p ) for p in price_domain ] [EOL] if any ( demand_gte_supply ) : [EOL] return price_domain [ demand_gte_supply ] . max ( ) [EOL] else : [EOL] return None [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class PriceRanges : [EOL] [docstring] [EOL] [EOL] supply = ... [EOL] demand = ... [EOL] [EOL] [EOL] def equil_price_ranges ( s , d ) : [EOL] [docstring] [EOL] [EOL] price_domain = np . unique ( np . hstack ( [ np . zeros ( [number] ) , s . _price , d . _price ] ) ) [EOL] equilibrium = equil_price ( s , d ) [EOL] if equilibrium : [EOL] prices_below_equil = price_domain [ price_domain < equilibrium ] [EOL] if len ( prices_below_equil ) > [number] : [EOL] supply_range = ( prices_below_equil [ - [number] ] , equilibrium ) [EOL] else : [EOL] supply_range = ( None , equilibrium ) [EOL] [EOL] prices_above_equil = price_domain [ price_domain > equilibrium ] [EOL] if len ( prices_above_equil ) > [number] : [EOL] demand_range = ( equilibrium , prices_above_equil [ [number] ] ) [EOL] else : [EOL] demand_range = ( equilibrium , None ) [EOL] [EOL] return PriceRanges ( supply_range , demand_range ) [EOL] [EOL] else : [EOL] return PriceRanges ( ( None , None ) , ( None , None ) ) [EOL] [EOL] [EOL] Curve = TypeVar ( [string] , SupplyCurve , DemandCurve ) [EOL] [docstring] [EOL] [EOL] [EOL] class Equilibrium : [EOL] [docstring] [EOL] [EOL] price = ... [EOL] price_ranges = ... [EOL] supply_q = ... [EOL] demand_q = ... [EOL] [EOL] def __init__ ( self , supply_curve , demand_curve ) : [EOL] eq_price_ranges = equil_price_ranges ( supply_curve , demand_curve ) [EOL] eq_price = eq_price_ranges . demand [ [number] ] [EOL] self . price = eq_price [EOL] self . price_ranges = eq_price_ranges [EOL] self . supply_q = supply_curve . quantity ( eq_price ) if eq_price else None [EOL] self . demand_q = demand_curve . quantity ( eq_price ) if eq_price else None [EOL] [EOL] def __eq__ ( self , other ) : [EOL] criteria = ( ( self . price == other . price ) [EOL] and ( self . supply_q == other . supply_q ) [EOL] and ( self . demand_q == other . demand_q ) ) [EOL] if criteria : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] class EconShockScenario ( metaclass = abc . ABCMeta ) : [EOL] [docstring] [EOL] [EOL] supply_shock = ... [EOL] demand_shock = ... [EOL] [EOL] def __init__ ( self , supply_shock = [number] , demand_shock = [number] ) : [EOL] self . supply_shock = supply_shock [EOL] self . demand_shock = demand_shock [EOL] [EOL] def __repr__ ( self ) : [EOL] class_name = type ( self ) . __name__ [EOL] ss = self . supply_shock [EOL] ds = self . demand_shock [EOL] return f'{ class_name } [string] { ss } [string] { ds } [string] ' [EOL] [EOL] @ abc . abstractmethod def apply ( self , curve ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class NoneShock ( EconShockScenario ) : [EOL] [docstring] [EOL] [EOL] def apply ( self , curve ) : [EOL] return curve [EOL] [EOL] [EOL] none_shock = NoneShock ( ) [EOL] [EOL] [EOL] class HorizPriceShock ( EconShockScenario ) : [EOL] [docstring] [EOL] [EOL] def apply ( self , curve ) : [EOL] if isinstance ( curve , SupplyCurve ) : [EOL] return SupplyCurve ( [ { [string] : price + self . supply_shock , [string] : quantity } for price , quantity in zip ( curve . _price , curve . _quantity ) ] ) [EOL] elif isinstance ( curve , DemandCurve ) : [EOL] return DemandCurve ( [ { [string] : price + self . demand_shock , [string] : quantity } for price , quantity in zip ( curve . _price , curve . _quantity ) ] ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.float],typing.Optional[builtins.float]]$ 0 0 0 $typing.Tuple[typing.Optional[builtins.float],typing.Optional[builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $PriceRanges$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import py_pkg [EOL] [docstring] [EOL] [EOL] import json [EOL] from typing import Any , Dict , List [EOL] [EOL] import pytest [EOL] [EOL] from py_pkg . curves import SupplyCurve , DemandCurve [EOL] [EOL] [EOL] def load_test_data ( ) : [EOL] [docstring] [EOL] [EOL] config_file_path = [string] [EOL] with open ( config_file_path ) as file : [EOL] json_data = file . read ( ) [EOL] [EOL] data = json . loads ( json_data ) [EOL] return data [ [string] ] [EOL] [EOL] [EOL] @ pytest . fixture def supply_curve ( ) : [EOL] [docstring] [EOL] [EOL] supply_demand_data = load_test_data ( ) [EOL] return SupplyCurve ( supply_demand_data ) [EOL] [EOL] [EOL] @ pytest . fixture def demand_curve ( ) : [EOL] [docstring] [EOL] [EOL] supply_demand_data = load_test_data ( ) [EOL] return DemandCurve ( supply_demand_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import py_pkg [EOL] [docstring] [EOL] [EOL] from copy import deepcopy [EOL] [EOL] import pytest [EOL] [EOL] from py_pkg . curves import ( SupplyCurve , DemandCurve , Equilibrium , SupplyMonotonicityError , DemandMonotonicityError , equil_price , equil_price_ranges , HorizPriceShock , PriceRanges ) [EOL] [EOL] [EOL] class TestSupplyCurve : [EOL] [docstring] [EOL] [EOL] def test_curve_comparison ( self , supply_curve ) : [EOL] [docstring] [EOL] assert supply_curve == deepcopy ( supply_curve ) [EOL] [EOL] def test_curve_points ( self , supply_curve ) : [EOL] [docstring] [EOL] price = [number] [EOL] quantity = [number] [EOL] assert supply_curve . quantity ( price ) == quantity [EOL] [EOL] def test_curve_interpolation ( self , supply_curve ) : [EOL] [docstring] [EOL] price = [number] [EOL] quantity = [number] [EOL] assert supply_curve . quantity ( price ) == quantity [EOL] [EOL] def test_curve_extrapolation_from_above ( self , supply_curve ) : [EOL] [docstring] [EOL] price = [number] [EOL] quantity = [number] [EOL] assert supply_curve . quantity ( price ) == quantity [EOL] [EOL] def test_curve_extrapolation_from_below ( self , supply_curve ) : [EOL] [docstring] [EOL] price = [number] [EOL] quantity = [number] [EOL] assert supply_curve . quantity ( price ) == quantity [EOL] [EOL] def test_curve_raises_monotonicity_exception ( self ) : [EOL] [docstring] [EOL] supply_data = [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] [EOL] [EOL] with pytest . raises ( SupplyMonotonicityError ) : [EOL] SupplyCurve ( supply_data ) [EOL] [EOL] def test_curve_raises_zero_price_exception ( self ) : [EOL] [docstring] [EOL] supply_data = [ { [string] : [number] , [string] : [number] } ] [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] SupplyCurve ( supply_data ) [EOL] [EOL] [EOL] class TestDemandCurve : [EOL] [docstring] [EOL] [EOL] def test_curve_comparison ( self , demand_curve ) : [EOL] [docstring] [EOL] assert demand_curve == deepcopy ( demand_curve ) [EOL] [EOL] def test_curve_points ( self , demand_curve ) : [EOL] [docstring] [EOL] price = [number] [EOL] quantity = [number] [EOL] assert demand_curve . quantity ( price ) == quantity [EOL] [EOL] def test_curve_interpolation ( self , demand_curve ) : [EOL] [docstring] [EOL] price = [number] [EOL] quantity = [number] [EOL] assert demand_curve . quantity ( price ) == quantity [EOL] [EOL] def test_curve_extrapolation_from_above ( self , demand_curve ) : [EOL] [docstring] [EOL] price = [number] [EOL] quantity = [number] [EOL] assert demand_curve . quantity ( price ) == quantity [EOL] [EOL] def test_curve_extrapolation_from_below ( self , demand_curve ) : [EOL] [docstring] [EOL] price = [number] [EOL] quantity = [number] [EOL] assert demand_curve . quantity ( price ) == quantity [EOL] [EOL] def test_curve_raises_monotonicity_exception ( self ) : [EOL] [docstring] [EOL] demand_data = [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] [EOL] [EOL] with pytest . raises ( DemandMonotonicityError ) : [EOL] DemandCurve ( demand_data ) [EOL] [EOL] def test_curve_raises_zero_price_exception ( self ) : [EOL] [docstring] [EOL] demand_data = [ { [string] : [number] , [string] : [number] } ] [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] DemandCurve ( demand_data ) [EOL] [EOL] [EOL] class TestCurveAnalytics : [EOL] [docstring] [EOL] [EOL] def test_equilibrium_price ( self , supply_curve , demand_curve ) : [EOL] [docstring] [EOL] assert equil_price ( supply_curve , demand_curve ) == [number] [EOL] [EOL] def test_equilibrium_price_ranges ( self , supply_curve , demand_curve ) : [EOL] [docstring] [EOL] assert ( equil_price_ranges ( supply_curve , demand_curve ) == PriceRanges ( ( [number] , [number] ) , ( [number] , [number] ) ) ) [EOL] [EOL] def test_horiz_supply_shock ( self , supply_curve ) : [EOL] [docstring] [EOL] econ_shock = HorizPriceShock ( supply_shock = [number] ) [EOL] shifted_supply_curve = econ_shock . apply ( supply_curve ) [EOL] price_diffs = shifted_supply_curve . _price - supply_curve . _price [EOL] assert price_diffs == pytest . approx ( econ_shock . supply_shock ) [EOL] assert isinstance ( shifted_supply_curve , SupplyCurve ) [EOL] [EOL] def test_horiz_demand_shock ( self , demand_curve ) : [EOL] [docstring] [EOL] econ_shock = HorizPriceShock ( demand_shock = [number] ) [EOL] shifted_demand_curve = econ_shock . apply ( demand_curve ) [EOL] price_diffs = shifted_demand_curve . _price - demand_curve . _price [EOL] assert price_diffs == pytest . approx ( econ_shock . demand_shock ) [EOL] assert isinstance ( shifted_demand_curve , DemandCurve ) [EOL] [EOL] def test_equilibrium ( self , supply_curve , demand_curve ) : [EOL] [docstring] [EOL] equilibrium = Equilibrium ( supply_curve , demand_curve ) [EOL] assert equilibrium . price == [number] [EOL] assert ( equilibrium . price_ranges == PriceRanges ( ( [number] , [number] ) , ( [number] , [number] ) ) ) [EOL] assert equilibrium . supply_q == [number] [EOL] assert equilibrium . demand_q == [number] [EOL] [EOL] def test_equilibrium_comparison ( self , supply_curve , demand_curve ) : [EOL] [docstring] [EOL] assert ( Equilibrium ( supply_curve , demand_curve ) == Equilibrium ( supply_curve , demand_curve ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $py_pkg.curves.SupplyCurve$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 $typing.Any$ 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $py_pkg.curves.DemandCurve$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 0 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $py_pkg.curves.DemandCurve$ 0 0 0 0 $py_pkg.curves.SupplyCurve$ 0 $py_pkg.curves.DemandCurve$ 0 0 0