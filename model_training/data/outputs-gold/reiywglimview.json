from typing import List , Tuple , Any [EOL] import glimview [EOL] import typing [EOL] import flask [EOL] import os [EOL] [EOL] import numpy as np [EOL] from flask import Flask , jsonify , render_template , request , send_from_directory [EOL] from flask_cors import CORS [EOL] [EOL] from glimview . ModelKB import Model [EOL] [EOL] app = Flask ( __name__ , static_url_path = [string] , static_folder = [string] , template_folder = [string] ) [EOL] app . config . from_mapping ( MODEL = Model ( os . environ [ [string] ] , os . environ [ [string] ] , os . environ [ [string] ] , os . environ [ [string] ] , ) ) [EOL] CORS ( app , resources = { [string] : { [string] : [string] } } ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def get_entities ( ) : [EOL] return jsonify ( app . config [ [string] ] . list_word ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def get_relations ( ) : [EOL] return jsonify ( app . config [ [string] ] . list_role ) [EOL] [EOL] [EOL] @ app . route ( [string] , methods = [ [string] ] ) def query ( ) : [EOL] model = app . config [ [string] ] [EOL] triples = [ ( tri [ [string] ] , tri [ [string] ] , tri [ [string] ] ) for tri in request . json ] [EOL] vec = model . calc_phrase_from_triples ( triples ) [EOL] targets = model . list_word [EOL] sims = model . tvecs . dot ( vec ) [EOL] if model . sim_with_path : [EOL] path_sims = model . path_vecs . dot ( vec ) [EOL] sims = np . hstack ( ( sims , path_sims ) ) [EOL] targets . extend ( model . paths ) [EOL] top_inds = np . argpartition ( sims , - [number] ) [ - [number] : ] [EOL] most_similar = sorted ( [ ( sims [ i ] , targets [ i ] ) for i in top_inds ] , reverse = True ) [EOL] return jsonify ( [ dict ( target = tgt , similarity = sim ) for sim , tgt in most_similar ] ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def hello ( ) : [EOL] return render_template ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from __future__ import absolute_import , division , print_function [EOL] [EOL] import heapq [EOL] import sys [EOL] [EOL] import six [EOL] [EOL] [EOL] def readerLine ( fn ) : [EOL] with open ( fn , [string] ) as file : [EOL] for line in file : [EOL] yield line . decode ( [string] ) . rstrip ( [string] ) [EOL] [EOL] [EOL] def show_top ( k , scores , lst ) : [EOL] h = [ ] [EOL] for i , s in enumerate ( scores ) : [EOL] heapq . heappush ( h , ( s , - i ) ) [EOL] if len ( h ) > k : [EOL] heapq . heappop ( h ) [EOL] num = len ( h ) [EOL] res = [ heapq . heappop ( h ) for _ in six . moves . range ( num ) ] [EOL] for s , ii in res [ : : - [number] ] : [EOL] print ( [string] + str ( s ) + [string] + lst [ - ii ] ) [EOL] [EOL] [EOL] def split_wrt_brackets ( str , sp ) : [EOL] blocks = [ ] [EOL] part = [ ] [EOL] count = [number] [EOL] for x in str : [EOL] if count == [number] and x in sp : [EOL] blocks . append ( [string] . join ( part ) ) [EOL] part = [ ] [EOL] else : [EOL] part . append ( x ) [EOL] if x == [string] : [EOL] count += [number] [EOL] elif x == [string] : [EOL] count -= [number] [EOL] if count < [number] : [EOL] print ( [string] , file = sys . stderr ) [EOL] blocks . append ( [string] . join ( part ) ) [EOL] return blocks [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] import builtins [EOL] from itertools import islice [EOL] from functools import partial [EOL] from typing import List [EOL] [EOL] def take ( n , iterable ) : [EOL] [docstring] [EOL] return list ( islice ( iterable , n ) ) [EOL] [EOL] def chunked ( iterable , n ) : [EOL] return iter ( partial ( take , n , iter ( iterable ) ) , [ ] ) [EOL] [EOL] def build_path_expr ( path ) : [EOL] expr = path [ [number] ] [EOL] for rel , ent in chunked ( path [ [number] : ] , [number] ) : [EOL] [comment] [EOL] expr = f' [string] { expr } [string] { rel } [string] { ent }' [EOL] return expr	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Union , Any [EOL] import builtins [EOL] import typing [EOL] import numpy [EOL] from __future__ import absolute_import , division , print_function [EOL] [EOL] import json [EOL] import os [EOL] import sys [EOL] import warnings [EOL] from typing import List , Union [EOL] [EOL] import numpy as np [EOL] [EOL] from . utilityFuncs import readerLine , show_top , split_wrt_brackets [EOL] from . util import build_path_expr , chunked [EOL] [EOL] [EOL] class Model ( object ) : [EOL] def __init__ ( self , words , roles , path , path_file ) : [EOL] [comment] [EOL] self . list_word = [ line . split ( [string] , [number] ) [ [number] ] for line in readerLine ( words ) ] [EOL] self . dict_word = dict ( ( s , i ) for i , s in enumerate ( self . list_word ) ) [EOL] [EOL] list_role_pre = [ line . split ( [string] , [number] ) [ [number] ] for line in readerLine ( roles ) ] [EOL] self . list_role = [ x + [string] for x in list_role_pre ] + [ x + [string] for x in list_role_pre ] [EOL] [EOL] self . dict_role = dict ( ( s , i ) for i , s in enumerate ( self . list_role ) ) [EOL] [EOL] [comment] [EOL] if os . path . exists ( path + [string] ) : [EOL] tvecs = np . load ( path + [string] ) [EOL] else : [EOL] tvecs = np . loadtxt ( path + [string] ) [EOL] np . save ( path + [string] , tvecs ) [EOL] tvecs /= np . sqrt ( np . sum ( np . square ( tvecs ) , axis = [number] , keepdims = True ) ) [EOL] dim = tvecs . shape [ [number] ] [EOL] [EOL] if os . path . exists ( path + [string] ) : [EOL] cvecs = np . load ( path + [string] ) [EOL] else : [EOL] cvecs = np . loadtxt ( path + [string] ) [EOL] np . save ( path + [string] , cvecs ) [EOL] with open ( path + [string] ) as params_file : [EOL] params = json . load ( params_file ) [EOL] cvecs /= np . expand_dims ( [number] + np . loadtxt ( path + [string] ) . astype ( [string] ) [ : cvecs . shape [ [number] ] ] * params [ [string] ] , axis = [number] , ) [EOL] [EOL] if os . path . exists ( path + [string] ) : [EOL] mats = np . load ( path + [string] ) [EOL] else : [EOL] [comment] [EOL] mats = np . loadtxt ( path + [string] ) . reshape ( - [number] , params [ [string] ] , params [ [string] ] ) [EOL] np . save ( path + [string] , mats ) [EOL] mats *= np . sqrt ( dim / np . sum ( np . square ( mats ) , axis = ( [number] , [number] ) , keepdims = True ) ) [EOL] [EOL] self . tvecs = tvecs [EOL] self . dim = dim [EOL] self . mats = mats [EOL] self . cvecs = cvecs [EOL] denc_scal = [number] / ( [number] + np . loadtxt ( path + [string] ) . astype ( [string] ) * params [ [string] ] ) [EOL] [EOL] if os . path . exists ( path + [string] ) : [EOL] self . encoder = ( np . load ( path + [string] ) . reshape ( ( - [number] , dim * dim ) ) * denc_scal ) [EOL] else : [EOL] enc = np . loadtxt ( path + [string] ) [EOL] np . save ( path + [string] , enc ) [EOL] self . encoder = enc . reshape ( ( - [number] , dim * dim ) ) * denc_scal [EOL] [EOL] if os . path . exists ( path + [string] ) : [EOL] self . decoder = ( np . load ( path + [string] ) . reshape ( ( - [number] , dim * dim ) ) * denc_scal ) [EOL] else : [EOL] dec = np . loadtxt ( path + [string] ) [EOL] np . save ( path + [string] , dec ) [EOL] self . decoder = dec . reshape ( ( - [number] , dim * dim ) ) * denc_scal [EOL] [EOL] self . msteps = np . loadtxt ( path + [string] , dtype = np . uint ) [EOL] [EOL] if os . path . exists ( path_file ) : [EOL] paths = [ ] [EOL] path_vecs = [ ] [EOL] for path_repr in open ( path_file ) : [EOL] path_repr = path_repr . rstrip ( [string] ) [EOL] paths . append ( path_repr ) [EOL] vec = self . calc_phrase_from_path_with_entities ( path_repr . split ( [string] ) ) [EOL] path_vecs . append ( vec ) [EOL] self . paths = paths [EOL] self . path_vecs = np . asarray ( path_vecs ) [EOL] self . sim_with_path = True [EOL] else : [EOL] self . sim_with_path = False [EOL] [EOL] print ( [string] . format ( len ( list_role_pre ) , len ( self . list_word ) ) , file = sys . stderr , ) [EOL] [EOL] def get_word_vector ( self , word , backoff_to_zero_vector = False ) : [EOL] if backoff_to_zero_vector and word not in self . dict_word : [EOL] return np . zeros ( self . dim ) [EOL] else : [EOL] return self . tvecs [ self . dict_word [ word ] ] [EOL] [EOL] def get_relation_matrix ( self , role , backoff_to_identity_matrix = False ) : [EOL] if not role . endswith ( [string] ) and not role . endswith ( [string] ) : [EOL] raise ValueError ( f' [string] { role }' ) [EOL] [EOL] if backoff_to_identity_matrix and role not in self . dict_role : [EOL] return np . identity ( self . dim ) [EOL] else : [EOL] return self . mats [ self . dict_role [ role ] ] [EOL] [EOL] def trans ( self , v , m ) : [EOL] v = m . dot ( v ) [EOL] v /= np . sqrt ( np . sum ( np . square ( v ) ) ) [EOL] return v [EOL] [EOL] def calc ( self , expr , addition_symbol = [string] ) : [EOL] tosum = [ ] [EOL] for pre in split_wrt_brackets ( expr , addition_symbol ) : [EOL] s = pre . strip ( ) [EOL] if s . startswith ( [string] ) and s . endswith ( [string] ) : [EOL] ss , r = s [ len ( [string] ) : - len ( [string] ) ] . rsplit ( [string] , [number] ) [EOL] tosum . append ( self . trans ( self . calc ( ss ) , self . get_relation_matrix ( r ) ) ) [EOL] elif s . startswith ( [string] ) and s . endswith ( [string] ) : [EOL] tosum . append ( self . calc ( s [ [number] : - [number] ] ) ) [EOL] else : [EOL] tosum . append ( self . get_word_vector ( s ) ) [EOL] ret = np . sum ( tosum , axis = [number] ) [EOL] ret /= np . sqrt ( np . sum ( np . square ( ret ) ) ) [EOL] return ret [EOL] [EOL] def show_v ( self , v , k ) : [EOL] tsim = self . tvecs . dot ( v ) [EOL] print ( [string] ) [EOL] show_top ( k , tsim , self . list_word ) [EOL] print ( ) [EOL] csim = self . cvecs . dot ( v ) [EOL] print ( [string] ) [EOL] show_top ( k , csim , self . list_word ) [EOL] print ( ) [EOL] [EOL] def show_m ( self , r , k ) : [EOL] prj = self . mats [ self . dict_role [ r ] ] [EOL] [EOL] def calc_deform ( x ) : [EOL] mean = x . trace ( ) / self . dim [EOL] y = x - np . diagflat ( np . full ( self . dim , mean , dtype = np . float32 ) ) [EOL] return np . sqrt ( np . sum ( np . square ( y ) ) ) , mean [EOL] [EOL] p_dfm , p_mtr = calc_deform ( prj ) [EOL] prj_dfm = calc_deform ( np . dot ( prj , prj . T ) ) [ [number] ] [EOL] [EOL] def code_relu ( x ) : [EOL] code = np . minimum ( x , [number] * np . sqrt ( self . dim ) ) [EOL] code_hinge = np . maximum ( [number] + [number] * code , [number] ) [EOL] code_grad = np . minimum ( code_hinge , [number] ) [EOL] return code_grad * np . maximum ( [number] * code_hinge , code ) [EOL] [EOL] prj_code = code_relu ( self . encoder . dot ( prj . flatten ( ) ) ) [EOL] prj_dec = self . decoder . transpose ( ) . dot ( prj_code ) [EOL] prj_dec_norm = np . sqrt ( self . dim / np . sum ( np . square ( prj_dec ) ) ) [EOL] prj_dec *= prj_dec_norm [EOL] prj_err = prj_dec . dot ( prj . flatten ( ) ) / self . dim [EOL] [EOL] prj_sim = ( self . mats . reshape ( ( - [number] , self . dim * self . dim ) ) . dot ( prj . flatten ( ) ) / self . dim ) [EOL] [EOL] print ( [string] + str ( p_dfm ) ) [EOL] print ( [string] + str ( p_mtr ) ) [EOL] print ( [string] + str ( prj_dfm ) ) [EOL] print ( [string] + str ( prj_dec_norm ) ) [EOL] print ( [string] + str ( prj_err ) ) [EOL] print ( ) [EOL] print ( [string] ) [EOL] print ( prj_code ) [EOL] print ( ) [EOL] print ( [string] + str ( self . msteps [ self . dict_role [ r ] ] ) ) [EOL] print ( ) [EOL] [EOL] print ( [string] ) [EOL] show_top ( k , prj_sim , self . list_role ) [EOL] print ( ) [EOL] [EOL] def get_score ( self , head , relation , direction ) : [EOL] ti = self . dict_word [ head ] [EOL] ri = self . dict_role [ relation + ( [string] if direction else [string] ) ] [EOL] vec = self . mats [ ri ] . dot ( self . tvecs [ ti ] ) [EOL] return self . cvecs . dot ( vec ) [EOL] [EOL] def show_mm ( self , r1 , r2 , k ) : [EOL] m = self . mats [ self . dict_role [ r1 ] ] . dot ( self . mats [ self . dict_role [ r2 ] ] ) [EOL] sim = self . mats . reshape ( ( - [number] , self . dim * self . dim ) ) . dot ( m . flatten ( ) ) / self . dim [EOL] print ( [string] ) [EOL] show_top ( k , sim , self . list_role ) [EOL] print ( ) [EOL] [EOL] def mm_rank ( self , r1 , r2 , r ) : [EOL] from scipy . stats import rankdata [EOL] [EOL] m = self . mats [ self . dict_role [ r1 ] ] . dot ( self . mats [ self . dict_role [ r2 ] ] ) [EOL] sim = self . mats . reshape ( ( - [number] , self . dim * self . dim ) ) . dot ( m . flatten ( ) ) [comment] [EOL] return rankdata ( - sim ) [ self . dict_role [ r ] ] [EOL] [EOL] def code_of ( self , r ) : [EOL] def code_relu ( x ) : [EOL] code = np . minimum ( x , [number] * np . sqrt ( self . dim ) ) [EOL] code_hinge = np . maximum ( [number] + [number] * code , [number] ) [EOL] code_grad = np . minimum ( code_hinge , [number] ) [EOL] return code_grad * np . maximum ( [number] * code_hinge , code ) [EOL] [EOL] prj = self . mats [ self . dict_role [ r ] ] [EOL] prj_code = code_relu ( self . encoder . dot ( prj . flatten ( ) ) ) [EOL] return prj_code [EOL] [EOL] def _get_word_vector_if_str ( self , word_or_vec , backoff_to_zero_vector ) : [EOL] if isinstance ( word_or_vec , str ) : [EOL] return self . get_word_vector ( word_or_vec , backoff_to_zero_vector = backoff_to_zero_vector ) [EOL] else : [EOL] return word_or_vec [EOL] [EOL] def calc_phrase_from_path ( self , path , ignore_oov = True ) : [EOL] [docstring] [EOL] if len ( path ) < [number] : [EOL] raise ValueError ( f" [string] { path }" ) [EOL] [EOL] s = path [ [number] ] [EOL] t = path [ - [number] ] [EOL] if ( isinstance ( s , str ) [EOL] and isinstance ( t , str ) [EOL] and s not in self . dict_word [EOL] and t not in self . dict_word ) : [EOL] warnings . warn ( f" [string] { s } [string] { t } [string] " [string] , UserWarning , ) [EOL] [EOL] v = self . _get_word_vector_if_str ( s , backoff_to_zero_vector = ignore_oov ) [EOL] for role in path [ [number] : - [number] ] : [EOL] m = self . get_relation_matrix ( role , backoff_to_identity_matrix = ignore_oov ) [EOL] v = self . trans ( v , m ) [EOL] [EOL] v += self . _get_word_vector_if_str ( t , backoff_to_zero_vector = ignore_oov ) [EOL] v /= np . sqrt ( np . sum ( np . square ( v ) ) ) [EOL] [EOL] return v [EOL] [EOL] def calc_phrase_from_path_with_entities ( self , path , ignore_oov = True ) : [EOL] if len ( path ) < [number] : [EOL] raise ValueError ( f" [string] { path }" ) [EOL] [EOL] v = self . _get_word_vector_if_str ( path [ [number] ] , backoff_to_zero_vector = ignore_oov ) [EOL] for role , ent in chunked ( path [ [number] : ] , [number] ) : [EOL] m = self . get_relation_matrix ( role , backoff_to_identity_matrix = ignore_oov ) [EOL] v = self . trans ( v , m ) [EOL] v += self . _get_word_vector_if_str ( ent , backoff_to_zero_vector = ignore_oov ) [EOL] v /= np . sqrt ( np . sum ( np . square ( v ) ) ) [EOL] [EOL] return v [EOL] [EOL] def calc_phrase_from_triples ( self , triples , ignore_oov = True ) : [EOL] [docstring] [EOL] vec = np . zeros ( self . dim ) [EOL] for head , rel , * tail in triples : [EOL] v = self . _get_word_vector_if_str ( head , backoff_to_zero_vector = ignore_oov ) [EOL] m = self . get_relation_matrix ( rel , backoff_to_identity_matrix = ignore_oov ) [EOL] v = self . trans ( v , m ) [EOL] if tail and tail [ [number] ] : [EOL] v += self . _get_word_vector_if_str ( tail [ [number] ] , backoff_to_zero_vector = ignore_oov ) [EOL] v /= np . sqrt ( np . sum ( np . square ( v ) ) ) [EOL] vec += v [EOL] vec /= np . sqrt ( np . sum ( np . square ( vec ) ) ) [EOL] return vec [EOL] [EOL] def get_average_word_vector ( self , words , skip_oov = True ) : [EOL] [docstring] [EOL] vecs = [ ] [EOL] for word in words : [EOL] if not skip_oov or word in self . dict_word : [EOL] vecs . append ( self . get_word_vector ( word ) ) [EOL] [EOL] if not vecs : [EOL] warnings . warn ( [string] f" [string] { words } [string] " [string] , UserWarning , ) [EOL] return np . zeros ( self . dim ) [EOL] [EOL] return np . average ( vecs , axis = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 $typing.Any$ 0 $numpy.ndarray$ 0 0 0 $typing.Any$ 0 $numpy.ndarray$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $numpy.ndarray$ 0 0 0 $typing.Union[builtins.str,numpy.ndarray]$ 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,numpy.ndarray]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,numpy.ndarray]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,numpy.ndarray]$ 0 0 0 $numpy.ndarray$ 0 0 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,numpy.ndarray]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0