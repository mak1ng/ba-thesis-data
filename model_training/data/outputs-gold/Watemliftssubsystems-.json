[docstring] [EOL]	0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import functools [EOL] import logging [EOL] import os [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] import requests_mock as _requests_mock [EOL] [EOL] from homeassistant import util [EOL] from homeassistant . util import location [EOL] from homeassistant . auth . const import GROUP_ID_ADMIN , GROUP_ID_READ_ONLY [EOL] from homeassistant . auth . providers import legacy_api_password , homeassistant [EOL] [EOL] from tests . common import ( async_test_home_assistant , INSTANCES , mock_coro , mock_storage as mock_storage , MockUser , CLIENT_ID ) [EOL] from tests . test_util . aiohttp import mock_aiohttp_client [EOL] [EOL] if os . environ . get ( [string] ) == [string] : [EOL] import uvloop [EOL] asyncio . set_event_loop_policy ( uvloop . EventLoopPolicy ( ) ) [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] def check_real ( func ) : [EOL] [docstring] [EOL] @ functools . wraps ( func ) def guard_func ( * args , ** kwargs ) : [EOL] real = kwargs . pop ( [string] , None ) [EOL] [EOL] if not real : [EOL] raise Exception ( [string] , func . __name__ ) [EOL] [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return guard_func [EOL] [EOL] [EOL] [comment] [EOL] location . async_detect_location_info = check_real ( location . async_detect_location_info ) [EOL] util . get_local_ip = lambda : [string] [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def verify_cleanup ( ) : [EOL] [docstring] [EOL] yield [EOL] [EOL] if len ( INSTANCES ) >= [number] : [EOL] count = len ( INSTANCES ) [EOL] for inst in INSTANCES : [EOL] inst . stop ( ) [EOL] pytest . exit ( [string] [string] . format ( count ) ) [EOL] [EOL] [EOL] @ pytest . fixture def hass_storage ( ) : [EOL] [docstring] [EOL] with mock_storage ( ) as stored_data : [EOL] yield stored_data [EOL] [EOL] [EOL] @ pytest . fixture def hass ( loop , hass_storage ) : [EOL] [docstring] [EOL] hass = loop . run_until_complete ( async_test_home_assistant ( loop ) ) [EOL] [EOL] yield hass [EOL] [EOL] loop . run_until_complete ( hass . async_stop ( force = True ) ) [EOL] [EOL] [EOL] @ pytest . fixture def requests_mock ( ) : [EOL] [docstring] [EOL] with _requests_mock . mock ( ) as m : [EOL] yield m [EOL] [EOL] [EOL] @ pytest . fixture def aioclient_mock ( ) : [EOL] [docstring] [EOL] with mock_aiohttp_client ( ) as mock_session : [EOL] yield mock_session [EOL] [EOL] [EOL] @ pytest . fixture def mock_device_tracker_conf ( ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] [EOL] async def mock_update_config ( path , id , entity ) : [EOL] devices . append ( entity ) [EOL] [EOL] with patch ( [string] [string] , side_effect = mock_update_config ) , patch ( [string] , side_effect = lambda * args : mock_coro ( devices ) ) : [EOL] yield devices [EOL] [EOL] [EOL] @ pytest . fixture def hass_access_token ( hass , hass_admin_user ) : [EOL] [docstring] [EOL] refresh_token = hass . loop . run_until_complete ( hass . auth . async_create_refresh_token ( hass_admin_user , CLIENT_ID ) ) [EOL] return hass . auth . async_create_access_token ( refresh_token ) [EOL] [EOL] [EOL] @ pytest . fixture def hass_owner_user ( hass , local_auth ) : [EOL] [docstring] [EOL] return MockUser ( is_owner = True ) . add_to_hass ( hass ) [EOL] [EOL] [EOL] @ pytest . fixture def hass_admin_user ( hass , local_auth ) : [EOL] [docstring] [EOL] admin_group = hass . loop . run_until_complete ( hass . auth . async_get_group ( GROUP_ID_ADMIN ) ) [EOL] return MockUser ( groups = [ admin_group ] ) . add_to_hass ( hass ) [EOL] [EOL] [EOL] @ pytest . fixture def hass_read_only_user ( hass , local_auth ) : [EOL] [docstring] [EOL] read_only_group = hass . loop . run_until_complete ( hass . auth . async_get_group ( GROUP_ID_READ_ONLY ) ) [EOL] return MockUser ( groups = [ read_only_group ] ) . add_to_hass ( hass ) [EOL] [EOL] [EOL] @ pytest . fixture def hass_read_only_access_token ( hass , hass_read_only_user ) : [EOL] [docstring] [EOL] refresh_token = hass . loop . run_until_complete ( hass . auth . async_create_refresh_token ( hass_read_only_user , CLIENT_ID ) ) [EOL] return hass . auth . async_create_access_token ( refresh_token ) [EOL] [EOL] [EOL] @ pytest . fixture def legacy_auth ( hass ) : [EOL] [docstring] [EOL] prv = legacy_api_password . LegacyApiPasswordAuthProvider ( hass , hass . auth . _store , { [string] : [string] , [string] : [string] , } ) [EOL] hass . auth . _providers [ ( prv . type , prv . id ) ] = prv [EOL] return prv [EOL] [EOL] [EOL] @ pytest . fixture def local_auth ( hass ) : [EOL] [docstring] [EOL] prv = homeassistant . HassAuthProvider ( hass , hass . auth . _store , { [string] : [string] } ) [EOL] hass . auth . _providers [ ( prv . type , prv . id ) ] = prv [EOL] return prv [EOL] [EOL] [EOL] @ pytest . fixture def hass_client ( hass , aiohttp_client , hass_access_token ) : [EOL] [docstring] [EOL] async def auth_client ( ) : [EOL] [docstring] [EOL] return await aiohttp_client ( hass . http . app , headers = { [string] : [string] . format ( hass_access_token ) } ) [EOL] [EOL] return auth_client [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities_callback , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Optional , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . vacuum import ( ATTR_FAN_SPEED , ATTR_PARAMS , DOMAIN , SERVICE_CLEAN_SPOT , SERVICE_LOCATE , SERVICE_PAUSE , SERVICE_SEND_COMMAND , SERVICE_SET_FAN_SPEED , SERVICE_START , SERVICE_START_PAUSE , SERVICE_STOP , SERVICE_RETURN_TO_BASE ) [EOL] from homeassistant . const import ( ATTR_COMMAND , ATTR_ENTITY_ID , SERVICE_TOGGLE , SERVICE_TURN_OFF , SERVICE_TURN_ON ) [EOL] from homeassistant . loader import bind_hass [EOL] [EOL] [EOL] @ bind_hass def turn_on ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_turn_on , hass , entity_id ) [EOL] [EOL] [EOL] async def async_turn_on ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_TURN_ON , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def turn_off ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_turn_off , hass , entity_id ) [EOL] [EOL] [EOL] async def async_turn_off ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def toggle ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_toggle , hass , entity_id ) [EOL] [EOL] [EOL] async def async_toggle ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_TOGGLE , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def locate ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_locate , hass , entity_id ) [EOL] [EOL] [EOL] async def async_locate ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_LOCATE , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def clean_spot ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_clean_spot , hass , entity_id ) [EOL] [EOL] [EOL] async def async_clean_spot ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_CLEAN_SPOT , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def return_to_base ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_return_to_base , hass , entity_id ) [EOL] [EOL] [EOL] async def async_return_to_base ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_RETURN_TO_BASE , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def start_pause ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_start_pause , hass , entity_id ) [EOL] [EOL] [EOL] async def async_start_pause ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_START_PAUSE , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def start ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_start , hass , entity_id ) [EOL] [EOL] [EOL] async def async_start ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_START , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def pause ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_pause , hass , entity_id ) [EOL] [EOL] [EOL] async def async_pause ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_PAUSE , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def stop ( hass , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_stop , hass , entity_id ) [EOL] [EOL] [EOL] async def async_stop ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else None [EOL] await hass . services . async_call ( DOMAIN , SERVICE_STOP , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def set_fan_speed ( hass , fan_speed , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_set_fan_speed , hass , fan_speed , entity_id ) [EOL] [EOL] [EOL] async def async_set_fan_speed ( hass , fan_speed , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else { } [EOL] data [ ATTR_FAN_SPEED ] = fan_speed [EOL] await hass . services . async_call ( DOMAIN , SERVICE_SET_FAN_SPEED , data , blocking = True ) [EOL] [EOL] [EOL] @ bind_hass def send_command ( hass , command , params = None , entity_id = None ) : [EOL] [docstring] [EOL] hass . add_job ( async_send_command , hass , command , params , entity_id ) [EOL] [EOL] [EOL] async def async_send_command ( hass , command , params = None , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else { } [EOL] data [ ATTR_COMMAND ] = command [EOL] if params is not None : [EOL] data [ ATTR_PARAMS ] = params [EOL] await hass . services . async_call ( DOMAIN , SERVICE_SEND_COMMAND , data , blocking = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] from io import BytesIO [EOL] from unittest . mock import patch [EOL] import pytest [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components . stream . core import Segment [EOL] from homeassistant . components . stream . recorder import recorder_save_worker [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] from tests . common import async_fire_time_changed [EOL] from tests . components . stream . common import ( generate_h264_video , preload_stream ) [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) async def test_record_stream ( hass , hass_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { } } ) [EOL] [EOL] with patch ( [string] ) : [EOL] [comment] [EOL] source = generate_h264_video ( ) [EOL] stream = preload_stream ( hass , source ) [EOL] recorder = stream . add_provider ( [string] ) [EOL] stream . start ( ) [EOL] [EOL] segments = [number] [EOL] while True : [EOL] segment = await recorder . recv ( ) [EOL] if not segment : [EOL] break [EOL] segments += [number] [EOL] [EOL] stream . stop ( ) [EOL] [EOL] assert segments > [number] [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) async def test_recorder_timeout ( hass , hass_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { } } ) [EOL] [EOL] with patch ( [string] ) as mock_cleanup : [EOL] [comment] [EOL] source = generate_h264_video ( ) [EOL] stream = preload_stream ( hass , source ) [EOL] recorder = stream . add_provider ( [string] ) [EOL] stream . start ( ) [EOL] [EOL] await recorder . recv ( ) [EOL] [EOL] [comment] [EOL] future = dt_util . utcnow ( ) + timedelta ( minutes = [number] ) [EOL] async_fire_time_changed ( hass , future ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert mock_cleanup . called [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) async def test_recorder_save ( ) : [EOL] [docstring] [EOL] [comment] [EOL] source = generate_h264_video ( ) [EOL] output = BytesIO ( ) [EOL] output . name = [string] [EOL] [EOL] [comment] [EOL] recorder_save_worker ( output , [ Segment ( [number] , source , [number] ) ] ) [EOL] [EOL] [comment] [EOL] assert output . getvalue ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from tests . common import mock_coro [EOL] [EOL] [EOL] @ pytest . fixture def mock_weather ( ) : [EOL] [docstring] [EOL] with patch ( [string] ) as mock_data : [EOL] mock_data = mock_data . return_value [EOL] mock_data . fetching_data . side_effect = lambda : mock_coro ( True ) [EOL] mock_data . get_current_weather . return_value = { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [string] , } [EOL] mock_data . get_forecast . return_value = { } [EOL] yield mock_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] async def test_tracking_home ( hass , mock_weather ) : [EOL] [docstring] [EOL] await hass . config_entries . flow . async_init ( [string] , context = { [string] : [string] } ) [EOL] await hass . async_block_till_done ( ) [EOL] assert len ( hass . states . async_entity_ids ( [string] ) ) == [number] [EOL] assert len ( mock_weather . mock_calls ) == [number] [EOL] [EOL] [comment] [EOL] await hass . config . async_update ( latitude = [number] , longitude = [number] , ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( mock_weather . mock_calls ) == [number] [EOL] [EOL] entry = hass . config_entries . async_entries ( ) [ [number] ] [EOL] await hass . config_entries . async_remove ( entry . entry_id ) [EOL] assert len ( hass . states . async_entity_ids ( [string] ) ) == [number] [EOL] [EOL] [EOL] async def test_not_tracking_home ( hass , mock_weather ) : [EOL] [docstring] [EOL] await hass . config_entries . flow . async_init ( [string] , context = { [string] : [string] } , data = { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [number] , } ) [EOL] await hass . async_block_till_done ( ) [EOL] assert len ( hass . states . async_entity_ids ( [string] ) ) == [number] [EOL] assert len ( mock_weather . mock_calls ) == [number] [EOL] [EOL] [comment] [EOL] await hass . config . async_update ( latitude = [number] , longitude = [number] , ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( mock_weather . mock_calls ) == [number] [EOL] [EOL] entry = hass . config_entries . async_entries ( ) [ [number] ] [EOL] await hass . config_entries . async_remove ( entry . entry_id ) [EOL] assert len ( hass . states . async_entity_ids ( [string] ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import pytest [EOL] [EOL] from tests . common import mock_device_registry [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] [EOL] from homeassistant . components . mobile_app . const import DOMAIN [EOL] [EOL] from . const import REGISTER , REGISTER_CLEARTEXT [EOL] [EOL] [EOL] @ pytest . fixture def registry ( hass ) : [EOL] [docstring] [EOL] return mock_device_registry ( hass ) [EOL] [EOL] [EOL] @ pytest . fixture async def create_registrations ( authed_api_client ) : [EOL] [docstring] [EOL] enc_reg = await authed_api_client . post ( [string] , json = REGISTER ) [EOL] [EOL] assert enc_reg . status == [number] [EOL] enc_reg_json = await enc_reg . json ( ) [EOL] [EOL] clear_reg = await authed_api_client . post ( [string] , json = REGISTER_CLEARTEXT ) [EOL] [EOL] assert clear_reg . status == [number] [EOL] clear_reg_json = await clear_reg . json ( ) [EOL] [EOL] return ( enc_reg_json , clear_reg_json ) [EOL] [EOL] [EOL] @ pytest . fixture async def webhook_client ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , DOMAIN , { DOMAIN : { } } ) [EOL] await hass . async_block_till_done ( ) [EOL] return await aiohttp_client ( hass . http . app ) [EOL] [EOL] [EOL] @ pytest . fixture async def authed_api_client ( hass , hass_client ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , DOMAIN , { DOMAIN : { } } ) [EOL] await hass . async_block_till_done ( ) [EOL] return await hass_client ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) async def setup_ws ( hass ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , [string] , { } ) [EOL] await hass . async_block_till_done ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import pytest [EOL] [EOL] from homeassistant . components . mobile_app . const import CONF_SECRET , DOMAIN [EOL] from homeassistant . const import CONF_WEBHOOK_ID [EOL] from homeassistant . setup import async_setup_component [EOL] [EOL] from . const import REGISTER , RENDER_TEMPLATE [EOL] [EOL] [EOL] async def test_registration ( hass , hass_client ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] from nacl . secret import SecretBox [comment] [EOL] from nacl . encoding import Base64Encoder [comment] [EOL] except ( ImportError , OSError ) : [EOL] pytest . skip ( [string] ) [EOL] return [EOL] [EOL] import json [EOL] [EOL] await async_setup_component ( hass , DOMAIN , { DOMAIN : { } } ) [EOL] [EOL] api_client = await hass_client ( ) [EOL] [EOL] resp = await api_client . post ( [string] , json = REGISTER ) [EOL] [EOL] assert resp . status == [number] [EOL] register_json = await resp . json ( ) [EOL] assert CONF_WEBHOOK_ID in register_json [EOL] assert CONF_SECRET in register_json [EOL] [EOL] entries = hass . config_entries . async_entries ( DOMAIN ) [EOL] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] assert entries [ [number] ] . data [ [string] ] == REGISTER [ [string] ] [EOL] [EOL] keylen = SecretBox . KEY_SIZE [EOL] key = register_json [ CONF_SECRET ] . encode ( [string] ) [EOL] key = key [ : keylen ] [EOL] key = key . ljust ( keylen , [string] ) [EOL] [EOL] payload = json . dumps ( RENDER_TEMPLATE [ [string] ] ) . encode ( [string] ) [EOL] [EOL] data = SecretBox ( key ) . encrypt ( payload , encoder = Base64Encoder ) . decode ( [string] ) [EOL] [EOL] container = { [string] : [string] , [string] : True , [string] : data , } [EOL] [EOL] resp = await api_client . post ( [string] . format ( register_json [ CONF_WEBHOOK_ID ] ) , json = container ) [EOL] [EOL] assert resp . status == [number] [EOL] [EOL] webhook_json = await resp . json ( ) [EOL] assert [string] in webhook_json [EOL] [EOL] decrypted_data = SecretBox ( key ) . decrypt ( webhook_json [ [string] ] , encoder = Base64Encoder ) [EOL] decrypted_data = decrypted_data . decode ( [string] ) [EOL] [EOL] assert json . loads ( decrypted_data ) == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union [EOL] import typing [EOL] [docstring] [EOL] CALL_SERVICE = { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] } } } [EOL] [EOL] FIRE_EVENT = { [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] } } } [EOL] [EOL] REGISTER = { [string] : { [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True } [EOL] [EOL] REGISTER_CLEARTEXT = { [string] : { [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : False } [EOL] [EOL] RENDER_TEMPLATE = { [string] : [string] , [string] : { [string] : { [string] : [string] } } } [EOL] [EOL] UPDATE = { [string] : { [string] : [string] } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Generator , Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . loader import bind_hass [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components import duckdns [EOL] from homeassistant . util . dt import utcnow [EOL] [EOL] from tests . common import async_fire_time_changed [EOL] [EOL] DOMAIN = [string] [EOL] TOKEN = [string] [EOL] [EOL] [EOL] @ bind_hass @ asyncio . coroutine def async_set_txt ( hass , txt ) : [EOL] [docstring] [EOL] yield from hass . services . async_call ( duckdns . DOMAIN , duckdns . SERVICE_SET_TXT , { duckdns . ATTR_TXT : txt } , blocking = True ) [EOL] [EOL] [EOL] @ pytest . fixture def setup_duckdns ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( duckdns . UPDATE_URL , params = { [string] : DOMAIN , [string] : TOKEN } , text = [string] ) [EOL] [EOL] hass . loop . run_until_complete ( async_setup_component ( hass , duckdns . DOMAIN , { [string] : { [string] : DOMAIN , [string] : TOKEN } } ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_setup ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( duckdns . UPDATE_URL , params = { [string] : DOMAIN , [string] : TOKEN } , text = [string] ) [EOL] [EOL] result = yield from async_setup_component ( hass , duckdns . DOMAIN , { [string] : { [string] : DOMAIN , [string] : TOKEN } } ) [EOL] assert result [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] async_fire_time_changed ( hass , utcnow ( ) + timedelta ( minutes = [number] ) ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_setup_fails_if_update_fails ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( duckdns . UPDATE_URL , params = { [string] : DOMAIN , [string] : TOKEN } , text = [string] ) [EOL] [EOL] result = yield from async_setup_component ( hass , duckdns . DOMAIN , { [string] : { [string] : DOMAIN , [string] : TOKEN } } ) [EOL] assert not result [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_service_set_txt ( hass , aioclient_mock , setup_duckdns ) : [EOL] [docstring] [EOL] [comment] [EOL] aioclient_mock . clear_requests ( ) [EOL] [EOL] aioclient_mock . get ( duckdns . UPDATE_URL , params = { [string] : DOMAIN , [string] : TOKEN , [string] : [string] , } , text = [string] ) [EOL] [EOL] assert aioclient_mock . call_count == [number] [EOL] yield from async_set_txt ( hass , [string] ) [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_service_clear_txt ( hass , aioclient_mock , setup_duckdns ) : [EOL] [docstring] [EOL] [comment] [EOL] aioclient_mock . clear_requests ( ) [EOL] [EOL] aioclient_mock . get ( duckdns . UPDATE_URL , params = { [string] : DOMAIN , [string] : TOKEN , [string] : [string] , [string] : [string] , } , text = [string] ) [EOL] [EOL] assert aioclient_mock . call_count == [number] [EOL] yield from async_set_txt ( hass , None ) [EOL] assert aioclient_mock . call_count == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Tuple , Any [EOL] import typing [EOL] import asyncio [EOL] import builtins [EOL] import unittest [EOL] [docstring] [EOL] import asyncio [EOL] import os [EOL] import tempfile [EOL] import unittest [EOL] from typing import Tuple [EOL] from unittest . mock import Mock , patch [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components import shell_command [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] @ asyncio . coroutine def mock_process_creator ( error = False ) : [EOL] [docstring] [EOL] @ asyncio . coroutine def communicate ( ) : [EOL] [docstring] [EOL] return [string] , [string] [EOL] [EOL] mock_process = Mock ( ) [EOL] mock_process . communicate = communicate [EOL] mock_process . returncode = int ( error ) [EOL] return mock_process [EOL] [EOL] [EOL] class TestShellCommand ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] asyncio . get_child_watcher ( ) . attach_loop ( self . hass . loop ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_executing_service ( self ) : [EOL] [docstring] [EOL] with tempfile . TemporaryDirectory ( ) as tempdirname : [EOL] path = os . path . join ( tempdirname , [string] ) [EOL] assert setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] . format ( path ) } } ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] assert os . path . isfile ( path ) [EOL] [EOL] def test_config_not_dict ( self ) : [EOL] [docstring] [EOL] assert not setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : [ [string] , [string] , [string] ] } ) [EOL] [EOL] def test_config_not_valid_service_names ( self ) : [EOL] [docstring] [EOL] assert not setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] } } ) [EOL] [EOL] @ patch ( [string] [string] ) def test_template_render_no_template ( self , mock_call ) : [EOL] [docstring] [EOL] mock_call . return_value = mock_process_creator ( error = False ) [EOL] [EOL] assert setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] } } ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] cmd = mock_call . mock_calls [ [number] ] [ [number] ] [ [number] ] [EOL] [EOL] assert [number] == mock_call . call_count [EOL] assert [string] == cmd [EOL] [EOL] @ patch ( [string] [string] ) def test_template_render ( self , mock_call ) : [EOL] [docstring] [EOL] self . hass . states . set ( [string] , [string] ) [EOL] mock_call . return_value = mock_process_creator ( error = False ) [EOL] assert setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : ( [string] [string] ) } } ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] cmd = mock_call . mock_calls [ [number] ] [ [number] ] [EOL] [EOL] assert [number] == mock_call . call_count [EOL] assert ( [string] , [string] , [string] ) == cmd [EOL] [EOL] @ patch ( [string] [string] ) @ patch ( [string] ) def test_subprocess_error ( self , mock_error , mock_call ) : [EOL] [docstring] [EOL] mock_call . return_value = mock_process_creator ( error = True ) [EOL] with tempfile . TemporaryDirectory ( ) as tempdirname : [EOL] path = os . path . join ( tempdirname , [string] ) [EOL] assert setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] . format ( path ) } } ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] assert [number] == mock_call . call_count [EOL] assert [number] == mock_error . call_count [EOL] assert not os . path . isfile ( path ) [EOL] [EOL] @ patch ( [string] ) def test_stdout_captured ( self , mock_output ) : [EOL] [docstring] [EOL] test_phrase = [string] [EOL] assert setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] . format ( test_phrase ) } } ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] assert [number] == mock_output . call_count [EOL] assert test_phrase . encode ( ) + [string] == mock_output . call_args_list [ [number] ] [ [number] ] [ - [number] ] [EOL] [EOL] @ patch ( [string] ) def test_stderr_captured ( self , mock_output ) : [EOL] [docstring] [EOL] test_phrase = [string] [EOL] assert setup_component ( self . hass , shell_command . DOMAIN , { shell_command . DOMAIN : { [string] : [string] . format ( test_phrase ) } } ) [EOL] [EOL] self . hass . services . call ( [string] , [string] , blocking = True ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] assert [number] == mock_output . call_count [EOL] assert test_phrase . encode ( ) + [string] == mock_output . call_args_list [ [number] ] [ [number] ] [ - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from pysmartthings import ATTRIBUTES , CAPABILITIES , Attribute , Capability [EOL] [EOL] from homeassistant . components . sensor import ( DEVICE_CLASSES , DOMAIN as SENSOR_DOMAIN ) [EOL] from homeassistant . components . smartthings import sensor [EOL] from homeassistant . components . smartthings . const import ( DOMAIN , SIGNAL_SMARTTHINGS_UPDATE ) [EOL] from homeassistant . const import ( ATTR_FRIENDLY_NAME , ATTR_UNIT_OF_MEASUREMENT , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_send [EOL] [EOL] from . conftest import setup_platform [EOL] [EOL] [EOL] async def test_mapping_integrity ( ) : [EOL] [docstring] [EOL] for capability , maps in sensor . CAPABILITY_TO_SENSORS . items ( ) : [EOL] assert capability in CAPABILITIES , capability [EOL] for sensor_map in maps : [EOL] assert sensor_map . attribute in ATTRIBUTES , sensor_map . attribute [EOL] if sensor_map . device_class : [EOL] assert sensor_map . device_class in DEVICE_CLASSES , sensor_map . device_class [EOL] [EOL] [EOL] async def test_async_setup_platform ( ) : [EOL] [docstring] [EOL] await sensor . async_setup_platform ( None , None , None ) [EOL] [EOL] [EOL] async def test_entity_state ( hass , device_factory ) : [EOL] [docstring] [EOL] device = device_factory ( [string] , [ Capability . battery ] , { Attribute . battery : [number] } ) [EOL] await setup_platform ( hass , SENSOR_DOMAIN , devices = [ device ] ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ ATTR_UNIT_OF_MEASUREMENT ] == [string] [EOL] assert state . attributes [ ATTR_FRIENDLY_NAME ] == device . label + [string] [EOL] [EOL] [EOL] async def test_entity_three_axis_state ( hass , device_factory ) : [EOL] [docstring] [EOL] device = device_factory ( [string] , [ Capability . three_axis ] , { Attribute . three_axis : [ [number] , [number] , [number] ] } ) [EOL] await setup_platform ( hass , SENSOR_DOMAIN , devices = [ device ] ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ ATTR_FRIENDLY_NAME ] == device . label + [string] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ ATTR_FRIENDLY_NAME ] == device . label + [string] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ ATTR_FRIENDLY_NAME ] == device . label + [string] [EOL] [EOL] [EOL] async def test_entity_three_axis_invalid_state ( hass , device_factory ) : [EOL] [docstring] [EOL] device = device_factory ( [string] , [ Capability . three_axis ] , { Attribute . three_axis : [ ] } ) [EOL] await setup_platform ( hass , SENSOR_DOMAIN , devices = [ device ] ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == STATE_UNKNOWN [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == STATE_UNKNOWN [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == STATE_UNKNOWN [EOL] [EOL] [EOL] async def test_entity_and_device_attributes ( hass , device_factory ) : [EOL] [docstring] [EOL] [comment] [EOL] device = device_factory ( [string] , [ Capability . battery ] , { Attribute . battery : [number] } ) [EOL] entity_registry = await hass . helpers . entity_registry . async_get_registry ( ) [EOL] device_registry = await hass . helpers . device_registry . async_get_registry ( ) [EOL] [comment] [EOL] await setup_platform ( hass , SENSOR_DOMAIN , devices = [ device ] ) [EOL] [comment] [EOL] entry = entity_registry . async_get ( [string] ) [EOL] assert entry [EOL] assert entry . unique_id == device . device_id + [string] + Attribute . battery [EOL] entry = device_registry . async_get_device ( { ( DOMAIN , device . device_id ) } , [ ] ) [EOL] assert entry [EOL] assert entry . name == device . label [EOL] assert entry . model == device . device_type_name [EOL] assert entry . manufacturer == [string] [EOL] [EOL] [EOL] async def test_update_from_signal ( hass , device_factory ) : [EOL] [docstring] [EOL] [comment] [EOL] device = device_factory ( [string] , [ Capability . battery ] , { Attribute . battery : [number] } ) [EOL] await setup_platform ( hass , SENSOR_DOMAIN , devices = [ device ] ) [EOL] device . status . apply_attribute_update ( [string] , Capability . battery , Attribute . battery , [number] ) [EOL] [comment] [EOL] async_dispatcher_send ( hass , SIGNAL_SMARTTHINGS_UPDATE , [ device . device_id ] ) [EOL] [comment] [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . state == [string] [EOL] [EOL] [EOL] async def test_unload_config_entry ( hass , device_factory ) : [EOL] [docstring] [EOL] [comment] [EOL] device = device_factory ( [string] , [ Capability . battery ] , { Attribute . battery : [number] } ) [EOL] config_entry = await setup_platform ( hass , SENSOR_DOMAIN , devices = [ device ] ) [EOL] [comment] [EOL] await hass . config_entries . async_forward_entry_unload ( config_entry , [string] ) [EOL] [comment] [EOL] assert not hass . states . get ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] [docstring] [EOL] import socket [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import requests [EOL] from uvcclient import camera [EOL] from uvcclient import nvr [EOL] [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components . uvc import camera as uvc [EOL] from tests . common import get_test_home_assistant [EOL] import pytest [EOL] [EOL] [EOL] class TestUVCSetup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch . object ( uvc , [string] ) def test_setup_full_config ( self , mock_uvc , mock_remote ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } [EOL] mock_cameras = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] [EOL] def mock_get_camera ( uuid ) : [EOL] [docstring] [EOL] if uuid == [string] : [EOL] return { [string] : [string] } [EOL] return { [string] : [string] } [EOL] [EOL] mock_remote . return_value . index . return_value = mock_cameras [EOL] mock_remote . return_value . get_camera . side_effect = mock_get_camera [EOL] mock_remote . return_value . server_version = ( [number] , [number] , [number] ) [EOL] [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] [EOL] assert mock_remote . call_count == [number] [EOL] assert mock_remote . call_args == mock . call ( [string] , [number] , [string] , ssl = False ) [EOL] mock_uvc . assert_has_calls ( [ mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch . object ( uvc , [string] ) def test_setup_partial_config ( self , mock_uvc , mock_remote ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] mock_cameras = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] mock_remote . return_value . index . return_value = mock_cameras [EOL] mock_remote . return_value . get_camera . return_value = { [string] : [string] } [EOL] mock_remote . return_value . server_version = ( [number] , [number] , [number] ) [EOL] [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] [EOL] assert mock_remote . call_count == [number] [EOL] assert mock_remote . call_args == mock . call ( [string] , [number] , [string] , ssl = False ) [EOL] mock_uvc . assert_has_calls ( [ mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch . object ( uvc , [string] ) def test_setup_partial_config_v31x ( self , mock_uvc , mock_remote ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] mock_cameras = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] mock_remote . return_value . index . return_value = mock_cameras [EOL] mock_remote . return_value . get_camera . return_value = { [string] : [string] } [EOL] mock_remote . return_value . server_version = ( [number] , [number] , [number] ) [EOL] [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] [EOL] assert mock_remote . call_count == [number] [EOL] assert mock_remote . call_args == mock . call ( [string] , [number] , [string] , ssl = False ) [EOL] mock_uvc . assert_has_calls ( [ mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , ] ) [EOL] [EOL] @ mock . patch . object ( uvc , [string] ) def test_setup_incomplete_config ( self , mock_uvc ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , [string] , { [string] : [string] , [string] : [string] } ) [EOL] assert not mock_uvc . called [EOL] assert setup_component ( self . hass , [string] , { [string] : [string] , [string] : [string] } ) [EOL] assert not mock_uvc . called [EOL] assert setup_component ( self . hass , [string] , { [string] : [string] , [string] : [string] } ) [EOL] assert not mock_uvc . called [EOL] [EOL] @ mock . patch . object ( uvc , [string] ) @ mock . patch ( [string] ) def setup_nvr_errors_during_indexing ( self , error , mock_remote , mock_uvc ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] mock_remote . return_value . index . side_effect = error [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] assert not mock_uvc . called [EOL] [EOL] def test_setup_nvr_error_during_indexing_notauthorized ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_indexing ( nvr . NotAuthorized ) [EOL] [EOL] def test_setup_nvr_error_during_indexing_nvrerror ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_indexing ( nvr . NvrError ) [EOL] pytest . raises ( PlatformNotReady ) [EOL] [EOL] def test_setup_nvr_error_during_indexing_connectionerror ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_indexing ( requests . exceptions . ConnectionError ) [EOL] pytest . raises ( PlatformNotReady ) [EOL] [EOL] @ mock . patch . object ( uvc , [string] ) @ mock . patch ( [string] ) def setup_nvr_errors_during_initialization ( self , error , mock_remote , mock_uvc ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] mock_remote . return_value = None [EOL] mock_remote . side_effect = error [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] assert not mock_remote . index . called [EOL] assert not mock_uvc . called [EOL] [EOL] def test_setup_nvr_error_during_initialization_notauthorized ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_initialization ( nvr . NotAuthorized ) [EOL] [EOL] def test_setup_nvr_error_during_initialization_nvrerror ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_initialization ( nvr . NvrError ) [EOL] pytest . raises ( PlatformNotReady ) [EOL] [EOL] def test_setup_nvr_error_during_initialization_connectionerror ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_initialization ( requests . exceptions . ConnectionError ) [EOL] pytest . raises ( PlatformNotReady ) [EOL] [EOL] [EOL] class TestUVC ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . nvr = mock . MagicMock ( ) [EOL] self . uuid = [string] [EOL] self . name = [string] [EOL] self . password = [string] [EOL] self . uvc = uvc . UnifiVideoCamera ( self . nvr , self . uuid , self . name , self . password ) [EOL] self . nvr . get_camera . return_value = { [string] : [string] , [string] : { [string] : True , } , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] self . nvr . server_version = ( [number] , [number] , [number] ) [EOL] [EOL] def test_properties ( self ) : [EOL] [docstring] [EOL] assert self . name == self . uvc . name [EOL] assert self . uvc . is_recording [EOL] assert [string] == self . uvc . brand [EOL] assert [string] == self . uvc . model [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_login ( self , mock_camera , mock_store ) : [EOL] [docstring] [EOL] self . uvc . _login ( ) [EOL] assert mock_camera . call_count == [number] [EOL] assert mock_camera . call_args == mock . call ( [string] , [string] , [string] ) [EOL] assert mock_camera . return_value . login . call_count == [number] [EOL] assert mock_camera . return_value . login . call_args == mock . call ( ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_login_v31x ( self , mock_camera , mock_store ) : [EOL] [docstring] [EOL] self . nvr . server_version = ( [number] , [number] , [number] ) [EOL] self . uvc . _login ( ) [EOL] assert mock_camera . call_count == [number] [EOL] assert mock_camera . call_args == mock . call ( [string] , [string] , [string] ) [EOL] assert mock_camera . return_value . login . call_count == [number] [EOL] assert mock_camera . return_value . login . call_args == mock . call ( ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_login_tries_both_addrs_and_caches ( self , mock_camera , mock_store ) : [EOL] [docstring] [EOL] responses = [ [number] ] [EOL] [EOL] def mock_login ( * a ) : [EOL] [docstring] [EOL] try : [EOL] responses . pop ( [number] ) [EOL] raise socket . error [EOL] except IndexError : [EOL] pass [EOL] [EOL] mock_store . return_value . get_camera_password . return_value = None [EOL] mock_camera . return_value . login . side_effect = mock_login [EOL] self . uvc . _login ( ) [EOL] assert [number] == mock_camera . call_count [EOL] assert [string] == self . uvc . _connect_addr [EOL] [EOL] mock_camera . reset_mock ( ) [EOL] self . uvc . _login ( ) [EOL] assert mock_camera . call_count == [number] [EOL] assert mock_camera . call_args == mock . call ( [string] , [string] , [string] ) [EOL] assert mock_camera . return_value . login . call_count == [number] [EOL] assert mock_camera . return_value . login . call_args == mock . call ( ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_login_fails_both_properly ( self , mock_camera , mock_store ) : [EOL] [docstring] [EOL] mock_camera . return_value . login . side_effect = socket . error [EOL] assert self . uvc . _login ( ) is None [EOL] assert self . uvc . _connect_addr is None [EOL] [EOL] def test_camera_image_tries_login_bails_on_failure ( self ) : [EOL] [docstring] [EOL] with mock . patch . object ( self . uvc , [string] ) as mock_login : [EOL] mock_login . return_value = False [EOL] assert self . uvc . camera_image ( ) is None [EOL] assert mock_login . call_count == [number] [EOL] assert mock_login . call_args == mock . call ( ) [EOL] [EOL] def test_camera_image_logged_in ( self ) : [EOL] [docstring] [EOL] self . uvc . _camera = mock . MagicMock ( ) [EOL] assert self . uvc . _camera . get_snapshot . return_value == self . uvc . camera_image ( ) [EOL] [EOL] def test_camera_image_error ( self ) : [EOL] [docstring] [EOL] self . uvc . _camera = mock . MagicMock ( ) [EOL] self . uvc . _camera . get_snapshot . side_effect = camera . CameraConnectError [EOL] assert self . uvc . camera_image ( ) is None [EOL] [EOL] def test_camera_image_reauths ( self ) : [EOL] [docstring] [EOL] responses = [ [number] ] [EOL] [EOL] def mock_snapshot ( ) : [EOL] [docstring] [EOL] try : [EOL] responses . pop ( ) [EOL] raise camera . CameraAuthError ( ) [EOL] except IndexError : [EOL] pass [EOL] return [string] [EOL] [EOL] self . uvc . _camera = mock . MagicMock ( ) [EOL] self . uvc . _camera . get_snapshot . side_effect = mock_snapshot [EOL] with mock . patch . object ( self . uvc , [string] ) as mock_login : [EOL] assert [string] == self . uvc . camera_image ( ) [EOL] assert mock_login . call_count == [number] [EOL] assert mock_login . call_args == mock . call ( ) [EOL] assert [ ] == responses [EOL] [EOL] def test_camera_image_reauths_only_once ( self ) : [EOL] [docstring] [EOL] self . uvc . _camera = mock . MagicMock ( ) [EOL] self . uvc . _camera . get_snapshot . side_effect = camera . CameraAuthError [EOL] with mock . patch . object ( self . uvc , [string] ) as mock_login : [EOL] with pytest . raises ( camera . CameraAuthError ) : [EOL] self . uvc . camera_image ( ) [EOL] assert mock_login . call_count == [number] [EOL] assert mock_login . call_args == mock . call ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import patch [EOL] from homeassistant . const import ( STATE_LOCKED , STATE_UNLOCKED , STATE_UNAVAILABLE ) [EOL] from homeassistant . components . lock import DOMAIN [EOL] from tests . common import mock_coro [EOL] from . common import ( async_init_zigpy_device , make_attribute , make_entity_id , async_enable_traffic ) [EOL] [EOL] LOCK_DOOR = [number] [EOL] UNLOCK_DOOR = [number] [EOL] [EOL] [EOL] async def test_lock ( hass , config_entry , zha_gateway ) : [EOL] [docstring] [EOL] from zigpy . zcl . clusters . closures import DoorLock [EOL] from zigpy . zcl . clusters . general import Basic [EOL] [EOL] [comment] [EOL] zigpy_device = await async_init_zigpy_device ( hass , [ DoorLock . cluster_id , Basic . cluster_id ] , [ ] , None , zha_gateway ) [EOL] [EOL] [comment] [EOL] await hass . config_entries . async_forward_entry_setup ( config_entry , DOMAIN ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] cluster = zigpy_device . endpoints . get ( [number] ) . door_lock [EOL] entity_id = make_entity_id ( DOMAIN , zigpy_device , cluster ) [EOL] zha_device = zha_gateway . get_device ( zigpy_device . ieee ) [EOL] [EOL] [comment] [EOL] assert hass . states . get ( entity_id ) . state == STATE_UNAVAILABLE [EOL] [EOL] [comment] [EOL] await async_enable_traffic ( hass , zha_gateway , [ zha_device ] ) [EOL] [EOL] [comment] [EOL] assert hass . states . get ( entity_id ) . state == STATE_UNLOCKED [EOL] [EOL] [comment] [EOL] attr = make_attribute ( [number] , [number] ) [EOL] cluster . handle_message ( False , [number] , [number] , [ [ attr ] ] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert hass . states . get ( entity_id ) . state == STATE_LOCKED [EOL] [EOL] [comment] [EOL] attr . value . value = [number] [EOL] cluster . handle_message ( False , [number] , [number] , [ [ attr ] ] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert hass . states . get ( entity_id ) . state == STATE_UNLOCKED [EOL] [EOL] [comment] [EOL] await async_lock ( hass , cluster , entity_id ) [EOL] [EOL] [comment] [EOL] await async_unlock ( hass , cluster , entity_id ) [EOL] [EOL] [EOL] async def async_lock ( hass , cluster , entity_id ) : [EOL] [docstring] [EOL] from zigpy . zcl . foundation import Status [EOL] with patch ( [string] , return_value = mock_coro ( [ Status . SUCCESS , ] ) ) : [EOL] [comment] [EOL] await hass . services . async_call ( DOMAIN , [string] , { [string] : entity_id } , blocking = True ) [EOL] assert cluster . request . call_count == [number] [EOL] assert cluster . request . call_args [ [number] ] [ [number] ] is False [EOL] assert cluster . request . call_args [ [number] ] [ [number] ] == LOCK_DOOR [EOL] [EOL] [EOL] async def async_unlock ( hass , cluster , entity_id ) : [EOL] [docstring] [EOL] from zigpy . zcl . foundation import Status [EOL] with patch ( [string] , return_value = mock_coro ( [ Status . SUCCESS , ] ) ) : [EOL] [comment] [EOL] await hass . services . async_call ( DOMAIN , [string] , { [string] : entity_id } , blocking = True ) [EOL] assert cluster . request . call_count == [number] [EOL] assert cluster . request . call_args [ [number] ] [ [number] ] is False [EOL] assert cluster . request . call_args [ [number] ] [ [number] ] == UNLOCK_DOOR [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components . frontend import storage [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def setup_frontend ( hass ) : [EOL] [docstring] [EOL] hass . loop . run_until_complete ( async_setup_component ( hass , [string] , { } ) ) [EOL] [EOL] [EOL] async def test_get_user_data_empty ( hass , hass_ws_client , hass_storage ) : [EOL] [docstring] [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] assert res [ [string] ] [ [string] ] is None [EOL] [EOL] [EOL] async def test_get_user_data ( hass , hass_ws_client , hass_admin_user , hass_storage ) : [EOL] [docstring] [EOL] storage_key = storage . STORAGE_KEY_USER_DATA . format ( hass_admin_user . id ) [EOL] hass_storage [ storage_key ] = { [string] : storage_key , [string] : [number] , [string] : { [string] : [string] , [string] : [ { [string] : [string] } ] } } [EOL] [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] [comment] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] assert res [ [string] ] [ [string] ] == [string] [EOL] [EOL] [comment] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] assert res [ [string] ] [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [comment] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] assert res [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] assert res [ [string] ] [ [string] ] [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_set_user_data_empty ( hass , hass_ws_client , hass_storage ) : [EOL] [docstring] [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] [comment] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] assert res [ [string] ] [ [string] ] is None [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] assert res [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_set_user_data ( hass , hass_ws_client , hass_storage , hass_admin_user ) : [EOL] [docstring] [EOL] storage_key = storage . STORAGE_KEY_USER_DATA . format ( hass_admin_user . id ) [EOL] hass_storage [ storage_key ] = { [string] : [number] , [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] client = await hass_ws_client ( hass ) [EOL] [EOL] [comment] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] assert res [ [string] ] [ [string] ] == [string] [EOL] [EOL] [comment] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] } ] } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] assert res [ [string] ] [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [comment] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] res = await client . receive_json ( ) [EOL] assert res [ [string] ] , res [EOL] assert res [ [string] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . setup import setup_component [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] VALID_CONFIG = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } } [EOL] [EOL] [EOL] def get_departuresMock ( _stop_id , route , destination , api_key ) : [EOL] [docstring] [EOL] data = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] return data [EOL] [EOL] [EOL] class TestRMVtransportSensor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ patch ( [string] , side_effect = get_departuresMock ) def test_transportnsw_config ( self , mock_get_departures ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , [string] , VALID_CONFIG ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ [string] ] == [string] [EOL] assert state . attributes [ [string] ] == [string] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [string] [EOL] assert state . attributes [ [string] ] == [string] [EOL] assert state . attributes [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Any , Dict , List , Type [EOL] import tests [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] from datetime import timedelta , datetime [EOL] import pytz [EOL] [EOL] from homeassistant import setup [EOL] import homeassistant . core as ha [EOL] from homeassistant . const import STATE_OFF , STATE_ON [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . setup import setup_component [EOL] from tests . common import ( get_test_home_assistant , assert_setup_component ) [EOL] from homeassistant . helpers . sun import ( get_astral_event_date , get_astral_event_next ) [EOL] [EOL] [EOL] class TestBinarySensorTod ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] hass = None [EOL] [comment] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . hass . config . latitute = [number] [EOL] self . hass . config . longitude = [number] [EOL] [EOL] def teardown_method ( self , method ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup ( self ) : [EOL] [docstring] [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] , } [EOL] with assert_setup_component ( [number] ) : [EOL] assert setup . setup_component ( self . hass , [string] , config ) [EOL] [EOL] def test_setup_no_sensors ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] } } ) [EOL] [EOL] def test_in_period_on_start ( self ) : [EOL] [docstring] [EOL] test_time = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = self . hass . config . time_zone ) [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] with patch ( [string] , return_value = test_time ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_ON [EOL] [EOL] def test_midnight_turnover_before_midnight_inside_period ( self ) : [EOL] [docstring] [EOL] test_time = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = self . hass . config . time_zone ) [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , ] } [EOL] with patch ( [string] , return_value = test_time ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_ON [EOL] [EOL] def test_midnight_turnover_after_midnight_inside_period ( self ) : [EOL] [docstring] [EOL] test_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } , ] } [EOL] with patch ( [string] , return_value = test_time ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] with patch ( [string] , return_value = test_time + timedelta ( hours = [number] ) ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : test_time + timedelta ( hours = [number] ) } ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_ON [EOL] [EOL] def test_midnight_turnover_before_midnight_outside_period ( self ) : [EOL] [docstring] [EOL] test_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] with patch ( [string] , return_value = test_time ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] def test_midnight_turnover_after_midnight_outside_period ( self ) : [EOL] [docstring] [EOL] test_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] with patch ( [string] , return_value = test_time ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] switchover_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] with patch ( [string] , return_value = switchover_time ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : switchover_time } ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_ON [EOL] [EOL] with patch ( [string] , return_value = switchover_time + timedelta ( minutes = [number] , seconds = [number] ) ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : switchover_time + timedelta ( minutes = [number] , seconds = [number] ) } ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] def test_from_sunrise_to_sunset ( self ) : [EOL] [docstring] [EOL] test_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] sunrise = dt_util . as_local ( get_astral_event_date ( self . hass , [string] , dt_util . as_utc ( test_time ) ) ) [EOL] sunset = dt_util . as_local ( get_astral_event_date ( self . hass , [string] , dt_util . as_utc ( test_time ) ) ) [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] entity_id = [string] [EOL] testtime = sunrise + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = sunrise [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] testtime = sunrise + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] def test_from_sunset_to_sunrise ( self ) : [EOL] [docstring] [EOL] test_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] sunset = dt_util . as_local ( get_astral_event_date ( self . hass , [string] , test_time ) ) [EOL] sunrise = dt_util . as_local ( get_astral_event_next ( self . hass , [string] , sunset ) ) [EOL] [comment] [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] entity_id = [string] [EOL] testtime = sunset + timedelta ( minutes = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = sunset [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] testtime = sunset + timedelta ( minutes = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] testtime = sunrise + timedelta ( minutes = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] testtime = sunrise [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] self . hass . block_till_done ( ) [EOL] [comment] [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = sunrise + timedelta ( minutes = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] def test_offset ( self ) : [EOL] [docstring] [EOL] after = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) + timedelta ( hours = [number] , minutes = [number] ) [EOL] [EOL] before = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) + timedelta ( hours = [number] , minutes = [number] ) [EOL] [EOL] entity_id = [string] [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] testtime = after + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = after [EOL] with patch ( [string] , return_value = testtime ) : [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] testtime = before + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] testtime = before [EOL] with patch ( [string] , return_value = testtime ) : [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = before + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] def test_offset_overnight ( self ) : [EOL] [docstring] [EOL] after = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) + timedelta ( hours = [number] , minutes = [number] ) [EOL] entity_id = [string] [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] testtime = after + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = after [EOL] with patch ( [string] , return_value = testtime ) : [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] def test_norwegian_case_winter ( self ) : [EOL] [docstring] [EOL] self . hass . config . latitude = [number] [EOL] self . hass . config . longitude = [number] [EOL] [EOL] test_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] sunrise = dt_util . as_local ( get_astral_event_next ( self . hass , [string] , dt_util . as_utc ( test_time ) ) ) [EOL] sunset = dt_util . as_local ( get_astral_event_next ( self . hass , [string] , dt_util . as_utc ( test_time ) ) ) [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] entity_id = [string] [EOL] testtime = test_time [EOL] with patch ( [string] , return_value = testtime ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = sunrise + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = sunrise [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] testtime = sunrise + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] def test_norwegian_case_summer ( self ) : [EOL] [docstring] [EOL] self . hass . config . latitude = [number] [EOL] self . hass . config . longitude = [number] [EOL] [EOL] test_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] [EOL] sunrise = dt_util . as_local ( get_astral_event_next ( self . hass , [string] , dt_util . as_utc ( test_time ) ) ) [EOL] sunset = dt_util . as_local ( get_astral_event_next ( self . hass , [string] , dt_util . as_utc ( test_time ) ) ) [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] entity_id = [string] [EOL] testtime = test_time [EOL] with patch ( [string] , return_value = testtime ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = sunrise + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = sunrise [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] testtime = sunrise + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] def test_sun_offset ( self ) : [EOL] [docstring] [EOL] test_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] sunrise = dt_util . as_local ( get_astral_event_date ( self . hass , [string] , dt_util . as_utc ( test_time ) ) + timedelta ( hours = - [number] , minutes = - [number] ) ) [EOL] sunset = dt_util . as_local ( get_astral_event_date ( self . hass , [string] , dt_util . as_utc ( test_time ) ) + timedelta ( hours = [number] , minutes = [number] ) ) [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] entity_id = [string] [EOL] testtime = sunrise + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] testtime = sunrise [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] testtime = sunrise + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset + timedelta ( seconds = - [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] testtime = sunset + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_OFF [EOL] [EOL] test_time = test_time + timedelta ( days = [number] ) [EOL] sunrise = dt_util . as_local ( get_astral_event_date ( self . hass , [string] , dt_util . as_utc ( test_time ) ) + timedelta ( hours = - [number] , minutes = - [number] ) ) [EOL] testtime = sunrise [EOL] with patch ( [string] , return_value = testtime ) : [EOL] [EOL] self . hass . bus . fire ( ha . EVENT_TIME_CHANGED , { ha . ATTR_NOW : testtime } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( entity_id ) [EOL] assert state . state == STATE_ON [EOL] [EOL] def test_dst ( self ) : [EOL] [docstring] [EOL] self . hass . config . time_zone = pytz . timezone ( [string] ) [EOL] test_time = self . hass . config . time_zone . localize ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) . astimezone ( pytz . UTC ) [EOL] config = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] entity_id = [string] [EOL] testtime = test_time [EOL] with patch ( [string] , return_value = testtime ) : [EOL] setup_component ( self . hass , [string] , config ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( entity_id ) [EOL] state . attributes [ [string] ] == [string] [EOL] state . attributes [ [string] ] == [string] [EOL] state . attributes [ [string] ] == [string] [EOL] assert state . state == STATE_OFF [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Optional , Any [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components import cloud [EOL] from homeassistant . components . cloud import const [EOL] [EOL] from tests . common import mock_coro [EOL] [EOL] [EOL] async def mock_cloud ( hass , config = None ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , cloud . DOMAIN , { [string] : config or { } } ) [EOL] cloud_inst = hass . data [ [string] ] [EOL] with patch ( [string] , return_value = mock_coro ( ) ) : [EOL] await cloud_inst . start ( ) [EOL] [EOL] [EOL] def mock_cloud_prefs ( hass , prefs = { } ) : [EOL] [docstring] [EOL] prefs_to_set = { const . PREF_ENABLE_ALEXA : True , const . PREF_ENABLE_GOOGLE : True , const . PREF_GOOGLE_SECURE_DEVICES_PIN : None , } [EOL] prefs_to_set . update ( prefs ) [EOL] hass . data [ cloud . DOMAIN ] . client . _prefs . _prefs = prefs_to_set [EOL] return prefs_to_set [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import homeassistant [EOL] [docstring] [EOL] from unittest . mock import patch [EOL] [EOL] import jwt [EOL] import pytest [EOL] [EOL] from homeassistant . components . cloud import const , prefs [EOL] [EOL] from . import mock_cloud , mock_cloud_prefs [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def mock_user_data ( ) : [EOL] [docstring] [EOL] with patch ( [string] ) as writer : [EOL] yield writer [EOL] [EOL] [EOL] @ pytest . fixture def mock_cloud_fixture ( hass ) : [EOL] [docstring] [EOL] hass . loop . run_until_complete ( mock_cloud ( hass ) ) [EOL] return mock_cloud_prefs ( hass ) [EOL] [EOL] [EOL] @ pytest . fixture async def cloud_prefs ( hass ) : [EOL] [docstring] [EOL] cloud_prefs = prefs . CloudPreferences ( hass ) [EOL] await cloud_prefs . async_initialize ( ) [EOL] return cloud_prefs [EOL] [EOL] [EOL] @ pytest . fixture async def mock_cloud_setup ( hass ) : [EOL] [docstring] [EOL] await mock_cloud ( hass ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_cloud_login ( hass , mock_cloud_setup ) : [EOL] [docstring] [EOL] hass . data [ const . DOMAIN ] . id_token = jwt . encode ( { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import Mock [EOL] [EOL] from aiohttp . web_exceptions import ( HTTPInternalServerError , HTTPBadRequest , HTTPUnauthorized ) [EOL] import pytest [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . http . view import ( HomeAssistantView , request_handler_factory ) [EOL] from homeassistant . exceptions import ServiceNotFound , Unauthorized [EOL] [EOL] from tests . common import mock_coro_func [EOL] [EOL] [EOL] @ pytest . fixture def mock_request ( ) : [EOL] [docstring] [EOL] return Mock ( app = { [string] : Mock ( is_running = True ) } , match_info = { } , ) [EOL] [EOL] [EOL] async def test_invalid_json ( caplog ) : [EOL] [docstring] [EOL] view = HomeAssistantView ( ) [EOL] [EOL] with pytest . raises ( HTTPInternalServerError ) : [EOL] view . json ( float ( [string] ) ) [EOL] [EOL] assert str ( float ( [string] ) ) in caplog . text [EOL] [EOL] [EOL] async def test_handling_unauthorized ( mock_request ) : [EOL] [docstring] [EOL] with pytest . raises ( HTTPUnauthorized ) : [EOL] await request_handler_factory ( Mock ( requires_auth = False ) , mock_coro_func ( exception = Unauthorized ) ) ( mock_request ) [EOL] [EOL] [EOL] async def test_handling_invalid_data ( mock_request ) : [EOL] [docstring] [EOL] with pytest . raises ( HTTPBadRequest ) : [EOL] await request_handler_factory ( Mock ( requires_auth = False ) , mock_coro_func ( exception = vol . Invalid ( [string] ) ) ) ( mock_request ) [EOL] [EOL] [EOL] async def test_handling_service_not_found ( mock_request ) : [EOL] [docstring] [EOL] with pytest . raises ( HTTPInternalServerError ) : [EOL] await request_handler_factory ( Mock ( requires_auth = False ) , mock_coro_func ( exception = ServiceNotFound ( [string] , [string] ) ) ) ( mock_request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from unittest . mock import patch , Mock [EOL] [EOL] import aiohttp [EOL] import pytest [EOL] [EOL] from homeassistant . generated import ssdp as gn_ssdp [EOL] from homeassistant . components import ssdp [EOL] [EOL] from tests . common import mock_coro [EOL] [EOL] [EOL] async def test_scan_match_st ( hass ) : [EOL] [docstring] [EOL] scanner = ssdp . Scanner ( hass ) [EOL] [EOL] with patch ( [string] , return_value = [ Mock ( st = [string] , location = None ) ] ) , patch . dict ( gn_ssdp . SSDP [ [string] ] , { [string] : [ [string] ] } ) , patch . object ( hass . config_entries . flow , [string] , return_value = mock_coro ( ) ) as mock_init : [EOL] await scanner . async_scan ( None ) [EOL] [EOL] assert len ( mock_init . mock_calls ) == [number] [EOL] assert mock_init . mock_calls [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert mock_init . mock_calls [ [number] ] [ [number] ] [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] async def test_scan_match_manufacturer ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , text = [string] ) [EOL] scanner = ssdp . Scanner ( hass ) [EOL] [EOL] with patch ( [string] , return_value = [ Mock ( st = [string] , location = [string] ) ] ) , patch . dict ( gn_ssdp . SSDP [ [string] ] , { [string] : [ [string] ] } ) , patch . object ( hass . config_entries . flow , [string] , return_value = mock_coro ( ) ) as mock_init : [EOL] await scanner . async_scan ( None ) [EOL] [EOL] assert len ( mock_init . mock_calls ) == [number] [EOL] assert mock_init . mock_calls [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert mock_init . mock_calls [ [number] ] [ [number] ] [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] async def test_scan_match_device_type ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , text = [string] ) [EOL] scanner = ssdp . Scanner ( hass ) [EOL] [EOL] with patch ( [string] , return_value = [ Mock ( st = [string] , location = [string] ) ] ) , patch . dict ( gn_ssdp . SSDP [ [string] ] , { [string] : [ [string] ] } ) , patch . object ( hass . config_entries . flow , [string] , return_value = mock_coro ( ) ) as mock_init : [EOL] await scanner . async_scan ( None ) [EOL] [EOL] assert len ( mock_init . mock_calls ) == [number] [EOL] assert mock_init . mock_calls [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] assert mock_init . mock_calls [ [number] ] [ [number] ] [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ asyncio . TimeoutError , aiohttp . ClientError ] ) async def test_scan_description_fetch_fail ( hass , aioclient_mock , exc ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , exc = exc ) [EOL] scanner = ssdp . Scanner ( hass ) [EOL] [EOL] with patch ( [string] , return_value = [ Mock ( st = [string] , location = [string] ) ] ) : [EOL] await scanner . async_scan ( None ) [EOL] [EOL] [EOL] async def test_scan_description_parse_fail ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , text = [string] ) [EOL] scanner = ssdp . Scanner ( hass ) [EOL] [EOL] with patch ( [string] , return_value = [ Mock ( st = [string] , location = [string] ) ] ) : [EOL] await scanner . async_scan ( None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from datetime import timedelta [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . const import ( EVENT_HOMEASSISTANT_START , ATTR_ENTITY_ID ) [EOL] from homeassistant . components . utility_meter . const import ( SERVICE_RESET , SERVICE_SELECT_TARIFF , SERVICE_SELECT_NEXT_TARIFF , ATTR_TARIFF ) [EOL] from homeassistant . setup import async_setup_component [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . components . utility_meter . const import DOMAIN [EOL] from homeassistant . components . sensor import DOMAIN as SENSOR_DOMAIN [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def test_services ( hass ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] , } } } [EOL] [EOL] assert await async_setup_component ( hass , DOMAIN , config ) [EOL] assert await async_setup_component ( hass , SENSOR_DOMAIN , config ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] hass . bus . async_fire ( EVENT_HOMEASSISTANT_START ) [EOL] entity_id = config [ DOMAIN ] [ [string] ] [ [string] ] [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] now = dt_util . utcnow ( ) + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = now ) : [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } , force_update = True ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] [EOL] [comment] [EOL] data = { ATTR_ENTITY_ID : [string] } [EOL] await hass . services . async_call ( DOMAIN , SERVICE_SELECT_NEXT_TARIFF , data ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] now += timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = now ) : [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } , force_update = True ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] [EOL] [comment] [EOL] data = { ATTR_ENTITY_ID : [string] , ATTR_TARIFF : [string] } [EOL] await hass . services . async_call ( DOMAIN , SERVICE_SELECT_TARIFF , data ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] now += timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = now ) : [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } , force_update = True ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] [EOL] [comment] [EOL] data = { ATTR_ENTITY_ID : [string] } [EOL] await hass . services . async_call ( DOMAIN , SERVICE_RESET , data ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import logging [EOL] import unittest [EOL] [docstring] [EOL] import logging [EOL] [EOL] from datetime import timedelta [EOL] from unittest . mock import patch [EOL] from contextlib import contextmanager [EOL] [EOL] from tests . common import async_fire_time_changed [EOL] from homeassistant . const import EVENT_HOMEASSISTANT_START , ATTR_ENTITY_ID [EOL] from homeassistant . setup import async_setup_component [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . components . utility_meter . const import ( DOMAIN , SERVICE_SELECT_TARIFF , ATTR_TARIFF ) [EOL] from homeassistant . components . sensor import DOMAIN as SENSOR_DOMAIN [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ contextmanager def alter_time ( retval ) : [EOL] [docstring] [EOL] patch1 = patch ( [string] , return_value = retval ) [EOL] patch2 = patch ( [string] , return_value = retval ) [EOL] [EOL] with patch1 , patch2 : [EOL] yield [EOL] [EOL] [EOL] async def test_state ( hass ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : { [string] : [string] , [string] : [ [string] , [string] , [string] ] } , } } [EOL] [EOL] assert await async_setup_component ( hass , DOMAIN , config ) [EOL] assert await async_setup_component ( hass , SENSOR_DOMAIN , config ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] hass . bus . async_fire ( EVENT_HOMEASSISTANT_START ) [EOL] entity_id = config [ DOMAIN ] [ [string] ] [ [string] ] [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] now = dt_util . utcnow ( ) + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = now ) : [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } , force_update = True ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . state == [string] [EOL] [EOL] await hass . services . async_call ( DOMAIN , SERVICE_SELECT_TARIFF , { ATTR_ENTITY_ID : [string] , ATTR_TARIFF : [string] } , blocking = True ) [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] now = dt_util . utcnow ( ) + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = now ) : [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } , force_update = True ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . state == [string] [EOL] [EOL] [EOL] async def test_net_consumption ( hass ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : { [string] : [string] , [string] : True } } } [EOL] [EOL] assert await async_setup_component ( hass , DOMAIN , config ) [EOL] assert await async_setup_component ( hass , SENSOR_DOMAIN , config ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] hass . bus . async_fire ( EVENT_HOMEASSISTANT_START ) [EOL] entity_id = config [ DOMAIN ] [ [string] ] [ [string] ] [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] now = dt_util . utcnow ( ) + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = now ) : [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } , force_update = True ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] [EOL] assert state . state == [string] [EOL] [EOL] [EOL] async def test_non_net_consumption ( hass ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : { [string] : [string] , [string] : False } } } [EOL] [EOL] assert await async_setup_component ( hass , DOMAIN , config ) [EOL] assert await async_setup_component ( hass , SENSOR_DOMAIN , config ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] hass . bus . async_fire ( EVENT_HOMEASSISTANT_START ) [EOL] entity_id = config [ DOMAIN ] [ [string] ] [ [string] ] [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] now = dt_util . utcnow ( ) + timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = now ) : [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } , force_update = True ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] [EOL] assert state . state == [string] [EOL] [EOL] [EOL] def gen_config ( cycle , offset = None ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : { [string] : [string] , [string] : cycle } } } [EOL] [EOL] if offset : [EOL] config [ [string] ] [ [string] ] [ [string] ] = { [string] : offset . days , [string] : offset . seconds } [EOL] return config [EOL] [EOL] [EOL] async def _test_self_reset ( hass , config , start_time , expect_reset = True ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , DOMAIN , config ) [EOL] assert await async_setup_component ( hass , SENSOR_DOMAIN , config ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] hass . bus . async_fire ( EVENT_HOMEASSISTANT_START ) [EOL] entity_id = config [ DOMAIN ] [ [string] ] [ [string] ] [EOL] [EOL] now = dt_util . parse_datetime ( start_time ) [EOL] with alter_time ( now ) : [EOL] async_fire_time_changed ( hass , now ) [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] now += timedelta ( seconds = [number] ) [EOL] with alter_time ( now ) : [EOL] async_fire_time_changed ( hass , now ) [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } , force_update = True ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] now += timedelta ( seconds = [number] ) [EOL] with alter_time ( now ) : [EOL] async_fire_time_changed ( hass , now ) [EOL] await hass . async_block_till_done ( ) [EOL] hass . states . async_set ( entity_id , [number] , { [string] : [string] } , force_update = True ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] if expect_reset : [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] assert state . state == [string] [EOL] else : [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] assert state . state == [string] [EOL] [EOL] [EOL] async def test_self_reset_hourly ( hass ) : [EOL] [docstring] [EOL] await _test_self_reset ( hass , gen_config ( [string] ) , [string] ) [EOL] [EOL] [EOL] async def test_self_reset_daily ( hass ) : [EOL] [docstring] [EOL] await _test_self_reset ( hass , gen_config ( [string] ) , [string] ) [EOL] [EOL] [EOL] async def test_self_reset_weekly ( hass ) : [EOL] [docstring] [EOL] await _test_self_reset ( hass , gen_config ( [string] ) , [string] ) [EOL] [EOL] [EOL] async def test_self_reset_monthly ( hass ) : [EOL] [docstring] [EOL] await _test_self_reset ( hass , gen_config ( [string] ) , [string] ) [EOL] [EOL] [EOL] async def test_self_reset_yearly ( hass ) : [EOL] [docstring] [EOL] await _test_self_reset ( hass , gen_config ( [string] ) , [string] ) [EOL] [EOL] [EOL] async def test_self_no_reset_yearly ( hass ) : [EOL] [docstring] [EOL] await _test_self_reset ( hass , gen_config ( [string] ) , [string] , expect_reset = False ) [EOL] [EOL] [EOL] async def test_reset_yearly_offset ( hass ) : [EOL] [docstring] [EOL] await _test_self_reset ( hass , gen_config ( [string] , timedelta ( days = [number] , minutes = [number] ) ) , [string] ) [EOL] [EOL] [EOL] async def test_no_reset_yearly_offset ( hass ) : [EOL] [docstring] [EOL] await _test_self_reset ( hass , gen_config ( [string] , timedelta ( [number] ) ) , [string] , expect_reset = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import requests [EOL] [EOL] from homeassistant . components . fritzbox . climate import FritzboxThermostat [EOL] [EOL] [EOL] class TestFritzboxClimate ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . device = Mock ( ) [EOL] self . device . name = [string] [EOL] self . device . actual_temperature = [number] [EOL] self . device . target_temperature = [number] [EOL] self . device . comfort_temperature = [number] [EOL] self . device . eco_temperature = [number] [EOL] self . device . present = True [EOL] self . device . device_lock = True [EOL] self . device . lock = False [EOL] self . device . battery_low = True [EOL] self . device . set_target_temperature = Mock ( ) [EOL] self . device . update = Mock ( ) [EOL] mock_fritz = Mock ( ) [EOL] mock_fritz . login = Mock ( ) [EOL] self . thermostat = FritzboxThermostat ( self . device , mock_fritz ) [EOL] [EOL] def test_init ( self ) : [EOL] [docstring] [EOL] assert [number] == self . thermostat . _current_temperature [EOL] assert [number] == self . thermostat . _target_temperature [EOL] assert [number] == self . thermostat . _comfort_temperature [EOL] assert [number] == self . thermostat . _eco_temperature [EOL] [EOL] def test_supported_features ( self ) : [EOL] [docstring] [EOL] assert [number] == self . thermostat . supported_features [EOL] [EOL] def test_available ( self ) : [EOL] [docstring] [EOL] assert self . thermostat . available [EOL] self . thermostat . _device . present = False [EOL] assert not self . thermostat . available [EOL] [EOL] def test_name ( self ) : [EOL] [docstring] [EOL] assert [string] == self . thermostat . name [EOL] [EOL] def test_temperature_unit ( self ) : [EOL] [docstring] [EOL] assert [string] == self . thermostat . temperature_unit [EOL] [EOL] def test_precision ( self ) : [EOL] [docstring] [EOL] assert [number] == self . thermostat . precision [EOL] [EOL] def test_current_temperature ( self ) : [EOL] [docstring] [EOL] assert [number] == self . thermostat . current_temperature [EOL] [EOL] def test_target_temperature ( self ) : [EOL] [docstring] [EOL] assert [number] == self . thermostat . target_temperature [EOL] [EOL] self . thermostat . _target_temperature = [number] [EOL] assert self . thermostat . target_temperature is None [EOL] [EOL] self . thermostat . _target_temperature = [number] [EOL] assert self . thermostat . target_temperature is None [EOL] [EOL] @ patch . object ( FritzboxThermostat , [string] ) def test_set_temperature_operation_mode ( self , mock_set_op ) : [EOL] [docstring] [EOL] self . thermostat . set_temperature ( operation_mode = [string] ) [EOL] mock_set_op . assert_called_once_with ( [string] ) [EOL] [EOL] def test_set_temperature_temperature ( self ) : [EOL] [docstring] [EOL] self . thermostat . set_temperature ( temperature = [number] ) [EOL] self . thermostat . _device . set_target_temperature . assert_called_once_with ( [number] ) [EOL] [EOL] @ patch . object ( FritzboxThermostat , [string] ) def test_set_temperature_none ( self , mock_set_op ) : [EOL] [docstring] [EOL] self . thermostat . set_temperature ( ) [EOL] mock_set_op . assert_not_called ( ) [EOL] self . thermostat . _device . set_target_temperature . assert_not_called ( ) [EOL] [EOL] @ patch . object ( FritzboxThermostat , [string] ) def test_set_temperature_operation_mode_precedence ( self , mock_set_op ) : [EOL] [docstring] [EOL] self . thermostat . set_temperature ( operation_mode = [string] , temperature = [number] ) [EOL] mock_set_op . assert_called_once_with ( [string] ) [EOL] self . thermostat . _device . set_target_temperature . assert_not_called ( ) [EOL] [EOL] def test_current_operation ( self ) : [EOL] [docstring] [EOL] self . thermostat . _target_temperature = [number] [EOL] assert [string] == self . thermostat . current_operation [EOL] self . thermostat . _target_temperature = [number] [EOL] assert [string] == self . thermostat . current_operation [EOL] self . thermostat . _target_temperature = [number] [EOL] assert [string] == self . thermostat . current_operation [EOL] self . thermostat . _target_temperature = [number] [EOL] assert [string] == self . thermostat . current_operation [EOL] self . thermostat . _target_temperature = [number] [EOL] assert [string] == self . thermostat . current_operation [EOL] [EOL] def test_operation_list ( self ) : [EOL] [docstring] [EOL] assert [ [string] , [string] , [string] , [string] ] == self . thermostat . operation_list [EOL] [EOL] @ patch . object ( FritzboxThermostat , [string] ) def test_set_operation_mode ( self , mock_set_temp ) : [EOL] [docstring] [EOL] values = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] for mode , temp in values . items ( ) : [EOL] print ( mode , temp ) [EOL] [EOL] mock_set_temp . reset_mock ( ) [EOL] self . thermostat . set_operation_mode ( mode ) [EOL] mock_set_temp . assert_called_once_with ( temperature = temp ) [EOL] [EOL] mock_set_temp . reset_mock ( ) [EOL] self . thermostat . set_operation_mode ( [string] ) [EOL] mock_set_temp . assert_not_called ( ) [EOL] [EOL] def test_min_max_temperature ( self ) : [EOL] [docstring] [EOL] assert [number] == self . thermostat . min_temp [EOL] assert [number] == self . thermostat . max_temp [EOL] [EOL] def test_device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = self . thermostat . device_state_attributes [EOL] assert attr [ [string] ] is True [EOL] assert attr [ [string] ] is False [EOL] assert attr [ [string] ] is True [EOL] [EOL] def test_update ( self ) : [EOL] [docstring] [EOL] device = Mock ( ) [EOL] device . update = Mock ( ) [EOL] device . actual_temperature = [number] [EOL] device . target_temperature = [number] [EOL] device . comfort_temperature = [number] [EOL] device . eco_temperature = [number] [EOL] self . thermostat . _device = device [EOL] [EOL] self . thermostat . update ( ) [EOL] [EOL] device . update . assert_called_once_with ( ) [EOL] assert [number] == self . thermostat . _current_temperature [EOL] assert [number] == self . thermostat . _target_temperature [EOL] assert [number] == self . thermostat . _comfort_temperature [EOL] assert [number] == self . thermostat . _eco_temperature [EOL] [EOL] def test_update_http_error ( self ) : [EOL] [docstring] [EOL] self . device . update . side_effect = requests . exceptions . HTTPError [EOL] self . thermostat . update ( ) [EOL] self . thermostat . _fritz . login . assert_called_once_with ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components . websocket_api . const import TYPE_RESULT [EOL] from homeassistant . helpers import device_registry [EOL] [EOL] [EOL] from tests . common import ( MockConfigEntry , mock_device_registry , mock_registry ) [EOL] [EOL] [EOL] @ pytest . fixture def device_reg ( hass ) : [EOL] [docstring] [EOL] return mock_device_registry ( hass ) [EOL] [EOL] [EOL] @ pytest . fixture def entity_reg ( hass ) : [EOL] [docstring] [EOL] return mock_registry ( hass ) [EOL] [EOL] [EOL] def _same_triggers ( a , b ) : [EOL] if len ( a ) != len ( b ) : [EOL] return False [EOL] [EOL] for d in a : [EOL] if d not in b : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] async def test_websocket_get_triggers ( hass , hass_ws_client , device_reg , entity_reg ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { } ) [EOL] config_entry = MockConfigEntry ( domain = [string] , data = { } ) [EOL] config_entry . add_to_hass ( hass ) [EOL] device_entry = device_reg . async_get_or_create ( config_entry_id = config_entry . entry_id , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } ) [EOL] entity_reg . async_get_or_create ( [string] , [string] , [string] , device_id = device_entry . id ) [EOL] expected_triggers = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : device_entry . id , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : device_entry . id , [string] : [string] } , ] [EOL] [EOL] client = await hass_ws_client ( hass ) [EOL] await client . send_json ( { [string] : [number] , [string] : [string] , [string] : device_entry . id } ) [EOL] msg = await client . receive_json ( ) [EOL] [EOL] assert msg [ [string] ] == [number] [EOL] assert msg [ [string] ] == TYPE_RESULT [EOL] assert msg [ [string] ] [EOL] triggers = msg [ [string] ] [ [string] ] [EOL] assert _same_triggers ( triggers , expected_triggers ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from homeassistant . bootstrap import async_setup_component [EOL] [EOL] from tests . common import assert_setup_component [EOL] from . test_auth import test_auth_via_msg [EOL] [EOL] [EOL] async def test_websocket_api ( hass , no_auth_websocket_client , legacy_auth ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] ) : [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , } } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] [EOL] await test_auth_via_msg ( no_auth_websocket_client , legacy_auth ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] [EOL] await no_auth_websocket_client . close ( ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components import websocket_api [EOL] from homeassistant . components . websocket_api import const [EOL] [EOL] [EOL] async def test_send_big_result ( hass , websocket_client ) : [EOL] [docstring] [EOL] @ websocket_api . websocket_command ( { [string] : [string] } ) @ websocket_api . async_response async def send_big_result ( hass , connection , msg ) : [EOL] await connection . send_big_result ( msg [ [string] ] , { [string] : [string] } ) [EOL] [EOL] hass . components . websocket_api . async_register_command ( send_big_result ) [EOL] [EOL] await websocket_client . send_json ( { [string] : [number] , [string] : [string] , } ) [EOL] [EOL] msg = await websocket_client . receive_json ( ) [EOL] assert msg [ [string] ] == [number] [EOL] assert msg [ [string] ] == const . TYPE_RESULT [EOL] assert msg [ [string] ] [EOL] assert msg [ [string] ] == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] API_PASSWORD = [string] [EOL]	0 0 $builtins.str$ 0 0 0
import builtins [EOL] from typing import Dict , Union , Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import copy [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import httplib2 [EOL] import pytest [EOL] [EOL] from homeassistant . components . google import ( CONF_CAL_ID , CONF_CLIENT_ID , CONF_CLIENT_SECRET , CONF_DEVICE_ID , CONF_ENTITIES , CONF_NAME , CONF_TRACK , DEVICE_SCHEMA , SERVICE_SCAN_CALENDARS , do_setup ) [EOL] from homeassistant . const import STATE_OFF , STATE_ON [EOL] from homeassistant . helpers . template import DATE_STR_FORMAT [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . util import slugify [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] from tests . common import async_mock_service [EOL] [EOL] GOOGLE_CONFIG = { CONF_CLIENT_ID : [string] , CONF_CLIENT_SECRET : [string] , } [EOL] TEST_ENTITY = [string] [EOL] TEST_ENTITY_NAME = [string] [EOL] [EOL] TEST_EVENT = { [string] : [string] , [string] : { } , [string] : { } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : True } , [string] : { [string] : [string] , [string] : [string] , [string] : True } , [string] : [number] , [string] : { [string] : [string] , [string] : [string] , [string] : True } , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def get_calendar_info ( calendar ) : [EOL] [docstring] [EOL] calendar_info = DEVICE_SCHEMA ( { CONF_CAL_ID : calendar [ [string] ] , CONF_ENTITIES : [ { CONF_TRACK : calendar [ [string] ] , CONF_NAME : calendar [ [string] ] , CONF_DEVICE_ID : slugify ( calendar [ [string] ] ) , } ] } ) [EOL] return calendar_info [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def mock_google_setup ( hass , test_calendar ) : [EOL] [docstring] [EOL] hass . loop . run_until_complete ( async_setup_component ( hass , [string] , { [string] : { } } ) ) [EOL] calendar = get_calendar_info ( test_calendar ) [EOL] calendars = { calendar [ CONF_CAL_ID ] : calendar } [EOL] patch_google_auth = patch ( [string] , side_effect = do_setup ) [EOL] patch_google_load = patch ( [string] , return_value = calendars ) [EOL] patch_google_services = patch ( [string] ) [EOL] async_mock_service ( hass , [string] , SERVICE_SCAN_CALENDARS ) [EOL] [EOL] with patch_google_auth , patch_google_load , patch_google_services : [EOL] yield [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def mock_http ( hass ) : [EOL] [docstring] [EOL] hass . http = Mock ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def set_time_zone ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] dt_util . set_default_time_zone ( dt_util . get_time_zone ( [string] ) ) [EOL] yield [EOL] dt_util . set_default_time_zone ( dt_util . get_time_zone ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def mock_google_service ( ) : [EOL] [docstring] [EOL] patch_google_service = patch ( [string] ) [EOL] with patch_google_service as mock_service : [EOL] yield mock_service [EOL] [EOL] [EOL] async def test_all_day_event ( hass , mock_next_event ) : [EOL] [docstring] [EOL] week_from_today = ( dt_util . dt . date . today ( ) + dt_util . dt . timedelta ( days = [number] ) ) [EOL] end_event = week_from_today + dt_util . dt . timedelta ( days = [number] ) [EOL] event = copy . deepcopy ( TEST_EVENT ) [EOL] start = week_from_today . isoformat ( ) [EOL] end = end_event . isoformat ( ) [EOL] event [ [string] ] [ [string] ] = start [EOL] event [ [string] ] [ [string] ] = end [EOL] mock_next_event . return_value . event = event [EOL] [EOL] assert await async_setup_component ( hass , [string] , { [string] : GOOGLE_CONFIG } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( TEST_ENTITY ) [EOL] assert state . name == TEST_ENTITY_NAME [EOL] assert state . state == STATE_OFF [EOL] assert dict ( state . attributes ) == { [string] : TEST_ENTITY_NAME , [string] : event [ [string] ] , [string] : True , [string] : False , [string] : week_from_today . strftime ( DATE_STR_FORMAT ) , [string] : end_event . strftime ( DATE_STR_FORMAT ) , [string] : event [ [string] ] , [string] : event [ [string] ] , } [EOL] [EOL] [EOL] async def test_future_event ( hass , mock_next_event ) : [EOL] [docstring] [EOL] one_hour_from_now = dt_util . now ( ) + dt_util . dt . timedelta ( minutes = [number] ) [EOL] end_event = one_hour_from_now + dt_util . dt . timedelta ( minutes = [number] ) [EOL] start = one_hour_from_now . isoformat ( ) [EOL] end = end_event . isoformat ( ) [EOL] event = copy . deepcopy ( TEST_EVENT ) [EOL] event [ [string] ] [ [string] ] = start [EOL] event [ [string] ] [ [string] ] = end [EOL] mock_next_event . return_value . event = event [EOL] [EOL] assert await async_setup_component ( hass , [string] , { [string] : GOOGLE_CONFIG } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( TEST_ENTITY ) [EOL] assert state . name == TEST_ENTITY_NAME [EOL] assert state . state == STATE_OFF [EOL] assert dict ( state . attributes ) == { [string] : TEST_ENTITY_NAME , [string] : event [ [string] ] , [string] : False , [string] : False , [string] : one_hour_from_now . strftime ( DATE_STR_FORMAT ) , [string] : end_event . strftime ( DATE_STR_FORMAT ) , [string] : event [ [string] ] , [string] : event [ [string] ] , } [EOL] [EOL] [EOL] async def test_in_progress_event ( hass , mock_next_event ) : [EOL] [docstring] [EOL] middle_of_event = dt_util . now ( ) - dt_util . dt . timedelta ( minutes = [number] ) [EOL] end_event = middle_of_event + dt_util . dt . timedelta ( minutes = [number] ) [EOL] start = middle_of_event . isoformat ( ) [EOL] end = end_event . isoformat ( ) [EOL] event = copy . deepcopy ( TEST_EVENT ) [EOL] event [ [string] ] [ [string] ] = start [EOL] event [ [string] ] [ [string] ] = end [EOL] mock_next_event . return_value . event = event [EOL] [EOL] assert await async_setup_component ( hass , [string] , { [string] : GOOGLE_CONFIG } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( TEST_ENTITY ) [EOL] assert state . name == TEST_ENTITY_NAME [EOL] assert state . state == STATE_ON [EOL] assert dict ( state . attributes ) == { [string] : TEST_ENTITY_NAME , [string] : event [ [string] ] , [string] : False , [string] : False , [string] : middle_of_event . strftime ( DATE_STR_FORMAT ) , [string] : end_event . strftime ( DATE_STR_FORMAT ) , [string] : event [ [string] ] , [string] : event [ [string] ] , } [EOL] [EOL] [EOL] async def test_offset_in_progress_event ( hass , mock_next_event ) : [EOL] [docstring] [EOL] middle_of_event = dt_util . now ( ) + dt_util . dt . timedelta ( minutes = [number] ) [EOL] end_event = middle_of_event + dt_util . dt . timedelta ( minutes = [number] ) [EOL] start = middle_of_event . isoformat ( ) [EOL] end = end_event . isoformat ( ) [EOL] event_summary = [string] [EOL] event = copy . deepcopy ( TEST_EVENT ) [EOL] event [ [string] ] [ [string] ] = start [EOL] event [ [string] ] [ [string] ] = end [EOL] event [ [string] ] = [string] . format ( event_summary ) [EOL] mock_next_event . return_value . event = event [EOL] [EOL] assert await async_setup_component ( hass , [string] , { [string] : GOOGLE_CONFIG } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( TEST_ENTITY ) [EOL] assert state . name == TEST_ENTITY_NAME [EOL] assert state . state == STATE_OFF [EOL] assert dict ( state . attributes ) == { [string] : TEST_ENTITY_NAME , [string] : event_summary , [string] : False , [string] : True , [string] : middle_of_event . strftime ( DATE_STR_FORMAT ) , [string] : end_event . strftime ( DATE_STR_FORMAT ) , [string] : event [ [string] ] , [string] : event [ [string] ] , } [EOL] [EOL] [EOL] @ pytest . mark . skip async def test_all_day_offset_in_progress_event ( hass , mock_next_event ) : [EOL] [docstring] [EOL] tomorrow = dt_util . dt . date . today ( ) + dt_util . dt . timedelta ( days = [number] ) [EOL] end_event = tomorrow + dt_util . dt . timedelta ( days = [number] ) [EOL] start = tomorrow . isoformat ( ) [EOL] end = end_event . isoformat ( ) [EOL] event_summary = [string] [EOL] event = copy . deepcopy ( TEST_EVENT ) [EOL] event [ [string] ] [ [string] ] = start [EOL] event [ [string] ] [ [string] ] = end [EOL] event [ [string] ] = [string] . format ( event_summary ) [EOL] mock_next_event . return_value . event = event [EOL] [EOL] assert await async_setup_component ( hass , [string] , { [string] : GOOGLE_CONFIG } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( TEST_ENTITY ) [EOL] assert state . name == TEST_ENTITY_NAME [EOL] assert state . state == STATE_OFF [EOL] assert dict ( state . attributes ) == { [string] : TEST_ENTITY_NAME , [string] : event_summary , [string] : True , [string] : True , [string] : tomorrow . strftime ( DATE_STR_FORMAT ) , [string] : end_event . strftime ( DATE_STR_FORMAT ) , [string] : event [ [string] ] , [string] : event [ [string] ] , } [EOL] [EOL] [EOL] async def test_all_day_offset_event ( hass , mock_next_event ) : [EOL] [docstring] [EOL] tomorrow = dt_util . dt . date . today ( ) + dt_util . dt . timedelta ( days = [number] ) [EOL] end_event = tomorrow + dt_util . dt . timedelta ( days = [number] ) [EOL] start = tomorrow . isoformat ( ) [EOL] end = end_event . isoformat ( ) [EOL] offset_hours = ( [number] + dt_util . now ( ) . hour ) [EOL] event_summary = [string] [EOL] event = copy . deepcopy ( TEST_EVENT ) [EOL] event [ [string] ] [ [string] ] = start [EOL] event [ [string] ] [ [string] ] = end [EOL] event [ [string] ] = [string] . format ( event_summary , offset_hours ) [EOL] mock_next_event . return_value . event = event [EOL] [EOL] assert await async_setup_component ( hass , [string] , { [string] : GOOGLE_CONFIG } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( TEST_ENTITY ) [EOL] assert state . name == TEST_ENTITY_NAME [EOL] assert state . state == STATE_OFF [EOL] assert dict ( state . attributes ) == { [string] : TEST_ENTITY_NAME , [string] : event_summary , [string] : True , [string] : False , [string] : tomorrow . strftime ( DATE_STR_FORMAT ) , [string] : end_event . strftime ( DATE_STR_FORMAT ) , [string] : event [ [string] ] , [string] : event [ [string] ] , } [EOL] [EOL] [EOL] async def test_update_false ( hass , google_service ) : [EOL] [docstring] [EOL] google_service . return_value . get = Mock ( side_effect = httplib2 . ServerNotFoundError ( [string] ) ) [EOL] assert await async_setup_component ( hass , [string] , { [string] : GOOGLE_CONFIG } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( TEST_ENTITY ) [EOL] assert state . name == TEST_ENTITY_NAME [EOL] assert state . state == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.bool],typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] TEST_CALENDAR = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : True , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ ] , [string] : True } [EOL] [EOL] [EOL] @ pytest . fixture def test_calendar ( ) : [EOL] [docstring] [EOL] return TEST_CALENDAR [EOL] [EOL] [EOL] @ pytest . fixture def mock_next_event ( ) : [EOL] [docstring] [EOL] patch_google_cal = patch ( [string] ) [EOL] with patch_google_cal as google_cal_data : [EOL] yield google_cal_data [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from homeassistant . components . fan import ( ATTR_DIRECTION , ATTR_SPEED , ATTR_OSCILLATING , DOMAIN , SERVICE_OSCILLATE , SERVICE_SET_DIRECTION , SERVICE_SET_SPEED ) [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , SERVICE_TURN_ON , SERVICE_TURN_OFF ) [EOL] [EOL] [EOL] async def async_turn_on ( hass , entity_id = None , speed = None ) : [EOL] [docstring] [EOL] data = { key : value for key , value in [ ( ATTR_ENTITY_ID , entity_id ) , ( ATTR_SPEED , speed ) , ] if value is not None } [EOL] [EOL] await hass . services . async_call ( DOMAIN , SERVICE_TURN_ON , data , blocking = True ) [EOL] [EOL] [EOL] async def async_turn_off ( hass , entity_id = None ) : [EOL] [docstring] [EOL] data = { ATTR_ENTITY_ID : entity_id } if entity_id else { } [EOL] [EOL] await hass . services . async_call ( DOMAIN , SERVICE_TURN_OFF , data , blocking = True ) [EOL] [EOL] [EOL] async def async_oscillate ( hass , entity_id = None , should_oscillate = True ) : [EOL] [docstring] [EOL] data = { key : value for key , value in [ ( ATTR_ENTITY_ID , entity_id ) , ( ATTR_OSCILLATING , should_oscillate ) , ] if value is not None } [EOL] [EOL] await hass . services . async_call ( DOMAIN , SERVICE_OSCILLATE , data , blocking = True ) [EOL] [EOL] [EOL] async def async_set_speed ( hass , entity_id = None , speed = None ) : [EOL] [docstring] [EOL] data = { key : value for key , value in [ ( ATTR_ENTITY_ID , entity_id ) , ( ATTR_SPEED , speed ) , ] if value is not None } [EOL] [EOL] await hass . services . async_call ( DOMAIN , SERVICE_SET_SPEED , data , blocking = True ) [EOL] [EOL] [EOL] async def async_set_direction ( hass , entity_id = None , direction = None ) : [EOL] [docstring] [EOL] data = { key : value for key , value in [ ( ATTR_ENTITY_ID , entity_id ) , ( ATTR_DIRECTION , direction ) , ] if value is not None } [EOL] [EOL] await hass . services . async_call ( DOMAIN , SERVICE_SET_DIRECTION , data , blocking = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . components . media_player import async_reproduce_states [EOL] from homeassistant . components . media_player . const import ( ATTR_INPUT_SOURCE , ATTR_MEDIA_CONTENT_ID , ATTR_MEDIA_CONTENT_TYPE , ATTR_MEDIA_ENQUEUE , ATTR_MEDIA_SEEK_POSITION , ATTR_MEDIA_VOLUME_LEVEL , ATTR_MEDIA_VOLUME_MUTED , ATTR_SOUND_MODE , DOMAIN , SERVICE_PLAY_MEDIA , SERVICE_SELECT_SOUND_MODE , SERVICE_SELECT_SOURCE ) [EOL] from homeassistant . const import ( SERVICE_MEDIA_PAUSE , SERVICE_MEDIA_PLAY , SERVICE_MEDIA_SEEK , SERVICE_MEDIA_STOP , SERVICE_TURN_OFF , SERVICE_TURN_ON , SERVICE_VOLUME_MUTE , SERVICE_VOLUME_SET , STATE_IDLE , STATE_OFF , STATE_ON , STATE_PAUSED , STATE_PLAYING ) [EOL] from homeassistant . core import Context , State [EOL] [EOL] from tests . common import async_mock_service [EOL] [EOL] ENTITY_1 = [string] [EOL] ENTITY_2 = [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( SERVICE_TURN_ON , STATE_ON ) , ( SERVICE_TURN_OFF , STATE_OFF ) , ( SERVICE_MEDIA_PLAY , STATE_PLAYING ) , ( SERVICE_MEDIA_STOP , STATE_IDLE ) , ( SERVICE_MEDIA_PAUSE , STATE_PAUSED ) , ] ) async def test_state ( hass , service , state ) : [EOL] [docstring] [EOL] calls_1 = async_mock_service ( hass , DOMAIN , service ) [EOL] [EOL] await async_reproduce_states ( hass , [ State ( ENTITY_1 , state ) ] ) [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls_1 ) == [number] [EOL] assert calls_1 [ [number] ] . data == { [string] : ENTITY_1 } [EOL] [EOL] [EOL] async def test_turn_on_with_mode ( hass ) : [EOL] [docstring] [EOL] calls_1 = async_mock_service ( hass , DOMAIN , SERVICE_TURN_ON ) [EOL] calls_2 = async_mock_service ( hass , DOMAIN , SERVICE_SELECT_SOUND_MODE ) [EOL] [EOL] await async_reproduce_states ( hass , [ State ( ENTITY_1 , [string] , { ATTR_SOUND_MODE : [string] } ) ] ) [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls_1 ) == [number] [EOL] assert calls_1 [ [number] ] . data == { [string] : ENTITY_1 } [EOL] [EOL] assert len ( calls_2 ) == [number] [EOL] assert calls_2 [ [number] ] . data == { [string] : ENTITY_1 , ATTR_SOUND_MODE : [string] } [EOL] [EOL] [EOL] async def test_multiple_same_state ( hass ) : [EOL] [docstring] [EOL] calls_1 = async_mock_service ( hass , DOMAIN , SERVICE_TURN_ON ) [EOL] [EOL] await async_reproduce_states ( hass , [ State ( ENTITY_1 , [string] ) , State ( ENTITY_2 , [string] ) , ] ) [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls_1 ) == [number] [EOL] [comment] [EOL] assert any ( call . data == { [string] : [string] } for call in calls_1 ) [EOL] assert any ( call . data == { [string] : [string] } for call in calls_1 ) [EOL] [EOL] [EOL] async def test_multiple_different_state ( hass ) : [EOL] [docstring] [EOL] calls_1 = async_mock_service ( hass , DOMAIN , SERVICE_TURN_ON ) [EOL] calls_2 = async_mock_service ( hass , DOMAIN , SERVICE_TURN_OFF ) [EOL] [EOL] await async_reproduce_states ( hass , [ State ( ENTITY_1 , [string] ) , State ( ENTITY_2 , [string] ) , ] ) [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls_1 ) == [number] [EOL] assert calls_1 [ [number] ] . data == { [string] : [string] } [EOL] assert len ( calls_2 ) == [number] [EOL] assert calls_2 [ [number] ] . data == { [string] : [string] } [EOL] [EOL] [EOL] async def test_state_with_context ( hass ) : [EOL] [docstring] [EOL] calls = async_mock_service ( hass , DOMAIN , SERVICE_TURN_ON ) [EOL] [EOL] context = Context ( ) [EOL] [EOL] await async_reproduce_states ( hass , [ State ( ENTITY_1 , [string] ) ] , context ) [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls ) == [number] [EOL] assert calls [ [number] ] . data == { [string] : ENTITY_1 } [EOL] assert calls [ [number] ] . context == context [EOL] [EOL] [EOL] async def test_attribute_no_state ( hass ) : [EOL] [docstring] [EOL] calls_1 = async_mock_service ( hass , DOMAIN , SERVICE_TURN_ON ) [EOL] calls_2 = async_mock_service ( hass , DOMAIN , SERVICE_TURN_OFF ) [EOL] calls_3 = async_mock_service ( hass , DOMAIN , SERVICE_SELECT_SOUND_MODE ) [EOL] [EOL] value = [string] [EOL] [EOL] await async_reproduce_states ( hass , [ State ( ENTITY_1 , None , { ATTR_SOUND_MODE : value } ) ] ) [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls_1 ) == [number] [EOL] assert len ( calls_2 ) == [number] [EOL] assert len ( calls_3 ) == [number] [EOL] assert calls_3 [ [number] ] . data == { [string] : ENTITY_1 , ATTR_SOUND_MODE : value } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( SERVICE_VOLUME_SET , ATTR_MEDIA_VOLUME_LEVEL ) , ( SERVICE_VOLUME_MUTE , ATTR_MEDIA_VOLUME_MUTED ) , ( SERVICE_MEDIA_SEEK , ATTR_MEDIA_SEEK_POSITION ) , ( SERVICE_SELECT_SOURCE , ATTR_INPUT_SOURCE ) , ( SERVICE_SELECT_SOUND_MODE , ATTR_SOUND_MODE ) , ] ) async def test_attribute ( hass , service , attribute ) : [EOL] [docstring] [EOL] calls_1 = async_mock_service ( hass , DOMAIN , service ) [EOL] [EOL] value = [string] [EOL] [EOL] await async_reproduce_states ( hass , [ State ( ENTITY_1 , None , { attribute : value } ) ] ) [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls_1 ) == [number] [EOL] assert calls_1 [ [number] ] . data == { [string] : ENTITY_1 , attribute : value } [EOL] [EOL] [EOL] async def test_play_media ( hass ) : [EOL] [docstring] [EOL] calls_1 = async_mock_service ( hass , DOMAIN , SERVICE_PLAY_MEDIA ) [EOL] [EOL] value_1 = [string] [EOL] value_2 = [string] [EOL] value_3 = [string] [EOL] [EOL] await async_reproduce_states ( hass , [ State ( ENTITY_1 , None , { ATTR_MEDIA_CONTENT_TYPE : value_1 , ATTR_MEDIA_CONTENT_ID : value_2 } ) ] ) [EOL] [EOL] await async_reproduce_states ( hass , [ State ( ENTITY_1 , None , { ATTR_MEDIA_CONTENT_TYPE : value_1 , ATTR_MEDIA_CONTENT_ID : value_2 , ATTR_MEDIA_ENQUEUE : value_3 } ) ] ) [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls_1 ) == [number] [EOL] assert calls_1 [ [number] ] . data == { [string] : ENTITY_1 , ATTR_MEDIA_CONTENT_TYPE : value_1 , ATTR_MEDIA_CONTENT_ID : value_2 } [EOL] [EOL] assert calls_1 [ [number] ] . data == { [string] : ENTITY_1 , ATTR_MEDIA_CONTENT_TYPE : value_1 , ATTR_MEDIA_CONTENT_ID : value_2 , ATTR_MEDIA_ENQUEUE : value_3 } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import Mock [EOL] [EOL] [EOL] class AsyncMock ( Mock ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] async def __call__ ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] return super ( AsyncMock , self ) . __call__ ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from tests . common import async_mock_mqtt_component [EOL] [EOL] [EOL] @ pytest . fixture def mqtt_mock ( loop , hass ) : [EOL] [docstring] [EOL] client = loop . run_until_complete ( async_mock_mqtt_component ( hass ) ) [EOL] client . reset_mock ( ) [EOL] return client [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Tuple , Any [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest import mock [EOL] import voluptuous as vol [EOL] [EOL] from collections import defaultdict [EOL] from homeassistant . components . media_player . const import ( DOMAIN , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_VOLUME_STEP , SUPPORT_SELECT_SOURCE ) [EOL] from homeassistant . const import STATE_ON , STATE_OFF [EOL] [EOL] import tests . common [EOL] from homeassistant . components . monoprice . media_player import ( DATA_MONOPRICE , PLATFORM_SCHEMA , SERVICE_SNAPSHOT , SERVICE_RESTORE , setup_platform ) [EOL] import pytest [EOL] [EOL] [EOL] class AttrDict ( dict ) : [EOL] [docstring] [EOL] [EOL] def __setattr__ ( self , name , value ) : [EOL] [docstring] [EOL] self [ name ] = value [EOL] [EOL] def __getattr__ ( self , item ) : [EOL] [docstring] [EOL] return self [ item ] [EOL] [EOL] [EOL] class MockMonoprice : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . zones = defaultdict ( lambda : AttrDict ( power = True , volume = [number] , mute = True , source = [number] ) ) [EOL] [EOL] def zone_status ( self , zone_id ) : [EOL] [docstring] [EOL] status = self . zones [ zone_id ] [EOL] status . zone = zone_id [EOL] return AttrDict ( status ) [EOL] [EOL] def set_source ( self , zone_id , source_idx ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . source = source_idx [EOL] [EOL] def set_power ( self , zone_id , power ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . power = power [EOL] [EOL] def set_mute ( self , zone_id , mute ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . mute = mute [EOL] [EOL] def set_volume ( self , zone_id , volume ) : [EOL] [docstring] [EOL] self . zones [ zone_id ] . volume = volume [EOL] [EOL] def restore_zone ( self , zone ) : [EOL] [docstring] [EOL] self . zones [ zone . zone ] = AttrDict ( zone ) [EOL] [EOL] [EOL] class TestMonopriceSchema ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_valid_schema ( self ) : [EOL] [docstring] [EOL] valid_schema = { [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , } , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } } } [EOL] PLATFORM_SCHEMA ( valid_schema ) [EOL] [EOL] def test_invalid_schemas ( self ) : [EOL] [docstring] [EOL] schemas = ( { } , None , { [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { } } , [string] : { [number] : { [string] : [string] } } , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { } } , } , ) [EOL] for value in schemas : [EOL] with pytest . raises ( vol . MultipleInvalid ) : [EOL] PLATFORM_SCHEMA ( value ) [EOL] [EOL] [EOL] class TestMonopriceMediaPlayer ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . monoprice = MockMonoprice ( ) [EOL] self . hass = tests . common . get_test_home_assistant ( ) [EOL] self . hass . start ( ) [EOL] [comment] [EOL] with mock . patch ( [string] , new = lambda * a : self . monoprice ) : [EOL] setup_platform ( self . hass , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [number] : { [string] : [string] } } , [string] : { [number] : { [string] : [string] } , [number] : { [string] : [string] } , [number] : { [string] : [string] } } , } , lambda * args , ** kwargs : None , { } ) [EOL] self . hass . block_till_done ( ) [EOL] self . media_player = self . hass . data [ DATA_MONOPRICE ] [ [number] ] [EOL] self . media_player . hass = self . hass [EOL] self . media_player . entity_id = [string] [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_platform ( self , * args ) : [EOL] [docstring] [EOL] [comment] [EOL] assert self . hass . services . has_service ( DOMAIN , SERVICE_RESTORE ) [EOL] assert self . hass . services . has_service ( DOMAIN , SERVICE_SNAPSHOT ) [EOL] assert len ( self . hass . data [ DATA_MONOPRICE ] ) == [number] [EOL] assert self . hass . data [ DATA_MONOPRICE ] [ [number] ] . name == [string] [EOL] [EOL] def test_service_calls_with_entity_id ( self ) : [EOL] [docstring] [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . name [EOL] assert STATE_ON == self . media_player . state [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] assert self . media_player . is_volume_muted [EOL] assert [string] == self . media_player . source [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_SNAPSHOT , { [string] : [string] } , blocking = True ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] self . media_player . select_source ( [string] ) [EOL] self . media_player . mute_volume ( False ) [EOL] self . media_player . turn_off ( ) [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . name [EOL] assert STATE_OFF == self . media_player . state [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] assert not self . media_player . is_volume_muted [EOL] assert [string] == self . media_player . source [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_RESTORE , { [string] : [string] } , blocking = True ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . name [EOL] assert STATE_OFF == self . media_player . state [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] assert not self . media_player . is_volume_muted [EOL] assert [string] == self . media_player . source [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_RESTORE , { [string] : [string] } , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert [string] == self . media_player . name [EOL] assert STATE_ON == self . media_player . state [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] assert self . media_player . is_volume_muted [EOL] assert [string] == self . media_player . source [EOL] [EOL] def test_service_calls_without_entity_id ( self ) : [EOL] [docstring] [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . name [EOL] assert STATE_ON == self . media_player . state [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] assert self . media_player . is_volume_muted [EOL] assert [string] == self . media_player . source [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_RESTORE , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . name [EOL] assert STATE_ON == self . media_player . state [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] assert self . media_player . is_volume_muted [EOL] assert [string] == self . media_player . source [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_SNAPSHOT , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] self . media_player . select_source ( [string] ) [EOL] self . media_player . mute_volume ( False ) [EOL] self . media_player . turn_off ( ) [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . name [EOL] assert STATE_OFF == self . media_player . state [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] assert not self . media_player . is_volume_muted [EOL] assert [string] == self . media_player . source [EOL] [EOL] [comment] [EOL] self . hass . services . call ( DOMAIN , SERVICE_RESTORE , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert [string] == self . media_player . name [EOL] assert STATE_ON == self . media_player . state [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] assert self . media_player . is_volume_muted [EOL] assert [string] == self . media_player . source [EOL] [EOL] def test_update ( self ) : [EOL] [docstring] [EOL] assert self . media_player . state is None [EOL] assert self . media_player . volume_level is None [EOL] assert self . media_player . is_volume_muted is None [EOL] assert self . media_player . source is None [EOL] [EOL] self . media_player . update ( ) [EOL] [EOL] assert STATE_ON == self . media_player . state [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] assert self . media_player . is_volume_muted [EOL] assert [string] == self . media_player . source [EOL] [EOL] def test_name ( self ) : [EOL] [docstring] [EOL] assert [string] == self . media_player . name [EOL] [EOL] def test_state ( self ) : [EOL] [docstring] [EOL] assert self . media_player . state is None [EOL] [EOL] self . media_player . update ( ) [EOL] assert STATE_ON == self . media_player . state [EOL] [EOL] self . monoprice . zones [ [number] ] . power = False [EOL] self . media_player . update ( ) [EOL] assert STATE_OFF == self . media_player . state [EOL] [EOL] def test_volume_level ( self ) : [EOL] [docstring] [EOL] assert self . media_player . volume_level is None [EOL] self . media_player . update ( ) [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] [EOL] self . monoprice . zones [ [number] ] . volume = [number] [EOL] self . media_player . update ( ) [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] [EOL] self . monoprice . zones [ [number] ] . volume = [number] [EOL] self . media_player . update ( ) [EOL] assert [number] == self . media_player . volume_level , [number] [EOL] [EOL] def test_is_volume_muted ( self ) : [EOL] [docstring] [EOL] assert self . media_player . is_volume_muted is None [EOL] [EOL] self . media_player . update ( ) [EOL] assert self . media_player . is_volume_muted [EOL] [EOL] self . monoprice . zones [ [number] ] . mute = False [EOL] self . media_player . update ( ) [EOL] assert not self . media_player . is_volume_muted [EOL] [EOL] def test_supported_features ( self ) : [EOL] [docstring] [EOL] assert SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_STEP | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE == self . media_player . supported_features [EOL] [EOL] def test_source ( self ) : [EOL] [docstring] [EOL] assert self . media_player . source is None [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . source [EOL] [EOL] def test_media_title ( self ) : [EOL] [docstring] [EOL] assert self . media_player . media_title is None [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . media_title [EOL] [EOL] def test_source_list ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] assert [ [string] , [string] , [string] ] == self . media_player . source_list [EOL] [EOL] def test_select_source ( self ) : [EOL] [docstring] [EOL] self . media_player . update ( ) [EOL] [EOL] assert [string] == self . media_player . source [EOL] [EOL] self . media_player . select_source ( [string] ) [EOL] assert [number] == self . monoprice . zones [ [number] ] . source [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . source [EOL] [EOL] [comment] [EOL] self . media_player . select_source ( [string] ) [EOL] assert [number] == self . monoprice . zones [ [number] ] . source [EOL] self . media_player . update ( ) [EOL] assert [string] == self . media_player . source [EOL] [EOL] def test_turn_on ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . power = False [EOL] self . media_player . update ( ) [EOL] assert STATE_OFF == self . media_player . state [EOL] [EOL] self . media_player . turn_on ( ) [EOL] assert self . monoprice . zones [ [number] ] . power [EOL] self . media_player . update ( ) [EOL] assert STATE_ON == self . media_player . state [EOL] [EOL] def test_turn_off ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . power = True [EOL] self . media_player . update ( ) [EOL] assert STATE_ON == self . media_player . state [EOL] [EOL] self . media_player . turn_off ( ) [EOL] assert not self . monoprice . zones [ [number] ] . power [EOL] self . media_player . update ( ) [EOL] assert STATE_OFF == self . media_player . state [EOL] [EOL] def test_mute_volume ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . mute = True [EOL] self . media_player . update ( ) [EOL] assert self . media_player . is_volume_muted [EOL] [EOL] self . media_player . mute_volume ( False ) [EOL] assert not self . monoprice . zones [ [number] ] . mute [EOL] self . media_player . update ( ) [EOL] assert not self . media_player . is_volume_muted [EOL] [EOL] self . media_player . mute_volume ( True ) [EOL] assert self . monoprice . zones [ [number] ] . mute [EOL] self . media_player . update ( ) [EOL] assert self . media_player . is_volume_muted [EOL] [EOL] def test_set_volume_level ( self ) : [EOL] [docstring] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] assert [number] == self . monoprice . zones [ [number] ] . volume [EOL] assert isinstance ( self . monoprice . zones [ [number] ] . volume , int ) [EOL] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] assert [number] == self . monoprice . zones [ [number] ] . volume [EOL] assert isinstance ( self . monoprice . zones [ [number] ] . volume , int ) [EOL] [EOL] self . media_player . set_volume_level ( [number] ) [EOL] assert [number] == self . monoprice . zones [ [number] ] . volume [EOL] assert isinstance ( self . monoprice . zones [ [number] ] . volume , int ) [EOL] [EOL] def test_volume_up ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . volume = [number] [EOL] self . media_player . update ( ) [EOL] self . media_player . volume_up ( ) [EOL] assert [number] == self . monoprice . zones [ [number] ] . volume [EOL] assert isinstance ( self . monoprice . zones [ [number] ] . volume , int ) [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] self . media_player . volume_up ( ) [EOL] assert [number] == self . monoprice . zones [ [number] ] . volume [EOL] assert isinstance ( self . monoprice . zones [ [number] ] . volume , int ) [EOL] [EOL] def test_volume_down ( self ) : [EOL] [docstring] [EOL] self . monoprice . zones [ [number] ] . volume = [number] [EOL] self . media_player . update ( ) [EOL] self . media_player . volume_down ( ) [EOL] assert [number] == self . monoprice . zones [ [number] ] . volume [EOL] assert isinstance ( self . monoprice . zones [ [number] ] . volume , int ) [EOL] [EOL] [comment] [EOL] self . media_player . update ( ) [EOL] self . media_player . volume_down ( ) [EOL] assert [number] == self . monoprice . zones [ [number] ] . volume [EOL] assert isinstance ( self . monoprice . zones [ [number] ] . volume , int ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],None,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Dict[typing.Any,typing.Any],None,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Dict[typing.Any,typing.Any]],typing.Dict[builtins.int,typing.Dict[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.monoprice.test_media_player.MockMonoprice$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.monoprice.test_media_player.MockMonoprice$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . const import MATCH_ALL [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components . recorder import Recorder [EOL] from homeassistant . components . recorder . const import DATA_INSTANCE [EOL] from homeassistant . components . recorder . util import session_scope [EOL] from homeassistant . components . recorder . models import States , Events [EOL] [EOL] from tests . common import get_test_home_assistant , init_recorder_component [EOL] [EOL] [EOL] class TestRecorder ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] init_recorder_component ( self . hass ) [EOL] self . hass . start ( ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_saving_state ( self ) : [EOL] [docstring] [EOL] entity_id = [string] [EOL] state = [string] [EOL] attributes = { [string] : [number] , [string] : [string] } [EOL] [EOL] self . hass . states . set ( entity_id , state , attributes ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] self . hass . data [ DATA_INSTANCE ] . block_till_done ( ) [EOL] [EOL] with session_scope ( hass = self . hass ) as session : [EOL] db_states = list ( session . query ( States ) ) [EOL] assert len ( db_states ) == [number] [EOL] assert db_states [ [number] ] . event_id > [number] [EOL] state = db_states [ [number] ] . to_native ( ) [EOL] [EOL] assert state == self . hass . states . get ( entity_id ) [EOL] [EOL] def test_saving_event ( self ) : [EOL] [docstring] [EOL] event_type = [string] [EOL] event_data = { [string] : [number] , [string] : [string] } [EOL] [EOL] events = [ ] [EOL] [EOL] @ callback def event_listener ( event ) : [EOL] [docstring] [EOL] if event . event_type == event_type : [EOL] events . append ( event ) [EOL] [EOL] self . hass . bus . listen ( MATCH_ALL , event_listener ) [EOL] [EOL] self . hass . bus . fire ( event_type , event_data ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( events ) == [number] [EOL] event = events [ [number] ] [EOL] [EOL] self . hass . data [ DATA_INSTANCE ] . block_till_done ( ) [EOL] [EOL] with session_scope ( hass = self . hass ) as session : [EOL] db_events = list ( session . query ( Events ) . filter_by ( event_type = event_type ) ) [EOL] assert len ( db_events ) == [number] [EOL] db_event = db_events [ [number] ] . to_native ( ) [EOL] [EOL] assert event . event_type == db_event . event_type [EOL] assert event . data == db_event . data [EOL] assert event . origin == db_event . origin [EOL] [EOL] [comment] [EOL] assert event . time_fired . replace ( microsecond = [number] ) == db_event . time_fired . replace ( microsecond = [number] ) [EOL] [EOL] [EOL] @ pytest . fixture def hass_recorder ( ) : [EOL] [docstring] [EOL] hass = get_test_home_assistant ( ) [EOL] [EOL] def setup_recorder ( config = None ) : [EOL] [docstring] [EOL] init_recorder_component ( hass , config ) [EOL] hass . start ( ) [EOL] hass . block_till_done ( ) [EOL] hass . data [ DATA_INSTANCE ] . block_till_done ( ) [EOL] return hass [EOL] [EOL] yield setup_recorder [EOL] hass . stop ( ) [EOL] [EOL] [EOL] def _add_entities ( hass , entity_ids ) : [EOL] [docstring] [EOL] attributes = { [string] : [number] , [string] : [string] } [EOL] for idx , entity_id in enumerate ( entity_ids ) : [EOL] hass . states . set ( entity_id , [string] . format ( idx ) , attributes ) [EOL] hass . block_till_done ( ) [EOL] hass . data [ DATA_INSTANCE ] . block_till_done ( ) [EOL] [EOL] with session_scope ( hass = hass ) as session : [EOL] return [ st . to_native ( ) for st in session . query ( States ) ] [EOL] [EOL] [EOL] def _add_events ( hass , events ) : [EOL] with session_scope ( hass = hass ) as session : [EOL] session . query ( Events ) . delete ( synchronize_session = False ) [EOL] for event_type in events : [EOL] hass . bus . fire ( event_type ) [EOL] hass . block_till_done ( ) [EOL] hass . data [ DATA_INSTANCE ] . block_till_done ( ) [EOL] [EOL] with session_scope ( hass = hass ) as session : [EOL] return [ ev . to_native ( ) for ev in session . query ( Events ) ] [EOL] [EOL] [EOL] [comment] [EOL] def test_saving_state_include_domains ( hass_recorder ) : [EOL] [docstring] [EOL] hass = hass_recorder ( { [string] : { [string] : [string] } } ) [EOL] states = _add_entities ( hass , [ [string] , [string] ] ) [EOL] assert len ( states ) == [number] [EOL] assert hass . states . get ( [string] ) == states [ [number] ] [EOL] [EOL] [EOL] def test_saving_state_incl_entities ( hass_recorder ) : [EOL] [docstring] [EOL] hass = hass_recorder ( { [string] : { [string] : [string] } } ) [EOL] states = _add_entities ( hass , [ [string] , [string] ] ) [EOL] assert len ( states ) == [number] [EOL] assert hass . states . get ( [string] ) == states [ [number] ] [EOL] [EOL] [EOL] def test_saving_event_exclude_event_type ( hass_recorder ) : [EOL] [docstring] [EOL] hass = hass_recorder ( { [string] : { [string] : [string] } } ) [EOL] events = _add_events ( hass , [ [string] , [string] ] ) [EOL] assert len ( events ) == [number] [EOL] assert events [ [number] ] . event_type == [string] [EOL] [EOL] [EOL] def test_saving_state_exclude_domains ( hass_recorder ) : [EOL] [docstring] [EOL] hass = hass_recorder ( { [string] : { [string] : [string] } } ) [EOL] states = _add_entities ( hass , [ [string] , [string] ] ) [EOL] assert len ( states ) == [number] [EOL] assert hass . states . get ( [string] ) == states [ [number] ] [EOL] [EOL] [EOL] def test_saving_state_exclude_entities ( hass_recorder ) : [EOL] [docstring] [EOL] hass = hass_recorder ( { [string] : { [string] : [string] } } ) [EOL] states = _add_entities ( hass , [ [string] , [string] ] ) [EOL] assert len ( states ) == [number] [EOL] assert hass . states . get ( [string] ) == states [ [number] ] [EOL] [EOL] [EOL] def test_saving_state_exclude_domain_include_entity ( hass_recorder ) : [EOL] [docstring] [EOL] hass = hass_recorder ( { [string] : { [string] : [string] } , [string] : { [string] : [string] } } ) [EOL] states = _add_entities ( hass , [ [string] , [string] ] ) [EOL] assert len ( states ) == [number] [EOL] [EOL] [EOL] def test_saving_state_include_domain_exclude_entity ( hass_recorder ) : [EOL] [docstring] [EOL] hass = hass_recorder ( { [string] : { [string] : [string] } , [string] : { [string] : [string] } } ) [EOL] states = _add_entities ( hass , [ [string] , [string] , [string] ] ) [EOL] assert len ( states ) == [number] [EOL] assert hass . states . get ( [string] ) == states [ [number] ] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] [EOL] def test_recorder_setup_failure ( ) : [EOL] [docstring] [EOL] hass = get_test_home_assistant ( ) [EOL] [EOL] with patch . object ( Recorder , [string] ) as setup , patch ( [string] ) : [EOL] setup . side_effect = ImportError ( [string] ) [EOL] rec = Recorder ( hass , keep_days = [number] , purge_interval = [number] , uri = [string] , include = { } , exclude = { } ) [EOL] rec . start ( ) [EOL] rec . join ( ) [EOL] [EOL] hass . stop ( ) [EOL] [EOL] [EOL] async def test_defaults_set ( hass ) : [EOL] [docstring] [EOL] recorder_config = None [EOL] [EOL] async def mock_setup ( hass , config ) : [EOL] [docstring] [EOL] nonlocal recorder_config [EOL] recorder_config = config [ [string] ] [EOL] return True [EOL] [EOL] with patch ( [string] , side_effect = mock_setup ) : [EOL] assert await async_setup_component ( hass , [string] , { } ) [EOL] [EOL] assert recorder_config is not None [EOL] assert recorder_config [ [string] ] == [number] [EOL] assert recorder_config [ [string] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Union , List , Dict , Generator , Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import asyncio [EOL] import json [EOL] from unittest . mock import patch , MagicMock [EOL] [EOL] from homeassistant . bootstrap import async_setup_component [EOL] from homeassistant . components import config [EOL] [EOL] [EOL] VIEW_NAME = [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_get_device_config ( hass , hass_client ) : [EOL] [docstring] [EOL] with patch . object ( config , [string] , [ [string] ] ) : [EOL] yield from async_setup_component ( hass , [string] , { } ) [EOL] [EOL] client = yield from hass_client ( ) [EOL] [EOL] def mock_read ( path ) : [EOL] [docstring] [EOL] return { [string] : { [string] : [string] , } , [string] : { [string] : [string] , } , } [EOL] [EOL] with patch ( [string] , mock_read ) : [EOL] resp = yield from client . get ( [string] ) [EOL] [EOL] assert resp . status == [number] [EOL] result = yield from resp . json ( ) [EOL] [EOL] assert result == { [string] : [string] } [EOL] [EOL] [EOL] @ asyncio . coroutine def test_update_device_config ( hass , hass_client ) : [EOL] [docstring] [EOL] with patch . object ( config , [string] , [ [string] ] ) : [EOL] yield from async_setup_component ( hass , [string] , { } ) [EOL] [EOL] client = yield from hass_client ( ) [EOL] [EOL] orig_data = { [string] : { [string] : True , } , [string] : { [string] : [number] , } , } [EOL] [EOL] def mock_read ( path ) : [EOL] [docstring] [EOL] return orig_data [EOL] [EOL] written = [ ] [EOL] [EOL] def mock_write ( path , data ) : [EOL] [docstring] [EOL] written . append ( data ) [EOL] [EOL] mock_call = MagicMock ( ) [EOL] [EOL] with patch ( [string] , mock_read ) , patch ( [string] , mock_write ) , patch . object ( hass . services , [string] , mock_call ) : [EOL] resp = yield from client . post ( [string] , data = json . dumps ( { [string] : [string] , [string] : [ [string] , [string] ] , } ) ) [EOL] [EOL] assert resp . status == [number] [EOL] result = yield from resp . json ( ) [EOL] assert result == { [string] : [string] } [EOL] [EOL] orig_data [ [string] ] [ [string] ] = [string] [EOL] orig_data [ [string] ] [ [string] ] = [ [string] , [string] ] [EOL] [EOL] assert written [ [number] ] == orig_data [EOL] mock_call . assert_called_once_with ( [string] , [string] ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_update_device_config_invalid_key ( hass , hass_client ) : [EOL] [docstring] [EOL] with patch . object ( config , [string] , [ [string] ] ) : [EOL] yield from async_setup_component ( hass , [string] , { } ) [EOL] [EOL] client = yield from hass_client ( ) [EOL] [EOL] resp = yield from client . post ( [string] , data = json . dumps ( { [string] : [string] , } ) ) [EOL] [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_update_device_config_invalid_data ( hass , hass_client ) : [EOL] [docstring] [EOL] with patch . object ( config , [string] , [ [string] ] ) : [EOL] yield from async_setup_component ( hass , [string] , { } ) [EOL] [EOL] client = yield from hass_client ( ) [EOL] [EOL] resp = yield from client . post ( [string] , data = json . dumps ( { [string] : [number] } ) ) [EOL] [EOL] assert resp . status == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_update_device_config_invalid_json ( hass , hass_client ) : [EOL] [docstring] [EOL] with patch . object ( config , [string] , [ [string] ] ) : [EOL] yield from async_setup_component ( hass , [string] , { } ) [EOL] [EOL] client = yield from hass_client ( ) [EOL] [EOL] resp = yield from client . post ( [string] , data = [string] ) [EOL] [EOL] assert resp . status == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . notify import ( ATTR_DATA , ATTR_MESSAGE , ATTR_TITLE , DOMAIN , SERVICE_NOTIFY ) [EOL] from homeassistant . loader import bind_hass [EOL] [EOL] [EOL] @ bind_hass def send_message ( hass , message , title = None , data = None ) : [EOL] [docstring] [EOL] info = { ATTR_MESSAGE : message } [EOL] [EOL] if title is not None : [EOL] info [ ATTR_TITLE ] = title [EOL] [EOL] if data is not None : [EOL] info [ ATTR_DATA ] = data [EOL] [EOL] hass . services . call ( DOMAIN , SERVICE_NOTIFY , info ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import unittest [EOL] import statistics [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components . statistics . sensor import StatisticsSensor [EOL] from homeassistant . const import ( ATTR_UNIT_OF_MEASUREMENT , TEMP_CELSIUS , STATE_UNKNOWN ) [EOL] from homeassistant . util import dt as dt_util [EOL] from tests . common import get_test_home_assistant [EOL] from unittest . mock import patch [EOL] from datetime import datetime , timedelta [EOL] from tests . common import init_recorder_component [EOL] from homeassistant . components import recorder [EOL] [EOL] [EOL] class TestStatisticsSensor ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . values = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . count = len ( self . values ) [EOL] self . min = min ( self . values ) [EOL] self . max = max ( self . values ) [EOL] self . total = sum ( self . values ) [EOL] self . mean = round ( sum ( self . values ) / len ( self . values ) , [number] ) [EOL] self . median = round ( statistics . median ( self . values ) , [number] ) [EOL] self . deviation = round ( statistics . stdev ( self . values ) , [number] ) [EOL] self . variance = round ( statistics . variance ( self . values ) , [number] ) [EOL] self . change = round ( self . values [ - [number] ] - self . values [ [number] ] , [number] ) [EOL] self . average_change = round ( self . change / ( len ( self . values ) - [number] ) , [number] ) [EOL] self . change_rate = round ( self . average_change / ( [number] * ( self . count - [number] ) ) , [number] ) [EOL] [EOL] def teardown_method ( self , method ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_binary_sensor_source ( self ) : [EOL] [docstring] [EOL] values = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] for value in values : [EOL] self . hass . states . set ( [string] , value ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert str ( len ( values ) ) == state . state [EOL] [EOL] def test_sensor_source ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] for value in self . values : [EOL] self . hass . states . set ( [string] , value , { ATTR_UNIT_OF_MEASUREMENT : TEMP_CELSIUS } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert str ( self . mean ) == state . state [EOL] assert self . min == state . attributes . get ( [string] ) [EOL] assert self . max == state . attributes . get ( [string] ) [EOL] assert self . variance == state . attributes . get ( [string] ) [EOL] assert self . median == state . attributes . get ( [string] ) [EOL] assert self . deviation == state . attributes . get ( [string] ) [EOL] assert self . mean == state . attributes . get ( [string] ) [EOL] assert self . count == state . attributes . get ( [string] ) [EOL] assert self . total == state . attributes . get ( [string] ) [EOL] assert [string] == state . attributes . get ( [string] ) [EOL] assert self . change == state . attributes . get ( [string] ) [EOL] assert self . average_change == state . attributes . get ( [string] ) [EOL] [EOL] def test_sampling_size ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] for value in self . values : [EOL] self . hass . states . set ( [string] , value , { ATTR_UNIT_OF_MEASUREMENT : TEMP_CELSIUS } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert [number] == state . attributes . get ( [string] ) [EOL] assert [number] == state . attributes . get ( [string] ) [EOL] [EOL] def test_sampling_size_1 ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] for value in self . values [ - [number] : ] : [comment] [EOL] self . hass . states . set ( [string] , value , { ATTR_UNIT_OF_MEASUREMENT : TEMP_CELSIUS } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] [comment] [EOL] assert self . values [ - [number] ] == state . attributes . get ( [string] ) [EOL] assert self . values [ - [number] ] == state . attributes . get ( [string] ) [EOL] assert self . values [ - [number] ] == state . attributes . get ( [string] ) [EOL] assert self . values [ - [number] ] == state . attributes . get ( [string] ) [EOL] assert self . values [ - [number] ] == state . attributes . get ( [string] ) [EOL] assert [number] == state . attributes . get ( [string] ) [EOL] assert [number] == state . attributes . get ( [string] ) [EOL] [EOL] [comment] [EOL] assert STATE_UNKNOWN == state . attributes . get ( [string] ) [EOL] assert STATE_UNKNOWN == state . attributes . get ( [string] ) [EOL] [EOL] def test_max_age ( self ) : [EOL] [docstring] [EOL] mock_data = { [string] : datetime ( [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) , } [EOL] [EOL] def mock_now ( ) : [EOL] return mock_data [ [string] ] [EOL] [EOL] with patch ( [string] , new = mock_now ) : [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [number] } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] for value in self . values : [EOL] self . hass . states . set ( [string] , value , { ATTR_UNIT_OF_MEASUREMENT : TEMP_CELSIUS } ) [EOL] self . hass . block_till_done ( ) [EOL] [comment] [EOL] mock_data [ [string] ] += timedelta ( minutes = [number] ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert [number] == state . attributes . get ( [string] ) [EOL] assert [number] == state . attributes . get ( [string] ) [EOL] [EOL] def test_change_rate ( self ) : [EOL] [docstring] [EOL] mock_data = { [string] : datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) , } [EOL] [EOL] def mock_now ( ) : [EOL] return mock_data [ [string] ] [EOL] [EOL] with patch ( [string] , new = mock_now ) : [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] for value in self . values : [EOL] self . hass . states . set ( [string] , value , { ATTR_UNIT_OF_MEASUREMENT : TEMP_CELSIUS } ) [EOL] self . hass . block_till_done ( ) [EOL] [comment] [EOL] mock_data [ [string] ] += timedelta ( minutes = [number] ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) == state . attributes . get ( [string] ) [EOL] assert datetime ( [number] , [number] , [number] , [number] , [number] + self . count - [number] , [number] , tzinfo = dt_util . UTC ) == state . attributes . get ( [string] ) [EOL] assert self . change_rate == state . attributes . get ( [string] ) [EOL] [EOL] @ pytest . mark . skip ( [string] ) def test_initialize_from_database ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] init_recorder_component ( self . hass ) [EOL] [comment] [EOL] for value in self . values : [EOL] self . hass . states . set ( [string] , value , { ATTR_UNIT_OF_MEASUREMENT : TEMP_CELSIUS } ) [EOL] self . hass . block_till_done ( ) [EOL] [comment] [EOL] self . hass . data [ recorder . DATA_INSTANCE ] . block_till_done ( ) [EOL] [comment] [EOL] [comment] [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert str ( self . mean ) == state . state [EOL] [EOL] @ pytest . mark . skip ( [string] ) def test_initialize_from_database_with_maxage ( self ) : [EOL] [docstring] [EOL] mock_data = { [string] : datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) , } [EOL] [EOL] def mock_now ( ) : [EOL] return mock_data [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def mock_purge ( self ) : [EOL] return [EOL] [EOL] [comment] [EOL] max_age = [number] [EOL] [comment] [EOL] expected_min_age = mock_data [ [string] ] + timedelta ( hours = len ( self . values ) - max_age ) [EOL] [EOL] [comment] [EOL] init_recorder_component ( self . hass ) [EOL] [EOL] with patch ( [string] , new = mock_now ) , patch . object ( StatisticsSensor , [string] , mock_purge ) : [EOL] [comment] [EOL] for value in self . values : [EOL] self . hass . states . set ( [string] , value , { ATTR_UNIT_OF_MEASUREMENT : TEMP_CELSIUS } ) [EOL] self . hass . block_till_done ( ) [EOL] [comment] [EOL] mock_data [ [string] ] += timedelta ( hours = [number] ) [EOL] [EOL] [comment] [EOL] self . hass . data [ recorder . DATA_INSTANCE ] . block_till_done ( ) [EOL] [comment] [EOL] [comment] [EOL] assert setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : { [string] : max_age } } } ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert expected_min_age == state . attributes . get ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] assert mock_data [ [string] ] == state . attributes . get ( [string] ) + timedelta ( hours = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 $typing.Dict[builtins.str,datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,datetime.datetime.datetime]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture def mock_gateway_info ( ) : [EOL] [docstring] [EOL] with patch ( [string] [string] ) as mock_gateway : [EOL] yield mock_gateway [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] from zeroconf import ServiceInfo , ServiceStateChange [EOL] [EOL] from homeassistant . generated import zeroconf as zc_gen [EOL] from homeassistant . setup import async_setup_component [EOL] from homeassistant . components import zeroconf [EOL] [EOL] [EOL] @ pytest . fixture def mock_zeroconf ( ) : [EOL] [docstring] [EOL] with patch ( [string] ) as mock_zc : [EOL] yield mock_zc . return_value [EOL] [EOL] [EOL] def service_update_mock ( zeroconf , service , handlers ) : [EOL] [docstring] [EOL] handlers [ [number] ] ( zeroconf , service , [string] . format ( [string] , service ) , ServiceStateChange . Added ) [EOL] [EOL] [EOL] def get_service_info_mock ( service_type , name ) : [EOL] [docstring] [EOL] return ServiceInfo ( service_type , name , address = [string] , port = [number] , weight = [number] , priority = [number] , server = [string] , properties = { [string] : [string] } ) [EOL] [EOL] [EOL] def get_homekit_info_mock ( model ) : [EOL] [docstring] [EOL] def mock_homekit_info ( service_type , name ) : [EOL] return ServiceInfo ( service_type , name , address = [string] , port = [number] , weight = [number] , priority = [number] , server = [string] , properties = { [string] : model . encode ( ) } ) [EOL] [EOL] return mock_homekit_info [EOL] [EOL] [EOL] async def test_setup ( hass , mock_zeroconf ) : [EOL] [docstring] [EOL] with patch . object ( hass . config_entries , [string] ) as mock_config_flow , patch . object ( zeroconf , [string] , side_effect = service_update_mock ) as mock_service_browser : [EOL] mock_zeroconf . get_service_info . side_effect = get_service_info_mock [EOL] assert await async_setup_component ( hass , zeroconf . DOMAIN , { zeroconf . DOMAIN : { } } ) [EOL] [EOL] assert len ( mock_service_browser . mock_calls ) == len ( zc_gen . ZEROCONF ) [EOL] assert len ( mock_config_flow . mock_calls ) == len ( zc_gen . ZEROCONF ) * [number] [EOL] [EOL] [EOL] async def test_homekit_match_partial ( hass , mock_zeroconf ) : [EOL] [docstring] [EOL] with patch . dict ( zc_gen . ZEROCONF , { zeroconf . HOMEKIT_TYPE : [ [string] ] } , clear = True ) , patch . object ( hass . config_entries , [string] ) as mock_config_flow , patch . object ( zeroconf , [string] , side_effect = service_update_mock ) as mock_service_browser : [EOL] mock_zeroconf . get_service_info . side_effect = get_homekit_info_mock ( [string] ) [EOL] assert await async_setup_component ( hass , zeroconf . DOMAIN , { zeroconf . DOMAIN : { } } ) [EOL] [EOL] assert len ( mock_service_browser . mock_calls ) == [number] [EOL] assert len ( mock_config_flow . mock_calls ) == [number] [EOL] assert mock_config_flow . mock_calls [ [number] ] [ [number] ] [ [number] ] == [string] [EOL] [EOL] [EOL] async def test_homekit_match_full ( hass , mock_zeroconf ) : [EOL] [docstring] [EOL] with patch . dict ( zc_gen . ZEROCONF , { zeroconf . HOMEKIT_TYPE : [ [string] ] } , clear = True ) , patch . object ( hass . config_entries , [string] ) as mock_config_flow , patch . object ( zeroconf , [string] , side_effect = service_update_mock ) as mock_service_browser : [EOL] mock_zeroconf . get_service_info . side_effect = get_homekit_info_mock ( [string] ) [EOL] assert await async_setup_component ( hass , zeroconf . DOMAIN , { zeroconf . DOMAIN : { } } ) [EOL] [EOL] assert len ( mock_service_browser . mock_calls ) == [number] [EOL] assert len ( mock_config_flow . mock_calls ) == [number] [EOL] assert mock_config_flow . mock_calls [ [number] ] [ [number] ] [ [number] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import ( async_dispatcher_connect , dispatcher_send , dispatcher_connect ) [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class TestHelpersDispatcher : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def teardown_method ( self , method ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_simple_function ( self ) : [EOL] [docstring] [EOL] calls = [ ] [EOL] [EOL] def test_funct ( data ) : [EOL] [docstring] [EOL] calls . append ( data ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] ] [EOL] [EOL] dispatcher_send ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] , [string] ] [EOL] [EOL] def test_simple_function_unsub ( self ) : [EOL] [docstring] [EOL] calls1 = [ ] [EOL] calls2 = [ ] [EOL] [EOL] def test_funct1 ( data ) : [EOL] [docstring] [EOL] calls1 . append ( data ) [EOL] [EOL] def test_funct2 ( data ) : [EOL] [docstring] [EOL] calls2 . append ( data ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct1 ) [EOL] unsub = dispatcher_connect ( self . hass , [string] , test_funct2 ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls1 == [ [number] ] [EOL] assert calls2 == [ [number] ] [EOL] [EOL] unsub ( ) [EOL] [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls1 == [ [number] , [number] ] [EOL] assert calls2 == [ [number] ] [EOL] [EOL] [comment] [EOL] unsub ( ) [EOL] [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls1 == [ [number] , [number] , [number] ] [EOL] assert calls2 == [ [number] ] [EOL] [EOL] def test_simple_callback ( self ) : [EOL] [docstring] [EOL] calls = [ ] [EOL] [EOL] @ callback def test_funct ( data ) : [EOL] [docstring] [EOL] calls . append ( data ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] ] [EOL] [EOL] dispatcher_send ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] , [string] ] [EOL] [EOL] def test_simple_coro ( self ) : [EOL] [docstring] [EOL] calls = [ ] [EOL] [EOL] @ asyncio . coroutine def test_funct ( data ) : [EOL] [docstring] [EOL] calls . append ( data ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] ] [EOL] [EOL] dispatcher_send ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] , [string] ] [EOL] [EOL] def test_simple_function_multiargs ( self ) : [EOL] [docstring] [EOL] calls = [ ] [EOL] [EOL] def test_funct ( data1 , data2 , data3 ) : [EOL] [docstring] [EOL] calls . append ( data1 ) [EOL] calls . append ( data2 ) [EOL] calls . append ( data3 ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct ) [EOL] dispatcher_send ( self . hass , [string] , [number] , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] , [number] , [string] ] [EOL] [EOL] [EOL] async def test_callback_exception_gets_logged ( hass , caplog ) : [EOL] [docstring] [EOL] @ callback def bad_handler ( * args ) : [EOL] [docstring] [EOL] raise Exception ( [string] ) [EOL] [EOL] async_dispatcher_connect ( hass , [string] , bad_handler ) [EOL] dispatcher_send ( hass , [string] , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert [string] in caplog . text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Set , Tuple , List [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from unittest . mock import patch [EOL] [EOL] import asynctest [EOL] import pytest [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers import device_registry [EOL] from tests . common import mock_device_registry , flush_store [EOL] [EOL] [EOL] @ pytest . fixture def registry ( hass ) : [EOL] [docstring] [EOL] return mock_device_registry ( hass ) [EOL] [EOL] [EOL] @ pytest . fixture def update_events ( hass ) : [EOL] [docstring] [EOL] events = [ ] [EOL] [EOL] @ callback def async_capture ( event ) : [EOL] events . append ( event . data ) [EOL] [EOL] hass . bus . async_listen ( device_registry . EVENT_DEVICE_REGISTRY_UPDATED , async_capture ) [EOL] [EOL] return events [EOL] [EOL] [EOL] async def test_get_or_create_returns_same_entry ( hass , registry , update_events ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , sw_version = [string] , name = [string] , manufacturer = [string] , model = [string] ) [EOL] entry2 = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] entry3 = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } ) [EOL] [EOL] assert len ( registry . devices ) == [number] [EOL] assert entry . id == entry2 . id [EOL] assert entry . id == entry3 . id [EOL] assert entry . identifiers == { ( [string] , [string] ) } [EOL] [EOL] assert entry3 . manufacturer == [string] [EOL] assert entry3 . model == [string] [EOL] assert entry3 . name == [string] [EOL] assert entry3 . sw_version == [string] [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert len ( update_events ) == [number] [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == entry . id [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == entry . id [EOL] [EOL] [EOL] async def test_requirement_for_identifier_or_connection ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = set ( ) , manufacturer = [string] , model = [string] ) [EOL] entry2 = registry . async_get_or_create ( config_entry_id = [string] , connections = set ( ) , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] entry3 = registry . async_get_or_create ( config_entry_id = [string] , connections = set ( ) , identifiers = set ( ) , manufacturer = [string] , model = [string] ) [EOL] [EOL] assert len ( registry . devices ) == [number] [EOL] assert entry [EOL] assert entry2 [EOL] assert entry3 is None [EOL] [EOL] [EOL] async def test_multiple_config_entries ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] entry2 = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] entry3 = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] [EOL] assert len ( registry . devices ) == [number] [EOL] assert entry . id == entry2 . id [EOL] assert entry . id == entry3 . id [EOL] assert entry2 . config_entries == { [string] , [string] } [EOL] [EOL] [EOL] async def test_loading_from_storage ( hass , hass_storage ) : [EOL] [docstring] [EOL] hass_storage [ device_registry . STORAGE_KEY ] = { [string] : device_registry . STORAGE_VERSION , [string] : { [string] : [ { [string] : [ [string] ] , [string] : [ [ [string] , [string] ] ] , [string] : [string] , [string] : [ [ [string] , [string] ] ] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] } } [EOL] [EOL] registry = await device_registry . async_get_registry ( hass ) [EOL] [EOL] entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( [string] , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] assert entry . id == [string] [EOL] assert entry . area_id == [string] [EOL] assert entry . name_by_user == [string] [EOL] assert isinstance ( entry . config_entries , set ) [EOL] [EOL] [EOL] async def test_removing_config_entries ( hass , registry , update_events ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] entry2 = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] entry3 = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] [EOL] assert len ( registry . devices ) == [number] [EOL] assert entry . id == entry2 . id [EOL] assert entry . id != entry3 . id [EOL] assert entry2 . config_entries == { [string] , [string] } [EOL] [EOL] registry . async_clear_config_entry ( [string] ) [EOL] entry = registry . async_get_device ( { ( [string] , [string] ) } , set ( ) ) [EOL] entry3_removed = registry . async_get_device ( { ( [string] , [string] ) } , set ( ) ) [EOL] [EOL] assert entry . config_entries == { [string] } [EOL] assert entry3_removed is None [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( update_events ) == [number] [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == entry . id [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == entry2 . id [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == entry3 . id [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == entry . id [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == entry3 . id [EOL] [EOL] [EOL] async def test_removing_area_id ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] [EOL] entry_w_area = registry . async_update_device ( entry . id , area_id = [string] ) [EOL] [EOL] registry . async_clear_area_id ( [string] ) [EOL] entry_wo_area = registry . async_get_device ( { ( [string] , [string] ) } , set ( ) ) [EOL] [EOL] assert not entry_wo_area . area_id [EOL] assert entry_w_area != entry_wo_area [EOL] [EOL] [EOL] async def test_specifying_via_device_create ( registry ) : [EOL] [docstring] [EOL] via = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] [EOL] light = registry . async_get_or_create ( config_entry_id = [string] , connections = set ( ) , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] , via_device = ( [string] , [string] ) ) [EOL] [EOL] assert light . via_device_id == via . id [EOL] [EOL] [EOL] async def test_specifying_via_device_update ( registry ) : [EOL] [docstring] [EOL] light = registry . async_get_or_create ( config_entry_id = [string] , connections = set ( ) , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] , via_device = ( [string] , [string] ) ) [EOL] [EOL] assert light . via_device_id is None [EOL] [EOL] via = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] [EOL] light = registry . async_get_or_create ( config_entry_id = [string] , connections = set ( ) , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] , via_device = ( [string] , [string] ) ) [EOL] [EOL] assert light . via_device_id == via . id [EOL] [EOL] [EOL] async def test_loading_saving_data ( hass , registry ) : [EOL] [docstring] [EOL] orig_via = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] ) [EOL] [EOL] orig_light = registry . async_get_or_create ( config_entry_id = [string] , connections = set ( ) , identifiers = { ( [string] , [string] ) } , manufacturer = [string] , model = [string] , via_device = ( [string] , [string] ) ) [EOL] [EOL] assert len ( registry . devices ) == [number] [EOL] [EOL] [comment] [EOL] registry2 = device_registry . DeviceRegistry ( hass ) [EOL] await flush_store ( registry . _store ) [EOL] await registry2 . async_load ( ) [EOL] [EOL] [comment] [EOL] assert list ( registry . devices ) == list ( registry2 . devices ) [EOL] [EOL] new_via = registry2 . async_get_device ( { ( [string] , [string] ) } , set ( ) ) [EOL] new_light = registry2 . async_get_device ( { ( [string] , [string] ) } , set ( ) ) [EOL] [EOL] assert orig_via == new_via [EOL] assert orig_light == new_light [EOL] [EOL] [EOL] async def test_no_unnecessary_changes ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( [string] , [string] ) } , identifiers = { ( [string] , [string] ) , ( [string] , [string] ) } , ) [EOL] with patch ( [string] [string] ) as mock_save : [EOL] entry2 = registry . async_get_or_create ( config_entry_id = [string] , identifiers = { ( [string] , [string] ) } , ) [EOL] [EOL] assert entry . id == entry2 . id [EOL] assert len ( mock_save . mock_calls ) == [number] [EOL] [EOL] [EOL] async def test_format_mac ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , ) [EOL] for mac in [ [string] , [string] , [string] , [string] , ] : [EOL] test_entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , mac ) } , ) [EOL] assert test_entry . id == entry . id , mac [EOL] assert test_entry . connections == { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } [EOL] [EOL] [comment] [EOL] for invalid in [ [string] , [string] , [string] , [string] , [string] , [string] , ] : [EOL] invalid_mac_entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , invalid ) } , ) [EOL] assert list ( invalid_mac_entry . connections ) [ [number] ] [ [number] ] == invalid [EOL] [EOL] [EOL] async def test_update ( registry ) : [EOL] [docstring] [EOL] entry = registry . async_get_or_create ( config_entry_id = [string] , connections = { ( device_registry . CONNECTION_NETWORK_MAC , [string] ) } , identifiers = { ( [string] , [string] ) , ( [string] , [string] ) } ) [EOL] new_identifiers = { ( [string] , [string] ) , ( [string] , [string] ) } [EOL] assert not entry . area_id [EOL] assert not entry . name_by_user [EOL] [EOL] with patch . object ( registry , [string] ) as mock_save : [EOL] updated_entry = registry . async_update_device ( entry . id , area_id = [string] , name_by_user = [string] , new_identifiers = new_identifiers ) [EOL] [EOL] assert mock_save . call_count == [number] [EOL] assert updated_entry != entry [EOL] assert updated_entry . area_id == [string] [EOL] assert updated_entry . name_by_user == [string] [EOL] assert updated_entry . identifiers == new_identifiers [EOL] [EOL] [EOL] async def test_loading_race_condition ( hass ) : [EOL] [docstring] [EOL] with asynctest . patch ( [string] , ) as mock_load : [EOL] results = await asyncio . gather ( device_registry . async_get_registry ( hass ) , device_registry . async_get_registry ( hass ) , ) [EOL] [EOL] mock_load . assert_called_once_with ( ) [EOL] assert results [ [number] ] == results [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] import asynctest [EOL] import pytest [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers import area_registry [EOL] from tests . common import mock_area_registry , flush_store [EOL] [EOL] [EOL] @ pytest . fixture def registry ( hass ) : [EOL] [docstring] [EOL] return mock_area_registry ( hass ) [EOL] [EOL] [EOL] @ pytest . fixture def update_events ( hass ) : [EOL] [docstring] [EOL] events = [ ] [EOL] [EOL] @ callback def async_capture ( event ) : [EOL] events . append ( event . data ) [EOL] [EOL] hass . bus . async_listen ( area_registry . EVENT_AREA_REGISTRY_UPDATED , async_capture ) [EOL] [EOL] return events [EOL] [EOL] [EOL] async def test_list_areas ( registry ) : [EOL] [docstring] [EOL] registry . async_create ( [string] ) [EOL] [EOL] areas = registry . async_list_areas ( ) [EOL] [EOL] assert len ( areas ) == len ( registry . areas ) [EOL] [EOL] [EOL] async def test_create_area ( hass , registry , update_events ) : [EOL] [docstring] [EOL] area = registry . async_create ( [string] ) [EOL] [EOL] assert area . name == [string] [EOL] assert len ( registry . areas ) == [number] [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( update_events ) == [number] [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == area . id [EOL] [EOL] [EOL] async def test_create_area_with_name_already_in_use ( hass , registry , update_events ) : [EOL] [docstring] [EOL] area1 = registry . async_create ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as e_info : [EOL] area2 = registry . async_create ( [string] ) [EOL] assert area1 != area2 [EOL] assert e_info == [string] [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( registry . areas ) == [number] [EOL] assert len ( update_events ) == [number] [EOL] [EOL] [EOL] async def test_delete_area ( hass , registry , update_events ) : [EOL] [docstring] [EOL] area = registry . async_create ( [string] ) [EOL] [EOL] await registry . async_delete ( area . id ) [EOL] [EOL] assert not registry . areas [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( update_events ) == [number] [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == area . id [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == area . id [EOL] [EOL] [EOL] async def test_delete_non_existing_area ( registry ) : [EOL] [docstring] [EOL] registry . async_create ( [string] ) [EOL] [EOL] with pytest . raises ( KeyError ) : [EOL] await registry . async_delete ( [string] ) [EOL] [EOL] assert len ( registry . areas ) == [number] [EOL] [EOL] [EOL] async def test_update_area ( hass , registry , update_events ) : [EOL] [docstring] [EOL] area = registry . async_create ( [string] ) [EOL] [EOL] updated_area = registry . async_update ( area . id , name = [string] ) [EOL] [EOL] assert updated_area != area [EOL] assert updated_area . name == [string] [EOL] assert len ( registry . areas ) == [number] [EOL] [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert len ( update_events ) == [number] [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == area . id [EOL] assert update_events [ [number] ] [ [string] ] == [string] [EOL] assert update_events [ [number] ] [ [string] ] == area . id [EOL] [EOL] [EOL] async def test_update_area_with_same_name ( registry ) : [EOL] [docstring] [EOL] area = registry . async_create ( [string] ) [EOL] [EOL] updated_area = registry . async_update ( area . id , name = [string] ) [EOL] [EOL] assert updated_area == area [EOL] assert len ( registry . areas ) == [number] [EOL] [EOL] [EOL] async def test_update_area_with_name_already_in_use ( registry ) : [EOL] [docstring] [EOL] area1 = registry . async_create ( [string] ) [EOL] area2 = registry . async_create ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as e_info : [EOL] registry . async_update ( area1 . id , name = [string] ) [EOL] assert e_info == [string] [EOL] [EOL] assert area1 . name == [string] [EOL] assert area2 . name == [string] [EOL] assert len ( registry . areas ) == [number] [EOL] [EOL] [EOL] async def test_load_area ( hass , registry ) : [EOL] [docstring] [EOL] registry . async_create ( [string] ) [EOL] registry . async_create ( [string] ) [EOL] [EOL] assert len ( registry . areas ) == [number] [EOL] [EOL] registry2 = area_registry . AreaRegistry ( hass ) [EOL] await flush_store ( registry . _store ) [EOL] await registry2 . async_load ( ) [EOL] [EOL] assert list ( registry . areas ) == list ( registry2 . areas ) [EOL] [EOL] [EOL] async def test_loading_area_from_storage ( hass , hass_storage ) : [EOL] [docstring] [EOL] hass_storage [ area_registry . STORAGE_KEY ] = { [string] : area_registry . STORAGE_VERSION , [string] : { [string] : [ { [string] : [string] , [string] : [string] } ] } } [EOL] [EOL] registry = await area_registry . async_get_registry ( hass ) [EOL] [EOL] assert len ( registry . areas ) == [number] [EOL] [EOL] [EOL] async def test_loading_race_condition ( hass ) : [EOL] [docstring] [EOL] with asynctest . patch ( [string] , ) as mock_load : [EOL] results = await asyncio . gather ( area_registry . async_get_registry ( hass ) , area_registry . async_get_registry ( hass ) , ) [EOL] [EOL] mock_load . assert_called_once_with ( ) [EOL] assert results [ [number] ] == results [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import model [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] from typing import Dict [EOL] [EOL] from . model import Integration , Config [EOL] [EOL] BASE = [string] . strip ( ) [EOL] [EOL] [EOL] def validate_integration ( integration ) : [EOL] [docstring] [EOL] if not ( integration . path / [string] ) . is_file ( ) : [EOL] integration . add_error ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def generate_and_validate ( integrations ) : [EOL] [docstring] [EOL] domains = [ ] [EOL] [EOL] for domain in sorted ( integrations ) : [EOL] integration = integrations [ domain ] [EOL] [EOL] if not integration . manifest : [EOL] continue [EOL] [EOL] config_flow = integration . manifest . get ( [string] ) [EOL] [EOL] if not config_flow : [EOL] continue [EOL] [EOL] validate_integration ( integration ) [EOL] [EOL] domains . append ( domain ) [EOL] [EOL] return BASE . format ( json . dumps ( domains , indent = [number] ) ) [EOL] [EOL] [EOL] def validate ( integrations , config ) : [EOL] [docstring] [EOL] config_flow_path = config . root / [string] [EOL] config . cache [ [string] ] = content = generate_and_validate ( integrations ) [EOL] [EOL] with open ( str ( config_flow_path ) , [string] ) as fp : [EOL] if fp . read ( ) . strip ( ) != content : [EOL] config . add_error ( [string] , [string] [string] , fixable = True ) [EOL] return [EOL] [EOL] [EOL] def generate ( integrations , config ) : [EOL] [docstring] [EOL] config_flow_path = config . root / [string] [EOL] with open ( str ( config_flow_path ) , [string] ) as fp : [EOL] fp . write ( config . cache [ [string] ] + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] import argparse [EOL] import os [EOL] [EOL] from homeassistant . core import HomeAssistant [EOL] import homeassistant . config as config_util [EOL] [EOL] [EOL] def run ( args ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( description = ( [string] [string] ) ) [EOL] parser . add_argument ( [string] , [string] , metavar = [string] , default = config_util . get_default_config_dir ( ) , help = [string] ) [EOL] parser . add_argument ( [string] , choices = [ [string] ] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] config_dir = os . path . join ( os . getcwd ( ) , args . config ) [EOL] [EOL] [comment] [EOL] if not os . path . isdir ( config_dir ) : [EOL] print ( [string] , config_dir ) [EOL] os . makedirs ( config_dir ) [EOL] [EOL] hass = HomeAssistant ( ) [EOL] config_path = hass . loop . run_until_complete ( async_run ( hass , config_dir ) ) [EOL] print ( [string] , config_path ) [EOL] return [number] [EOL] [EOL] [EOL] async def async_run ( hass , config_dir ) : [EOL] [docstring] [EOL] path = await config_util . async_ensure_config_exists ( hass , config_dir ) [EOL] await hass . async_stop ( force = True ) [EOL] return path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL] MFA_SESSION_EXPIRATION = timedelta ( minutes = [number] ) [EOL] [EOL] GROUP_ID_ADMIN = [string] [EOL] GROUP_ID_USER = [string] [EOL] GROUP_ID_READ_ONLY = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] from . const import CAT_ENTITIES , SUBCAT_ALL , POLICY_READ [EOL] [EOL] ADMIN_POLICY = { CAT_ENTITIES : True , } [EOL] [EOL] USER_POLICY = { CAT_ENTITIES : True , } [EOL] [EOL] READ_ONLY_POLICY = { CAT_ENTITIES : { SUBCAT_ALL : { POLICY_READ : True } } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.bool]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] CAT_ENTITIES = [string] [EOL] CAT_CONFIG_ENTRIES = [string] [EOL] SUBCAT_ALL = [string] [EOL] [EOL] POLICY_READ = [string] [EOL] POLICY_CONTROL = [string] [EOL] POLICY_EDIT = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Callable , Any , Type [EOL] import homeassistant [EOL] import models [EOL] import logging [EOL] import typing [EOL] import types [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] from typing import ( cast , Any , Callable , Dict , List , Mapping , Set , Tuple , Union , TYPE_CHECKING ) [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from . const import CAT_ENTITIES [EOL] from . models import PermissionLookup [EOL] from . types import PolicyType [EOL] from . entities import ENTITY_POLICY_SCHEMA , compile_entities [EOL] from . merge import merge_policies [comment] [EOL] from . util import test_all [EOL] [EOL] [EOL] POLICY_SCHEMA = vol . Schema ( { vol . Optional ( CAT_ENTITIES ) : ENTITY_POLICY_SCHEMA } ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class AbstractPermissions : [EOL] [docstring] [EOL] [EOL] _cached_entity_func = None [EOL] [EOL] def _entity_func ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] def access_all_entities ( self , key ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] def check_entity ( self , entity_id , key ) : [EOL] [docstring] [EOL] entity_func = self . _cached_entity_func [EOL] [EOL] if entity_func is None : [EOL] entity_func = self . _cached_entity_func = self . _entity_func ( ) [EOL] [EOL] return entity_func ( entity_id , key ) [EOL] [EOL] [EOL] class PolicyPermissions ( AbstractPermissions ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , policy , perm_lookup ) : [EOL] [docstring] [EOL] self . _policy = policy [EOL] self . _perm_lookup = perm_lookup [EOL] [EOL] def access_all_entities ( self , key ) : [EOL] [docstring] [EOL] return test_all ( self . _policy . get ( CAT_ENTITIES ) , key ) [EOL] [EOL] def _entity_func ( self ) : [EOL] [docstring] [EOL] return compile_entities ( self . _policy . get ( CAT_ENTITIES ) , self . _perm_lookup ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] [docstring] [EOL] [comment] [EOL] return ( isinstance ( other , PolicyPermissions ) and other . _policy == self . _policy ) [EOL] [EOL] [EOL] class _OwnerPermissions ( AbstractPermissions ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def access_all_entities ( self , key ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def _entity_func ( self ) : [EOL] [docstring] [EOL] return lambda entity_id , key : True [EOL] [EOL] [EOL] OwnerPermissions = _OwnerPermissions ( ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $models.PermissionLookup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $models.PermissionLookup$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Callable[[builtins.str,builtins.str],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str,builtins.str],builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] FLOWS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] SSDP = { [string] : { } , [string] : { [string] : [ [string] ] , [string] : [ [string] , [string] ] } , [string] : { [string] : [ [string] ] , [string] : [ [string] ] } } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,typing.List[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] ZEROCONF = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] } [EOL] [EOL] HOMEKIT = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import requests [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_NAME , CONF_RESOURCE ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_FUNCTIONS = [string] [EOL] CONF_PINS = [string] [EOL] CONF_INVERT = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PIN_FUNCTION_SCHEMA = vol . Schema ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_INVERT , default = False ) : cv . boolean , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_RESOURCE ) : cv . url , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PINS , default = { } ) : vol . Schema ( { cv . string : PIN_FUNCTION_SCHEMA } ) , vol . Optional ( CONF_FUNCTIONS , default = { } ) : vol . Schema ( { cv . string : PIN_FUNCTION_SCHEMA } ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] resource = config . get ( CONF_RESOURCE ) [EOL] [EOL] try : [EOL] response = requests . get ( resource , timeout = [number] ) [EOL] except requests . exceptions . MissingSchema : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return False [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] , resource ) [EOL] return False [EOL] [EOL] dev = [ ] [EOL] pins = config . get ( CONF_PINS ) [EOL] for pinnum , pin in pins . items ( ) : [EOL] dev . append ( ArestSwitchPin ( resource , config . get ( CONF_NAME , response . json ( ) [ CONF_NAME ] ) , pin . get ( CONF_NAME ) , pinnum , pin . get ( CONF_INVERT ) ) ) [EOL] [EOL] functions = config . get ( CONF_FUNCTIONS ) [EOL] for funcname , func in functions . items ( ) : [EOL] dev . append ( ArestSwitchFunction ( resource , config . get ( CONF_NAME , response . json ( ) [ CONF_NAME ] ) , func . get ( CONF_NAME ) , funcname ) ) [EOL] [EOL] add_entities ( dev ) [EOL] [EOL] [EOL] class ArestSwitchBase ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource , location , name ) : [EOL] [docstring] [EOL] self . _resource = resource [EOL] self . _name = [string] . format ( location . title ( ) , name . title ( ) ) [EOL] self . _state = None [EOL] self . _available = True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] [EOL] class ArestSwitchFunction ( ArestSwitchBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource , location , name , func ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( resource , location , name ) [EOL] self . _func = func [EOL] [EOL] request = requests . get ( [string] . format ( self . _resource , self . _func ) , timeout = [number] ) [EOL] [EOL] if request . status_code != [number] : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] try : [EOL] request . json ( ) [ [string] ] [EOL] except KeyError : [EOL] _LOGGER . error ( [string] ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] request = requests . get ( [string] . format ( self . _resource , self . _func ) , timeout = [number] , params = { [string] : [string] } ) [EOL] [EOL] if request . status_code == [number] : [EOL] self . _state = True [EOL] else : [EOL] _LOGGER . error ( [string] , self . _func , self . _resource ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] request = requests . get ( [string] . format ( self . _resource , self . _func ) , timeout = [number] , params = { [string] : [string] } ) [EOL] [EOL] if request . status_code == [number] : [EOL] self . _state = False [EOL] else : [EOL] _LOGGER . error ( [string] , self . _func , self . _resource ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] request = requests . get ( [string] . format ( self . _resource , self . _func ) , timeout = [number] ) [EOL] self . _state = request . json ( ) [ [string] ] != [number] [EOL] self . _available = True [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . warning ( [string] , self . _resource ) [EOL] self . _available = False [EOL] [EOL] [EOL] class ArestSwitchPin ( ArestSwitchBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource , location , name , pin , invert ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( resource , location , name ) [EOL] self . _pin = pin [EOL] self . invert = invert [EOL] [EOL] request = requests . get ( [string] . format ( self . _resource , self . _pin ) , timeout = [number] ) [EOL] if request . status_code != [number] : [EOL] _LOGGER . error ( [string] ) [EOL] self . _available = False [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] turn_on_payload = int ( not self . invert ) [EOL] request = requests . get ( [string] . format ( self . _resource , self . _pin , turn_on_payload ) , timeout = [number] ) [EOL] if request . status_code == [number] : [EOL] self . _state = True [EOL] else : [EOL] _LOGGER . error ( [string] , self . _pin , self . _resource ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] turn_off_payload = int ( self . invert ) [EOL] request = requests . get ( [string] . format ( self . _resource , self . _pin , turn_off_payload ) , timeout = [number] ) [EOL] if request . status_code == [number] : [EOL] self . _state = False [EOL] else : [EOL] _LOGGER . error ( [string] , self . _pin , self . _resource ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] request = requests . get ( [string] . format ( self . _resource , self . _pin ) , timeout = [number] ) [EOL] status_value = int ( self . invert ) [EOL] self . _state = request . json ( ) [ [string] ] != status_value [EOL] self . _available = True [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . warning ( [string] , self . _resource ) [EOL] self . _available = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] DATA_CLIENT = [string] [EOL] [EOL] DEFAULT_SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] TOPIC_UPDATE = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Tuple , List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] STEP_CORE_CONFIG = [string] [EOL] STEP_INTEGRATION = [string] [EOL] [EOL] STEPS = [ STEP_USER , STEP_CORE_CONFIG , STEP_INTEGRATION , ] [EOL] [EOL] DEFAULT_AREAS = ( [string] , [string] , [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import homeassistant [EOL] import datetime [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] from homeassistant . components import habitica [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] name = discovery_info [ habitica . CONF_NAME ] [EOL] sensors = discovery_info [ habitica . CONF_SENSORS ] [EOL] sensor_data = HabitipyData ( hass . data [ habitica . DOMAIN ] [ name ] ) [EOL] await sensor_data . update ( ) [EOL] async_add_devices ( [ HabitipySensor ( name , sensor , sensor_data ) for sensor in sensors ] , True ) [EOL] [EOL] [EOL] class HabitipyData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api ) : [EOL] [docstring] [EOL] self . api = api [EOL] self . data = None [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) async def update ( self ) : [EOL] [docstring] [EOL] self . data = await self . api . user . get ( ) [EOL] [EOL] [EOL] class HabitipySensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , sensor_name , updater ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _sensor_name = sensor_name [EOL] self . _sensor_type = habitica . SENSORS_TYPES [ sensor_name ] [EOL] self . _state = None [EOL] self . _updater = updater [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] await self . _updater . update ( ) [EOL] data = self . _updater . data [EOL] for element in self . _sensor_type . path : [EOL] data = data [ element ] [EOL] self . _state = data [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _sensor_type . icon [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( habitica . DOMAIN , self . _name , self . _sensor_name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _sensor_type . unit [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import datetime [EOL] [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] from . const import DOMAIN [EOL] [EOL] TIME_FRAME1_BEGIN = [string] [EOL] TIME_FRAME1_END = [string] [EOL] TIME_FRAME2_BEGIN = [string] [EOL] TIME_FRAME2_END = [string] [EOL] TIME_FRAME3_BEGIN = [string] [EOL] TIME_FRAME3_END = [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] ebusd_api = hass . data [ DOMAIN ] [EOL] monitored_conditions = discovery_info [ [string] ] [EOL] name = discovery_info [ [string] ] [EOL] [EOL] dev = [ ] [EOL] for condition in monitored_conditions : [EOL] dev . append ( EbusdSensor ( ebusd_api , discovery_info [ [string] ] [ condition ] , name ) ) [EOL] [EOL] add_entities ( dev , True ) [EOL] [EOL] [EOL] class EbusdSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , sensor , name ) : [EOL] [docstring] [EOL] self . _state = None [EOL] self . _client_name = name [EOL] self . _name , self . _unit_of_measurement , self . _icon , self . _type = sensor [EOL] self . data = data [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _type == [number] and self . _state is not None : [EOL] schedule = { TIME_FRAME1_BEGIN : None , TIME_FRAME1_END : None , TIME_FRAME2_BEGIN : None , TIME_FRAME2_END : None , TIME_FRAME3_BEGIN : None , TIME_FRAME3_END : None } [EOL] time_frame = self . _state . split ( [string] ) [EOL] for index , item in enumerate ( sorted ( schedule . items ( ) ) ) : [EOL] if index < len ( time_frame ) : [EOL] parsed = datetime . datetime . strptime ( time_frame [ index ] , [string] ) [EOL] parsed = parsed . replace ( datetime . datetime . now ( ) . year , datetime . datetime . now ( ) . month , datetime . datetime . now ( ) . day ) [EOL] schedule [ item [ [number] ] ] = parsed . isoformat ( ) [EOL] return schedule [EOL] return None [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . data . update ( self . _name , self . _type ) [EOL] if self . _name not in self . data . value : [EOL] return [EOL] [EOL] self . _state = self . data . value [ self . _name ] [EOL] except RuntimeError : [EOL] _LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Dict , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] DOMAIN = [string] [EOL] DATA_UPDATED = [string] . format ( DOMAIN ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from . const import DOMAIN [EOL] [EOL] config_entry_flow . register_webhook_flow ( DOMAIN , [string] , { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from homeassistant import config_entries [EOL] from . const import DOMAIN [EOL] from . common import async_get_discoverable_devices [EOL] [EOL] [EOL] config_entry_flow . register_discovery_flow ( DOMAIN , [string] , async_get_discoverable_devices , config_entries . CONN_CLASS_LOCAL_POLL ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import io [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import io [EOL] [EOL] from homeassistant . core import split_entity_id [EOL] [comment] [EOL] from homeassistant . components . image_processing import PLATFORM_SCHEMA [comment] [EOL] from homeassistant . components . image_processing import ( ImageProcessingFaceEntity , CONF_SOURCE , CONF_ENTITY_ID , CONF_NAME ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_LOCATION = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] entities = [ ] [EOL] for camera in config [ CONF_SOURCE ] : [EOL] entities . append ( DlibFaceDetectEntity ( camera [ CONF_ENTITY_ID ] , camera . get ( CONF_NAME ) ) ) [EOL] [EOL] add_entities ( entities ) [EOL] [EOL] [EOL] class DlibFaceDetectEntity ( ImageProcessingFaceEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , camera_entity , name = None ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _camera = camera_entity [EOL] [EOL] if name : [EOL] self . _name = name [EOL] else : [EOL] self . _name = [string] . format ( split_entity_id ( camera_entity ) [ [number] ] ) [EOL] [EOL] @ property def camera_entity ( self ) : [EOL] [docstring] [EOL] return self . _camera [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def process_image ( self , image ) : [EOL] [docstring] [EOL] import face_recognition [comment] [EOL] [EOL] fak_file = io . BytesIO ( image ) [EOL] fak_file . name = [string] [EOL] fak_file . seek ( [number] ) [EOL] [EOL] image = face_recognition . load_image_file ( fak_file ) [EOL] face_locations = face_recognition . face_locations ( image ) [EOL] [EOL] face_locations = [ { ATTR_LOCATION : location } for location in face_locations ] [EOL] [EOL] self . process_faces ( face_locations , len ( face_locations ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 $typing.Any$ 0 0 $io.BytesIO$ 0 $typing.Any$ 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.BytesIO$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] [EOL] from homeassistant . components . sensor import ENTITY_ID_FORMAT [EOL] from homeassistant . const import TEMP_FAHRENHEIT [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import slugify [EOL] [EOL] from . import DOMAIN as WF_DOMAIN , UPDATE_TOPIC [EOL] [EOL] [EOL] class WFSensorConfig : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , friendly_name , field , icon = [string] , unit_of_measurement = None ) : [EOL] [docstring] [EOL] self . friendly_name = friendly_name [EOL] self . field = field [EOL] self . icon = icon [EOL] self . unit_of_measurement = unit_of_measurement [EOL] [EOL] [EOL] SENSORS = [ WFSensorConfig ( [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] sensors = [ ] [EOL] client = hass . data [ WF_DOMAIN ] [EOL] for sconfig in SENSORS : [EOL] sensors . append ( WaterFurnaceSensor ( client , sconfig ) ) [EOL] [EOL] add_entities ( sensors ) [EOL] [EOL] [EOL] class WaterFurnaceSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , config ) : [EOL] [docstring] [EOL] self . client = client [EOL] self . _name = config . friendly_name [EOL] self . _attr = config . field [EOL] self . _state = None [EOL] self . _icon = config . icon [EOL] self . _unit_of_measurement = config . unit_of_measurement [EOL] [EOL] [comment] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( [string] . format ( slugify ( self . client . unit ) , slugify ( self . _attr ) ) ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( UPDATE_TOPIC , self . async_update_callback ) [EOL] [EOL] @ callback def async_update_callback ( self ) : [EOL] [docstring] [EOL] if self . client . data is not None : [EOL] self . _state = getattr ( self . client . data , self . _attr , None ) [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[homeassistant.components.waterfurnace.sensor.WFSensorConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[homeassistant.components.waterfurnace.sensor.WFSensorConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import datetime [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] import time [EOL] import threading [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers import discovery [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] UPDATE_TOPIC = DOMAIN + [string] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] ERROR_INTERVAL = timedelta ( seconds = [number] ) [EOL] MAX_FAILS = [number] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , base_config ) : [EOL] [docstring] [EOL] import waterfurnace . waterfurnace as wf [EOL] config = base_config . get ( DOMAIN ) [EOL] [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] wfconn = wf . WaterFurnace ( username , password ) [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] wfconn . login ( ) [EOL] except wf . WFCredentialError : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] hass . data [ DOMAIN ] = WaterFurnaceData ( hass , wfconn ) [EOL] hass . data [ DOMAIN ] . start ( ) [EOL] [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] return True [EOL] [EOL] [EOL] class WaterFurnaceData ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , client ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . hass = hass [EOL] self . client = client [EOL] self . unit = self . client . gwid [EOL] self . data = None [EOL] self . _shutdown = False [EOL] self . _fails = [number] [EOL] [EOL] def _reconnect ( self ) : [EOL] [docstring] [EOL] import waterfurnace . waterfurnace as wf [EOL] self . _fails += [number] [EOL] if self . _fails > MAX_FAILS : [EOL] _LOGGER . error ( [string] ) [EOL] self . hass . components . persistent_notification . create ( [string] [string] , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] [EOL] self . _shutdown = True [EOL] return [EOL] [EOL] [comment] [EOL] _LOGGER . debug ( [string] , self . _fails ) [EOL] time . sleep ( self . _fails * ERROR_INTERVAL . seconds ) [EOL] [EOL] try : [EOL] self . client . login ( ) [EOL] self . data = self . client . read ( ) [EOL] except wf . WFException : [EOL] _LOGGER . exception ( [string] , self . _fails ) [EOL] else : [EOL] _LOGGER . debug ( [string] ) [EOL] self . _fails = [number] [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] import waterfurnace . waterfurnace as wf [EOL] [EOL] @ callback def register ( ) : [EOL] [docstring] [EOL] def shutdown ( event ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] self . _shutdown = True [EOL] self . join ( ) [EOL] [EOL] self . hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , shutdown ) [EOL] [EOL] self . hass . add_job ( register ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] while True : [EOL] if self . _shutdown : [EOL] _LOGGER . debug ( [string] ) [EOL] return [EOL] [EOL] try : [EOL] self . data = self . client . read ( ) [EOL] [EOL] except wf . WFException : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _LOGGER . exception ( [string] ) [EOL] self . _reconnect ( ) [EOL] [EOL] else : [EOL] self . hass . helpers . dispatcher . dispatcher_send ( UPDATE_TOPIC ) [EOL] time . sleep ( SCAN_INTERVAL . seconds ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Set , Tuple , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components import websocket_api [EOL] from homeassistant . core import split_entity_id [EOL] from homeassistant . helpers . entity_registry import async_entries_for_device [EOL] from homeassistant . loader import async_get_integration , IntegrationNotFound [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] hass . components . websocket_api . async_register_command ( websocket_device_automation_list_triggers ) [EOL] return True [EOL] [EOL] [EOL] async def _async_get_device_automation_triggers ( hass , domain , device_id ) : [EOL] [docstring] [EOL] integration = None [EOL] try : [EOL] integration = await async_get_integration ( hass , domain ) [EOL] except IntegrationNotFound : [EOL] _LOGGER . warning ( [string] , domain ) [EOL] return None [EOL] [EOL] try : [EOL] platform = integration . get_platform ( [string] ) [EOL] except ImportError : [EOL] [comment] [EOL] return None [EOL] [EOL] if hasattr ( platform , [string] ) : [EOL] return await platform . async_get_triggers ( hass , device_id ) [EOL] [EOL] [EOL] async def async_get_device_automation_triggers ( hass , device_id ) : [EOL] [docstring] [EOL] device_registry , entity_registry = await asyncio . gather ( hass . helpers . device_registry . async_get_registry ( ) , hass . helpers . entity_registry . async_get_registry ( ) ) [EOL] [EOL] domains = set ( ) [EOL] triggers = [ ] [EOL] device = device_registry . async_get ( device_id ) [EOL] for entry_id in device . config_entries : [EOL] config_entry = hass . config_entries . async_get_entry ( entry_id ) [EOL] domains . add ( config_entry . domain ) [EOL] [EOL] entities = async_entries_for_device ( entity_registry , device_id ) [EOL] for entity in entities : [EOL] domains . add ( split_entity_id ( entity . entity_id ) [ [number] ] ) [EOL] [EOL] device_triggers = await asyncio . gather ( * [ _async_get_device_automation_triggers ( hass , domain , device_id ) for domain in domains ] ) [EOL] for device_trigger in device_triggers : [EOL] if device_trigger is not None : [EOL] triggers . extend ( device_trigger ) [EOL] [EOL] return triggers [EOL] [EOL] [EOL] @ websocket_api . async_response @ websocket_api . websocket_command ( { vol . Required ( [string] ) : [string] , vol . Required ( [string] ) : str , } ) async def websocket_device_automation_list_triggers ( hass , connection , msg ) : [EOL] [docstring] [EOL] device_id = msg [ [string] ] [EOL] triggers = await async_get_device_automation_triggers ( hass , device_id ) [EOL] connection . send_result ( msg [ [string] ] , { [string] : triggers } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Set , Tuple , List , Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import queue [EOL] import threading [EOL] import time [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_DOMAINS , CONF_ENTITIES , CONF_EXCLUDE , CONF_ID , CONF_INCLUDE , CONF_TOKEN , CONF_TYPE , EVENT_HOMEASSISTANT_STOP , EVENT_STATE_CHANGED , STATE_UNAVAILABLE , STATE_UNKNOWN ) [EOL] from homeassistant . helpers import state as state_helper [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ORG = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] MAX_TRIES = [number] [EOL] [EOL] RETRY_DELAY = [number] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . All ( vol . Schema ( { vol . Required ( CONF_ORG ) : cv . string , vol . Required ( CONF_TYPE ) : cv . string , vol . Required ( CONF_ID ) : cv . string , vol . Required ( CONF_TOKEN ) : cv . string , vol . Optional ( CONF_EXCLUDE , default = { } ) : vol . Schema ( { vol . Optional ( CONF_ENTITIES , default = [ ] ) : cv . entity_ids , vol . Optional ( CONF_DOMAINS , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) } ) , vol . Optional ( CONF_INCLUDE , default = { } ) : vol . Schema ( { vol . Optional ( CONF_ENTITIES , default = [ ] ) : cv . entity_ids , vol . Optional ( CONF_DOMAINS , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) , } ) ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] from ibmiotf import gateway [EOL] [EOL] conf = config [ DOMAIN ] [EOL] [EOL] include = conf [ CONF_INCLUDE ] [EOL] exclude = conf [ CONF_EXCLUDE ] [EOL] whitelist_e = set ( include [ CONF_ENTITIES ] ) [EOL] whitelist_d = set ( include [ CONF_DOMAINS ] ) [EOL] blacklist_e = set ( exclude [ CONF_ENTITIES ] ) [EOL] blacklist_d = set ( exclude [ CONF_DOMAINS ] ) [EOL] [EOL] client_args = { [string] : conf [ CONF_ORG ] , [string] : conf [ CONF_TYPE ] , [string] : conf [ CONF_ID ] , [string] : [string] , [string] : conf [ CONF_TOKEN ] , } [EOL] watson_gateway = gateway . Client ( client_args ) [EOL] [EOL] def event_to_json ( event ) : [EOL] [docstring] [EOL] state = event . data . get ( [string] ) [EOL] if state is None or state . state in ( STATE_UNKNOWN , [string] , STATE_UNAVAILABLE ) or state . entity_id in blacklist_e or state . domain in blacklist_d : [EOL] return [EOL] [EOL] if ( whitelist_e and state . entity_id not in whitelist_e ) or ( whitelist_d and state . domain not in whitelist_d ) : [EOL] return [EOL] [EOL] try : [EOL] _state_as_value = float ( state . state ) [EOL] except ValueError : [EOL] _state_as_value = None [EOL] [EOL] if _state_as_value is None : [EOL] try : [EOL] _state_as_value = float ( state_helper . state_as_number ( state ) ) [EOL] except ValueError : [EOL] _state_as_value = None [EOL] [EOL] out_event = { [string] : { [string] : state . domain , [string] : state . object_id , } , [string] : event . time_fired . isoformat ( ) , [string] : { [string] : state . state , } } [EOL] if _state_as_value is not None : [EOL] out_event [ [string] ] [ [string] ] = _state_as_value [EOL] [EOL] for key , value in state . attributes . items ( ) : [EOL] if key != [string] : [EOL] [comment] [EOL] if key in out_event [ [string] ] : [EOL] key = [string] . format ( key ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] out_event [ [string] ] [ key ] = float ( value ) [EOL] except ( ValueError , TypeError ) : [EOL] out_event [ [string] ] [ key ] = str ( value ) [EOL] [EOL] return out_event [EOL] [EOL] instance = hass . data [ DOMAIN ] = WatsonIOTThread ( hass , watson_gateway , event_to_json ) [EOL] instance . start ( ) [EOL] [EOL] def shutdown ( event ) : [EOL] [docstring] [EOL] instance . queue . put ( None ) [EOL] instance . join ( ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , shutdown ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class WatsonIOTThread ( threading . Thread ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , gateway , event_to_json ) : [EOL] [docstring] [EOL] threading . Thread . __init__ ( self , name = [string] ) [EOL] self . queue = queue . Queue ( ) [EOL] self . gateway = gateway [EOL] self . gateway . connect ( ) [EOL] self . event_to_json = event_to_json [EOL] self . write_errors = [number] [EOL] self . shutdown = False [EOL] hass . bus . listen ( EVENT_STATE_CHANGED , self . _event_listener ) [EOL] [EOL] def _event_listener ( self , event ) : [EOL] [docstring] [EOL] item = ( time . monotonic ( ) , event ) [EOL] self . queue . put ( item ) [EOL] [EOL] def get_events_json ( self ) : [EOL] [docstring] [EOL] events = [ ] [EOL] [EOL] try : [EOL] item = self . queue . get ( ) [EOL] [EOL] if item is None : [EOL] self . shutdown = True [EOL] else : [EOL] event_json = self . event_to_json ( item [ [number] ] ) [EOL] if event_json : [EOL] events . append ( event_json ) [EOL] [EOL] except queue . Empty : [EOL] pass [EOL] [EOL] return events [EOL] [EOL] def write_to_watson ( self , events ) : [EOL] [docstring] [EOL] import ibmiotf [EOL] [EOL] for event in events : [EOL] for retry in range ( MAX_TRIES + [number] ) : [EOL] try : [EOL] for field in event [ [string] ] : [EOL] value = event [ [string] ] [ field ] [EOL] device_success = self . gateway . publishDeviceEvent ( event [ [string] ] [ [string] ] , event [ [string] ] [ [string] ] , field , [string] , value ) [EOL] if not device_success : [EOL] _LOGGER . error ( [string] ) [EOL] continue [EOL] break [EOL] except ( ibmiotf . MissingMessageEncoderException , IOError ) : [EOL] if retry < MAX_TRIES : [EOL] time . sleep ( RETRY_DELAY ) [EOL] else : [EOL] _LOGGER . exception ( [string] ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] while not self . shutdown : [EOL] event = self . get_events_json ( ) [EOL] if event : [EOL] self . write_to_watson ( event ) [EOL] self . queue . task_done ( ) [EOL] [EOL] def block_till_done ( self ) : [EOL] [docstring] [EOL] self . queue . join ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . air_quality import ( PLATFORM_SCHEMA , AirQualityEntity ) [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTRIBUTION = [string] [EOL] [EOL] CONF_STATION_ID = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_STATION_ID ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from opensensemap_api import OpenSenseMap [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] station_id = config [ CONF_STATION_ID ] [EOL] [EOL] session = async_get_clientsession ( hass ) [EOL] osm_api = OpenSenseMapData ( OpenSenseMap ( station_id , hass . loop , session ) ) [EOL] [EOL] await osm_api . async_update ( ) [EOL] [EOL] if [string] not in osm_api . api . data : [EOL] _LOGGER . error ( [string] , station_id ) [EOL] return [EOL] [EOL] station_name = osm_api . api . data [ [string] ] if name is None else name [EOL] [EOL] async_add_entities ( [ OpenSenseMapQuality ( station_name , osm_api ) ] , True ) [EOL] [EOL] [EOL] class OpenSenseMapQuality ( AirQualityEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , osm ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _osm = osm [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def particulate_matter_2_5 ( self ) : [EOL] [docstring] [EOL] return self . _osm . api . pm2_5 [EOL] [EOL] @ property def particulate_matter_10 ( self ) : [EOL] [docstring] [EOL] return self . _osm . api . pm10 [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] return ATTRIBUTION [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] await self . _osm . async_update ( ) [EOL] [EOL] [EOL] class OpenSenseMapData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api ) : [EOL] [docstring] [EOL] self . api = api [EOL] [EOL] @ Throttle ( SCAN_INTERVAL ) async def async_update ( self ) : [EOL] [docstring] [EOL] from opensensemap_api . exceptions import OpenSenseMapError [EOL] [EOL] try : [EOL] await self . api . get_data ( ) [EOL] except OpenSenseMapError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] CONF_ENABLE_PORT_MAPPING = [string] [EOL] CONF_ENABLE_SENSORS = [string] [EOL] CONF_HASS = [string] [EOL] CONF_LOCAL_IP = [string] [EOL] CONF_PORTS = [string] [EOL] DOMAIN = [string] [EOL] LOGGER = logging . getLogger ( __package__ ) [EOL] SIGNAL_REMOVE_SENSOR = [string] [EOL]	0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from homeassistant import config_entries [EOL] [EOL] from . const import DOMAIN [EOL] from . device import Device [EOL] [EOL] [EOL] config_entry_flow . register_discovery_flow ( DOMAIN , [string] , Device . async_discover , config_entries . CONN_CLASS_LOCAL_POLL ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . ffmpeg import ( FFmpegBase , DATA_FFMPEG , CONF_INPUT , CONF_EXTRA_ARGUMENTS , CONF_INITIAL_STATE ) [EOL] from homeassistant . const import CONF_NAME [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_RESET = [string] [EOL] CONF_CHANGES = [string] [EOL] CONF_REPEAT = [string] [EOL] CONF_REPEAT_TIME = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_INIT_STATE = True [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_INPUT ) : cv . string , vol . Optional ( CONF_INITIAL_STATE , default = DEFAULT_INIT_STATE ) : cv . boolean , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_EXTRA_ARGUMENTS ) : cv . string , vol . Optional ( CONF_RESET , default = [number] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) , vol . Optional ( CONF_CHANGES , default = [number] ) : vol . All ( vol . Coerce ( float ) , vol . Range ( min = [number] , max = [number] ) ) , vol . Inclusive ( CONF_REPEAT , [string] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) , vol . Inclusive ( CONF_REPEAT_TIME , [string] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] manager = hass . data [ DATA_FFMPEG ] [EOL] entity = FFmpegMotion ( hass , manager , config ) [EOL] async_add_entities ( [ entity ] ) [EOL] [EOL] [EOL] class FFmpegBinarySensor ( FFmpegBase , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( config . get ( CONF_INITIAL_STATE ) ) [EOL] [EOL] self . _state = False [EOL] self . _config = config [EOL] self . _name = config . get ( CONF_NAME ) [EOL] [EOL] @ callback def _async_callback ( self , state ) : [EOL] [docstring] [EOL] self . _state = state [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] [EOL] class FFmpegMotion ( FFmpegBinarySensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , manager , config ) : [EOL] [docstring] [EOL] from haffmpeg . sensor import SensorMotion [EOL] [EOL] super ( ) . __init__ ( config ) [EOL] self . ffmpeg = SensorMotion ( manager . binary , hass . loop , self . _async_callback ) [EOL] [EOL] async def _async_start_ffmpeg ( self , entity_ids ) : [EOL] [docstring] [EOL] if entity_ids is not None and self . entity_id not in entity_ids : [EOL] return [EOL] [EOL] [comment] [EOL] self . ffmpeg . set_options ( time_reset = self . _config . get ( CONF_RESET ) , time_repeat = self . _config . get ( CONF_REPEAT_TIME , [number] ) , repeat = self . _config . get ( CONF_REPEAT , [number] ) , changes = self . _config . get ( CONF_CHANGES ) , ) [EOL] [EOL] [comment] [EOL] await self . ffmpeg . open_sensor ( input_source = self . _config . get ( CONF_INPUT ) , extra_cmd = self . _config . get ( CONF_EXTRA_ARGUMENTS ) , ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from homeassistant . components . air_quality import AirQualityEntity [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] add_entities ( [ DemoAirQuality ( [string] , [number] , [number] , [number] ) , DemoAirQuality ( [string] , [number] , [number] , None ) ] ) [EOL] [EOL] [EOL] class DemoAirQuality ( AirQualityEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , pm_2_5 , pm_10 , n2o ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _pm_2_5 = pm_2_5 [EOL] self . _pm_10 = pm_10 [EOL] self . _n2o = n2o [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( [string] , self . _name ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def particulate_matter_2_5 ( self ) : [EOL] [docstring] [EOL] return self . _pm_2_5 [EOL] [EOL] @ property def particulate_matter_10 ( self ) : [EOL] [docstring] [EOL] return self . _pm_10 [EOL] [EOL] @ property def nitrogen_oxide ( self ) : [EOL] [docstring] [EOL] return self . _n2o [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import time [EOL] [EOL] from homeassistant import bootstrap [EOL] import homeassistant . core as ha [EOL] from homeassistant . const import ATTR_ENTITY_ID , EVENT_HOMEASSISTANT_START [EOL] [EOL] DOMAIN = [string] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] COMPONENTS_WITH_DEMO_PLATFORM = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] if DOMAIN not in config : [EOL] return True [EOL] [EOL] config . setdefault ( ha . DOMAIN , { } ) [EOL] config . setdefault ( DOMAIN , { } ) [EOL] [EOL] [comment] [EOL] for component in COMPONENTS_WITH_DEMO_PLATFORM : [EOL] hass . async_create_task ( hass . helpers . discovery . async_load_platform ( component , DOMAIN , { } , config , ) ) [EOL] [EOL] [comment] [EOL] if not hass . config . latitude : [EOL] hass . config . latitude = [number] [EOL] [EOL] if not hass . config . longitude : [EOL] hass . config . longitude = [number] [EOL] [EOL] tasks = [ bootstrap . async_setup_component ( hass , [string] , config ) ] [EOL] [EOL] [comment] [EOL] tasks . append ( bootstrap . async_setup_component ( hass , [string] , { [string] : { [string] : { [string] : [ [string] , [string] , [string] ] } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] ] } } } ) ) [EOL] [EOL] [comment] [EOL] tasks . append ( bootstrap . async_setup_component ( hass , [string] , { [string] : { [string] : { [string] : [string] , [string] : False , [string] : [string] } } } ) ) [EOL] [EOL] [comment] [EOL] tasks . append ( bootstrap . async_setup_component ( hass , [string] , { [string] : { [string] : { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] } } } ) ) [EOL] [EOL] [comment] [EOL] tasks . append ( bootstrap . async_setup_component ( hass , [string] , { [string] : { [string] : [ { [string] : [string] , [string] : [string] } ] } } ) ) [EOL] [EOL] results = await asyncio . gather ( * tasks ) [EOL] [EOL] if any ( not result for result in results ) : [EOL] return False [EOL] [EOL] [comment] [EOL] hass . components . persistent_notification . async_create ( [string] , title = [string] ) [EOL] [EOL] [comment] [EOL] configurator_ids = [ ] [EOL] configurator = hass . components . configurator [EOL] [EOL] def hue_configuration_callback ( data ) : [EOL] [docstring] [EOL] time . sleep ( [number] ) [EOL] [EOL] [comment] [EOL] if len ( configurator_ids ) == [number] : [EOL] configurator . notify_errors ( configurator_ids [ [number] ] , [string] ) [EOL] [EOL] configurator_ids . append ( [number] ) [EOL] else : [EOL] configurator . request_done ( configurator_ids [ [number] ] ) [EOL] [EOL] request_id = configurator . async_request_config ( [string] , hue_configuration_callback , description = ( [string] [string] ) , description_image = [string] , fields = [ { [string] : [string] , [string] : [string] } ] , submit_caption = [string] ) [EOL] configurator_ids . append ( request_id ) [EOL] [EOL] async def demo_start_listener ( _event ) : [EOL] [docstring] [EOL] await finish_setup ( hass , config ) [EOL] [EOL] hass . bus . async_listen ( EVENT_HOMEASSISTANT_START , demo_start_listener ) [EOL] [EOL] return True [EOL] [EOL] [EOL] async def finish_setup ( hass , config ) : [EOL] [docstring] [EOL] lights = sorted ( hass . states . async_entity_ids ( [string] ) ) [EOL] switches = sorted ( hass . states . async_entity_ids ( [string] ) ) [EOL] [EOL] [comment] [EOL] await bootstrap . async_setup_component ( hass , [string] , { [string] : { [string] : { [string] : [string] , [string] : switches , [string] : [number] , [string] : [number] } } } ) [EOL] [EOL] [comment] [EOL] await bootstrap . async_setup_component ( hass , [string] , { [string] : { [string] : { [string] : [string] . format ( lights [ [number] ] . split ( [string] ) [ [number] ] ) , [string] : [ { [string] : [string] , [string] : { ATTR_ENTITY_ID : lights [ [number] ] } } , { [string] : { [string] : [number] } } , { [string] : [string] , [string] : { ATTR_ENTITY_ID : lights [ [number] ] } } , { [string] : { [string] : [number] } } , { [string] : [string] , [string] : { ATTR_ENTITY_ID : lights [ [number] ] } } ] } } } ) [EOL] [EOL] [comment] [EOL] await bootstrap . async_setup_component ( hass , [string] , { [string] : [ { [string] : [string] , [string] : { lights [ [number] ] : True , lights [ [number] ] : { [string] : [string] , [string] : [ [number] , [number] ] , [string] : [number] } , } } , { [string] : [string] , [string] : { switches [ [number] ] : True , switches [ [number] ] : False , } } , ] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL] ATTR_PASSIVE = [string] [EOL] ATTR_RADIUS = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . const import CONF_PLATFORM [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . helpers . event import track_point_in_utc_time [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_NUMBER = [string] [EOL] CONF_HELD_MORE_THAN = [string] [EOL] CONF_HELD_LESS_THAN = [string] [EOL] [EOL] TRIGGER_SCHEMA = vol . Schema ( { vol . Required ( CONF_PLATFORM ) : [string] , vol . Required ( CONF_NUMBER ) : cv . positive_int , vol . Optional ( CONF_HELD_MORE_THAN ) : vol . All ( cv . time_period , cv . positive_timedelta ) , vol . Optional ( CONF_HELD_LESS_THAN ) : vol . All ( cv . time_period , cv . positive_timedelta ) } ) [EOL] [EOL] [EOL] async def async_trigger ( hass , config , action , automation_info ) : [EOL] [docstring] [EOL] number = config . get ( CONF_NUMBER ) [EOL] held_more_than = config . get ( CONF_HELD_MORE_THAN ) [EOL] held_less_than = config . get ( CONF_HELD_LESS_THAN ) [EOL] pressed_time = None [EOL] cancel_pressed_more_than = None [EOL] [EOL] @ callback def call_action ( ) : [EOL] [docstring] [EOL] hass . async_run_job ( action , { [string] : { CONF_PLATFORM : [string] , CONF_NUMBER : number , CONF_HELD_MORE_THAN : held_more_than , CONF_HELD_LESS_THAN : held_less_than } , } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ callback def pressed_more_than_satisfied ( now ) : [EOL] [docstring] [EOL] call_action ( ) [EOL] [EOL] def pressed ( ) : [EOL] [docstring] [EOL] nonlocal cancel_pressed_more_than , pressed_time [EOL] nonlocal held_less_than , held_more_than [EOL] pressed_time = dt_util . utcnow ( ) [EOL] if held_more_than is None and held_less_than is None : [EOL] hass . add_job ( call_action ) [EOL] if held_more_than is not None and held_less_than is None : [EOL] cancel_pressed_more_than = track_point_in_utc_time ( hass , pressed_more_than_satisfied , dt_util . utcnow ( ) + held_more_than ) [EOL] [EOL] def released ( ) : [EOL] [docstring] [EOL] nonlocal cancel_pressed_more_than , pressed_time [EOL] nonlocal held_less_than , held_more_than [EOL] [comment] [EOL] if cancel_pressed_more_than is not None : [EOL] cancel_pressed_more_than ( ) [EOL] cancel_pressed_more_than = None [EOL] held_time = dt_util . utcnow ( ) - pressed_time [EOL] if held_less_than is not None and held_time < held_less_than : [EOL] if held_more_than is None or held_time > held_more_than : [EOL] hass . add_job ( call_action ) [EOL] [EOL] hass . data [ [string] ] . on_switch_pressed ( number , pressed ) [EOL] hass . data [ [string] ] . on_switch_released ( number , released ) [EOL] [EOL] def async_remove ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] return async_remove [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components import mqtt [EOL] from homeassistant . const import ( CONF_PLATFORM , CONF_PAYLOAD ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] CONF_ENCODING = [string] [EOL] CONF_TOPIC = [string] [EOL] DEFAULT_ENCODING = [string] [EOL] [EOL] TRIGGER_SCHEMA = vol . Schema ( { vol . Required ( CONF_PLATFORM ) : mqtt . DOMAIN , vol . Required ( CONF_TOPIC ) : mqtt . valid_subscribe_topic , vol . Optional ( CONF_PAYLOAD ) : cv . string , vol . Optional ( CONF_ENCODING , default = DEFAULT_ENCODING ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_trigger ( hass , config , action , automation_info ) : [EOL] [docstring] [EOL] topic = config [ CONF_TOPIC ] [EOL] payload = config . get ( CONF_PAYLOAD ) [EOL] encoding = config [ CONF_ENCODING ] or None [EOL] [EOL] @ callback def mqtt_automation_listener ( mqttmsg ) : [EOL] [docstring] [EOL] if payload is None or payload == mqttmsg . payload : [EOL] data = { [string] : [string] , [string] : mqttmsg . topic , [string] : mqttmsg . payload , [string] : mqttmsg . qos , } [EOL] [EOL] try : [EOL] data [ [string] ] = json . loads ( mqttmsg . payload ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] hass . async_run_job ( action , { [string] : data } ) [EOL] [EOL] remove = await mqtt . async_subscribe ( hass , topic , mqtt_automation_listener , encoding = encoding ) [EOL] return remove [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from homeassistant import config_entries [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] async def _async_has_devices ( hass ) : [EOL] [docstring] [EOL] from pychromecast . discovery import discover_chromecasts [EOL] [EOL] return await hass . async_add_executor_job ( discover_chromecasts ) [EOL] [EOL] [EOL] config_entry_flow . register_discovery_flow ( DOMAIN , [string] , _async_has_devices , config_entries . CONN_CLASS_LOCAL_PUSH ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant import config_entries [EOL] [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config . get ( DOMAIN ) [EOL] [EOL] hass . data [ DOMAIN ] = conf or { } [EOL] [EOL] if conf is not None : [EOL] hass . async_create_task ( hass . config_entries . flow . async_init ( DOMAIN , context = { [string] : config_entries . SOURCE_IMPORT } ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry ) : [EOL] [docstring] [EOL] hass . async_create_task ( hass . config_entries . async_forward_entry_setup ( entry , [string] ) ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] DATA_CONFIG = [string] [EOL] DATA_HASS_CONFIG = [string] [EOL] DATA_SESSIONS = [string] [EOL] [EOL] CONF_ACCESS_KEY_ID = [string] [EOL] CONF_CONTEXT = [string] [EOL] CONF_CREDENTIAL_NAME = [string] [EOL] CONF_CREDENTIALS = [string] [EOL] CONF_NOTIFY = [string] [EOL] CONF_PROFILE_NAME = [string] [EOL] CONF_REGION = [string] [EOL] CONF_SECRET_ACCESS_KEY = [string] [EOL] CONF_SERVICE = [string] [EOL] CONF_VALIDATE = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import ( PLATFORM_SCHEMA , BinarySensorDevice ) [EOL] from homeassistant . const import ATTR_ATTRIBUTION , CONF_API_KEY [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_TARGET = [string] [EOL] [EOL] ATTRIBUTION = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pyuptimerobot import UptimeRobot [EOL] [EOL] up_robot = UptimeRobot ( ) [EOL] api_key = config . get ( CONF_API_KEY ) [EOL] monitors = up_robot . getMonitors ( api_key ) [EOL] [EOL] devices = [ ] [EOL] if not monitors or monitors . get ( [string] ) != [string] : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] for monitor in monitors [ [string] ] : [EOL] devices . append ( UptimeRobotBinarySensor ( api_key , up_robot , monitor [ [string] ] , monitor [ [string] ] , monitor [ [string] ] ) ) [EOL] [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class UptimeRobotBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_key , up_robot , monitor_id , name , target ) : [EOL] [docstring] [EOL] self . _api_key = api_key [EOL] self . _monitor_id = str ( monitor_id ) [EOL] self . _name = name [EOL] self . _target = target [EOL] self . _up_robot = up_robot [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : ATTRIBUTION , ATTR_TARGET : self . _target , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] monitor = self . _up_robot . getMonitors ( self . _api_key , self . _monitor_id ) [EOL] if not monitor or monitor . get ( [string] ) != [string] : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] status = monitor [ [string] ] [ [number] ] [ [string] ] [EOL] self . _state = [number] if status == [number] else [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL] DATA_EVOHOME = [string] + DOMAIN [EOL] DISPATCHER_EVOHOME = [string] + DOMAIN [EOL] [EOL] [comment] [EOL] GWS = [string] [EOL] TCS = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Any , Dict , List [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . climate import ClimateDevice , PLATFORM_SCHEMA [EOL] from homeassistant . components . climate . const import ( STATE_HEAT , SUPPORT_ON_OFF , SUPPORT_TARGET_TEMPERATURE , SUPPORT_OPERATION_MODE , SUPPORT_AWAY_MODE , STATE_MANUAL , STATE_AUTO , STATE_ECO , STATE_COOL ) [EOL] from homeassistant . const import ( STATE_OFF , TEMP_CELSIUS , ATTR_TEMPERATURE , CONF_NAME ) [EOL] from homeassistant . util import Throttle [EOL] [EOL] from . const import DATA_NETATMO_AUTH [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_HOMES = [string] [EOL] CONF_ROOMS = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] HOME_CONFIG_SCHEMA = vol . Schema ( { vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_ROOMS , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOMES ) : vol . All ( cv . ensure_list , [ HOME_CONFIG_SCHEMA ] ) } ) [EOL] [EOL] STATE_NETATMO_SCHEDULE = [string] [EOL] STATE_NETATMO_HG = [string] [EOL] STATE_NETATMO_MAX = [string] [EOL] STATE_NETATMO_AWAY = [string] [EOL] STATE_NETATMO_OFF = STATE_OFF [EOL] STATE_NETATMO_MANUAL = STATE_MANUAL [EOL] [EOL] DICT_NETATMO_TO_HA = { STATE_NETATMO_SCHEDULE : STATE_AUTO , STATE_NETATMO_HG : STATE_COOL , STATE_NETATMO_MAX : STATE_HEAT , STATE_NETATMO_AWAY : STATE_ECO , STATE_NETATMO_OFF : STATE_OFF , STATE_NETATMO_MANUAL : STATE_MANUAL } [EOL] [EOL] DICT_HA_TO_NETATMO = { STATE_AUTO : STATE_NETATMO_SCHEDULE , STATE_COOL : STATE_NETATMO_HG , STATE_HEAT : STATE_NETATMO_MAX , STATE_ECO : STATE_NETATMO_AWAY , STATE_OFF : STATE_NETATMO_OFF , STATE_MANUAL : STATE_NETATMO_MANUAL } [EOL] [EOL] SUPPORT_FLAGS = ( SUPPORT_TARGET_TEMPERATURE | SUPPORT_OPERATION_MODE | SUPPORT_AWAY_MODE ) [EOL] [EOL] NA_THERM = [string] [EOL] NA_VALVE = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import pyatmo [EOL] homes_conf = config . get ( CONF_HOMES ) [EOL] [EOL] auth = hass . data [ DATA_NETATMO_AUTH ] [EOL] [EOL] try : [EOL] home_data = HomeData ( auth ) [EOL] except pyatmo . NoDevice : [EOL] return [EOL] [EOL] homes = [ ] [EOL] rooms = { } [EOL] if homes_conf is not None : [EOL] for home_conf in homes_conf : [EOL] home = home_conf [ CONF_NAME ] [EOL] if home_conf [ CONF_ROOMS ] != [ ] : [EOL] rooms [ home ] = home_conf [ CONF_ROOMS ] [EOL] homes . append ( home ) [EOL] else : [EOL] homes = home_data . get_home_names ( ) [EOL] [EOL] devices = [ ] [EOL] for home in homes : [EOL] _LOGGER . debug ( [string] , home ) [EOL] try : [EOL] room_data = ThermostatData ( auth , home ) [EOL] except pyatmo . NoDevice : [EOL] continue [EOL] for room_id in room_data . get_room_ids ( ) : [EOL] room_name = room_data . homedata . rooms [ home ] [ room_id ] [ [string] ] [EOL] _LOGGER . debug ( [string] , room_name , room_id ) [EOL] if home in rooms and room_name not in rooms [ home ] : [EOL] _LOGGER . debug ( [string] , room_name ) [EOL] continue [EOL] _LOGGER . debug ( [string] , room_name , room_id ) [EOL] devices . append ( NetatmoThermostat ( room_data , room_id ) ) [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class NetatmoThermostat ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , room_id ) : [EOL] [docstring] [EOL] self . _data = data [EOL] self . _state = None [EOL] self . _room_id = room_id [EOL] room_name = self . _data . homedata . rooms [ self . _data . home ] [ room_id ] [ [string] ] [EOL] self . _name = [string] . format ( room_name ) [EOL] self . _target_temperature = None [EOL] self . _away = None [EOL] self . _module_type = self . _data . room_status [ room_id ] [ [string] ] [EOL] if self . _module_type == NA_VALVE : [EOL] self . _operation_list = [ DICT_NETATMO_TO_HA [ STATE_NETATMO_SCHEDULE ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_MANUAL ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_AWAY ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_HG ] ] [EOL] self . _support_flags = SUPPORT_FLAGS [EOL] elif self . _module_type == NA_THERM : [EOL] self . _operation_list = [ DICT_NETATMO_TO_HA [ STATE_NETATMO_SCHEDULE ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_MANUAL ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_AWAY ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_HG ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_MAX ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_OFF ] ] [EOL] self . _support_flags = SUPPORT_FLAGS | SUPPORT_ON_OFF [EOL] self . _operation_mode = None [EOL] self . update_without_throttle = False [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _support_flags [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _data . room_status [ self . _room_id ] [ [string] ] [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _data . room_status [ self . _room_id ] [ [string] ] [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] return self . _operation_mode [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return self . _operation_list [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] module_type = self . _data . room_status [ self . _room_id ] [ [string] ] [EOL] if module_type not in ( NA_THERM , NA_VALVE ) : [EOL] return { } [EOL] state_attributes = { [string] : self . _data . homedata . gethomeId ( self . _data . home ) , [string] : self . _room_id , [string] : self . _data . setpoint_duration , [string] : self . _data . away_temperature , [string] : self . _data . hg_temperature , [string] : self . _operation_mode , [string] : module_type , [string] : self . _data . room_status [ self . _room_id ] [ [string] ] } [EOL] if module_type == NA_THERM : [EOL] state_attributes [ [string] ] = self . _data . boilerstatus [EOL] elif module_type == NA_VALVE : [EOL] state_attributes [ [string] ] = self . _data . room_status [ self . _room_id ] [ [string] ] [EOL] return state_attributes [EOL] [EOL] @ property def is_away_mode_on ( self ) : [EOL] [docstring] [EOL] return self . _away [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . target_temperature > [number] [EOL] [EOL] def turn_away_mode_on ( self ) : [EOL] [docstring] [EOL] self . set_operation_mode ( DICT_NETATMO_TO_HA [ STATE_NETATMO_AWAY ] ) [EOL] [EOL] def turn_away_mode_off ( self ) : [EOL] [docstring] [EOL] self . set_operation_mode ( DICT_NETATMO_TO_HA [ STATE_NETATMO_SCHEDULE ] ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] self . set_operation_mode ( DICT_NETATMO_TO_HA [ STATE_NETATMO_OFF ] ) [EOL] self . update_without_throttle = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] _LOGGER . debug ( [string] , self . _data . hg_temperature ) [EOL] self . _data . homestatus . setroomThermpoint ( self . _data . homedata . gethomeId ( self . _data . home ) , self . _room_id , STATE_NETATMO_MANUAL , self . _data . hg_temperature ) [EOL] _LOGGER . debug ( [string] ) [EOL] self . _data . homestatus . setThermmode ( self . _data . homedata . gethomeId ( self . _data . home ) , STATE_NETATMO_SCHEDULE ) [EOL] self . update_without_throttle = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] if not self . is_on : [EOL] self . turn_on ( ) [EOL] if operation_mode in [ DICT_NETATMO_TO_HA [ STATE_NETATMO_MAX ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_OFF ] ] : [EOL] self . _data . homestatus . setroomThermpoint ( self . _data . homedata . gethomeId ( self . _data . home ) , self . _room_id , DICT_HA_TO_NETATMO [ operation_mode ] ) [EOL] elif operation_mode in [ DICT_NETATMO_TO_HA [ STATE_NETATMO_HG ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_SCHEDULE ] , DICT_NETATMO_TO_HA [ STATE_NETATMO_AWAY ] ] : [EOL] self . _data . homestatus . setThermmode ( self . _data . homedata . gethomeId ( self . _data . home ) , DICT_HA_TO_NETATMO [ operation_mode ] ) [EOL] self . update_without_throttle = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temp = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if temp is None : [EOL] return [EOL] mode = STATE_NETATMO_MANUAL [EOL] self . _data . homestatus . setroomThermpoint ( self . _data . homedata . gethomeId ( self . _data . home ) , self . _room_id , DICT_HA_TO_NETATMO [ mode ] , temp ) [EOL] self . update_without_throttle = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] if self . update_without_throttle : [EOL] self . _data . update ( no_throttle = True ) [EOL] self . update_without_throttle = False [EOL] else : [EOL] self . _data . update ( ) [EOL] except AttributeError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return [EOL] self . _target_temperature = self . _data . room_status [ self . _room_id ] [ [string] ] [EOL] self . _operation_mode = DICT_NETATMO_TO_HA [ self . _data . room_status [ self . _room_id ] [ [string] ] ] [EOL] self . _away = self . _operation_mode == DICT_NETATMO_TO_HA [ STATE_NETATMO_AWAY ] [EOL] [EOL] [EOL] class HomeData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , auth , home = None ) : [EOL] [docstring] [EOL] self . auth = auth [EOL] self . homedata = None [EOL] self . home_names = [ ] [EOL] self . room_names = [ ] [EOL] self . schedules = [ ] [EOL] self . home = home [EOL] self . home_id = None [EOL] [EOL] def get_home_names ( self ) : [EOL] [docstring] [EOL] self . setup ( ) [EOL] if self . homedata is None : [EOL] return [ ] [EOL] for home in self . homedata . homes : [EOL] if [string] in self . homedata . homes [ home ] and [string] in self . homedata . homes [ home ] : [EOL] self . home_names . append ( self . homedata . homes [ home ] [ [string] ] ) [EOL] return self . home_names [EOL] [EOL] def setup ( self ) : [EOL] [docstring] [EOL] import pyatmo [EOL] try : [EOL] self . homedata = pyatmo . HomeData ( self . auth ) [EOL] self . home_id = self . homedata . gethomeId ( self . home ) [EOL] except TypeError : [EOL] _LOGGER . error ( [string] ) [EOL] except AttributeError : [EOL] _LOGGER . error ( [string] ) [EOL] except pyatmo . NoDevice : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [EOL] class ThermostatData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , auth , home = None ) : [EOL] [docstring] [EOL] self . auth = auth [EOL] self . homedata = None [EOL] self . homestatus = None [EOL] self . room_ids = [ ] [EOL] self . room_status = { } [EOL] self . schedules = [ ] [EOL] self . home = home [EOL] self . away_temperature = None [EOL] self . hg_temperature = None [EOL] self . boilerstatus = None [EOL] self . setpoint_duration = None [EOL] self . home_id = None [EOL] [EOL] def get_room_ids ( self ) : [EOL] [docstring] [EOL] if not self . setup ( ) : [EOL] return [ ] [EOL] for room in self . homestatus . rooms : [EOL] self . room_ids . append ( room ) [EOL] return self . room_ids [EOL] [EOL] def setup ( self ) : [EOL] [docstring] [EOL] import pyatmo [EOL] try : [EOL] self . homedata = pyatmo . HomeData ( self . auth ) [EOL] self . homestatus = pyatmo . HomeStatus ( self . auth , home = self . home ) [EOL] self . home_id = self . homedata . gethomeId ( self . home ) [EOL] self . update ( ) [EOL] except TypeError : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] return True [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] import pyatmo [EOL] [EOL] try : [EOL] self . homestatus = pyatmo . HomeStatus ( self . auth , home = self . home ) [EOL] except TypeError : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] except requests . exceptions . Timeout : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] _LOGGER . debug ( [string] ) [EOL] _LOGGER . debug ( self . homestatus . rawData ) [EOL] for room in self . homestatus . rooms : [EOL] try : [EOL] roomstatus = { } [EOL] homestatus_room = self . homestatus . rooms [ room ] [EOL] homedata_room = self . homedata . rooms [ self . home ] [ room ] [EOL] roomstatus [ [string] ] = homestatus_room [ [string] ] [EOL] roomstatus [ [string] ] = homedata_room [ [string] ] [EOL] roomstatus [ [string] ] = homestatus_room [ [string] ] [EOL] roomstatus [ [string] ] = homestatus_room [ [string] ] [EOL] roomstatus [ [string] ] = homestatus_room [ [string] ] [EOL] roomstatus [ [string] ] = self . homestatus . thermostatType ( self . home , room ) [EOL] roomstatus [ [string] ] = None [EOL] roomstatus [ [string] ] = None [EOL] roomstatus [ [string] ] = None [EOL] for module_id in homedata_room [ [string] ] : [EOL] if ( self . homedata . modules [ self . home ] [ module_id ] [ [string] ] == NA_THERM or roomstatus [ [string] ] is None ) : [EOL] roomstatus [ [string] ] = module_id [EOL] if roomstatus [ [string] ] == NA_THERM : [EOL] self . boilerstatus = self . homestatus . boilerStatus ( rid = roomstatus [ [string] ] ) [EOL] roomstatus [ [string] ] = self . boilerstatus [EOL] elif roomstatus [ [string] ] == NA_VALVE : [EOL] roomstatus [ [string] ] = homestatus_room [ [string] ] [EOL] roomstatus [ [string] ] = ( roomstatus [ [string] ] > [number] ) [EOL] if self . boilerstatus is not None : [EOL] roomstatus [ [string] ] = ( self . boilerstatus and roomstatus [ [string] ] ) [EOL] self . room_status [ room ] = roomstatus [EOL] except KeyError as err : [EOL] _LOGGER . error ( [string] , room , err ) [EOL] self . away_temperature = self . homestatus . getAwaytemp ( self . home ) [EOL] self . hg_temperature = self . homestatus . getHgtemp ( self . home ) [EOL] self . setpoint_duration = self . homedata . setpoint_duration [ self . home ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] DATA_NETATMO = [string] [EOL] DATA_NETATMO_AUTH = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( __package__ ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Type [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , DEVICE_CLASS_MOTION ) [EOL] from homeassistant . components . hue . sensor_base import ( GenericZLLSensor , async_setup_entry as shared_async_setup_entry ) [EOL] [EOL] [EOL] PRESENCE_NAME_FORMAT = [string] [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_entities ) : [EOL] [docstring] [EOL] await shared_async_setup_entry ( hass , config_entry , async_add_entities , binary = True ) [EOL] [EOL] [EOL] class HuePresence ( GenericZLLSensor , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] device_class = DEVICE_CLASS_MOTION [EOL] [EOL] async def _async_update_ha_state ( self , * args , ** kwargs ) : [EOL] await self . async_update_ha_state ( self , * args , ** kwargs ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . sensor . presence [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = super ( ) . device_state_attributes [EOL] if [string] in self . sensor . config : [EOL] attributes [ [string] ] = self . sensor . config [ [string] ] [EOL] if [string] in self . sensor . config : [EOL] attributes [ [string] ] = self . sensor . config [ [string] ] [EOL] return attributes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.hue.binary_sensor.HuePresence]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Dict , Any [EOL] import datetime [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import datetime [EOL] import logging [EOL] import re [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_MONITORED_CONDITIONS , TEMP_CELSIUS , CONF_NAME , CONF_LATITUDE , CONF_LONGITUDE , ATTR_ATTRIBUTION , ATTR_LOCATION , ATTR_HIDDEN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] import homeassistant . util . dt as dt [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_UPDATED = [string] [EOL] ATTR_STATION = [string] [EOL] ATTR_DETAIL = [string] [EOL] ATTR_TIME = [string] [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_STATION = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = datetime . timedelta ( minutes = [number] ) [EOL] [EOL] SENSOR_TYPES = { [string] : { [string] : [string] , [string] : TEMP_CELSIUS } , [string] : { [string] : [string] , [string] : TEMP_CELSIUS } , [string] : { [string] : [string] , [string] : TEMP_CELSIUS } , [string] : { [string] : [string] , [string] : TEMP_CELSIUS } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] , [string] : TEMP_CELSIUS } , [string] : { [string] : [string] , [string] : TEMP_CELSIUS } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } } [EOL] [EOL] [EOL] def validate_station ( station ) : [EOL] [docstring] [EOL] if station is None : [EOL] return [EOL] if not re . fullmatch ( [string] , station ) : [EOL] raise vol . error . Invalid ( [string] ) [EOL] return station [EOL] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_STATION ) : validate_station , vol . Inclusive ( CONF_LATITUDE , [string] ) : cv . latitude , vol . Inclusive ( CONF_LONGITUDE , [string] ) : cv . longitude , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from env_canada import ECData [EOL] [EOL] if config . get ( CONF_STATION ) : [EOL] ec_data = ECData ( station_id = config [ CONF_STATION ] ) [EOL] elif config . get ( CONF_LATITUDE ) and config . get ( CONF_LONGITUDE ) : [EOL] ec_data = ECData ( coordinates = ( config [ CONF_LATITUDE ] , config [ CONF_LONGITUDE ] ) ) [EOL] else : [EOL] ec_data = ECData ( coordinates = ( hass . config . latitude , hass . config . longitude ) ) [EOL] [EOL] add_devices ( [ ECSensor ( sensor_type , ec_data , config . get ( CONF_NAME ) ) for sensor_type in config [ CONF_MONITORED_CONDITIONS ] ] , True ) [EOL] [EOL] [EOL] class ECSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor_type , ec_data , platform_name ) : [EOL] [docstring] [EOL] self . sensor_type = sensor_type [EOL] self . ec_data = ec_data [EOL] self . platform_name = platform_name [EOL] self . _state = None [EOL] self . _attr = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] if self . platform_name is None : [EOL] return SENSOR_TYPES [ self . sensor_type ] [ [string] ] [EOL] [EOL] return [string] . join ( [ self . platform_name , SENSOR_TYPES [ self . sensor_type ] [ [string] ] ] ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attr [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES [ self . sensor_type ] . get ( [string] ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . ec_data . update ( ) [EOL] self . ec_data . conditions . update ( self . ec_data . alerts ) [EOL] [EOL] self . _attr = { } [EOL] [EOL] sensor_data = self . ec_data . conditions . get ( self . sensor_type ) [EOL] if isinstance ( sensor_data , list ) : [EOL] self . _state = [string] . join ( [ str ( s . get ( [string] ) ) for s in sensor_data ] ) [EOL] self . _attr . update ( { ATTR_DETAIL : [string] . join ( [ str ( s . get ( [string] ) ) for s in sensor_data ] ) , ATTR_TIME : [string] . join ( [ str ( s . get ( [string] ) ) for s in sensor_data ] ) } ) [EOL] else : [EOL] self . _state = sensor_data [EOL] [EOL] timestamp = self . ec_data . conditions . get ( [string] ) [EOL] if timestamp : [EOL] updated_utc = datetime . datetime . strptime ( timestamp , [string] ) [EOL] updated_local = dt . as_local ( updated_utc ) . isoformat ( ) [EOL] else : [EOL] updated_local = None [EOL] [EOL] hidden = bool ( self . _state is None or self . _state == [string] ) [EOL] [EOL] self . _attr . update ( { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , ATTR_UPDATED : updated_local , ATTR_LOCATION : self . ec_data . conditions . get ( [string] ) , ATTR_STATION : self . ec_data . conditions . get ( [string] ) , ATTR_HIDDEN : hidden } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class Disconnect ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import io [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . core import split_entity_id [EOL] from homeassistant . components . image_processing import ( ImageProcessingEntity , CONF_SOURCE , CONF_ENTITY_ID , CONF_NAME ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] [comment] [EOL] entities = [ ] [EOL] for camera in config [ CONF_SOURCE ] : [EOL] entities . append ( QrEntity ( camera [ CONF_ENTITY_ID ] , camera . get ( CONF_NAME ) ) ) [EOL] [EOL] add_entities ( entities ) [EOL] [EOL] [EOL] class QrEntity ( ImageProcessingEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , camera_entity , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _camera = camera_entity [EOL] if name : [EOL] self . _name = name [EOL] else : [EOL] self . _name = [string] . format ( split_entity_id ( camera_entity ) [ [number] ] ) [EOL] self . _state = None [EOL] [EOL] @ property def camera_entity ( self ) : [EOL] [docstring] [EOL] return self . _camera [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def process_image ( self , image ) : [EOL] [docstring] [EOL] import io [EOL] from pyzbar import pyzbar [EOL] from PIL import Image [EOL] [EOL] stream = io . BytesIO ( image ) [EOL] img = Image . open ( stream ) [EOL] [EOL] barcodes = pyzbar . decode ( img ) [EOL] if barcodes : [EOL] self . _state = barcodes [ [number] ] . data . decode ( [string] ) [EOL] else : [EOL] self . _state = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.BytesIO$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $io.BytesIO$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import config_entries [EOL] from homeassistant . components . media_player import DOMAIN as MP_DOMAIN [EOL] from homeassistant . const import CONF_HOSTS , ATTR_ENTITY_ID , ATTR_TIME [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_send [EOL] [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] CONF_ADVERTISE_ADDR = [string] [EOL] CONF_INTERFACE_ADDR = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { MP_DOMAIN : vol . Schema ( { vol . Optional ( CONF_ADVERTISE_ADDR ) : cv . string , vol . Optional ( CONF_INTERFACE_ADDR ) : cv . string , vol . Optional ( CONF_HOSTS ) : vol . All ( cv . ensure_list_csv , [ cv . string ] ) , } ) , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] SERVICE_JOIN = [string] [EOL] SERVICE_UNJOIN = [string] [EOL] SERVICE_SNAPSHOT = [string] [EOL] SERVICE_RESTORE = [string] [EOL] SERVICE_SET_TIMER = [string] [EOL] SERVICE_CLEAR_TIMER = [string] [EOL] SERVICE_UPDATE_ALARM = [string] [EOL] SERVICE_SET_OPTION = [string] [EOL] [EOL] ATTR_SLEEP_TIME = [string] [EOL] ATTR_ALARM_ID = [string] [EOL] ATTR_VOLUME = [string] [EOL] ATTR_ENABLED = [string] [EOL] ATTR_INCLUDE_LINKED_ZONES = [string] [EOL] ATTR_MASTER = [string] [EOL] ATTR_WITH_GROUP = [string] [EOL] ATTR_NIGHT_SOUND = [string] [EOL] ATTR_SPEECH_ENHANCE = [string] [EOL] [EOL] SONOS_JOIN_SCHEMA = vol . Schema ( { vol . Required ( ATTR_MASTER ) : cv . entity_id , vol . Optional ( ATTR_ENTITY_ID ) : cv . comp_entity_ids , } ) [EOL] [EOL] SONOS_UNJOIN_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . comp_entity_ids , } ) [EOL] [EOL] SONOS_STATES_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . comp_entity_ids , vol . Optional ( ATTR_WITH_GROUP , default = True ) : cv . boolean , } ) [EOL] [EOL] SONOS_SET_TIMER_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . comp_entity_ids , vol . Required ( ATTR_SLEEP_TIME ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) } ) [EOL] [EOL] SONOS_CLEAR_TIMER_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . comp_entity_ids , } ) [EOL] [EOL] SONOS_UPDATE_ALARM_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . comp_entity_ids , vol . Required ( ATTR_ALARM_ID ) : cv . positive_int , vol . Optional ( ATTR_TIME ) : cv . time , vol . Optional ( ATTR_VOLUME ) : cv . small_float , vol . Optional ( ATTR_ENABLED ) : cv . boolean , vol . Optional ( ATTR_INCLUDE_LINKED_ZONES ) : cv . boolean , } ) [EOL] [EOL] SONOS_SET_OPTION_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . comp_entity_ids , vol . Optional ( ATTR_NIGHT_SOUND ) : cv . boolean , vol . Optional ( ATTR_SPEECH_ENHANCE ) : cv . boolean , } ) [EOL] [EOL] DATA_SERVICE_EVENT = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config . get ( DOMAIN ) [EOL] [EOL] hass . data [ DOMAIN ] = conf or { } [EOL] hass . data [ DATA_SERVICE_EVENT ] = asyncio . Event ( ) [EOL] [EOL] if conf is not None : [EOL] hass . async_create_task ( hass . config_entries . flow . async_init ( DOMAIN , context = { [string] : config_entries . SOURCE_IMPORT } ) ) [EOL] [EOL] async def service_handle ( service ) : [EOL] [docstring] [EOL] hass . data [ DATA_SERVICE_EVENT ] . clear ( ) [EOL] async_dispatcher_send ( hass , DOMAIN , service . service , service . data ) [EOL] await hass . data [ DATA_SERVICE_EVENT ] . wait ( ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_JOIN , service_handle , schema = SONOS_JOIN_SCHEMA ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_UNJOIN , service_handle , schema = SONOS_UNJOIN_SCHEMA ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_SNAPSHOT , service_handle , schema = SONOS_STATES_SCHEMA ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_RESTORE , service_handle , schema = SONOS_STATES_SCHEMA ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_TIMER , service_handle , schema = SONOS_SET_TIMER_SCHEMA ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_CLEAR_TIMER , service_handle , schema = SONOS_CLEAR_TIMER_SCHEMA ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_UPDATE_ALARM , service_handle , schema = SONOS_UPDATE_ALARM_SCHEMA ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_OPTION , service_handle , schema = SONOS_SET_OPTION_SCHEMA ) [EOL] [EOL] return True [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry ) : [EOL] [docstring] [EOL] hass . async_create_task ( hass . config_entries . async_forward_entry_setup ( entry , MP_DOMAIN ) ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL] CLIENT_ID = [string] [EOL] CLIENT_SECRET = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] from . const import DOMAIN as AXIS_DOMAIN [EOL] [EOL] [EOL] class AxisEntityBase ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] self . device = device [EOL] self . unsub_dispatcher = [ ] [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . unsub_dispatcher . append ( async_dispatcher_connect ( self . hass , self . device . event_reachable , self . update_callback ) ) [EOL] [EOL] async def async_will_remove_from_hass ( self ) : [EOL] [docstring] [EOL] for unsub_dispatcher in self . unsub_dispatcher : [EOL] unsub_dispatcher ( ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . device . available [EOL] [EOL] @ property def device_info ( self ) : [EOL] [docstring] [EOL] return { [string] : { ( AXIS_DOMAIN , self . device . serial ) } } [EOL] [EOL] @ callback def update_callback ( self , no_delay = None ) : [EOL] [docstring] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] [EOL] class AxisEventBase ( AxisEntityBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , event , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( device ) [EOL] self . event = event [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . event . register_callback ( self . update_callback ) [EOL] [EOL] await super ( ) . async_added_to_hass ( ) [EOL] [EOL] async def async_will_remove_from_hass ( self ) : [EOL] [docstring] [EOL] self . event . remove_callback ( self . update_callback ) [EOL] [EOL] await super ( ) . async_will_remove_from_hass ( ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . event . CLASS [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . device . name , self . event . TYPE , self . event . id ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . device . serial , self . event . topic , self . event . id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( __package__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] CONF_CAMERA = [string] [EOL] CONF_EVENTS = [string] [EOL] CONF_MODEL = [string] [EOL] [EOL] DEFAULT_TRIGGER_TIME = [number] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class AxisException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AlreadyConfigured ( AxisException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( AxisException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( AxisException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UserLevel ( AxisException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Dict , Tuple , Any [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import json [EOL] import logging [EOL] [EOL] from pylinky . client import DAILY , MONTHLY , YEARLY , LinkyClient , PyLinkyError [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_PASSWORD , CONF_TIMEOUT , CONF_USERNAME , ENERGY_KILO_WATT_HOUR ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import track_time_interval [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( hours = [number] ) [EOL] ICON_ENERGY = [string] [EOL] CONSUMPTION = [string] [EOL] TIME = [string] [EOL] INDEX_CURRENT = - [number] [EOL] INDEX_LAST = - [number] [EOL] ATTRIBUTION = [string] [EOL] [EOL] DEFAULT_TIMEOUT = [number] [EOL] SENSORS = { [string] : ( [string] , DAILY , INDEX_LAST ) , [string] : ( [string] , MONTHLY , INDEX_CURRENT ) , [string] : ( [string] , MONTHLY , INDEX_LAST ) , [string] : ( [string] , YEARLY , INDEX_CURRENT ) , [string] : ( [string] , YEARLY , INDEX_LAST ) } [EOL] SENSORS_INDEX_LABEL = [number] [EOL] SENSORS_INDEX_SCALE = [number] [EOL] SENSORS_INDEX_WHEN = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] username = config [ CONF_USERNAME ] [EOL] password = config [ CONF_PASSWORD ] [EOL] timeout = config [ CONF_TIMEOUT ] [EOL] [EOL] account = LinkyAccount ( hass , add_entities , username , password , timeout ) [EOL] add_entities ( account . sensors , True ) [EOL] [EOL] [EOL] class LinkyAccount : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , add_entities , username , password , timeout ) : [EOL] [docstring] [EOL] self . _username = username [EOL] self . __password = password [EOL] self . _timeout = timeout [EOL] self . _data = None [EOL] self . sensors = [ ] [EOL] [EOL] self . update_linky_data ( dt_util . utcnow ( ) ) [EOL] [EOL] self . sensors . append ( LinkySensor ( [string] , self , DAILY , INDEX_LAST ) ) [EOL] self . sensors . append ( LinkySensor ( [string] , self , MONTHLY , INDEX_CURRENT ) ) [EOL] self . sensors . append ( LinkySensor ( [string] , self , MONTHLY , INDEX_LAST ) ) [EOL] self . sensors . append ( LinkySensor ( [string] , self , YEARLY , INDEX_CURRENT ) ) [EOL] self . sensors . append ( LinkySensor ( [string] , self , YEARLY , INDEX_LAST ) ) [EOL] [EOL] track_time_interval ( hass , self . update_linky_data , SCAN_INTERVAL ) [EOL] [EOL] def update_linky_data ( self , event_time ) : [EOL] [docstring] [EOL] client = LinkyClient ( self . _username , self . __password , None , self . _timeout ) [EOL] try : [EOL] client . login ( ) [EOL] client . fetch_data ( ) [EOL] self . _data = client . get_data ( ) [EOL] _LOGGER . debug ( json . dumps ( self . _data , indent = [number] ) ) [EOL] except PyLinkyError as exp : [EOL] _LOGGER . error ( exp ) [EOL] finally : [EOL] client . close_session ( ) [EOL] [EOL] @ property def username ( self ) : [EOL] [docstring] [EOL] return self . _username [EOL] [EOL] @ property def data ( self ) : [EOL] [docstring] [EOL] return self . _data [EOL] [EOL] [EOL] class LinkySensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , account , scale , when ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . __account = account [EOL] self . _scale = scale [EOL] self . __when = when [EOL] self . _username = account . username [EOL] self . __time = None [EOL] self . __consumption = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . __consumption [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return ENERGY_KILO_WATT_HOUR [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON_ENERGY [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : ATTRIBUTION , [string] : self . __time , CONF_USERNAME : self . _username } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] data = self . __account . data [ self . _scale ] [ self . __when ] [EOL] self . __consumption = data [ CONSUMPTION ] [EOL] self . __time = data [ TIME ] [EOL] [EOL] if self . _scale is not YEARLY : [EOL] year_index = INDEX_CURRENT [EOL] if self . __time . endswith ( [string] ) : [EOL] year_index = INDEX_LAST [EOL] self . __time += [string] + self . __account . data [ YEARLY ] [ year_index ] [ TIME ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LinkyAccount$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.components.linky.sensor.LinkyAccount$ 0 $LinkyAccount$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LinkyAccount$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import util [EOL] from homeassistant . components . media_player import ( MediaPlayerDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . media_player . const import ( MEDIA_TYPE_CHANNEL , SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PLAY , SUPPORT_PLAY_MEDIA , SUPPORT_PREVIOUS_TRACK , SUPPORT_TURN_OFF , SUPPORT_TURN_ON ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , STATE_OFF , STATE_PAUSED , STATE_PLAYING ) [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] SUPPORT_HORIZON = SUPPORT_NEXT_TRACK | SUPPORT_PAUSE | SUPPORT_PLAY | SUPPORT_PLAY_MEDIA | SUPPORT_PREVIOUS_TRACK | SUPPORT_TURN_ON | SUPPORT_TURN_OFF [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from horimote import Client , keys [EOL] from horimote . exceptions import AuthenticationError [EOL] [EOL] host = config [ CONF_HOST ] [EOL] name = config [ CONF_NAME ] [EOL] port = config [ CONF_PORT ] [EOL] [EOL] try : [EOL] client = Client ( host , port = port ) [EOL] except AuthenticationError as msg : [EOL] _LOGGER . error ( [string] , name , host , msg ) [EOL] return [EOL] except OSError as msg : [EOL] [comment] [EOL] _LOGGER . error ( [string] , name , host , msg ) [EOL] raise PlatformNotReady [EOL] [EOL] _LOGGER . info ( [string] , name , host ) [EOL] [EOL] add_entities ( [ HorizonDevice ( client , name , keys ) ] , True ) [EOL] [EOL] [EOL] class HorizonDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , name , keys ) : [EOL] [docstring] [EOL] self . _client = client [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _keys = keys [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_HORIZON [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] if self . _client . is_powered_on ( ) : [EOL] self . _state = STATE_PLAYING [EOL] else : [EOL] self . _state = STATE_OFF [EOL] except OSError : [EOL] self . _state = STATE_OFF [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] if self . _state is STATE_OFF : [EOL] self . _send_key ( self . _keys . POWER ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] if self . _state is not STATE_OFF : [EOL] self . _send_key ( self . _keys . POWER ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . CHAN_DOWN ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . CHAN_UP ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . PAUSE ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . PAUSE ) [EOL] self . _state = STATE_PAUSED [EOL] [EOL] def media_play_pause ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . PAUSE ) [EOL] if self . _state == STATE_PAUSED : [EOL] self . _state = STATE_PLAYING [EOL] else : [EOL] self . _state = STATE_PAUSED [EOL] [EOL] def play_media ( self , media_type , media_id , ** kwargs ) : [EOL] [docstring] [EOL] if MEDIA_TYPE_CHANNEL == media_type : [EOL] try : [EOL] self . _select_channel ( int ( media_id ) ) [EOL] self . _state = STATE_PLAYING [EOL] except ValueError : [EOL] _LOGGER . error ( [string] , media_id ) [EOL] else : [EOL] _LOGGER . error ( [string] , media_type , MEDIA_TYPE_CHANNEL ) [EOL] [EOL] def _select_channel ( self , channel ) : [EOL] [docstring] [EOL] self . _send ( channel = channel ) [EOL] [EOL] def _send_key ( self , key ) : [EOL] [docstring] [EOL] self . _send ( key = key ) [EOL] [EOL] def _send ( self , key = None , channel = None ) : [EOL] [docstring] [EOL] from horimote . exceptions import AuthenticationError [EOL] [EOL] try : [EOL] if key : [EOL] self . _client . send_key ( key ) [EOL] elif channel : [EOL] self . _client . select_channel ( channel ) [EOL] except OSError as msg : [EOL] _LOGGER . error ( [string] , self . _name , msg ) [EOL] [EOL] [comment] [EOL] self . _client . disconnect ( ) [EOL] [EOL] try : [EOL] self . _client . connect ( ) [EOL] self . _client . authorize ( ) [EOL] except AuthenticationError as msg : [EOL] _LOGGER . error ( [string] , self . _name , msg ) [EOL] return [EOL] except OSError as msg : [EOL] [comment] [EOL] _LOGGER . error ( [string] , self . _name , msg ) [EOL] return [EOL] [EOL] self . _send ( key = key , channel = channel ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] DATA = [string] [EOL] [EOL] CARD_STATE_ACTIVE = [string] [EOL] CARD_STATE_BLOCKED = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ATTR_SENSOR_ID = [string] [EOL] [EOL] CONF_SENSOR_ID = [string] [EOL] [EOL] DEFAULT_SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . entity_registry import async_get_registry [EOL] from homeassistant . components import websocket_api [EOL] from homeassistant . components . websocket_api . const import ERR_NOT_FOUND [EOL] from homeassistant . components . websocket_api . decorators import ( async_response , require_admin ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] WS_TYPE_LIST = [string] [EOL] SCHEMA_WS_LIST = websocket_api . BASE_COMMAND_MESSAGE_SCHEMA . extend ( { vol . Required ( [string] ) : WS_TYPE_LIST , } ) [EOL] [EOL] WS_TYPE_GET = [string] [EOL] SCHEMA_WS_GET = websocket_api . BASE_COMMAND_MESSAGE_SCHEMA . extend ( { vol . Required ( [string] ) : WS_TYPE_GET , vol . Required ( [string] ) : cv . entity_id } ) [EOL] [EOL] WS_TYPE_UPDATE = [string] [EOL] SCHEMA_WS_UPDATE = websocket_api . BASE_COMMAND_MESSAGE_SCHEMA . extend ( { vol . Required ( [string] ) : WS_TYPE_UPDATE , vol . Required ( [string] ) : cv . entity_id , vol . Optional ( [string] ) : vol . Any ( str , None ) , vol . Optional ( [string] ) : str , } ) [EOL] [EOL] WS_TYPE_REMOVE = [string] [EOL] SCHEMA_WS_REMOVE = websocket_api . BASE_COMMAND_MESSAGE_SCHEMA . extend ( { vol . Required ( [string] ) : WS_TYPE_REMOVE , vol . Required ( [string] ) : cv . entity_id } ) [EOL] [EOL] [EOL] async def async_setup ( hass ) : [EOL] [docstring] [EOL] hass . components . websocket_api . async_register_command ( WS_TYPE_LIST , websocket_list_entities , SCHEMA_WS_LIST ) [EOL] hass . components . websocket_api . async_register_command ( WS_TYPE_GET , websocket_get_entity , SCHEMA_WS_GET ) [EOL] hass . components . websocket_api . async_register_command ( WS_TYPE_UPDATE , websocket_update_entity , SCHEMA_WS_UPDATE ) [EOL] hass . components . websocket_api . async_register_command ( WS_TYPE_REMOVE , websocket_remove_entity , SCHEMA_WS_REMOVE ) [EOL] return True [EOL] [EOL] [EOL] @ async_response async def websocket_list_entities ( hass , connection , msg ) : [EOL] [docstring] [EOL] registry = await async_get_registry ( hass ) [EOL] connection . send_message ( websocket_api . result_message ( msg [ [string] ] , [ _entry_dict ( entry ) for entry in registry . entities . values ( ) ] ) ) [EOL] [EOL] [EOL] @ async_response async def websocket_get_entity ( hass , connection , msg ) : [EOL] [docstring] [EOL] registry = await async_get_registry ( hass ) [EOL] entry = registry . entities . get ( msg [ [string] ] ) [EOL] [EOL] if entry is None : [EOL] connection . send_message ( websocket_api . error_message ( msg [ [string] ] , ERR_NOT_FOUND , [string] ) ) [EOL] return [EOL] [EOL] connection . send_message ( websocket_api . result_message ( msg [ [string] ] , _entry_dict ( entry ) ) ) [EOL] [EOL] [EOL] @ require_admin @ async_response async def websocket_update_entity ( hass , connection , msg ) : [EOL] [docstring] [EOL] registry = await async_get_registry ( hass ) [EOL] [EOL] if msg [ [string] ] not in registry . entities : [EOL] connection . send_message ( websocket_api . error_message ( msg [ [string] ] , ERR_NOT_FOUND , [string] ) ) [EOL] return [EOL] [EOL] changes = { } [EOL] [EOL] if [string] in msg : [EOL] changes [ [string] ] = msg [ [string] ] [EOL] [EOL] if [string] in msg and msg [ [string] ] != msg [ [string] ] : [EOL] changes [ [string] ] = msg [ [string] ] [EOL] if hass . states . get ( msg [ [string] ] ) is not None : [EOL] connection . send_message ( websocket_api . error_message ( msg [ [string] ] , [string] , [string] ) ) [EOL] return [EOL] [EOL] try : [EOL] if changes : [EOL] entry = registry . async_update_entity ( msg [ [string] ] , ** changes ) [EOL] except ValueError as err : [EOL] connection . send_message ( websocket_api . error_message ( msg [ [string] ] , [string] , str ( err ) ) ) [EOL] else : [EOL] connection . send_message ( websocket_api . result_message ( msg [ [string] ] , _entry_dict ( entry ) ) ) [EOL] [EOL] [EOL] @ require_admin @ async_response async def websocket_remove_entity ( hass , connection , msg ) : [EOL] [docstring] [EOL] registry = await async_get_registry ( hass ) [EOL] [EOL] if msg [ [string] ] not in registry . entities : [EOL] connection . send_message ( websocket_api . error_message ( msg [ [string] ] , ERR_NOT_FOUND , [string] ) ) [EOL] return [EOL] [EOL] registry . async_remove ( msg [ [string] ] ) [EOL] connection . send_message ( websocket_api . result_message ( msg [ [string] ] ) ) [EOL] [EOL] [EOL] @ callback def _entry_dict ( entry ) : [EOL] [docstring] [EOL] return { [string] : entry . config_entry_id , [string] : entry . device_id , [string] : entry . disabled_by , [string] : entry . entity_id , [string] : entry . name , [string] : entry . platform , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . camera import PLATFORM_SCHEMA , Camera [EOL] from homeassistant . const import CONF_ID , CONF_NAME [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] CONF_DELTA = [string] [EOL] CONF_FRAMES = [string] [EOL] CONF_LOCATION = [string] [EOL] CONF_OUTFILE = [string] [EOL] [EOL] LOCATIONS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def _validate_schema ( config ) : [EOL] if config . get ( CONF_LOCATION ) is None : [EOL] if not all ( config . get ( x ) for x in ( CONF_ID , CONF_DELTA , CONF_FRAMES ) ) : [EOL] raise vol . Invalid ( [string] . format ( CONF_ID , CONF_DELTA , CONF_FRAMES , CONF_LOCATION ) ) [EOL] return config [EOL] [EOL] [EOL] LOCATIONS_MSG = [string] . format ( CONF_LOCATION , [string] . join ( sorted ( LOCATIONS ) ) ) [EOL] XOR_MSG = [string] . format ( CONF_ID , CONF_LOCATION ) [EOL] [EOL] PLATFORM_SCHEMA = vol . All ( PLATFORM_SCHEMA . extend ( { vol . Exclusive ( CONF_ID , [string] , msg = XOR_MSG ) : cv . string , vol . Exclusive ( CONF_LOCATION , [string] , msg = XOR_MSG ) : vol . In ( LOCATIONS , msg = LOCATIONS_MSG ) , vol . Optional ( CONF_DELTA ) : cv . positive_int , vol . Optional ( CONF_FRAMES ) : cv . positive_int , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_OUTFILE ) : cv . string , } ) , _validate_schema ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] location = config . get ( CONF_LOCATION ) or [string] . format ( config . get ( CONF_ID ) ) [EOL] name = config . get ( CONF_NAME ) or [string] . format ( location ) [EOL] args = [ config . get ( x ) for x in ( CONF_LOCATION , CONF_ID , CONF_DELTA , CONF_FRAMES , CONF_OUTFILE ) ] [EOL] add_entities ( [ BOMRadarCam ( name , * args ) ] ) [EOL] [EOL] [EOL] class BOMRadarCam ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , location , radar_id , delta , frames , outfile ) : [EOL] [docstring] [EOL] from bomradarloop import BOMRadarLoop [EOL] super ( ) . __init__ ( ) [EOL] self . _name = name [EOL] self . _cam = BOMRadarLoop ( location , radar_id , delta , frames , outfile ) [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] return self . _cam . current [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_REGION = [string] [EOL] DEFAULT_ALIAS = [string] [EOL] DOMAIN = [string] [EOL] PS4_DATA = [string] [EOL] [EOL] [comment] [EOL] REGIONS = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] REQUEST_TIMEOUT = [number] [EOL] [EOL] PREF_ENABLE_ALEXA = [string] [EOL] PREF_ENABLE_GOOGLE = [string] [EOL] PREF_ENABLE_REMOTE = [string] [EOL] PREF_GOOGLE_SECURE_DEVICES_PIN = [string] [EOL] PREF_CLOUDHOOKS = [string] [EOL] PREF_CLOUD_USER = [string] [EOL] PREF_GOOGLE_ENTITY_CONFIGS = [string] [EOL] PREF_ALEXA_ENTITY_CONFIGS = [string] [EOL] PREF_ALEXA_REPORT_STATE = [string] [EOL] PREF_OVERRIDE_NAME = [string] [EOL] PREF_DISABLE_2FA = [string] [EOL] PREF_ALIASES = [string] [EOL] PREF_SHOULD_EXPOSE = [string] [EOL] DEFAULT_SHOULD_EXPOSE = True [EOL] DEFAULT_DISABLE_2FA = False [EOL] DEFAULT_ALEXA_REPORT_STATE = False [EOL] [EOL] CONF_ALEXA = [string] [EOL] CONF_ALIASES = [string] [EOL] CONF_COGNITO_CLIENT_ID = [string] [EOL] CONF_ENTITY_CONFIG = [string] [EOL] CONF_FILTER = [string] [EOL] CONF_GOOGLE_ACTIONS = [string] [EOL] CONF_RELAYER = [string] [EOL] CONF_USER_POOL_ID = [string] [EOL] CONF_GOOGLE_ACTIONS_SYNC_URL = [string] [EOL] CONF_SUBSCRIPTION_INFO_URL = [string] [EOL] CONF_CLOUDHOOK_CREATE_URL = [string] [EOL] CONF_REMOTE_API_URL = [string] [EOL] CONF_ACME_DIRECTORY_SERVER = [string] [EOL] CONF_ALEXA_ACCESS_TOKEN_URL = [string] [EOL] [EOL] MODE_DEV = [string] [EOL] MODE_PROD = [string] [EOL] [EOL] DISPATCHER_REMOTE_UPDATE = [string] [EOL] [EOL] [EOL] class InvalidTrustedNetworks ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class InvalidTrustedProxies ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class RequireRelink ( Exception ) : [EOL] [docstring] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from ipaddress import ip_address [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . util . logging import async_create_catching_coro [EOL] [EOL] from . const import ( DOMAIN , PREF_ENABLE_ALEXA , PREF_ENABLE_GOOGLE , PREF_ENABLE_REMOTE , PREF_GOOGLE_SECURE_DEVICES_PIN , PREF_CLOUDHOOKS , PREF_CLOUD_USER , PREF_GOOGLE_ENTITY_CONFIGS , PREF_OVERRIDE_NAME , PREF_DISABLE_2FA , PREF_ALIASES , PREF_SHOULD_EXPOSE , PREF_ALEXA_ENTITY_CONFIGS , PREF_ALEXA_REPORT_STATE , DEFAULT_ALEXA_REPORT_STATE , InvalidTrustedNetworks , InvalidTrustedProxies ) [EOL] [EOL] STORAGE_KEY = DOMAIN [EOL] STORAGE_VERSION = [number] [EOL] _UNDEF = object ( ) [EOL] [EOL] [EOL] class CloudPreferences : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _store = hass . helpers . storage . Store ( STORAGE_VERSION , STORAGE_KEY ) [EOL] self . _prefs = None [EOL] self . _listeners = [ ] [EOL] [EOL] async def async_initialize ( self ) : [EOL] [docstring] [EOL] prefs = await self . _store . async_load ( ) [EOL] [EOL] if prefs is None : [EOL] prefs = { PREF_ENABLE_ALEXA : True , PREF_ENABLE_GOOGLE : True , PREF_ENABLE_REMOTE : False , PREF_GOOGLE_SECURE_DEVICES_PIN : None , PREF_GOOGLE_ENTITY_CONFIGS : { } , PREF_ALEXA_ENTITY_CONFIGS : { } , PREF_CLOUDHOOKS : { } , PREF_CLOUD_USER : None , } [EOL] [EOL] self . _prefs = prefs [EOL] [EOL] @ callback def async_listen_updates ( self , listener ) : [EOL] [docstring] [EOL] self . _listeners . append ( listener ) [EOL] [EOL] async def async_update ( self , * , google_enabled = _UNDEF , alexa_enabled = _UNDEF , remote_enabled = _UNDEF , google_secure_devices_pin = _UNDEF , cloudhooks = _UNDEF , cloud_user = _UNDEF , google_entity_configs = _UNDEF , alexa_entity_configs = _UNDEF , alexa_report_state = _UNDEF ) : [EOL] [docstring] [EOL] for key , value in ( ( PREF_ENABLE_GOOGLE , google_enabled ) , ( PREF_ENABLE_ALEXA , alexa_enabled ) , ( PREF_ENABLE_REMOTE , remote_enabled ) , ( PREF_GOOGLE_SECURE_DEVICES_PIN , google_secure_devices_pin ) , ( PREF_CLOUDHOOKS , cloudhooks ) , ( PREF_CLOUD_USER , cloud_user ) , ( PREF_GOOGLE_ENTITY_CONFIGS , google_entity_configs ) , ( PREF_ALEXA_ENTITY_CONFIGS , alexa_entity_configs ) , ( PREF_ALEXA_REPORT_STATE , alexa_report_state ) , ) : [EOL] if value is not _UNDEF : [EOL] self . _prefs [ key ] = value [EOL] [EOL] if remote_enabled is True and self . _has_local_trusted_network : [EOL] self . _prefs [ PREF_ENABLE_REMOTE ] = False [EOL] raise InvalidTrustedNetworks [EOL] [EOL] if remote_enabled is True and self . _has_local_trusted_proxies : [EOL] self . _prefs [ PREF_ENABLE_REMOTE ] = False [EOL] raise InvalidTrustedProxies [EOL] [EOL] await self . _store . async_save ( self . _prefs ) [EOL] [EOL] for listener in self . _listeners : [EOL] self . _hass . async_create_task ( async_create_catching_coro ( listener ( self ) ) ) [EOL] [EOL] async def async_update_google_entity_config ( self , * , entity_id , override_name = _UNDEF , disable_2fa = _UNDEF , aliases = _UNDEF , should_expose = _UNDEF ) : [EOL] [docstring] [EOL] entities = self . google_entity_configs [EOL] entity = entities . get ( entity_id , { } ) [EOL] [EOL] changes = { } [EOL] for key , value in ( ( PREF_OVERRIDE_NAME , override_name ) , ( PREF_DISABLE_2FA , disable_2fa ) , ( PREF_ALIASES , aliases ) , ( PREF_SHOULD_EXPOSE , should_expose ) , ) : [EOL] if value is not _UNDEF : [EOL] changes [ key ] = value [EOL] [EOL] if not changes : [EOL] return [EOL] [EOL] updated_entity = { ** entity , ** changes , } [EOL] [EOL] updated_entities = { ** entities , entity_id : updated_entity , } [EOL] await self . async_update ( google_entity_configs = updated_entities ) [EOL] [EOL] async def async_update_alexa_entity_config ( self , * , entity_id , should_expose = _UNDEF ) : [EOL] [docstring] [EOL] entities = self . alexa_entity_configs [EOL] entity = entities . get ( entity_id , { } ) [EOL] [EOL] changes = { } [EOL] for key , value in ( ( PREF_SHOULD_EXPOSE , should_expose ) , ) : [EOL] if value is not _UNDEF : [EOL] changes [ key ] = value [EOL] [EOL] if not changes : [EOL] return [EOL] [EOL] updated_entity = { ** entity , ** changes , } [EOL] [EOL] updated_entities = { ** entities , entity_id : updated_entity , } [EOL] await self . async_update ( alexa_entity_configs = updated_entities ) [EOL] [EOL] def as_dict ( self ) : [EOL] [docstring] [EOL] return { PREF_ENABLE_ALEXA : self . alexa_enabled , PREF_ENABLE_GOOGLE : self . google_enabled , PREF_ENABLE_REMOTE : self . remote_enabled , PREF_GOOGLE_SECURE_DEVICES_PIN : self . google_secure_devices_pin , PREF_GOOGLE_ENTITY_CONFIGS : self . google_entity_configs , PREF_ALEXA_ENTITY_CONFIGS : self . alexa_entity_configs , PREF_ALEXA_REPORT_STATE : self . alexa_report_state , PREF_CLOUDHOOKS : self . cloudhooks , PREF_CLOUD_USER : self . cloud_user , } [EOL] [EOL] @ property def remote_enabled ( self ) : [EOL] [docstring] [EOL] enabled = self . _prefs . get ( PREF_ENABLE_REMOTE , False ) [EOL] [EOL] if not enabled : [EOL] return False [EOL] [EOL] if self . _has_local_trusted_network or self . _has_local_trusted_proxies : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] @ property def alexa_enabled ( self ) : [EOL] [docstring] [EOL] return self . _prefs [ PREF_ENABLE_ALEXA ] [EOL] [EOL] @ property def alexa_report_state ( self ) : [EOL] [docstring] [EOL] return self . _prefs . get ( PREF_ALEXA_REPORT_STATE , DEFAULT_ALEXA_REPORT_STATE ) [EOL] [EOL] @ property def google_enabled ( self ) : [EOL] [docstring] [EOL] return self . _prefs [ PREF_ENABLE_GOOGLE ] [EOL] [EOL] @ property def google_secure_devices_pin ( self ) : [EOL] [docstring] [EOL] return self . _prefs . get ( PREF_GOOGLE_SECURE_DEVICES_PIN ) [EOL] [EOL] @ property def google_entity_configs ( self ) : [EOL] [docstring] [EOL] return self . _prefs . get ( PREF_GOOGLE_ENTITY_CONFIGS , { } ) [EOL] [EOL] @ property def alexa_entity_configs ( self ) : [EOL] [docstring] [EOL] return self . _prefs . get ( PREF_ALEXA_ENTITY_CONFIGS , { } ) [EOL] [EOL] @ property def cloudhooks ( self ) : [EOL] [docstring] [EOL] return self . _prefs . get ( PREF_CLOUDHOOKS , { } ) [EOL] [EOL] @ property def cloud_user ( self ) : [EOL] [docstring] [EOL] return self . _prefs . get ( PREF_CLOUD_USER ) [EOL] [EOL] @ property def _has_local_trusted_network ( self ) : [EOL] [docstring] [EOL] local4 = ip_address ( [string] ) [EOL] local6 = ip_address ( [string] ) [EOL] [EOL] for prv in self . _hass . auth . auth_providers : [EOL] if prv . type != [string] : [EOL] continue [EOL] [EOL] for network in prv . trusted_networks : [EOL] if local4 in network or local6 in network : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] @ property def _has_local_trusted_proxies ( self ) : [EOL] [docstring] [EOL] if not hasattr ( self . _hass , [string] ) : [EOL] return False [EOL] [EOL] local4 = ip_address ( [string] ) [EOL] local6 = ip_address ( [string] ) [EOL] [EOL] if any ( local4 in nwk or local6 in nwk for nwk in self . _hass . http . trusted_proxies ) : [EOL] return True [EOL] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 $builtins.object$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , List [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] from hass_nabucasa import cloud_api [EOL] [EOL] from homeassistant . const import CLOUD_NEVER_EXPOSED_ENTITIES [EOL] from homeassistant . helpers import entity_registry [EOL] from homeassistant . helpers . event import async_call_later [EOL] from homeassistant . util . dt import utcnow [EOL] from homeassistant . components . alexa import ( config as alexa_config , errors as alexa_errors , entities as alexa_entities , state_report as alexa_state_report , ) [EOL] [EOL] [EOL] from . const import ( CONF_ENTITY_CONFIG , CONF_FILTER , PREF_SHOULD_EXPOSE , DEFAULT_SHOULD_EXPOSE , RequireRelink ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] SYNC_DELAY = [number] [EOL] [EOL] [EOL] class AlexaConfig ( alexa_config . AbstractConfig ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config , prefs , cloud ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( hass ) [EOL] self . _config = config [EOL] self . _prefs = prefs [EOL] self . _cloud = cloud [EOL] self . _token = None [EOL] self . _token_valid = None [EOL] self . _cur_entity_prefs = prefs . alexa_entity_configs [EOL] self . _alexa_sync_unsub = None [EOL] self . _endpoint = None [EOL] [EOL] prefs . async_listen_updates ( self . _async_prefs_updated ) [EOL] hass . bus . async_listen ( entity_registry . EVENT_ENTITY_REGISTRY_UPDATED , self . _handle_entity_registry_updated ) [EOL] [EOL] @ property def enabled ( self ) : [EOL] [docstring] [EOL] return self . _prefs . alexa_enabled [EOL] [EOL] @ property def supports_auth ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def should_report_state ( self ) : [EOL] [docstring] [EOL] return self . _prefs . alexa_report_state [EOL] [EOL] @ property def endpoint ( self ) : [EOL] [docstring] [EOL] if self . _endpoint is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] return self . _endpoint [EOL] [EOL] @ property def entity_config ( self ) : [EOL] [docstring] [EOL] return self . _config . get ( CONF_ENTITY_CONFIG ) or { } [EOL] [EOL] def should_expose ( self , entity_id ) : [EOL] [docstring] [EOL] if entity_id in CLOUD_NEVER_EXPOSED_ENTITIES : [EOL] return False [EOL] [EOL] if not self . _config [ CONF_FILTER ] . empty_filter : [EOL] return self . _config [ CONF_FILTER ] ( entity_id ) [EOL] [EOL] entity_configs = self . _prefs . alexa_entity_configs [EOL] entity_config = entity_configs . get ( entity_id , { } ) [EOL] return entity_config . get ( PREF_SHOULD_EXPOSE , DEFAULT_SHOULD_EXPOSE ) [EOL] [EOL] async def async_get_access_token ( self ) : [EOL] [docstring] [EOL] if self . _token_valid is not None and self . _token_valid < utcnow ( ) : [EOL] return self . _token [EOL] [EOL] resp = await cloud_api . async_alexa_access_token ( self . _cloud ) [EOL] body = await resp . json ( ) [EOL] [EOL] if resp . status == [number] : [EOL] if body [ [string] ] in ( [string] , [string] ) : [EOL] if self . should_report_state : [EOL] await self . _prefs . async_update ( alexa_report_state = False ) [EOL] self . hass . components . persistent_notification . async_create ( [string] [string] [string] . format ( body [ [string] ] ) , [string] , [string] , ) [EOL] raise RequireRelink [EOL] [EOL] raise alexa_errors . NoTokenAvailable [EOL] [EOL] self . _token = body [ [string] ] [EOL] self . _endpoint = body [ [string] ] [EOL] self . _token_valid = utcnow ( ) + timedelta ( seconds = body [ [string] ] ) [EOL] return self . _token [EOL] [EOL] async def _async_prefs_updated ( self , prefs ) : [EOL] [docstring] [EOL] if self . should_report_state != self . is_reporting_states : [EOL] if self . should_report_state : [EOL] await self . async_enable_proactive_mode ( ) [EOL] else : [EOL] await self . async_disable_proactive_mode ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] await self . async_sync_entities ( ) [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( self . _cur_entity_prefs is prefs . alexa_entity_configs or not self . _config [ CONF_FILTER ] . empty_filter ) : [EOL] return [EOL] [EOL] if self . _alexa_sync_unsub : [EOL] self . _alexa_sync_unsub ( ) [EOL] [EOL] self . _alexa_sync_unsub = async_call_later ( self . hass , SYNC_DELAY , self . _sync_prefs ) [EOL] [EOL] async def _sync_prefs ( self , _now ) : [EOL] [docstring] [EOL] self . _alexa_sync_unsub = None [EOL] old_prefs = self . _cur_entity_prefs [EOL] new_prefs = self . _prefs . alexa_entity_configs [EOL] [EOL] seen = set ( ) [EOL] to_update = [ ] [EOL] to_remove = [ ] [EOL] [EOL] for entity_id , info in old_prefs . items ( ) : [EOL] seen . add ( entity_id ) [EOL] old_expose = info . get ( PREF_SHOULD_EXPOSE ) [EOL] [EOL] if entity_id in new_prefs : [EOL] new_expose = new_prefs [ entity_id ] . get ( PREF_SHOULD_EXPOSE ) [EOL] else : [EOL] new_expose = None [EOL] [EOL] if old_expose == new_expose : [EOL] continue [EOL] [EOL] if new_expose : [EOL] to_update . append ( entity_id ) [EOL] else : [EOL] to_remove . append ( entity_id ) [EOL] [EOL] [comment] [EOL] for entity_id , info in new_prefs . items ( ) : [EOL] if entity_id in seen : [EOL] continue [EOL] [EOL] new_expose = info . get ( PREF_SHOULD_EXPOSE ) [EOL] [EOL] if new_expose is None : [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] if new_expose : [EOL] to_update . append ( entity_id ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if await self . _sync_helper ( to_update , to_remove ) : [EOL] self . _cur_entity_prefs = new_prefs [EOL] [EOL] async def async_sync_entities ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _alexa_sync_unsub : [EOL] self . _alexa_sync_unsub ( ) [EOL] self . _alexa_sync_unsub = None [EOL] [EOL] to_update = [ ] [EOL] to_remove = [ ] [EOL] [EOL] for entity in alexa_entities . async_get_entities ( self . hass , self ) : [EOL] if self . should_expose ( entity . entity_id ) : [EOL] to_update . append ( entity . entity_id ) [EOL] else : [EOL] to_remove . append ( entity . entity_id ) [EOL] [EOL] return await self . _sync_helper ( to_update , to_remove ) [EOL] [EOL] async def _sync_helper ( self , to_update , to_remove ) : [EOL] [docstring] [EOL] if not to_update and not to_remove : [EOL] return True [EOL] [EOL] [comment] [EOL] await self . async_get_access_token ( ) [EOL] [EOL] tasks = [ ] [EOL] [EOL] if to_update : [EOL] tasks . append ( alexa_state_report . async_send_add_or_update_message ( self . hass , self , to_update ) ) [EOL] [EOL] if to_remove : [EOL] tasks . append ( alexa_state_report . async_send_delete_message ( self . hass , self , to_remove ) ) [EOL] [EOL] try : [EOL] with async_timeout . timeout ( [number] ) : [EOL] await asyncio . wait ( tasks , return_when = asyncio . ALL_COMPLETED ) [EOL] [EOL] return True [EOL] [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . warning ( [string] ) [EOL] return False [EOL] [EOL] except aiohttp . ClientError as err : [EOL] _LOGGER . warning ( [string] , err ) [EOL] return False [EOL] [EOL] async def _handle_entity_registry_updated ( self , event ) : [EOL] [docstring] [EOL] if not self . enabled or not self . _cloud . is_logged_in : [EOL] return [EOL] [EOL] action = event . data [ [string] ] [EOL] entity_id = event . data [ [string] ] [EOL] to_update = [ ] [EOL] to_remove = [ ] [EOL] [EOL] if action == [string] and self . should_expose ( entity_id ) : [EOL] to_update . append ( entity_id ) [EOL] elif action == [string] and self . should_expose ( entity_id ) : [EOL] to_remove . append ( entity_id ) [EOL] [EOL] try : [EOL] await self . _sync_helper ( to_update , to_remove ) [EOL] except alexa_errors . NoTokenAvailable : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0
from typing import Union , Literal , List , Dict , Any , Optional [EOL] import homeassistant [EOL] import logging [EOL] import datetime [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] from datetime import datetime , timedelta [EOL] import logging [EOL] [EOL] from requests . exceptions import ( ConnectionError as ConnectError , HTTPError , Timeout ) [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . weather import ( ATTR_FORECAST_CONDITION , ATTR_FORECAST_PRECIPITATION , ATTR_FORECAST_TEMP , ATTR_FORECAST_TEMP_LOW , ATTR_FORECAST_TIME , ATTR_FORECAST_WIND_BEARING , ATTR_FORECAST_WIND_SPEED , PLATFORM_SCHEMA , WeatherEntity ) [EOL] from homeassistant . const import ( CONF_API_KEY , CONF_LATITUDE , CONF_LONGITUDE , CONF_MODE , CONF_NAME , PRESSURE_HPA , PRESSURE_INHG , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . util . pressure import convert as convert_pressure [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTRIBUTION = [string] [EOL] [EOL] FORECAST_MODE = [ [string] , [string] ] [EOL] [EOL] MAP_CONDITION = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , } [EOL] [EOL] CONF_UNITS = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Optional ( CONF_LATITUDE ) : cv . latitude , vol . Optional ( CONF_LONGITUDE ) : cv . longitude , vol . Optional ( CONF_MODE , default = [string] ) : vol . In ( FORECAST_MODE ) , vol . Optional ( CONF_UNITS ) : vol . In ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] latitude = config . get ( CONF_LATITUDE , hass . config . latitude ) [EOL] longitude = config . get ( CONF_LONGITUDE , hass . config . longitude ) [EOL] name = config . get ( CONF_NAME ) [EOL] mode = config . get ( CONF_MODE ) [EOL] [EOL] units = config . get ( CONF_UNITS ) [EOL] if not units : [EOL] units = [string] if hass . config . units . is_metric else [string] [EOL] [EOL] dark_sky = DarkSkyData ( config . get ( CONF_API_KEY ) , latitude , longitude , units ) [EOL] [EOL] add_entities ( [ DarkSkyWeather ( name , dark_sky , mode ) ] , True ) [EOL] [EOL] [EOL] class DarkSkyWeather ( WeatherEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , dark_sky , mode ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _dark_sky = dark_sky [EOL] self . _mode = mode [EOL] [EOL] self . _ds_data = None [EOL] self . _ds_currently = None [EOL] self . _ds_hourly = None [EOL] self . _ds_daily = None [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] return ATTRIBUTION [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def temperature ( self ) : [EOL] [docstring] [EOL] return self . _ds_currently . get ( [string] ) [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] if self . _dark_sky . units is None : [EOL] return None [EOL] return TEMP_FAHRENHEIT if [string] in self . _dark_sky . units \ [EOL] else TEMP_CELSIUS [EOL] [EOL] @ property def humidity ( self ) : [EOL] [docstring] [EOL] return round ( self . _ds_currently . get ( [string] ) * [number] , [number] ) [EOL] [EOL] @ property def wind_speed ( self ) : [EOL] [docstring] [EOL] return self . _ds_currently . get ( [string] ) [EOL] [EOL] @ property def wind_bearing ( self ) : [EOL] [docstring] [EOL] return self . _ds_currently . get ( [string] ) [EOL] [EOL] @ property def ozone ( self ) : [EOL] [docstring] [EOL] return self . _ds_currently . get ( [string] ) [EOL] [EOL] @ property def pressure ( self ) : [EOL] [docstring] [EOL] pressure = self . _ds_currently . get ( [string] ) [EOL] if [string] in self . _dark_sky . units : [EOL] return round ( convert_pressure ( pressure , PRESSURE_HPA , PRESSURE_INHG ) , [number] ) [EOL] return pressure [EOL] [EOL] @ property def visibility ( self ) : [EOL] [docstring] [EOL] return self . _ds_currently . get ( [string] ) [EOL] [EOL] @ property def condition ( self ) : [EOL] [docstring] [EOL] return MAP_CONDITION . get ( self . _ds_currently . get ( [string] ) ) [EOL] [EOL] @ property def forecast ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def calc_precipitation ( intensity , hours ) : [EOL] amount = None [EOL] if intensity is not None : [EOL] amount = round ( ( intensity * hours ) , [number] ) [EOL] return amount if amount > [number] else None [EOL] [EOL] data = None [EOL] [EOL] if self . _mode == [string] : [EOL] data = [ { ATTR_FORECAST_TIME : datetime . fromtimestamp ( entry . d . get ( [string] ) ) . isoformat ( ) , ATTR_FORECAST_TEMP : entry . d . get ( [string] ) , ATTR_FORECAST_TEMP_LOW : entry . d . get ( [string] ) , ATTR_FORECAST_PRECIPITATION : calc_precipitation ( entry . d . get ( [string] ) , [number] ) , ATTR_FORECAST_WIND_SPEED : entry . d . get ( [string] ) , ATTR_FORECAST_WIND_BEARING : entry . d . get ( [string] ) , ATTR_FORECAST_CONDITION : MAP_CONDITION . get ( entry . d . get ( [string] ) ) } for entry in self . _ds_daily . data ] [EOL] else : [EOL] data = [ { ATTR_FORECAST_TIME : datetime . fromtimestamp ( entry . d . get ( [string] ) ) . isoformat ( ) , ATTR_FORECAST_TEMP : entry . d . get ( [string] ) , ATTR_FORECAST_PRECIPITATION : calc_precipitation ( entry . d . get ( [string] ) , [number] ) , ATTR_FORECAST_CONDITION : MAP_CONDITION . get ( entry . d . get ( [string] ) ) } for entry in self . _ds_hourly . data ] [EOL] [EOL] return data [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _dark_sky . update ( ) [EOL] [EOL] self . _ds_data = self . _dark_sky . data [EOL] self . _ds_currently = self . _dark_sky . currently . d [EOL] self . _ds_hourly = self . _dark_sky . hourly [EOL] self . _ds_daily = self . _dark_sky . daily [EOL] [EOL] [EOL] class DarkSkyData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_key , latitude , longitude , units ) : [EOL] [docstring] [EOL] self . _api_key = api_key [EOL] self . latitude = latitude [EOL] self . longitude = longitude [EOL] self . requested_units = units [EOL] [EOL] self . data = None [EOL] self . currently = None [EOL] self . hourly = None [EOL] self . daily = None [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] import forecastio [EOL] [EOL] try : [EOL] self . data = forecastio . load_forecast ( self . _api_key , self . latitude , self . longitude , units = self . requested_units ) [EOL] self . currently = self . data . currently ( ) [EOL] self . hourly = self . data . hourly ( ) [EOL] self . daily = self . data . daily ( ) [EOL] except ( ConnectError , HTTPError , Timeout , ValueError ) as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] self . data = None [EOL] [EOL] @ property def units ( self ) : [EOL] [docstring] [EOL] if self . data is None : [EOL] return None [EOL] return self . data . json . get ( [string] ) . get ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Any]]$ 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . discovery import async_load_platform [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DATA_SISYPHUS = [string] [EOL] DOMAIN = [string] [EOL] [EOL] AUTODETECT_SCHEMA = vol . Schema ( { } ) [EOL] [EOL] TABLE_SCHEMA = vol . Schema ( { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , } ) [EOL] [EOL] TABLES_SCHEMA = vol . Schema ( [ TABLE_SCHEMA ] ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Any ( AUTODETECT_SCHEMA , TABLES_SCHEMA ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] from sisyphus_control import Table [EOL] [EOL] class SocketIONoiseFilter ( logging . Filter ) : [EOL] [docstring] [EOL] [EOL] def filter ( self , record ) : [EOL] if record . msg . contains ( [string] ) : [EOL] return False [EOL] return True [EOL] [EOL] logging . getLogger ( [string] ) . addFilter ( SocketIONoiseFilter ( ) ) [EOL] tables = hass . data . setdefault ( DATA_SISYPHUS , { } ) [EOL] table_configs = config . get ( DOMAIN ) [EOL] session = async_get_clientsession ( hass ) [EOL] [EOL] async def add_table ( host , name = None ) : [EOL] [docstring] [EOL] tables [ host ] = TableHolder ( hass , session , host , name ) [EOL] [EOL] hass . async_create_task ( async_load_platform ( hass , [string] , DOMAIN , { CONF_HOST : host , } , config ) ) [EOL] hass . async_create_task ( async_load_platform ( hass , [string] , DOMAIN , { CONF_HOST : host , } , config ) ) [EOL] [EOL] if isinstance ( table_configs , dict ) : [comment] [EOL] for ip_address in await Table . find_table_ips ( session ) : [EOL] await add_table ( ip_address ) [EOL] else : [comment] [EOL] for conf in table_configs : [EOL] await add_table ( conf [ CONF_HOST ] , conf [ CONF_NAME ] ) [EOL] [EOL] async def close_tables ( * args ) : [EOL] [docstring] [EOL] tasks = [ table . close ( ) for table in tables . values ( ) ] [EOL] if tasks : [EOL] await asyncio . wait ( tasks ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , close_tables ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class TableHolder : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , session , host , name ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _session = session [EOL] self . _host = host [EOL] self . _name = name [EOL] self . _table = None [EOL] self . _table_task = None [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] if self . _table_task and self . _table_task . done ( ) : [EOL] return self . _table_task . result ( ) . is_connected [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] async def get_table ( self ) : [EOL] [docstring] [EOL] if not self . _table_task : [EOL] self . _table_task = self . _hass . async_create_task ( self . _connect_table ( ) ) [EOL] [EOL] return await self . _table_task [EOL] [EOL] async def _connect_table ( self ) : [EOL] from sisyphus_control import Table [EOL] self . _table = await Table . connect ( self . _host , self . _session ) [EOL] if self . _name is None : [EOL] self . _name = self . _table . name [EOL] _LOGGER . debug ( [string] , self . _name , self . _host ) [EOL] return self . _table [EOL] [EOL] async def close ( self ) : [EOL] [docstring] [EOL] if self . _table : [EOL] await self . _table . close ( ) [EOL] self . _table = None [EOL] self . _table_task = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] from collections . abc import Mapping [EOL] from copy import deepcopy [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ATTR_SERVICE [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] from homeassistant . components . notify import ( ATTR_DATA , ATTR_MESSAGE , DOMAIN , PLATFORM_SCHEMA , BaseNotificationService ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_SERVICES = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SERVICES ) : vol . All ( cv . ensure_list , [ { vol . Required ( ATTR_SERVICE ) : cv . slug , vol . Optional ( ATTR_DATA ) : dict , } ] ) } ) [EOL] [EOL] [EOL] def update ( input_dict , update_source ) : [EOL] [docstring] [EOL] for key , val in update_source . items ( ) : [EOL] if isinstance ( val , Mapping ) : [EOL] recurse = update ( input_dict . get ( key , { } ) , val ) [EOL] input_dict [ key ] = recurse [EOL] else : [EOL] input_dict [ key ] = update_source [ key ] [EOL] return input_dict [EOL] [EOL] [EOL] async def async_get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] return GroupNotifyPlatform ( hass , config . get ( CONF_SERVICES ) ) [EOL] [EOL] [EOL] class GroupNotifyPlatform ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , entities ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . entities = entities [EOL] [EOL] async def async_send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] payload = { ATTR_MESSAGE : message } [EOL] payload . update ( { key : val for key , val in kwargs . items ( ) if val } ) [EOL] [EOL] tasks = [ ] [EOL] for entity in self . entities : [EOL] sending_payload = deepcopy ( payload . copy ( ) ) [EOL] if entity . get ( ATTR_DATA ) is not None : [EOL] update ( sending_payload , entity . get ( ATTR_DATA ) ) [EOL] tasks . append ( self . hass . services . async_call ( DOMAIN , entity . get ( ATTR_SERVICE ) , sending_payload ) ) [EOL] [EOL] if tasks : [EOL] await asyncio . wait ( tasks ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ATTR_ENTITY_ID , CONF_ICON , CONF_NAME , CONF_MAXIMUM , CONF_MINIMUM [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . restore_state import RestoreEntity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_INITIAL = [string] [EOL] ATTR_STEP = [string] [EOL] ATTR_MINIMUM = [string] [EOL] ATTR_MAXIMUM = [string] [EOL] [EOL] CONF_INITIAL = [string] [EOL] CONF_RESTORE = [string] [EOL] CONF_STEP = [string] [EOL] [EOL] DEFAULT_INITIAL = [number] [EOL] DEFAULT_STEP = [number] [EOL] DOMAIN = [string] [EOL] [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] SERVICE_DECREMENT = [string] [EOL] SERVICE_INCREMENT = [string] [EOL] SERVICE_RESET = [string] [EOL] SERVICE_CONFIGURE = [string] [EOL] [EOL] SERVICE_SCHEMA_SIMPLE = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . comp_entity_ids , } ) [EOL] [EOL] SERVICE_SCHEMA_CONFIGURE = vol . Schema ( { ATTR_ENTITY_ID : cv . comp_entity_ids , vol . Optional ( ATTR_MINIMUM ) : vol . Any ( None , vol . Coerce ( int ) ) , vol . Optional ( ATTR_MAXIMUM ) : vol . Any ( None , vol . Coerce ( int ) ) , vol . Optional ( ATTR_STEP ) : cv . positive_int , } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : cv . schema_with_slug_keys ( vol . Any ( { vol . Optional ( CONF_ICON ) : cv . icon , vol . Optional ( CONF_INITIAL , default = DEFAULT_INITIAL ) : cv . positive_int , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_MAXIMUM , default = None ) : vol . Any ( None , vol . Coerce ( int ) ) , vol . Optional ( CONF_MINIMUM , default = None ) : vol . Any ( None , vol . Coerce ( int ) ) , vol . Optional ( CONF_RESTORE , default = True ) : cv . boolean , vol . Optional ( CONF_STEP , default = DEFAULT_STEP ) : cv . positive_int , } , None ) ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass ) [EOL] [EOL] entities = [ ] [EOL] [EOL] for object_id , cfg in config [ DOMAIN ] . items ( ) : [EOL] if not cfg : [EOL] cfg = { } [EOL] [EOL] name = cfg . get ( CONF_NAME ) [EOL] initial = cfg . get ( CONF_INITIAL ) [EOL] restore = cfg . get ( CONF_RESTORE ) [EOL] step = cfg . get ( CONF_STEP ) [EOL] icon = cfg . get ( CONF_ICON ) [EOL] minimum = cfg . get ( CONF_MINIMUM ) [EOL] maximum = cfg . get ( CONF_MAXIMUM ) [EOL] [EOL] entities . append ( Counter ( object_id , name , initial , minimum , maximum , restore , step , icon ) ) [EOL] [EOL] if not entities : [EOL] return False [EOL] [EOL] component . async_register_entity_service ( SERVICE_INCREMENT , SERVICE_SCHEMA_SIMPLE , [string] ) [EOL] component . async_register_entity_service ( SERVICE_DECREMENT , SERVICE_SCHEMA_SIMPLE , [string] ) [EOL] component . async_register_entity_service ( SERVICE_RESET , SERVICE_SCHEMA_SIMPLE , [string] ) [EOL] component . async_register_entity_service ( SERVICE_CONFIGURE , SERVICE_SCHEMA_CONFIGURE , [string] ) [EOL] [EOL] await component . async_add_entities ( entities ) [EOL] return True [EOL] [EOL] [EOL] class Counter ( RestoreEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , object_id , name , initial , minimum , maximum , restore , step , icon ) : [EOL] [docstring] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( object_id ) [EOL] self . _name = name [EOL] self . _restore = restore [EOL] self . _step = step [EOL] self . _state = self . _initial = initial [EOL] self . _min = minimum [EOL] self . _max = maximum [EOL] self . _icon = icon [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] ret = { ATTR_INITIAL : self . _initial , ATTR_STEP : self . _step , } [EOL] if self . _min is not None : [EOL] ret [ CONF_MINIMUM ] = self . _min [EOL] if self . _max is not None : [EOL] ret [ CONF_MAXIMUM ] = self . _max [EOL] return ret [EOL] [EOL] def compute_next_state ( self , state ) : [EOL] [docstring] [EOL] if self . _min is not None : [EOL] state = max ( self . _min , state ) [EOL] if self . _max is not None : [EOL] state = min ( self . _max , state ) [EOL] [EOL] return state [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] await super ( ) . async_added_to_hass ( ) [EOL] [comment] [EOL] [comment] [EOL] if self . _restore : [EOL] state = await self . async_get_last_state ( ) [EOL] if state is not None : [EOL] self . _state = self . compute_next_state ( int ( state . state ) ) [EOL] [EOL] async def async_decrement ( self ) : [EOL] [docstring] [EOL] self . _state = self . compute_next_state ( self . _state - self . _step ) [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_increment ( self ) : [EOL] [docstring] [EOL] self . _state = self . compute_next_state ( self . _state + self . _step ) [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_reset ( self ) : [EOL] [docstring] [EOL] self . _state = self . compute_next_state ( self . _initial ) [EOL] await self . async_update_ha_state ( ) [EOL] [EOL] async def async_configure ( self , ** kwargs ) : [EOL] [docstring] [EOL] if CONF_MINIMUM in kwargs : [EOL] self . _min = kwargs [ CONF_MINIMUM ] [EOL] if CONF_MAXIMUM in kwargs : [EOL] self . _max = kwargs [ CONF_MAXIMUM ] [EOL] if CONF_STEP in kwargs : [EOL] self . _step = kwargs [ CONF_STEP ] [EOL] [EOL] self . _state = self . compute_next_state ( self . _state ) [EOL] await self . async_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Dict , Any , Optional [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] import random [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_MONITORED_CONDITIONS , CONF_NAME , CONF_TOKEN ) [EOL] from homeassistant . helpers . aiohttp_client import SERVER_SOFTWARE [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_IDENTITY = [string] [EOL] [EOL] ATTRIBUTION = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] ICON_RECORD = [string] [EOL] ICON_PLAYER = [string] [EOL] UNIT_RECORDS = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] SENSOR_COLLECTION_TYPE = [string] [EOL] SENSOR_WANTLIST_TYPE = [string] [EOL] SENSOR_RANDOM_RECORD_TYPE = [string] [EOL] [EOL] SENSORS = { SENSOR_COLLECTION_TYPE : { [string] : [string] , [string] : ICON_RECORD , [string] : UNIT_RECORDS } , SENSOR_WANTLIST_TYPE : { [string] : [string] , [string] : ICON_RECORD , [string] : UNIT_RECORDS } , SENSOR_RANDOM_RECORD_TYPE : { [string] : [string] , [string] : ICON_PLAYER , [string] : None } , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_TOKEN ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSORS ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSORS ) ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import discogs_client [EOL] [EOL] token = config [ CONF_TOKEN ] [EOL] name = config [ CONF_NAME ] [EOL] [EOL] try : [EOL] discogs_client = discogs_client . Client ( SERVER_SOFTWARE , user_token = token ) [EOL] [EOL] discogs_data = { [string] : discogs_client . identity ( ) . name , [string] : discogs_client . identity ( ) . collection_folders , [string] : discogs_client . identity ( ) . num_collection , [string] : discogs_client . identity ( ) . num_wantlist } [EOL] except discogs_client . exceptions . HTTPError : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] sensors = [ ] [EOL] for sensor_type in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] sensors . append ( DiscogsSensor ( discogs_data , name , sensor_type ) ) [EOL] [EOL] add_entities ( sensors , True ) [EOL] [EOL] [EOL] class DiscogsSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , discogs_data , name , sensor_type ) : [EOL] [docstring] [EOL] self . _discogs_data = discogs_data [EOL] self . _name = name [EOL] self . _type = sensor_type [EOL] self . _state = None [EOL] self . _attrs = { } [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name , SENSORS [ self . _type ] [ [string] ] ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return SENSORS [ self . _type ] [ [string] ] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return SENSORS [ self . _type ] [ [string] ] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _state is None or self . _attrs is None : [EOL] return None [EOL] [EOL] if self . _type != SENSOR_RANDOM_RECORD_TYPE : [EOL] return { ATTR_ATTRIBUTION : ATTRIBUTION , ATTR_IDENTITY : self . _discogs_data [ [string] ] , } [EOL] [EOL] return { [string] : self . _attrs [ [string] ] [ [number] ] [ [string] ] , [string] : self . _attrs [ [string] ] , [string] : [string] . format ( self . _attrs [ [string] ] [ [number] ] [ [string] ] , self . _attrs [ [string] ] [ [number] ] [ [string] ] [ [number] ] ) , [string] : self . _attrs [ [string] ] [ [number] ] [ [string] ] , [string] : self . _attrs [ [string] ] , ATTR_ATTRIBUTION : ATTRIBUTION , ATTR_IDENTITY : self . _discogs_data [ [string] ] , } [EOL] [EOL] def get_random_record ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] collection = self . _discogs_data [ [string] ] [ [number] ] [EOL] random_index = random . randrange ( collection . count ) [EOL] random_record = collection . releases [ random_index ] . release [EOL] [EOL] self . _attrs = random_record . data [EOL] return [string] . format ( random_record . data [ [string] ] [ [number] ] [ [string] ] , random_record . data [ [string] ] ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . _type == SENSOR_COLLECTION_TYPE : [EOL] self . _state = self . _discogs_data [ [string] ] [EOL] elif self . _type == SENSOR_WANTLIST_TYPE : [EOL] self . _state = self . _discogs_data [ [string] ] [EOL] else : [EOL] self . _state = self . get_random_record ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List , Type [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import collections [EOL] import itertools [EOL] import logging [EOL] import os [EOL] import traceback [EOL] [EOL] from homeassistant . components . system_log import LogEntry , _figure_out_source [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . device_registry import ( async_get_registry as get_dev_reg ) [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_send [EOL] [EOL] from . . api import async_get_device_info [EOL] from . const import ( ADD_DEVICE_RELAY_LOGGERS , ATTR_MANUFACTURER , BELLOWS , CONF_BAUDRATE , CONF_DATABASE , CONF_RADIO_TYPE , CONF_USB_PATH , CONTROLLER , CURRENT , DATA_ZHA , DATA_ZHA_BRIDGE_ID , DATA_ZHA_GATEWAY , DEBUG_LEVELS , DEFAULT_BAUDRATE , DEFAULT_DATABASE_NAME , DEVICE_FULL_INIT , DEVICE_INFO , DEVICE_JOINED , DEVICE_REMOVED , DOMAIN , IEEE , LOG_ENTRY , LOG_OUTPUT , MODEL , NWK , ORIGINAL , RADIO , RADIO_DESCRIPTION , RAW_INIT , SIGNAL_REMOVE , SIGNATURE , TYPE , UNKNOWN_MANUFACTURER , UNKNOWN_MODEL , ZHA , ZHA_GW_MSG , ZIGPY , ZIGPY_DECONZ , ZIGPY_XBEE ) [EOL] from . device import DeviceStatus , ZHADevice [EOL] from . discovery import ( async_dispatch_discovery_info , async_process_endpoint ) [EOL] from . patches import apply_application_controller_patch [EOL] from . registries import INPUT_BIND_ONLY_CLUSTERS , RADIO_TYPES [EOL] from . store import async_get_registry [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] EntityReference = collections . namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] class ZHAGateway : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _config = config [EOL] self . _devices = { } [EOL] self . _device_registry = collections . defaultdict ( list ) [EOL] self . zha_storage = None [EOL] self . application_controller = None [EOL] self . radio_description = None [EOL] hass . data [ DATA_ZHA ] [ DATA_ZHA_GATEWAY ] = self [EOL] self . _log_levels = { ORIGINAL : async_capture_log_levels ( ) , CURRENT : async_capture_log_levels ( ) } [EOL] self . debug_enabled = False [EOL] self . _log_relay_handler = LogRelayHandler ( hass , self ) [EOL] [EOL] async def async_initialize ( self , config_entry ) : [EOL] [docstring] [EOL] self . zha_storage = await async_get_registry ( self . _hass ) [EOL] [EOL] usb_path = config_entry . data . get ( CONF_USB_PATH ) [EOL] baudrate = self . _config . get ( CONF_BAUDRATE , DEFAULT_BAUDRATE ) [EOL] radio_type = config_entry . data . get ( CONF_RADIO_TYPE ) [EOL] [EOL] radio_details = RADIO_TYPES [ radio_type ] [ RADIO ] ( ) [EOL] radio = radio_details [ RADIO ] [EOL] self . radio_description = RADIO_TYPES [ radio_type ] [ RADIO_DESCRIPTION ] [EOL] await radio . connect ( usb_path , baudrate ) [EOL] [EOL] if CONF_DATABASE in self . _config : [EOL] database = self . _config [ CONF_DATABASE ] [EOL] else : [EOL] database = os . path . join ( self . _hass . config . config_dir , DEFAULT_DATABASE_NAME ) [EOL] [EOL] self . application_controller = radio_details [ CONTROLLER ] ( radio , database ) [EOL] apply_application_controller_patch ( self ) [EOL] self . application_controller . add_listener ( self ) [EOL] await self . application_controller . startup ( auto_form = True ) [EOL] self . _hass . data [ DATA_ZHA ] [ DATA_ZHA_BRIDGE_ID ] = str ( self . application_controller . ieee ) [EOL] [EOL] init_tasks = [ ] [EOL] for device in self . application_controller . devices . values ( ) : [EOL] if device . nwk == [number] : [EOL] continue [EOL] init_tasks . append ( self . async_device_initialized ( device , False ) ) [EOL] await asyncio . gather ( * init_tasks ) [EOL] [EOL] def device_joined ( self , device ) : [EOL] [docstring] [EOL] async_dispatcher_send ( self . _hass , ZHA_GW_MSG , { TYPE : DEVICE_JOINED , NWK : device . nwk , IEEE : str ( device . ieee ) } ) [EOL] [EOL] def raw_device_initialized ( self , device ) : [EOL] [docstring] [EOL] if device . nwk == [number] : [EOL] return [EOL] [EOL] manuf = device . manufacturer [EOL] async_dispatcher_send ( self . _hass , ZHA_GW_MSG , { TYPE : RAW_INIT , NWK : device . nwk , IEEE : str ( device . ieee ) , MODEL : device . model if device . model else UNKNOWN_MODEL , ATTR_MANUFACTURER : manuf if manuf else UNKNOWN_MANUFACTURER , SIGNATURE : device . get_signature ( ) } ) [EOL] [EOL] def device_initialized ( self , device ) : [EOL] [docstring] [EOL] self . _hass . async_create_task ( self . async_device_initialized ( device , True ) ) [EOL] [EOL] def device_left ( self , device ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] async def _async_remove_device ( self , device , entity_refs ) : [EOL] if entity_refs is not None : [EOL] remove_tasks = [ ] [EOL] for entity_ref in entity_refs : [EOL] remove_tasks . append ( entity_ref . remove_future ) [EOL] await asyncio . wait ( remove_tasks ) [EOL] ha_device_registry = await get_dev_reg ( self . _hass ) [EOL] reg_device = ha_device_registry . async_get_device ( { ( DOMAIN , str ( device . ieee ) ) } , set ( ) ) [EOL] if reg_device is not None : [EOL] ha_device_registry . async_remove_device ( reg_device . id ) [EOL] [EOL] def device_removed ( self , device ) : [EOL] [docstring] [EOL] zha_device = self . _devices . pop ( device . ieee , None ) [EOL] entity_refs = self . _device_registry . pop ( device . ieee , None ) [EOL] if zha_device is not None : [EOL] device_info = async_get_device_info ( self . _hass , zha_device ) [EOL] zha_device . async_unsub_dispatcher ( ) [EOL] async_dispatcher_send ( self . _hass , [string] . format ( SIGNAL_REMOVE , str ( zha_device . ieee ) ) ) [EOL] asyncio . ensure_future ( self . _async_remove_device ( zha_device , entity_refs ) ) [EOL] if device_info is not None : [EOL] async_dispatcher_send ( self . _hass , ZHA_GW_MSG , { TYPE : DEVICE_REMOVED , DEVICE_INFO : device_info } ) [EOL] [EOL] def get_device ( self , ieee ) : [EOL] [docstring] [EOL] return self . _devices . get ( ieee ) [EOL] [EOL] def get_entity_reference ( self , entity_id ) : [EOL] [docstring] [EOL] for entity_reference in itertools . chain . from_iterable ( self . device_registry . values ( ) ) : [EOL] if entity_id == entity_reference . reference_id : [EOL] return entity_reference [EOL] [EOL] @ property def devices ( self ) : [EOL] [docstring] [EOL] return self . _devices [EOL] [EOL] @ property def device_registry ( self ) : [EOL] [docstring] [EOL] return self . _device_registry [EOL] [EOL] def register_entity_reference ( self , ieee , reference_id , zha_device , cluster_channels , device_info , remove_future ) : [EOL] [docstring] [EOL] self . _device_registry [ ieee ] . append ( EntityReference ( reference_id = reference_id , zha_device = zha_device , cluster_channels = cluster_channels , device_info = device_info , remove_future = remove_future ) ) [EOL] [EOL] @ callback def async_enable_debug_mode ( self ) : [EOL] [docstring] [EOL] self . _log_levels [ ORIGINAL ] = async_capture_log_levels ( ) [EOL] async_set_logger_levels ( DEBUG_LEVELS ) [EOL] self . _log_levels [ CURRENT ] = async_capture_log_levels ( ) [EOL] [EOL] for logger_name in ADD_DEVICE_RELAY_LOGGERS : [EOL] logging . getLogger ( logger_name ) . addHandler ( self . _log_relay_handler ) [EOL] [EOL] self . debug_enabled = True [EOL] [EOL] @ callback def async_disable_debug_mode ( self ) : [EOL] [docstring] [EOL] async_set_logger_levels ( self . _log_levels [ ORIGINAL ] ) [EOL] self . _log_levels [ CURRENT ] = async_capture_log_levels ( ) [EOL] for logger_name in ADD_DEVICE_RELAY_LOGGERS : [EOL] logging . getLogger ( logger_name ) . removeHandler ( self . _log_relay_handler ) [EOL] self . debug_enabled = False [EOL] [EOL] @ callback def _async_get_or_create_device ( self , zigpy_device , is_new_join ) : [EOL] [docstring] [EOL] zha_device = self . _devices . get ( zigpy_device . ieee ) [EOL] if zha_device is None : [EOL] zha_device = ZHADevice ( self . _hass , zigpy_device , self ) [EOL] self . _devices [ zigpy_device . ieee ] = zha_device [EOL] if not is_new_join : [EOL] entry = self . zha_storage . async_get_or_create ( zha_device ) [EOL] zha_device . async_update_last_seen ( entry . last_seen ) [EOL] return zha_device [EOL] [EOL] @ callback def async_device_became_available ( self , sender , is_reply , profile , cluster , src_ep , dst_ep , tsn , command_id , args ) : [EOL] [docstring] [EOL] self . async_update_device ( sender ) [EOL] [EOL] @ callback def async_update_device ( self , sender ) : [EOL] [docstring] [EOL] if sender . ieee in self . devices : [EOL] device = self . devices [ sender . ieee ] [EOL] [comment] [EOL] if device . status is DeviceStatus . INITIALIZED : [EOL] device . update_available ( True ) [EOL] [EOL] async def async_update_device_storage ( self ) : [EOL] [docstring] [EOL] for device in self . devices . values ( ) : [EOL] self . zha_storage . async_update ( device ) [EOL] await self . zha_storage . async_save ( ) [EOL] [EOL] async def async_device_initialized ( self , device , is_new_join ) : [EOL] [docstring] [EOL] if device . nwk == [number] : [EOL] return [EOL] [EOL] zha_device = self . _async_get_or_create_device ( device , is_new_join ) [EOL] [EOL] is_rejoin = False [EOL] if zha_device . status is not DeviceStatus . INITIALIZED : [EOL] discovery_infos = [ ] [EOL] for endpoint_id , endpoint in device . endpoints . items ( ) : [EOL] async_process_endpoint ( self . _hass , self . _config , endpoint_id , endpoint , discovery_infos , device , zha_device , is_new_join ) [EOL] if endpoint_id != [number] : [EOL] for cluster in endpoint . in_clusters . values ( ) : [EOL] cluster . bind_only = cluster . cluster_id in INPUT_BIND_ONLY_CLUSTERS [EOL] for cluster in endpoint . out_clusters . values ( ) : [EOL] [comment] [EOL] cluster . bind_only = True [EOL] else : [EOL] is_rejoin = is_new_join is True [EOL] _LOGGER . debug ( [string] , [string] . format ( zha_device . ieee , is_rejoin ) ) [EOL] [EOL] if is_new_join : [EOL] [comment] [EOL] await zha_device . async_configure ( ) [EOL] zha_device . update_available ( True ) [EOL] elif zha_device . is_mains_powered : [EOL] [comment] [EOL] [comment] [EOL] _LOGGER . debug ( [string] , zha_device . name , [string] . format ( zha_device . power_source ) ) [EOL] await zha_device . async_initialize ( from_cache = False ) [EOL] else : [EOL] await zha_device . async_initialize ( from_cache = True ) [EOL] [EOL] if not is_rejoin : [EOL] for discovery_info in discovery_infos : [EOL] async_dispatch_discovery_info ( self . _hass , is_new_join , discovery_info ) [EOL] [EOL] if is_new_join : [EOL] device_info = async_get_device_info ( self . _hass , zha_device ) [EOL] async_dispatcher_send ( self . _hass , ZHA_GW_MSG , { TYPE : DEVICE_FULL_INIT , DEVICE_INFO : device_info } ) [EOL] [EOL] async def shutdown ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] await self . application_controller . shutdown ( ) [EOL] [EOL] [EOL] @ callback def async_capture_log_levels ( ) : [EOL] [docstring] [EOL] return { BELLOWS : logging . getLogger ( BELLOWS ) . getEffectiveLevel ( ) , ZHA : logging . getLogger ( ZHA ) . getEffectiveLevel ( ) , ZIGPY : logging . getLogger ( ZIGPY ) . getEffectiveLevel ( ) , ZIGPY_XBEE : logging . getLogger ( ZIGPY_XBEE ) . getEffectiveLevel ( ) , ZIGPY_DECONZ : logging . getLogger ( ZIGPY_DECONZ ) . getEffectiveLevel ( ) , } [EOL] [EOL] [EOL] @ callback def async_set_logger_levels ( levels ) : [EOL] [docstring] [EOL] logging . getLogger ( BELLOWS ) . setLevel ( levels [ BELLOWS ] ) [EOL] logging . getLogger ( ZHA ) . setLevel ( levels [ ZHA ] ) [EOL] logging . getLogger ( ZIGPY ) . setLevel ( levels [ ZIGPY ] ) [EOL] logging . getLogger ( ZIGPY_XBEE ) . setLevel ( levels [ ZIGPY_XBEE ] ) [EOL] logging . getLogger ( ZIGPY_DECONZ ) . setLevel ( levels [ ZIGPY_DECONZ ] ) [EOL] [EOL] [EOL] class LogRelayHandler ( logging . Handler ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , gateway ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . hass = hass [EOL] self . gateway = gateway [EOL] [EOL] def emit ( self , record ) : [EOL] [docstring] [EOL] stack = [ ] [EOL] if record . levelno >= logging . WARN : [EOL] if not record . exc_info : [EOL] stack = [ f for f , _ , _ , _ in traceback . extract_stack ( ) ] [EOL] [EOL] entry = LogEntry ( record , stack , _figure_out_source ( record , stack , self . hass ) ) [EOL] async_dispatcher_send ( self . hass , ZHA_GW_MSG , { TYPE : LOG_OUTPUT , LOG_ENTRY : entry . to_dict ( ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.zha.core.gateway.EntityReference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $homeassistant.components.zha.core.gateway.LogRelayHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.zha.core.gateway.EntityReference]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [comment] [EOL] from . device import ZHADevice [EOL] from . gateway import ZHAGateway [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Literal , Dict , Tuple , List [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] import enum [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import DOMAIN as BINARY_SENSOR [EOL] from homeassistant . components . fan import DOMAIN as FAN [EOL] from homeassistant . components . light import DOMAIN as LIGHT [EOL] from homeassistant . components . lock import DOMAIN as LOCK [EOL] from homeassistant . components . sensor import DOMAIN as SENSOR [EOL] from homeassistant . components . switch import DOMAIN as SWITCH [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] BAUD_RATES = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] DATA_ZHA = [string] [EOL] DATA_ZHA_CONFIG = [string] [EOL] DATA_ZHA_BRIDGE_ID = [string] [EOL] DATA_ZHA_DISPATCHERS = [string] [EOL] DATA_ZHA_CORE_EVENTS = [string] [EOL] DATA_ZHA_GATEWAY = [string] [EOL] ZHA_DISCOVERY_NEW = [string] [EOL] [EOL] COMPONENTS = ( BINARY_SENSOR , FAN , LIGHT , LOCK , SENSOR , SWITCH , ) [EOL] [EOL] CONF_BAUDRATE = [string] [EOL] CONF_DATABASE = [string] [EOL] CONF_DEVICE_CONFIG = [string] [EOL] CONF_RADIO_TYPE = [string] [EOL] CONF_USB_PATH = [string] [EOL] DATA_DEVICE_CONFIG = [string] [EOL] ENABLE_QUIRKS = [string] [EOL] [EOL] RADIO = [string] [EOL] RADIO_DESCRIPTION = [string] [EOL] CONTROLLER = [string] [EOL] [EOL] DEFAULT_RADIO_TYPE = [string] [EOL] DEFAULT_BAUDRATE = [number] [EOL] DEFAULT_DATABASE_NAME = [string] [EOL] [EOL] ATTR_CLUSTER_ID = [string] [EOL] ATTR_CLUSTER_TYPE = [string] [EOL] ATTR_ATTRIBUTE = [string] [EOL] ATTR_VALUE = [string] [EOL] ATTR_MANUFACTURER = [string] [EOL] ATTR_COMMAND = [string] [EOL] ATTR_COMMAND_TYPE = [string] [EOL] ATTR_ARGS = [string] [EOL] ATTR_ENDPOINT_ID = [string] [EOL] [EOL] IN = [string] [EOL] OUT = [string] [EOL] CLIENT_COMMANDS = [string] [EOL] SERVER_COMMANDS = [string] [EOL] SERVER = [string] [EOL] IEEE = [string] [EOL] MODEL = [string] [EOL] NAME = [string] [EOL] LQI = [string] [EOL] RSSI = [string] [EOL] LAST_SEEN = [string] [EOL] [EOL] SENSOR_TYPE = [string] [EOL] HUMIDITY = [string] [EOL] TEMPERATURE = [string] [EOL] ILLUMINANCE = [string] [EOL] PRESSURE = [string] [EOL] METERING = [string] [EOL] ELECTRICAL_MEASUREMENT = [string] [EOL] GENERIC = [string] [EOL] BATTERY = [string] [EOL] UNKNOWN = [string] [EOL] UNKNOWN_MANUFACTURER = [string] [EOL] UNKNOWN_MODEL = [string] [EOL] OPENING = [string] [EOL] OCCUPANCY = [string] [EOL] ACCELERATION = [string] [EOL] [EOL] ATTR_LEVEL = [string] [EOL] [EOL] ZDO_CHANNEL = [string] [EOL] ON_OFF_CHANNEL = [string] [EOL] ATTRIBUTE_CHANNEL = [string] [EOL] BASIC_CHANNEL = [string] [EOL] COLOR_CHANNEL = [string] [EOL] FAN_CHANNEL = [string] [EOL] LEVEL_CHANNEL = ATTR_LEVEL [EOL] ZONE_CHANNEL = ZONE = [string] [EOL] ELECTRICAL_MEASUREMENT_CHANNEL = [string] [EOL] POWER_CONFIGURATION_CHANNEL = [string] [EOL] EVENT_RELAY_CHANNEL = [string] [EOL] DOORLOCK_CHANNEL = [string] [EOL] [EOL] SIGNAL_ATTR_UPDATED = [string] [EOL] SIGNAL_MOVE_LEVEL = [string] [EOL] SIGNAL_SET_LEVEL = [string] [EOL] SIGNAL_STATE_ATTR = [string] [EOL] SIGNAL_AVAILABLE = [string] [EOL] SIGNAL_REMOVE = [string] [EOL] [EOL] QUIRK_APPLIED = [string] [EOL] QUIRK_CLASS = [string] [EOL] MANUFACTURER_CODE = [string] [EOL] POWER_SOURCE = [string] [EOL] MAINS_POWERED = [string] [EOL] BATTERY_OR_UNKNOWN = [string] [EOL] [EOL] BELLOWS = [string] [EOL] ZHA = [string] [EOL] ZIGPY = [string] [EOL] ZIGPY_XBEE = [string] [EOL] ZIGPY_DECONZ = [string] [EOL] ORIGINAL = [string] [EOL] CURRENT = [string] [EOL] DEBUG_LEVELS = { BELLOWS : logging . DEBUG , ZHA : logging . DEBUG , ZIGPY : logging . DEBUG , ZIGPY_XBEE : logging . DEBUG , ZIGPY_DECONZ : logging . DEBUG , } [EOL] ADD_DEVICE_RELAY_LOGGERS = [ ZHA , ZIGPY ] [EOL] TYPE = [string] [EOL] NWK = [string] [EOL] SIGNATURE = [string] [EOL] RAW_INIT = [string] [EOL] ZHA_GW_MSG = [string] [EOL] DEVICE_REMOVED = [string] [EOL] DEVICE_INFO = [string] [EOL] DEVICE_FULL_INIT = [string] [EOL] DEVICE_JOINED = [string] [EOL] LOG_OUTPUT = [string] [EOL] LOG_ENTRY = [string] [EOL] MFG_CLUSTER_ID_START = [number] [EOL] [EOL] [EOL] class RadioType ( enum . Enum ) : [EOL] [docstring] [EOL] [EOL] ezsp = [string] [EOL] xbee = [string] [EOL] deconz = [string] [EOL] [EOL] @ classmethod def list ( cls ) : [EOL] [docstring] [EOL] return [ e . value for e in RadioType ] [EOL] [EOL] [EOL] DISCOVERY_KEY = [string] [EOL] [EOL] REPORT_CONFIG_MAX_INT = [number] [EOL] REPORT_CONFIG_MAX_INT_BATTERY_SAVE = [number] [EOL] REPORT_CONFIG_MIN_INT = [number] [EOL] REPORT_CONFIG_MIN_INT_ASAP = [number] [EOL] REPORT_CONFIG_MIN_INT_IMMEDIATE = [number] [EOL] REPORT_CONFIG_MIN_INT_OP = [number] [EOL] REPORT_CONFIG_MIN_INT_BATTERY_SAVE = [number] [EOL] REPORT_CONFIG_RPT_CHANGE = [number] [EOL] REPORT_CONFIG_DEFAULT = ( REPORT_CONFIG_MIN_INT , REPORT_CONFIG_MAX_INT , REPORT_CONFIG_RPT_CHANGE ) [EOL] REPORT_CONFIG_ASAP = ( REPORT_CONFIG_MIN_INT_ASAP , REPORT_CONFIG_MAX_INT , REPORT_CONFIG_RPT_CHANGE ) [EOL] REPORT_CONFIG_BATTERY_SAVE = ( REPORT_CONFIG_MIN_INT_BATTERY_SAVE , REPORT_CONFIG_MAX_INT_BATTERY_SAVE , REPORT_CONFIG_RPT_CHANGE ) [EOL] REPORT_CONFIG_IMMEDIATE = ( REPORT_CONFIG_MIN_INT_IMMEDIATE , REPORT_CONFIG_MAX_INT , REPORT_CONFIG_RPT_CHANGE ) [EOL] REPORT_CONFIG_OP = ( REPORT_CONFIG_MIN_INT_OP , REPORT_CONFIG_MAX_INT , REPORT_CONFIG_RPT_CHANGE ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] CONF_AUTHORIZATION = [string] [EOL] CONF_CIRCLES = [string] [EOL] CONF_DRIVING_SPEED = [string] [EOL] CONF_ERROR_THRESHOLD = [string] [EOL] CONF_MAX_GPS_ACCURACY = [string] [EOL] CONF_MAX_UPDATE_WAIT = [string] [EOL] CONF_MEMBERS = [string] [EOL] CONF_SHOW_AS_STATE = [string] [EOL] CONF_WARNING_THRESHOLD = [string] [EOL] [EOL] SHOW_DRIVING = [string] [EOL] SHOW_MOVING = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from life360 import Life360 [EOL] [EOL] [EOL] def get_api ( authorization = None ) : [EOL] [docstring] [EOL] return Life360 ( timeout = [number] , max_retries = [number] , authorization = authorization ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] DATA_CAMERA_PREFS = [string] [EOL] [EOL] PREF_PRELOAD_STREAM = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_LATITUDE , CONF_LONGITUDE , CONF_NAME , SUN_EVENT_SUNSET ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . sun import get_astral_event_date [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] CONF_DIASPORA = [string] [EOL] CONF_LANGUAGE = [string] [EOL] CONF_SENSORS = [string] [EOL] CONF_CANDLE_LIGHT_MINUTES = [string] [EOL] CONF_HAVDALAH_OFFSET_MINUTES = [string] [EOL] [EOL] CANDLE_LIGHT_DEFAULT = [number] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_DIASPORA , default = False ) : cv . boolean , vol . Optional ( CONF_LATITUDE ) : cv . latitude , vol . Optional ( CONF_LONGITUDE ) : cv . longitude , vol . Optional ( CONF_LANGUAGE , default = [string] ) : vol . In ( [ [string] , [string] ] ) , vol . Optional ( CONF_CANDLE_LIGHT_MINUTES , default = CANDLE_LIGHT_DEFAULT ) : int , vol . Optional ( CONF_HAVDALAH_OFFSET_MINUTES , default = [number] ) : int , vol . Optional ( CONF_SENSORS , default = [ [string] ] ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) , [ vol . In ( SENSOR_TYPES ) ] ) , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] language = config . get ( CONF_LANGUAGE ) [EOL] name = config . get ( CONF_NAME ) [EOL] latitude = config . get ( CONF_LATITUDE , hass . config . latitude ) [EOL] longitude = config . get ( CONF_LONGITUDE , hass . config . longitude ) [EOL] diaspora = config . get ( CONF_DIASPORA ) [EOL] candle_lighting_offset = config . get ( CONF_CANDLE_LIGHT_MINUTES ) [EOL] havdalah_offset = config . get ( CONF_HAVDALAH_OFFSET_MINUTES ) [EOL] [EOL] if None in ( latitude , longitude ) : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] dev = [ ] [EOL] for sensor_type in config [ CONF_SENSORS ] : [EOL] dev . append ( JewishCalSensor ( name , language , sensor_type , latitude , longitude , hass . config . time_zone , diaspora , candle_lighting_offset , havdalah_offset ) ) [EOL] async_add_entities ( dev , True ) [EOL] [EOL] [EOL] class JewishCalSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , language , sensor_type , latitude , longitude , timezone , diaspora , candle_lighting_offset = CANDLE_LIGHT_DEFAULT , havdalah_offset = [number] ) : [EOL] [docstring] [EOL] self . client_name = name [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . type = sensor_type [EOL] self . _hebrew = ( language == [string] ) [EOL] self . _state = None [EOL] self . latitude = latitude [EOL] self . longitude = longitude [EOL] self . timezone = timezone [EOL] self . diaspora = diaspora [EOL] self . candle_lighting_offset = candle_lighting_offset [EOL] self . havdalah_offset = havdalah_offset [EOL] _LOGGER . debug ( [string] , self . type ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES [ self . type ] [ [number] ] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] import hdate [EOL] [EOL] now = dt_util . as_local ( dt_util . now ( ) ) [EOL] _LOGGER . debug ( [string] , now , now . tzinfo ) [EOL] [EOL] today = now . date ( ) [EOL] sunset = dt_util . as_local ( get_astral_event_date ( self . hass , SUN_EVENT_SUNSET , today ) ) [EOL] [EOL] _LOGGER . debug ( [string] , now , sunset ) [EOL] [EOL] location = hdate . Location ( latitude = self . latitude , longitude = self . longitude , timezone = self . timezone , diaspora = self . diaspora ) [EOL] [EOL] def make_zmanim ( date ) : [EOL] [docstring] [EOL] return hdate . Zmanim ( date = date , location = location , candle_lighting_offset = self . candle_lighting_offset , havdalah_offset = self . havdalah_offset , hebrew = self . _hebrew ) [EOL] [EOL] date = hdate . HDate ( today , diaspora = self . diaspora , hebrew = self . _hebrew ) [EOL] lagging_date = date [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if now > sunset : [EOL] date = date . next_day [EOL] today_times = make_zmanim ( today ) [EOL] if today_times . havdalah and now > today_times . havdalah : [EOL] lagging_date = lagging_date . next_day [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . type == [string] : [EOL] self . _state = date . hebrew_date [EOL] elif self . type == [string] : [EOL] [comment] [EOL] self . _state = lagging_date . upcoming_shabbat . parasha [EOL] elif self . type == [string] : [EOL] self . _state = date . holiday_description [EOL] elif self . type == [string] : [EOL] self . _state = date . holiday_type [EOL] elif self . type == [string] : [EOL] times = make_zmanim ( lagging_date . upcoming_shabbat . previous_day . gdate ) [EOL] self . _state = times . candle_lighting [EOL] elif self . type == [string] : [EOL] times = make_zmanim ( lagging_date . upcoming_shabbat_or_yom_tov . first_day . previous_day . gdate ) [EOL] self . _state = times . candle_lighting [EOL] elif self . type == [string] : [EOL] times = make_zmanim ( lagging_date . upcoming_shabbat . gdate ) [EOL] self . _state = times . havdalah [EOL] elif self . type == [string] : [EOL] times = make_zmanim ( lagging_date . upcoming_shabbat_or_yom_tov . last_day . gdate ) [EOL] self . _state = times . havdalah [EOL] elif self . type == [string] : [EOL] self . _state = make_zmanim ( now ) . issur_melacha_in_effect [EOL] else : [EOL] times = make_zmanim ( today ) . zmanim [EOL] self . _state = times [ self . type ] . time ( ) [EOL] [EOL] _LOGGER . debug ( [string] , self . _state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import hashlib [EOL] import datetime [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . asterisk_mbox import SIGNAL_CDR_UPDATE [EOL] from homeassistant . components . asterisk_mbox import DOMAIN as ASTERISK_DOMAIN [EOL] from homeassistant . components . mailbox import Mailbox [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] MAILBOX_NAME = [string] [EOL] [EOL] [EOL] async def async_get_handler ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] return AsteriskCDR ( hass , MAILBOX_NAME ) [EOL] [EOL] [EOL] class AsteriskCDR ( Mailbox ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( hass , name ) [EOL] self . cdr = [ ] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_CDR_UPDATE , self . _update_callback ) [EOL] [EOL] @ callback def _update_callback ( self , msg ) : [EOL] [docstring] [EOL] self . _build_message ( ) [EOL] self . async_update ( ) [EOL] [EOL] def _build_message ( self ) : [EOL] [docstring] [EOL] cdr = [ ] [EOL] for entry in self . hass . data [ ASTERISK_DOMAIN ] . cdr : [EOL] timestamp = datetime . datetime . strptime ( entry [ [string] ] , [string] ) . timestamp ( ) [EOL] info = { [string] : timestamp , [string] : entry [ [string] ] , [string] : entry [ [string] ] , } [EOL] sha = hashlib . sha256 ( str ( entry ) . encode ( [string] ) ) . hexdigest ( ) [EOL] msg = [string] . format ( entry [ [string] ] , entry [ [string] ] , entry [ [string] ] ) [EOL] cdr . append ( { [string] : info , [string] : sha , [string] : msg } ) [EOL] self . cdr = cdr [EOL] [EOL] async def async_get_messages ( self ) : [EOL] [docstring] [EOL] if not self . cdr : [EOL] self . _build_message ( ) [EOL] return self . cdr [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] from base64 import b64decode , b64encode [EOL] import logging [EOL] import socket [EOL] [EOL] from datetime import timedelta [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_HOST [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util . dt import utcnow [EOL] [EOL] from . const import CONF_PACKET , DOMAIN , SERVICE_LEARN , SERVICE_SEND [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_RETRY = [number] [EOL] [EOL] [EOL] def data_packet ( value ) : [EOL] [docstring] [EOL] value = cv . string ( value ) [EOL] extra = len ( value ) % [number] [EOL] if extra > [number] : [EOL] value = value + ( [string] * ( [number] - extra ) ) [EOL] return b64decode ( value ) [EOL] [EOL] [EOL] SERVICE_SEND_SCHEMA = vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_PACKET ) : vol . All ( cv . ensure_list , [ data_packet ] ) } ) [EOL] [EOL] SERVICE_LEARN_SCHEMA = vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , } ) [EOL] [EOL] [EOL] def async_setup_service ( hass , host , device ) : [EOL] [docstring] [EOL] hass . data . setdefault ( DOMAIN , { } ) [ host ] = device [EOL] [EOL] if not hass . services . has_service ( DOMAIN , SERVICE_LEARN ) : [EOL] [EOL] async def _learn_command ( call ) : [EOL] [docstring] [EOL] device = hass . data [ DOMAIN ] [ call . data [ CONF_HOST ] ] [EOL] [EOL] try : [EOL] auth = await hass . async_add_executor_job ( device . auth ) [EOL] except socket . timeout : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] if not auth : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] await hass . async_add_executor_job ( device . enter_learning ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] start_time = utcnow ( ) [EOL] while ( utcnow ( ) - start_time ) < timedelta ( seconds = [number] ) : [EOL] packet = await hass . async_add_executor_job ( device . check_data ) [EOL] if packet : [EOL] data = b64encode ( packet ) . decode ( [string] ) [EOL] log_msg = [string] . format ( data ) [EOL] _LOGGER . info ( log_msg ) [EOL] hass . components . persistent_notification . async_create ( log_msg , title = [string] ) [EOL] return [EOL] await asyncio . sleep ( [number] ) [EOL] _LOGGER . error ( [string] ) [EOL] hass . components . persistent_notification . async_create ( [string] , title = [string] ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_LEARN , _learn_command , schema = SERVICE_LEARN_SCHEMA ) [EOL] [EOL] if not hass . services . has_service ( DOMAIN , SERVICE_SEND ) : [EOL] [EOL] async def _send_packet ( call ) : [EOL] [docstring] [EOL] device = hass . data [ DOMAIN ] [ call . data [ CONF_HOST ] ] [EOL] packets = call . data [ CONF_PACKET ] [EOL] for packet in packets : [EOL] for retry in range ( DEFAULT_RETRY ) : [EOL] try : [EOL] await hass . async_add_executor_job ( device . send_data , packet ) [EOL] break [EOL] except ( socket . timeout , ValueError ) : [EOL] try : [EOL] await hass . async_add_executor_job ( device . auth ) [EOL] except socket . timeout : [EOL] if retry == DEFAULT_RETRY - [number] : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_SEND , _send_packet , schema = SERVICE_SEND_SCHEMA ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[docstring] [EOL] CONF_PACKET = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] SERVICE_LEARN = [string] [EOL] SERVICE_SEND = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] import binascii [EOL] from datetime import timedelta [EOL] import logging [EOL] import socket [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( ENTITY_ID_FORMAT , PLATFORM_SCHEMA , SwitchDevice ) [EOL] from homeassistant . const import ( CONF_COMMAND_OFF , CONF_COMMAND_ON , CONF_FRIENDLY_NAME , CONF_HOST , CONF_MAC , CONF_SWITCHES , CONF_TIMEOUT , CONF_TYPE , STATE_ON ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle , slugify [EOL] from homeassistant . helpers . restore_state import RestoreEntity [EOL] [EOL] from . import async_setup_service , data_packet [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_TIMEOUT = [number] [EOL] CONF_SLOTS = [string] [EOL] [EOL] RM_TYPES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] SP1_TYPES = [ [string] ] [EOL] SP2_TYPES = [ [string] , [string] , [string] , [string] , [string] ] [EOL] MP1_TYPES = [ [string] ] [EOL] [EOL] SWITCH_TYPES = RM_TYPES + SP1_TYPES + SP2_TYPES + MP1_TYPES [EOL] [EOL] SWITCH_SCHEMA = vol . Schema ( { vol . Optional ( CONF_COMMAND_OFF ) : data_packet , vol . Optional ( CONF_COMMAND_ON ) : data_packet , vol . Optional ( CONF_FRIENDLY_NAME ) : cv . string , } ) [EOL] [EOL] MP1_SWITCH_SLOT_SCHEMA = vol . Schema ( { vol . Optional ( [string] ) : cv . string , vol . Optional ( [string] ) : cv . string , vol . Optional ( [string] ) : cv . string , vol . Optional ( [string] ) : cv . string } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_SWITCHES , default = { } ) : cv . schema_with_slug_keys ( SWITCH_SCHEMA ) , vol . Optional ( CONF_SLOTS , default = { } ) : MP1_SWITCH_SLOT_SCHEMA , vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_MAC ) : cv . string , vol . Optional ( CONF_FRIENDLY_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_TYPE , default = SWITCH_TYPES [ [number] ] ) : vol . In ( SWITCH_TYPES ) , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import broadlink [EOL] devices = config . get ( CONF_SWITCHES ) [EOL] slots = config . get ( [string] , { } ) [EOL] ip_addr = config . get ( CONF_HOST ) [EOL] friendly_name = config . get ( CONF_FRIENDLY_NAME ) [EOL] mac_addr = binascii . unhexlify ( config . get ( CONF_MAC ) . encode ( ) . replace ( [string] , [string] ) ) [EOL] switch_type = config . get ( CONF_TYPE ) [EOL] [EOL] def _get_mp1_slot_name ( switch_friendly_name , slot ) : [EOL] [docstring] [EOL] if not slots [ [string] . format ( slot ) ] : [EOL] return [string] . format ( switch_friendly_name , slot ) [EOL] return slots [ [string] . format ( slot ) ] [EOL] [EOL] if switch_type in RM_TYPES : [EOL] broadlink_device = broadlink . rm ( ( ip_addr , [number] ) , mac_addr , None ) [EOL] hass . add_job ( async_setup_service , hass , ip_addr , broadlink_device ) [EOL] [EOL] switches = [ ] [EOL] for object_id , device_config in devices . items ( ) : [EOL] switches . append ( BroadlinkRMSwitch ( object_id , device_config . get ( CONF_FRIENDLY_NAME , object_id ) , broadlink_device , device_config . get ( CONF_COMMAND_ON ) , device_config . get ( CONF_COMMAND_OFF ) ) ) [EOL] elif switch_type in SP1_TYPES : [EOL] broadlink_device = broadlink . sp1 ( ( ip_addr , [number] ) , mac_addr , None ) [EOL] switches = [ BroadlinkSP1Switch ( friendly_name , broadlink_device ) ] [EOL] elif switch_type in SP2_TYPES : [EOL] broadlink_device = broadlink . sp2 ( ( ip_addr , [number] ) , mac_addr , None ) [EOL] switches = [ BroadlinkSP2Switch ( friendly_name , broadlink_device ) ] [EOL] elif switch_type in MP1_TYPES : [EOL] switches = [ ] [EOL] broadlink_device = broadlink . mp1 ( ( ip_addr , [number] ) , mac_addr , None ) [EOL] parent_device = BroadlinkMP1Switch ( broadlink_device ) [EOL] for i in range ( [number] , [number] ) : [EOL] slot = BroadlinkMP1Slot ( _get_mp1_slot_name ( friendly_name , i ) , broadlink_device , i , parent_device ) [EOL] switches . append ( slot ) [EOL] [EOL] broadlink_device . timeout = config . get ( CONF_TIMEOUT ) [EOL] try : [EOL] broadlink_device . auth ( ) [EOL] except OSError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] add_entities ( switches ) [EOL] [EOL] [EOL] class BroadlinkRMSwitch ( SwitchDevice , RestoreEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , friendly_name , device , command_on , command_off ) : [EOL] [docstring] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( slugify ( name ) ) [EOL] self . _name = friendly_name [EOL] self . _state = False [EOL] self . _command_on = command_on [EOL] self . _command_off = command_off [EOL] self . _device = device [EOL] self . _is_available = False [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] await super ( ) . async_added_to_hass ( ) [EOL] state = await self . async_get_last_state ( ) [EOL] if state : [EOL] self . _state = state . state == STATE_ON [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return not self . should_poll or self . _is_available [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _sendpacket ( self . _command_on ) : [EOL] self . _state = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _sendpacket ( self . _command_off ) : [EOL] self . _state = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _sendpacket ( self , packet , retry = [number] ) : [EOL] [docstring] [EOL] if packet is None : [EOL] _LOGGER . debug ( [string] ) [EOL] return True [EOL] try : [EOL] self . _device . send_data ( packet ) [EOL] except ( ValueError , OSError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( [string] , error ) [EOL] return False [EOL] if not self . _auth ( ) : [EOL] return False [EOL] return self . _sendpacket ( packet , retry - [number] ) [EOL] return True [EOL] [EOL] def _auth ( self , retry = [number] ) : [EOL] try : [EOL] auth = self . _device . auth ( ) [EOL] except OSError : [EOL] auth = False [EOL] if retry < [number] : [EOL] _LOGGER . error ( [string] ) [EOL] if not auth and retry > [number] : [EOL] return self . _auth ( retry - [number] ) [EOL] return auth [EOL] [EOL] [EOL] class BroadlinkSP1Switch ( BroadlinkRMSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , friendly_name , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( friendly_name , friendly_name , device , None , None ) [EOL] self . _command_on = [number] [EOL] self . _command_off = [number] [EOL] self . _load_power = None [EOL] [EOL] def _sendpacket ( self , packet , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] self . _device . set_power ( packet ) [EOL] except ( socket . timeout , ValueError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( [string] , error ) [EOL] return False [EOL] if not self . _auth ( ) : [EOL] return False [EOL] return self . _sendpacket ( packet , retry - [number] ) [EOL] return True [EOL] [EOL] [EOL] class BroadlinkSP2Switch ( BroadlinkSP1Switch ) : [EOL] [docstring] [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def current_power_w ( self ) : [EOL] [docstring] [EOL] try : [EOL] return round ( self . _load_power , [number] ) [EOL] except ( ValueError , TypeError ) : [EOL] return None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _update ( ) [EOL] [EOL] def _update ( self , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] state = self . _device . check_power ( ) [EOL] load_power = self . _device . get_energy ( ) [EOL] except ( socket . timeout , ValueError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( [string] , error ) [EOL] self . _is_available = False [EOL] return [EOL] if not self . _auth ( ) : [EOL] return [EOL] return self . _update ( retry - [number] ) [EOL] if state is None and retry > [number] : [EOL] return self . _update ( retry - [number] ) [EOL] self . _state = state [EOL] self . _load_power = load_power [EOL] self . _is_available = True [EOL] [EOL] [EOL] class BroadlinkMP1Slot ( BroadlinkRMSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , friendly_name , device , slot , parent_device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( friendly_name , friendly_name , device , None , None ) [EOL] self . _command_on = [number] [EOL] self . _command_off = [number] [EOL] self . _slot = slot [EOL] self . _parent_device = parent_device [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] def _sendpacket ( self , packet , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] self . _device . set_power ( self . _slot , packet ) [EOL] except ( socket . timeout , ValueError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( [string] , error ) [EOL] self . _is_available = False [EOL] return False [EOL] if not self . _auth ( ) : [EOL] return False [EOL] return self . _sendpacket ( packet , max ( [number] , retry - [number] ) ) [EOL] self . _is_available = True [EOL] return True [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _parent_device . update ( ) [EOL] self . _state = self . _parent_device . get_outlet_status ( self . _slot ) [EOL] [EOL] [EOL] class BroadlinkMP1Switch : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] self . _device = device [EOL] self . _states = None [EOL] [EOL] def get_outlet_status ( self , slot ) : [EOL] [docstring] [EOL] if self . _states is None : [EOL] return None [EOL] return self . _states [ [string] . format ( slot ) ] [EOL] [EOL] @ Throttle ( TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . _update ( ) [EOL] [EOL] def _update ( self , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] states = self . _device . check_power ( ) [EOL] except ( socket . timeout , ValueError ) as error : [EOL] if retry < [number] : [EOL] _LOGGER . error ( [string] , error ) [EOL] return [EOL] if not self . _auth ( ) : [EOL] return [EOL] return self . _update ( max ( [number] , retry - [number] ) ) [EOL] if states is None and retry > [number] : [EOL] return self . _update ( max ( [number] , retry - [number] ) ) [EOL] self . _states = states [EOL] [EOL] def _auth ( self , retry = [number] ) : [EOL] [docstring] [EOL] try : [EOL] auth = self . _device . auth ( ) [EOL] except OSError : [EOL] auth = False [EOL] if not auth and retry > [number] : [EOL] return self . _auth ( retry - [number] ) [EOL] return auth [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[docstring] [EOL]	0 0
[docstring] [EOL] CONF_BROKER = [string] [EOL] CONF_DISCOVERY = [string] [EOL] DEFAULT_DISCOVERY = False [EOL] [EOL] ATTR_DISCOVERY_HASH = [string] [EOL] CONF_STATE_TOPIC = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import random [EOL] import socket [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_HS_COLOR , ATTR_TRANSITION , ATTR_EFFECT , EFFECT_RANDOM , PLATFORM_SCHEMA , SUPPORT_BRIGHTNESS , SUPPORT_COLOR , SUPPORT_COLOR_TEMP , SUPPORT_EFFECT , SUPPORT_TRANSITION , Light ) [EOL] [EOL] from homeassistant . const import CONF_HOST [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . color as color_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ALLOW_LIGHTIFY_NODES = [string] [EOL] CONF_ALLOW_LIGHTIFY_GROUPS = [string] [EOL] CONF_ALLOW_LIGHTIFY_SENSORS = [string] [EOL] CONF_ALLOW_LIGHTIFY_SWITCHES = [string] [EOL] CONF_INTERVAL_LIGHTIFY_STATUS = [string] [EOL] CONF_INTERVAL_LIGHTIFY_CONF = [string] [EOL] [EOL] DEFAULT_ALLOW_LIGHTIFY_NODES = True [EOL] DEFAULT_ALLOW_LIGHTIFY_GROUPS = True [EOL] DEFAULT_ALLOW_LIGHTIFY_SENSORS = True [EOL] DEFAULT_ALLOW_LIGHTIFY_SWITCHES = True [EOL] DEFAULT_INTERVAL_LIGHTIFY_STATUS = [number] [EOL] DEFAULT_INTERVAL_LIGHTIFY_CONF = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_ALLOW_LIGHTIFY_NODES , default = DEFAULT_ALLOW_LIGHTIFY_NODES ) : cv . boolean , vol . Optional ( CONF_ALLOW_LIGHTIFY_GROUPS , default = DEFAULT_ALLOW_LIGHTIFY_GROUPS ) : cv . boolean , vol . Optional ( CONF_ALLOW_LIGHTIFY_SENSORS , default = DEFAULT_ALLOW_LIGHTIFY_SENSORS ) : cv . boolean , vol . Optional ( CONF_ALLOW_LIGHTIFY_SWITCHES , default = DEFAULT_ALLOW_LIGHTIFY_SWITCHES ) : cv . boolean , vol . Optional ( CONF_INTERVAL_LIGHTIFY_STATUS , default = DEFAULT_INTERVAL_LIGHTIFY_STATUS ) : cv . positive_int , vol . Optional ( CONF_INTERVAL_LIGHTIFY_CONF , default = DEFAULT_INTERVAL_LIGHTIFY_CONF ) : cv . positive_int } ) [EOL] [EOL] DEFAULT_BRIGHTNESS = [number] [EOL] DEFAULT_KELVIN = [number] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import lightify [EOL] [EOL] host = config [ CONF_HOST ] [EOL] try : [EOL] bridge = lightify . Lightify ( host , log_level = logging . NOTSET ) [EOL] except socket . error as err : [EOL] msg = [string] . format ( host , str ( err ) ) [EOL] _LOGGER . exception ( msg ) [EOL] return [EOL] [EOL] setup_bridge ( bridge , add_entities , config ) [EOL] [EOL] [EOL] def setup_bridge ( bridge , add_entities , config ) : [EOL] [docstring] [EOL] lights = { } [EOL] groups = { } [EOL] groups_last_updated = [ [number] ] [EOL] [EOL] def update_lights ( ) : [EOL] [docstring] [EOL] try : [EOL] new_lights = bridge . update_all_light_status ( config [ CONF_INTERVAL_LIGHTIFY_STATUS ] ) [EOL] lights_changed = bridge . lights_changed ( ) [EOL] except TimeoutError : [EOL] _LOGGER . error ( [string] ) [EOL] return [number] [EOL] except OSError : [EOL] _LOGGER . error ( [string] ) [EOL] return [number] [EOL] [EOL] if new_lights and config [ CONF_ALLOW_LIGHTIFY_NODES ] : [EOL] new_entities = [ ] [EOL] for addr , light in new_lights . items ( ) : [EOL] if ( ( light . devicetype ( ) . name == [string] [EOL] and not config [ CONF_ALLOW_LIGHTIFY_SENSORS ] ) or ( light . devicetype ( ) . name == [string] [EOL] and not config [ CONF_ALLOW_LIGHTIFY_SWITCHES ] ) ) : [EOL] continue [EOL] [EOL] if addr not in lights : [EOL] osram_light = OsramLightifyLight ( light , update_lights , lights_changed ) [EOL] lights [ addr ] = osram_light [EOL] new_entities . append ( osram_light ) [EOL] else : [EOL] lights [ addr ] . update_luminary ( light ) [EOL] [EOL] add_entities ( new_entities ) [EOL] [EOL] return lights_changed [EOL] [EOL] def update_groups ( ) : [EOL] [docstring] [EOL] lights_changed = update_lights ( ) [EOL] [EOL] try : [EOL] bridge . update_scene_list ( config [ CONF_INTERVAL_LIGHTIFY_CONF ] ) [EOL] new_groups = bridge . update_group_list ( config [ CONF_INTERVAL_LIGHTIFY_CONF ] ) [EOL] groups_updated = bridge . groups_updated ( ) [EOL] except TimeoutError : [EOL] _LOGGER . error ( [string] ) [EOL] return [number] [EOL] except OSError : [EOL] _LOGGER . error ( [string] ) [EOL] return [number] [EOL] [EOL] if new_groups : [EOL] new_groups = { group . idx ( ) : group for group in new_groups . values ( ) } [EOL] new_entities = [ ] [EOL] for idx , group in new_groups . items ( ) : [EOL] if idx not in groups : [EOL] osram_group = OsramLightifyGroup ( group , update_groups , groups_updated ) [EOL] groups [ idx ] = osram_group [EOL] new_entities . append ( osram_group ) [EOL] else : [EOL] groups [ idx ] . update_luminary ( group ) [EOL] [EOL] add_entities ( new_entities ) [EOL] [EOL] if groups_updated > groups_last_updated [ [number] ] : [EOL] groups_last_updated [ [number] ] = groups_updated [EOL] for idx , osram_group in groups . items ( ) : [EOL] if idx not in new_groups : [EOL] osram_group . update_static_attributes ( ) [EOL] [EOL] return max ( lights_changed , groups_updated ) [EOL] [EOL] update_lights ( ) [EOL] if config [ CONF_ALLOW_LIGHTIFY_GROUPS ] : [EOL] update_groups ( ) [EOL] [EOL] [EOL] class Luminary ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , luminary , update_func , changed ) : [EOL] [docstring] [EOL] self . update_func = update_func [EOL] self . _luminary = luminary [EOL] self . _changed = changed [EOL] [EOL] self . _unique_id = None [EOL] self . _supported_features = [ ] [EOL] self . _effect_list = [ ] [EOL] self . _is_on = False [EOL] self . _available = True [EOL] self . _min_mireds = None [EOL] self . _max_mireds = None [EOL] self . _brightness = None [EOL] self . _color_temp = None [EOL] self . _rgb_color = None [EOL] self . _device_attributes = None [EOL] [EOL] self . update_static_attributes ( ) [EOL] self . update_dynamic_attributes ( ) [EOL] [EOL] def _get_unique_id ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] def _get_supported_features ( self ) : [EOL] [docstring] [EOL] features = [number] [EOL] if [string] in self . _luminary . supported_features ( ) : [EOL] features = features | SUPPORT_BRIGHTNESS | SUPPORT_TRANSITION [EOL] [EOL] if [string] in self . _luminary . supported_features ( ) : [EOL] features = features | SUPPORT_COLOR_TEMP | SUPPORT_TRANSITION [EOL] [EOL] if [string] in self . _luminary . supported_features ( ) : [EOL] features = ( features | SUPPORT_COLOR | SUPPORT_TRANSITION | SUPPORT_EFFECT ) [EOL] [EOL] return features [EOL] [EOL] def _get_effect_list ( self ) : [EOL] [docstring] [EOL] effects = [ ] [EOL] if [string] in self . _luminary . supported_features ( ) : [EOL] effects . append ( EFFECT_RANDOM ) [EOL] [EOL] return effects [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _luminary . name ( ) [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return color_util . color_RGB_to_hs ( * self . _rgb_color ) [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] return self . _color_temp [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _is_on [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported_features [EOL] [EOL] @ property def effect_list ( self ) : [EOL] [docstring] [EOL] return self . _effect_list [EOL] [EOL] @ property def min_mireds ( self ) : [EOL] [docstring] [EOL] return self . _min_mireds [EOL] [EOL] @ property def max_mireds ( self ) : [EOL] [docstring] [EOL] return self . _max_mireds [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _unique_id [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _device_attributes [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] def play_effect ( self , effect , transition ) : [EOL] [docstring] [EOL] if effect == EFFECT_RANDOM : [EOL] self . _rgb_color = ( random . randrange ( [number] , [number] ) , random . randrange ( [number] , [number] ) , random . randrange ( [number] , [number] ) ) [EOL] self . _luminary . set_rgb ( * self . _rgb_color , transition ) [EOL] self . _luminary . set_onoff ( True ) [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] transition = int ( kwargs . get ( ATTR_TRANSITION , [number] ) * [number] ) [EOL] if ATTR_EFFECT in kwargs : [EOL] self . play_effect ( kwargs [ ATTR_EFFECT ] , transition ) [EOL] return [EOL] [EOL] if ATTR_HS_COLOR in kwargs : [EOL] self . _rgb_color = color_util . color_hs_to_RGB ( * kwargs [ ATTR_HS_COLOR ] ) [EOL] self . _luminary . set_rgb ( * self . _rgb_color , transition ) [EOL] [EOL] if ATTR_COLOR_TEMP in kwargs : [EOL] self . _color_temp = kwargs [ ATTR_COLOR_TEMP ] [EOL] self . _luminary . set_temperature ( int ( color_util . color_temperature_mired_to_kelvin ( self . _color_temp ) ) , transition ) [EOL] [EOL] self . _is_on = True [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] self . _luminary . set_luminance ( int ( self . _brightness / [number] ) , transition ) [EOL] else : [EOL] self . _luminary . set_onoff ( True ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _is_on = False [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition = int ( kwargs [ ATTR_TRANSITION ] * [number] ) [EOL] self . _brightness = DEFAULT_BRIGHTNESS [EOL] self . _luminary . set_luminance ( [number] , transition ) [EOL] else : [EOL] self . _luminary . set_onoff ( False ) [EOL] [EOL] def update_luminary ( self , luminary ) : [EOL] [docstring] [EOL] self . _luminary = luminary [EOL] self . update_static_attributes ( ) [EOL] [EOL] def update_static_attributes ( self ) : [EOL] [docstring] [EOL] self . _unique_id = self . _get_unique_id ( ) [EOL] self . _supported_features = self . _get_supported_features ( ) [EOL] self . _effect_list = self . _get_effect_list ( ) [EOL] if self . _supported_features & SUPPORT_COLOR_TEMP : [EOL] self . _min_mireds = color_util . color_temperature_kelvin_to_mired ( self . _luminary . max_temp ( ) or DEFAULT_KELVIN ) [EOL] self . _max_mireds = color_util . color_temperature_kelvin_to_mired ( self . _luminary . min_temp ( ) or DEFAULT_KELVIN ) [EOL] [EOL] def update_dynamic_attributes ( self ) : [EOL] [docstring] [EOL] self . _is_on = self . _luminary . on ( ) [EOL] self . _available = ( self . _luminary . reachable ( ) and not self . _luminary . deleted ( ) ) [EOL] if self . _supported_features & SUPPORT_BRIGHTNESS : [EOL] self . _brightness = int ( self . _luminary . lum ( ) * [number] ) [EOL] [EOL] if self . _supported_features & SUPPORT_COLOR_TEMP : [EOL] self . _color_temp = color_util . color_temperature_kelvin_to_mired ( self . _luminary . temp ( ) or DEFAULT_KELVIN ) [EOL] [EOL] if self . _supported_features & SUPPORT_COLOR : [EOL] self . _rgb_color = self . _luminary . rgb ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] changed = self . update_func ( ) [EOL] if changed > self . _changed : [EOL] self . _changed = changed [EOL] self . update_dynamic_attributes ( ) [EOL] [EOL] [EOL] class OsramLightifyLight ( Luminary ) : [EOL] [docstring] [EOL] [EOL] def _get_unique_id ( self ) : [EOL] [docstring] [EOL] return self . _luminary . addr ( ) [EOL] [EOL] def update_static_attributes ( self ) : [EOL] [docstring] [EOL] super ( ) . update_static_attributes ( ) [EOL] attrs = { [string] : [string] . format ( self . _luminary . type_id ( ) , self . _luminary . devicename ( ) ) , [string] : self . _luminary . version ( ) } [EOL] if self . _luminary . devicetype ( ) . name == [string] : [EOL] attrs [ [string] ] = self . _luminary . raw_values ( ) [EOL] [EOL] self . _device_attributes = attrs [EOL] [EOL] [EOL] class OsramLightifyGroup ( Luminary ) : [EOL] [docstring] [EOL] [EOL] def _get_unique_id ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return [string] . format ( self . _luminary . lights ( ) ) [EOL] [EOL] def _get_supported_features ( self ) : [EOL] [docstring] [EOL] features = super ( ) . _get_supported_features ( ) [EOL] if self . _luminary . scenes ( ) : [EOL] features = features | SUPPORT_EFFECT [EOL] [EOL] return features [EOL] [EOL] def _get_effect_list ( self ) : [EOL] [docstring] [EOL] effects = super ( ) . _get_effect_list ( ) [EOL] effects . extend ( self . _luminary . scenes ( ) ) [EOL] return sorted ( effects ) [EOL] [EOL] def play_effect ( self , effect , transition ) : [EOL] [docstring] [EOL] if super ( ) . play_effect ( effect , transition ) : [EOL] return True [EOL] [EOL] if effect in self . _luminary . scenes ( ) : [EOL] self . _luminary . activate_scene ( effect ) [EOL] return True [EOL] [EOL] return False [EOL] [EOL] def update_static_attributes ( self ) : [EOL] [docstring] [EOL] super ( ) . update_static_attributes ( ) [EOL] self . _device_attributes = { [string] : self . _luminary . light_names ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from subprocess import check_output , CalledProcessError , STDOUT [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_ID , CONF_DEVICES ) [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light , PLATFORM_SCHEMA ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_X10 = SUPPORT_BRIGHTNESS [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICES ) : vol . All ( cv . ensure_list , [ { vol . Required ( CONF_ID ) : cv . string , vol . Required ( CONF_NAME ) : cv . string , } ] ) , } ) [EOL] [EOL] [EOL] def x10_command ( command ) : [EOL] [docstring] [EOL] return check_output ( [ [string] ] + command . split ( [string] ) , stderr = STDOUT ) [EOL] [EOL] [EOL] def get_unit_status ( code ) : [EOL] [docstring] [EOL] output = check_output ( [string] + code , shell = True ) [EOL] return int ( output . decode ( [string] ) [ [number] ] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] is_cm11a = True [EOL] try : [EOL] x10_command ( [string] ) [EOL] except CalledProcessError as err : [EOL] _LOGGER . info ( [string] , err . output ) [EOL] is_cm11a = False [EOL] [EOL] add_entities ( X10Light ( light , is_cm11a ) for light in config [ CONF_DEVICES ] ) [EOL] [EOL] [EOL] class X10Light ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , light , is_cm11a ) : [EOL] [docstring] [EOL] self . _name = light [ [string] ] [EOL] self . _id = light [ [string] ] [EOL] self . _brightness = [number] [EOL] self . _state = False [EOL] self . _is_cm11a = is_cm11a [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_X10 [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _is_cm11a : [EOL] x10_command ( [string] + self . _id ) [EOL] else : [EOL] x10_command ( [string] + self . _id ) [EOL] self . _brightness = kwargs . get ( ATTR_BRIGHTNESS , [number] ) [EOL] self . _state = True [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . _is_cm11a : [EOL] x10_command ( [string] + self . _id ) [EOL] else : [EOL] x10_command ( [string] + self . _id ) [EOL] self . _state = False [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . _is_cm11a : [EOL] self . _state = bool ( get_unit_status ( self . _id ) ) [EOL] else : [EOL] [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] [EOL] KNOWN_DEVICES = [string] . format ( DOMAIN ) [EOL] CONTROLLER = [string] . format ( DOMAIN ) [EOL] ENTITY_MAP = [string] . format ( DOMAIN ) [EOL] [EOL] HOMEKIT_DIR = [string] [EOL] PAIRING_FILE = [string] [EOL] [EOL] [comment] [EOL] HOMEKIT_ACCESSORY_DISPATCH = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from homeassistant . helpers . storage import Store [EOL] from homeassistant . core import callback [EOL] [EOL] from . const import DOMAIN [EOL] [EOL] ENTITY_MAP_STORAGE_KEY = [string] . format ( DOMAIN ) [EOL] ENTITY_MAP_STORAGE_VERSION = [number] [EOL] ENTITY_MAP_SAVE_DELAY = [number] [EOL] [EOL] [EOL] class EntityMapStorage : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . store = Store ( hass , ENTITY_MAP_STORAGE_VERSION , ENTITY_MAP_STORAGE_KEY ) [EOL] self . storage_data = { } [EOL] [EOL] async def async_initialize ( self ) : [EOL] [docstring] [EOL] raw_storage = await self . store . async_load ( ) [EOL] if not raw_storage : [EOL] [comment] [EOL] return [EOL] [EOL] self . storage_data = raw_storage . get ( [string] , { } ) [EOL] [EOL] def get_map ( self , homekit_id ) : [EOL] [docstring] [EOL] return self . storage_data . get ( homekit_id ) [EOL] [EOL] def async_create_or_update_map ( self , homekit_id , config_num , accessories ) : [EOL] [docstring] [EOL] data = { [string] : config_num , [string] : accessories , } [EOL] self . storage_data [ homekit_id ] = data [EOL] self . _async_schedule_save ( ) [EOL] return data [EOL] [EOL] def async_delete_map ( self , homekit_id ) : [EOL] [docstring] [EOL] if homekit_id not in self . storage_data : [EOL] return [EOL] [EOL] self . storage_data . pop ( homekit_id ) [EOL] self . _async_schedule_save ( ) [EOL] [EOL] @ callback def _async_schedule_save ( self ) : [EOL] [docstring] [EOL] self . store . async_delay_save ( self . _data_to_save , ENTITY_MAP_SAVE_DELAY ) [EOL] [EOL] @ callback def _data_to_save ( self ) : [EOL] [docstring] [EOL] return { [string] : self . storage_data , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . sensor import ENTITY_ID_FORMAT [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] from homeassistant . helpers . entity import Entity , async_generate_entity_id [EOL] [EOL] from . const import DATA_GATEWAYS , DATA_OPENTHERM_GW , SENSOR_INFO [EOL] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] gw_dev = hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ discovery_info ] [EOL] sensors = [ ] [EOL] for var , info in SENSOR_INFO . items ( ) : [EOL] device_class = info [ [number] ] [EOL] unit = info [ [number] ] [EOL] friendly_name_format = info [ [number] ] [EOL] sensors . append ( OpenThermSensor ( gw_dev , var , device_class , unit , friendly_name_format ) ) [EOL] async_add_entities ( sensors ) [EOL] [EOL] [EOL] class OpenThermSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , gw_dev , var , device_class , unit , friendly_name_format ) : [EOL] [docstring] [EOL] self . entity_id = async_generate_entity_id ( ENTITY_ID_FORMAT , [string] . format ( var , gw_dev . gw_id ) , hass = gw_dev . hass ) [EOL] self . _gateway = gw_dev [EOL] self . _var = var [EOL] self . _value = None [EOL] self . _device_class = device_class [EOL] self . _unit = unit [EOL] self . _friendly_name = friendly_name_format . format ( gw_dev . name ) [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _friendly_name ) [EOL] async_dispatcher_connect ( self . hass , self . _gateway . update_signal , self . receive_report ) [EOL] [EOL] @ callback def receive_report ( self , status ) : [EOL] [docstring] [EOL] value = status . get ( self . _var ) [EOL] if isinstance ( value , float ) : [EOL] value = [string] . format ( value ) [EOL] self . _value = value [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _friendly_name [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _value [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import datetime , date [EOL] [EOL] import pyotgw [EOL] import pyotgw . vars as gw_vars [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import DOMAIN as COMP_BINARY_SENSOR [EOL] from homeassistant . components . climate import DOMAIN as COMP_CLIMATE [EOL] from homeassistant . components . sensor import DOMAIN as COMP_SENSOR [EOL] from homeassistant . const import ( ATTR_DATE , ATTR_ID , ATTR_TEMPERATURE , ATTR_TIME , CONF_DEVICE , CONF_NAME , EVENT_HOMEASSISTANT_STOP , PRECISION_HALVES , PRECISION_TENTHS , PRECISION_WHOLE ) [EOL] from homeassistant . helpers . discovery import async_load_platform [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_send [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] from . const import ( ATTR_GW_ID , ATTR_MODE , ATTR_LEVEL , CONF_CLIMATE , CONF_FLOOR_TEMP , CONF_PRECISION , DATA_GATEWAYS , DATA_OPENTHERM_GW , SERVICE_RESET_GATEWAY , SERVICE_SET_CLOCK , SERVICE_SET_CONTROL_SETPOINT , SERVICE_SET_GPIO_MODE , SERVICE_SET_LED_MODE , SERVICE_SET_MAX_MOD , SERVICE_SET_OAT , SERVICE_SET_SB_TEMP ) [EOL] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] CLIMATE_SCHEMA = vol . Schema ( { vol . Optional ( CONF_PRECISION ) : vol . In ( [ PRECISION_TENTHS , PRECISION_HALVES , PRECISION_WHOLE ] ) , vol . Optional ( CONF_FLOOR_TEMP , default = False ) : cv . boolean , } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : cv . schema_with_slug_keys ( { vol . Required ( CONF_DEVICE ) : cv . string , vol . Optional ( CONF_CLIMATE , default = { } ) : CLIMATE_SCHEMA , vol . Optional ( CONF_NAME ) : cv . string , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config [ DOMAIN ] [EOL] hass . data [ DATA_OPENTHERM_GW ] = { DATA_GATEWAYS : { } } [EOL] for gw_id , cfg in conf . items ( ) : [EOL] gateway = OpenThermGatewayDevice ( hass , gw_id , cfg ) [EOL] hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ gw_id ] = gateway [EOL] hass . async_create_task ( async_load_platform ( hass , COMP_CLIMATE , DOMAIN , gw_id , config ) ) [EOL] hass . async_create_task ( async_load_platform ( hass , COMP_BINARY_SENSOR , DOMAIN , gw_id , config ) ) [EOL] hass . async_create_task ( async_load_platform ( hass , COMP_SENSOR , DOMAIN , gw_id , config ) ) [EOL] [comment] [EOL] hass . loop . create_task ( gateway . connect_and_subscribe ( cfg [ CONF_DEVICE ] ) ) [EOL] register_services ( hass ) [EOL] return True [EOL] [EOL] [EOL] def register_services ( hass ) : [EOL] [docstring] [EOL] service_reset_schema = vol . Schema ( { vol . Required ( ATTR_GW_ID ) : vol . All ( cv . string , vol . In ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] ) ) , } ) [EOL] service_set_clock_schema = vol . Schema ( { vol . Required ( ATTR_GW_ID ) : vol . All ( cv . string , vol . In ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] ) ) , vol . Optional ( ATTR_DATE , default = date . today ( ) ) : cv . date , vol . Optional ( ATTR_TIME , default = datetime . now ( ) . time ( ) ) : cv . time , } ) [EOL] service_set_control_setpoint_schema = vol . Schema ( { vol . Required ( ATTR_GW_ID ) : vol . All ( cv . string , vol . In ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] ) ) , vol . Required ( ATTR_TEMPERATURE ) : vol . All ( vol . Coerce ( float ) , vol . Range ( min = [number] , max = [number] ) ) , } ) [EOL] service_set_gpio_mode_schema = vol . Schema ( vol . Any ( vol . Schema ( { vol . Required ( ATTR_GW_ID ) : vol . All ( cv . string , vol . In ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] ) ) , vol . Required ( ATTR_ID ) : vol . Equal ( [string] ) , vol . Required ( ATTR_MODE ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , } ) , vol . Schema ( { vol . Required ( ATTR_GW_ID ) : vol . All ( cv . string , vol . In ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] ) ) , vol . Required ( ATTR_ID ) : vol . Equal ( [string] ) , vol . Required ( ATTR_MODE ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , } ) , ) ) [EOL] service_set_led_mode_schema = vol . Schema ( { vol . Required ( ATTR_GW_ID ) : vol . All ( cv . string , vol . In ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] ) ) , vol . Required ( ATTR_ID ) : vol . In ( [string] ) , vol . Required ( ATTR_MODE ) : vol . In ( [string] ) , } ) [EOL] service_set_max_mod_schema = vol . Schema ( { vol . Required ( ATTR_GW_ID ) : vol . All ( cv . string , vol . In ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] ) ) , vol . Required ( ATTR_LEVEL ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = - [number] , max = [number] ) ) } ) [EOL] service_set_oat_schema = vol . Schema ( { vol . Required ( ATTR_GW_ID ) : vol . All ( cv . string , vol . In ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] ) ) , vol . Required ( ATTR_TEMPERATURE ) : vol . All ( vol . Coerce ( float ) , vol . Range ( min = - [number] , max = [number] ) ) , } ) [EOL] service_set_sb_temp_schema = vol . Schema ( { vol . Required ( ATTR_GW_ID ) : vol . All ( cv . string , vol . In ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] ) ) , vol . Required ( ATTR_TEMPERATURE ) : vol . All ( vol . Coerce ( float ) , vol . Range ( min = [number] , max = [number] ) ) , } ) [EOL] [EOL] async def reset_gateway ( call ) : [EOL] [docstring] [EOL] gw_dev = ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ call . data [ ATTR_GW_ID ] ] ) [EOL] mode_rst = gw_vars . OTGW_MODE_RESET [EOL] status = await gw_dev . gateway . set_mode ( mode_rst ) [EOL] gw_dev . status = status [EOL] async_dispatcher_send ( hass , gw_dev . update_signal , gw_dev . status ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_RESET_GATEWAY , reset_gateway , service_reset_schema ) [EOL] [EOL] async def set_control_setpoint ( call ) : [EOL] [docstring] [EOL] gw_dev = ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ call . data [ ATTR_GW_ID ] ] ) [EOL] gw_var = gw_vars . DATA_CONTROL_SETPOINT [EOL] value = await gw_dev . gateway . set_control_setpoint ( call . data [ ATTR_TEMPERATURE ] ) [EOL] gw_dev . status . update ( { gw_var : value } ) [EOL] async_dispatcher_send ( hass , gw_dev . update_signal , gw_dev . status ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_CONTROL_SETPOINT , set_control_setpoint , service_set_control_setpoint_schema ) [EOL] [EOL] async def set_device_clock ( call ) : [EOL] [docstring] [EOL] gw_dev = ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ call . data [ ATTR_GW_ID ] ] ) [EOL] attr_date = call . data [ ATTR_DATE ] [EOL] attr_time = call . data [ ATTR_TIME ] [EOL] await gw_dev . gateway . set_clock ( datetime . combine ( attr_date , attr_time ) ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_CLOCK , set_device_clock , service_set_clock_schema ) [EOL] [EOL] async def set_gpio_mode ( call ) : [EOL] [docstring] [EOL] gw_dev = ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ call . data [ ATTR_GW_ID ] ] ) [EOL] gpio_id = call . data [ ATTR_ID ] [EOL] gpio_mode = call . data [ ATTR_MODE ] [EOL] mode = await gw_dev . gateway . set_gpio_mode ( gpio_id , gpio_mode ) [EOL] gpio_var = getattr ( gw_vars , [string] . format ( gpio_id ) ) [EOL] gw_dev . status . update ( { gpio_var : mode } ) [EOL] async_dispatcher_send ( hass , gw_dev . update_signal , gw_dev . status ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_GPIO_MODE , set_gpio_mode , service_set_gpio_mode_schema ) [EOL] [EOL] async def set_led_mode ( call ) : [EOL] [docstring] [EOL] gw_dev = ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ call . data [ ATTR_GW_ID ] ] ) [EOL] led_id = call . data [ ATTR_ID ] [EOL] led_mode = call . data [ ATTR_MODE ] [EOL] mode = await gw_dev . gateway . set_led_mode ( led_id , led_mode ) [EOL] led_var = getattr ( gw_vars , [string] . format ( led_id ) ) [EOL] gw_dev . status . update ( { led_var : mode } ) [EOL] async_dispatcher_send ( hass , gw_dev . update_signal , gw_dev . status ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_LED_MODE , set_led_mode , service_set_led_mode_schema ) [EOL] [EOL] async def set_max_mod ( call ) : [EOL] [docstring] [EOL] gw_dev = ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ call . data [ ATTR_GW_ID ] ] ) [EOL] gw_var = gw_vars . DATA_SLAVE_MAX_RELATIVE_MOD [EOL] level = call . data [ ATTR_LEVEL ] [EOL] if level == - [number] : [EOL] [comment] [EOL] level = [string] [EOL] value = await gw_dev . gateway . set_max_relative_mod ( level ) [EOL] gw_dev . status . update ( { gw_var : value } ) [EOL] async_dispatcher_send ( hass , gw_dev . update_signal , gw_dev . status ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_MAX_MOD , set_max_mod , service_set_max_mod_schema ) [EOL] [EOL] async def set_outside_temp ( call ) : [EOL] [docstring] [EOL] gw_dev = ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ call . data [ ATTR_GW_ID ] ] ) [EOL] gw_var = gw_vars . DATA_OUTSIDE_TEMP [EOL] value = await gw_dev . gateway . set_outside_temp ( call . data [ ATTR_TEMPERATURE ] ) [EOL] gw_dev . status . update ( { gw_var : value } ) [EOL] async_dispatcher_send ( hass , gw_dev . update_signal , gw_dev . status ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_OAT , set_outside_temp , service_set_oat_schema ) [EOL] [EOL] async def set_setback_temp ( call ) : [EOL] [docstring] [EOL] gw_dev = ( hass . data [ DATA_OPENTHERM_GW ] [ DATA_GATEWAYS ] [ call . data [ ATTR_GW_ID ] ] ) [EOL] gw_var = gw_vars . OTGW_SB_TEMP [EOL] value = await gw_dev . gateway . set_setback_temp ( call . data [ ATTR_TEMPERATURE ] ) [EOL] gw_dev . status . update ( { gw_var : value } ) [EOL] async_dispatcher_send ( hass , gw_dev . update_signal , gw_dev . status ) [EOL] hass . services . async_register ( DOMAIN , SERVICE_SET_SB_TEMP , set_setback_temp , service_set_sb_temp_schema ) [EOL] [EOL] [EOL] class OpenThermGatewayDevice ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , gw_id , config ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . gw_id = gw_id [EOL] self . name = config . get ( CONF_NAME , gw_id ) [EOL] self . climate_config = config [ CONF_CLIMATE ] [EOL] self . status = { } [EOL] self . update_signal = [string] . format ( DATA_OPENTHERM_GW , gw_id ) [EOL] self . gateway = pyotgw . pyotgw ( ) [EOL] [EOL] async def connect_and_subscribe ( self , device_path ) : [EOL] [docstring] [EOL] await self . gateway . connect ( self . hass . loop , device_path ) [EOL] _LOGGER . debug ( [string] , device_path ) [EOL] [EOL] async def cleanup ( event ) : [EOL] [docstring] [EOL] await self . gateway . set_control_setpoint ( [number] ) [EOL] await self . gateway . set_max_relative_mod ( [string] ) [EOL] self . hass . bus . async_listen ( EVENT_HOMEASSISTANT_STOP , cleanup ) [EOL] [EOL] async def handle_report ( status ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , status ) [EOL] self . status = status [EOL] async_dispatcher_send ( self . hass , self . update_signal , status ) [EOL] self . gateway . subscribe ( handle_report ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] SENSOR_OXYGEN_LEVEL = [string] [EOL] SENSOR_HEART_RATE = [string] [EOL] [EOL] SENSOR_BASE_STATION = [string] [EOL] SENSOR_MOVEMENT = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from homeassistant import config_entries [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] config_entry_flow . register_discovery_flow ( DOMAIN , [string] , lambda * _ : True , config_entries . CONN_CLASS_CLOUD_PUSH ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_API_KEY , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_XUID = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_XUID ) : vol . All ( cv . ensure_list , [ cv . string ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from xboxapi import xbox_api [EOL] api = xbox_api . XboxApi ( config . get ( CONF_API_KEY ) ) [EOL] devices = [ ] [EOL] [EOL] [comment] [EOL] profile = api . get_profile ( ) [EOL] if profile . get ( [string] ) is not None : [EOL] _LOGGER . error ( [string] [string] , profile . get ( [string] , STATE_UNKNOWN ) , profile . get ( [string] , STATE_UNKNOWN ) ) [EOL] return [EOL] [EOL] for xuid in config . get ( CONF_XUID ) : [EOL] new_device = XboxSensor ( hass , api , xuid ) [EOL] if new_device . success_init : [EOL] devices . append ( new_device ) [EOL] [EOL] if devices : [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class XboxSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , api , xuid ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _state = None [EOL] self . _presence = { } [EOL] self . _xuid = xuid [EOL] self . _api = api [EOL] [EOL] [comment] [EOL] profile = self . _api . get_user_gamercard ( self . _xuid ) [EOL] [EOL] if profile . get ( [string] , True ) and profile . get ( [string] ) is None : [EOL] self . success_init = True [EOL] self . _gamertag = profile . get ( [string] ) [EOL] self . _gamerscore = profile . get ( [string] ) [EOL] self . _picture = profile . get ( [string] ) [EOL] self . _tier = profile . get ( [string] ) [EOL] else : [EOL] _LOGGER . error ( [string] [string] , self . _xuid , profile . get ( [string] , STATE_UNKNOWN ) , profile . get ( [string] , STATE_UNKNOWN ) ) [EOL] self . success_init = False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _gamertag [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attributes = { } [EOL] attributes [ [string] ] = self . _gamerscore [EOL] attributes [ [string] ] = self . _tier [EOL] [EOL] for device in self . _presence : [EOL] for title in device . get ( [string] ) : [EOL] attributes [ [string] . format ( device . get ( [string] ) , title . get ( [string] ) ) ] = title . get ( [string] ) [EOL] [EOL] return attributes [EOL] [EOL] @ property def entity_picture ( self ) : [EOL] [docstring] [EOL] return self . _picture [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] presence = self . _api . get_user_presence ( self . _xuid ) [EOL] self . _state = presence . get ( [string] ) [EOL] self . _presence = presence . get ( [string] , { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_DISPLAY_OPTIONS [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . helpers . event import async_track_point_in_utc_time [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] TIME_STR_FORMAT = [string] [EOL] [EOL] OPTION_TYPES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_DISPLAY_OPTIONS , default = [ [string] ] ) : vol . All ( cv . ensure_list , [ vol . In ( OPTION_TYPES ) ] ) , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if hass . config . time_zone is None : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] devices = [ ] [EOL] for variable in config [ CONF_DISPLAY_OPTIONS ] : [EOL] device = TimeDateSensor ( hass , variable ) [EOL] async_track_point_in_utc_time ( hass , device . point_in_time_listener , device . get_next_interval ( ) ) [EOL] devices . append ( device ) [EOL] [EOL] async_add_entities ( devices , True ) [EOL] [EOL] [EOL] class TimeDateSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , option_type ) : [EOL] [docstring] [EOL] self . _name = OPTION_TYPES [ option_type ] [EOL] self . type = option_type [EOL] self . _state = None [EOL] self . hass = hass [EOL] [EOL] self . _update_internal_state ( dt_util . utcnow ( ) ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if [string] in self . type and [string] in self . type : [EOL] return [string] [EOL] if [string] in self . type : [EOL] return [string] [EOL] return [string] [EOL] [EOL] def get_next_interval ( self , now = None ) : [EOL] [docstring] [EOL] if now is None : [EOL] now = dt_util . utcnow ( ) [EOL] if self . type == [string] : [EOL] now = dt_util . start_of_local_day ( dt_util . as_local ( now ) ) [EOL] return now + timedelta ( seconds = [number] ) [EOL] if self . type == [string] : [EOL] interval = [number] [EOL] else : [EOL] interval = [number] [EOL] timestamp = int ( dt_util . as_timestamp ( now ) ) [EOL] delta = interval - ( timestamp % interval ) [EOL] return now + timedelta ( seconds = delta ) [EOL] [EOL] def _update_internal_state ( self , time_date ) : [EOL] time = dt_util . as_local ( time_date ) . strftime ( TIME_STR_FORMAT ) [EOL] time_utc = time_date . strftime ( TIME_STR_FORMAT ) [EOL] date = dt_util . as_local ( time_date ) . date ( ) . isoformat ( ) [EOL] [EOL] [comment] [EOL] time_bmt = time_date + timedelta ( hours = [number] ) [EOL] delta = timedelta ( hours = time_bmt . hour , minutes = time_bmt . minute , seconds = time_bmt . second , microseconds = time_bmt . microsecond ) [EOL] beat = int ( ( delta . seconds + delta . microseconds / [number] ) / [number] ) [EOL] [EOL] if self . type == [string] : [EOL] self . _state = time [EOL] elif self . type == [string] : [EOL] self . _state = date [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( date , time ) [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( time , date ) [EOL] elif self . type == [string] : [EOL] self . _state = time_utc [EOL] elif self . type == [string] : [EOL] self . _state = [string] . format ( beat ) [EOL] elif self . type == [string] : [EOL] self . _state = dt_util . parse_datetime ( [string] . format ( date , time ) ) . isoformat ( ) [EOL] [EOL] @ callback def point_in_time_listener ( self , time_date ) : [EOL] [docstring] [EOL] self . _update_internal_state ( time_date ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] async_track_point_in_utc_time ( self . hass , self . point_in_time_listener , self . get_next_interval ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_BRAND = [string] [EOL] CONF_SERIAL_DEVICE = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_BRAND ) : cv . string , vol . Required ( CONF_SERIAL_DEVICE ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pmsensor import serial_pm as pm [EOL] [EOL] try : [EOL] coll = pm . PMDataCollector ( config . get ( CONF_SERIAL_DEVICE ) , pm . SUPPORTED_SENSORS [ config . get ( CONF_BRAND ) ] ) [EOL] except KeyError : [EOL] _LOGGER . error ( [string] , config . get ( CONF_BRAND ) , pm . SUPPORTED_SENSORS . keys ( ) ) [EOL] return [EOL] except OSError as err : [EOL] _LOGGER . error ( [string] , config . get ( CONF_SERIAL_DEVICE ) , err ) [EOL] return [EOL] [EOL] dev = [ ] [EOL] [EOL] for pmname in coll . supported_values ( ) : [EOL] if config . get ( CONF_NAME ) is not None : [EOL] name = [string] . format ( config . get ( CONF_NAME ) , pmname ) [EOL] else : [EOL] name = [string] . format ( pmname ) [EOL] dev . append ( ParticulateMatterSensor ( coll , name , pmname ) ) [EOL] [EOL] add_entities ( dev ) [EOL] [EOL] [EOL] class ParticulateMatterSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , pmDataCollector , name , pmname ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _pmname = pmname [EOL] self . _state = None [EOL] self . _collector = pmDataCollector [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] try : [EOL] self . _state = self . _collector . read_data ( ) [ self . _pmname ] [EOL] except KeyError : [EOL] _LOGGER . error ( [string] , self . _pmname ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import threading [EOL] [docstring] [EOL] import logging [EOL] import threading [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( EVENT_HOMEASSISTANT_START , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONTROLLER = None [EOL] [EOL] CONF_COMM_TYPE = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] REQ_LOCK = threading . Lock ( ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Optional ( CONF_HOST , default = [string] ) : cv . string , vol . Optional ( CONF_PORT , default = [number] ) : cv . port , } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config [ DOMAIN ] [EOL] host = conf . get ( CONF_HOST ) [EOL] port = conf . get ( CONF_PORT ) [EOL] [EOL] from pymochad import exceptions [EOL] [EOL] global CONTROLLER [EOL] try : [EOL] CONTROLLER = MochadCtrl ( host , port ) [EOL] except exceptions . ConfigurationError : [EOL] _LOGGER . exception ( ) [EOL] return False [EOL] [EOL] def stop_mochad ( event ) : [EOL] [docstring] [EOL] CONTROLLER . disconnect ( ) [EOL] [EOL] def start_mochad ( event ) : [EOL] [docstring] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , stop_mochad ) [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , start_mochad ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class MochadCtrl : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port ) : [EOL] [docstring] [EOL] super ( MochadCtrl , self ) . __init__ ( ) [EOL] self . _host = host [EOL] self . _port = port [EOL] [EOL] from pymochad import controller [EOL] [EOL] self . ctrl = controller . PyMochad ( server = self . _host , port = self . _port ) [EOL] [EOL] @ property def host ( self ) : [EOL] [docstring] [EOL] return self . _host [EOL] [EOL] @ property def port ( self ) : [EOL] [docstring] [EOL] return self . _port [EOL] [EOL] def disconnect ( self ) : [EOL] [docstring] [EOL] self . ctrl . socket . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] config_entry_flow . register_webhook_flow ( DOMAIN , [string] , { [string] : [string] , [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] from datetime import timedelta [EOL] [EOL] import ipaddress [EOL] import logging [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_HOST ) [EOL] from homeassistant . helpers import discovery [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . dispatcher import dispatcher_send [EOL] from homeassistant . helpers . event import track_time_interval [EOL] [EOL] DOMAIN = [string] [EOL] DATA_SMARTY = [string] [EOL] SMARTY_NAME = [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_HOST ) : vol . All ( ipaddress . ip_address , cv . string ) , vol . Optional ( CONF_NAME , default = SMARTY_NAME ) : cv . string } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] RPM = [string] [EOL] SIGNAL_UPDATE_SMARTY = [string] [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] from pysmarty import ( Smarty ) [EOL] conf = config [ DOMAIN ] [EOL] [EOL] host = conf [ CONF_HOST ] [EOL] name = conf [ CONF_NAME ] [EOL] [EOL] _LOGGER . debug ( [string] , name , host ) [EOL] [EOL] smarty = Smarty ( host = host ) [EOL] [EOL] hass . data [ DOMAIN ] = { [string] : smarty , [string] : name } [EOL] [EOL] [comment] [EOL] smarty . update ( ) [EOL] [EOL] [comment] [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] [EOL] def poll_device_update ( event_time ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] if smarty . update ( ) : [EOL] _LOGGER . debug ( [string] ) [EOL] dispatcher_send ( hass , SIGNAL_UPDATE_SMARTY ) [EOL] else : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] track_time_interval ( hass , poll_device_update , timedelta ( seconds = [number] ) ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Type [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] from homeassistant import config_entries [EOL] from . const import DOMAIN , ATTR_DEVICE_NAME [EOL] [EOL] [EOL] @ config_entries . HANDLERS . register ( DOMAIN ) class MobileAppFlowHandler ( config_entries . ConfigFlow ) : [EOL] [docstring] [EOL] [EOL] VERSION = [number] [EOL] CONNECTION_CLASS = config_entries . CONN_CLASS_CLOUD_PUSH [EOL] [EOL] async def async_step_user ( self , user_input = None ) : [EOL] [docstring] [EOL] placeholders = { [string] : [string] } [EOL] [EOL] return self . async_abort ( reason = [string] , description_placeholders = placeholders ) [EOL] [EOL] async def async_step_registration ( self , user_input = None ) : [EOL] [docstring] [EOL] return self . async_create_entry ( title = user_input [ ATTR_DEVICE_NAME ] , data = user_input ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Type[homeassistant.components.mobile_app.config_flow.MobileAppFlowHandler]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import aiohttp [EOL] [docstring] [EOL] import uuid [EOL] from typing import Dict [EOL] [EOL] from aiohttp . web import Response , Request [EOL] [EOL] from homeassistant . auth . util import generate_secret [EOL] from homeassistant . components . cloud import ( async_create_cloudhook , async_remote_ui_url , CloudNotAvailable ) [EOL] from homeassistant . components . http import HomeAssistantView [EOL] from homeassistant . components . http . data_validator import RequestDataValidator [EOL] from homeassistant . const import ( HTTP_CREATED , CONF_WEBHOOK_ID ) [EOL] [EOL] from . const import ( ATTR_DEVICE_ID , ATTR_SUPPORTS_ENCRYPTION , CONF_CLOUDHOOK_URL , CONF_REMOTE_UI_URL , CONF_SECRET , CONF_USER_ID , DOMAIN , REGISTRATION_SCHEMA ) [EOL] [EOL] from . helpers import supports_encryption [EOL] [EOL] [EOL] class RegistrationsView ( HomeAssistantView ) : [EOL] [docstring] [EOL] [EOL] url = [string] [EOL] name = [string] [EOL] [EOL] @ RequestDataValidator ( REGISTRATION_SCHEMA ) async def post ( self , request , data ) : [EOL] [docstring] [EOL] hass = request . app [ [string] ] [EOL] [EOL] webhook_id = generate_secret ( ) [EOL] [EOL] if hass . components . cloud . async_active_subscription ( ) : [EOL] data [ CONF_CLOUDHOOK_URL ] = await async_create_cloudhook ( hass , webhook_id ) [EOL] [EOL] data [ ATTR_DEVICE_ID ] = str ( uuid . uuid4 ( ) ) . replace ( [string] , [string] ) [EOL] [EOL] data [ CONF_WEBHOOK_ID ] = webhook_id [EOL] [EOL] if data [ ATTR_SUPPORTS_ENCRYPTION ] and supports_encryption ( ) : [EOL] from nacl . secret import SecretBox [EOL] [EOL] data [ CONF_SECRET ] = generate_secret ( SecretBox . KEY_SIZE ) [EOL] [EOL] data [ CONF_USER_ID ] = request [ [string] ] . id [EOL] [EOL] ctx = { [string] : [string] } [EOL] await hass . async_create_task ( hass . config_entries . flow . async_init ( DOMAIN , context = ctx , data = data ) ) [EOL] [EOL] remote_ui_url = None [EOL] try : [EOL] remote_ui_url = async_remote_ui_url ( hass ) [EOL] except CloudNotAvailable : [EOL] pass [EOL] [EOL] return self . json ( { CONF_CLOUDHOOK_URL : data . get ( CONF_CLOUDHOOK_URL ) , CONF_REMOTE_UI_URL : remote_ui_url , CONF_SECRET : data . get ( CONF_SECRET ) , CONF_WEBHOOK_ID : data [ CONF_WEBHOOK_ID ] , } , status_code = HTTP_CREATED ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web.Response$ 0 0 0 $aiohttp.web.Request$ 0 $typing.Dict$ 0 0 0 0 0 $typing.Any$ 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 $aiohttp.web.Request$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict$ 0 $typing.Dict$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Optional [EOL] import typing [EOL] [docstring] [EOL] CONF_ACCEPT_ERRORS = [string] [EOL] CONF_AUTH_KEY = [string] [EOL] CONF_AUTH_PROTOCOL = [string] [EOL] CONF_BASEOID = [string] [EOL] CONF_COMMUNITY = [string] [EOL] CONF_DEFAULT_VALUE = [string] [EOL] CONF_PRIV_KEY = [string] [EOL] CONF_PRIV_PROTOCOL = [string] [EOL] CONF_VERSION = [string] [EOL] [EOL] DEFAULT_AUTH_PROTOCOL = [string] [EOL] DEFAULT_COMMUNITY = [string] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [string] [EOL] DEFAULT_PRIV_PROTOCOL = [string] [EOL] DEFAULT_VERSION = [string] [EOL] [EOL] SNMP_VERSIONS = { [string] : [number] , [string] : [number] , [string] : None } [EOL] [EOL] MAP_AUTH_PROTOCOLS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] MAP_PRIV_PROTOCOLS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , CONF_UNIT_OF_MEASUREMENT , CONF_USERNAME , CONF_VALUE_TEMPLATE , STATE_UNKNOWN ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] from . const import ( CONF_ACCEPT_ERRORS , CONF_AUTH_KEY , CONF_AUTH_PROTOCOL , CONF_BASEOID , CONF_COMMUNITY , CONF_DEFAULT_VALUE , CONF_PRIV_KEY , CONF_PRIV_PROTOCOL , CONF_VERSION , DEFAULT_AUTH_PROTOCOL , DEFAULT_COMMUNITY , DEFAULT_HOST , DEFAULT_NAME , DEFAULT_PORT , DEFAULT_PRIV_PROTOCOL , DEFAULT_VERSION , MAP_AUTH_PROTOCOLS , MAP_PRIV_PROTOCOLS , SNMP_VERSIONS ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_BASEOID ) : cv . string , vol . Optional ( CONF_ACCEPT_ERRORS , default = False ) : cv . boolean , vol . Optional ( CONF_COMMUNITY , default = DEFAULT_COMMUNITY ) : cv . string , vol . Optional ( CONF_DEFAULT_VALUE ) : cv . string , vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_UNIT_OF_MEASUREMENT ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_VERSION , default = DEFAULT_VERSION ) : vol . In ( SNMP_VERSIONS ) , vol . Optional ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_AUTH_KEY ) : cv . string , vol . Optional ( CONF_AUTH_PROTOCOL , default = DEFAULT_AUTH_PROTOCOL ) : vol . In ( MAP_AUTH_PROTOCOLS ) , vol . Optional ( CONF_PRIV_KEY ) : cv . string , vol . Optional ( CONF_PRIV_PROTOCOL , default = DEFAULT_PRIV_PROTOCOL ) : vol . In ( MAP_PRIV_PROTOCOLS ) , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pysnmp . hlapi . asyncio import ( getCmd , CommunityData , SnmpEngine , UdpTransportTarget , ContextData , ObjectType , ObjectIdentity , UsmUserData ) [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] community = config . get ( CONF_COMMUNITY ) [EOL] baseoid = config . get ( CONF_BASEOID ) [EOL] unit = config . get ( CONF_UNIT_OF_MEASUREMENT ) [EOL] version = config . get ( CONF_VERSION ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] authkey = config . get ( CONF_AUTH_KEY ) [EOL] authproto = config . get ( CONF_AUTH_PROTOCOL ) [EOL] privkey = config . get ( CONF_PRIV_KEY ) [EOL] privproto = config . get ( CONF_PRIV_PROTOCOL ) [EOL] accept_errors = config . get ( CONF_ACCEPT_ERRORS ) [EOL] default_value = config . get ( CONF_DEFAULT_VALUE ) [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] if version == [string] : [EOL] import pysnmp . hlapi . asyncio as hlapi [EOL] [EOL] if not authkey : [EOL] authproto = [string] [EOL] if not privkey : [EOL] privproto = [string] [EOL] [EOL] request_args = [ SnmpEngine ( ) , UsmUserData ( username , authKey = authkey or None , privKey = privkey or None , authProtocol = getattr ( hlapi , MAP_AUTH_PROTOCOLS [ authproto ] ) , privProtocol = getattr ( hlapi , MAP_PRIV_PROTOCOLS [ privproto ] ) , ) , UdpTransportTarget ( ( host , port ) ) , ContextData ( ) , ] [EOL] else : [EOL] request_args = [ SnmpEngine ( ) , CommunityData ( community , mpModel = SNMP_VERSIONS [ version ] ) , UdpTransportTarget ( ( host , port ) ) , ContextData ( ) , ] [EOL] [EOL] errindication , _ , _ , _ = await getCmd ( * request_args , ObjectType ( ObjectIdentity ( baseoid ) ) ) [EOL] [EOL] if errindication and not accept_errors : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] data = SnmpData ( request_args , baseoid , accept_errors , default_value ) [EOL] async_add_entities ( [ SnmpSensor ( data , name , unit , value_template ) ] , True ) [EOL] [EOL] [EOL] class SnmpSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , name , unit_of_measurement , value_template ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _value_template = value_template [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] await self . data . async_update ( ) [EOL] value = self . data . value [EOL] [EOL] if value is None : [EOL] value = STATE_UNKNOWN [EOL] elif self . _value_template is not None : [EOL] value = self . _value_template . async_render_with_possible_json_value ( value , STATE_UNKNOWN ) [EOL] [EOL] self . _state = value [EOL] [EOL] [EOL] class SnmpData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , request_args , baseoid , accept_errors , default_value ) : [EOL] [docstring] [EOL] self . _request_args = request_args [EOL] self . _baseoid = baseoid [EOL] self . _accept_errors = accept_errors [EOL] self . _default_value = default_value [EOL] self . value = None [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] from pysnmp . hlapi . asyncio import getCmd , ObjectType , ObjectIdentity [EOL] [EOL] errindication , errstatus , errindex , restable = await getCmd ( * self . _request_args , ObjectType ( ObjectIdentity ( self . _baseoid ) ) ) [EOL] [EOL] if errindication and not self . _accept_errors : [EOL] _LOGGER . error ( [string] , errindication ) [EOL] elif errstatus and not self . _accept_errors : [EOL] _LOGGER . error ( [string] , errstatus . prettyPrint ( ) , errindex and restable [ - [number] ] [ int ( errindex ) - [number] ] or [string] ) [EOL] elif ( errindication or errstatus ) and self . _accept_errors : [EOL] self . value = self . _default_value [EOL] else : [EOL] for resrow in restable : [EOL] self . value = str ( resrow [ - [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import math [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import util [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . core import callback [EOL] from homeassistant . const import ( ATTR_UNIT_OF_MEASUREMENT , EVENT_HOMEASSISTANT_START , STATE_UNKNOWN , TEMP_CELSIUS , TEMP_FAHRENHEIT , CONF_NAME ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_CRITICAL_TEMP = [string] [EOL] ATTR_DEWPOINT = [string] [EOL] [EOL] CONF_CALIBRATION_FACTOR = [string] [EOL] CONF_INDOOR_HUMIDITY = [string] [EOL] CONF_INDOOR_TEMP = [string] [EOL] CONF_OUTDOOR_TEMP = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MAGNUS_K2 = [number] [EOL] MAGNUS_K3 = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_INDOOR_TEMP ) : cv . entity_id , vol . Required ( CONF_OUTDOOR_TEMP ) : cv . entity_id , vol . Required ( CONF_INDOOR_HUMIDITY ) : cv . entity_id , vol . Optional ( CONF_CALIBRATION_FACTOR ) : vol . Coerce ( float ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME , DEFAULT_NAME ) [EOL] indoor_temp_sensor = config . get ( CONF_INDOOR_TEMP ) [EOL] outdoor_temp_sensor = config . get ( CONF_OUTDOOR_TEMP ) [EOL] indoor_humidity_sensor = config . get ( CONF_INDOOR_HUMIDITY ) [EOL] calib_factor = config . get ( CONF_CALIBRATION_FACTOR ) [EOL] [EOL] async_add_entities ( [ MoldIndicator ( name , hass . config . units . is_metric , indoor_temp_sensor , outdoor_temp_sensor , indoor_humidity_sensor , calib_factor ) ] , False ) [EOL] [EOL] [EOL] class MoldIndicator ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , is_metric , indoor_temp_sensor , outdoor_temp_sensor , indoor_humidity_sensor , calib_factor ) : [EOL] [docstring] [EOL] self . _state = None [EOL] self . _name = name [EOL] self . _indoor_temp_sensor = indoor_temp_sensor [EOL] self . _indoor_humidity_sensor = indoor_humidity_sensor [EOL] self . _outdoor_temp_sensor = outdoor_temp_sensor [EOL] self . _calib_factor = calib_factor [EOL] self . _is_metric = is_metric [EOL] self . _available = False [EOL] self . _entities = set ( [ self . _indoor_temp_sensor , self . _indoor_humidity_sensor , self . _outdoor_temp_sensor ] ) [EOL] [EOL] self . _dewpoint = None [EOL] self . _indoor_temp = None [EOL] self . _outdoor_temp = None [EOL] self . _indoor_hum = None [EOL] self . _crit_temp = None [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] @ callback def mold_indicator_sensors_state_listener ( entity , old_state , new_state ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] [string] , entity , old_state , new_state ) [EOL] [EOL] if self . _update_sensor ( entity , old_state , new_state ) : [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] @ callback def mold_indicator_startup ( event ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . entity_id ) [EOL] [EOL] async_track_state_change ( self . hass , self . _entities , mold_indicator_sensors_state_listener ) [EOL] [EOL] [comment] [EOL] indoor_temp = self . hass . states . get ( self . _indoor_temp_sensor ) [EOL] outdoor_temp = self . hass . states . get ( self . _outdoor_temp_sensor ) [EOL] indoor_hum = self . hass . states . get ( self . _indoor_humidity_sensor ) [EOL] [EOL] schedule_update = self . _update_sensor ( self . _indoor_temp_sensor , None , indoor_temp ) [EOL] [EOL] schedule_update = False if not self . _update_sensor ( self . _outdoor_temp_sensor , None , outdoor_temp ) else\ [EOL] schedule_update [EOL] [EOL] schedule_update = False if not self . _update_sensor ( self . _indoor_humidity_sensor , None , indoor_hum ) else\ [EOL] schedule_update [EOL] [EOL] if schedule_update : [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] self . hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_START , mold_indicator_startup ) [EOL] [EOL] def _update_sensor ( self , entity , old_state , new_state ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , entity ) [EOL] if new_state is None : [EOL] return False [EOL] [EOL] [comment] [EOL] [comment] [EOL] if old_state is None and new_state . state == STATE_UNKNOWN : [EOL] return False [EOL] [EOL] if entity == self . _indoor_temp_sensor : [EOL] self . _indoor_temp = MoldIndicator . _update_temp_sensor ( new_state ) [EOL] elif entity == self . _outdoor_temp_sensor : [EOL] self . _outdoor_temp = MoldIndicator . _update_temp_sensor ( new_state ) [EOL] elif entity == self . _indoor_humidity_sensor : [EOL] self . _indoor_hum = MoldIndicator . _update_hum_sensor ( new_state ) [EOL] [EOL] return True [EOL] [EOL] @ staticmethod def _update_temp_sensor ( state ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , state . state ) [EOL] [EOL] [comment] [EOL] if state . state == STATE_UNKNOWN : [EOL] _LOGGER . error ( [string] [string] , state . entity_id , state . state ) [EOL] return None [EOL] [EOL] unit = state . attributes . get ( ATTR_UNIT_OF_MEASUREMENT ) [EOL] temp = util . convert ( state . state , float ) [EOL] [EOL] if temp is None : [EOL] _LOGGER . error ( [string] [string] , state . entity_id , state . state ) [EOL] return None [EOL] [EOL] [comment] [EOL] if unit == TEMP_FAHRENHEIT : [EOL] return util . temperature . fahrenheit_to_celsius ( temp ) [EOL] if unit == TEMP_CELSIUS : [EOL] return temp [EOL] _LOGGER . error ( [string] [string] , state . entity_id , unit , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] [EOL] return None [EOL] [EOL] @ staticmethod def _update_hum_sensor ( state ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , state . state ) [EOL] [EOL] [comment] [EOL] if state . state == STATE_UNKNOWN : [EOL] _LOGGER . error ( [string] , state . entity_id , state . state ) [EOL] return None [EOL] [EOL] unit = state . attributes . get ( ATTR_UNIT_OF_MEASUREMENT ) [EOL] hum = util . convert ( state . state , float ) [EOL] [EOL] if hum is None : [EOL] _LOGGER . error ( [string] , state . entity_id , state . state ) [EOL] return None [EOL] [EOL] if unit != [string] : [EOL] _LOGGER . error ( [string] , state . entity_id , unit , [string] ) [EOL] return None [EOL] [EOL] if hum > [number] or hum < [number] : [EOL] _LOGGER . error ( [string] , state . entity_id , hum , [string] ) [EOL] return None [EOL] [EOL] return hum [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . entity_id ) [EOL] [comment] [EOL] if None in ( self . _indoor_temp , self . _indoor_hum , self . _outdoor_temp ) : [EOL] self . _available = False [EOL] self . _dewpoint = None [EOL] self . _crit_temp = None [EOL] return [EOL] [EOL] [comment] [EOL] self . _calc_dewpoint ( ) [EOL] self . _calc_moldindicator ( ) [EOL] if self . _state is None : [EOL] self . _available = False [EOL] self . _dewpoint = None [EOL] self . _crit_temp = None [EOL] else : [EOL] self . _available = True [EOL] [EOL] def _calc_dewpoint ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] alpha = MAGNUS_K2 * self . _indoor_temp / ( MAGNUS_K3 + self . _indoor_temp ) [EOL] beta = MAGNUS_K2 * MAGNUS_K3 / ( MAGNUS_K3 + self . _indoor_temp ) [EOL] [EOL] if self . _indoor_hum == [number] : [EOL] self . _dewpoint = - [number] [comment] [EOL] else : [EOL] self . _dewpoint = MAGNUS_K3 * ( alpha + math . log ( self . _indoor_hum / [number] ) ) / ( beta - math . log ( self . _indoor_hum / [number] ) ) [EOL] _LOGGER . debug ( [string] , self . _dewpoint , TEMP_CELSIUS ) [EOL] [EOL] def _calc_moldindicator ( self ) : [EOL] [docstring] [EOL] if None in ( self . _dewpoint , self . _calib_factor ) or self . _calib_factor == [number] : [EOL] [EOL] _LOGGER . debug ( [string] [string] , self . _dewpoint , self . _calib_factor ) [EOL] self . _state = None [EOL] self . _available = False [EOL] self . _crit_temp = None [EOL] return [EOL] [EOL] [comment] [EOL] self . _crit_temp = self . _outdoor_temp + ( self . _indoor_temp - self . _outdoor_temp ) / self . _calib_factor [EOL] [EOL] _LOGGER . debug ( [string] , self . _crit_temp , TEMP_CELSIUS ) [EOL] [EOL] [comment] [EOL] alpha = MAGNUS_K2 * self . _crit_temp / ( MAGNUS_K3 + self . _crit_temp ) [EOL] beta = MAGNUS_K2 * MAGNUS_K3 / ( MAGNUS_K3 + self . _crit_temp ) [EOL] [EOL] crit_humidity = math . exp ( ( self . _dewpoint * beta - MAGNUS_K3 * alpha ) / ( self . _dewpoint + MAGNUS_K3 ) ) * [number] [EOL] [EOL] [comment] [EOL] if crit_humidity > [number] : [EOL] self . _state = [string] [EOL] elif crit_humidity < [number] : [EOL] self . _state = [string] [EOL] else : [EOL] self . _state = [string] . format ( int ( crit_humidity ) ) [EOL] [EOL] _LOGGER . debug ( [string] , self . _state ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _is_metric : [EOL] return { ATTR_DEWPOINT : self . _dewpoint , ATTR_CRITICAL_TEMP : self . _crit_temp , } [EOL] [EOL] dewpoint = util . temperature . celsius_to_fahrenheit ( self . _dewpoint ) \ [EOL] if self . _dewpoint is not None else None [EOL] [EOL] crit_temp = util . temperature . celsius_to_fahrenheit ( self . _crit_temp ) \ [EOL] if self . _crit_temp is not None else None [EOL] [EOL] return { ATTR_DEWPOINT : dewpoint , ATTR_CRITICAL_TEMP : crit_temp , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . switch import SwitchDevice , PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME , CONF_MAC [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_FLIP_ON_OFF = [string] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MAC ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_FLIP_ON_OFF , default = False ) : cv . boolean , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] mac_addr = config [ CONF_MAC ] [EOL] flip_on_off = config [ CONF_FLIP_ON_OFF ] [EOL] add_entities ( [ SwitchmateEntity ( mac_addr , name , flip_on_off ) ] , True ) [EOL] [EOL] [EOL] class SwitchmateEntity ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mac , name , flip_on_off ) : [EOL] [docstring] [EOL] [comment] [EOL] import switchmate [EOL] self . _mac = mac [EOL] self . _name = name [EOL] self . _device = switchmate . Switchmate ( mac = mac , flip_on_off = flip_on_off ) [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _mac . replace ( [string] , [string] ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _device . available [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _device . update ( ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _device . state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _device . turn_on ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _device . turn_off ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] ATTR_ALTITUDE = [string] [EOL] ATTR_ACCURACY = [string] [EOL] ATTR_ACTIVITY = [string] [EOL] ATTR_DEVICE = [string] [EOL] ATTR_DIRECTION = [string] [EOL] ATTR_PROVIDER = [string] [EOL] ATTR_SPEED = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] config_entry_flow . register_webhook_flow ( DOMAIN , [string] , { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] ATTR_LAST_DATA = [string] [EOL] [EOL] CONF_APP_KEY = [string] [EOL] [EOL] DATA_CLIENT = [string] [EOL] [EOL] TOPIC_UPDATE = [string] [EOL] [EOL] TYPE_BINARY_SENSOR = [string] [EOL] TYPE_SENSOR = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os . path [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_TOKEN [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] from homeassistant . components . notify import ( ATTR_DATA , ATTR_TARGET , PLATFORM_SCHEMA , BaseNotificationService ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_TOKEN ) : cv . string } ) [EOL] [EOL] ATTR_IMAGES = [string] [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] token = config . get ( CONF_TOKEN ) [EOL] return DiscordNotificationService ( hass , token ) [EOL] [EOL] [EOL] class DiscordNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , token ) : [EOL] [docstring] [EOL] self . token = token [EOL] self . hass = hass [EOL] [EOL] def file_exists ( self , filename ) : [EOL] [docstring] [EOL] if not self . hass . config . is_allowed_path ( filename ) : [EOL] return False [EOL] [EOL] return os . path . isfile ( filename ) [EOL] [EOL] async def async_send_message ( self , message , ** kwargs ) : [EOL] [docstring] [EOL] import discord [EOL] [EOL] discord . VoiceClient . warn_nacl = False [EOL] discord_bot = discord . Client ( ) [EOL] images = None [EOL] [EOL] if ATTR_TARGET not in kwargs : [EOL] _LOGGER . error ( [string] ) [EOL] return None [EOL] [EOL] data = kwargs . get ( ATTR_DATA ) or { } [EOL] [EOL] if ATTR_IMAGES in data : [EOL] images = list ( ) [EOL] [EOL] for image in data . get ( ATTR_IMAGES ) : [EOL] image_exists = await self . hass . async_add_executor_job ( self . file_exists , image ) [EOL] [EOL] if image_exists : [EOL] images . append ( image ) [EOL] else : [EOL] _LOGGER . warning ( [string] , image ) [EOL] [EOL] [comment] [EOL] @ discord_bot . event async def on_ready ( ) : [EOL] [docstring] [EOL] try : [EOL] for channelid in kwargs [ ATTR_TARGET ] : [EOL] channelid = int ( channelid ) [EOL] channel = discord_bot . get_channel ( channelid ) [EOL] [EOL] if channel is None : [EOL] _LOGGER . warning ( [string] , channelid ) [EOL] continue [EOL] [EOL] [comment] [EOL] files = None [EOL] if images : [EOL] files = list ( ) [EOL] for image in images : [EOL] files . append ( discord . File ( image ) ) [EOL] [EOL] await channel . send ( message , files = files ) [EOL] except ( discord . errors . HTTPException , discord . errors . NotFound ) as error : [EOL] _LOGGER . warning ( [string] , error ) [EOL] await discord_bot . logout ( ) [EOL] await discord_bot . close ( ) [EOL] [EOL] [comment] [EOL] await discord_bot . start ( self . token , reconnect = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union [EOL] import typing [EOL] [docstring] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] CONF_ACTIVATION = [string] [EOL] CONF_API_HOST = [string] [EOL] CONF_MOMENTARY = [string] [EOL] CONF_PAUSE = [string] [EOL] CONF_POLL_INTERVAL = [string] [EOL] CONF_PRECISION = [string] [EOL] CONF_REPEAT = [string] [EOL] CONF_INVERSE = [string] [EOL] CONF_BLINK = [string] [EOL] CONF_DISCOVERY = [string] [EOL] CONF_DHT_SENSORS = [string] [EOL] CONF_DS18B20_SENSORS = [string] [EOL] [EOL] STATE_LOW = [string] [EOL] STATE_HIGH = [string] [EOL] [EOL] PIN_TO_ZONE = { [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [number] , [number] : [string] , [number] : [number] } [EOL] ZONE_TO_PIN = { zone : pin for pin , zone in PIN_TO_ZONE . items ( ) } [EOL] [EOL] ENDPOINT_ROOT = [string] [EOL] UPDATE_ENDPOINT = ( ENDPOINT_ROOT + [string] ) [EOL] SIGNAL_SENSOR_UPDATE = [string] [EOL] SIGNAL_DS18B20_NEW = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.int,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Union[builtins.int,builtins.str],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Tuple , Any [EOL] import datetime [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from geniushubclient import GeniusHubClient [EOL] [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_TOKEN , CONF_USERNAME ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] from homeassistant . helpers . discovery import async_load_platform [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_send [EOL] from homeassistant . helpers . event import async_track_time_interval [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] _V1_API_SCHEMA = vol . Schema ( { vol . Required ( CONF_TOKEN ) : cv . string , } ) [EOL] _V3_API_SCHEMA = vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , } ) [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Any ( _V3_API_SCHEMA , _V1_API_SCHEMA , ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , hass_config ) : [EOL] [docstring] [EOL] kwargs = dict ( hass_config [ DOMAIN ] ) [EOL] if CONF_HOST in kwargs : [EOL] args = ( kwargs . pop ( CONF_HOST ) , ) [EOL] else : [EOL] args = ( kwargs . pop ( CONF_TOKEN ) , ) [EOL] [EOL] hass . data [ DOMAIN ] = { } [EOL] data = hass . data [ DOMAIN ] [ [string] ] = GeniusData ( hass , args , kwargs ) [EOL] try : [EOL] await data . _client . hub . update ( ) [comment] [EOL] except AssertionError : [comment] [EOL] _LOGGER . warning ( [string] , exc_info = True ) [EOL] return False [EOL] [EOL] async_track_time_interval ( hass , data . async_update , SCAN_INTERVAL ) [EOL] [EOL] for platform in [ [string] , [string] ] : [EOL] hass . async_create_task ( async_load_platform ( hass , platform , DOMAIN , { } , hass_config ) ) [EOL] [EOL] if not data . _client . _api_v1 : [comment] [EOL] for platform in [ [string] , [string] ] : [EOL] hass . async_create_task ( async_load_platform ( hass , platform , DOMAIN , { } , hass_config ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class GeniusData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , args , kwargs ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _client = hass . data [ DOMAIN ] [ [string] ] = GeniusHubClient ( * args , ** kwargs , session = async_get_clientsession ( hass ) ) [EOL] [EOL] async def async_update ( self , now , ** kwargs ) : [EOL] [docstring] [EOL] try : [EOL] await self . _client . hub . update ( ) [EOL] except AssertionError : [comment] [EOL] _LOGGER . warning ( [string] , exc_info = True ) [EOL] return [EOL] async_dispatcher_send ( self . _hass , DOMAIN ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . air_quality import ( PLATFORM_SCHEMA , AirQualityEntity ) [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTRIBUTION = [string] [EOL] CONF_STATION_ID = [string] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_STATION_ID ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from asmog import AmpioSmog [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] station_id = config [ CONF_STATION_ID ] [EOL] [EOL] session = async_get_clientsession ( hass ) [EOL] api = AmpioSmogMapData ( AmpioSmog ( station_id , hass . loop , session ) ) [EOL] [EOL] await api . async_update ( ) [EOL] [EOL] if not api . api . data : [EOL] _LOGGER . error ( [string] , station_id ) [EOL] return [EOL] [EOL] async_add_entities ( [ AmpioSmogQuality ( api , station_id , name ) ] , True ) [EOL] [EOL] [EOL] class AmpioSmogQuality ( AirQualityEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api , station_id , name ) : [EOL] [docstring] [EOL] self . _ampio = api [EOL] self . _station_id = station_id [EOL] self . _name = name or api . api . name [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _station_id ) [EOL] [EOL] @ property def particulate_matter_2_5 ( self ) : [EOL] [docstring] [EOL] return self . _ampio . api . pm2_5 [EOL] [EOL] @ property def particulate_matter_10 ( self ) : [EOL] [docstring] [EOL] return self . _ampio . api . pm10 [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] return ATTRIBUTION [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] await self . _ampio . async_update ( ) [EOL] [EOL] [EOL] class AmpioSmogMapData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api ) : [EOL] [docstring] [EOL] self . api = api [EOL] [EOL] @ Throttle ( SCAN_INTERVAL ) async def async_update ( self ) : [EOL] [docstring] [EOL] await self . api . get_data ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import functools as ft [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . loader import bind_hass [EOL] from homeassistant . helpers . entity_component import EntityComponent [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( STATE_ON , SERVICE_TURN_ON , SERVICE_TURN_OFF , SERVICE_TOGGLE , ATTR_ENTITY_ID ) [EOL] from homeassistant . components import group [EOL] from homeassistant . helpers . config_validation import ( PLATFORM_SCHEMA , PLATFORM_SCHEMA_BASE ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_ACTIVITY = [string] [EOL] ATTR_COMMAND = [string] [EOL] ATTR_DEVICE = [string] [EOL] ATTR_NUM_REPEATS = [string] [EOL] ATTR_DELAY_SECS = [string] [EOL] ATTR_HOLD_SECS = [string] [EOL] ATTR_ALTERNATIVE = [string] [EOL] ATTR_TIMEOUT = [string] [EOL] [EOL] DOMAIN = [string] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] ENTITY_ID_ALL_REMOTES = group . ENTITY_ID_FORMAT . format ( [string] ) [EOL] ENTITY_ID_FORMAT = DOMAIN + [string] [EOL] [EOL] GROUP_NAME_ALL_REMOTES = [string] [EOL] [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] SERVICE_SEND_COMMAND = [string] [EOL] SERVICE_LEARN_COMMAND = [string] [EOL] SERVICE_SYNC = [string] [EOL] [EOL] DEFAULT_NUM_REPEATS = [number] [EOL] DEFAULT_DELAY_SECS = [number] [EOL] DEFAULT_HOLD_SECS = [number] [EOL] [EOL] SUPPORT_LEARN_COMMAND = [number] [EOL] [EOL] REMOTE_SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . comp_entity_ids , } ) [EOL] [EOL] REMOTE_SERVICE_ACTIVITY_SCHEMA = REMOTE_SERVICE_SCHEMA . extend ( { vol . Optional ( ATTR_ACTIVITY ) : cv . string } ) [EOL] [EOL] REMOTE_SERVICE_SEND_COMMAND_SCHEMA = REMOTE_SERVICE_SCHEMA . extend ( { vol . Required ( ATTR_COMMAND ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( ATTR_DEVICE ) : cv . string , vol . Optional ( ATTR_NUM_REPEATS , default = DEFAULT_NUM_REPEATS ) : cv . positive_int , vol . Optional ( ATTR_DELAY_SECS ) : vol . Coerce ( float ) , vol . Optional ( ATTR_HOLD_SECS , default = DEFAULT_HOLD_SECS ) : vol . Coerce ( float ) , } ) [EOL] [EOL] REMOTE_SERVICE_LEARN_COMMAND_SCHEMA = REMOTE_SERVICE_SCHEMA . extend ( { vol . Optional ( ATTR_DEVICE ) : cv . string , vol . Optional ( ATTR_COMMAND ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( ATTR_ALTERNATIVE ) : cv . boolean , vol . Optional ( ATTR_TIMEOUT ) : cv . positive_int } ) [EOL] [EOL] [EOL] @ bind_hass def is_on ( hass , entity_id = None ) : [EOL] [docstring] [EOL] entity_id = entity_id or ENTITY_ID_ALL_REMOTES [EOL] return hass . states . is_state ( entity_id , STATE_ON ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] component = EntityComponent ( _LOGGER , DOMAIN , hass , SCAN_INTERVAL , GROUP_NAME_ALL_REMOTES ) [EOL] await component . async_setup ( config ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_TURN_OFF , REMOTE_SERVICE_ACTIVITY_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_TURN_ON , REMOTE_SERVICE_ACTIVITY_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_TOGGLE , REMOTE_SERVICE_ACTIVITY_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_SEND_COMMAND , REMOTE_SERVICE_SEND_COMMAND_SCHEMA , [string] ) [EOL] [EOL] component . async_register_entity_service ( SERVICE_LEARN_COMMAND , REMOTE_SERVICE_LEARN_COMMAND_SCHEMA , [string] ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class RemoteDevice ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] def send_command ( self , command , ** kwargs ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def async_send_command ( self , command , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_executor_job ( ft . partial ( self . send_command , command , ** kwargs ) ) [EOL] [EOL] def learn_command ( self , ** kwargs ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def async_learn_command ( self , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_executor_job ( ft . partial ( self . learn_command , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( MediaPlayerDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . media_player . const import ( SUPPORT_SELECT_SOURCE , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , EVENT_HOMEASSISTANT_STOP , STATE_OFF , STATE_ON ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] SUPPORT_ANTHEMAV = SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import anthemav [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] name = config . get ( CONF_NAME ) [EOL] device = None [EOL] [EOL] _LOGGER . info ( [string] , host , port ) [EOL] [EOL] def async_anthemav_update_callback ( message ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , message ) [EOL] hass . async_create_task ( device . async_update_ha_state ( ) ) [EOL] [EOL] avr = await anthemav . Connection . create ( host = host , port = port , update_callback = async_anthemav_update_callback ) [EOL] [EOL] device = AnthemAVR ( avr , name ) [EOL] [EOL] _LOGGER . debug ( [string] , device . dump_avrdata ) [EOL] _LOGGER . debug ( [string] , avr . dump_conndata ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , device . avr . close ) [EOL] async_add_entities ( [ device ] ) [EOL] [EOL] [EOL] class AnthemAVR ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , avr , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . avr = avr [EOL] self . _name = name [EOL] [EOL] def _lookup ( self , propname , dval = None ) : [EOL] return getattr ( self . avr . protocol , propname , dval ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_ANTHEMAV [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name or self . _lookup ( [string] ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] pwrstate = self . _lookup ( [string] ) [EOL] [EOL] if pwrstate is True : [EOL] return STATE_ON [EOL] if pwrstate is False : [EOL] return STATE_OFF [EOL] return None [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , False ) [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [number] ) [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [string] ) [EOL] [EOL] @ property def app_name ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [string] ) + [string] + self . _lookup ( [string] , [string] ) [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [string] ) [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _lookup ( [string] , [ [string] ] ) [EOL] [EOL] async def async_select_source ( self , source ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , source ) [EOL] [EOL] async def async_turn_off ( self ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , False ) [EOL] [EOL] async def async_turn_on ( self ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , True ) [EOL] [EOL] async def async_set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , volume ) [EOL] [EOL] async def async_mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . _update_avr ( [string] , mute ) [EOL] [EOL] def _update_avr ( self , propname , value ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , propname , str ( value ) ) [EOL] setattr ( self . avr . protocol , propname , value ) [EOL] [EOL] @ property def dump_avrdata ( self ) : [EOL] [docstring] [EOL] attrs = vars ( self ) [EOL] return ( [string] + [string] . join ( [string] % item for item in attrs . items ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Union , Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] from datetime import datetime [EOL] import logging [EOL] import math [EOL] [EOL] from homeassistant import core as ha [EOL] from homeassistant . util . decorator import Registry [EOL] import homeassistant . util . color as color_util [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_TEMPERATURE , SERVICE_LOCK , SERVICE_MEDIA_NEXT_TRACK , SERVICE_MEDIA_PAUSE , SERVICE_MEDIA_PLAY , SERVICE_MEDIA_PREVIOUS_TRACK , SERVICE_MEDIA_STOP , SERVICE_SET_COVER_POSITION , SERVICE_TURN_OFF , SERVICE_TURN_ON , SERVICE_UNLOCK , SERVICE_VOLUME_DOWN , SERVICE_VOLUME_MUTE , SERVICE_VOLUME_SET , SERVICE_VOLUME_UP , TEMP_CELSIUS , TEMP_FAHRENHEIT , ) [EOL] from homeassistant . components . climate import const as climate [EOL] from homeassistant . components import cover , fan , group , light , media_player [EOL] from homeassistant . util . temperature import convert as convert_temperature [EOL] [EOL] from . const import ( API_TEMP_UNITS , API_THERMOSTAT_MODES , Cause , ) [EOL] from . entities import async_get_entities [EOL] from . state_report import async_enable_proactive_mode [EOL] from . errors import ( AlexaInvalidValueError , AlexaTempRangeError , AlexaUnsupportedThermostatModeError , ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] HANDLERS = Registry ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_discovery ( hass , config , directive , context ) : [EOL] [docstring] [EOL] discovery_endpoints = [ alexa_entity . serialize_discovery ( ) for alexa_entity in async_get_entities ( hass , config ) if config . should_expose ( alexa_entity . entity_id ) ] [EOL] [EOL] return directive . response ( name = [string] , namespace = [string] , payload = { [string] : discovery_endpoints } , ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_accept_grant ( hass , config , directive , context ) : [EOL] [docstring] [EOL] auth_code = directive . payload [ [string] ] [ [string] ] [EOL] _LOGGER . debug ( [string] , auth_code ) [EOL] [EOL] if config . supports_auth : [EOL] await config . async_accept_grant ( auth_code ) [EOL] [EOL] if config . should_report_state : [EOL] await async_enable_proactive_mode ( hass , config ) [EOL] [EOL] return directive . response ( name = [string] , namespace = [string] , payload = { } ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_turn_on ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] domain = entity . domain [EOL] if domain == group . DOMAIN : [EOL] domain = ha . DOMAIN [EOL] [EOL] service = SERVICE_TURN_ON [EOL] if domain == cover . DOMAIN : [EOL] service = cover . SERVICE_OPEN_COVER [EOL] [EOL] await hass . services . async_call ( domain , service , { ATTR_ENTITY_ID : entity . entity_id } , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_turn_off ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] domain = entity . domain [EOL] if entity . domain == group . DOMAIN : [EOL] domain = ha . DOMAIN [EOL] [EOL] service = SERVICE_TURN_OFF [EOL] if entity . domain == cover . DOMAIN : [EOL] service = cover . SERVICE_CLOSE_COVER [EOL] [EOL] await hass . services . async_call ( domain , service , { ATTR_ENTITY_ID : entity . entity_id } , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_set_brightness ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] brightness = int ( directive . payload [ [string] ] ) [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_TURN_ON , { ATTR_ENTITY_ID : entity . entity_id , light . ATTR_BRIGHTNESS_PCT : brightness , } , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_adjust_brightness ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] brightness_delta = int ( directive . payload [ [string] ] ) [EOL] [EOL] [comment] [EOL] try : [EOL] current = math . floor ( int ( entity . attributes . get ( light . ATTR_BRIGHTNESS ) ) / [number] * [number] ) [EOL] except ZeroDivisionError : [EOL] current = [number] [EOL] [EOL] [comment] [EOL] brightness = max ( [number] , brightness_delta + current ) [EOL] await hass . services . async_call ( entity . domain , SERVICE_TURN_ON , { ATTR_ENTITY_ID : entity . entity_id , light . ATTR_BRIGHTNESS_PCT : brightness , } , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_set_color ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] rgb = color_util . color_hsb_to_RGB ( float ( directive . payload [ [string] ] [ [string] ] ) , float ( directive . payload [ [string] ] [ [string] ] ) , float ( directive . payload [ [string] ] [ [string] ] ) ) [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_TURN_ON , { ATTR_ENTITY_ID : entity . entity_id , light . ATTR_RGB_COLOR : rgb , } , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_set_color_temperature ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] kelvin = int ( directive . payload [ [string] ] ) [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_TURN_ON , { ATTR_ENTITY_ID : entity . entity_id , light . ATTR_KELVIN : kelvin , } , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_decrease_color_temp ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] current = int ( entity . attributes . get ( light . ATTR_COLOR_TEMP ) ) [EOL] max_mireds = int ( entity . attributes . get ( light . ATTR_MAX_MIREDS ) ) [EOL] [EOL] value = min ( max_mireds , current + [number] ) [EOL] await hass . services . async_call ( entity . domain , SERVICE_TURN_ON , { ATTR_ENTITY_ID : entity . entity_id , light . ATTR_COLOR_TEMP : value , } , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_increase_color_temp ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] current = int ( entity . attributes . get ( light . ATTR_COLOR_TEMP ) ) [EOL] min_mireds = int ( entity . attributes . get ( light . ATTR_MIN_MIREDS ) ) [EOL] [EOL] value = max ( min_mireds , current - [number] ) [EOL] await hass . services . async_call ( entity . domain , SERVICE_TURN_ON , { ATTR_ENTITY_ID : entity . entity_id , light . ATTR_COLOR_TEMP : value , } , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_activate ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] domain = entity . domain [EOL] [EOL] await hass . services . async_call ( domain , SERVICE_TURN_ON , { ATTR_ENTITY_ID : entity . entity_id } , blocking = False , context = context ) [EOL] [EOL] payload = { [string] : { [string] : Cause . VOICE_INTERACTION } , [string] : [string] % ( datetime . utcnow ( ) . isoformat ( ) , ) } [EOL] [EOL] return directive . response ( name = [string] , namespace = [string] , payload = payload , ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_deactivate ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] domain = entity . domain [EOL] [EOL] await hass . services . async_call ( domain , SERVICE_TURN_OFF , { ATTR_ENTITY_ID : entity . entity_id } , blocking = False , context = context ) [EOL] [EOL] payload = { [string] : { [string] : Cause . VOICE_INTERACTION } , [string] : [string] % ( datetime . utcnow ( ) . isoformat ( ) , ) } [EOL] [EOL] return directive . response ( name = [string] , namespace = [string] , payload = payload , ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_set_percentage ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] percentage = int ( directive . payload [ [string] ] ) [EOL] service = None [EOL] data = { ATTR_ENTITY_ID : entity . entity_id } [EOL] [EOL] if entity . domain == fan . DOMAIN : [EOL] service = fan . SERVICE_SET_SPEED [EOL] speed = [string] [EOL] [EOL] if percentage <= [number] : [EOL] speed = [string] [EOL] elif percentage <= [number] : [EOL] speed = [string] [EOL] elif percentage <= [number] : [EOL] speed = [string] [EOL] data [ fan . ATTR_SPEED ] = speed [EOL] [EOL] elif entity . domain == cover . DOMAIN : [EOL] service = SERVICE_SET_COVER_POSITION [EOL] data [ cover . ATTR_POSITION ] = percentage [EOL] [EOL] await hass . services . async_call ( entity . domain , service , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_adjust_percentage ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] percentage_delta = int ( directive . payload [ [string] ] ) [EOL] service = None [EOL] data = { ATTR_ENTITY_ID : entity . entity_id } [EOL] [EOL] if entity . domain == fan . DOMAIN : [EOL] service = fan . SERVICE_SET_SPEED [EOL] speed = entity . attributes . get ( fan . ATTR_SPEED ) [EOL] [EOL] if speed == [string] : [EOL] current = [number] [EOL] elif speed == [string] : [EOL] current = [number] [EOL] elif speed == [string] : [EOL] current = [number] [EOL] elif speed == [string] : [EOL] current = [number] [EOL] [EOL] [comment] [EOL] percentage = max ( [number] , percentage_delta + current ) [EOL] speed = [string] [EOL] [EOL] if percentage <= [number] : [EOL] speed = [string] [EOL] elif percentage <= [number] : [EOL] speed = [string] [EOL] elif percentage <= [number] : [EOL] speed = [string] [EOL] [EOL] data [ fan . ATTR_SPEED ] = speed [EOL] [EOL] elif entity . domain == cover . DOMAIN : [EOL] service = SERVICE_SET_COVER_POSITION [EOL] [EOL] current = entity . attributes . get ( cover . ATTR_POSITION ) [EOL] [EOL] data [ cover . ATTR_POSITION ] = max ( [number] , percentage_delta + current ) [EOL] [EOL] await hass . services . async_call ( entity . domain , service , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_lock ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] await hass . services . async_call ( entity . domain , SERVICE_LOCK , { ATTR_ENTITY_ID : entity . entity_id } , blocking = False , context = context ) [EOL] [EOL] response = directive . response ( ) [EOL] response . add_context_property ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] return response [EOL] [EOL] [EOL] [comment] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_unlock ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] await hass . services . async_call ( entity . domain , SERVICE_UNLOCK , { ATTR_ENTITY_ID : entity . entity_id } , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_set_volume ( hass , config , directive , context ) : [EOL] [docstring] [EOL] volume = round ( float ( directive . payload [ [string] ] / [number] ) , [number] ) [EOL] entity = directive . entity [EOL] [EOL] data = { ATTR_ENTITY_ID : entity . entity_id , media_player . const . ATTR_MEDIA_VOLUME_LEVEL : volume , } [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_VOLUME_SET , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_select_input ( hass , config , directive , context ) : [EOL] [docstring] [EOL] media_input = directive . payload [ [string] ] [EOL] entity = directive . entity [EOL] [EOL] [comment] [EOL] source_list = entity . attributes [ media_player . const . ATTR_INPUT_SOURCE_LIST ] or [ ] [EOL] for source in source_list : [EOL] [comment] [EOL] [comment] [EOL] formatted_source = source . lower ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] if formatted_source in media_input . lower ( ) : [EOL] media_input = source [EOL] break [EOL] else : [EOL] msg = [string] . format ( media_input , entity . entity_id ) [EOL] raise AlexaInvalidValueError ( msg ) [EOL] [EOL] data = { ATTR_ENTITY_ID : entity . entity_id , media_player . const . ATTR_INPUT_SOURCE : media_input , } [EOL] [EOL] await hass . services . async_call ( entity . domain , media_player . SERVICE_SELECT_SOURCE , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_adjust_volume ( hass , config , directive , context ) : [EOL] [docstring] [EOL] volume_delta = int ( directive . payload [ [string] ] ) [EOL] [EOL] entity = directive . entity [EOL] current_level = entity . attributes . get ( media_player . const . ATTR_MEDIA_VOLUME_LEVEL ) [EOL] [EOL] [comment] [EOL] try : [EOL] current = math . floor ( int ( current_level * [number] ) ) [EOL] except ZeroDivisionError : [EOL] current = [number] [EOL] [EOL] volume = float ( max ( [number] , volume_delta + current ) / [number] ) [EOL] [EOL] data = { ATTR_ENTITY_ID : entity . entity_id , media_player . const . ATTR_MEDIA_VOLUME_LEVEL : volume , } [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_VOLUME_SET , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_adjust_volume_step ( hass , config , directive , context ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] volume_step = directive . payload [ [string] ] [EOL] entity = directive . entity [EOL] [EOL] data = { ATTR_ENTITY_ID : entity . entity_id , } [EOL] [EOL] if volume_step > [number] : [EOL] await hass . services . async_call ( entity . domain , SERVICE_VOLUME_UP , data , blocking = False , context = context ) [EOL] elif volume_step < [number] : [EOL] await hass . services . async_call ( entity . domain , SERVICE_VOLUME_DOWN , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_set_mute ( hass , config , directive , context ) : [EOL] [docstring] [EOL] mute = bool ( directive . payload [ [string] ] ) [EOL] entity = directive . entity [EOL] [EOL] data = { ATTR_ENTITY_ID : entity . entity_id , media_player . const . ATTR_MEDIA_VOLUME_MUTED : mute , } [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_VOLUME_MUTE , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_play ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] data = { ATTR_ENTITY_ID : entity . entity_id } [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_MEDIA_PLAY , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_pause ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] data = { ATTR_ENTITY_ID : entity . entity_id } [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_MEDIA_PAUSE , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_stop ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] data = { ATTR_ENTITY_ID : entity . entity_id } [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_MEDIA_STOP , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_next ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] data = { ATTR_ENTITY_ID : entity . entity_id } [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_MEDIA_NEXT_TRACK , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_previous ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] data = { ATTR_ENTITY_ID : entity . entity_id } [EOL] [EOL] await hass . services . async_call ( entity . domain , SERVICE_MEDIA_PREVIOUS_TRACK , data , blocking = False , context = context ) [EOL] [EOL] return directive . response ( ) [EOL] [EOL] [EOL] def temperature_from_object ( hass , temp_obj , interval = False ) : [EOL] [docstring] [EOL] to_unit = hass . config . units . temperature_unit [EOL] from_unit = TEMP_CELSIUS [EOL] temp = float ( temp_obj [ [string] ] ) [EOL] [EOL] if temp_obj [ [string] ] == [string] : [EOL] from_unit = TEMP_FAHRENHEIT [EOL] elif temp_obj [ [string] ] == [string] : [EOL] [comment] [EOL] if not interval : [EOL] temp -= [number] [EOL] [EOL] return convert_temperature ( temp , from_unit , to_unit , interval ) [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_set_target_temp ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] min_temp = entity . attributes . get ( climate . ATTR_MIN_TEMP ) [EOL] max_temp = entity . attributes . get ( climate . ATTR_MAX_TEMP ) [EOL] unit = hass . config . units . temperature_unit [EOL] [EOL] data = { ATTR_ENTITY_ID : entity . entity_id } [EOL] [EOL] payload = directive . payload [EOL] response = directive . response ( ) [EOL] if [string] in payload : [EOL] temp = temperature_from_object ( hass , payload [ [string] ] ) [EOL] if temp < min_temp or temp > max_temp : [EOL] raise AlexaTempRangeError ( hass , temp , min_temp , max_temp ) [EOL] data [ ATTR_TEMPERATURE ] = temp [EOL] response . add_context_property ( { [string] : [string] , [string] : [string] , [string] : { [string] : temp , [string] : API_TEMP_UNITS [ unit ] } , } ) [EOL] if [string] in payload : [EOL] temp_low = temperature_from_object ( hass , payload [ [string] ] ) [EOL] if temp_low < min_temp or temp_low > max_temp : [EOL] raise AlexaTempRangeError ( hass , temp_low , min_temp , max_temp ) [EOL] data [ climate . ATTR_TARGET_TEMP_LOW ] = temp_low [EOL] response . add_context_property ( { [string] : [string] , [string] : [string] , [string] : { [string] : temp_low , [string] : API_TEMP_UNITS [ unit ] } , } ) [EOL] if [string] in payload : [EOL] temp_high = temperature_from_object ( hass , payload [ [string] ] ) [EOL] if temp_high < min_temp or temp_high > max_temp : [EOL] raise AlexaTempRangeError ( hass , temp_high , min_temp , max_temp ) [EOL] data [ climate . ATTR_TARGET_TEMP_HIGH ] = temp_high [EOL] response . add_context_property ( { [string] : [string] , [string] : [string] , [string] : { [string] : temp_high , [string] : API_TEMP_UNITS [ unit ] } , } ) [EOL] [EOL] await hass . services . async_call ( entity . domain , climate . SERVICE_SET_TEMPERATURE , data , blocking = False , context = context ) [EOL] [EOL] return response [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_adjust_target_temp ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] min_temp = entity . attributes . get ( climate . ATTR_MIN_TEMP ) [EOL] max_temp = entity . attributes . get ( climate . ATTR_MAX_TEMP ) [EOL] unit = hass . config . units . temperature_unit [EOL] [EOL] temp_delta = temperature_from_object ( hass , directive . payload [ [string] ] , interval = True ) [EOL] target_temp = float ( entity . attributes . get ( ATTR_TEMPERATURE ) ) + temp_delta [EOL] [EOL] if target_temp < min_temp or target_temp > max_temp : [EOL] raise AlexaTempRangeError ( hass , target_temp , min_temp , max_temp ) [EOL] [EOL] data = { ATTR_ENTITY_ID : entity . entity_id , ATTR_TEMPERATURE : target_temp , } [EOL] [EOL] response = directive . response ( ) [EOL] await hass . services . async_call ( entity . domain , climate . SERVICE_SET_TEMPERATURE , data , blocking = False , context = context ) [EOL] response . add_context_property ( { [string] : [string] , [string] : [string] , [string] : { [string] : target_temp , [string] : API_TEMP_UNITS [ unit ] } , } ) [EOL] [EOL] return response [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_set_thermostat_mode ( hass , config , directive , context ) : [EOL] [docstring] [EOL] entity = directive . entity [EOL] mode = directive . payload [ [string] ] [EOL] mode = mode if isinstance ( mode , str ) else mode [ [string] ] [EOL] [EOL] operation_list = entity . attributes . get ( climate . ATTR_OPERATION_LIST ) [EOL] ha_mode = next ( ( k for k , v in API_THERMOSTAT_MODES . items ( ) if v == mode ) , None ) [EOL] if ha_mode not in operation_list : [EOL] msg = [string] . format ( mode ) [EOL] raise AlexaUnsupportedThermostatModeError ( msg ) [EOL] [EOL] data = { ATTR_ENTITY_ID : entity . entity_id , climate . ATTR_OPERATION_MODE : ha_mode , } [EOL] [EOL] response = directive . response ( ) [EOL] await hass . services . async_call ( entity . domain , climate . SERVICE_SET_OPERATION_MODE , data , blocking = False , context = context ) [EOL] response . add_context_property ( { [string] : [string] , [string] : [string] , [string] : mode , } ) [EOL] [EOL] return response [EOL] [EOL] [EOL] @ HANDLERS . register ( ( [string] , [string] ) ) async def async_api_reportstate ( hass , config , directive , context ) : [EOL] [docstring] [EOL] return directive . response ( name = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Union , List , Dict , Any , Optional [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] import decimal [EOL] [docstring] [EOL] import logging [EOL] [EOL] from decimal import Decimal , DecimalException [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , ATTR_UNIT_OF_MEASUREMENT , STATE_UNKNOWN , STATE_UNAVAILABLE ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] from homeassistant . helpers . restore_state import RestoreEntity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_SOURCE_ID = [string] [EOL] [EOL] CONF_SOURCE_SENSOR = [string] [EOL] CONF_ROUND_DIGITS = [string] [EOL] CONF_UNIT_PREFIX = [string] [EOL] CONF_UNIT_TIME = [string] [EOL] CONF_UNIT_OF_MEASUREMENT = [string] [EOL] CONF_METHOD = [string] [EOL] [EOL] TRAPEZOIDAL_METHOD = [string] [EOL] LEFT_METHOD = [string] [EOL] RIGHT_METHOD = [string] [EOL] INTEGRATION_METHOD = [ TRAPEZOIDAL_METHOD , LEFT_METHOD , RIGHT_METHOD ] [EOL] [EOL] [comment] [EOL] UNIT_PREFIXES = { None : [number] , [string] : [number] ** [number] , [string] : [number] ** [number] , [string] : [number] ** [number] } [EOL] [EOL] [comment] [EOL] UNIT_TIME = { [string] : [number] , [string] : [number] , [string] : [number] * [number] , [string] : [number] * [number] * [number] } [EOL] [EOL] ICON = [string] [EOL] [EOL] DEFAULT_ROUND = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Required ( CONF_SOURCE_SENSOR ) : cv . entity_id , vol . Optional ( CONF_ROUND_DIGITS , default = DEFAULT_ROUND ) : vol . Coerce ( int ) , vol . Optional ( CONF_UNIT_PREFIX , default = None ) : vol . In ( UNIT_PREFIXES ) , vol . Optional ( CONF_UNIT_TIME , default = [string] ) : vol . In ( UNIT_TIME ) , vol . Optional ( CONF_UNIT_OF_MEASUREMENT ) : cv . string , vol . Optional ( CONF_METHOD , default = TRAPEZOIDAL_METHOD ) : vol . In ( INTEGRATION_METHOD ) , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] integral = IntegrationSensor ( config [ CONF_SOURCE_SENSOR ] , config . get ( CONF_NAME ) , config [ CONF_ROUND_DIGITS ] , config [ CONF_UNIT_PREFIX ] , config [ CONF_UNIT_TIME ] , config . get ( CONF_UNIT_OF_MEASUREMENT ) , config [ CONF_METHOD ] ) [EOL] [EOL] async_add_entities ( [ integral ] ) [EOL] [EOL] [EOL] class IntegrationSensor ( RestoreEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , source_entity , name , round_digits , unit_prefix , unit_time , unit_of_measurement , integration_method ) : [EOL] [docstring] [EOL] self . _sensor_source_id = source_entity [EOL] self . _round_digits = round_digits [EOL] self . _state = [number] [EOL] self . _method = integration_method [EOL] [EOL] self . _name = name if name is not None\ [EOL] else [string] . format ( source_entity ) [EOL] [EOL] if unit_of_measurement is None : [EOL] self . _unit_template = [string] . format ( [string] if unit_prefix is None else unit_prefix , [string] , unit_time ) [EOL] [comment] [EOL] self . _unit_of_measurement = None [EOL] else : [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] [EOL] self . _unit_prefix = UNIT_PREFIXES [ unit_prefix ] [EOL] self . _unit_time = UNIT_TIME [ unit_time ] [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] await super ( ) . async_added_to_hass ( ) [EOL] state = await self . async_get_last_state ( ) [EOL] if state : [EOL] try : [EOL] self . _state = Decimal ( state . state ) [EOL] except ValueError as err : [EOL] _LOGGER . warning ( [string] , err ) [EOL] [EOL] @ callback def calc_integration ( entity , old_state , new_state ) : [EOL] [docstring] [EOL] if old_state is None or old_state . state in [ STATE_UNKNOWN , STATE_UNAVAILABLE ] or new_state . state in [ STATE_UNKNOWN , STATE_UNAVAILABLE ] : [EOL] return [EOL] [EOL] if self . _unit_of_measurement is None : [EOL] unit = new_state . attributes . get ( ATTR_UNIT_OF_MEASUREMENT ) [EOL] self . _unit_of_measurement = self . _unit_template . format ( [string] if unit is None else unit ) [EOL] [EOL] try : [EOL] [comment] [EOL] area = [number] [EOL] elapsed_time = ( new_state . last_updated - old_state . last_updated ) . total_seconds ( ) [EOL] [EOL] if self . _method == TRAPEZOIDAL_METHOD : [EOL] area = ( Decimal ( new_state . state ) + Decimal ( old_state . state ) ) * Decimal ( elapsed_time ) / [number] [EOL] elif self . _method == LEFT_METHOD : [EOL] area = Decimal ( old_state . state ) * Decimal ( elapsed_time ) [EOL] elif self . _method == RIGHT_METHOD : [EOL] area = Decimal ( new_state . state ) * Decimal ( elapsed_time ) [EOL] [EOL] integral = area / ( self . _unit_prefix * self . _unit_time ) [EOL] assert isinstance ( integral , Decimal ) [EOL] except ValueError as err : [EOL] _LOGGER . warning ( [string] , err ) [EOL] except DecimalException as err : [EOL] _LOGGER . warning ( [string] , old_state . state , new_state . state , err ) [EOL] except AssertionError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] else : [EOL] self . _state += integral [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] async_track_state_change ( self . hass , self . _sensor_source_id , calc_integration ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return round ( self . _state , self . _round_digits ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] state_attr = { ATTR_SOURCE_ID : self . _sensor_source_id , } [EOL] return state_attr [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Optional[builtins.str],typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Optional[builtins.str],typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Optional[builtins.str],typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $decimal.Decimal$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Union[decimal.Decimal,builtins.float]$ 0 $decimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[decimal.Decimal,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[decimal.Decimal,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import os [EOL] from functools import partial [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . notify import ( ATTR_TARGET , ATTR_MESSAGE ) [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD , CONF_VERIFY_SSL , CONF_NAME , EVENT_HOMEASSISTANT_STOP , EVENT_HOMEASSISTANT_START ) [EOL] from homeassistant . util . json import load_json , save_json [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SESSION_FILE = [string] [EOL] [EOL] CONF_HOMESERVER = [string] [EOL] CONF_ROOMS = [string] [EOL] CONF_COMMANDS = [string] [EOL] CONF_WORD = [string] [EOL] CONF_EXPRESSION = [string] [EOL] [EOL] EVENT_MATRIX_COMMAND = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] COMMAND_SCHEMA = vol . All ( vol . Schema ( { vol . Exclusive ( CONF_WORD , [string] ) : cv . string , vol . Exclusive ( CONF_EXPRESSION , [string] ) : cv . is_regex , vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_ROOMS , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) , cv . has_at_least_one_key ( CONF_WORD , CONF_EXPRESSION ) ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_HOMESERVER ) : cv . url , vol . Optional ( CONF_VERIFY_SSL , default = True ) : cv . boolean , vol . Required ( CONF_USERNAME ) : cv . matches_regex ( [string] ) , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_ROOMS , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_COMMANDS , default = [ ] ) : [ COMMAND_SCHEMA ] } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] SERVICE_SEND_MESSAGE = [string] [EOL] [EOL] SERVICE_SCHEMA_SEND_MESSAGE = vol . Schema ( { vol . Required ( ATTR_MESSAGE ) : cv . string , vol . Required ( ATTR_TARGET ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] from matrix_client . client import MatrixRequestError [EOL] [EOL] config = config [ DOMAIN ] [EOL] [EOL] try : [EOL] bot = MatrixBot ( hass , os . path . join ( hass . config . path ( ) , SESSION_FILE ) , config [ CONF_HOMESERVER ] , config [ CONF_VERIFY_SSL ] , config [ CONF_USERNAME ] , config [ CONF_PASSWORD ] , config [ CONF_ROOMS ] , config [ CONF_COMMANDS ] ) [EOL] hass . data [ DOMAIN ] = bot [EOL] except MatrixRequestError as exception : [EOL] _LOGGER . error ( [string] , str ( exception ) ) [EOL] return False [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_SEND_MESSAGE , bot . handle_send_message , schema = SERVICE_SCHEMA_SEND_MESSAGE ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class MatrixBot : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config_file , homeserver , verify_ssl , username , password , listening_rooms , commands ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] [EOL] self . _session_filepath = config_file [EOL] self . _auth_tokens = self . _get_auth_tokens ( ) [EOL] [EOL] self . _homeserver = homeserver [EOL] self . _verify_tls = verify_ssl [EOL] self . _mx_id = username [EOL] self . _password = password [EOL] [EOL] self . _listening_rooms = listening_rooms [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _aliases_fetched_for = set ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _word_commands = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _expression_commands = { } [EOL] [EOL] for command in commands : [EOL] if not command . get ( CONF_ROOMS ) : [EOL] command [ CONF_ROOMS ] = listening_rooms [EOL] [EOL] if command . get ( CONF_WORD ) : [EOL] for room_id in command [ CONF_ROOMS ] : [EOL] if room_id not in self . _word_commands : [EOL] self . _word_commands [ room_id ] = { } [EOL] self . _word_commands [ room_id ] [ command [ CONF_WORD ] ] = command [EOL] else : [EOL] for room_id in command [ CONF_ROOMS ] : [EOL] if room_id not in self . _expression_commands : [EOL] self . _expression_commands [ room_id ] = [ ] [EOL] self . _expression_commands [ room_id ] . append ( command ) [EOL] [EOL] [comment] [EOL] self . _client = self . _login ( ) [EOL] [EOL] def handle_matrix_exception ( exception ) : [EOL] [docstring] [EOL] _LOGGER . error ( [string] , str ( exception ) ) [EOL] [EOL] self . _client . start_listener_thread ( exception_handler = handle_matrix_exception ) [EOL] [EOL] def stop_client ( _ ) : [EOL] [docstring] [EOL] self . _client . stop_listener_thread ( ) [EOL] [EOL] self . hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , stop_client ) [EOL] [EOL] [comment] [EOL] def handle_startup ( _ ) : [EOL] [docstring] [EOL] self . _join_rooms ( ) [EOL] [EOL] self . hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , handle_startup ) [EOL] [EOL] def _handle_room_message ( self , room_id , room , event ) : [EOL] [docstring] [EOL] if event [ [string] ] [ [string] ] != [string] : [EOL] return [EOL] [EOL] if event [ [string] ] == self . _mx_id : [EOL] return [EOL] [EOL] _LOGGER . debug ( [string] , event [ [string] ] [ [string] ] ) [EOL] [EOL] if event [ [string] ] [ [string] ] [ [number] ] == [string] : [EOL] [comment] [EOL] pieces = event [ [string] ] [ [string] ] . split ( [string] ) [EOL] cmd = pieces [ [number] ] [ [number] : ] [EOL] [EOL] command = self . _word_commands . get ( room_id , { } ) . get ( cmd ) [EOL] if command : [EOL] event_data = { [string] : command [ CONF_NAME ] , [string] : event [ [string] ] , [string] : room_id , [string] : pieces [ [number] : ] } [EOL] self . hass . bus . fire ( EVENT_MATRIX_COMMAND , event_data ) [EOL] [EOL] [comment] [EOL] for command in self . _expression_commands . get ( room_id , [ ] ) : [EOL] match = command [ CONF_EXPRESSION ] . match ( event [ [string] ] [ [string] ] ) [EOL] if not match : [EOL] continue [EOL] event_data = { [string] : command [ CONF_NAME ] , [string] : event [ [string] ] , [string] : room_id , [string] : match . groupdict ( ) } [EOL] self . hass . bus . fire ( EVENT_MATRIX_COMMAND , event_data ) [EOL] [EOL] def _join_or_get_room ( self , room_id_or_alias ) : [EOL] [docstring] [EOL] rooms = self . _client . get_rooms ( ) [EOL] if room_id_or_alias in rooms : [EOL] _LOGGER . debug ( [string] , room_id_or_alias ) [EOL] return rooms [ room_id_or_alias ] [EOL] [EOL] for room in rooms . values ( ) : [EOL] if room . room_id not in self . _aliases_fetched_for : [EOL] room . update_aliases ( ) [EOL] self . _aliases_fetched_for . add ( room . room_id ) [EOL] [EOL] if room_id_or_alias in room . aliases : [EOL] _LOGGER . debug ( [string] , room . room_id , room_id_or_alias ) [EOL] return room [EOL] [EOL] room = self . _client . join_room ( room_id_or_alias ) [EOL] _LOGGER . info ( [string] , room . room_id , room_id_or_alias ) [EOL] return room [EOL] [EOL] def _join_rooms ( self ) : [EOL] [docstring] [EOL] from matrix_client . client import MatrixRequestError [EOL] [EOL] for room_id in self . _listening_rooms : [EOL] try : [EOL] room = self . _join_or_get_room ( room_id ) [EOL] room . add_listener ( partial ( self . _handle_room_message , room_id ) , [string] ) [EOL] [EOL] except MatrixRequestError as ex : [EOL] _LOGGER . error ( [string] , room_id , ex ) [EOL] [EOL] def _get_auth_tokens ( self ) : [EOL] [docstring] [EOL] try : [EOL] auth_tokens = load_json ( self . _session_filepath ) [EOL] [EOL] return auth_tokens [EOL] except HomeAssistantError as ex : [EOL] _LOGGER . warning ( [string] , self . _session_filepath , str ( ex ) ) [EOL] return { } [EOL] [EOL] def _store_auth_token ( self , token ) : [EOL] [docstring] [EOL] self . _auth_tokens [ self . _mx_id ] = token [EOL] [EOL] save_json ( self . _session_filepath , self . _auth_tokens ) [EOL] [EOL] def _login ( self ) : [EOL] [docstring] [EOL] from matrix_client . client import MatrixRequestError [EOL] [EOL] [comment] [EOL] [comment] [EOL] client = None [EOL] [EOL] [comment] [EOL] if self . _mx_id in self . _auth_tokens : [EOL] try : [EOL] client = self . _login_by_token ( ) [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] except MatrixRequestError as ex : [EOL] _LOGGER . warning ( [string] [string] , ex . code , ex . content ) [EOL] [EOL] [comment] [EOL] if not client : [EOL] try : [EOL] client = self . _login_by_password ( ) [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] except MatrixRequestError as ex : [EOL] _LOGGER . error ( [string] [string] , ex . code , ex . content ) [EOL] [EOL] [comment] [EOL] raise [EOL] [EOL] return client [EOL] [EOL] def _login_by_token ( self ) : [EOL] [docstring] [EOL] from matrix_client . client import MatrixClient [EOL] [EOL] return MatrixClient ( base_url = self . _homeserver , token = self . _auth_tokens [ self . _mx_id ] , user_id = self . _mx_id , valid_cert_check = self . _verify_tls ) [EOL] [EOL] def _login_by_password ( self ) : [EOL] [docstring] [EOL] from matrix_client . client import MatrixClient [EOL] [EOL] _client = MatrixClient ( base_url = self . _homeserver , valid_cert_check = self . _verify_tls ) [EOL] [EOL] _client . login_with_password ( self . _mx_id , self . _password ) [EOL] [EOL] self . _store_auth_token ( _client . token ) [EOL] [EOL] return _client [EOL] [EOL] def _send_message ( self , message , target_rooms ) : [EOL] [docstring] [EOL] from matrix_client . client import MatrixRequestError [EOL] [EOL] for target_room in target_rooms : [EOL] try : [EOL] room = self . _join_or_get_room ( target_room ) [EOL] _LOGGER . debug ( room . send_text ( message ) ) [EOL] except MatrixRequestError as ex : [EOL] _LOGGER . error ( [string] , target_room , ex . code , ex . content ) [EOL] [EOL] def handle_send_message ( self , service ) : [EOL] [docstring] [EOL] self . _send_message ( service . data [ ATTR_MESSAGE ] , service . data [ ATTR_TARGET ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] try : [EOL] import av [EOL] except ImportError : [EOL] av = None [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] if av is None : [EOL] return True [EOL] [EOL] return await async_setup_component ( hass , [string] , config ) [EOL]	0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Set , Any [EOL] import typing [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import config_entries [EOL] from homeassistant . const import ( CONF_API_KEY , CONF_HOST , CONF_PORT , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] [comment] [EOL] from . config_flow import get_master_gateway [EOL] from . const import ( CONF_ALLOW_CLIP_SENSOR , CONF_ALLOW_DECONZ_GROUPS , CONF_BRIDGEID , CONF_MASTER_GATEWAY , DEFAULT_PORT , DOMAIN , _LOGGER ) [EOL] from . gateway import DeconzGateway [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Optional ( CONF_API_KEY ) : cv . string , vol . Optional ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] SERVICE_DECONZ = [string] [EOL] [EOL] SERVICE_FIELD = [string] [EOL] SERVICE_ENTITY = [string] [EOL] SERVICE_DATA = [string] [EOL] [EOL] SERVICE_SCHEMA = vol . All ( vol . Schema ( { vol . Optional ( SERVICE_ENTITY ) : cv . entity_id , vol . Optional ( SERVICE_FIELD ) : cv . matches_regex ( [string] ) , vol . Required ( SERVICE_DATA ) : dict , vol . Optional ( CONF_BRIDGEID ) : str } ) , cv . has_at_least_one_key ( SERVICE_ENTITY , SERVICE_FIELD ) ) [EOL] [EOL] SERVICE_DEVICE_REFRESH = [string] [EOL] [EOL] SERVICE_DEVICE_REFRESCH_SCHEMA = vol . All ( vol . Schema ( { vol . Optional ( CONF_BRIDGEID ) : str } ) ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] if not hass . config_entries . async_entries ( DOMAIN ) and DOMAIN in config : [EOL] deconz_config = config [ DOMAIN ] [EOL] hass . async_create_task ( hass . config_entries . flow . async_init ( DOMAIN , context = { [string] : config_entries . SOURCE_IMPORT } , data = deconz_config ) ) [EOL] return True [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry ) : [EOL] [docstring] [EOL] if DOMAIN not in hass . data : [EOL] hass . data [ DOMAIN ] = { } [EOL] [EOL] if not config_entry . options : [EOL] await async_populate_options ( hass , config_entry ) [EOL] [EOL] gateway = DeconzGateway ( hass , config_entry ) [EOL] [EOL] if not await gateway . async_setup ( ) : [EOL] return False [EOL] [EOL] hass . data [ DOMAIN ] [ gateway . bridgeid ] = gateway [EOL] [EOL] await gateway . async_update_device_registry ( ) [EOL] [EOL] async def async_configure ( call ) : [EOL] [docstring] [EOL] field = call . data . get ( SERVICE_FIELD , [string] ) [EOL] entity_id = call . data . get ( SERVICE_ENTITY ) [EOL] data = call . data [ SERVICE_DATA ] [EOL] [EOL] gateway = get_master_gateway ( hass ) [EOL] if CONF_BRIDGEID in call . data : [EOL] gateway = hass . data [ DOMAIN ] [ call . data [ CONF_BRIDGEID ] ] [EOL] [EOL] if entity_id : [EOL] try : [EOL] field = gateway . deconz_ids [ entity_id ] + field [EOL] except KeyError : [EOL] _LOGGER . error ( [string] , entity_id ) [EOL] return [EOL] [EOL] await gateway . api . async_put_state ( field , data ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_DECONZ , async_configure , schema = SERVICE_SCHEMA ) [EOL] [EOL] async def async_refresh_devices ( call ) : [EOL] [docstring] [EOL] gateway = get_master_gateway ( hass ) [EOL] if CONF_BRIDGEID in call . data : [EOL] gateway = hass . data [ DOMAIN ] [ call . data [ CONF_BRIDGEID ] ] [EOL] [EOL] groups = set ( gateway . api . groups . keys ( ) ) [EOL] lights = set ( gateway . api . lights . keys ( ) ) [EOL] scenes = set ( gateway . api . scenes . keys ( ) ) [EOL] sensors = set ( gateway . api . sensors . keys ( ) ) [EOL] [EOL] await gateway . api . async_load_parameters ( ) [EOL] [EOL] gateway . async_add_device_callback ( [string] , [ group for group_id , group in gateway . api . groups . items ( ) if group_id not in groups ] ) [EOL] [EOL] gateway . async_add_device_callback ( [string] , [ light for light_id , light in gateway . api . lights . items ( ) if light_id not in lights ] ) [EOL] [EOL] gateway . async_add_device_callback ( [string] , [ scene for scene_id , scene in gateway . api . scenes . items ( ) if scene_id not in scenes ] ) [EOL] [EOL] gateway . async_add_device_callback ( [string] , [ sensor for sensor_id , sensor in gateway . api . sensors . items ( ) if sensor_id not in sensors ] ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_DEVICE_REFRESH , async_refresh_devices , schema = SERVICE_DEVICE_REFRESCH_SCHEMA ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , gateway . shutdown ) [EOL] return True [EOL] [EOL] [EOL] async def async_unload_entry ( hass , config_entry ) : [EOL] [docstring] [EOL] gateway = hass . data [ DOMAIN ] . pop ( config_entry . data [ CONF_BRIDGEID ] ) [EOL] [EOL] if not hass . data [ DOMAIN ] : [EOL] hass . services . async_remove ( DOMAIN , SERVICE_DECONZ ) [EOL] hass . services . async_remove ( DOMAIN , SERVICE_DEVICE_REFRESH ) [EOL] [EOL] elif gateway . master : [EOL] await async_populate_options ( hass , config_entry ) [EOL] new_master_gateway = next ( iter ( hass . data [ DOMAIN ] . values ( ) ) ) [EOL] await async_populate_options ( hass , new_master_gateway . config_entry ) [EOL] [EOL] return await gateway . async_reset ( ) [EOL] [EOL] [EOL] async def async_populate_options ( hass , config_entry ) : [EOL] [docstring] [EOL] master = not get_master_gateway ( hass ) [EOL] [EOL] options = { CONF_MASTER_GATEWAY : master , CONF_ALLOW_CLIP_SENSOR : config_entry . data . get ( CONF_ALLOW_CLIP_SENSOR , False ) , CONF_ALLOW_DECONZ_GROUPS : config_entry . data . get ( CONF_ALLOW_DECONZ_GROUPS , True ) } [EOL] [EOL] hass . config_entries . async_update_entry ( config_entry , options = options ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] [EOL] from . const import NEW_LIGHT , POWER_PLUGS , SIRENS [EOL] from . deconz_device import DeconzDevice [EOL] from . gateway import get_gateway_from_config_entry [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_entities ) : [EOL] [docstring] [EOL] gateway = get_gateway_from_config_entry ( hass , config_entry ) [EOL] [EOL] @ callback def async_add_switch ( lights ) : [EOL] [docstring] [EOL] entities = [ ] [EOL] [EOL] for light in lights : [EOL] [EOL] if light . type in POWER_PLUGS : [EOL] entities . append ( DeconzPowerPlug ( light , gateway ) ) [EOL] [EOL] elif light . type in SIRENS : [EOL] entities . append ( DeconzSiren ( light , gateway ) ) [EOL] [EOL] async_add_entities ( entities , True ) [EOL] [EOL] gateway . listeners . append ( async_dispatcher_connect ( hass , gateway . async_event_new_device ( NEW_LIGHT ) , async_add_switch ) ) [EOL] [EOL] async_add_switch ( gateway . api . lights . values ( ) ) [EOL] [EOL] [EOL] class DeconzPowerPlug ( DeconzDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _device . state [EOL] [EOL] async def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { [string] : True } [EOL] await self . _device . async_set_state ( data ) [EOL] [EOL] async def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { [string] : False } [EOL] await self . _device . async_set_state ( data ) [EOL] [EOL] [EOL] class DeconzSiren ( DeconzDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _device . alert == [string] [EOL] [EOL] async def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { [string] : [string] } [EOL] await self . _device . async_set_state ( data ) [EOL] [EOL] async def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] data = { [string] : [string] } [EOL] await self . _device . async_set_state ( data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0
from typing import Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] _LOGGER = logging . getLogger ( [string] ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_ALLOW_CLIP_SENSOR = False [EOL] DEFAULT_ALLOW_DECONZ_GROUPS = False [EOL] [EOL] CONF_ALLOW_CLIP_SENSOR = [string] [EOL] CONF_ALLOW_DECONZ_GROUPS = [string] [EOL] CONF_BRIDGEID = [string] [EOL] CONF_MASTER_GATEWAY = [string] [EOL] [EOL] SUPPORTED_PLATFORMS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] NEW_GROUP = [string] [EOL] NEW_LIGHT = [string] [EOL] NEW_SCENE = [string] [EOL] NEW_SENSOR = [string] [EOL] [EOL] NEW_DEVICE = { NEW_GROUP : [string] , NEW_LIGHT : [string] , NEW_SCENE : [string] , NEW_SENSOR : [string] } [EOL] [EOL] ATTR_DARK = [string] [EOL] ATTR_OFFSET = [string] [EOL] ATTR_ON = [string] [EOL] ATTR_VALVE = [string] [EOL] [EOL] DAMPERS = [ [string] ] [EOL] WINDOW_COVERS = [ [string] ] [EOL] COVER_TYPES = DAMPERS + WINDOW_COVERS [EOL] [EOL] POWER_PLUGS = [ [string] , [string] ] [EOL] SIRENS = [ [string] ] [EOL] SWITCH_TYPES = POWER_PLUGS + SIRENS [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class DeconzException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AlreadyConfigured ( DeconzException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( DeconzException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( DeconzException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] config_entry_flow . register_webhook_flow ( DOMAIN , [string] , { [string] : [string] , [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_HASS = [string] [EOL] KEY_HASS_USER = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import aiohttp [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_API_KEY , CONF_MONITORED_CONDITIONS , CONF_NAME , DEVICE_CLASS_HUMIDITY , DEVICE_CLASS_TEMPERATURE , TEMP_CELSIUS ) [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTRIBUTION = [string] [EOL] ATTR_MEASURE_TIME = [string] [EOL] ATTR_ACTIVE = [string] [EOL] [EOL] CONF_STATION = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , TEMP_CELSIUS , [string] , [string] , DEVICE_CLASS_TEMPERATURE ] , [string] : [ [string] , TEMP_CELSIUS , [string] , [string] , DEVICE_CLASS_TEMPERATURE ] , [string] : [ [string] , None , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , [string] , None ] , [string] : [ [string] , None , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , [string] , DEVICE_CLASS_HUMIDITY ] , [string] : [ [string] , [string] , [string] , [string] , None ] , [string] : [ [string] , None , [string] , [string] , None ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_STATION ) : cv . string , vol . Required ( CONF_MONITORED_CONDITIONS , default = [ ] ) : [ vol . In ( SENSOR_TYPES ) ] , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pytrafikverket . trafikverket_weather import TrafikverketWeather [EOL] [EOL] sensor_name = config [ CONF_NAME ] [EOL] sensor_api = config [ CONF_API_KEY ] [EOL] sensor_station = config [ CONF_STATION ] [EOL] [EOL] web_session = async_get_clientsession ( hass ) [EOL] [EOL] weather_api = TrafikverketWeather ( web_session , sensor_api ) [EOL] [EOL] dev = [ ] [EOL] for condition in config [ CONF_MONITORED_CONDITIONS ] : [EOL] dev . append ( TrafikverketWeatherStation ( weather_api , sensor_name , condition , sensor_station ) ) [EOL] [EOL] if dev : [EOL] async_add_entities ( dev , True ) [EOL] [EOL] [EOL] class TrafikverketWeatherStation ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , weather_api , name , sensor_type , sensor_station ) : [EOL] [docstring] [EOL] self . _client = name [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _type = sensor_type [EOL] self . _state = None [EOL] self . _unit = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _station = sensor_station [EOL] self . _weather_api = weather_api [EOL] self . _icon = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _device_class = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _weather = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _client , self . _name ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : ATTRIBUTION , ATTR_ACTIVE : self . _weather . active , ATTR_MEASURE_TIME : self . _weather . measure_time , } [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) async def async_update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _weather = await self . _weather_api . async_get_weather ( self . _station ) [EOL] self . _state = getattr ( self . _weather , SENSOR_TYPES [ self . _type ] [ [number] ] ) [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError , ValueError ) as error : [EOL] _LOGGER . error ( [string] , error ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import PLATFORM_SCHEMA [EOL] from homeassistant . const import DEVICE_DEFAULT_NAME [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_INVERT_LOGIC = [string] [EOL] CONF_I2C_ADDRESS = [string] [EOL] CONF_PINS = [string] [EOL] CONF_PULL_MODE = [string] [EOL] [EOL] DEFAULT_INVERT_LOGIC = False [EOL] DEFAULT_I2C_ADDRESS = [number] [EOL] [EOL] _SWITCHES_SCHEMA = vol . Schema ( { cv . positive_int : cv . string , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_PINS ) : _SWITCHES_SCHEMA , vol . Optional ( CONF_INVERT_LOGIC , default = DEFAULT_INVERT_LOGIC ) : cv . boolean , vol . Optional ( CONF_I2C_ADDRESS , default = DEFAULT_I2C_ADDRESS ) : vol . Coerce ( int ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import board [EOL] import busio [EOL] import adafruit_mcp230xx [EOL] [EOL] invert_logic = config . get ( CONF_INVERT_LOGIC ) [EOL] i2c_address = config . get ( CONF_I2C_ADDRESS ) [EOL] [EOL] i2c = busio . I2C ( board . SCL , board . SDA ) [EOL] mcp = adafruit_mcp230xx . MCP23017 ( i2c , address = i2c_address ) [EOL] [EOL] switches = [ ] [EOL] pins = config . get ( CONF_PINS ) [EOL] for pin_num , pin_name in pins . items ( ) : [EOL] pin = mcp . get_pin ( pin_num ) [EOL] switches . append ( MCP23017Switch ( pin_name , pin , invert_logic ) ) [EOL] add_entities ( switches ) [EOL] [EOL] [EOL] class MCP23017Switch ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , pin , invert_logic ) : [EOL] [docstring] [EOL] import digitalio [EOL] self . _name = name or DEVICE_DEFAULT_NAME [EOL] self . _pin = pin [EOL] self . _invert_logic = invert_logic [EOL] self . _state = False [EOL] [EOL] self . _pin . direction = digitalio . Direction . OUTPUT [EOL] self . _pin . value = self . _invert_logic [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _pin . value = not self . _invert_logic [EOL] self . _state = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _pin . value = self . _invert_logic [EOL] self . _state = False [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . tts import CONF_LANG , PLATFORM_SCHEMA , Provider [EOL] from homeassistant . const import CONF_API_KEY [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] YANDEX_API_URL = [string] [EOL] [EOL] SUPPORT_LANGUAGES = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] SUPPORT_CODECS = [ [string] , [string] , [string] , ] [EOL] [EOL] SUPPORT_VOICES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] SUPPORTED_EMOTION = [ [string] , [string] , [string] ] [EOL] [EOL] MIN_SPEED = [number] [EOL] MAX_SPEED = [number] [EOL] [EOL] CONF_CODEC = [string] [EOL] CONF_VOICE = [string] [EOL] CONF_EMOTION = [string] [EOL] CONF_SPEED = [string] [EOL] [EOL] DEFAULT_LANG = [string] [EOL] DEFAULT_CODEC = [string] [EOL] DEFAULT_VOICE = [string] [EOL] DEFAULT_EMOTION = [string] [EOL] DEFAULT_SPEED = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Optional ( CONF_LANG , default = DEFAULT_LANG ) : vol . In ( SUPPORT_LANGUAGES ) , vol . Optional ( CONF_CODEC , default = DEFAULT_CODEC ) : vol . In ( SUPPORT_CODECS ) , vol . Optional ( CONF_VOICE , default = DEFAULT_VOICE ) : vol . In ( SUPPORT_VOICES ) , vol . Optional ( CONF_EMOTION , default = DEFAULT_EMOTION ) : vol . In ( SUPPORTED_EMOTION ) , vol . Optional ( CONF_SPEED , default = DEFAULT_SPEED ) : vol . Range ( min = MIN_SPEED , max = MAX_SPEED ) } ) [EOL] [EOL] SUPPORTED_OPTIONS = [ CONF_CODEC , CONF_VOICE , CONF_EMOTION , CONF_SPEED , ] [EOL] [EOL] [EOL] async def async_get_engine ( hass , config ) : [EOL] [docstring] [EOL] return YandexSpeechKitProvider ( hass , config ) [EOL] [EOL] [EOL] class YandexSpeechKitProvider ( Provider ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , conf ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _codec = conf . get ( CONF_CODEC ) [EOL] self . _key = conf . get ( CONF_API_KEY ) [EOL] self . _speaker = conf . get ( CONF_VOICE ) [EOL] self . _language = conf . get ( CONF_LANG ) [EOL] self . _emotion = conf . get ( CONF_EMOTION ) [EOL] self . _speed = str ( conf . get ( CONF_SPEED ) ) [EOL] self . name = [string] [EOL] [EOL] @ property def default_language ( self ) : [EOL] [docstring] [EOL] return self . _language [EOL] [EOL] @ property def supported_languages ( self ) : [EOL] [docstring] [EOL] return SUPPORT_LANGUAGES [EOL] [EOL] @ property def supported_options ( self ) : [EOL] [docstring] [EOL] return SUPPORTED_OPTIONS [EOL] [EOL] async def async_get_tts_audio ( self , message , language , options = None ) : [EOL] [docstring] [EOL] websession = async_get_clientsession ( self . hass ) [EOL] actual_language = language [EOL] options = options or { } [EOL] [EOL] try : [EOL] with async_timeout . timeout ( [number] ) : [EOL] url_param = { [string] : message , [string] : actual_language , [string] : self . _key , [string] : options . get ( CONF_VOICE , self . _speaker ) , [string] : options . get ( CONF_CODEC , self . _codec ) , [string] : options . get ( CONF_EMOTION , self . _emotion ) , [string] : options . get ( CONF_SPEED , self . _speed ) } [EOL] [EOL] request = await websession . get ( YANDEX_API_URL , params = url_param ) [EOL] [EOL] if request . status != [number] : [EOL] _LOGGER . error ( [string] , request . status , request . url ) [EOL] return ( None , None ) [EOL] data = await request . read ( ) [EOL] [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . error ( [string] ) [EOL] return ( None , None ) [EOL] [EOL] return ( self . _codec , data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import socket [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_LATITUDE , ATTR_LONGITUDE , CONF_HOST , CONF_PORT , CONF_NAME ) [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_CLIMB = [string] [EOL] ATTR_ELEVATION = [string] [EOL] ATTR_GPS_TIME = [string] [EOL] ATTR_MODE = [string] [EOL] ATTR_SPEED = [string] [EOL] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import socket [EOL] [EOL] sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] try : [EOL] sock . connect ( ( host , port ) ) [EOL] sock . shutdown ( [number] ) [EOL] _LOGGER . debug ( [string] ) [EOL] except socket . error : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] add_entities ( [ GpsdSensor ( hass , name , host , port ) ] ) [EOL] [EOL] [EOL] class GpsdSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , host , port ) : [EOL] [docstring] [EOL] from gps3 . agps3threaded import AGPS3mechanism [EOL] [EOL] self . hass = hass [EOL] self . _name = name [EOL] self . _host = host [EOL] self . _port = port [EOL] [EOL] self . agps_thread = AGPS3mechanism ( ) [EOL] self . agps_thread . stream_data ( host = self . _host , port = self . _port ) [EOL] self . agps_thread . run_thread ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . agps_thread . data_stream . mode == [number] : [EOL] return [string] [EOL] if self . agps_thread . data_stream . mode == [number] : [EOL] return [string] [EOL] return None [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_LATITUDE : self . agps_thread . data_stream . lat , ATTR_LONGITUDE : self . agps_thread . data_stream . lon , ATTR_ELEVATION : self . agps_thread . data_stream . alt , ATTR_GPS_TIME : self . agps_thread . data_stream . time , ATTR_SPEED : self . agps_thread . data_stream . speed , ATTR_CLIMB : self . agps_thread . data_stream . climb , ATTR_MODE : self . agps_thread . data_stream . mode , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] CONF_SERVERS = [string] [EOL] CONF_LISTEN_PORT = [string] [EOL] CONF_HOST_IP = [string] [EOL] CONF_ADVERTISE_IP = [string] [EOL] CONF_ADVERTISE_PORT = [string] [EOL] CONF_UPNP_BIND_MULTICAST = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from homeassistant . const import CONF_HOST [comment] [EOL] [EOL] CONF_IMPORT_GROUPS = [string] [EOL] CONF_IDENTITY = [string] [EOL] CONF_KEY = [string] [EOL] CONF_GATEWAY_ID = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import threading [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import time [EOL] from socket import timeout [EOL] from threading import Lock [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . discovery import load_platform [EOL] from homeassistant . const import CONF_HOST , CONF_PORT , CONF_SCAN_INTERVAL [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_PORT = [number] [EOL] DOMAIN = [string] [EOL] [EOL] DATA_KEY = [string] [EOL] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] CONF_GATEWAYS = [string] [EOL] [EOL] CONFIG_GATEWAY = vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_SCAN_INTERVAL , default = [number] ) : cv . time_period , } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_GATEWAYS , default = { } ) : vol . All ( cv . ensure_list , [ CONFIG_GATEWAY ] ) , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] from maxcube . connection import MaxCubeConnection [EOL] from maxcube . cube import MaxCube [EOL] if DATA_KEY not in hass . data : [EOL] hass . data [ DATA_KEY ] = { } [EOL] [EOL] connection_failed = [number] [EOL] gateways = config [ DOMAIN ] [ CONF_GATEWAYS ] [EOL] for gateway in gateways : [EOL] host = gateway [ CONF_HOST ] [EOL] port = gateway [ CONF_PORT ] [EOL] scan_interval = gateway [ CONF_SCAN_INTERVAL ] . total_seconds ( ) [EOL] [EOL] try : [EOL] cube = MaxCube ( MaxCubeConnection ( host , port ) ) [EOL] hass . data [ DATA_KEY ] [ host ] = MaxCubeHandle ( cube , scan_interval ) [EOL] except timeout as ex : [EOL] _LOGGER . error ( [string] , str ( ex ) ) [EOL] hass . components . persistent_notification . create ( [string] [string] [string] . format ( ex ) , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] connection_failed += [number] [EOL] [EOL] if connection_failed >= len ( gateways ) : [EOL] return False [EOL] [EOL] load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class MaxCubeHandle : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cube , scan_interval ) : [EOL] [docstring] [EOL] self . cube = cube [EOL] self . scan_interval = scan_interval [EOL] self . mutex = Lock ( ) [EOL] self . _updatets = time . time ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] with self . mutex : [EOL] [comment] [EOL] if ( time . time ( ) - self . _updatets ) >= self . scan_interval : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] try : [EOL] self . cube . update ( ) [EOL] except timeout : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] self . _updatets = time . time ( ) [EOL] else : [EOL] _LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] config_entry_flow . register_webhook_flow ( DOMAIN , [string] , { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import config_entries [EOL] from homeassistant . config_entries import ConfigEntry [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . core import HomeAssistant [EOL] from homeassistant . helpers import device_registry as dr [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . typing import ConfigType [EOL] [EOL] from . config_flow import configured_haps [EOL] from . const import ( CONF_ACCESSPOINT , CONF_AUTHTOKEN , DOMAIN , HMIPC_AUTHTOKEN , HMIPC_HAPID , HMIPC_NAME ) [EOL] from . device import HomematicipGenericDevice [comment] [EOL] from . hap import HomematicipAuth , HomematicipHAP [comment] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { vol . Optional ( DOMAIN , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . Schema ( { vol . Optional ( CONF_NAME , default = [string] ) : vol . Any ( cv . string ) , vol . Required ( CONF_ACCESSPOINT ) : cv . string , vol . Required ( CONF_AUTHTOKEN ) : cv . string , } ) ] ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] hass . data [ DOMAIN ] = { } [EOL] [EOL] accesspoints = config . get ( DOMAIN , [ ] ) [EOL] [EOL] for conf in accesspoints : [EOL] if conf [ CONF_ACCESSPOINT ] not in configured_haps ( hass ) : [EOL] hass . async_add_job ( hass . config_entries . flow . async_init ( DOMAIN , context = { [string] : config_entries . SOURCE_IMPORT } , data = { HMIPC_HAPID : conf [ CONF_ACCESSPOINT ] , HMIPC_AUTHTOKEN : conf [ CONF_AUTHTOKEN ] , HMIPC_NAME : conf [ CONF_NAME ] , } ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry ) : [EOL] [docstring] [EOL] hap = HomematicipHAP ( hass , entry ) [EOL] hapid = entry . data [ HMIPC_HAPID ] . replace ( [string] , [string] ) . upper ( ) [EOL] hass . data [ DOMAIN ] [ hapid ] = hap [EOL] [EOL] if not await hap . async_setup ( ) : [EOL] return False [EOL] [EOL] [comment] [EOL] device_registry = await dr . async_get_registry ( hass ) [EOL] home = hap . home [EOL] [comment] [EOL] hapname = home . label \ [EOL] if not home . name else [string] . format ( home . label , home . name ) [EOL] device_registry . async_get_or_create ( config_entry_id = home . id , identifiers = { ( DOMAIN , home . id ) } , manufacturer = [string] , name = hapname , model = home . modelType , sw_version = home . currentAPVersion , ) [EOL] return True [EOL] [EOL] [EOL] async def async_unload_entry ( hass , entry ) : [EOL] [docstring] [EOL] hap = hass . data [ DOMAIN ] . pop ( entry . data [ HMIPC_HAPID ] ) [EOL] return await hap . async_reset ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] from typing import Optional [EOL] [EOL] from homematicip . aio . device import AsyncFullFlushShutter [EOL] [EOL] from homeassistant . components . cover import ATTR_POSITION , CoverDevice [EOL] from homeassistant . config_entries import ConfigEntry [EOL] from homeassistant . core import HomeAssistant [EOL] [EOL] from . import DOMAIN as HMIPC_DOMAIN , HMIPC_HAPID , HomematicipGenericDevice [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] HMIP_COVER_OPEN = [number] [EOL] HMIP_COVER_CLOSED = [number] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_entities ) : [EOL] [docstring] [EOL] home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home [EOL] devices = [ ] [EOL] for device in home . devices : [EOL] if isinstance ( device , AsyncFullFlushShutter ) : [EOL] devices . append ( HomematicipCoverShutter ( home , device ) ) [EOL] [EOL] if devices : [EOL] async_add_entities ( devices ) [EOL] [EOL] [EOL] class HomematicipCoverShutter ( HomematicipGenericDevice , CoverDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def current_cover_position ( self ) : [EOL] [docstring] [EOL] return int ( ( [number] - self . _device . shutterLevel ) * [number] ) [EOL] [EOL] async def async_set_cover_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] position = kwargs [ ATTR_POSITION ] [EOL] [comment] [EOL] level = [number] - position / [number] [EOL] await self . _device . set_shutter_level ( level ) [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] if self . _device . shutterLevel is not None : [EOL] return self . _device . shutterLevel == HMIP_COVER_CLOSED [EOL] return None [EOL] [EOL] async def async_open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] await self . _device . set_shutter_level ( HMIP_COVER_OPEN ) [EOL] [EOL] async def async_close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] await self . _device . set_shutter_level ( HMIP_COVER_CLOSED ) [EOL] [EOL] async def async_stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] await self . _device . set_shutter_stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Optional[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import homeassistant [EOL] import logging [EOL] import typing [EOL] import homematicip [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homematicip . aio . device import ( AsyncBrandSwitchMeasuring , AsyncFullFlushSwitchMeasuring , AsyncHeatingThermostat , AsyncHeatingThermostatCompact , AsyncLightSensor , AsyncMotionDetectorIndoor , AsyncMotionDetectorOutdoor , AsyncMotionDetectorPushButton , AsyncPlugableSwitchMeasuring , AsyncPresenceDetectorIndoor , AsyncTemperatureHumiditySensorDisplay , AsyncTemperatureHumiditySensorOutdoor , AsyncTemperatureHumiditySensorWithoutDisplay , AsyncWeatherSensor , AsyncWeatherSensorPlus , AsyncWeatherSensorPro ) [EOL] from homematicip . aio . home import AsyncHome [EOL] from homematicip . base . enums import ValveState [EOL] [EOL] from homeassistant . config_entries import ConfigEntry [EOL] from homeassistant . const import ( DEVICE_CLASS_HUMIDITY , DEVICE_CLASS_ILLUMINANCE , DEVICE_CLASS_POWER , DEVICE_CLASS_TEMPERATURE , POWER_WATT , TEMP_CELSIUS ) [EOL] from homeassistant . core import HomeAssistant [EOL] [EOL] from . import DOMAIN as HMIPC_DOMAIN , HMIPC_HAPID , HomematicipGenericDevice [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_TEMPERATURE_OFFSET = [string] [EOL] ATTR_WIND_DIRECTION = [string] [EOL] ATTR_WIND_DIRECTION_VARIATION = [string] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry , async_add_entities ) : [EOL] [docstring] [EOL] home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home [EOL] devices = [ HomematicipAccesspointStatus ( home ) ] [EOL] for device in home . devices : [EOL] if isinstance ( device , ( AsyncHeatingThermostat , AsyncHeatingThermostatCompact ) ) : [EOL] devices . append ( HomematicipHeatingThermostat ( home , device ) ) [EOL] devices . append ( HomematicipTemperatureSensor ( home , device ) ) [EOL] if isinstance ( device , ( AsyncTemperatureHumiditySensorDisplay , AsyncTemperatureHumiditySensorWithoutDisplay , AsyncTemperatureHumiditySensorOutdoor , AsyncWeatherSensor , AsyncWeatherSensorPlus , AsyncWeatherSensorPro ) ) : [EOL] devices . append ( HomematicipTemperatureSensor ( home , device ) ) [EOL] devices . append ( HomematicipHumiditySensor ( home , device ) ) [EOL] if isinstance ( device , ( AsyncLightSensor , AsyncMotionDetectorIndoor , AsyncMotionDetectorOutdoor , AsyncMotionDetectorPushButton , AsyncPresenceDetectorIndoor , AsyncWeatherSensor , AsyncWeatherSensorPlus , AsyncWeatherSensorPro ) ) : [EOL] devices . append ( HomematicipIlluminanceSensor ( home , device ) ) [EOL] if isinstance ( device , ( AsyncPlugableSwitchMeasuring , AsyncBrandSwitchMeasuring , AsyncFullFlushSwitchMeasuring ) ) : [EOL] devices . append ( HomematicipPowerSensor ( home , device ) ) [EOL] if isinstance ( device , ( AsyncWeatherSensor , AsyncWeatherSensorPlus , AsyncWeatherSensorPro ) ) : [EOL] devices . append ( HomematicipWindspeedSensor ( home , device ) ) [EOL] if isinstance ( device , ( AsyncWeatherSensorPlus , AsyncWeatherSensorPro ) ) : [EOL] devices . append ( HomematicipTodayRainSensor ( home , device ) ) [EOL] [EOL] if devices : [EOL] async_add_entities ( devices ) [EOL] [EOL] [EOL] class HomematicipAccesspointStatus ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , home ) [EOL] [EOL] @ property def device_info ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return { [string] : { ( HMIPC_DOMAIN , self . _device . id ) } } [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _home . dutyCycle [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _home . connected [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipHeatingThermostat ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if super ( ) . icon : [EOL] return super ( ) . icon [EOL] if self . _device . valveState != ValveState . ADAPTION_DONE : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _device . valveState != ValveState . ADAPTION_DONE : [EOL] return self . _device . valveState [EOL] return round ( self . _device . valvePosition * [number] ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipHumiditySensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_HUMIDITY [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . humidity [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipTemperatureSensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_TEMPERATURE [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if hasattr ( self . _device , [string] ) : [EOL] return self . _device . valveActualTemperature [EOL] [EOL] return self . _device . actualTemperature [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = super ( ) . device_state_attributes [EOL] if hasattr ( self . _device , [string] ) and self . _device . temperatureOffset : [EOL] attr [ ATTR_TEMPERATURE_OFFSET ] = self . _device . temperatureOffset [EOL] return attr [EOL] [EOL] [EOL] class HomematicipIlluminanceSensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_ILLUMINANCE [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if hasattr ( self . _device , [string] ) : [EOL] return self . _device . averageIllumination [EOL] [EOL] return self . _device . illumination [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class HomematicipPowerSensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEVICE_CLASS_POWER [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . currentPowerConsumption [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return POWER_WATT [EOL] [EOL] [EOL] class HomematicipWindspeedSensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _device . windSpeed [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = super ( ) . device_state_attributes [EOL] if hasattr ( self . _device , [string] ) and self . _device . windDirection : [EOL] attr [ ATTR_WIND_DIRECTION ] = _get_wind_direction ( self . _device . windDirection ) [EOL] if hasattr ( self . _device , [string] ) and self . _device . windDirectionVariation : [EOL] attr [ ATTR_WIND_DIRECTION_VARIATION ] = self . _device . windDirectionVariation [EOL] return attr [EOL] [EOL] [EOL] class HomematicipTodayRainSensor ( HomematicipGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , home , device ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( home , device , [string] ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return round ( self . _device . todayRainCounter , [number] ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] def _get_wind_direction ( wind_direction_degree ) : [EOL] [docstring] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] if [number] <= wind_direction_degree < [number] : [EOL] return [string] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 0 $homematicip.aio.home.AsyncHome$ 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $homematicip.aio.home.AsyncHome$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from requests . exceptions import RequestException [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . device_tracker import ( DOMAIN , PLATFORM_SCHEMA , DeviceScanner ) [EOL] from homeassistant . const import CONF_HOST [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_HOST = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string } ) [EOL] [EOL] [EOL] def get_scanner ( hass , config ) : [EOL] [docstring] [EOL] from xfinity_gateway import XfinityGateway [EOL] [EOL] gateway = XfinityGateway ( config [ DOMAIN ] [ CONF_HOST ] ) [EOL] scanner = None [EOL] try : [EOL] gateway . scan_devices ( ) [EOL] scanner = XfinityDeviceScanner ( gateway ) [EOL] except ( RequestException , ValueError ) : [EOL] _LOGGER . error ( [string] [string] , gateway . host ) [EOL] [EOL] return scanner [EOL] [EOL] [EOL] class XfinityDeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , gateway ) : [EOL] [docstring] [EOL] self . gateway = gateway [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] connected_devices = [ ] [EOL] try : [EOL] connected_devices = self . gateway . scan_devices ( ) [EOL] except ( RequestException , ValueError ) : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return connected_devices [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] return self . gateway . get_device_name ( device ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] config_entry_flow . register_webhook_flow ( DOMAIN , [string] , { [string] : [string] , [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Literal , Union , Any [EOL] import typing [EOL] import logging [EOL] import typing_extensions [EOL] [docstring] [EOL] from datetime import timedelta [EOL] from functools import partial , wraps [EOL] from inspect import getmodule [EOL] import logging [EOL] [EOL] from pyhap . accessory import Accessory , Bridge [EOL] from pyhap . accessory_driver import AccessoryDriver [EOL] from pyhap . const import CATEGORY_OTHER [EOL] [EOL] from homeassistant . const import ( ATTR_BATTERY_CHARGING , ATTR_BATTERY_LEVEL , ATTR_ENTITY_ID , ATTR_SERVICE , __version__ ) [EOL] from homeassistant . core import callback as ha_callback , split_entity_id [EOL] from homeassistant . helpers . event import ( async_track_state_change , track_point_in_utc_time ) [EOL] from homeassistant . util import dt as dt_util [EOL] [EOL] from . const import ( ATTR_DISPLAY_NAME , ATTR_VALUE , BRIDGE_MODEL , BRIDGE_SERIAL_NUMBER , CHAR_BATTERY_LEVEL , CHAR_CHARGING_STATE , CHAR_STATUS_LOW_BATTERY , CONF_LINKED_BATTERY_SENSOR , CONF_LOW_BATTERY_THRESHOLD , DEBOUNCE_TIMEOUT , DEFAULT_LOW_BATTERY_THRESHOLD , EVENT_HOMEKIT_CHANGED , MANUFACTURER , SERV_BATTERY_SERVICE ) [EOL] from . util import convert_to_float , dismiss_setup_message , show_setup_message [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def debounce ( func ) : [EOL] [docstring] [EOL] @ ha_callback def call_later_listener ( self , * args ) : [EOL] [docstring] [EOL] debounce_params = self . debounce . pop ( func . __name__ , None ) [EOL] if debounce_params : [EOL] self . hass . async_add_executor_job ( func , self , * debounce_params [ [number] : ] ) [EOL] [EOL] @ wraps ( func ) def wrapper ( self , * args ) : [EOL] [docstring] [EOL] debounce_params = self . debounce . pop ( func . __name__ , None ) [EOL] if debounce_params : [EOL] debounce_params [ [number] ] ( ) [comment] [EOL] remove_listener = track_point_in_utc_time ( self . hass , partial ( call_later_listener , self ) , dt_util . utcnow ( ) + timedelta ( seconds = DEBOUNCE_TIMEOUT ) ) [EOL] self . debounce [ func . __name__ ] = ( remove_listener , * args ) [EOL] logger . debug ( [string] , self . entity_id , func . __name__ . replace ( [string] , [string] ) ) [EOL] [EOL] name = getmodule ( func ) . __name__ [EOL] logger = logging . getLogger ( name ) [EOL] return wrapper [EOL] [EOL] [EOL] class HomeAccessory ( Accessory ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , driver , name , entity_id , aid , config , category = CATEGORY_OTHER ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( driver , name , aid = aid ) [EOL] model = split_entity_id ( entity_id ) [ [number] ] . replace ( [string] , [string] ) . title ( ) [EOL] self . set_info_service ( firmware_revision = __version__ , manufacturer = MANUFACTURER , model = model , serial_number = entity_id ) [EOL] self . category = category [EOL] self . config = config or { } [EOL] self . entity_id = entity_id [EOL] self . hass = hass [EOL] self . debounce = { } [EOL] self . _support_battery_level = False [EOL] self . _support_battery_charging = True [EOL] self . linked_battery_sensor = self . config . get ( CONF_LINKED_BATTERY_SENSOR ) [EOL] self . low_battery_threshold = self . config . get ( CONF_LOW_BATTERY_THRESHOLD , DEFAULT_LOW_BATTERY_THRESHOLD ) [EOL] [EOL] [docstring] [EOL] battery_found = self . hass . states . get ( self . entity_id ) . attributes . get ( ATTR_BATTERY_LEVEL ) [EOL] if self . linked_battery_sensor : [EOL] battery_found = self . hass . states . get ( self . linked_battery_sensor ) . state [EOL] [EOL] if battery_found is None : [EOL] return [EOL] _LOGGER . debug ( [string] , self . entity_id ) [EOL] self . _support_battery_level = True [EOL] serv_battery = self . add_preload_service ( SERV_BATTERY_SERVICE ) [EOL] self . _char_battery = serv_battery . configure_char ( CHAR_BATTERY_LEVEL , value = [number] ) [EOL] self . _char_charging = serv_battery . configure_char ( CHAR_CHARGING_STATE , value = [number] ) [EOL] self . _char_low_battery = serv_battery . configure_char ( CHAR_STATUS_LOW_BATTERY , value = [number] ) [EOL] [EOL] async def run ( self ) : [EOL] [docstring] [EOL] self . hass . add_job ( self . run_handler ) [EOL] [EOL] async def run_handler ( self ) : [EOL] [docstring] [EOL] state = self . hass . states . get ( self . entity_id ) [EOL] self . hass . async_add_job ( self . update_state_callback , None , None , state ) [EOL] async_track_state_change ( self . hass , self . entity_id , self . update_state_callback ) [EOL] [EOL] if self . linked_battery_sensor : [EOL] battery_state = self . hass . states . get ( self . linked_battery_sensor ) [EOL] self . hass . async_add_job ( self . update_linked_battery , None , None , battery_state ) [EOL] async_track_state_change ( self . hass , self . linked_battery_sensor , self . update_linked_battery ) [EOL] [EOL] @ ha_callback def update_state_callback ( self , entity_id = None , old_state = None , new_state = None ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , new_state ) [EOL] if new_state is None : [EOL] return [EOL] if self . _support_battery_level and not self . linked_battery_sensor : [EOL] self . hass . async_add_executor_job ( self . update_battery , new_state ) [EOL] self . hass . async_add_executor_job ( self . update_state , new_state ) [EOL] [EOL] @ ha_callback def update_linked_battery ( self , entity_id = None , old_state = None , new_state = None ) : [EOL] [docstring] [EOL] self . hass . async_add_executor_job ( self . update_battery , new_state ) [EOL] [EOL] def update_battery ( self , new_state ) : [EOL] [docstring] [EOL] battery_level = convert_to_float ( new_state . attributes . get ( ATTR_BATTERY_LEVEL ) ) [EOL] if self . linked_battery_sensor : [EOL] battery_level = convert_to_float ( new_state . state ) [EOL] if battery_level is None : [EOL] return [EOL] self . _char_battery . set_value ( battery_level ) [EOL] self . _char_low_battery . set_value ( battery_level < self . low_battery_threshold ) [EOL] _LOGGER . debug ( [string] , self . entity_id , battery_level ) [EOL] if not self . _support_battery_charging : [EOL] return [EOL] charging = new_state . attributes . get ( ATTR_BATTERY_CHARGING ) [EOL] if charging is None : [EOL] self . _support_battery_charging = False [EOL] return [EOL] hk_charging = [number] if charging is True else [number] [EOL] self . _char_charging . set_value ( hk_charging ) [EOL] _LOGGER . debug ( [string] , self . entity_id , hk_charging ) [EOL] [EOL] def update_state ( self , new_state ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] def call_service ( self , domain , service , service_data , value = None ) : [EOL] [docstring] [EOL] self . hass . add_job ( self . async_call_service , domain , service , service_data , value ) [EOL] [EOL] async def async_call_service ( self , domain , service , service_data , value = None ) : [EOL] [docstring] [EOL] event_data = { ATTR_ENTITY_ID : self . entity_id , ATTR_DISPLAY_NAME : self . display_name , ATTR_SERVICE : service , ATTR_VALUE : value } [EOL] [EOL] self . hass . bus . async_fire ( EVENT_HOMEKIT_CHANGED , event_data ) [EOL] await self . hass . services . async_call ( domain , service , service_data ) [EOL] [EOL] [EOL] class HomeBridge ( Bridge ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , driver , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( driver , name ) [EOL] self . set_info_service ( firmware_revision = __version__ , manufacturer = MANUFACTURER , model = BRIDGE_MODEL , serial_number = BRIDGE_SERIAL_NUMBER ) [EOL] self . hass = hass [EOL] [EOL] def setup_message ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class HomeDriver ( AccessoryDriver ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , ** kwargs ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] self . hass = hass [EOL] [EOL] def pair ( self , client_uuid , client_public ) : [EOL] [docstring] [EOL] success = super ( ) . pair ( client_uuid , client_public ) [EOL] if success : [EOL] dismiss_setup_message ( self . hass ) [EOL] return success [EOL] [EOL] def unpair ( self , client_uuid ) : [EOL] [docstring] [EOL] super ( ) . unpair ( client_uuid ) [EOL] show_setup_message ( self . hass , self . state . pincode ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] DATA_AMCREST = DOMAIN [EOL] CAMERAS = [string] [EOL] DEVICES = [string] [EOL] [EOL] BINARY_SENSOR_SCAN_INTERVAL_SECS = [number] [EOL] CAMERA_WEB_SESSION_TIMEOUT = [number] [EOL] SENSOR_SCAN_INTERVAL_SECS = [number] [EOL] [EOL] SERVICE_UPDATE = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from amcrest import AmcrestError [EOL] [EOL] from homeassistant . const import CONF_NAME , CONF_SWITCHES [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] [EOL] from . const import DATA_AMCREST , DEVICES , SERVICE_UPDATE [EOL] from . helpers import log_update_error , service_signal [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] MOTION_DETECTION = [string] [EOL] MOTION_RECORDING = [string] [EOL] [comment] [EOL] SWITCHES = { MOTION_DETECTION : [ [string] , [string] ] , MOTION_RECORDING : [ [string] , [string] ] } [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] name = discovery_info [ CONF_NAME ] [EOL] device = hass . data [ DATA_AMCREST ] [ DEVICES ] [ name ] [EOL] async_add_entities ( [ AmcrestSwitch ( name , device , setting ) for setting in discovery_info [ CONF_SWITCHES ] ] , True ) [EOL] [EOL] [EOL] class AmcrestSwitch ( ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , device , setting ) : [EOL] [docstring] [EOL] self . _name = [string] . format ( name , SWITCHES [ setting ] [ [number] ] ) [EOL] self . _signal_name = name [EOL] self . _api = device . api [EOL] self . _setting = setting [EOL] self . _state = False [EOL] self . _icon = SWITCHES [ setting ] [ [number] ] [EOL] self . _unsub_dispatcher = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . available : [EOL] return [EOL] try : [EOL] if self . _setting == MOTION_DETECTION : [EOL] self . _api . motion_detection = [string] [EOL] elif self . _setting == MOTION_RECORDING : [EOL] self . _api . motion_recording = [string] [EOL] except AmcrestError as error : [EOL] log_update_error ( _LOGGER , [string] , self . name , [string] , error ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . available : [EOL] return [EOL] try : [EOL] if self . _setting == MOTION_DETECTION : [EOL] self . _api . motion_detection = [string] [EOL] elif self . _setting == MOTION_RECORDING : [EOL] self . _api . motion_recording = [string] [EOL] except AmcrestError as error : [EOL] log_update_error ( _LOGGER , [string] , self . name , [string] , error ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _api . available [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if not self . available : [EOL] return [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] [EOL] try : [EOL] if self . _setting == MOTION_DETECTION : [EOL] detection = self . _api . is_motion_detector_on ( ) [EOL] elif self . _setting == MOTION_RECORDING : [EOL] detection = self . _api . is_record_on_motion_detection ( ) [EOL] self . _state = detection [EOL] except AmcrestError as error : [EOL] log_update_error ( _LOGGER , [string] , self . name , [string] , error ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] async def async_on_demand_update ( self ) : [EOL] [docstring] [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _unsub_dispatcher = async_dispatcher_connect ( self . hass , service_signal ( SERVICE_UPDATE , self . _signal_name ) , self . async_on_demand_update ) [EOL] [EOL] async def async_will_remove_from_hass ( self ) : [EOL] [docstring] [EOL] self . _unsub_dispatcher ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any , Type [EOL] import homeassistant [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from pyheos import Heos [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import config_entries [EOL] from homeassistant . const import CONF_HOST , CONF_NAME [EOL] [EOL] from . const import DATA_DISCOVERED_HOSTS , DOMAIN [EOL] [EOL] [EOL] def format_title ( host ) : [EOL] [docstring] [EOL] return [string] . format ( host ) [EOL] [EOL] [EOL] @ config_entries . HANDLERS . register ( DOMAIN ) class HeosFlowHandler ( config_entries . ConfigFlow ) : [EOL] [docstring] [EOL] [EOL] VERSION = [number] [EOL] CONNECTION_CLASS = config_entries . CONN_CLASS_LOCAL_PUSH [EOL] [EOL] async def async_step_ssdp ( self , discovery_info ) : [EOL] [docstring] [EOL] [comment] [EOL] friendly_name = [string] . format ( discovery_info [ CONF_NAME ] , discovery_info [ CONF_HOST ] ) [EOL] self . hass . data . setdefault ( DATA_DISCOVERED_HOSTS , { } ) [EOL] self . hass . data [ DATA_DISCOVERED_HOSTS ] [ friendly_name ] = discovery_info [ CONF_HOST ] [EOL] [comment] [EOL] if self . _async_in_progress ( ) or self . _async_current_entries ( ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [comment] [EOL] return self . async_show_form ( step_id = [string] ) [EOL] [EOL] async def async_step_import ( self , user_input = None ) : [EOL] [docstring] [EOL] host = user_input [ CONF_HOST ] [EOL] return self . async_create_entry ( title = format_title ( host ) , data = { CONF_HOST : host } ) [EOL] [EOL] async def async_step_user ( self , user_input = None ) : [EOL] [docstring] [EOL] self . hass . data . setdefault ( DATA_DISCOVERED_HOSTS , { } ) [EOL] [comment] [EOL] if self . _async_current_entries ( ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [comment] [EOL] errors = { } [EOL] host = None [EOL] if user_input is not None : [EOL] host = user_input [ CONF_HOST ] [EOL] [comment] [EOL] host = self . hass . data [ DATA_DISCOVERED_HOSTS ] . get ( host , host ) [EOL] heos = Heos ( host ) [EOL] try : [EOL] await heos . connect ( ) [EOL] self . hass . data . pop ( DATA_DISCOVERED_HOSTS ) [EOL] return await self . async_step_import ( { CONF_HOST : host } ) [EOL] except ( asyncio . TimeoutError , ConnectionError ) : [EOL] errors [ CONF_HOST ] = [string] [EOL] finally : [EOL] await heos . disconnect ( ) [EOL] [EOL] [comment] [EOL] host_type = str if not self . hass . data [ DATA_DISCOVERED_HOSTS ] \ [EOL] else vol . In ( list ( self . hass . data [ DATA_DISCOVERED_HOSTS ] ) ) [EOL] return self . async_show_form ( step_id = [string] , data_schema = vol . Schema ( { vol . Required ( CONF_HOST , default = host ) : host_type } ) , errors = errors ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Type[homeassistant.components.heos.config_flow.HeosFlowHandler]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0
from typing import Any , Sequence , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] from functools import reduce , wraps [EOL] import logging [EOL] from operator import ior [EOL] from typing import Sequence [EOL] [EOL] from pyheos import CommandError , const as heos_const [EOL] [EOL] from homeassistant . components . media_player import MediaPlayerDevice [EOL] from homeassistant . components . media_player . const import ( ATTR_MEDIA_ENQUEUE , DOMAIN , MEDIA_TYPE_MUSIC , MEDIA_TYPE_PLAYLIST , MEDIA_TYPE_URL , SUPPORT_CLEAR_PLAYLIST , SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PLAY , SUPPORT_PLAY_MEDIA , SUPPORT_PREVIOUS_TRACK , SUPPORT_SELECT_SOURCE , SUPPORT_SHUFFLE_SET , SUPPORT_STOP , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_VOLUME_STEP ) [EOL] from homeassistant . config_entries import ConfigEntry [EOL] from homeassistant . const import STATE_IDLE , STATE_PAUSED , STATE_PLAYING [EOL] from homeassistant . helpers . typing import HomeAssistantType [EOL] from homeassistant . util . dt import utcnow [EOL] [EOL] from . const import ( DATA_SOURCE_MANAGER , DOMAIN as HEOS_DOMAIN , SIGNAL_HEOS_UPDATED ) [EOL] [EOL] BASE_SUPPORTED_FEATURES = SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_STEP | SUPPORT_CLEAR_PLAYLIST | SUPPORT_SHUFFLE_SET | SUPPORT_SELECT_SOURCE | SUPPORT_PLAY_MEDIA [EOL] [EOL] PLAY_STATE_TO_STATE = { heos_const . PLAY_STATE_PLAY : STATE_PLAYING , heos_const . PLAY_STATE_STOP : STATE_IDLE , heos_const . PLAY_STATE_PAUSE : STATE_PAUSED } [EOL] [EOL] CONTROL_TO_SUPPORT = { heos_const . CONTROL_PLAY : SUPPORT_PLAY , heos_const . CONTROL_PAUSE : SUPPORT_PAUSE , heos_const . CONTROL_STOP : SUPPORT_STOP , heos_const . CONTROL_PLAY_PREVIOUS : SUPPORT_PREVIOUS_TRACK , heos_const . CONTROL_PLAY_NEXT : SUPPORT_NEXT_TRACK } [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry , async_add_entities ) : [EOL] [docstring] [EOL] players = hass . data [ HEOS_DOMAIN ] [ DOMAIN ] [EOL] devices = [ HeosMediaPlayer ( player ) for player in players . values ( ) ] [EOL] async_add_entities ( devices , True ) [EOL] [EOL] [EOL] def log_command_error ( command ) : [EOL] [docstring] [EOL] def decorator ( func ) : [EOL] @ wraps ( func ) async def wrapper ( * args , ** kwargs ) : [EOL] try : [EOL] await func ( * args , ** kwargs ) [EOL] except ( CommandError , asyncio . TimeoutError , ConnectionError , ValueError ) as ex : [EOL] _LOGGER . error ( [string] , command , ex ) [EOL] return wrapper [EOL] return decorator [EOL] [EOL] [EOL] class HeosMediaPlayer ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , player ) : [EOL] [docstring] [EOL] self . _media_position_updated_at = None [EOL] self . _player = player [EOL] self . _signals = [ ] [EOL] self . _supported_features = BASE_SUPPORTED_FEATURES [EOL] self . _source_manager = None [EOL] [EOL] async def _player_update ( self , player_id , event ) : [EOL] [docstring] [EOL] if self . _player . player_id != player_id : [EOL] return [EOL] if event == heos_const . EVENT_PLAYER_NOW_PLAYING_PROGRESS : [EOL] self . _media_position_updated_at = utcnow ( ) [EOL] await self . async_update_ha_state ( True ) [EOL] [EOL] async def _heos_updated ( self ) : [EOL] [docstring] [EOL] await self . async_update_ha_state ( True ) [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _source_manager = self . hass . data [ HEOS_DOMAIN ] [ DATA_SOURCE_MANAGER ] [EOL] [comment] [EOL] self . _signals . append ( self . _player . heos . dispatcher . connect ( heos_const . SIGNAL_PLAYER_EVENT , self . _player_update ) ) [EOL] [comment] [EOL] self . _signals . append ( self . hass . helpers . dispatcher . async_dispatcher_connect ( SIGNAL_HEOS_UPDATED , self . _heos_updated ) ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_clear_playlist ( self ) : [EOL] [docstring] [EOL] await self . _player . clear_queue ( ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_media_pause ( self ) : [EOL] [docstring] [EOL] await self . _player . pause ( ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_media_play ( self ) : [EOL] [docstring] [EOL] await self . _player . play ( ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_media_previous_track ( self ) : [EOL] [docstring] [EOL] await self . _player . play_previous ( ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_media_next_track ( self ) : [EOL] [docstring] [EOL] await self . _player . play_next ( ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_media_stop ( self ) : [EOL] [docstring] [EOL] await self . _player . stop ( ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_mute_volume ( self , mute ) : [EOL] [docstring] [EOL] await self . _player . set_mute ( mute ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_play_media ( self , media_type , media_id , ** kwargs ) : [EOL] [docstring] [EOL] if media_type == MEDIA_TYPE_URL : [EOL] await self . _player . play_url ( media_id ) [EOL] return [EOL] [EOL] if media_type == [string] : [EOL] [comment] [EOL] selects = await self . _player . get_quick_selects ( ) [EOL] try : [EOL] index = int ( media_id ) [EOL] except ValueError : [EOL] [comment] [EOL] index = next ( ( index for index , select in selects . items ( ) if select == media_id ) , None ) [EOL] if index is None : [EOL] raise ValueError ( [string] . format ( media_id ) ) [EOL] await self . _player . play_quick_select ( index ) [EOL] return [EOL] [EOL] if media_type == MEDIA_TYPE_PLAYLIST : [EOL] playlists = await self . _player . heos . get_playlists ( ) [EOL] playlist = next ( ( p for p in playlists if p . name == media_id ) , None ) [EOL] if not playlist : [EOL] raise ValueError ( [string] . format ( media_id ) ) [EOL] add_queue_option = heos_const . ADD_QUEUE_ADD_TO_END \ [EOL] if kwargs . get ( ATTR_MEDIA_ENQUEUE ) \ [EOL] else heos_const . ADD_QUEUE_REPLACE_AND_PLAY [EOL] await self . _player . add_to_queue ( playlist , add_queue_option ) [EOL] return [EOL] [EOL] if media_type == [string] : [EOL] [comment] [EOL] try : [EOL] index = int ( media_id ) [EOL] except ValueError : [EOL] [comment] [EOL] index = next ( ( index for index , favorite in self . _source_manager . favorites . items ( ) if favorite . name == media_id ) , None ) [EOL] if index is None : [EOL] raise ValueError ( [string] . format ( media_id ) ) [EOL] await self . _player . play_favorite ( index ) [EOL] return [EOL] [EOL] raise ValueError ( [string] . format ( media_type ) ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_select_source ( self , source ) : [EOL] [docstring] [EOL] await self . _source_manager . play_source ( source , self . _player ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_set_shuffle ( self , shuffle ) : [EOL] [docstring] [EOL] await self . _player . set_play_mode ( self . _player . repeat , shuffle ) [EOL] [EOL] @ log_command_error ( [string] ) async def async_set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] await self . _player . set_volume ( int ( volume * [number] ) ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] controls = self . _player . now_playing_media . supported_controls [EOL] current_support = [ CONTROL_TO_SUPPORT [ control ] for control in controls ] [EOL] self . _supported_features = reduce ( ior , current_support , BASE_SUPPORTED_FEATURES ) [EOL] [EOL] async def async_will_remove_from_hass ( self ) : [EOL] [docstring] [EOL] for signal_remove in self . _signals : [EOL] signal_remove ( ) [EOL] self . _signals . clear ( ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _player . available [EOL] [EOL] @ property def device_info ( self ) : [EOL] [docstring] [EOL] return { [string] : { ( HEOS_DOMAIN , self . _player . player_id ) } , [string] : self . _player . name , [string] : self . _player . model , [string] : [string] , [string] : self . _player . version } [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _player . now_playing_media . album_id , [string] : self . _player . now_playing_media . queue_id , [string] : self . _player . now_playing_media . source_id , [string] : self . _player . now_playing_media . station , [string] : self . _player . now_playing_media . type } [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _player . is_muted [EOL] [EOL] @ property def media_album_name ( self ) : [EOL] [docstring] [EOL] return self . _player . now_playing_media . album [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . _player . now_playing_media . artist [EOL] [EOL] @ property def media_content_id ( self ) : [EOL] [docstring] [EOL] return self . _player . now_playing_media . media_id [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def media_duration ( self ) : [EOL] [docstring] [EOL] duration = self . _player . now_playing_media . duration [EOL] if isinstance ( duration , int ) : [EOL] return duration / [number] [EOL] return None [EOL] [EOL] @ property def media_position ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if not self . _player . now_playing_media . duration : [EOL] return None [EOL] return self . _player . now_playing_media . current_position / [number] [EOL] [EOL] @ property def media_position_updated_at ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if not self . _player . now_playing_media . duration : [EOL] return None [EOL] return self . _media_position_updated_at [EOL] [EOL] @ property def media_image_remotely_accessible ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] image_url = self . _player . now_playing_media . image_url [EOL] return image_url if image_url else None [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _player . now_playing_media . song [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _player . name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def shuffle ( self ) : [EOL] [docstring] [EOL] return self . _player . shuffle [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _source_manager . get_current_source ( self . _player . now_playing_media ) [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _source_manager . source_list [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return PLAY_STATE_TO_STATE [ self . _player . state ] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported_features [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return str ( self . _player . player_id ) [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _player . volume / [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import homeassistant [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA , ATTR_CURRENT_POWER_W ) [EOL] from homeassistant . const import ( CONF_NAME , CONF_DEVICE , EVENT_HOMEASSISTANT_STOP ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_TOTAL_ENERGY_KWH = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Required ( CONF_DEVICE ) : cv . string } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] import pypca [EOL] from serial import SerialException [EOL] [EOL] name = config [ CONF_NAME ] [EOL] usb_device = config [ CONF_DEVICE ] [EOL] [EOL] try : [EOL] pca = pypca . PCA ( usb_device ) [EOL] pca . open ( ) [EOL] entities = [ SmartPlugSwitch ( pca , device , name ) for device in pca . get_devices ( ) ] [EOL] add_entities ( entities , True ) [EOL] [EOL] except SerialException as exc : [EOL] _LOGGER . warning ( [string] , exc ) [EOL] return [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , pca . close ) [EOL] [EOL] pca . start_scan ( ) [EOL] [EOL] [EOL] class SmartPlugSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , pca , device_id , name ) : [EOL] [docstring] [EOL] self . _device_id = device_id [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _available = True [EOL] self . _emeter_params = { } [EOL] self . _pca = pca [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _pca . turn_on ( self . _device_id ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _pca . turn_off ( self . _device_id ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _emeter_params [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _emeter_params [ ATTR_CURRENT_POWER_W ] = [string] . format ( self . _pca . get_current_power ( self . _device_id ) ) [EOL] self . _emeter_params [ ATTR_TOTAL_ENERGY_KWH ] = [string] . format ( self . _pca . get_total_consumption ( self . _device_id ) ) [EOL] [EOL] self . _available = True [EOL] self . _state = self . _pca . get_state ( self . _device_id ) [EOL] [EOL] except (OSError) as ex : [EOL] if self . _available : [EOL] _LOGGER . warning ( [string] , self . name , ex ) [EOL] self . _available = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Optional , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import DOMAIN , BinarySensorDevice [EOL] from homeassistant . components . http import HomeAssistantView [EOL] from homeassistant . const import HTTP_UNPROCESSABLE_ENTITY [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] hass . http . register_view ( MyStromView ( async_add_entities ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class MyStromView ( HomeAssistantView ) : [EOL] [docstring] [EOL] [EOL] url = [string] [EOL] name = [string] [EOL] supported_actions = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , add_entities ) : [EOL] [docstring] [EOL] self . buttons = { } [EOL] self . add_entities = add_entities [EOL] [EOL] async def get ( self , request ) : [EOL] [docstring] [EOL] res = await self . _handle ( request . app [ [string] ] , request . query ) [EOL] return res [EOL] [EOL] async def _handle ( self , hass , data ) : [EOL] [docstring] [EOL] button_action = next ( ( parameter for parameter in data if parameter in self . supported_actions ) , None ) [EOL] [EOL] if button_action is None : [EOL] _LOGGER . error ( [string] , data ) [EOL] return ( [string] . format ( data ) , HTTP_UNPROCESSABLE_ENTITY ) [EOL] [EOL] button_id = data [ button_action ] [EOL] entity_id = [string] . format ( DOMAIN , button_id , button_action ) [EOL] if entity_id not in self . buttons : [EOL] _LOGGER . info ( [string] , button_id , button_action ) [EOL] self . buttons [ entity_id ] = MyStromBinarySensor ( [string] . format ( button_id , button_action ) ) [EOL] self . add_entities ( [ self . buttons [ entity_id ] ] ) [EOL] else : [EOL] new_state = self . buttons [ entity_id ] . state == [string] [EOL] self . buttons [ entity_id ] . async_on_update ( new_state ) [EOL] [EOL] [EOL] class MyStromBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , button_id ) : [EOL] [docstring] [EOL] self . _button_id = button_id [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _button_id [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def async_on_update ( self , value ) : [EOL] [docstring] [EOL] self . _state = value [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Set , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import datetime [EOL] import glob [EOL] import logging [EOL] import os [EOL] import time [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import SERVICE_RELOAD [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] from homeassistant . loader import bind_hass [EOL] from homeassistant . util import sanitize_filename [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] FOLDER = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( dict ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] ALLOWED_HASS = set ( [ [string] , [string] , [string] ] ) [EOL] ALLOWED_EVENTBUS = set ( [ [string] ] ) [EOL] ALLOWED_STATEMACHINE = set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] ALLOWED_SERVICEREGISTRY = set ( [ [string] , [string] , [string] ] ) [EOL] ALLOWED_TIME = set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] ALLOWED_DATETIME = set ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] ALLOWED_DT_UTIL = set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class ScriptError ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] path = hass . config . path ( FOLDER ) [EOL] [EOL] if not os . path . isdir ( path ) : [EOL] _LOGGER . warning ( [string] , FOLDER ) [EOL] return False [EOL] [EOL] discover_scripts ( hass ) [EOL] [EOL] def reload_scripts_handler ( call ) : [EOL] [docstring] [EOL] discover_scripts ( hass ) [EOL] hass . services . register ( DOMAIN , SERVICE_RELOAD , reload_scripts_handler ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def discover_scripts ( hass ) : [EOL] [docstring] [EOL] path = hass . config . path ( FOLDER ) [EOL] [EOL] if not os . path . isdir ( path ) : [EOL] _LOGGER . warning ( [string] , FOLDER ) [EOL] return False [EOL] [EOL] def python_script_service_handler ( call ) : [EOL] [docstring] [EOL] execute_script ( hass , call . service , call . data ) [EOL] [EOL] existing = hass . services . services . get ( DOMAIN , { } ) . keys ( ) [EOL] for existing_service in existing : [EOL] if existing_service == SERVICE_RELOAD : [EOL] continue [EOL] hass . services . remove ( DOMAIN , existing_service ) [EOL] [EOL] for fil in glob . iglob ( os . path . join ( path , [string] ) ) : [EOL] name = os . path . splitext ( os . path . basename ( fil ) ) [ [number] ] [EOL] hass . services . register ( DOMAIN , name , python_script_service_handler ) [EOL] [EOL] [EOL] @ bind_hass def execute_script ( hass , name , data = None ) : [EOL] [docstring] [EOL] filename = [string] . format ( name ) [EOL] with open ( hass . config . path ( FOLDER , sanitize_filename ( filename ) ) ) as fil : [EOL] source = fil . read ( ) [EOL] execute ( hass , filename , source , data ) [EOL] [EOL] [EOL] @ bind_hass def execute ( hass , filename , source , data = None ) : [EOL] [docstring] [EOL] from RestrictedPython import compile_restricted_exec [EOL] from RestrictedPython . Guards import safe_builtins , full_write_guard , guarded_iter_unpack_sequence , guarded_unpack_sequence [EOL] from RestrictedPython . Utilities import utility_builtins [EOL] from RestrictedPython . Eval import default_guarded_getitem [EOL] [EOL] compiled = compile_restricted_exec ( source , filename = filename ) [EOL] [EOL] if compiled . errors : [EOL] _LOGGER . error ( [string] , filename , [string] . join ( compiled . errors ) ) [EOL] return [EOL] [EOL] if compiled . warnings : [EOL] _LOGGER . warning ( [string] , filename , [string] . join ( compiled . warnings ) ) [EOL] [EOL] def protected_getattr ( obj , name , default = None ) : [EOL] [docstring] [EOL] [comment] [EOL] if name . startswith ( [string] ) : [EOL] raise ScriptError ( [string] ) [EOL] if ( obj is hass and name not in ALLOWED_HASS or obj is hass . bus and name not in ALLOWED_EVENTBUS or obj is hass . states and name not in ALLOWED_STATEMACHINE or obj is hass . services and name not in ALLOWED_SERVICEREGISTRY or obj is dt_util and name not in ALLOWED_DT_UTIL or obj is datetime and name not in ALLOWED_DATETIME or isinstance ( obj , TimeWrapper ) and name not in ALLOWED_TIME ) : [EOL] raise ScriptError ( [string] . format ( obj . __class__ . __name__ , name ) ) [EOL] [EOL] return getattr ( obj , name , default ) [EOL] [EOL] builtins = safe_builtins . copy ( ) [EOL] builtins . update ( utility_builtins ) [EOL] builtins [ [string] ] = datetime [EOL] builtins [ [string] ] = sorted [EOL] builtins [ [string] ] = TimeWrapper ( ) [EOL] builtins [ [string] ] = dt_util [EOL] restricted_globals = { [string] : builtins , [string] : StubPrinter , [string] : protected_getattr , [string] : full_write_guard , [string] : iter , [string] : default_guarded_getitem , [string] : guarded_iter_unpack_sequence , [string] : guarded_unpack_sequence , } [EOL] logger = logging . getLogger ( [string] . format ( __name__ , filename ) ) [EOL] local = { [string] : hass , [string] : data or { } , [string] : logger } [EOL] [EOL] try : [EOL] _LOGGER . info ( [string] , filename , data ) [EOL] [comment] [EOL] exec ( compiled . code , restricted_globals , local ) [EOL] except ScriptError as err : [EOL] logger . error ( [string] , err ) [EOL] except Exception as err : [comment] [EOL] logger . exception ( [string] , err ) [EOL] [EOL] [EOL] class StubPrinter : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , _getattr_ ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def _call_print ( self , * objects , ** kwargs ) : [EOL] [docstring] [EOL] [comment] [EOL] _LOGGER . warning ( [string] ) [EOL] [EOL] [EOL] class TimeWrapper : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] warned = False [EOL] [EOL] [comment] [EOL] def sleep ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] if not TimeWrapper . warned : [EOL] TimeWrapper . warned = True [EOL] _LOGGER . warning ( [string] [string] ) [EOL] [EOL] time . sleep ( * args , ** kwargs ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] [docstring] [EOL] attribute = getattr ( time , attr ) [EOL] if callable ( attribute ) : [EOL] def wrapper ( * args , ** kw ) : [EOL] [docstring] [EOL] return attribute ( * args , ** kw ) [EOL] return wrapper [EOL] return attribute [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] config_entry_flow . register_webhook_flow ( DOMAIN , [string] , { [string] : [string] , [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] from typing import List [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_DOMAIN , CONF_TTL , CONF_ZONE [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . event import track_time_interval [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ACCESS_KEY_ID = [string] [EOL] CONF_SECRET_ACCESS_KEY = [string] [EOL] CONF_RECORDS = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] INTERVAL = timedelta ( minutes = [number] ) [EOL] DEFAULT_TTL = [number] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_ACCESS_KEY_ID ) : cv . string , vol . Required ( CONF_DOMAIN ) : cv . string , vol . Required ( CONF_RECORDS ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Required ( CONF_SECRET_ACCESS_KEY ) : cv . string , vol . Required ( CONF_ZONE ) : cv . string , vol . Optional ( CONF_TTL , default = DEFAULT_TTL ) : cv . positive_int , } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] domain = config [ DOMAIN ] [ CONF_DOMAIN ] [EOL] records = config [ DOMAIN ] [ CONF_RECORDS ] [EOL] zone = config [ DOMAIN ] [ CONF_ZONE ] [EOL] aws_access_key_id = config [ DOMAIN ] [ CONF_ACCESS_KEY_ID ] [EOL] aws_secret_access_key = config [ DOMAIN ] [ CONF_SECRET_ACCESS_KEY ] [EOL] ttl = config [ DOMAIN ] [ CONF_TTL ] [EOL] [EOL] def update_records_interval ( now ) : [EOL] [docstring] [EOL] _update_route53 ( aws_access_key_id , aws_secret_access_key , zone , domain , records , ttl ) [EOL] [EOL] def update_records_service ( now ) : [EOL] [docstring] [EOL] _update_route53 ( aws_access_key_id , aws_secret_access_key , zone , domain , records , ttl ) [EOL] [EOL] track_time_interval ( hass , update_records_interval , INTERVAL ) [EOL] [EOL] hass . services . register ( DOMAIN , [string] , update_records_service ) [EOL] return True [EOL] [EOL] [EOL] def _update_route53 ( aws_access_key_id , aws_secret_access_key , zone , domain , records , ttl , ) : [EOL] import boto3 [EOL] from ipify import get_ip [EOL] from ipify import exceptions [EOL] [EOL] _LOGGER . debug ( [string] , zone ) [EOL] [EOL] client = boto3 . client ( DOMAIN , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , ) [EOL] [EOL] [comment] [EOL] try : [EOL] ipaddress = get_ip ( ) [EOL] [EOL] except exceptions . ConnectionError : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] [EOL] except exceptions . ServiceError : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] [EOL] changes = [ ] [EOL] for record in records : [EOL] _LOGGER . debug ( [string] , record ) [EOL] [EOL] changes . append ( { [string] : [string] , [string] : { [string] : [string] . format ( record , domain ) , [string] : [string] , [string] : ttl , [string] : [ { [string] : ipaddress } , ] , } } ) [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] _LOGGER . debug ( changes ) [EOL] [EOL] response = client . change_resource_record_sets ( HostedZoneId = zone , ChangeBatch = { [string] : changes } ) [EOL] _LOGGER . debug ( [string] , response ) [EOL] [EOL] if response [ [string] ] [ [string] ] != [number] : [EOL] _LOGGER . warning ( response ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , Optional , List [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from typing import Optional [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_ACCESS_TOKEN [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . discovery import load_platform [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] DOMAIN = [string] [EOL] [EOL] CONF_SERVER = [string] [EOL] CONF_SERVERS = [string] [EOL] [EOL] SUPLA_FUNCTION_HA_CMP_MAP = { [string] : [string] } [EOL] SUPLA_CHANNELS = [string] [EOL] SUPLA_SERVERS = [string] [EOL] [EOL] SERVER_CONFIG = vol . Schema ( { vol . Required ( CONF_SERVER ) : cv . string , vol . Required ( CONF_ACCESS_TOKEN ) : cv . string } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_SERVERS ) : vol . All ( cv . ensure_list , [ SERVER_CONFIG ] ) } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , base_config ) : [EOL] [docstring] [EOL] from pysupla import SuplaAPI [EOL] [EOL] server_confs = base_config [ DOMAIN ] [ CONF_SERVERS ] [EOL] [EOL] hass . data [ SUPLA_SERVERS ] = { } [EOL] hass . data [ SUPLA_CHANNELS ] = { } [EOL] [EOL] for server_conf in server_confs : [EOL] [EOL] server_address = server_conf [ CONF_SERVER ] [EOL] [EOL] server = SuplaAPI ( server_address , server_conf [ CONF_ACCESS_TOKEN ] ) [EOL] [EOL] [comment] [EOL] try : [EOL] srv_info = server . get_server_info ( ) [EOL] if srv_info . get ( [string] ) : [EOL] hass . data [ SUPLA_SERVERS ] [ server_conf [ CONF_SERVER ] ] = server [EOL] else : [EOL] _LOGGER . error ( [string] , server_address , srv_info ) [EOL] return False [EOL] except IOError : [EOL] _LOGGER . exception ( [string] , server_address ) [EOL] return False [EOL] [EOL] discover_devices ( hass , base_config ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def discover_devices ( hass , hass_config ) : [EOL] [docstring] [EOL] component_configs = { } [EOL] [EOL] for server_name , server in hass . data [ SUPLA_SERVERS ] . items ( ) : [EOL] [EOL] for channel in server . get_channels ( include = [ [string] ] ) : [EOL] channel_function = channel [ [string] ] [ [string] ] [EOL] component_name = SUPLA_FUNCTION_HA_CMP_MAP . get ( channel_function ) [EOL] [EOL] if component_name is None : [EOL] _LOGGER . warning ( [string] , channel_function , channel [ [string] ] ) [EOL] continue [EOL] [EOL] channel [ [string] ] = server_name [EOL] component_configs . setdefault ( component_name , [ ] ) . append ( channel ) [EOL] [EOL] [comment] [EOL] for component_name , channel in component_configs . items ( ) : [EOL] load_platform ( hass , component_name , [string] , channel , hass_config ) [EOL] [EOL] [EOL] class SuplaChannel ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , channel_data ) : [EOL] [docstring] [EOL] self . server_name = channel_data [ [string] ] [EOL] self . channel_data = channel_data [EOL] [EOL] @ property def server ( self ) : [EOL] [docstring] [EOL] return self . hass . data [ SUPLA_SERVERS ] [ self . server_name ] [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . channel_data [ [string] ] [ [string] ] . lower ( ) , self . channel_data [ [string] ] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . channel_data [ [string] ] [EOL] [EOL] def action ( self , action , ** add_pars ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , action , self . channel_data [ [string] ] , add_pars ) [EOL] self . server . execute_action ( self . channel_data [ [string] ] , action , ** add_pars ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . channel_data = self . server . get_channel ( self . channel_data [ [string] ] , include = [ [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . weather import DOMAIN as WEATHER_DOMAIN [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] HOME_LOCATION_NAME = [string] [EOL] [EOL] ENTITY_ID_SENSOR_FORMAT = WEATHER_DOMAIN + [string] [EOL] ENTITY_ID_SENSOR_FORMAT_HOME = ENTITY_ID_SENSOR_FORMAT . format ( HOME_LOCATION_NAME ) [EOL] [EOL] _LOGGER = logging . getLogger ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import DOMAIN as SENSOR_DOMAIN [EOL] from homeassistant . const import CONF_MONITORED_CONDITIONS , CONF_PORT , CONF_HOST , CONF_PROTOCOL , CONF_HOSTS , CONF_SCAN_INTERVAL [EOL] from homeassistant . helpers . discovery import async_load_platform [EOL] from homeassistant . helpers . dispatcher import dispatcher_send [EOL] from homeassistant . helpers . event import async_track_time_interval [EOL] [EOL] DOMAIN = [string] [EOL] DATA_UPDATED = [string] . format ( DOMAIN ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_DURATION = [string] [EOL] CONF_PARALLEL = [string] [EOL] CONF_MANUAL = [string] [EOL] [EOL] DEFAULT_DURATION = [number] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_PARALLEL = [number] [EOL] DEFAULT_PROTOCOL = [string] [EOL] DEFAULT_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] ATTR_DOWNLOAD = [string] [EOL] ATTR_UPLOAD = [string] [EOL] ATTR_VERSION = [string] [EOL] ATTR_HOST = [string] [EOL] [EOL] UNIT_OF_MEASUREMENT = [string] [EOL] [EOL] SENSOR_TYPES = { ATTR_DOWNLOAD : [ ATTR_DOWNLOAD . capitalize ( ) , UNIT_OF_MEASUREMENT ] , ATTR_UPLOAD : [ ATTR_UPLOAD . capitalize ( ) , UNIT_OF_MEASUREMENT ] , } [EOL] [EOL] PROTOCOLS = [ [string] , [string] ] [EOL] [EOL] HOST_CONFIG_SCHEMA = vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_DURATION , default = DEFAULT_DURATION ) : vol . Range ( [number] , [number] ) , vol . Optional ( CONF_PARALLEL , default = DEFAULT_PARALLEL ) : vol . Range ( [number] , [number] ) , vol . Optional ( CONF_PROTOCOL , default = DEFAULT_PROTOCOL ) : vol . In ( PROTOCOLS ) , } ) [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_HOSTS ) : vol . All ( cv . ensure_list , [ HOST_CONFIG_SCHEMA ] ) , vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( list ( SENSOR_TYPES ) ) ] ) , vol . Optional ( CONF_SCAN_INTERVAL , default = DEFAULT_INTERVAL ) : vol . All ( cv . time_period , cv . positive_timedelta ) , vol . Optional ( CONF_MANUAL , default = False ) : cv . boolean , } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_HOST , default = None ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] import iperf3 [EOL] [EOL] hass . data [ DOMAIN ] = { } [EOL] [EOL] conf = config [ DOMAIN ] [EOL] for host in conf [ CONF_HOSTS ] : [EOL] host_name = host [ CONF_HOST ] [EOL] [EOL] client = iperf3 . Client ( ) [EOL] client . duration = host [ CONF_DURATION ] [EOL] client . server_hostname = host_name [EOL] client . port = host [ CONF_PORT ] [EOL] client . num_streams = host [ CONF_PARALLEL ] [EOL] client . protocol = host [ CONF_PROTOCOL ] [EOL] client . verbose = False [EOL] [EOL] data = hass . data [ DOMAIN ] [ host_name ] = Iperf3Data ( hass , client ) [EOL] [EOL] if not conf [ CONF_MANUAL ] : [EOL] async_track_time_interval ( hass , data . update , conf [ CONF_SCAN_INTERVAL ] ) [EOL] [EOL] def update ( call ) : [EOL] [docstring] [EOL] called_host = call . data [ ATTR_HOST ] [EOL] if called_host in hass . data [ DOMAIN ] : [EOL] hass . data [ DOMAIN ] [ called_host ] . update ( ) [EOL] else : [EOL] for iperf3_host in hass . data [ DOMAIN ] . values ( ) : [EOL] iperf3_host . update ( ) [EOL] [EOL] hass . services . async_register ( DOMAIN , [string] , update , schema = SERVICE_SCHEMA ) [EOL] [EOL] hass . async_create_task ( async_load_platform ( hass , SENSOR_DOMAIN , DOMAIN , conf [ CONF_MONITORED_CONDITIONS ] , config ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class Iperf3Data : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , client ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _client = client [EOL] self . data = { ATTR_DOWNLOAD : None , ATTR_UPLOAD : None , ATTR_VERSION : None } [EOL] [EOL] @ property def protocol ( self ) : [EOL] [docstring] [EOL] return self . _client . protocol [EOL] [EOL] @ property def host ( self ) : [EOL] [docstring] [EOL] return self . _client . server_hostname [EOL] [EOL] @ property def port ( self ) : [EOL] [docstring] [EOL] return self . _client . port [EOL] [EOL] def update ( self , now = None ) : [EOL] [docstring] [EOL] if self . protocol == [string] : [EOL] [comment] [EOL] result = self . _run_test ( ATTR_DOWNLOAD ) [EOL] self . data [ ATTR_DOWNLOAD ] = self . data [ ATTR_UPLOAD ] = getattr ( result , [string] , None ) [EOL] self . data [ ATTR_VERSION ] = getattr ( result , [string] , None ) [EOL] else : [EOL] result = self . _run_test ( ATTR_DOWNLOAD ) [EOL] self . data [ ATTR_DOWNLOAD ] = getattr ( result , [string] , None ) [EOL] self . data [ ATTR_VERSION ] = getattr ( result , [string] , None ) [EOL] self . data [ ATTR_UPLOAD ] = getattr ( self . _run_test ( ATTR_UPLOAD ) , [string] , None ) [EOL] [EOL] dispatcher_send ( self . _hass , DATA_UPDATED , self . host ) [EOL] [EOL] def _run_test ( self , test_type ) : [EOL] [docstring] [EOL] self . _client . reverse = test_type == ATTR_DOWNLOAD [EOL] try : [EOL] result = self . _client . run ( ) [EOL] except ( AttributeError , OSError , ValueError ) as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] return None [EOL] [EOL] if result is not None and hasattr ( result , [string] ) and result . error is not None : [EOL] _LOGGER . error ( [string] , result . error ) [EOL] return None [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] from . import ACTUATORS , DOMAIN as COMPONENT_DOMAIN , SENSORS , XS1DeviceEntity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from xs1_api_client . api_constants import ActuatorType [EOL] [EOL] sensors = hass . data [ COMPONENT_DOMAIN ] [ SENSORS ] [EOL] actuators = hass . data [ COMPONENT_DOMAIN ] [ ACTUATORS ] [EOL] [EOL] sensor_entities = [ ] [EOL] for sensor in sensors : [EOL] belongs_to_climate_actuator = False [EOL] for actuator in actuators : [EOL] if actuator . type ( ) == ActuatorType . TEMPERATURE and actuator . name ( ) in sensor . name ( ) : [EOL] belongs_to_climate_actuator = True [EOL] break [EOL] [EOL] if not belongs_to_climate_actuator : [EOL] sensor_entities . append ( XS1Sensor ( sensor ) ) [EOL] [EOL] async_add_entities ( sensor_entities ) [EOL] [EOL] [EOL] class XS1Sensor ( XS1DeviceEntity , Entity ) : [EOL] [docstring] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . device . name ( ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . device . value ( ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . device . unit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] from functools import partial [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_PORT , CONF_SSL , CONF_USERNAME ) [EOL] from homeassistant . helpers import discovery [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] ACTUATORS = [string] [EOL] SENSORS = [string] [EOL] [EOL] [comment] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PORT , default = [number] ) : cv . string , vol . Optional ( CONF_SSL , default = False ) : cv . boolean , vol . Optional ( CONF_USERNAME ) : cv . string , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] XS1_COMPONENTS = [ [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] UPDATE_LOCK = asyncio . Lock ( ) [EOL] [EOL] [EOL] def _create_controller_api ( host , port , ssl , user , password ) : [EOL] [docstring] [EOL] import xs1_api_client [EOL] [EOL] try : [EOL] return xs1_api_client . XS1 ( host = host , port = port , ssl = ssl , user = user , password = password ) [EOL] except ConnectionError as error : [EOL] _LOGGER . error ( [string] [string] , error ) [EOL] return None [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] host = config [ DOMAIN ] [ CONF_HOST ] [EOL] port = config [ DOMAIN ] [ CONF_PORT ] [EOL] ssl = config [ DOMAIN ] [ CONF_SSL ] [EOL] user = config [ DOMAIN ] . get ( CONF_USERNAME ) [EOL] password = config [ DOMAIN ] . get ( CONF_PASSWORD ) [EOL] [EOL] [comment] [EOL] xs1 = await hass . async_add_executor_job ( partial ( _create_controller_api , host , port , ssl , user , password ) ) [EOL] if xs1 is None : [EOL] return False [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] hass . data [ DOMAIN ] = { } [EOL] [EOL] actuators = await hass . async_add_executor_job ( partial ( xs1 . get_all_actuators , enabled = True ) ) [EOL] sensors = await hass . async_add_executor_job ( partial ( xs1 . get_all_sensors , enabled = True ) ) [EOL] [EOL] hass . data [ DOMAIN ] [ ACTUATORS ] = actuators [EOL] hass . data [ DOMAIN ] [ SENSORS ] = sensors [EOL] [EOL] _LOGGER . debug ( [string] ) [EOL] [comment] [EOL] for component in XS1_COMPONENTS : [EOL] hass . async_create_task ( discovery . async_load_platform ( hass , component , DOMAIN , { } , config ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class XS1DeviceEntity ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] self . device = device [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] async with UPDATE_LOCK : [EOL] await self . hass . async_add_executor_job ( partial ( self . device . update ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.locks.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.locks.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import requests [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ID = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ID ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] ohmid = config . get ( CONF_ID ) [EOL] [EOL] add_entities ( [ OhmconnectSensor ( name , ohmid ) ] , True ) [EOL] [EOL] [EOL] class OhmconnectSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , ohmid ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _ohmid = ohmid [EOL] self . _data = { } [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _data . get ( [string] ) == [string] : [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _data . get ( [string] ) , [string] : self . _ohmid } [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] import defusedxml . ElementTree as ET [EOL] [EOL] try : [EOL] url = ( [string] [string] ) . format ( self . _ohmid ) [EOL] response = requests . get ( url , timeout = [number] ) [EOL] root = ET . fromstring ( response . text ) [EOL] [EOL] for child in root : [EOL] self . _data [ child . tag ] = child . text [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] , url ) [EOL] self . _data = { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . helpers import config_entry_flow [EOL] from . const import DOMAIN [EOL] [EOL] [EOL] config_entry_flow . register_webhook_flow ( DOMAIN , [string] , { [string] : [string] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( __package__ ) [EOL] DOMAIN = [string] [EOL] [EOL] CONTROLLER_ID = [string] [EOL] [EOL] CONF_CONTROLLER = [string] [EOL] CONF_SITE_ID = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import typing [EOL] import ssl [EOL] [docstring] [EOL] import asyncio [EOL] import ssl [EOL] import async_timeout [EOL] [EOL] from aiohttp import CookieJar [EOL] [EOL] import aiounifi [EOL] [EOL] from homeassistant . exceptions import ConfigEntryNotReady [EOL] from homeassistant . const import CONF_HOST [EOL] from homeassistant . helpers import aiohttp_client [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_send [EOL] [EOL] from . const import CONF_CONTROLLER , CONF_SITE_ID , CONTROLLER_ID , LOGGER [EOL] from . errors import AuthenticationRequired , CannotConnect [EOL] [EOL] [EOL] class UniFiController : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config_entry ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . config_entry = config_entry [EOL] self . available = True [EOL] self . api = None [EOL] self . progress = None [EOL] [EOL] @ property def host ( self ) : [EOL] [docstring] [EOL] return self . config_entry . data [ CONF_CONTROLLER ] [ CONF_HOST ] [EOL] [EOL] @ property def mac ( self ) : [EOL] [docstring] [EOL] for client in self . api . clients . values ( ) : [EOL] if self . host == client . ip : [EOL] return client . mac [EOL] return None [EOL] [EOL] @ property def event_update ( self ) : [EOL] [docstring] [EOL] return [string] . format ( CONTROLLER_ID . format ( host = self . host , site = self . config_entry . data [ CONF_CONTROLLER ] [ CONF_SITE_ID ] ) ) [EOL] [EOL] async def request_update ( self ) : [EOL] [docstring] [EOL] if self . progress is not None : [EOL] return await self . progress [EOL] [EOL] self . progress = self . hass . async_create_task ( self . async_update ( ) ) [EOL] await self . progress [EOL] [EOL] self . progress = None [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] failed = False [EOL] [EOL] try : [EOL] with async_timeout . timeout ( [number] ) : [EOL] await self . api . clients . update ( ) [EOL] await self . api . devices . update ( ) [EOL] [EOL] except aiounifi . LoginRequired : [EOL] try : [EOL] with async_timeout . timeout ( [number] ) : [EOL] await self . api . login ( ) [EOL] [EOL] except ( asyncio . TimeoutError , aiounifi . AiounifiException ) : [EOL] failed = True [EOL] if self . available : [EOL] LOGGER . error ( [string] , self . host ) [EOL] self . available = False [EOL] [EOL] except ( asyncio . TimeoutError , aiounifi . AiounifiException ) : [EOL] failed = True [EOL] if self . available : [EOL] LOGGER . error ( [string] , self . host ) [EOL] self . available = False [EOL] [EOL] if not failed and not self . available : [EOL] LOGGER . info ( [string] , self . host ) [EOL] self . available = True [EOL] [EOL] async_dispatcher_send ( self . hass , self . event_update ) [EOL] [EOL] async def async_setup ( self ) : [EOL] [docstring] [EOL] hass = self . hass [EOL] [EOL] try : [EOL] self . api = await get_controller ( self . hass , ** self . config_entry . data [ CONF_CONTROLLER ] ) [EOL] await self . api . initialize ( ) [EOL] [EOL] except CannotConnect : [EOL] raise ConfigEntryNotReady [EOL] [EOL] except Exception : [comment] [EOL] LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] hass . async_create_task ( hass . config_entries . async_forward_entry_setup ( self . config_entry , [string] ) ) [EOL] [EOL] return True [EOL] [EOL] async def async_reset ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . api is None : [EOL] return True [EOL] [EOL] return await self . hass . config_entries . async_forward_entry_unload ( self . config_entry , [string] ) [EOL] [EOL] [EOL] async def get_controller ( hass , host , username , password , port , site , verify_ssl ) : [EOL] [docstring] [EOL] sslcontext = None [EOL] [EOL] if verify_ssl : [EOL] session = aiohttp_client . async_get_clientsession ( hass ) [EOL] if isinstance ( verify_ssl , str ) : [EOL] sslcontext = ssl . create_default_context ( cafile = verify_ssl ) [EOL] else : [EOL] session = aiohttp_client . async_create_clientsession ( hass , verify_ssl = verify_ssl , cookie_jar = CookieJar ( unsafe = True ) ) [EOL] [EOL] controller = aiounifi . Controller ( host , username = username , password = password , port = port , site = site , websession = session , sslcontext = sslcontext ) [EOL] [EOL] try : [EOL] with async_timeout . timeout ( [number] ) : [EOL] await controller . login ( ) [EOL] return controller [EOL] [EOL] except aiounifi . Unauthorized : [EOL] LOGGER . warning ( [string] , host ) [EOL] raise AuthenticationRequired [EOL] [EOL] except ( asyncio . TimeoutError , aiounifi . RequestError ) : [EOL] LOGGER . error ( [string] , host ) [EOL] raise CannotConnect [EOL] [EOL] except aiounifi . AiounifiException : [EOL] LOGGER . exception ( [string] ) [EOL] raise AuthenticationRequired [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Union , List [EOL] import homeassistant [EOL] import logging [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] from adguardhome import AdGuardHomeConnectionError , AdGuardHomeError [EOL] [EOL] from homeassistant . components . adguard import AdGuardHomeDeviceEntity [EOL] from homeassistant . components . adguard . const import ( DATA_ADGUARD_CLIENT , DATA_ADGUARD_VERION , DOMAIN ) [EOL] from homeassistant . config_entries import ConfigEntry [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] from homeassistant . helpers . typing import HomeAssistantType [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] PARALLEL_UPDATES = [number] [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry , async_add_entities ) : [EOL] [docstring] [EOL] adguard = hass . data [ DOMAIN ] [ DATA_ADGUARD_CLIENT ] [EOL] [EOL] try : [EOL] version = await adguard . version ( ) [EOL] except AdGuardHomeConnectionError as exception : [EOL] raise PlatformNotReady from exception [EOL] [EOL] hass . data [ DOMAIN ] [ DATA_ADGUARD_VERION ] = version [EOL] [EOL] switches = [ AdGuardHomeProtectionSwitch ( adguard ) , AdGuardHomeFilteringSwitch ( adguard ) , AdGuardHomeParentalSwitch ( adguard ) , AdGuardHomeSafeBrowsingSwitch ( adguard ) , AdGuardHomeSafeSearchSwitch ( adguard ) , AdGuardHomeQueryLogSwitch ( adguard ) , ] [EOL] async_add_entities ( switches , True ) [EOL] [EOL] [EOL] class AdGuardHomeSwitch ( ToggleEntity , AdGuardHomeDeviceEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , adguard , name , icon , key ) : [EOL] [docstring] [EOL] self . _state = False [EOL] self . _key = key [EOL] super ( ) . __init__ ( adguard , name , icon ) [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return [string] . join ( [ DOMAIN , self . adguard . host , str ( self . adguard . port ) , [string] , self . _key , ] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] async def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] try : [EOL] await self . _adguard_turn_off ( ) [EOL] except AdGuardHomeError : [EOL] _LOGGER . error ( [string] ) [EOL] self . _available = False [EOL] [EOL] async def _adguard_turn_off ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] async def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] try : [EOL] await self . _adguard_turn_on ( ) [EOL] except AdGuardHomeError : [EOL] _LOGGER . error ( [string] ) [EOL] self . _available = False [EOL] [EOL] async def _adguard_turn_on ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] [EOL] class AdGuardHomeProtectionSwitch ( AdGuardHomeSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , adguard ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( adguard , [string] , [string] , [string] ) [EOL] [EOL] async def _adguard_turn_off ( self ) : [EOL] [docstring] [EOL] await self . adguard . disable_protection ( ) [EOL] [EOL] async def _adguard_turn_on ( self ) : [EOL] [docstring] [EOL] await self . adguard . enable_protection ( ) [EOL] [EOL] async def _adguard_update ( self ) : [EOL] [docstring] [EOL] self . _state = await self . adguard . protection_enabled ( ) [EOL] [EOL] [EOL] class AdGuardHomeParentalSwitch ( AdGuardHomeSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , adguard ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( adguard , [string] , [string] , [string] ) [EOL] [EOL] async def _adguard_turn_off ( self ) : [EOL] [docstring] [EOL] await self . adguard . parental . disable ( ) [EOL] [EOL] async def _adguard_turn_on ( self ) : [EOL] [docstring] [EOL] await self . adguard . parental . enable ( ) [EOL] [EOL] async def _adguard_update ( self ) : [EOL] [docstring] [EOL] self . _state = await self . adguard . parental . enabled ( ) [EOL] [EOL] [EOL] class AdGuardHomeSafeSearchSwitch ( AdGuardHomeSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , adguard ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( adguard , [string] , [string] , [string] ) [EOL] [EOL] async def _adguard_turn_off ( self ) : [EOL] [docstring] [EOL] await self . adguard . safesearch . disable ( ) [EOL] [EOL] async def _adguard_turn_on ( self ) : [EOL] [docstring] [EOL] await self . adguard . safesearch . enable ( ) [EOL] [EOL] async def _adguard_update ( self ) : [EOL] [docstring] [EOL] self . _state = await self . adguard . safesearch . enabled ( ) [EOL] [EOL] [EOL] class AdGuardHomeSafeBrowsingSwitch ( AdGuardHomeSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , adguard ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( adguard , [string] , [string] , [string] , ) [EOL] [EOL] async def _adguard_turn_off ( self ) : [EOL] [docstring] [EOL] await self . adguard . safebrowsing . disable ( ) [EOL] [EOL] async def _adguard_turn_on ( self ) : [EOL] [docstring] [EOL] await self . adguard . safebrowsing . enable ( ) [EOL] [EOL] async def _adguard_update ( self ) : [EOL] [docstring] [EOL] self . _state = await self . adguard . safebrowsing . enabled ( ) [EOL] [EOL] [EOL] class AdGuardHomeFilteringSwitch ( AdGuardHomeSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , adguard ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( adguard , [string] , [string] , [string] ) [EOL] [EOL] async def _adguard_turn_off ( self ) : [EOL] [docstring] [EOL] await self . adguard . filtering . disable ( ) [EOL] [EOL] async def _adguard_turn_on ( self ) : [EOL] [docstring] [EOL] await self . adguard . filtering . enable ( ) [EOL] [EOL] async def _adguard_update ( self ) : [EOL] [docstring] [EOL] self . _state = await self . adguard . filtering . enabled ( ) [EOL] [EOL] [EOL] class AdGuardHomeQueryLogSwitch ( AdGuardHomeSwitch ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , adguard ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( adguard , [string] , [string] , [string] ) [EOL] [EOL] async def _adguard_turn_off ( self ) : [EOL] [docstring] [EOL] await self . adguard . querylog . disable ( ) [EOL] [EOL] async def _adguard_turn_on ( self ) : [EOL] [docstring] [EOL] await self . adguard . querylog . enable ( ) [EOL] [EOL] async def _adguard_update ( self ) : [EOL] [docstring] [EOL] self . _state = await self . adguard . querylog . enabled ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Type [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from adguardhome import AdGuardHome , AdGuardHomeConnectionError [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import config_entries [EOL] from homeassistant . components . adguard . const import DOMAIN [EOL] from homeassistant . config_entries import ConfigFlow [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_PORT , CONF_SSL , CONF_USERNAME , CONF_VERIFY_SSL ) [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ config_entries . HANDLERS . register ( DOMAIN ) class AdGuardHomeFlowHandler ( ConfigFlow ) : [EOL] [docstring] [EOL] [EOL] VERSION = [number] [EOL] CONNECTION_CLASS = config_entries . CONN_CLASS_LOCAL_POLL [EOL] [EOL] _hassio_discovery = None [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] async def _show_setup_form ( self , errors = None ) : [EOL] [docstring] [EOL] return self . async_show_form ( step_id = [string] , data_schema = vol . Schema ( { vol . Required ( CONF_HOST ) : str , vol . Required ( CONF_PORT , default = [number] ) : vol . Coerce ( int ) , vol . Optional ( CONF_USERNAME ) : str , vol . Optional ( CONF_PASSWORD ) : str , vol . Required ( CONF_SSL , default = True ) : bool , vol . Required ( CONF_VERIFY_SSL , default = True ) : bool , } ) , errors = errors or { } , ) [EOL] [EOL] async def _show_hassio_form ( self , errors = None ) : [EOL] [docstring] [EOL] return self . async_show_form ( step_id = [string] , description_placeholders = { [string] : self . _hassio_discovery [ [string] ] } , data_schema = vol . Schema ( { } ) , errors = errors or { } , ) [EOL] [EOL] async def async_step_user ( self , user_input = None ) : [EOL] [docstring] [EOL] if self . _async_current_entries ( ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] if user_input is None : [EOL] return await self . _show_setup_form ( user_input ) [EOL] [EOL] errors = { } [EOL] [EOL] session = async_get_clientsession ( self . hass , user_input [ CONF_VERIFY_SSL ] ) [EOL] [EOL] adguard = AdGuardHome ( user_input [ CONF_HOST ] , port = user_input [ CONF_PORT ] , username = user_input . get ( CONF_USERNAME ) , password = user_input . get ( CONF_PASSWORD ) , tls = user_input [ CONF_SSL ] , verify_ssl = user_input [ CONF_VERIFY_SSL ] , loop = self . hass . loop , session = session , ) [EOL] [EOL] try : [EOL] await adguard . version ( ) [EOL] except AdGuardHomeConnectionError : [EOL] errors [ [string] ] = [string] [EOL] return await self . _show_setup_form ( errors ) [EOL] [EOL] return self . async_create_entry ( title = user_input [ CONF_HOST ] , data = { CONF_HOST : user_input [ CONF_HOST ] , CONF_PASSWORD : user_input . get ( CONF_PASSWORD ) , CONF_PORT : user_input [ CONF_PORT ] , CONF_SSL : user_input [ CONF_SSL ] , CONF_USERNAME : user_input . get ( CONF_USERNAME ) , CONF_VERIFY_SSL : user_input [ CONF_VERIFY_SSL ] , } , ) [EOL] [EOL] async def async_step_hassio ( self , user_input = None ) : [EOL] [docstring] [EOL] entries = self . _async_current_entries ( ) [EOL] [EOL] if not entries : [EOL] self . _hassio_discovery = user_input [EOL] return await self . async_step_hassio_confirm ( ) [EOL] [EOL] cur_entry = entries [ [number] ] [EOL] [EOL] if ( cur_entry . data [ CONF_HOST ] == user_input [ CONF_HOST ] and cur_entry . data [ CONF_PORT ] == user_input [ CONF_PORT ] ) : [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] is_loaded = cur_entry . state == config_entries . ENTRY_STATE_LOADED [EOL] [EOL] if is_loaded : [EOL] await self . hass . config_entries . async_unload ( cur_entry . entry_id ) [EOL] [EOL] self . hass . config_entries . async_update_entry ( cur_entry , data = { ** cur_entry . data , CONF_HOST : user_input [ CONF_HOST ] , CONF_PORT : user_input [ CONF_PORT ] , } ) [EOL] [EOL] if is_loaded : [EOL] await self . hass . config_entries . async_setup ( cur_entry . entry_id ) [EOL] [EOL] return self . async_abort ( reason = [string] ) [EOL] [EOL] async def async_step_hassio_confirm ( self , user_input = None ) : [EOL] [docstring] [EOL] if user_input is None : [EOL] return await self . _show_hassio_form ( ) [EOL] [EOL] errors = { } [EOL] [EOL] session = async_get_clientsession ( self . hass , False ) [EOL] [EOL] adguard = AdGuardHome ( self . _hassio_discovery [ CONF_HOST ] , port = self . _hassio_discovery [ CONF_PORT ] , tls = False , loop = self . hass . loop , session = session , ) [EOL] [EOL] try : [EOL] await adguard . version ( ) [EOL] except AdGuardHomeConnectionError : [EOL] errors [ [string] ] = [string] [EOL] return await self . _show_hassio_form ( errors ) [EOL] [EOL] return self . async_create_entry ( title = self . _hassio_discovery [ [string] ] , data = { CONF_HOST : self . _hassio_discovery [ CONF_HOST ] , CONF_PORT : self . _hassio_discovery [ CONF_PORT ] , CONF_PASSWORD : None , CONF_SSL : False , CONF_USERNAME : None , CONF_VERIFY_SSL : True , } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] DATA_ADGUARD_CLIENT = [string] [EOL] DATA_ADGUARD_VERION = [string] [EOL] [EOL] CONF_FORCE = [string] [EOL] [EOL] SERVICE_ADD_URL = [string] [EOL] SERVICE_DISABLE_URL = [string] [EOL] SERVICE_ENABLE_URL = [string] [EOL] SERVICE_REFRESH = [string] [EOL] SERVICE_REMOVE_URL = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import homeassistant [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] from copy import copy [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( MediaPlayerDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . media_player . const import ( ATTR_APP_ID , ATTR_APP_NAME , ATTR_INPUT_SOURCE , ATTR_INPUT_SOURCE_LIST , ATTR_MEDIA_ALBUM_ARTIST , ATTR_MEDIA_ALBUM_NAME , ATTR_MEDIA_ARTIST , ATTR_MEDIA_CHANNEL , ATTR_MEDIA_CONTENT_ID , ATTR_MEDIA_CONTENT_TYPE , ATTR_MEDIA_DURATION , ATTR_MEDIA_EPISODE , ATTR_MEDIA_PLAYLIST , ATTR_MEDIA_POSITION , ATTR_MEDIA_POSITION_UPDATED_AT , ATTR_MEDIA_SEASON , ATTR_MEDIA_SEEK_POSITION , ATTR_MEDIA_SERIES_TITLE , ATTR_MEDIA_SHUFFLE , ATTR_MEDIA_TITLE , ATTR_MEDIA_TRACK , ATTR_MEDIA_VOLUME_LEVEL , ATTR_MEDIA_VOLUME_MUTED , DOMAIN , SERVICE_CLEAR_PLAYLIST , SERVICE_PLAY_MEDIA , SERVICE_SELECT_SOURCE , SUPPORT_CLEAR_PLAYLIST , SUPPORT_SELECT_SOURCE , SUPPORT_SHUFFLE_SET , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_VOLUME_STEP ) [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_ENTITY_PICTURE , ATTR_SUPPORTED_FEATURES , CONF_NAME , CONF_STATE , CONF_STATE_TEMPLATE , SERVICE_MEDIA_NEXT_TRACK , SERVICE_MEDIA_PAUSE , SERVICE_MEDIA_PLAY , SERVICE_MEDIA_PLAY_PAUSE , SERVICE_MEDIA_PREVIOUS_TRACK , SERVICE_MEDIA_SEEK , SERVICE_MEDIA_STOP , SERVICE_SHUFFLE_SET , SERVICE_TURN_OFF , SERVICE_TURN_ON , SERVICE_VOLUME_DOWN , SERVICE_VOLUME_MUTE , SERVICE_VOLUME_SET , SERVICE_VOLUME_UP , STATE_IDLE , STATE_OFF , STATE_ON , STATE_UNAVAILABLE ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . service import async_call_from_config [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_ACTIVE_CHILD = [string] [EOL] ATTR_DATA = [string] [EOL] [EOL] CONF_ATTRS = [string] [EOL] CONF_CHILDREN = [string] [EOL] CONF_COMMANDS = [string] [EOL] CONF_SERVICE = [string] [EOL] CONF_SERVICE_DATA = [string] [EOL] [EOL] OFF_STATES = [ STATE_IDLE , STATE_OFF , STATE_UNAVAILABLE ] [EOL] [EOL] ATTRS_SCHEMA = cv . schema_with_slug_keys ( cv . string ) [EOL] CMD_SCHEMA = cv . schema_with_slug_keys ( cv . SERVICE_SCHEMA ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_CHILDREN , default = [ ] ) : cv . entity_ids , vol . Optional ( CONF_COMMANDS , default = { } ) : CMD_SCHEMA , vol . Optional ( CONF_ATTRS , default = { } ) : vol . Or ( cv . ensure_list ( ATTRS_SCHEMA ) , ATTRS_SCHEMA ) , vol . Optional ( CONF_STATE_TEMPLATE ) : cv . template } , extra = vol . REMOVE_EXTRA ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] player = UniversalMediaPlayer ( hass , config . get ( CONF_NAME ) , config . get ( CONF_CHILDREN ) , config . get ( CONF_COMMANDS ) , config . get ( CONF_ATTRS ) , config . get ( CONF_STATE_TEMPLATE ) ) [EOL] [EOL] async_add_entities ( [ player ] ) [EOL] [EOL] [EOL] class UniversalMediaPlayer ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , children , commands , attributes , state_template = None ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _name = name [EOL] self . _children = children [EOL] self . _cmds = commands [EOL] self . _attrs = { } [EOL] for key , val in attributes . items ( ) : [EOL] attr = val . split ( [string] , [number] ) [EOL] if len ( attr ) == [number] : [EOL] attr . append ( None ) [EOL] self . _attrs [ key ] = attr [EOL] self . _child_state = None [EOL] self . _state_template = state_template [EOL] if state_template is not None : [EOL] self . _state_template . hass = hass [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] @ callback def async_on_dependency_update ( * _ ) : [EOL] [docstring] [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] depend = copy ( self . _children ) [EOL] for entity in self . _attrs . values ( ) : [EOL] depend . append ( entity [ [number] ] ) [EOL] if self . _state_template is not None : [EOL] for entity in self . _state_template . extract_entities ( ) : [EOL] depend . append ( entity ) [EOL] [EOL] self . hass . helpers . event . async_track_state_change ( list ( set ( depend ) ) , async_on_dependency_update ) [EOL] [EOL] def _entity_lkp ( self , entity_id , state_attr = None ) : [EOL] [docstring] [EOL] state_obj = self . hass . states . get ( entity_id ) [EOL] [EOL] if state_obj is None : [EOL] return [EOL] [EOL] if state_attr : [EOL] return state_obj . attributes . get ( state_attr ) [EOL] return state_obj . state [EOL] [EOL] def _override_or_child_attr ( self , attr_name ) : [EOL] [docstring] [EOL] if attr_name in self . _attrs : [EOL] return self . _entity_lkp ( self . _attrs [ attr_name ] [ [number] ] , self . _attrs [ attr_name ] [ [number] ] ) [EOL] [EOL] return self . _child_attr ( attr_name ) [EOL] [EOL] def _child_attr ( self , attr_name ) : [EOL] [docstring] [EOL] active_child = self . _child_state [EOL] return active_child . attributes . get ( attr_name ) if active_child else None [EOL] [EOL] async def _async_call_service ( self , service_name , service_data = None , allow_override = False ) : [EOL] [docstring] [EOL] if service_data is None : [EOL] service_data = { } [EOL] [EOL] if allow_override and service_name in self . _cmds : [EOL] await async_call_from_config ( self . hass , self . _cmds [ service_name ] , variables = service_data , blocking = True , validate_config = False ) [EOL] return [EOL] [EOL] active_child = self . _child_state [EOL] if active_child is None : [EOL] [comment] [EOL] return [EOL] [EOL] service_data [ ATTR_ENTITY_ID ] = active_child . entity_id [EOL] [EOL] await self . hass . services . async_call ( DOMAIN , service_name , service_data , blocking = True ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def master_state ( self ) : [EOL] [docstring] [EOL] if self . _state_template is not None : [EOL] return self . _state_template . async_render ( ) [EOL] if CONF_STATE in self . _attrs : [EOL] master_state = self . _entity_lkp ( self . _attrs [ CONF_STATE ] [ [number] ] , self . _attrs [ CONF_STATE ] [ [number] ] ) [EOL] return master_state if master_state else STATE_OFF [EOL] [EOL] return None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] master_state = self . master_state [comment] [EOL] if ( master_state == STATE_OFF ) or ( self . _state_template is not None ) : [EOL] return master_state [EOL] [EOL] active_child = self . _child_state [EOL] if active_child : [EOL] return active_child . state [EOL] [EOL] return master_state if master_state else STATE_OFF [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _override_or_child_attr ( ATTR_MEDIA_VOLUME_LEVEL ) [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _override_or_child_attr ( ATTR_MEDIA_VOLUME_MUTED ) in [ True , STATE_ON ] [EOL] [EOL] @ property def media_content_id ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_CONTENT_ID ) [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_CONTENT_TYPE ) [EOL] [EOL] @ property def media_duration ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_DURATION ) [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_ENTITY_PICTURE ) [EOL] [EOL] @ property def entity_picture ( self ) : [EOL] [docstring] [EOL] return self . media_image_url [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_TITLE ) [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_ARTIST ) [EOL] [EOL] @ property def media_album_name ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_ALBUM_NAME ) [EOL] [EOL] @ property def media_album_artist ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_ALBUM_ARTIST ) [EOL] [EOL] @ property def media_track ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_TRACK ) [EOL] [EOL] @ property def media_series_title ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_SERIES_TITLE ) [EOL] [EOL] @ property def media_season ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_SEASON ) [EOL] [EOL] @ property def media_episode ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_EPISODE ) [EOL] [EOL] @ property def media_channel ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_CHANNEL ) [EOL] [EOL] @ property def media_playlist ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_PLAYLIST ) [EOL] [EOL] @ property def app_id ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_APP_ID ) [EOL] [EOL] @ property def app_name ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_APP_NAME ) [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _override_or_child_attr ( ATTR_INPUT_SOURCE ) [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _override_or_child_attr ( ATTR_INPUT_SOURCE_LIST ) [EOL] [EOL] @ property def shuffle ( self ) : [EOL] [docstring] [EOL] return self . _override_or_child_attr ( ATTR_MEDIA_SHUFFLE ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] flags = self . _child_attr ( ATTR_SUPPORTED_FEATURES ) or [number] [EOL] [EOL] if SERVICE_TURN_ON in self . _cmds : [EOL] flags |= SUPPORT_TURN_ON [EOL] if SERVICE_TURN_OFF in self . _cmds : [EOL] flags |= SUPPORT_TURN_OFF [EOL] [EOL] if any ( [ cmd in self . _cmds for cmd in [ SERVICE_VOLUME_UP , SERVICE_VOLUME_DOWN ] ] ) : [EOL] flags |= SUPPORT_VOLUME_STEP [EOL] if SERVICE_VOLUME_SET in self . _cmds : [EOL] flags |= SUPPORT_VOLUME_SET [EOL] [EOL] if SERVICE_VOLUME_MUTE in self . _cmds and ATTR_MEDIA_VOLUME_MUTED in self . _attrs : [EOL] flags |= SUPPORT_VOLUME_MUTE [EOL] [EOL] if SERVICE_SELECT_SOURCE in self . _cmds : [EOL] flags |= SUPPORT_SELECT_SOURCE [EOL] [EOL] if SERVICE_CLEAR_PLAYLIST in self . _cmds : [EOL] flags |= SUPPORT_CLEAR_PLAYLIST [EOL] [EOL] if SERVICE_SHUFFLE_SET in self . _cmds and ATTR_MEDIA_SHUFFLE in self . _attrs : [EOL] flags |= SUPPORT_SHUFFLE_SET [EOL] [EOL] return flags [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] active_child = self . _child_state [EOL] return { ATTR_ACTIVE_CHILD : active_child . entity_id } \ [EOL] if active_child else { } [EOL] [EOL] @ property def media_position ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_POSITION ) [EOL] [EOL] @ property def media_position_updated_at ( self ) : [EOL] [docstring] [EOL] return self . _child_attr ( ATTR_MEDIA_POSITION_UPDATED_AT ) [EOL] [EOL] def async_turn_on ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_TURN_ON , allow_override = True ) [EOL] [EOL] def async_turn_off ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_TURN_OFF , allow_override = True ) [EOL] [EOL] def async_mute_volume ( self , mute ) : [EOL] [docstring] [EOL] data = { ATTR_MEDIA_VOLUME_MUTED : mute } [EOL] return self . _async_call_service ( SERVICE_VOLUME_MUTE , data , allow_override = True ) [EOL] [EOL] def async_set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] data = { ATTR_MEDIA_VOLUME_LEVEL : volume } [EOL] return self . _async_call_service ( SERVICE_VOLUME_SET , data , allow_override = True ) [EOL] [EOL] def async_media_play ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_MEDIA_PLAY ) [EOL] [EOL] def async_media_pause ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_MEDIA_PAUSE ) [EOL] [EOL] def async_media_stop ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_MEDIA_STOP ) [EOL] [EOL] def async_media_previous_track ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_MEDIA_PREVIOUS_TRACK ) [EOL] [EOL] def async_media_next_track ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_MEDIA_NEXT_TRACK ) [EOL] [EOL] def async_media_seek ( self , position ) : [EOL] [docstring] [EOL] data = { ATTR_MEDIA_SEEK_POSITION : position } [EOL] return self . _async_call_service ( SERVICE_MEDIA_SEEK , data ) [EOL] [EOL] def async_play_media ( self , media_type , media_id , ** kwargs ) : [EOL] [docstring] [EOL] data = { ATTR_MEDIA_CONTENT_TYPE : media_type , ATTR_MEDIA_CONTENT_ID : media_id } [EOL] return self . _async_call_service ( SERVICE_PLAY_MEDIA , data ) [EOL] [EOL] def async_volume_up ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_VOLUME_UP , allow_override = True ) [EOL] [EOL] def async_volume_down ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_VOLUME_DOWN , allow_override = True ) [EOL] [EOL] def async_media_play_pause ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_MEDIA_PLAY_PAUSE ) [EOL] [EOL] def async_select_source ( self , source ) : [EOL] [docstring] [EOL] data = { ATTR_INPUT_SOURCE : source } [EOL] return self . _async_call_service ( SERVICE_SELECT_SOURCE , data , allow_override = True ) [EOL] [EOL] def async_clear_playlist ( self ) : [EOL] [docstring] [EOL] return self . _async_call_service ( SERVICE_CLEAR_PLAYLIST ) [EOL] [EOL] def async_set_shuffle ( self , shuffle ) : [EOL] [docstring] [EOL] data = { ATTR_MEDIA_SHUFFLE : shuffle } [EOL] return self . _async_call_service ( SERVICE_SHUFFLE_SET , data , allow_override = True ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] for child_name in self . _children : [EOL] child_state = self . hass . states . get ( child_name ) [EOL] if child_state and child_state . state not in OFF_STATES : [EOL] self . _child_state = child_state [EOL] return [EOL] self . _child_state = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_HOST , CONF_PORT [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . helpers . discovery import async_load_platform [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] CONF_ENTITY_CONFIG = [string] [EOL] CONF_SYSTEM_ID = [string] [EOL] CONF_REVERSE = [string] [EOL] CONF_DEFAULT_REVERSE = [string] [EOL] DATA_SOMFY_MYLINK = [string] [EOL] DOMAIN = [string] [EOL] SOMFY_MYLINK_COMPONENTS = [ [string] ] [EOL] [EOL] [EOL] def validate_entity_config ( values ) : [EOL] [docstring] [EOL] entity_config_schema = vol . Schema ( { vol . Optional ( CONF_REVERSE ) : cv . boolean } ) [EOL] if not isinstance ( values , dict ) : [EOL] raise vol . Invalid ( [string] ) [EOL] entities = { } [EOL] for entity_id , config in values . items ( ) : [EOL] entity = cv . entity_id ( entity_id ) [EOL] config = entity_config_schema ( config ) [EOL] entities [ entity ] = config [EOL] return entities [EOL] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_SYSTEM_ID ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = [number] ) : cv . port , vol . Optional ( CONF_DEFAULT_REVERSE , default = False ) : cv . boolean , vol . Optional ( CONF_ENTITY_CONFIG , default = { } ) : validate_entity_config } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] from somfy_mylink_synergy import SomfyMyLinkSynergy [EOL] host = config [ DOMAIN ] [ CONF_HOST ] [EOL] port = config [ DOMAIN ] [ CONF_PORT ] [EOL] system_id = config [ DOMAIN ] [ CONF_SYSTEM_ID ] [EOL] entity_config = config [ DOMAIN ] [ CONF_ENTITY_CONFIG ] [EOL] entity_config [ CONF_DEFAULT_REVERSE ] = config [ DOMAIN ] [ CONF_DEFAULT_REVERSE ] [EOL] somfy_mylink = SomfyMyLinkSynergy ( system_id , host , port ) [EOL] hass . data [ DATA_SOMFY_MYLINK ] = somfy_mylink [EOL] for component in SOMFY_MYLINK_COMPONENTS : [EOL] hass . async_create_task ( async_load_platform ( hass , component , DOMAIN , entity_config , config ) ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . cover import ENTITY_ID_FORMAT , CoverDevice [EOL] from homeassistant . util import slugify [EOL] [EOL] from . import CONF_DEFAULT_REVERSE , DATA_SOMFY_MYLINK [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] somfy_mylink = hass . data [ DATA_SOMFY_MYLINK ] [EOL] cover_list = [ ] [EOL] try : [EOL] mylink_status = await somfy_mylink . status_info ( ) [EOL] except TimeoutError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return [EOL] for cover in mylink_status [ [string] ] : [EOL] entity_id = ENTITY_ID_FORMAT . format ( slugify ( cover [ [string] ] ) ) [EOL] entity_config = discovery_info . get ( entity_id , { } ) [EOL] default_reverse = discovery_info [ CONF_DEFAULT_REVERSE ] [EOL] cover_config = { } [EOL] cover_config [ [string] ] = cover [ [string] ] [EOL] cover_config [ [string] ] = cover [ [string] ] [EOL] cover_config [ [string] ] = entity_config . get ( [string] , default_reverse ) [EOL] cover_list . append ( SomfyShade ( somfy_mylink , ** cover_config ) ) [EOL] _LOGGER . info ( [string] , cover_config [ [string] ] , cover_config [ [string] ] ) [EOL] async_add_entities ( cover_list ) [EOL] [EOL] [EOL] class SomfyShade ( CoverDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , somfy_mylink , target_id = [string] , name = [string] , reverse = False , device_class = [string] ) : [EOL] [docstring] [EOL] self . somfy_mylink = somfy_mylink [EOL] self . _target_id = target_id [EOL] self . _name = name [EOL] self . _reverse = reverse [EOL] self . _device_class = device_class [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] async def async_open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _reverse : [EOL] await self . somfy_mylink . move_up ( self . _target_id ) [EOL] else : [EOL] await self . somfy_mylink . move_down ( self . _target_id ) [EOL] [EOL] async def async_close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _reverse : [EOL] await self . somfy_mylink . move_down ( self . _target_id ) [EOL] else : [EOL] await self . somfy_mylink . move_up ( self . _target_id ) [EOL] [EOL] async def async_stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] await self . somfy_mylink . move_stop ( self . _target_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import logging [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import logging [EOL] from numbers import Number [EOL] from homeassistant . const import ( VOLUME_LITERS , VOLUME_MILLILITERS , VOLUME_GALLONS , VOLUME_FLUID_OUNCE , VOLUME , UNIT_NOT_RECOGNIZED_TEMPLATE ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] VALID_UNITS = [ VOLUME_LITERS , VOLUME_MILLILITERS , VOLUME_GALLONS , VOLUME_FLUID_OUNCE ] [EOL] [EOL] [EOL] def __liter_to_gallon ( liter ) : [EOL] [docstring] [EOL] return liter * [number] [EOL] [EOL] [EOL] def __gallon_to_liter ( gallon ) : [EOL] [docstring] [EOL] return gallon * [number] [EOL] [EOL] [EOL] def convert ( volume , from_unit , to_unit ) : [EOL] [docstring] [EOL] if from_unit not in VALID_UNITS : [EOL] raise ValueError ( UNIT_NOT_RECOGNIZED_TEMPLATE . format ( from_unit , VOLUME ) ) [EOL] if to_unit not in VALID_UNITS : [EOL] raise ValueError ( UNIT_NOT_RECOGNIZED_TEMPLATE . format ( to_unit , VOLUME ) ) [EOL] [EOL] if not isinstance ( volume , Number ) : [EOL] raise TypeError ( [string] . format ( volume ) ) [EOL] [EOL] if from_unit == to_unit : [EOL] return volume [EOL] [EOL] result = volume [EOL] if from_unit == VOLUME_LITERS and to_unit == VOLUME_GALLONS : [EOL] result = __liter_to_gallon ( volume ) [EOL] elif from_unit == VOLUME_GALLONS and to_unit == VOLUME_LITERS : [EOL] result = __gallon_to_liter ( volume ) [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] SECRET_YAML = [string] [EOL] [EOL] _SECRET_NAMESPACE = [string] [EOL]	0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] [EOL] [EOL] class NodeListClass ( list ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] class NodeStrClass ( str ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0