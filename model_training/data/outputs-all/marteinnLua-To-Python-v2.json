import click [EOL] [EOL] [EOL] @ click . command ( ) def run ( ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import luatopy [EOL] from io import StringIO [EOL] [EOL] import click [EOL] [EOL] from luatopy . lexer import Lexer [EOL] from luatopy . parser import Parser [EOL] from luatopy . obj import Environment [EOL] from luatopy import evaluator [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , is_flag = True , help = [string] ) @ click . option ( [string] , is_flag = True , help = [string] ) def run ( tokens , ast_code ) : [EOL] print ( [string] ) [EOL] if tokens : [EOL] print ( [string] ) [EOL] [EOL] if ast_code : [EOL] print ( [string] ) [EOL] [EOL] env = Environment ( ) [EOL] while True : [EOL] source = input ( [string] ) [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] if tokens : [EOL] print ( list ( lexer . tokens ( ) ) ) [EOL] [EOL] parser = Parser ( lexer ) [EOL] program = parser . parse_program ( ) [EOL] [EOL] if parser . errors : [EOL] for err in parser . errors : [EOL] print ( [string] . format ( err ) ) [EOL] [EOL] if ast_code : [EOL] print ( program . to_code ( ) ) [EOL] [EOL] evaluated = evaluator . evaluate ( program , env ) [EOL] if evaluated : [EOL] print ( evaluated . inspect ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any , Union [EOL] import typing [EOL] import luatopy [EOL] from io import StringIO [EOL] import unittest [EOL] [EOL] from luatopy . lexer import Lexer [EOL] from luatopy . parser import Parser [EOL] from luatopy import obj [EOL] from luatopy import evaluator [EOL] [EOL] [EOL] class EvaluatorTest ( unittest . TestCase ) : [EOL] def test_integer_expressions ( self ) : [EOL] tests = [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , - [number] ) , ( [string] , - [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , - [number] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Integer ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_float_expressions ( self ) : [EOL] tests = [ ( [string] , [number] ) , ( [string] , [number] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Float ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_string_concat ( self ) : [EOL] tests = [ ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . String ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_boolean_expressions ( self ) : [EOL] tests = [ ( [string] , False ) , ( [string] , True ) , ( [string] , False ) , ( [string] , False ) , ( [string] , True ) , ( [string] , True ) , ( [string] , True ) , ( [string] , False ) , ( [string] , False ) , ( [string] , True ) , ( [string] , True ) , ( [string] , True ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Boolean ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_not_prefix_operator ( self ) : [EOL] tests = [ ( [string] , True ) , ( [string] , False ) , ( [string] , False ) , ( [string] , True ) , ( [string] , True ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Boolean ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_bool_infix_operations ( self ) : [EOL] tests = [ ( [string] , True ) , ( [string] , False ) , ( [string] , False ) , ( [string] , True ) , ( [string] , True ) , ( [string] , False ) , ( [string] , False ) , ( [string] , False ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Boolean ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_length_prefix_operator ( self ) : [EOL] tests = [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Integer ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_if_else_expressions ( self ) : [EOL] tests = [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , evaluator . NULL ) , ( [string] , [number] ) , ( [string] , evaluator . NULL ) , ( [string] , [number] ) , ( [string] , [number] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] if evaluated == evaluator . NULL : [EOL] self . assertEqual ( evaluated , expected ) [EOL] else : [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_return_statements ( self ) : [EOL] tests = [ ( [string] , [number] ) , ( [string] , [number] , ) , ( [string] , [number] ) , ( [string] , [number] , ) , ( [string] , [number] , ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Integer ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_error_handling ( self ) : [EOL] tests = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] , ) , ( [string] , [string] ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Error ) [EOL] self . assertEqual ( evaluated . message , expected ) [EOL] [EOL] def test_that_non_existing_identifiers_returns_nil ( self ) : [EOL] tests = [ ( [string] , [string] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Null ) [EOL] [EOL] def test_assignments ( self ) : [EOL] tests = [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Integer ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_function_declaration ( self ) : [EOL] tests = [ ( [string] , [string] , ) ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] [EOL] self . assertEqual ( type ( evaluated ) , obj . Function ) [EOL] self . assertEqual ( evaluated . inspect ( ) , expected ) [EOL] [EOL] def test_named_function_declaration ( self ) : [EOL] tests = [ ( [string] , [number] ) , ( [string] , [string] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_function_call ( self ) : [EOL] tests = [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_function_closure ( self ) : [EOL] source = [string] [EOL] [EOL] evaluated = source_to_eval ( source ) [EOL] self . assertEqual ( evaluated . value , [number] ) [EOL] [EOL] def test_string_expressions ( self ) : [EOL] tests = [ ( [string] , [string] ) ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_builints ( self ) : [EOL] tests = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] self . assertEqual ( evaluated . value , expected ) [EOL] [EOL] def test_table_expressions ( self ) : [EOL] tests = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] self . assertEqual ( evaluated . inspect ( ) , expected ) [EOL] [EOL] def test_table_index_expressions ( self ) : [EOL] tests = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] evaluated = source_to_eval ( source ) [EOL] self . assertEqual ( evaluated . inspect ( ) , expected ) [EOL] [EOL] [EOL] def source_to_eval ( source ) : [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] parser = Parser ( lexer ) [EOL] program = parser . parse_program ( ) [EOL] env = obj . Environment ( ) [EOL] return evaluator . evaluate ( program , env ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.float]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.int,luatopy.obj.Null]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.int,luatopy.obj.Null]]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.int]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Literal , Any [EOL] import typing [EOL] import typing_extensions [EOL] import luatopy [EOL] from io import StringIO [EOL] import unittest [EOL] [EOL] from luatopy . lexer import Lexer [EOL] from luatopy . parser import Parser [EOL] from luatopy import ast [EOL] [EOL] [EOL] class ParserTest ( unittest . TestCase ) : [EOL] def test_prefix_parsing ( self ) : [EOL] tests = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_influx_parsing ( self ) : [EOL] tests = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_string_influx_parsing ( self ) : [EOL] tests = ( ( [string] , [string] ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_operator_precedence ( self ) : [EOL] tests = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_operator_precedence_groups ( self ) : [EOL] tests = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_semicolon_delimiter ( self ) : [EOL] tests = ( ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) ) [EOL] [EOL] for source , expected in tests : [EOL] program = program_from_source ( source ) [EOL] self . assertEqual ( len ( program . statements ) , expected ) [EOL] [EOL] def test_integer_literal ( self ) : [EOL] program = program_from_source ( [string] ) [EOL] [EOL] statement = program . statements [ [number] ] [EOL] self . assertIs ( type ( statement ) , ast . ExpressionStatement ) [EOL] self . assertIs ( type ( statement . expression ) , ast . IntegerLiteral ) [EOL] [EOL] def test_identifier ( self ) : [EOL] program = program_from_source ( [string] ) [EOL] [EOL] statement = program . statements [ [number] ] [EOL] self . assertIs ( type ( statement ) , ast . ExpressionStatement ) [EOL] self . assertIs ( type ( statement . expression ) , ast . Identifier ) [EOL] [EOL] def test_booleans ( self ) : [EOL] program = program_from_source ( [string] ) [EOL] [EOL] statement = program . statements [ [number] ] [EOL] self . assertIs ( type ( statement ) , ast . ExpressionStatement ) [EOL] self . assertIs ( type ( statement . expression ) , ast . Boolean ) [EOL] self . assertIs ( statement . expression . value , True ) [EOL] [EOL] def test_variable_assign ( self ) : [EOL] self . assertEqual ( program_from_source ( [string] ) . to_code ( ) , [string] ) [EOL] self . assertEqual ( program_from_source ( [string] ) . to_code ( ) , [string] ) [EOL] self . assertEqual ( program_from_source ( [string] ) . to_code ( ) , [string] ) [EOL] [EOL] def test_multiple_variable_assign ( self ) : [EOL] source = [string] [EOL] [EOL] program = program_from_source ( source ) [EOL] self . assertEqual ( len ( program . statements ) , [number] ) [EOL] self . assertEqual ( program . statements [ [number] ] . to_code ( ) , [string] ) [EOL] self . assertEqual ( program . statements [ [number] ] . to_code ( ) , [string] ) [EOL] self . assertEqual ( program . statements [ [number] ] . to_code ( ) , [string] ) [EOL] [EOL] def test_if_statements ( self ) : [EOL] tests = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] , ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_function_statements ( self ) : [EOL] tests = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_named_function_statements ( self ) : [EOL] tests = ( ( [string] , [string] ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_function_calls ( self ) : [EOL] tests = ( ( [string] , [string] ) , ( [string] , [string] ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_return_statements ( self ) : [EOL] tests = ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ) [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_string_literal ( self ) : [EOL] program = program_from_source ( [string] ) [EOL] [EOL] statement = program . statements [ [number] ] [EOL] self . assertIs ( type ( statement ) , ast . ExpressionStatement ) [EOL] self . assertIs ( type ( statement . expression ) , ast . StringLiteral ) [EOL] [EOL] def test_table_literal ( self ) : [EOL] program = program_from_source ( [string] ) [EOL] [EOL] statement = program . statements [ [number] ] [EOL] self . assertIs ( type ( statement ) , ast . ExpressionStatement ) [EOL] self . assertIs ( type ( statement . expression ) , ast . TableLiteral ) [EOL] [EOL] def test_table_key_value ( self ) : [EOL] tests = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] for source , expected in tests : [EOL] self . assertEqual ( program_from_source ( source ) . to_code ( ) , expected ) [EOL] [EOL] def test_parsing_index_expressions ( self ) : [EOL] program = program_from_source ( [string] ) [EOL] [EOL] statement = program . statements [ [number] ] [EOL] self . assertIs ( type ( statement ) , ast . ExpressionStatement ) [EOL] self . assertIs ( type ( statement . expression ) , ast . IndexExpression ) [EOL] self . assertIs ( statement . expression . index . value , [number] ) [EOL] [EOL] [EOL] def program_from_source ( source ) : [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] parser = Parser ( lexer ) [EOL] program = parser . parse_program ( ) [EOL] [EOL] if len ( parser . errors ) > [number] : [EOL] print ( parser . errors [ [number] ] ) [EOL] [EOL] return program [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal],typing.Tuple[typing_extensions.Literal,typing_extensions.Literal]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import luatopy [EOL] from io import StringIO [EOL] import unittest [EOL] [EOL] from luatopy . lexer import Lexer [EOL] from luatopy . token import TokenType [EOL] [EOL] [EOL] class LexerTest ( unittest . TestCase ) : [EOL] def test_binary_op ( self ) : [EOL] source = [string] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . INT , [string] ) , ( TokenType . PLUS , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . MINUS , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_that_eof_gets_retruned ( self ) : [EOL] source = [string] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_that_tokens_are_created_according_to_source ( self ) : [EOL] source = [string] [EOL] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . IDENTIFIER , [string] ) , ( TokenType . ASSIGN , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . ASSIGN , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . COMMENT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . COMMENT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . EQ , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . ASSIGN , [string] ) , ( TokenType . NIL , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . AND , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . OR , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . NOT , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . LPAREN , [string] ) , ( TokenType . RPAREN , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . COMMA , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . NOT_EQ , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . CONCAT , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . GT , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . GTE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . LT , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . LTE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . ASTERISK , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_bool_tokens ( self ) : [EOL] source = [string] [EOL] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . TRUE , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . ASSIGN , [string] ) , ( TokenType . FALSE , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_if_statement_keywords ( self ) : [EOL] source = [string] [EOL] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . IF , [string] ) , ( TokenType . TRUE , [string] ) , ( TokenType . THEN , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . ELSE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . END , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_function_tokens ( self ) : [EOL] source = [string] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . FUNCTION , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . LPAREN , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . RPAREN , [string] ) , ( TokenType . RETURN , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . END , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_call_tokens ( self ) : [EOL] source = [string] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . IDENTIFIER , [string] ) , ( TokenType . LPAREN , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . COMMA , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . PLUS , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . COMMA , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . RPAREN , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_semicolon_delimiter ( self ) : [EOL] source = [string] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . INT , [string] ) , ( TokenType . SEMICOLON , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_string_type ( self ) : [EOL] source = [string] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . STR , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . STR , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . STR , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . STR , [string] ) , ( TokenType . NEWLINE , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_table_list_declaration ( self ) : [EOL] source = [string] [EOL] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . LBRACE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . COMMA , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . RBRACE , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_identifier_with_num_in_name ( self ) : [EOL] source = [string] [EOL] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . IDENTIFIER , [string] ) , ( TokenType . ASSIGN , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_table_hashmap_declaration ( self ) : [EOL] source = [string] [EOL] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . LBRACE , [string] ) , ( TokenType . IDENTIFIER , [string] ) , ( TokenType . ASSIGN , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . RBRACE , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_table_length_hash_char ( self ) : [EOL] source = [string] [EOL] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . HASH , [string] ) , ( TokenType . LBRACE , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . COMMA , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . RBRACE , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL] [EOL] def test_modulo_operator ( self ) : [EOL] source = [string] [EOL] [EOL] lexer = Lexer ( StringIO ( source ) ) [EOL] [EOL] tokens = [ ( TokenType . INT , [string] ) , ( TokenType . PERCENT , [string] ) , ( TokenType . INT , [string] ) , ( TokenType . EOF , [string] ) , ] [EOL] [EOL] for expected_token in tokens : [EOL] token = lexer . next_token ( ) [EOL] [EOL] self . assertEqual ( expected_token [ [number] ] , token . token_type ) [EOL] self . assertEqual ( expected_token [ [number] ] , token . literal ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.lexer.Lexer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any , Optional [EOL] import builtins [EOL] import typing [EOL] from dataclasses import dataclass , field [EOL] from typing import List , Optional , Dict , Tuple [EOL] [EOL] from . token import Token [EOL] [EOL] [EOL] class Program : [EOL] def __init__ ( self , statements ) : [EOL] self . statements = statements [EOL] [EOL] def to_code ( self ) : [EOL] out = [ x . to_code ( ) for x in self . statements ] [EOL] return [string] . join ( out ) [EOL] [EOL] [EOL] @ dataclass class Node : [EOL] token = ... [EOL] [EOL] def to_code ( self ) : [EOL] pass [EOL] [EOL] [EOL] @ dataclass class Identifier ( Node ) : [EOL] value = ... [EOL] [EOL] def to_code ( self ) : [EOL] return self . value [EOL] [EOL] [EOL] class Statement ( Node ) : [EOL] pass [EOL] [EOL] [EOL] class Expression ( Node ) : [EOL] pass [EOL] [EOL] [EOL] @ dataclass class ReturnStatement ( Statement ) : [EOL] value = ... [EOL] [EOL] def to_code ( self ) : [EOL] return [string] . format ( self . value . to_code ( ) ) [EOL] [EOL] [EOL] @ dataclass class Boolean ( Node ) : [EOL] value = ... [EOL] [EOL] def to_code ( self ) : [EOL] return [string] if self . value else [string] [EOL] [EOL] [EOL] @ dataclass class AssignStatement ( Statement ) : [EOL] name = ... [EOL] value = ... [EOL] [EOL] def to_code ( self ) : [EOL] return [string] . format ( self . name . value , self . value . to_code ( ) ) [EOL] [EOL] [EOL] @ dataclass class ExpressionStatement ( Statement ) : [EOL] expression = ... [EOL] [EOL] def to_code ( self ) : [EOL] if not self . expression : [EOL] return [string] [EOL] return self . expression . to_code ( ) [EOL] [EOL] [EOL] @ dataclass class IntegerLiteral ( Node ) : [EOL] value = ... [EOL] [EOL] def to_code ( self ) : [EOL] return str ( self . value ) [EOL] [EOL] [EOL] @ dataclass class StringLiteral ( Node ) : [EOL] value = ... [EOL] [EOL] def to_code ( self ) : [EOL] return [string] . format ( self . value ) [EOL] [EOL] [EOL] @ dataclass class PrefixExpression ( Expression ) : [EOL] right = ... [EOL] operator = ... [EOL] [EOL] def to_code ( self ) : [EOL] if len ( self . operator ) > [number] : [EOL] return [string] . format ( self . operator , self . right . to_code ( ) ) [EOL] return [string] . format ( self . operator , self . right . to_code ( ) ) [EOL] [EOL] [EOL] @ dataclass class InfixExpression ( Expression ) : [EOL] left = ... [EOL] operator = ... [EOL] right = ... [EOL] [EOL] def to_code ( self ) : [EOL] return [string] . format ( self . left . to_code ( ) , self . operator , self . right . to_code ( ) ) [EOL] [EOL] [EOL] @ dataclass class BlockStatement ( Statement ) : [EOL] statements = field ( default_factory = list ) [EOL] [EOL] def to_code ( self ) : [EOL] out = [ x . to_code ( ) for x in self . statements ] [EOL] return [string] . join ( out ) [EOL] [EOL] [EOL] @ dataclass class IfExpression ( Expression ) : [EOL] condition = ... [EOL] consequence = ... [EOL] alternative = ... [EOL] [EOL] def to_code ( self ) : [EOL] out = [string] . format ( self . condition . to_code ( ) ) [EOL] out = out + self . consequence . to_code ( ) [EOL] if self . alternative : [EOL] out = out + [string] [EOL] out = out + self . alternative . to_code ( ) [EOL] out = out + [string] [EOL] return out [EOL] [EOL] [EOL] @ dataclass class FunctionLiteral ( Node ) : [EOL] body = ... [EOL] parameters = field ( default_factory = list ) [EOL] name = None [EOL] [EOL] def to_code ( self ) : [EOL] signature = [string] . join ( [ x . value for x in self . parameters ] ) [EOL] [EOL] if self . name : [EOL] out = [string] . format ( self . name . value , signature ) [EOL] else : [EOL] out = [string] . format ( signature ) [EOL] [EOL] body_code = self . body . to_code ( ) . strip ( ) [EOL] if body_code : [EOL] out = out + body_code + [string] [EOL] return out + [string] [EOL] [EOL] [EOL] @ dataclass class CallExpression ( Expression ) : [EOL] function = ... [EOL] arguments = ... [EOL] [EOL] def to_code ( self ) : [EOL] out = [string] . format ( self . function . to_code ( ) , [string] . join ( [ x . to_code ( ) for x in self . arguments ] ) , ) [EOL] return out [EOL] [EOL] [EOL] @ dataclass class TableLiteral ( Expression ) : [EOL] elements = ... [EOL] [EOL] def to_code ( self ) : [EOL] out = [string] [EOL] [EOL] items = [ ] [EOL] for key , value in self . elements : [EOL] key_code = key . to_code ( ) [EOL] items . append ( f"{ key_code } [string] { value . to_code ( ) }" ) [EOL] [EOL] out = out + [string] . join ( x for x in items ) [EOL] out = out + [string] [EOL] return out [EOL] [EOL] [EOL] @ dataclass class IndexExpression ( Expression ) : [EOL] left = ... [EOL] index = ... [EOL] [EOL] def to_code ( self ) : [EOL] return [string] . format ( self . left . to_code ( ) , self . index . to_code ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $token.Token$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Expression$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Identifier$ 0 0 0 $Node$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Expression$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 $builtins.str$ 0 0 0 $Node$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Node]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Expression$ 0 0 0 $BlockStatement$ 0 0 0 $BlockStatement$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $BlockStatement$ 0 0 0 $typing.List[Identifier]$ 0 0 0 0 0 0 0 0 $typing.Optional[Identifier]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Node$ 0 0 0 $typing.List[Expression]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[Expression,Expression]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $Expression$ 0 0 0 $Expression$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , List , Any , Optional [EOL] import builtins [EOL] import typing [EOL] import luatopy [EOL] from typing import Any , Dict , Optional , List [EOL] [EOL] from luatopy import obj [EOL] from luatopy . obj import TRUE , FALSE , NULL [EOL] [EOL] [EOL] builtins = { } [EOL] [EOL] [EOL] def register ( store , name , fn ) : [EOL] store [ name ] = obj . Builtin ( fn = fn ) [EOL] return store [EOL] [EOL] [EOL] def builtin_type ( * args ) : [EOL] if len ( args ) == [number] : [EOL] return obj . Error . create ( [string] ) [EOL] [EOL] value = args [ [number] ] [EOL] value_type = None [EOL] if type ( value ) == obj . String : [EOL] value_type = [string] [EOL] if type ( value ) == obj . Integer : [EOL] value_type = [string] [EOL] if type ( value ) == obj . Boolean : [EOL] value_type = [string] [EOL] if type ( value ) == obj . Table : [EOL] value_type = [string] [EOL] if type ( value ) == obj . Function : [EOL] value_type = [string] [EOL] [EOL] if not value_type : [EOL] return NULL [EOL] return obj . String ( value = value_type ) [EOL] [EOL] [EOL] builtins = register ( builtins , [string] , builtin_type ) [EOL] [EOL] [EOL] def builtin_print ( * args ) : [EOL] out = [ x . inspect ( ) for x in args ] [EOL] print ( [string] . join ( out ) ) [EOL] return NULL [EOL] [EOL] [EOL] builtins = register ( builtins , [string] , builtin_print ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0
from typing import Tuple , List , Type , Dict , Any [EOL] import obj [EOL] import typing [EOL] import builtins [EOL] import ast [EOL] import luatopy [EOL] from typing import cast , Optional , List , Tuple , Dict [EOL] [EOL] from . import ast [EOL] from . import obj [EOL] from luatopy . builtins import builtins [EOL] [EOL] from . obj import TRUE , FALSE , NULL [EOL] [EOL] [EOL] def evaluate ( node , env ) : [EOL] klass = type ( node ) [EOL] [EOL] if klass == ast . Program : [EOL] program = cast ( ast . Program , node ) [EOL] return evaluate_program ( program , env ) [EOL] [EOL] if klass == ast . ExpressionStatement : [EOL] exp = cast ( ast . ExpressionStatement , node ) [EOL] return evaluate ( exp . expression , env ) [EOL] [EOL] if klass == ast . IntegerLiteral : [EOL] integer_literal = cast ( ast . IntegerLiteral , node ) [EOL] return obj . Integer ( value = integer_literal . value ) [EOL] [EOL] if klass == ast . StringLiteral : [EOL] string_literal = cast ( ast . StringLiteral , node ) [EOL] return obj . String ( value = string_literal . value ) [EOL] [EOL] if klass == ast . Boolean : [EOL] boolean = cast ( ast . Boolean , node ) [EOL] return native_bool_to_bool_obj ( boolean . value ) [EOL] [EOL] if klass == ast . PrefixExpression : [EOL] prefix_exp = cast ( ast . PrefixExpression , node ) [EOL] prefix_right = evaluate ( prefix_exp . right , env ) [EOL] [EOL] if is_error ( prefix_right ) : [EOL] return prefix_right [EOL] [EOL] return evaluate_prefix_expression ( prefix_exp . operator , prefix_right ) [EOL] [EOL] if klass == ast . InfixExpression : [EOL] infix_exp = cast ( ast . InfixExpression , node ) [EOL] [EOL] infix_left = evaluate ( infix_exp . left , env ) [EOL] if is_error ( infix_left ) : [EOL] return infix_left [EOL] [EOL] infix_right = evaluate ( infix_exp . right , env ) [EOL] if is_error ( infix_right ) : [EOL] return infix_right [EOL] [EOL] return evaluate_infix_expression ( infix_exp . operator , infix_left , infix_right ) [EOL] [EOL] if klass == ast . BlockStatement : [EOL] block_statement = cast ( ast . BlockStatement , node ) [EOL] return evaluate_block_statement ( block_statement , env ) [EOL] [EOL] if klass == ast . IfExpression : [EOL] if_exp = cast ( ast . IfExpression , node ) [EOL] return eval_if_expression ( if_exp , env ) [EOL] [EOL] if klass == ast . ReturnStatement : [EOL] return_statement = cast ( ast . ReturnStatement , node ) [EOL] return_value = evaluate ( return_statement . value , env ) [EOL] if is_error ( return_value ) : [EOL] return return_value [EOL] return obj . ReturnValue ( return_value ) [EOL] [EOL] if klass == ast . AssignStatement : [EOL] assignment = cast ( ast . AssignStatement , node ) [EOL] assignment_value = evaluate ( assignment . value , env ) [EOL] [EOL] if is_error ( assignment_value ) : [EOL] return assignment_value [EOL] env . set ( assignment . name . value , assignment_value ) [EOL] return None [EOL] [EOL] if klass == ast . Identifier : [EOL] identifier = cast ( ast . Identifier , node ) [EOL] return evaluate_identifier ( identifier , env ) [EOL] [EOL] if klass == ast . FunctionLiteral : [EOL] fn_literal = cast ( ast . FunctionLiteral , node ) [EOL] [EOL] if fn_literal . name : [EOL] funct_assignment = obj . Function ( body = fn_literal . body , parameters = fn_literal . parameters , env = env ) [EOL] env . set ( fn_literal . name . value , funct_assignment ) [EOL] return None [EOL] [EOL] return obj . Function ( body = fn_literal . body , parameters = fn_literal . parameters , env = env ) [EOL] [EOL] if klass == ast . CallExpression : [EOL] call_exp = cast ( ast . CallExpression , node ) [EOL] fn_obj = evaluate ( call_exp . function , env ) [EOL] [EOL] if is_error ( fn_obj ) : [EOL] return fn_obj [EOL] [EOL] fn = cast ( obj . Function , fn_obj ) [EOL] args = evaluate_expressions ( call_exp . arguments , env ) [EOL] if len ( args ) > [number] and is_error ( args [ [number] ] ) : [EOL] return args [ [number] ] [EOL] [EOL] return apply_function ( fn , args , env ) [EOL] [EOL] if klass == ast . TableLiteral : [EOL] table_literal = cast ( ast . TableLiteral , node ) [EOL] elements = evaluate_expression_pairs ( table_literal . elements , env ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] return obj . Table ( elements = elements ) [EOL] [EOL] if klass == ast . IndexExpression : [EOL] index_expression = cast ( ast . IndexExpression , node ) [EOL] left = evaluate ( index_expression . left , env ) [EOL] if is_error ( left ) : [EOL] return left [EOL] [EOL] index = evaluate ( index_expression . index , env ) [EOL] if is_error ( index ) : [EOL] return index [EOL] [EOL] return evaluate_index_expression ( left , index ) [EOL] [EOL] return None [EOL] [EOL] [EOL] def evaluate_index_expression ( left , index ) : [EOL] if left . type ( ) == obj . ObjType . TABLE and index . type ( ) == obj . ObjType . INTEGER : [EOL] return evaluate_table_index_expression ( cast ( obj . Table , left ) , cast ( obj . Integer , index ) ) [EOL] if left . type ( ) == obj . ObjType . TABLE and index . type ( ) == obj . ObjType . STRING : [EOL] return evaluate_table_key_expression ( cast ( obj . Table , left ) , cast ( obj . String , index ) ) [EOL] [EOL] return obj . Error . create ( [string] ) [EOL] [EOL] [EOL] def evaluate_table_index_expression ( table , index ) : [EOL] try : [EOL] return table . elements [ index ] [EOL] except : [EOL] return NULL [EOL] [EOL] [EOL] def evaluate_table_key_expression ( table , index ) : [EOL] index_value = index . value [EOL] try : [EOL] return table . elements [ index ] [EOL] except : [EOL] return NULL [EOL] [EOL] [EOL] def apply_function ( fn , args , env ) : [EOL] if type ( fn ) == obj . Function : [EOL] fn_fn = cast ( obj . Function , fn ) [EOL] extended_env = extend_function_env ( fn_fn , args ) [EOL] evaluated = evaluate ( fn_fn . body , extended_env ) [EOL] return unwrap_return_value ( evaluated ) [EOL] [EOL] if type ( fn ) == obj . Builtin : [EOL] builtin_fn = cast ( obj . Builtin , fn ) [EOL] return builtin_fn . fn ( * args ) [EOL] [EOL] return obj . Error . create ( [string] , fn . type ( ) ) [EOL] [EOL] [EOL] def unwrap_return_value ( value ) : [EOL] if type ( value ) == obj . ReturnValue : [EOL] return_value = cast ( obj . ReturnValue , value ) [EOL] return return_value . value [EOL] return value [EOL] [EOL] [EOL] def extend_function_env ( fn , args ) : [EOL] enclosed_env = obj . Environment . create_enclosed ( fn . env ) [EOL] [EOL] param = ... [EOL] for index , param in enumerate ( fn . parameters ) : [EOL] enclosed_env . set ( param . value , args [ index ] ) [EOL] return enclosed_env [EOL] [EOL] [EOL] def evaluate_expressions ( expressions , env ) : [EOL] result = [ ] [EOL] [EOL] for exp in expressions : [EOL] evaluated = evaluate ( exp , env ) [EOL] if is_error ( evaluated ) : [EOL] return [ evaluated ] [EOL] [EOL] result . append ( evaluated ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def evaluate_expression_pairs ( expressions , env , ) : [EOL] out = { } [EOL] for key_exp , val_exp in expressions : [EOL] key = evaluate ( key_exp , env ) [EOL] value = evaluate ( val_exp , env ) [EOL] out [ key ] = value [EOL] [EOL] return out [EOL] [EOL] [EOL] def evaluate_identifier ( identifier , env ) : [EOL] val , found = env . get ( identifier . value , NULL ) [EOL] if found : [EOL] return val [EOL] [EOL] if identifier . value in builtins : [EOL] return builtins [ identifier . value ] [EOL] [EOL] return NULL [EOL] [EOL] [EOL] def evaluate_program ( program , env ) : [EOL] result = None [EOL] for statement in program . statements : [EOL] result = evaluate ( statement , env ) [EOL] [EOL] if type ( result ) == obj . ReturnValue : [EOL] return_value = cast ( obj . ReturnValue , result ) [EOL] return return_value . value [EOL] if type ( result ) == obj . Error : [EOL] return result [EOL] [EOL] return result [EOL] [EOL] [EOL] def evaluate_block_statement ( block_statement , env ) : [EOL] result = None [EOL] for statement in block_statement . statements : [EOL] result = evaluate ( statement , env ) [EOL] if result != None : [EOL] if result . type ( ) in [ obj . ObjType . RETURN , obj . ObjType . ERROR ] : [EOL] return result [EOL] [EOL] return result [EOL] [EOL] [EOL] def eval_if_expression ( if_exp , env ) : [EOL] condition = evaluate ( if_exp . condition , env ) [EOL] [EOL] if is_error ( condition ) : [EOL] return condition [EOL] [EOL] if is_truthy ( condition ) : [EOL] return evaluate ( if_exp . consequence , env ) [EOL] elif if_exp . alternative : [EOL] return evaluate ( if_exp . alternative , env ) [EOL] [EOL] return NULL [EOL] [EOL] [EOL] def is_truthy ( obj ) : [EOL] if obj == NULL : [EOL] return False [EOL] if obj == TRUE : [EOL] return True [EOL] if obj == FALSE : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def evaluate_statements ( statements , env ) : [EOL] result = None [EOL] for statement in statements : [EOL] result = evaluate ( statement , env ) [EOL] [EOL] if type ( result ) == obj . ReturnValue : [EOL] return_value = cast ( obj . ReturnValue , result ) [EOL] return return_value . value [EOL] [EOL] return result [EOL] [EOL] [EOL] def evaluate_prefix_expression ( operator , right ) : [EOL] if operator == [string] : [EOL] return evaluate_not_operator_expression ( right ) [EOL] if operator == [string] : [EOL] return evaluate_minus_operator_expression ( right ) [EOL] if operator == [string] : [EOL] return evaluate_length_operator_expression ( right ) [EOL] [EOL] return obj . Error . create ( [string] , operator , right . inspect ( ) ) [EOL] [EOL] [EOL] def evaluate_not_operator_expression ( right ) : [EOL] if right == TRUE : [EOL] return FALSE [EOL] if right == FALSE : [EOL] return TRUE [EOL] if right == NULL : [EOL] return TRUE [EOL] return FALSE [EOL] [EOL] [EOL] def evaluate_minus_operator_expression ( right ) : [EOL] if right . type ( ) == obj . ObjType . BOOLEAN : [EOL] return obj . Error . create ( [string] ) [EOL] [EOL] if type ( right ) != obj . Integer : [EOL] return NULL [EOL] [EOL] obj_int = cast ( obj . Integer , right ) [EOL] return obj . Integer ( value = [number] - obj_int . value ) [EOL] [EOL] [EOL] def evaluate_length_operator_expression ( right ) : [EOL] if right . type ( ) == obj . ObjType . STRING : [EOL] return obj . Integer ( len ( right . value ) ) [EOL] if right . type ( ) == obj . ObjType . TABLE : [EOL] length = [number] [EOL] while True : [EOL] try : [EOL] right . elements [ obj . Integer ( value = length ) ] [EOL] length = length + [number] [EOL] except : [EOL] break [EOL] [EOL] return obj . Integer ( length - [number] ) [EOL] return NULL [EOL] [EOL] [EOL] def evaluate_infix_expression ( operator , left , right ) : [EOL] if type ( left ) == obj . Integer and type ( right ) == obj . Integer : [EOL] left_val = cast ( obj . Integer , left ) [EOL] right_val = cast ( obj . Integer , right ) [EOL] return evaluate_infix_integer_expression ( operator , left_val , right_val ) [EOL] [EOL] if type ( left ) == obj . String and type ( right ) == obj . String : [EOL] left_str_val = cast ( obj . String , left ) [EOL] right_str_val = cast ( obj . String , right ) [EOL] return evaluate_infix_string_expression ( operator , left_str_val , right_str_val ) [EOL] [EOL] if obj . ObjType . BOOLEAN in [ left . type ( ) , right . type ( ) ] and operator in [ [string] , [string] , [string] , [string] , ] : [EOL] return obj . Error . create ( [string] ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left == right ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left != right ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left . value and right . value ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left . value or right . value ) [EOL] [EOL] return obj . Error . create ( [string] , operator ) [EOL] [EOL] [EOL] def evaluate_infix_string_expression ( operator , left , right ) : [EOL] if operator == [string] : [EOL] return obj . String ( left . value + right . value ) [EOL] return NULL [EOL] [EOL] [EOL] def evaluate_infix_integer_expression ( operator , left , right ) : [EOL] if operator == [string] : [EOL] return obj . Integer ( left . value + right . value ) [EOL] [EOL] if operator == [string] : [EOL] return obj . Integer ( left . value - right . value ) [EOL] [EOL] if operator == [string] : [EOL] return obj . Integer ( left . value * right . value ) [EOL] [EOL] if operator == [string] : [EOL] return obj . Float ( left . value / right . value ) [EOL] [EOL] if operator == [string] : [EOL] return obj . Float ( left . value % right . value ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left . value > right . value ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left . value >= right . value ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left . value < right . value ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left . value <= right . value ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left . value == right . value ) [EOL] [EOL] if operator == [string] : [EOL] return native_bool_to_bool_obj ( left . value != right . value ) [EOL] [EOL] return NULL [EOL] [EOL] [EOL] def native_bool_to_bool_obj ( value ) : [EOL] return TRUE if value else FALSE [EOL] [EOL] [EOL] def is_error ( instance ) : [EOL] if instance == None : [EOL] return False [EOL] [EOL] return instance . type ( ) == obj . ObjType . ERROR [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $obj.Boolean$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $obj.Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $obj.Boolean$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Dict , Optional [EOL] import builtins [EOL] import typing [EOL] import luatopy [EOL] from dataclasses import dataclass , field [EOL] from typing import Any , Dict , Tuple , List , Optional , Callable [EOL] from mypy_extensions import VarArg [EOL] from enum import Enum , auto [EOL] [EOL] from luatopy import ast [EOL] [EOL] [EOL] class ObjType ( Enum ) : [EOL] INTEGER = auto ( ) [EOL] FLOAT = auto ( ) [EOL] BOOLEAN = auto ( ) [EOL] NULL = auto ( ) [EOL] RETURN = auto ( ) [EOL] ERROR = auto ( ) [EOL] FUNCTION = auto ( ) [EOL] STRING = auto ( ) [EOL] BUILTIN = auto ( ) [EOL] TABLE = auto ( ) [EOL] [EOL] [EOL] class Obj : [EOL] def type ( self ) : [EOL] pass [EOL] [EOL] def inspect ( self ) : [EOL] pass [EOL] [EOL] [EOL] class Environment : [EOL] def __init__ ( self , outer = None ) : [EOL] self . store = { } [EOL] self . outer = outer [EOL] [EOL] def get ( self , name , default ) : [EOL] val = self . store . get ( name , default ) [EOL] found = self . contains ( name ) [EOL] [EOL] if not found and self . outer : [EOL] return self . outer . get ( name , default ) [EOL] [EOL] return ( val , found ) [EOL] [EOL] def contains ( self , name ) : [EOL] return name in self . store [EOL] [EOL] def set ( self , name , value ) : [EOL] self . store [ name ] = value [EOL] return value [EOL] [EOL] def __str__ ( self ) : [EOL] combined = self . store [EOL] if self . outer : [EOL] combined = { ** self . outer . store , ** self . store } [EOL] return str ( combined ) [EOL] [EOL] @ staticmethod def create_enclosed ( outer ) : [EOL] return Environment ( outer = outer ) [EOL] [EOL] [EOL] @ dataclass class Integer ( Obj ) : [EOL] value = [number] [EOL] [EOL] def type ( self ) : [EOL] return ObjType . INTEGER [EOL] [EOL] def inspect ( self ) : [EOL] return str ( self . value ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . value ) [EOL] [EOL] [EOL] @ dataclass class Float ( Obj ) : [EOL] value = [number] [EOL] [EOL] def type ( self ) : [EOL] return ObjType . FLOAT [EOL] [EOL] def inspect ( self ) : [EOL] return str ( self . value ) [EOL] [EOL] [EOL] @ dataclass class Boolean ( Obj ) : [EOL] value = False [EOL] [EOL] def type ( self ) : [EOL] return ObjType . BOOLEAN [EOL] [EOL] def inspect ( self ) : [EOL] return [string] if self . value else [string] [EOL] [EOL] [EOL] class Null ( Obj ) : [EOL] def type ( self ) : [EOL] return ObjType . NULL [EOL] [EOL] def inspect ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] @ dataclass class ReturnValue ( Obj ) : [EOL] value = ... [EOL] [EOL] def type ( self ) : [EOL] return ObjType . RETURN [EOL] [EOL] def inspect ( self ) : [EOL] return self . value . inspect ( ) [EOL] [EOL] [EOL] @ dataclass class Error ( Obj ) : [EOL] message = ... [EOL] [EOL] @ staticmethod def create ( str_format , * args ) : [EOL] return Error ( message = str_format . format ( * args ) ) [EOL] [EOL] def type ( self ) : [EOL] return ObjType . ERROR [EOL] [EOL] def inspect ( self ) : [EOL] return [string] . format ( self . message ) [EOL] [EOL] [EOL] @ dataclass class Function ( Obj ) : [EOL] body = ... [EOL] env = ... [EOL] parameters = field ( default_factory = list ) [EOL] [EOL] def type ( self ) : [EOL] return ObjType . FUNCTION [EOL] [EOL] def inspect ( self ) : [EOL] out = [string] [EOL] signature = [string] . join ( [ x . value for x in self . parameters ] ) [EOL] [EOL] out = [string] . format ( signature ) [EOL] out = out + self . body . to_code ( ) [EOL] out = out + [string] [EOL] return out [EOL] [EOL] [EOL] @ dataclass class String ( Obj ) : [EOL] value = [string] [EOL] [EOL] def type ( self ) : [EOL] return ObjType . STRING [EOL] [EOL] def inspect ( self ) : [EOL] return self . value [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . value ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ dataclass class Builtin ( Obj ) : [EOL] fn = ... [EOL] [EOL] def type ( self ) : [EOL] return ObjType . BUILTIN [EOL] [EOL] def inspect ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] @ dataclass class Table ( Obj ) : [EOL] elements = ... [EOL] [EOL] def type ( self ) : [EOL] return ObjType . TABLE [EOL] [EOL] def inspect ( self ) : [EOL] pairs_signature = [string] . join ( [ f"{ x [ [number] ] . inspect ( ) } [string] { x [ [number] ] . inspect ( ) }" for x in self . elements . items ( ) ] ) [EOL] [EOL] out = [string] [EOL] out = out + pairs_signature [EOL] out = out + [string] [EOL] return out [EOL] [EOL] [EOL] TRUE = Boolean ( value = True ) [EOL] FALSE = Boolean ( value = False ) [EOL] NULL = Null ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional["Environment"]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Obj]$ 0 0 0 0 0 0 $typing.Optional["Environment"]$ 0 $typing.Optional["Environment"]$ 0 0 0 $typing.Tuple[Obj,builtins.bool]$ 0 0 0 $builtins.str$ 0 $Obj$ 0 0 0 $luatopy.obj.Obj$ 0 0 0 0 0 0 0 $builtins.str$ 0 $Obj$ 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $Obj$ 0 0 0 0 0 $luatopy.obj.Obj$ 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $Obj$ 0 0 0 $builtins.str$ 0 $Obj$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $Obj$ 0 0 $Obj$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Environment"$ 0 $"Environment"$ 0 0 0 0 0 0 $"Environment"$ 0 $"Environment"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Obj$ 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $luatopy.ast.BlockStatement$ 0 0 0 $Environment$ 0 0 0 $typing.List[luatopy.ast.Identifier]$ 0 0 0 0 0 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[mypy_extensions.VarArg],Obj]$ 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[Obj,Obj]$ 0 0 0 0 0 $ObjType$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0